<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Phone Chat 模拟器</title>
    <script src="https://cdn.jsdelivr.net/npm/dexie/dist/dexie.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@400;500;600;700&family=Comic+Neue:wght@400;700&family=Fredoka+One&family=Nunito:wght@400;500;600;700&family=Montserrat:wght@400;500;600&family=Inter:wght@400;500;600&family=Roboto:wght@400;500&family=Raleway:wght@400;500;600&family=Lato:wght@400;700&family=Poppins:wght@400;500;600&family=Quicksand:wght@400;500;600&family=Varela+Round&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
    <div id="phone-frame">
    <div id="phone-screen">
        <div class="wallpaper" id="wallpaper-element">
            <!-- 主屏幕状态栏 -->
            <div id="status-bar">
                <span id="status-bar-time">14:25</span>
                <div id="status-bar-battery" class="battery-container">
                    <span class="battery-text">ᰔᩚ</span>
                    <div class="battery-icon">
                        <div class="battery-level"></div>
                    </div>
                </div>
            </div>
            
            <!-- 时钟容器 -->
            <div id="clock-container">
                <div id="main-time">14:25</div>
                <div id="main-date">12月18日 星期一</div>
            </div>
            
            <div id="worldbook-screen" class="app-screen">
                <div class="app-status-bar">
                    <div class="app-status-time"></div>
                    <div class="app-battery-container">
                        <span class="battery-text">ᰔᩚ</span>
                        <div class="app-battery-icon">
                            <div class="app-battery-level"></div>
                        </div>
                    </div>
                </div>
                <div class="app-header">
                    <button class="back-button" onclick="hideApp('worldbook-screen')">‹</button>
                    <div class="app-title">世界书</div>
                    <div class="add-worldbook-btn worldbook-add-btn" onclick="onWorldbookAddClick()">
                        <i class="fas fa-plus"></i>
                    </div>
                </div>

                <div class="app-content">
                    <div id="global-worldbooks-content" class="worldbook-content-pane">
                        </div>
                    <div id="local-worldbooks-content" class="worldbook-content-pane" style="display: none;">
                        </div>
                </div>

                <div class="worldbook-tabs">
                    <div class="worldbook-tab active" onclick="switchWorldbookTab('global')">
                        <i class="fas fa-globe-asia"></i>
                        <span>全局设定</span>
                    </div>
                    <div class="worldbook-tab" onclick="switchWorldbookTab('local')">
                        <i class="fas fa-comment-dots"></i>
                        <span>局部设定</span>
                    </div>
                </div>
            </div>
                
                <!-- 应用图标 -->
                <div id="app-grid">
                    <div class="app-row">
                        <a href="#" class="app" onclick="showApp('chat-screen')">
                            <div class="app-icon">
                                <img src="https://i.postimg.cc/dVSd9QBz/IMG-3063.jpg" alt="Chat" class="app-icon-img">
                            </div>
                            <span>Chat</span>
                        </a>
                        <a href="#" class="app" onclick="showApp('worldbook-screen'); switchWorldbookTab('global');">
                            <div class="app-icon">
                                <img src="https://i.postimg.cc/Xqz3zPz7/IMG-3080.jpg" alt="世界书" class="app-icon-img">
                            </div>
                            <span>世界书</span>
                        </a>
                        <a href="#" class="app" onclick="showApp('settings-screen')">
                            <div class="app-icon">
                                <img src="https://i.postimg.cc/764L3jpF/IMG-3079.jpg" alt="设置" class="app-icon-img">
                            </div>
                            <span>设置</span>
                        </a>
                    </div>
                    <div class="app-row">
                                        <a href="#" class="app" onclick="showApp('game-screen')">
                            <div class="app-icon">
                        <i class="fas fa-gamepad"></i>
                            </div>
                    <span>游戏</span>
                        </a>
                        <a href="#" class="app" onclick="showApp('music-screen')">
                            <div class="app-icon">
                                <i class="fas fa-music"></i>
                            </div>
                            <span>音乐</span>
                        </a>
                                        <a href="#" class="app" onclick="showApp('forum-screen')">
                            <div class="app-icon">
                        <i class="fas fa-comments"></i>
                            </div>
                    <span>论坛</span>
                        </a>
                    </div>
                </div>

                
                <!-- 聊天界面 -->
                <div id="chat-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('chat-screen')">‹</button>
                        <div class="app-title">💬</div>
                        <div class="chat-header-actions">
                            <div id="add-contact-btn" class="add-btn" onclick="showCharacterForm()">
                                <i class="fas fa-plus"></i>
                            </div>
                            <div id="add-chat-btn" class="add-btn" onclick="showChatOptions()">
                                <i class="fas fa-plus"></i>
                            </div>
                        </div>
                    </div>
                    
                    <div class="app-content" id="chat-content">
                        <!-- 默认显示消息列表 -->
                        <div class="message-list" id="message-list">
                            <!-- 消息列表将通过JS动态生成 -->
                        </div>
                        
                        <!-- 通讯录 -->
                        <div class="contact-list hide" id="contact-list">
                            <div class="contact-section">
        
                                <!-- 联系人列表将通过JS动态生成 -->
                            </div>

                        </div>
                        
                        <!-- 动态页面 -->
                        <div class="moments-page hide moments-page-no-padding" id="moments-page">
                            <div class="moments-header">
                                <div class="moments-cover" onclick="changeCoverImage()">
                                    <div class="cover-image-placeholder" id="cover-placeholder">
                                        <div class="cover-placeholder-text">点击更换封面</div>
                                        </div>
                                    <img class="cover-image hide" id="cover-image" src="">
                                    </div>
                                
                                <!-- 用户名，独立放置在头像左上角 -->
                                <div class="moments-username" onclick="changeUsername(event)" id="moments-username">用户</div>
                                
                                <!-- 独立的头像，跨越背景和动态列表区域，放在header外面 -->
                                <div class="moments-avatar" onclick="changeAvatarImage(event)" id="moments-avatar">
                                    <i class="fas fa-user moments-avatar-icon"></i>
                                </div>
                            </div>
                            
                            <div class="moments-list" id="moments-list">
                                <!-- 动态列表将通过JS动态生成 -->
                            </div>
                            

                        </div>

                        
                        <!-- 面具区域 -->
                        <div class="profile-page hide" id="profile-page">
                            <div class="persona-header">
                                <div class="persona-title">
                                    <h2>我的面具</h2>
                                    <p>管理你的多重身份设定</p>
                                </div>
                                <div class="add-persona-btn persona-add-btn" onclick="showPersonaForm()">
                                    <i class="fas fa-plus"></i>
                                </div>
                            </div>
                            
                            <div class="persona-list" id="persona-list">
                                <!-- 面具列表将通过JS动态生成 -->
                            </div>
                            

                        </div>
                    </div>
                    
                    <div class="chat-tabs">
                        <div class="chat-tab active" onclick="switchChatTab('message-list')" id="message-tab">
                            <i class="fas fa-comment-alt"></i>
                            <span>消息</span>
                        </div>
                        <div class="chat-tab" onclick="switchChatTab('contact-list')">
                            <i class="fas fa-address-book"></i>
                            <span>角色</span>
                        </div>
                        <div class="chat-tab" onclick="switchChatTab('moments-page')">
                            <i class="fas fa-circle-notch"></i>
                            <span>动态</span>
                        </div>
                        <div class="chat-tab" onclick="switchChatTab('profile-page')">
                            <i class="fas fa-masks-theater"></i>
                            <span>我</span>
                        </div>
                    </div>
                </div>
                
                <!-- 发布动态界面 -->
                <div id="publish-moment-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hidePublishMoment()">‹</button>
                        <div class="app-title">发表动态</div>
                        <button class="publish-btn" onclick="publishMoment()">发表</button>
                    </div>
                    <div class="app-content">
                        <div class="publish-moment-form">
                            <!-- 文字输入区域 -->
                            <div class="moment-text-input">
                                <textarea 
                                    id="moment-text" 
                                    placeholder="分享新鲜事..." 
                                    class="moment-textarea"
                                    maxlength="500"
                                    oninput="updateTextCount()"></textarea>
                                <div class="text-count" id="text-count">0/500</div>
                            </div>
                            
                            <!-- 图片上传区域 -->
                            <div class="moment-images-section">
                                <div class="moment-images-grid" id="moment-images-grid">
                                    <!-- 动态添加的图片预览 -->
                                </div>
                                <div class="add-image-btn" onclick="addMomentImage()">
                                    <i class="fas fa-plus"></i>
                                    <span>添加图片</span>
                                </div>
                            </div>
                            
                            <!-- 发布选项 -->
                            <div class="publish-options">
                                <div class="option-item">
                                    <i class="fas fa-map-marker-alt"></i>
                                    <span>所在位置</span>
                                    <i class="fas fa-chevron-right"></i>
                                </div>
                                <div class="option-item">
                                    <i class="fas fa-users"></i>
                                    <span>提醒谁看</span>
                                    <i class="fas fa-chevron-right"></i>
                                </div>
                                <div class="option-item">
                                    <i class="fas fa-eye"></i>
                                    <span>谁可以看</span>
                                    <span class="option-value">公开</span>
                                    <i class="fas fa-chevron-right"></i>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 论坛界面 -->
                <div id="forum-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('forum-screen')">‹</button>
                        <div class="app-title">论坛</div>
                    </div>
                    <div class="app-content">
                        <div class="forum-categories">
                            <div class="forum-category">
                                <div class="category-icon">
                                    <i class="fas fa-fire"></i>
                                </div>
                                <div class="category-info">
                                    <div class="category-name">热门话题</div>
                                    <div class="category-desc">最受欢迎的讨论</div>
                            </div>
                                <div class="category-count">128</div>
                            </div>
                            <div class="forum-category">
                                <div class="category-icon">
                                    <i class="fas fa-gamepad"></i>
                            </div>
                                <div class="category-info">
                                    <div class="category-name">游戏讨论</div>
                                    <div class="category-desc">分享游戏心得</div>
                                </div>
                                <div class="category-count">89</div>
                                </div>
                            <div class="forum-category">
                                <div class="category-icon">
                                    <i class="fas fa-heart"></i>
                                </div>
                                <div class="category-info">
                                    <div class="category-name">角色互动</div>
                                    <div class="category-desc">与AI角色的故事</div>
                                </div>
                                <div class="category-count">256</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 世界书编辑表单 -->
                <div id="worldbook-form-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideWorldbookForm()">‹</button>
                        <div class="app-title" id="worldbook-form-title">新建世界书</div>
                        <button class="save-worldbook-btn save-btn-absolute" onclick="saveWorldbook()">保存</button>
                    </div>
                    <div class="app-content">
                        <div class="worldbook-form">
                            <div class="form-group">
                                <label class="form-label">标题</label>
                                <input type="text" id="worldbook-title" class="form-input" placeholder="请输入世界书标题">
                            </div>
                            <div class="form-group">
                                <label class="form-label">内容</label>
                                <textarea id="worldbook-content" class="form-textarea textarea-large" placeholder="请输入世界书内容，这里可以描述角色背景、世界观设定等..."></textarea>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 音乐应用界面 -->
                <div id="music-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('music-screen')">‹</button>
                        <div class="app-title">音乐</div>
                    </div>
                    <div class="app-content">
                        <div class="music-player">
                            <div class="now-playing">
                                <div class="album-cover" id="album-cover">
                                    <i class="fas fa-music"></i>
                                </div>
                                <div class="song-info">
                                    <div class="song-title" id="song-title">选择一首歌曲</div>
                                    <div class="artist-name" id="artist-name">未知艺术家</div>
                                </div>
                            </div>
                            
                            <div class="progress-container">
                                <div class="progress-bar">
                                    <div class="progress" id="progress"></div>
                                </div>
                                <div class="time-info">
                                    <span id="current-time">0:00</span>
                                    <span id="total-time">0:00</span>
                                </div>
                            </div>
                            
                            <div class="music-controls">
                                <button class="control-btn" onclick="previousSong()">
                                    <i class="fas fa-step-backward"></i>
                                </button>
                                <button class="control-btn play-pause" id="play-pause-btn" onclick="togglePlayPause()">
                                    <i class="fas fa-play"></i>
                                </button>
                                <button class="control-btn" onclick="nextSong()">
                                    <i class="fas fa-step-forward"></i>
                                </button>
                            </div>
                            
                            <div class="playlist-section">
                                <div class="section-header">
                                    <h3>播放列表</h3>
                                    <button class="add-music-btn" onclick="addMusicToPlaylist()">
                                        <i class="fas fa-plus"></i>
                                    </button>
                                </div>
                                <div class="playlist" id="playlist">
                                    <!-- 播放列表将通过JS动态生成 -->
                                </div>
                            </div>
                            
                            <div class="character-listening">
                                <div class="listening-header">
                                    <h3>一起听歌的角色</h3>
                                    <button class="invite-character-btn" onclick="inviteCharacterToListen()">
                                        <i class="fas fa-user-plus"></i>
                                    </button>
                                </div>
                                <div class="listening-characters" id="listening-characters">
                                    <!-- 听歌角色将通过JS动态生成 -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 聊天设置界面 -->
                <div id="api-chat-settings-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideChatSettings()">‹</button>
                        <div class="app-title">聊天设置</div>
                    </div>
                    <div class="app-content padding-none-flex overflow-auto">
                        <div class="settings-container">
                            
                            <!-- 群聊专用设置 - 仿QQ/微信群聊界面 -->
                            <div class="settings-section" id="group-chat-settings" style="display: none;">
                                <!-- 群聊信息卡片 -->
                                <div class="group-info-card">
                                    <div class="group-avatar-section" onclick="changeGroupAvatar()">
                                        <img id="group-avatar-preview" src="" class="group-avatar-large" alt="群头像">
                                        <div class="group-avatar-edit-hint">点击修改</div>
                                    </div>
                                    <div class="group-basic-info">
                                        <div class="group-name" onclick="changeGroupName()" id="group-name-display">群聊名称</div>
                                        <div class="group-member-count" id="group-member-count-display">0名成员</div>
                                        <div class="group-description" onclick="editGroupDescription()" id="group-description-display">群公告：点击设置群公告</div>
                                    </div>
                                </div>

                                <!-- 群成员展示区域 -->
                                <div class="group-members-section">
                                    <div class="section-title">群成员</div>
                                    <div class="group-members-grid" id="group-members-grid">
                                        <!-- 群成员头像将动态生成 -->
                                        <div class="member-item add-member" onclick="addGroupMember()">
                                            <div class="member-avatar">
                                                <i class="fas fa-plus"></i>
                                            </div>
                                            <div class="member-name">邀请</div>
                                        </div>
                                        <div class="member-item remove-member" onclick="removeGroupMember()">
                                            <div class="member-avatar">
                                                <i class="fas fa-minus"></i>
                                            </div>
                                            <div class="member-name">移除</div>
                                        </div>
                                    </div>
                                </div>

                                <!-- 群功能设置 -->
                                <div class="setting-card">
                                    <div class="setting-item" onclick="changeMyGroupNickname()">
                                        <div class="setting-left">
                                            <div class="setting-label">我在本群的昵称</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="current-my-group-nickname">未选择</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showGroupNotice()">
                                        <div class="setting-left">
                                            <div class="setting-label">群公告</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value">查看详情</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>

                                </div>

                                <!-- 群应用中心 -->
                                <div class="group-apps-section">
                                    <div class="section-title">群应用</div>
                                    <div class="group-apps-grid">
                                        <div class="app-item" onclick="showGroupVote()">
                                            <i class="fas fa-vote-yea app-icon"></i>
                                            <span class="app-name">投票</span>
                                        </div>
                                        <div class="app-item" onclick="showGroupActivity()">
                                            <i class="fas fa-calendar-alt app-icon"></i>
                                            <span class="app-name">群活动</span>
                                        </div>
                                        <div class="app-item" onclick="showGroupTask()">
                                            <i class="fas fa-tasks app-icon"></i>
                                            <span class="app-name">群任务</span>
                                        </div>
                                        <div class="app-item" onclick="showMoreApps()">
                                            <i class="fas fa-ellipsis-h app-icon"></i>
                                            <span class="app-name">更多</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- 聊天窗口设置 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-user-edit section-icon"></i>
                                    <span class="section-title">聊天窗口设置</span>
                                </div>
                                <div class="setting-card">
                                    <!-- 身份选择功能已移除，身份在创建对话时选择 -->
                                    <!-- 单聊时显示双方设置，群聊时隐藏 -->
                                    <div class="setting-item single-chat-only" onclick="showAvatarSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">双方头像设置</div>
                                            <div class="setting-desc">设置在此聊天窗口中显示的头像</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item single-chat-only" onclick="showNicknameSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">双方备注设置</div>
                                            <div class="setting-desc">设置在此聊天窗口中显示的昵称</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showBackgroundSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">聊天背景设置</div>
                                            <div class="setting-desc">自定义聊天界面的背景图片</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showBubbleStyleSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">气泡样式设置</div>
                                            <div class="setting-desc">选择气泡外观样式和颜色</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="current-bubble-style">默认样式</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 戳一戳功能设置 - 单聊特有 -->
                            <div class="settings-section" id="poke-settings-section">
                                <div class="section-header">
                                    <i class="fas fa-hand-paper section-icon"></i>
                                    <span class="section-title">戳一戳功能</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">启用戳一戳</div>
                                            <div class="setting-desc">允许发送戳一戳消息，双方可自定义戳一戳后缀</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="poke-enabled" checked>
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                    <div class="setting-item poke-settings poke-settings-visible" id="poke-suffix-settings" onclick="showPokeSuffixSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">戳一戳后缀设置</div>
                                            <div class="setting-desc">自定义双方的戳一戳动作后缀</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-explanation">
                                        <div class="explanation-text">
                                            <strong>功能说明：</strong><br>
                                            • 点击对方头像即可发送戳一戳<br>
                                            • 你可以自定义戳一戳后缀，如"的小脸蛋"、"的小手"等<br>
                                            • 角色也会根据心情和聊天内容自主修改自己的戳一戳后缀
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 记忆设置 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-brain section-icon"></i>
                                    <span class="section-title">记忆设置</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item" onclick="showHistorySettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">附带历史消息数</div>
                                            <div class="setting-desc">自定义角色回复时参考的历史对话数量</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="current-history-count">5回合</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showMemoryMountSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">挂载其他聊天记忆</div>
                                            <div class="setting-desc">让角色参考其他聊天窗口的对话记忆</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="current-memory-mount">已关闭</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showWorldbookMountSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">挂载世界书</div>
                                            <div class="setting-desc">让角色参考选定的世界书内容作为背景知识</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="current-worldbook-mount">未挂载</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 时间感知设置 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-clock section-icon"></i>
                                    <span class="section-title">时间感知</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">时间感知开关</div>
                                            <div class="setting-desc">角色会感知当前时间并调整回复</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="time-awareness-enabled">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 通话设置 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-phone section-icon"></i>
                                    <span class="section-title">通话设置</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">角色主动拨打电话</div>
                                            <div class="setting-desc">允许角色根据对话内容主动发起通话</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="ai-call-enabled">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                    <div class="setting-explanation">
                                        <div class="explanation-text">
                                            <strong>功能说明：</strong><br>
                                            • <strong>开启时：</strong>当本轮聊天中提到通话相关内容时，角色有20%概率主动给你打电话<br>
                                            • <strong>关闭时：</strong>角色不会主动拨打电话，只能由用户主动发起通话<br>
                                            • <strong>通话关键词：</strong>通话、电话、视频、语音、打给你、想听、想看等
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- AI心率监测 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-heartbeat section-icon"></i>
                                    <span class="section-title">角色心率监测</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">心率监测显示</div>
                                            <div class="setting-desc">在状态栏显示角色的情感心率</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="ai-heartrate-enabled">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 聊天模式设置 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-comments section-icon"></i>
                                    <span class="section-title">聊天模式</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">模式选择</div>
                                            <div class="setting-desc">选择线上纯聊天或线下剧情模式</div>
                                        </div>
                                    </div>
                                    <div class="chat-mode-switch">
                                        <div class="chat-mode-option">
                                            <input type="radio" id="chat-mode-online" name="chat-mode" value="online" checked>
                                            <label for="chat-mode-online">线上模式</label>
                                        </div>
                                        <div class="chat-mode-option">
                                            <input type="radio" id="chat-mode-offline" name="chat-mode" value="offline">
                                            <label for="chat-mode-offline">线下模式</label>
                                        </div>
                                    </div>
                                    <div class="offline-length-control hide" id="offline-length-control">
                                        <span class="control-label">每条消息最长：</span>
                                        <input type="number" id="offline-mode-max-length" min="50" max="500" value="100">
                                        <span class="control-unit">字</span>
                                    </div>
                                </div>
                            </div>



                            <!-- 后台互动设置 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-robot section-icon"></i>
                                    <span class="section-title">后台互动</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">后台互动开关</div>
                                            <div class="setting-desc">角色可在后台主动活动并发送推送</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="background-interaction-enabled">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                    <div class="background-interaction-details hide" id="background-interaction-settings">
                                        <div class="setting-item">
                                        <div class="setting-left">
                                                <div class="setting-label">主动聊天</div>
                                                <div class="setting-desc">角色在你10分钟未回复时主动发消息</div>
                                        </div>
                                        <div class="setting-right">
                                                <label class="toggle-switch">
                                                    <input type="checkbox" id="background-chat-enabled">
                                                    <span class="toggle-slider"></span>
                                                </label>
                                        </div>
                                    </div>
                                        
                                        <div class="setting-item" id="chat-frequency-setting" style="display: none;">
                                        <div class="setting-left">
                                                <div class="setting-label">主动聊天频率</div>
                                                <div class="setting-desc">角色主动发起对话的频率</div>
                                        </div>
                                        <div class="setting-right">
                                                <select id="background-chat-frequency" class="setting-select">
                                                    <option value="low">低 (1-2小时/次)</option>
                                                    <option value="medium">中 (30-60分钟/次)</option>
                                                    <option value="high">高 (10-30分钟/次)</option>
                                                </select>
                                </div>
                            </div>

                                    <div class="setting-item">
                                        <div class="setting-left">
                                                <div class="setting-label">主动发动态</div>
                                                <div class="setting-desc">角色根据人设主动发布动态</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                    <input type="checkbox" id="background-moments-enabled">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>

                                        <div class="setting-item" id="moments-frequency-setting" style="display: none; justify-content: space-between !important; align-items: center !important;">
                                            <div class="setting-left" style="flex: 1 !important;">
                                                <div class="setting-label">主动发动态频率</div>
                                                <div class="setting-desc">角色主动发布社交动态的频率</div>
                                            </div>
                                            <div class="setting-right" style="display: flex !important; align-items: center !important; flex-shrink: 0 !important;">
                                                <select id="background-moments-frequency" class="setting-select">
                                                    <option value="low">低 (4-8小时/次)</option>
                                                    <option value="medium">中 (2-4小时/次)</option>
                                                    <option value="high">高 (1-2小时/次)</option>
                                                </select>
                                            </div>
                                        </div>
                                        
                                        <div class="setting-item" id="scheduled-moments-setting" style="display: none; justify-content: space-between !important; align-items: flex-start !important;">
                                            <div class="setting-left" style="flex: 1 !important;">
                                                <div class="setting-label">定时发布动态</div>
                                                <div class="setting-desc">设置固定时间点自动发布动态</div>
                                            </div>
                                            <div class="setting-right" style="display: flex !important; flex-direction: column !important; align-items: flex-end !important; gap: 8px !important; flex-shrink: 0 !important;">
                                                <label class="toggle-switch">
                                                    <input type="checkbox" id="scheduled-moments-enabled">
                                                    <span class="toggle-slider"></span>
                                                </label>
                                                <button onclick="showScheduleTimesModal()" style="background-color: #4a84c1; color: white; border: none; padding: 6px 12px; border-radius: 15px; font-size: 12px;">
                                                    <span id="schedule-times-display">未设置</span>
                                                </button>
                                            </div>
                                        </div>
                                        
                                        <div class="setting-item" id="test-publish-setting" style="display: none; justify-content: space-between !important; align-items: center !important;">
                                            <div class="setting-left" style="flex: 1 !important;">
                                                <div class="setting-label">测试发布</div>
                                                <div class="setting-desc">让角色立即发布一条测试动态</div>
                                            </div>
                                            <div class="setting-right" style="display: flex !important; align-items: center !important; flex-shrink: 0 !important; gap: 8px;">
                                                <button onclick="testPublishMoment()" style="background-color: #4a84c1; color: white; border: none; padding: 6px 12px; border-radius: 15px; font-size: 12px;">
                                                    发布
                                                </button>
                                                <button onclick="fixAvatarData()" style="background-color: #ff6b6b; color: white; border: none; padding: 6px 12px; border-radius: 15px; font-size: 12px;">
                                                    修复头像
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 其他设置 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-cog section-icon"></i>
                                    <span class="section-title">其他设置</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">显示时间戳</div>
                                            <div class="setting-desc">在聊天消息中显示时间信息</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="timestamp-enabled" checked>
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showTimestampSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">时间戳设置</div>
                                            <div class="setting-desc">设置时间戳显示位置和格式</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="searchChatContent()">
                                        <div class="setting-left">
                                            <div class="setting-label">查找聊天内容</div>
                                            <div class="setting-desc">搜索历史消息中的关键词</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="exportChatHistory()">
                                        <div class="setting-left">
                                            <div class="setting-label">导出聊天记录</div>
                                            <div class="setting-desc">导出当前对话的所有消息</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>

                                </div>
                            </div>

                            <!-- 危险操作 -->
                            <div class="settings-section">
                                <div class="section-header">
                                                    <i class="fas fa-exclamation-triangle section-icon danger-section-icon"></i>
                <span class="section-title danger-section-title">危险操作</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item danger-item" onclick="clearChatHistory()">
                                        <div class="setting-left">
                                            <div class="setting-label danger-color">清空聊天记录</div>
                                            <div class="setting-desc">删除所有历史消息，不可恢复</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right danger-color"></i>
                                        </div>
                                    </div>
                                </div>
                            </div>

                        </div>
                    </div>
                </div>
                
                <!-- 人物编辑表单 -->
                <div id="character-form-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideCharacterForm()">‹</button>
                        <div class="app-title" id="character-form-title">新建人物</div>
                    </div>
                    <div class="app-content">
                        <div class="character-form">
                            <div class="form-group avatar-upload">
                                <label class="form-label">头像</label>
                                <div class="avatar-preview" id="avatar-preview">
                                    <div class="avatar-preview-text" id="avatar-preview-text">A</div>
                                </div>
                                <input type="file" id="avatar-upload" accept="image/*" class="file-input-hidden">
                                <button class="upload-button" onclick="handleAvatarUploadClick()">上传头像</button>
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">姓名</label>
                                <input type="text" class="form-input" id="character-name" placeholder="输入姓名">
                            </div>
                            <div class="form-group">
                                <label class="form-label">人设</label>
                                <textarea class="form-textarea" id="character-bio" placeholder="输入人物设定"></textarea>
                            </div>
                            <div class="form-actions form-actions-flex">
                                <button class="form-submit form-submit-flex">保存</button>
                                <button class="form-delete form-delete-red" id="character-delete-btn" onclick="deleteCurrentCharacter()">删除</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 面具创建表单 -->
                <div id="persona-form-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hidePersonaForm()">‹</button>
                        <div class="app-title" id="persona-form-title">新建面具</div>
                    </div>
                    <div class="app-content">
                        <div class="character-form">
                            <div class="form-group avatar-upload">
                                <label class="form-label">头像</label>
                                <div class="avatar-preview" id="persona-avatar-preview">
                                    <div class="avatar-preview-text" id="persona-avatar-preview-text">我</div>
                                </div>
                                <input type="file" id="persona-avatar-upload" accept="image/*" class="file-input-hidden">
                                <button class="upload-button" onclick="handlePersonaAvatarUploadClick()">上传头像</button>
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">我的名称</label>
                                <input type="text" class="form-input" id="persona-name" placeholder="例如：user小明、user学生、user工作者">
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">我的描述</label>
                                <textarea class="form-textarea" id="persona-description" placeholder="描述这个身份的特点，包括性格、说话风格、使用场合等..."></textarea>
                            </div>
                            
                            <button class="form-submit" onclick="savePersona()">保存面具</button>
                        </div>
                    </div>
                </div>
                
                <!-- API聊天界面 -->
                <div id="api-chat-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="header">
                        <div class="default-controls">
                            <button class="back-btn" onclick="backToChatApp()">‹</button>
                            <span class="header-title" id="api-chat-title">角色聊天</span>
                            <div class="header-actions">
                                <span class="action-btn" onclick="showChatSettings()">
                                <i class="fas fa-ellipsis-v"></i>
                                </span>
                            </div>
                        </div>
                        <div class="selection-controls">
                            <span id="selection-cancel-btn">取消</span>
                            <span id="selection-count"></span>
                            <span id="selection-delete-btn">删除</span>
                        </div>
                    </div>
                    <div class="app-content padding-none-flex">

                        <div class="chat-dialog">
                            <div class="chat-messages" id="api-chat-messages">
                                <!-- 聊天消息将通过JS动态生成 -->
                            </div>
                            
                            <!-- 悬浮按钮组 -->
                            <div class="floating-actions" id="floating-actions">
                                <button class="floating-btn" id="regenerate-btn" onclick="regenerateLastResponse()" title="重新生成回答">
                                    <i class="fas fa-redo-alt"></i>
                                </button>
                            </div>
                            
                            <div class="chat-input-area">
                                <!-- 工具栏区域 -->
                                <div class="chat-tools-row">
                                    <button class="tool-btn-mini" id="voice-record-btn" onclick="handleVoiceRecording()" title="语音消息">
                                        <i class="fas fa-microphone"></i>
                                    </button>
                                    <button class="tool-btn-mini" onclick="openCamera()" title="拍照">
                                        <i class="fas fa-camera"></i>
                                    </button>
                                    <button class="tool-btn-mini" onclick="uploadImage()" title="图片">
                                        <i class="fas fa-image"></i>
                                    </button>
                                    <button class="tool-btn-mini" onclick="openTransfer()" title="转账">
                                        <i class="fas fa-exchange-alt"></i>
                                    </button>
                                    <button class="tool-btn-mini" onclick="makeCall()" title="电话">
                                        <i class="fas fa-phone"></i>
                                    </button>
                                    <button class="tool-btn-mini" onclick="openVideoCall()" title="视频通话">
                                        <i class="fas fa-video"></i>
                                    </button>
                                    <button class="tool-btn-mini" onclick="shareLocation()" title="位置">
                                        <i class="fas fa-map-marker-alt"></i>
                                    </button>
                                </div>
                                
                                <!-- 输入区域 -->
                                <div class="input-controls">
                                <button class="chat-action-btn" onclick="showCustomEmojiPanel()" title="表情包">
                                    <i class="fas fa-smile"></i>
                                </button>
                                <textarea class="chat-input" id="api-chat-input" rows="1" placeholder="输入消息..."></textarea>
                                    <button class="chat-action-btn" onclick="triggerSmartReply()" title="获取AI回复">
                                        <i class="fas fa-comment-dots"></i>
                                </button>
                                <button class="send-button" onclick="sendApiMessage()">
                                    发送
                                </button>
                                </div>
                                <input type="file" id="image-upload" accept="image/*" class="file-input-hidden">
                                <input type="file" id="emoji-upload" accept="image/*" class="file-input-hidden" multiple>
                            </div>
                        </div>
                        
                        <!-- 自定义表情包面板 -->
                        <div class="custom-emoji-panel" id="custom-emoji-panel">
                            <div class="emoji-tabs">
                                <div class="emoji-tab active" data-tab="recent">最近</div>
                                <div class="emoji-tab" data-tab="custom">全部</div>
                            </div>
                            <div class="emoji-content">
                                <div class="emoji-grid" id="emoji-grid">
                                    <!-- 表情包网格将通过JS动态生成 -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 浏览器界面 -->
                <div id="browser-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('browser-screen')">‹</button>
                        <div class="app-title">浏览器</div>
                    </div>
                    <div class="app-content padding-none-flex">
                        <div class="browser-toolbar">
                            <input type="text" class="browser-url-bar" id="browser-url" placeholder="输入网址">
                            <button onclick="loadUrl()">前往</button>
                        </div>
                        <iframe class="browser-content" id="browser-frame"></iframe>
                    </div>
                </div>
                

                
                <!-- 游戏界面 -->
                <div id="game-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('game-screen')">‹</button>
                        <div class="app-title">游戏中心</div>
                    </div>
                    <div class="app-content">
                        <div class="game-list">
                            <div class="game-item" onclick="startGame('witchPotion')">
                                <div class="game-icon">
                                    <i class="fas fa-flask"></i>
                        </div>
                                <div class="game-info">
                                    <div class="game-name">女巫的解药</div>
                                    <div class="game-desc">与AI角色一起调制神秘药水</div>
                                </div>
                                <div class="game-badge">NEW</div>
                            </div>
                            <div class="game-item coming-soon">
                                <div class="game-icon">
                                    <i class="fas fa-dice"></i>
                                </div>
                                <div class="game-info">
                                    <div class="game-name">角色猜谜</div>
                                    <div class="game-desc">即将推出</div>
                                </div>
                            </div>
                            <div class="game-item coming-soon">
                                <div class="game-icon">
                                    <i class="fas fa-book"></i>
                                </div>
                                <div class="game-info">
                                    <div class="game-name">互动故事</div>
                                    <div class="game-desc">即将推出</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                

                

                
                <!-- 设置应用 -->
                <div id="settings-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('settings-screen')">‹</button>
                        <div class="app-title">设置</div>
                    </div>
                    <div class="app-content">
                        <div class="settings-item" onclick="showApp('api-settings-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon wifi">
                                    <i class="fas fa-wifi"></i>
                                </div>
                                <div>API设置</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('theme-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon settings-icon-custom">
                                    <i class="fas fa-palette"></i>
                                </div>
                                <div>主题设置</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('display-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon display">
                                    <i class="fas fa-font"></i>
                                </div>
                                <div>字号大小</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('appearance-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon display">
                                    <i class="fas fa-mobile-alt"></i>
                                </div>
                                <div>
                                    <div class="setting-label">外观设置</div>
                                </div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('wallpaper-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon wallpaper">
                                    <i class="fas fa-image"></i>
                                </div>
                                <div>壁纸</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('datetime-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon datetime">
                                    <i class="fas fa-clock"></i>
                                </div>
                                <div>日期与时间</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div class="settings-icon notification">
                                    <i class="fas fa-bell"></i>
                                </div>
                                <div>通知</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('data-management-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon data-management">
                                    <i class="fas fa-database"></i>
                                </div>
                                <div>数据管理</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('about-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon about">
                                    <i class="fas fa-info-circle"></i>
                                </div>
                                <div>关于我们</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                    </div>
                </div>
                
                <!-- 日期与时间设置 -->
                <div id="datetime-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('datetime-screen')">‹</button>
                        <div class="app-title">日期与时间</div>
                    </div>
                    <div class="app-content">
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>自动设置</div>
                            </div>
                            <label class="settings-toggle">
                                <input type="checkbox" checked>
                                <span class="settings-slider"></span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <!-- 数据管理 -->
                <div id="data-management-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('data-management-screen')">‹</button>
                        <div class="app-title">数据管理</div>
                    </div>
                    <div class="app-content">
                        <!-- 存储空间使用情况 -->
                        <div class="data-section">
                            <div class="data-section-title">存储空间使用情况</div>
                            <div class="storage-usage" id="storage-usage">
                                <div class="storage-item">
                                    <div class="storage-label">聊天记录</div>
                                    <div class="storage-size" id="chat-storage-size">计算中...</div>
                                </div>
                                <div class="storage-item">
                                    <div class="storage-label">角色数据</div>
                                    <div class="storage-size" id="character-storage-size">计算中...</div>
                                </div>
                                <div class="storage-item">
                                    <div class="storage-label">聊天设置</div>
                                    <div class="storage-size" id="settings-storage-size">计算中...</div>
                                </div>
                                <div class="storage-item">
                                    <div class="storage-label">表情包</div>
                                    <div class="storage-size" id="emoji-storage-size">计算中...</div>
                                </div>
                                <div class="storage-total">
                                    <div class="storage-label">总计</div>
                                    <div class="storage-size" id="total-storage-size">计算中...</div>
                                </div>
                            </div>
                        </div>

                        <!-- 数据导入导出 -->
                        <div class="data-section">
                            <div class="data-section-title">数据备份与恢复</div>
                            <div class="settings-item" onclick="exportAllData()">
                                <div class="settings-item-left">
                                    <div class="settings-icon export">
                                        <i class="fas fa-download"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">导出所有数据</div>
                                        <div class="setting-desc">将所有聊天记录和设置导出为JSON文件</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="settings-item" onclick="importDataFromFile()">
                                <div class="settings-item-left">
                                    <div class="settings-icon import">
                                        <i class="fas fa-upload"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">导入数据</div>
                                        <div class="setting-desc">从JSON文件恢复聊天记录和设置</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>

                        <!-- 选择性清理 -->
                        <div class="data-section">
                            <div class="data-section-title">存储清理</div>
                            <div class="settings-item" onclick="cleanupOrphanedContacts()">
                                <div class="settings-item-left">
                                    <div class="settings-icon cleanup">
                                        <i class="fas fa-user-slash"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">清理孤立联系人</div>
                                        <div class="setting-desc">清理不存在的角色联系人和相关数据</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>

                            <div class="settings-item" onclick="showCleanupOptions()">
                                <div class="settings-item-left">
                                    <div class="settings-icon cleanup">
                                        <i class="fas fa-broom"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">选择性清理</div>
                                        <div class="setting-desc">清理特定类型的数据以释放空间</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="settings-item" onclick="compressAllImages()">
                                <div class="settings-item-left">
                                    <div class="settings-icon compress">
                                        <i class="fas fa-compress-arrows-alt"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">压缩图片</div>
                                        <div class="setting-desc">压缩所有头像和背景图片以节省空间</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>

                        <!-- 危险操作 -->
                        <div class="data-section danger-section">
                            <div class="data-section-title">危险操作</div>
                            <div class="settings-item danger-item" onclick="clearAllData()">
                                <div class="settings-item-left">
                                    <div class="settings-icon danger">
                                        <i class="fas fa-trash-alt"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">清空所有数据</div>
                                        <div class="setting-desc">删除所有聊天记录、角色和设置（不可恢复）</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 关于我们 -->
                <div id="about-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('about-screen')">‹</button>
                        <div class="app-title">关于我们</div>
                    </div>
                    <div class="app-content">
                        <div class="about-content">
                            <div class="about-title">iPhone 模拟器</div>
                            <div class="about-version">版本 1.0.0</div>
                            <div class="about-author">作者@EVE</div>
                        </div>
                    </div>
                </div>
                
                <!-- 字号大小设置 -->
                <div id="display-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('display-screen')">‹</button>
                        <div class="app-title">字号大小</div>
                    </div>
                    <div class="app-content">
                        <div class="font-size-preview">
                            <div class="font-size-preview-text" id="font-size-preview">
                                这是一段示例文字，用于预览字体大小效果。调节下方滑块可以改变字体大小。
                            </div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">字号大小</div>
                                    <div class="setting-desc">调节聊天消息和社交动态的字体大小</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="font-size-slider-container">
                            <div class="font-size-labels">
                                <span>小</span>
                                <span>标准</span>
                                <span>大</span>
                            </div>
                            <input type="range" class="font-size-slider" id="font-size-slider" 
                                   min="12" max="20" step="1" value="15" 
                                   onchange="changeFontSize(this.value)">
                            <div class="font-size-value">
                                当前字号：<span id="font-size-value">15px</span>
                            </div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">字距设置</div>
                                    <div class="setting-desc">调节文字之间的间距</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="font-size-slider-container">
                            <div class="font-size-labels">
                                <span>紧凑</span>
                                <span>标准</span>
                                <span>宽松</span>
                            </div>
                            <input type="range" class="font-size-slider" id="letter-spacing-slider" 
                                   min="-0.5" max="2" step="0.1" value="0" 
                                   onchange="changeLetterSpacing(this.value)">
                            <div class="font-size-value">
                                当前字距：<span id="letter-spacing-value">标准</span>
                            </div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">自动缩放</div>
                                    <div class="setting-desc">根据屏幕尺寸自动调整字体大小</div>
                                </div>
                            </div>
                            <label class="settings-toggle">
                                <input type="checkbox" id="auto-scale-toggle" onchange="toggleAutoScale()">
                                <span class="settings-slider"></span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <!-- 屏幕尺寸设置 -->
                <div id="screen-size-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('screen-size-screen')">‹</button>
                        <div class="app-title">屏幕尺寸</div>
                    </div>
                    <div class="app-content">
                        <div class="size-option" onclick="changeScreenSize(320, 568, 'iPhone SE')">
                            <div class="size-option-left">
                                <div class="size-name">iPhone SE</div>
                                <div class="size-desc">320×568 (小屏模式)</div>
                            </div>
                            <div class="size-preview">
                                <div class="size-preview-rect size-preview-rect-xs"></div>
                            </div>
                        </div>
                        
                        <div class="size-option" onclick="changeScreenSize(350, 740, '适中尺寸')" id="size-350-740">
                            <div class="size-option-left">
                                <div class="size-name">适中尺寸</div>
                                <div class="size-desc">350×740 (推荐)</div>
                            </div>
                            <div class="size-preview">
                                <div class="size-preview-rect size-preview-rect-s"></div>
                            </div>
                            <i class="fas fa-check check-icon"></i>
                        </div>
                        
                        <div class="size-option" onclick="changeScreenSize(375, 812, 'iPhone 12/13')">
                            <div class="size-option-left">
                                <div class="size-name">iPhone 12/13</div>
                                <div class="size-desc">375×812 (标准)</div>
                            </div>
                            <div class="size-preview">
                                <div class="size-preview-rect size-preview-rect-m"></div>
                            </div>
                        </div>
                        
                        <div class="size-option" onclick="changeScreenSize(390, 844, 'iPhone 15')">
                            <div class="size-option-left">
                                <div class="size-name">iPhone 15</div>
                                <div class="size-desc">390×844 (真实尺寸)</div>
                            </div>
                            <div class="size-preview">
                                <div class="size-preview-rect size-preview-rect-l"></div>
                            </div>
                        </div>
                        
                        <div class="size-option" onclick="changeScreenSize(428, 926, 'iPhone 15 Plus')">
                            <div class="size-option-left">
                                <div class="size-name">iPhone 15 Plus</div>
                                <div class="size-desc">428×926 (大屏)</div>
                            </div>
                            <div class="size-preview">
                                <div class="size-preview-rect size-preview-rect-xl"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 外观设置 -->
                <div id="appearance-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('appearance-screen')">‹</button>
                        <div class="app-title">外观设置</div>
                    </div>
                    <div class="app-content">
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">显示手机边框</div>
                                    <div class="setting-desc">显示圆角边框和阴影效果</div>
                                </div>
                            </div>
                            <label class="settings-toggle">
                                <input type="checkbox" id="phone-border-toggle" checked onchange="togglePhoneBorder()">
                                <span class="settings-slider"></span>
                            </label>
                        </div>
                        <div class="settings-item" onclick="showScreenSizeOptions()">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">屏幕尺寸</div>
                                    <div class="setting-desc" id="current-screen-size">当前：350×740 (适中尺寸)</div>
                                </div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                    </div>
                </div>
                
                <!-- 主题设置界面 -->
                <div id="theme-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('theme-screen')">‹</button>
                        <div class="app-title">主题设置</div>
                    </div>
                    <div class="app-content">
                        <div class="theme-option" onclick="changeTheme('default')">
                            <div class="theme-preview theme-preview-simple">
                                <div class="theme-preview-header"></div>
                                <div class="theme-preview-content"></div>
                            </div>
                            <div class="theme-info">
                                <div class="theme-name">简约风格</div>
                                <div class="theme-description">清新简洁的默认主题</div>
                            </div>
                        </div>
                        
                        <div class="theme-option" onclick="changeTheme('cute')">
                            <div class="theme-preview theme-preview-cute">
                                <div class="theme-preview-header"></div>
                                <div class="theme-preview-content"></div>
                            </div>
                            <div class="theme-info">
                                <div class="theme-name">可爱风格</div>
                                <div class="theme-description">温馨可爱的粉色主题</div>
                            </div>
                        </div>
                        </div>
                    </div>
                </div>
                
                <!-- 壁纸设置 -->
                <div id="wallpaper-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('wallpaper-screen')">‹</button>
                        <div class="app-title">壁纸</div>
                    </div>
                    <div class="app-content">
                        <div class="settings-item" onclick="showWallpaperPicker()">
                            <div class="settings-item-left">
                                <div>选择新壁纸</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showIconPicker()">
                            <div class="settings-item-left">
                                <div>更改应用图标</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                    </div>
                </div>
                
                <!-- 无线局域网设置 -->
                <div id="wifi-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('wifi-screen')">‹</button>
                        <div class="app-title">无线局域网</div>
                    </div>
                    <div class="app-content">
                        <div class="wifi-settings">
                            <div class="settings-item">
                                <div class="settings-item-left">
                                    <div>无线局域网</div>
                                </div>
                                <label class="settings-toggle">
                                    <input type="checkbox" checked>
                                    <span class="settings-slider"></span>
                                </label>
                            </div>
                            
                            <div class="wifi-network">
                                <div class="wifi-network-left">
                                    <div class="wifi-icon">
                                        <i class="fas fa-lock"></i>
                                    </div>
                                    <div>
                                        <div>HomeWiFi</div>
                                        <div class="wifi-strength">
                                            <div class="wifi-strength-bar active"></div>
                                            <div class="wifi-strength-bar active"></div>
                                            <div class="wifi-strength-bar active"></div>
                                            <div class="wifi-strength-bar active"></div>
                                        </div>
                                    </div>
                                </div>
                                <i class="fas fa-check check-icon"></i>
                            </div>
                            
                            <div class="settings-item settings-item-margin" onclick="showApp('api-settings-screen')">
                                <div class="settings-item-left">
                                    <div>API设置</div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- API设置界面 -->
                <div id="api-settings-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('api-settings-screen')">‹</button>
                        <div class="app-title">API设置</div>
                    </div>
                    <div class="app-content">
                        <div class="form-container" style="color: #000000;">
                            

                            
                            <!-- 快速设置卡片 -->
                            <div class="form-group" style="margin-bottom: 30px;">
                                <label style="color: #333; margin-bottom: 15px; display: block; font-size: 16px; font-weight: 600;">🚀 快速设置</label>
                                
                                <!-- Gemini直连卡片 -->
                                <div style="margin-bottom: 12px; padding: 18px; background: linear-gradient(135deg, rgba(74, 132, 193, 0.1) 0%, rgba(74, 132, 193, 0.05) 100%); border: 2px solid rgba(74, 132, 193, 0.2); border-radius: 16px; color: #333; cursor: pointer; transition: all 0.3s ease; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);" onclick="setGeminiDirect()">
                                    <div style="display: flex; align-items: center; justify-content: space-between;">
                                        <div>
                                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 4px; color: var(--theme-button-bg, #4a84c1);">🌟 Gemini 直连</div>
                                            <div style="font-size: 13px; color: #666;">自动配置Google官方API，支持最新模型</div>
                                        </div>
                                        <div style="background: var(--theme-button-bg, rgba(74, 132, 193, 0.9)); color: white; padding: 8px 14px; border-radius: 20px; font-size: 13px; font-weight: 500; box-shadow: 0 2px 8px rgba(74, 132, 193, 0.3);">点击配置</div>
                                    </div>
                            </div>
                            
                                <!-- HuggingFace反代卡片 -->
                                <div style="margin-bottom: 15px; padding: 18px; background: linear-gradient(135deg, rgba(255, 193, 7, 0.1) 0%, rgba(255, 193, 7, 0.05) 100%); border: 2px solid rgba(255, 193, 7, 0.2); border-radius: 16px; color: #333; cursor: pointer; transition: all 0.3s ease; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);" onclick="setHuggingFaceProxy()">
                                    <div style="display: flex; align-items: center; justify-content: space-between;">
                                        <div>
                                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 4px; color: #f39c12;">🤗 HuggingFace 反代</div>
                                            <div style="font-size: 13px; color: #666;">免费使用多种大模型，支持Claude等</div>
                                        </div>
                                        <div style="background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%); color: white; padding: 8px 14px; border-radius: 20px; font-size: 13px; font-weight: 500; box-shadow: 0 2px 8px rgba(243, 156, 18, 0.3);">点击配置</div>
                                    </div>
                            </div>
                            
                                <div style="font-size: 12px; color: #666; text-align: center; margin-top: 10px;">
                                    ⚠️ 使用前请确保有对应的API密钥
                                </div>
                            </div>
                            
                            <!-- API配置表单 - 美化版 -->
                            <div style="background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 25px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1); border: 1px solid rgba(255, 255, 255, 0.2);">
                                
                                <!-- API地址 -->
                                <div style="margin-bottom: 20px;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: var(--theme-text-primary, #333); font-size: 15px;">API地址</label>
                                    <input type="text" id="api-base" placeholder="例如: https://api.openai.com 或 @https://xxx-xxx.hf.space/v1" style="width: 100%; padding: 12px 15px; border: 2px solid var(--theme-input-border, rgba(0, 0, 0, 0.08)); border-radius: 12px; font-size: 16px; background: var(--theme-form-bg, rgba(255, 255, 255, 0.9)); backdrop-filter: blur(10px); transition: all 0.3s ease; color: var(--theme-text-primary, #333); box-sizing: border-box;">
                                    <div style="font-size: 12px; color: #666; margin-top: 5px;">支持标准API和HuggingFace反代（格式：@https://xxx.hf.space/v1）</div>
                            </div>
                            
                                <!-- API密钥 -->
                                <div style="margin-bottom: 20px;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: var(--theme-text-primary, #333); font-size: 15px;">API密钥</label>
                                    <input type="password" id="api-key" placeholder="sk-... 或 Google AI Studio API Key" style="width: 100%; padding: 12px 15px; border: 2px solid var(--theme-input-border, rgba(0, 0, 0, 0.08)); border-radius: 12px; font-size: 16px; background: var(--theme-form-bg, rgba(255, 255, 255, 0.9)); backdrop-filter: blur(10px); transition: all 0.3s ease; color: var(--theme-text-primary, #333); box-sizing: border-box;">
                                </div>
                                
                                <!-- 模型选择 -->
                                <div style="margin-bottom: 20px;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: var(--theme-text-primary, #333); font-size: 15px;">模型</label>
                                    <div style="display: flex; gap: 10px; align-items: center;">
                                        <select id="model-select" style="flex: 1; padding: 12px 15px; border: 2px solid var(--theme-input-border, rgba(0, 0, 0, 0.08)); border-radius: 12px; font-size: 16px; background: var(--theme-form-bg, rgba(255, 255, 255, 0.9)); backdrop-filter: blur(10px); transition: all 0.3s ease; color: var(--theme-text-primary, #333);">
                                            <!-- 模型选项将通过JS动态填充 -->
                                    </select>
                                        <button id="fetch-models-btn" onclick="fetchModels()" style="padding: 10px 16px; background: var(--theme-button-secondary-bg, rgba(255, 255, 255, 0.8)); color: var(--theme-button-secondary-color, #666); border: 2px solid var(--theme-button-secondary-border, rgba(0, 0, 0, 0.1)); border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: 500; backdrop-filter: blur(10px); transition: all 0.3s ease; white-space: nowrap;">拉取模型</button>
                                </div>
                            </div>
                            
                                <!-- 温度参数 -->
                                <div style="margin-bottom: 25px;">
                                    <label style="display: block; margin-bottom: 12px; font-weight: 600; color: var(--theme-text-primary, #333); font-size: 15px;">温度参数 (<span id="temperature-value" style="color: var(--theme-button-bg, #4a84c1); font-weight: 700;">0.75</span>)</label>
                                    <div style="background: rgba(255, 255, 255, 0.8); padding: 15px; border-radius: 12px; border: 2px solid var(--theme-input-border, rgba(0, 0, 0, 0.08));">
                                        <input type="range" id="temperature-slider" min="0" max="2" step="0.05" value="0.75" oninput="document.getElementById('temperature-value').textContent = parseFloat(this.value).toFixed(2);" style="width: 100%; height: 6px; border-radius: 3px; background: linear-gradient(to right, rgba(74, 132, 193, 0.2) 0%, rgba(74, 132, 193, 0.4) 100%); outline: none; -webkit-appearance: none; appearance: none;">
                                        <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 12px; color: #666;">
                                            <span>0.00 (保守)</span>
                                            <span>1.00 (平衡)</span>
                                            <span>2.00 (创新)</span>
                                        </div>
                                        <div style="font-size: 12px; color: #666; margin-top: 8px; text-align: center;">温度越低，回答越保守稳定；温度越高，回答越有创意多样</div>
                                    </div>
                            </div>
                            
                                <!-- 操作按钮 -->
                                <div style="display: flex; gap: 12px; margin-top: 25px;">
                                    <button id="test-api-connection-btn" onclick="testApiConnection()" style="flex: 1; padding: 14px 20px; background: linear-gradient(135deg, #34c759 0%, #30d158 100%); color: white; border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: 0 4px 15px rgba(52, 199, 89, 0.3); transition: all 0.3s ease;">测试连接</button>
                                    <button id="save-api-settings-btn" onclick="saveApiSettings()" style="flex: 1; padding: 14px 20px; background: var(--theme-button-bg, rgba(74, 132, 193, 0.9)); color: var(--theme-button-color, white); border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: var(--theme-button-shadow, 0 4px 15px rgba(74, 132, 193, 0.3)); transition: all 0.3s ease;">保存设置</button>
                                </div>
                            </div>

                            <!-- API配置管理 -->
                            <hr style="margin: 30px 0; border: none; border-top: 1px solid #eaeaea;">
                            <div class="api-config-manager" style="background: rgba(248, 249, 250, 0.8); border-radius: 16px; padding: 20px; margin: 15px 0; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(0,0,0,0.05);">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>💾</span> API配置管理
                                </h4>
                                <p style="font-size: 13px; color: #666; margin: 0 0 15px 0; line-height: 1.5;">保存当前配置为预设，方便快速切换不同的API服务</p>
                                
                                <div class="save-config-section" style="margin-bottom: 20px; padding: 15px; background: rgba(255,255,255,0.6); border-radius: 12px; border: 1px solid rgba(0,0,0,0.05);">
                                    <div style="display: flex; gap: 10px; margin-bottom: 12px;">
                                        <input type="text" id="config-name-input" placeholder="输入配置名称 (如: OpenAI、Gemini、Claude等)" style="flex: 1; padding: 10px 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px; background: rgba(255,255,255,0.9);">
                                        <button id="save-current-config-btn" onclick="saveCurrentConfig()" style="padding: 10px 16px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);">💾 保存配置</button>
                        </div>
                                    <div style="font-size: 12px; color: #888;">当前配置将保存为: <span style="color: #333; font-weight: 500;">URL + 模型 + 温度设置</span></div>
                                </div>
                                
                                <div class="saved-configs-section">
                                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                                        <label style="font-size: 14px; font-weight: 500; color: #333;">已保存的配置</label>
                                        <button id="clear-all-configs-btn" onclick="clearAllConfigs()" style="padding: 6px 12px; background: rgba(255, 107, 107, 0.1); color: #ff6b6b; border: 1px solid rgba(255, 107, 107, 0.3); border-radius: 6px; font-size: 12px; cursor: pointer; transition: all 0.2s ease;">🗑️ 清空全部</button>
                                    </div>
                                    <div id="saved-configs-container" style="display: grid; gap: 10px; max-height: 300px; overflow-y: auto;">
                                        <!-- 保存的配置卡片将在这里动态生成 -->
                                    </div>
                                    <div id="no-configs-message" style="text-align: center; color: #999; padding: 30px 20px; font-size: 14px; display: none;">
                                        <div style="font-size: 24px; margin-bottom: 8px;">📝</div>
                                        <div>还没有保存任何配置</div>
                                        <div style="font-size: 12px; margin-top: 4px;">在上方输入配置名称并点击"保存配置"</div>
                                    </div>
                                </div>
                            </div>



                        </div>
                    </div>
                </div>
                
                <!-- 颜色选择器模态框 -->
                <div class="modal" id="color-picker-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title" id="color-picker-title">选择颜色</div>
                            <button class="modal-close" onclick="hideModal('color-picker-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="color-picker" id="color-picker">
                                <div class="color-option color-red" onclick="selectColor('#FF3B30')"></div>
                                <div class="color-option color-orange" onclick="selectColor('#FF9500')"></div>
                                <div class="color-option color-yellow" onclick="selectColor('#FFCC00')"></div>
                                <div class="color-option color-green" onclick="selectColor('#34C759')"></div>
                                <div class="color-option color-light-blue" onclick="selectColor('#5AC8FA')"></div>
                                <div class="color-option color-blue" onclick="selectColor('#007AFF')"></div>
                                <div class="color-option color-purple" onclick="selectColor('#5856D6')"></div>
                                <div class="color-option color-pink" onclick="selectColor('#AF52DE')"></div>
                                <div class="color-option color-red-alt" onclick="selectColor('#FF2D55')"></div>
                            </div>
                            <div class="form-group">
                                <label class="form-label">透明度</label>
                                <input type="range" class="opacity-slider" id="opacity-slider" min="0" max="1" step="0.1" value="1">
                                <span id="opacity-value">100%</span>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('color-picker-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="applyColorSelection()">应用</button>
                        </div>
                    </div>
                </div>
                
                <!-- 壁纸选择器模态框 -->
                <div class="modal" id="wallpaper-picker-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">选择壁纸</div>
                            <button class="modal-close" onclick="hideModal('wallpaper-picker-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="wallpaper-preview-container" id="wallpaper-preview-container">
                                <div class="wallpaper-preview-placeholder">
                                    <i class="fas fa-image"></i>
                                    <div>选择本地图片后可在此预览</div>
                                </div>
                            </div>
                            <div class="settings-item upload-custom-item" onclick="uploadCustomWallpaper()">
                                <div class="settings-item-left">
                                    <div>从相册选择</div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <input type="file" id="custom-wallpaper-upload" accept="image/*" class="file-input-hidden">
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('wallpaper-picker-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="applyWallpaperSelection()">应用</button>
                        </div>
                    </div>
                </div>
                
                <!-- 图标选择器模态框 -->
                <div class="modal" id="icon-picker-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">选择应用图标</div>
                            <button class="modal-close" onclick="hideModal('icon-picker-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="icon-options">
                                <div class="icon-option" onclick="selectAppIcon('chat-screen', 'fas fa-comment-dots')">
                                    <div class="icon-preview">
                                        <i class="fas fa-comment-dots"></i>
                                    </div>
                                    <span>Chat</span>
                                </div>
                                <div class="icon-option" onclick="selectAppIcon('weibo-screen', 'fab fa-weibo')">
                                    <div class="icon-preview">
                                        <i class="fab fa-weibo"></i>
                                    </div>
                                    <span>社交网络</span>
                                </div>
                                <div class="icon-option" onclick="selectAppIcon('music-screen', 'fas fa-music')">
                                    <div class="icon-preview">
                                        <i class="fas fa-music"></i>
                                    </div>
                                    <span>音乐</span>
                                </div>
                                <div class="icon-option" onclick="selectAppIcon('album-screen', 'fas fa-images')">
                                    <div class="icon-preview">
                                        <i class="fas fa-images"></i>
                                    </div>
                                    <span>相册</span>
                                </div>
                            </div>
                            <div class="settings-item upload-custom-item" onclick="uploadCustomIcon()">
                                <div class="settings-item-left">
                                    <div>从相册选择</div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <input type="file" id="custom-icon-upload" accept="image/*" class="file-input-hidden">
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('icon-picker-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="applyIconSelection()">应用</button>
                        </div>
                    </div>
                </div>
                
                <!-- 照片拍摄模态框 -->

                

                
                <!-- 添加联系人模态框 -->
                <div class="modal" id="add-contact-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">添加联系人</div>
                            <button class="modal-close" onclick="hideModal('add-contact-modal')">&times;</button>
                        </div>
                        <div class="modal-body" id="contact-modal-body">
                            <!-- 联系人选项将通过JS动态生成 -->
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('add-contact-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="addSelectedContacts()">添加</button>
                        </div>
                    </div>
                </div>
                
                <!-- 聊天选项模态框 -->
                <div class="modal" id="chat-options-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">选择聊天类型</div>
                            <button class="modal-close" onclick="hideModal('chat-options-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="chat-option-item" onclick="showSingleChatSelector()">
                                <div class="chat-option-icon">
                                    <i class="fas fa-user icon-user-blue"></i>
                                </div>
                                <div class="chat-option-text">
                                    <div class="chat-option-title">单聊</div>
                                    <div class="chat-option-desc">与单个角色进行对话</div>
                                </div>
                            </div>
                            <div class="chat-option-item" onclick="showGroupChatSelector()">
                                <div class="chat-option-icon">
                                    <i class="fas fa-users icon-users-green"></i>
                                </div>
                                <div class="chat-option-text">
                                    <div class="chat-option-title">群聊</div>
                                    <div class="chat-option-desc">与多个角色同时聊天</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 单聊角色选择模态框 -->
                <div class="modal" id="single-chat-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">选择聊天角色</div>
                            <button class="modal-close" onclick="hideModal('single-chat-modal')">&times;</button>
                        </div>
                        <div class="modal-body" id="single-chat-body">
                            <!-- 角色列表将通过JS动态生成 -->
                        </div>
                    </div>
                </div>
                
                <!-- 群聊角色选择模态框 -->
                <div class="modal" id="group-chat-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">创建群聊</div>
                            <button class="modal-close" onclick="hideModal('group-chat-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">群聊名称</label>
                                <input type="text" class="form-input" id="group-chat-name" placeholder="例如：动态分享、工作群">
                            </div>
                            <div class="form-group">
                                <label class="form-label">选择成员 (至少2人，最多8人)</label>
                                <div id="group-chat-members">
                                    <!-- 群聊成员选择将通过JS动态生成 -->
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('group-chat-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="createGroupChat()">创建群聊</button>
                        </div>
                    </div>
                </div>
                
                <!-- 历史消息设置模态框 -->
                <div class="modal" id="history-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">历史消息设置</div>
                            <button class="modal-close" onclick="hideModal('history-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="setting-card">
                                <div class="setting-item">
                                    <div class="setting-left">
                                        <div class="setting-label">附带历史消息数 (回合数)</div>
                                        <div class="setting-desc">AI回复时参考的历史对话回合数</div>
                                    </div>
                                    <div class="setting-right">
                                        <span class="setting-value" id="history-count-display">5回合</span>
                                    </div>
                                </div>
                                <div class="setting-range-container">
                                    <input type="range" class="theme-range" id="history-messages-count" min="0" max="100" step="1" value="5">
                                    <div class="range-labels">
                                        <span>0回合</span>
                                        <span>100回合</span>
                                    </div>
                                </div>
                                <div class="custom-input-container">
                                    <span class="input-label">自定义数值：</span>
                                    <input type="number" class="theme-input" id="custom-history-count" min="0" max="500" value="5">
                                    <span class="input-unit">回合 (最大500)</span>
                                </div>
                                <div class="setting-explanation">
                                    <div class="explanation-text">
                                        <strong>说明：</strong><br>
                                        • 一回合 = 你的一条消息 + AI的一条回复<br>
                                        • 设置为5表示AI回复时会参考最近5轮对话<br>
                                        • 注意：数值过大可能影响API响应速度
                                    </div>
                                </div>
                            </div>
                            
                            <div class="setting-card">
                                <div class="setting-item">
                                    <div class="setting-left">
                                        <div class="setting-label">跨窗口记忆回合数</div>
                                        <div class="setting-desc">从其他聊天窗口读取的背景记忆回合数</div>
                                    </div>
                                    <div class="setting-right">
                                        <span class="setting-value" id="cross-memory-display">3回合</span>
                                    </div>
                                </div>
                                <div class="setting-range-container">
                                    <input type="range" class="theme-range" id="cross-chat-memory" min="0" max="20" step="1" value="3">
                                    <div class="range-labels">
                                        <span>0回合</span>
                                        <span>20回合</span>
                                    </div>
                                </div>
                                <div class="setting-explanation">
                                    <div class="explanation-text">
                                        <strong>说明：</strong><br>
                                        • AI会读取其他聊天窗口中最新的几轮对话作为背景记忆<br>
                                        • 一回合 = 用户一条消息 + AI一条回复<br>
                                        • 帮助AI更好地理解整体对话上下文
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="theme-button theme-button-secondary" onclick="hideModal('history-settings-modal')">取消</button>
                            <button class="theme-button theme-button-primary" onclick="saveHistorySettings()">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 记忆挂载设置模态框 -->
                <div class="modal" id="memory-mount-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">记忆挂载设置</div>
                            <button class="modal-close" onclick="hideModal('memory-mount-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">
                                    <input type="checkbox" id="memory-mount-enabled" class="checkbox-with-margin">
                                    启用记忆挂载
                                </label>
                                <p class="small-text margin-top-5">
                                    开启后，AI会参考其他聊天窗口的对话内容作为背景记忆
                                </p>
                            </div>
                            <div class="form-group hide" id="memory-mount-details">
                                <label class="form-label">每个聊天挂载条数</label>
                                <input type="range" class="api-form-range" id="memory-mount-count" min="1" max="20" step="1" value="3">
                                <div class="flex-space-between">
                                    <span>1条</span>
                                    <span id="memory-mount-display">3条</span>
                                    <span>20条</span>
                                </div>
                            </div>
                            <div class="form-group hide" id="memory-mount-chats">
                                <label class="form-label">选择要挂载的聊天</label>
                                <div id="memory-mount-list" class="max-height-200-auto">
                                    <!-- 聊天列表将通过JS动态生成 -->
                                </div>
                                <p class="small-text margin-top-8">
                                    选择的聊天记录会作为背景信息提供给AI参考
                                </p>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('memory-mount-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveMemoryMountSettings()">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 头像设置模态框 -->
                <div class="modal" id="avatar-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">双方头像设置</div>
                            <button class="modal-close" onclick="hideModal('avatar-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="avatar-setting-group">
                                <label class="form-label">我的头像 (仅在此聊天窗口生效)</label>
                                <div class="avatar-preview-container">
                                    <div class="avatar-preview" id="my-chat-avatar-preview">
                                        <i class="fas fa-user"></i>
                                    </div>
                                    <input type="file" id="my-chat-avatar-upload" accept="image/*" class="file-input-hidden">
                                    <button class="upload-button" onclick="document.getElementById('my-chat-avatar-upload').click()">上传头像</button>
                                </div>
                            </div>
                            <div class="avatar-setting-group">
                                <label class="form-label">对方头像 (仅在此聊天窗口生效)</label>
                                <div class="avatar-preview-container">
                                    <div class="avatar-preview" id="ai-chat-avatar-preview">
                                        <i class="fas fa-robot"></i>
                                    </div>
                                    <input type="file" id="ai-chat-avatar-upload" accept="image/*" class="file-input-hidden">
                                    <button class="upload-button" onclick="document.getElementById('ai-chat-avatar-upload').click()">上传头像</button>
                                    <button class="upload-button clear-avatar-btn" onclick="clearAiDynamicAvatar()">清除动态头像</button>
                                </div>
                                <p class="small-text margin-top-5">
                                    注意：如果角色在聊天中更换了头像，动态头像会覆盖此设置，点击"清除动态头像"可重置
                                </p>
                            </div>
                            <div class="form-group margin-top-20">
                                <label class="form-label">
                                    <input type="checkbox" id="hide-avatars" class="checkbox-with-margin">
                                    隐藏双方头像
                                </label>
                                <p class="small-text margin-top-5">
                                    开启后，聊天界面将不显示任何头像
                                </p>
                            </div>
                            <p class="small-text margin-top-15">
                                注意：此设置仅影响当前聊天窗口显示，不会同步修改角色卡或面具设置
                            </p>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('avatar-settings-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveChatAvatarSettings()">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 昵称设置模态框 -->
                <div class="modal" id="nickname-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">双方备注设置</div>
                            <button class="modal-close" onclick="hideModal('nickname-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">我的昵称 (仅在此聊天中显示)</label>
                                <input type="text" class="form-input" id="my-chat-nickname" placeholder="输入你在此聊天中的昵称">
                            </div>
                            <div class="form-group">
                                <label class="form-label">对方昵称 (仅在此聊天中显示)</label>
                                <input type="text" class="form-input" id="ai-chat-nickname" placeholder="输入对方在此聊天中的昵称">
                            </div>
                            <p class="small-text margin-top-10">
                                注意：此设置仅影响当前聊天窗口显示，不会同步修改角色卡或面具设置。角色也可能根据心情和聊天内容自主修改自己的昵称。
                            </p>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('nickname-settings-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveChatNicknameSettings()">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 戳一戳后缀设置模态框 -->
                <div class="modal" id="poke-suffix-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">戳一戳后缀设置</div>
                            <button class="modal-close" onclick="hideModal('poke-suffix-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">我的戳一戳后缀</label>
                                <input type="text" class="form-input" id="my-poke-suffix" placeholder="留空为无后缀（例如：的小脸蛋）">
                                <p class="tiny-text margin-top-5">显示为：你戳了戳[角色名][后缀]，留空则显示：你戳了戳[角色名]</p>
                            </div>
                            <div class="form-group">
                                <label class="form-label">对方戳一戳后缀</label>
                                <input type="text" class="form-input" id="ai-poke-suffix" placeholder="留空为无后缀（例如：的小手）">
                                <p class="tiny-text margin-top-5">显示为：[角色名]戳了戳你[后缀]，留空则显示：[角色名]戳了戳你。角色可能根据心情自主修改此后缀。</p>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('poke-suffix-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="savePokeSuffixSettings()">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 聊天背景设置模态框 -->
                <div class="modal" id="background-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">聊天背景设置</div>
                            <button class="modal-close" onclick="hideModal('background-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="background-preview-container">
                                <div class="background-preview" id="chat-background-preview">
                                    <div class="preview-text">背景预览</div>
                                </div>
                            </div>
                            <div class="form-group">
                                <input type="file" id="background-upload" accept="image/*" class="file-input-hidden">
                                <button class="form-button" onclick="document.getElementById('background-upload').click()">选择背景图片</button>
                                <button class="form-button form-button-secondary" onclick="removeBackground()">移除背景</button>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('background-settings-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveChatBackgroundSettings()">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 气泡样式设置模态框 -->
                <div class="modal" id="bubble-style-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">气泡样式设置</div>
                            <button class="modal-close" onclick="hideModal('bubble-style-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="bubble-style-section">
                                <label class="form-label">选择气泡样式</label>
                                <div class="bubble-style-grid">
                                    <div class="bubble-style-option" data-style="default">
                                        <div class="style-preview">
                                            <div class="preview-bubble sent-preview">默认样式</div>
                                            <div class="preview-bubble received-preview">经典圆角</div>
                                        </div>
                                        <div class="style-name">默认样式</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="glass">
                                        <div class="style-preview bubble-style-glass">
                                            <div class="preview-bubble sent-preview">毛玻璃</div>
                                            <div class="preview-bubble received-preview">半透明</div>
                                        </div>
                                        <div class="style-name">毛玻璃</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="shadow">
                                        <div class="style-preview bubble-style-shadow">
                                            <div class="preview-bubble sent-preview">经典阴影</div>
                                            <div class="preview-bubble received-preview">立体感</div>
                                        </div>
                                        <div class="style-name">经典阴影</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="tail">
                                        <div class="style-preview bubble-style-tail">
                                            <div class="preview-bubble sent-preview">带尖角</div>
                                            <div class="preview-bubble received-preview">气泡戳</div>
                                        </div>
                                        <div class="style-name">经典气泡</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="gradient">
                                        <div class="style-preview bubble-style-gradient">
                                            <div class="preview-bubble sent-preview">渐变色</div>
                                            <div class="preview-bubble received-preview">美观</div>
                                        </div>
                                        <div class="style-name">渐变样式</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="minimal">
                                        <div class="style-preview bubble-style-minimal">
                                            <div class="preview-bubble sent-preview">极简线条</div>
                                            <div class="preview-bubble received-preview">简约</div>
                                        </div>
                                        <div class="style-name">极简样式</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="neon">
                                        <div class="style-preview bubble-style-neon">
                                            <div class="preview-bubble sent-preview">霓虹发光</div>
                                            <div class="preview-bubble received-preview">科技感</div>
                                        </div>
                                        <div class="style-name">霓虹样式</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="paper">
                                        <div class="style-preview bubble-style-paper">
                                            <div class="preview-bubble sent-preview">纸张卡片</div>
                                            <div class="preview-bubble received-preview">质感</div>
                                        </div>
                                        <div class="style-name">纸张样式</div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="color-setting-group">
                                <label class="form-label">自定义颜色</label>
                                <div class="color-picker-container">
                                    <div class="flex-gap-15">
                                        <div class="flex-1">
                                            <label class="label-small">我的气泡</label>
                                            <input type="color" id="my-bubble-color" class="color-input" value="#007AFF">
                                        </div>
                                        <div class="flex-1">
                                            <label class="label-small">对方气泡</label>
                                            <input type="color" id="ai-bubble-color" class="color-input" value="#f0f0f0">
                                        </div>
                                    </div>
                                </div>
                                <div class="opacity-setting">
                                    <div class="flex-gap-15-mb-15">
                                        <div class="flex-1">
                                            <label class="label-small">我的气泡透明度：<span id="my-bubble-opacity-value">100%</span></label>
                                            <input type="range" id="my-bubble-opacity" min="0.1" max="1" step="0.1" value="1" class="width-100">
                                        </div>
                                        <div class="flex-1">
                                            <label class="label-small">对方气泡透明度：<span id="ai-bubble-opacity-value">100%</span></label>
                                            <input type="range" id="ai-bubble-opacity" min="0.1" max="1" step="0.1" value="1" class="width-100">
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="padding-setting">
                                    <label class="form-label">气泡大小调节</label>
                                    <div class="flex-gap-15-mb-10">
                                        <div class="flex-1">
                                            <label class="label-small">内边距：<span id="bubble-padding-value">中等</span></label>
                                            <input type="range" id="bubble-padding" min="4" max="16" step="2" value="12" class="width-100">
                                        </div>
                                    </div>
                                    <p class="tiny-text-gray margin-top-5">
                                        调整气泡内文字与边缘的距离，数值越大气泡越大
                                    </p>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('bubble-style-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveBubbleStyleSettings()">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 定时发布设置模态框 -->
                <div class="modal" id="schedule-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">定时发布设置</div>
                            <button class="modal-close" onclick="hideModal('schedule-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">
                                    <input type="checkbox" id="schedule-enabled" class="checkbox-with-margin">
                                    启用定时发布
                                </label>
                                <p class="small-text margin-top-5">
                                    开启后，角色会在指定时间点自动发布社交动态
                                </p>
                            </div>
                            <div class="form-group hide" id="schedule-times-group">
                                <label class="form-label">发布时间点</label>
                                <div id="schedule-times-container">
                                    <!-- 时间点将通过JS动态添加 -->
                                </div>
                                <button type="button" class="form-button form-button-secondary" onclick="addScheduleTime()">+ 添加时间点</button>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('schedule-settings-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveScheduleSettings()">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 身份选择器模态框 -->
                <!-- 身份选择模态框已移除，身份在创建对话时选择 -->
                
                <!-- 世界书挂载设置模态框 -->
                <div class="modal" id="worldbook-mount-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">世界书挂载设置</div>
                            <button class="modal-close" onclick="hideModal('worldbook-mount-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">
                                    <input type="checkbox" id="worldbook-mount-enabled" class="checkbox-with-margin">
                                    启用世界书挂载
                                </label>
                                <p class="small-text margin-top-5">
                                    开启后，AI会参考选定的世界书内容作为背景知识进行对话
                                </p>
                            </div>
                            <div class="form-group hide" id="worldbook-mount-details">
                                <label class="form-label">选择要挂载的世界书</label>
                                <div id="worldbook-mount-list" class="max-height-300-auto">
                                    <!-- 世界书列表将通过JS动态生成 -->
                                </div>
                                <p class="small-text margin-top-8">
                                    选择的世界书内容会作为背景知识提供给AI参考，帮助AI更好地理解对话上下文
                                </p>
                            </div>
                            <div class="setting-explanation">
                                <div class="explanation-text">
                                    <strong>功能说明：</strong><br>
                                    • <strong>世界书挂载：</strong>将选定的世界书内容作为AI的背景知识<br>
                                    • <strong>多选支持：</strong>可以同时挂载多个世界书，内容会合并使用<br>
                                    • <strong>智能应用：</strong>AI会根据对话内容智能引用相关的世界书知识<br>
                                    • <strong>优先级：</strong>世界书知识优先级低于角色设定和历史对话
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('worldbook-mount-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveWorldbookMountSettings()">保存</button>
                        </div>
                    </div>
                </div>

                <!-- 时间戳设置模态框 -->
                <div class="modal" id="timestamp-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">时间戳设置</div>
                            <button class="modal-close" onclick="hideModal('timestamp-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">
                                    <input type="checkbox" id="timestamp-modal-enabled" class="checkbox-with-margin" checked>
                                    显示时间戳
                                </label>
                                <p class="small-text margin-top-5">
                                    在聊天消息中显示时间信息
                                </p>
                            </div>
                            
                            <div class="form-group" id="timestamp-options-group">
                                <label class="form-label">时间戳位置</label>
                                <div class="timestamp-position-options">
                                    <label class="radio-option">
                                        <input type="radio" name="timestamp-position" value="center" checked>
                                        <span class="radio-custom"></span>
                                        <div class="option-content">
                                            <div class="option-label">居中显示</div>
                                            <div class="option-desc">时间戳显示在聊天中间，每5分钟出现一次</div>
                                        </div>
                                    </label>
                                    
                                    <label class="radio-option">
                                        <input type="radio" name="timestamp-position" value="bubble">
                                        <span class="radio-custom"></span>
                                        <div class="option-content">
                                            <div class="option-label">气泡外侧</div>
                                            <div class="option-desc">时间戳显示在每条消息气泡的外侧</div>
                                        </div>
                                    </label>
                                    
                                    <label class="radio-option">
                                        <input type="radio" name="timestamp-position" value="avatar">
                                        <span class="radio-custom"></span>
                                        <div class="option-content">
                                            <div class="option-label">头像下方</div>
                                            <div class="option-desc">时间戳显示在头像正下方位置</div>
                                        </div>
                                    </label>
                                    
                                    <label class="radio-option">
                                        <input type="radio" name="timestamp-position" value="inside">
                                        <span class="radio-custom"></span>
                                        <div class="option-content">
                                            <div class="option-label">气泡内</div>
                                            <div class="option-desc">时间戳显示在气泡内右下角，与文字齐平</div>
                                        </div>
                                    </label>
                                </div>
                            </div>
                            
                            <div class="setting-explanation">
                                <div class="explanation-text">
                                    <strong>位置说明：</strong><br>
                                    • <strong>居中显示：</strong>时间戳水平居中，仅在超过5分钟间隔时显示<br>
                                    • <strong>气泡外侧：</strong>每条消息都显示时间，用户消息在左下角，角色消息在右下角<br>
                                    • <strong>头像下方：</strong>时间戳显示在对应头像的正下方位置<br>
                                    • 所有时间戳均使用灰色小字显示，不影响聊天体验
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('timestamp-settings-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveTimestampSettings()">保存</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    <!-- 转账功能相关模态框 -->
    <div id="transfer-modal">
        <div class="transfer-content">
                            <div class="transfer-header">发起转账</div>
            <div class="transfer-input-group">
                <label for="transfer-amount">转账金额</label>
                                    <input type="number" id="transfer-amount" placeholder="0.00" min="0" max="1000000000" step="0.01">
            </div>
            <div class="transfer-input-group">
                <label for="transfer-note">备注 (可选)</label>
                                    <input type="text" id="transfer-note" placeholder="说点什么吧..." maxlength="20">
            </div>
            <div class="transfer-actions">
                <button id="transfer-cancel-btn">取消</button>
                <button id="transfer-confirm-btn">确认转账</button>
            </div>
        </div>
    </div>
    
    <div id="transfer-confirm-modal">
        <div class="transfer-confirm-content">
            <div class="transfer-confirm-title">收到一笔转账</div>
            <div class="transfer-confirm-info">
                <div class="transfer-confirm-amount">¥ 0.00</div>
                <div class="transfer-confirm-note">备注：</div>
            </div>
            <div class="transfer-confirm-actions">
                <button id="transfer-reject-btn">退回</button>
                <button id="transfer-accept-btn">确认收款</button>
                </div>
            </div>
        </div>

    <script>
        // 初始化Dexie数据库
        const db = new Dexie('PhoneChatDB');
        let activeGlobalWorldbooks = []; // 用于存储当前激活的全局世界书ID
        
        // 版本1：原始表结构
        db.version(1).stores({
            characters: '&id, name',
            contacts: '&id, characterId', 
            chatMessages: '&id, characterId, timestamp',
            apiSettings: '&id',
            customEmojis: '&id, description',
            wallpapers: '&id, type',
            worldbooks: '&id, name',
            groupChats: '&id, name',
            personas: '&id, name',
            globalSettings: '&id',
            appIcons: '&id, appId',
            chatSettings: '&id, chatId'
        });
        
        // 版本2：添加动态相关表
        db.version(2).stores({
            characters: '&id, name',
            contacts: '&id, characterId', 
            chatMessages: '&id, characterId, timestamp',
            apiSettings: '&id',
            customEmojis: '&id, description',
            wallpapers: '&id, type',
            worldbooks: '&id, name',
            groupChats: '&id, name',
            personas: '&id, name',
            globalSettings: '&id',
            appIcons: '&id, appId',
            chatSettings: '&id, chatId',
            // 动态相关表
            moments: '&id, authorId, timestamp',
            momentLikes: '[momentId+authorId], momentId, authorId',
            momentComments: '&id, momentId, authorId, timestamp'
        });

        // 版本3：添加最近使用表情包表
        db.version(4).stores({
            characters: '&id, name',
    contacts: '++id, characterId', 
            chatMessages: '&id, characterId, timestamp',
            apiSettings: '&id',
            customEmojis: '&id, description',
            wallpapers: '&id, type',
    worldbooks: '&id, name, isGlobal',
            groupChats: '&id, name',
            personas: '&id, name',
            globalSettings: '&id',
            appIcons: '&id, appId',
            chatSettings: '&id, chatId',
            moments: '&id, authorId, timestamp',
            momentLikes: '[momentId+authorId], momentId, authorId',
            momentComments: '&id, momentId, authorId, timestamp',
            recentEmojis: '&id, lastUsed'
        });


        // 全局变量
        let characters = [];
        let contacts = [];
        let currentChatCharacter = null;
        let chatMessages = {};
        let selectedMessageId = null;
        let personas = []; // 用户面具列表
        let currentPersona = null; // 当前使用的面具
        let editingPersona = null; // 正在编辑的面具
        let isMultiSelectMode = false; // 多选模式状态
        let selectedCharacters = []; // 选中的角色ID列表
        let currentEditingCharacterId = null; // 当前正在编辑的角色ID
        let groupChats = []; // 群聊列表
        let selectedGroupMembers = []; // 群聊成员选择
        let currentWorldbookTab = 'global';
        
        // 自定义表情包相关变量
        let customEmojis = []; // 用户上传的表情包
        let recentEmojis = []; // 最近使用的表情包
        let currentEmojiTab = 'recent'; // 当前表情包标签页
        
        // 消息多选删除相关变量
        let isMessageSelectionMode = false; // 消息选择模式
        let selectedMessages = new Set(); // 选中的消息ID集合
        
        // 消息列表多选相关变量
        let isMessageListMultiSelectMode = false; // 消息列表多选模式状态
        let selectedConversations = []; // 选中的对话框ID列表
        
        // 动态评论对话轮次追踪
        let commentConversationRounds = new Map(); // 格式: "momentId-characterId" => 轮次数
        
        let apiSettings = {
            type: 'openai',
            base: 'https://api.openai.com/v1',
            endpoint: '/chat/completions',
            key: '',
            model: 'gpt-3.5-turbo',
            temperature: 0.70
        };
        
        // 注意：记忆设置现在已改为每个聊天窗口独立的设置，存储在各自的聊天设置中
        
        let chatSettings = {
            themeColor: '#007AFF',
            theirBubbleColor: '#f0f0f0',
            myBubbleColor: '#007AFF',
            bubbleOpacity: 1,
            timestampEnabled: true,
            timestampPosition: 'center'
        };
        

        let selectedAppIcon = null;
        let selectedWallpaper = null;
        let colorPickerContext = null;
        let customIconImage = null;
        
        // 初始化应用
        document.addEventListener('DOMContentLoaded', async function() {
            updateTime();
            
            try {
            
            // 并行加载所有数据
            await Promise.all([
                loadCharacters(),
                loadContacts(), 
                loadChatMessages(),
    
                loadChatSettings(),
                loadApiSettings(),
                loadCustomEmojis()
            ]);
            const globalSettings = await db.globalSettings.get('main');
            if (globalSettings && globalSettings.activeGlobalWorldbooks) {
                activeGlobalWorldbooks = globalSettings.activeGlobalWorldbooks;
            }
            
            // 加载外观设置
            loadPhoneBorderSetting();
            loadScreenSize();
            loadFontSizeSettings();
            
            // 加载动态图片设置
            loadMomentsImages();
            
            // 加载其他设置（包括需要数据库的壁纸设置）
            await loadWallpaper();
            await loadAppIcons();
            loadSavedTheme();
            await loadWorldbooks();
            loadMusicData();
            await loadPersonas();
            await loadGroupChats();
            
            // 渲染界面 - 添加数据验证
            try {
                if (characters && contacts && chatMessages) {
            renderMessageList();
            renderContactList();
            renderCharacterList();
            renderPersonaList();
                } else {
                    console.warn('数据未完全加载，推迟界面渲染');
                    // 延迟重试渲染
                    setTimeout(() => {
                        renderMessageList();
                        renderContactList();
                        renderCharacterList();
                        renderPersonaList();
                    }, 500);
                }
            } catch (renderError) {
                console.error('界面渲染失败:', renderError);
                // 尝试重新初始化空数据
                if (!chatMessages) chatMessages = {};
                if (!contacts) contacts = [];
                if (!characters) characters = [];
                renderMessageList();
                renderContactList();
                renderCharacterList();
            }
            
            // 初始化时设置正确的按钮显示状态 - 延迟执行确保DOM加载完成
            setTimeout(() => {
                switchChatTab('message-list');
                // 确保app标题有chat-mode类和正确内容
                const appTitle = document.querySelector('#chat-screen .app-title');
                if (appTitle) {
                    appTitle.classList.add('chat-mode');
                    appTitle.textContent = '💬';
                }
                initializeChatSettings(); // 初始化聊天设置界面
                updateWorldbookMountDisplay(); // 更新世界书挂载显示
            }, 100);
            
            // 温度滑块显示
            const temperatureSlider = document.getElementById('temperature-slider');
            if (temperatureSlider) {
                temperatureSlider.addEventListener('input', function() {
                document.getElementById('temperature-value').textContent = parseFloat(this.value).toFixed(2);
            });
            }
            
            // 初始化API设置界面
            initializeApiSettings();
            
            // 透明度滑块显示
            document.getElementById('opacity-slider').addEventListener('input', function() {
                document.getElementById('opacity-value').textContent = Math.round(this.value * 100) + '%';
            });
            
            // 按Enter键发送消息
            document.getElementById('api-chat-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault(); // 防止换行
                    sendApiMessage();
                }
            });
            

            
            // 初始化头像上传功能
            initializeAvatarUpload();
            
            // 初始化表情包上传功能
            initializeEmojiUpload();
            
            // 初始化消息选择模式状态
            isMessageSelectionMode = false;
            selectedMessages.clear();
            
            // 图片上传
            document.getElementById('image-upload').addEventListener('change', function(e) {
                if (e.target.files && e.target.files[0]) {
                    const file = e.target.files[0];
                    
                    // 检查文件类型，GIF格式不被Gemini API支持
                    if (file.type === 'image/gif') {
                        alert('抱歉，Gemini API 不支持 GIF 格式的图片。\n\n请选择其他格式的图片，如：\n• JPEG\n• PNG\n• WEBP');
                        // 清空文件选择器
                        e.target.value = '';
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        // 🔥【修复】直接发送图片消息，就像正常的图片发送一样
                        sendImageMessage(event.target.result);
                    };
                    reader.readAsDataURL(file);
                }
                
                // 清空文件选择器，允许重复选择同一文件
                e.target.value = '';
            });
            
            // 自定义壁纸上传
            document.getElementById('custom-wallpaper-upload').addEventListener('change', function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        selectedWallpaper = event.target.result;
                        
                        // 更新预览容器
                        const previewContainer = document.getElementById('wallpaper-preview-container');
                        if (previewContainer) {
                            previewContainer.innerHTML = `<img src="${selectedWallpaper}" class="wallpaper-preview-image" alt="壁纸预览">`;
                        }
                        
                        // 不在这里立即应用到主界面，等用户点击应用时再应用
                    };
                    reader.readAsDataURL(e.target.files[0]);
                }
            });
            
            // 自定义图标上传
            document.getElementById('custom-icon-upload').addEventListener('change', function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        customIconImage = event.target.result;
                        // 更新预览
                        const previews = document.querySelectorAll('.icon-preview');
                        previews.forEach(preview => {
                            preview.style.backgroundImage = `url(${customIconImage})`;
                            preview.innerHTML = ''; // 移除图标
                        });
                    };
                    reader.readAsDataURL(e.target.files[0]);
                }
            });
            
            setInterval(updateTime, 1000);
            initBatteryManager();
            
            } catch (error) {
                console.error('应用初始化失败:', error);
                // 如果是数据库错误，尝试重置
                if (error.name === 'DataError' || error.name === 'InvalidStateError' || error.name === 'DexieError') {
                    console.log('检测到数据库错误，尝试重置数据库...');
                    if (confirm('应用初始化失败，是否重置数据库？\n注意：这将清除所有本地数据。')) {
                        await resetDatabase();
                    }
                } else {
                    alert('应用初始化失败，请刷新页面重试。');
                }
            }
        });
        
        // 显示/隐藏应用
        function showApp(appId) {
            if (event) event.preventDefault();
            
            // 隐藏所有app界面
            const allApps = document.querySelectorAll('.app-screen');
            allApps.forEach(app => {
                app.style.display = 'none';
            });
            
            // 隐藏主屏幕组件
            const clockContainer = document.getElementById('clock-container');
            const appGrid = document.getElementById('app-grid');
            if (clockContainer) clockContainer.style.display = 'none';
            if (appGrid) appGrid.style.display = 'none';
            
            // 显示目标界面
            document.getElementById(appId).style.display = 'flex';
            
            // 如果是聊天界面，刷新消息列表
            if (appId === 'chat-screen') {
                renderMessageList();
            }
            
            // 如果是API设置界面，初始化设置
            if (appId === 'api-settings-screen') {
                // 延迟一点时间确保DOM已渲染
                setTimeout(() => {
                    initializeApiSettings();
                }, 100);
            }
        }
        

        
        // 隐藏角色创建表单，返回到chat界面的通讯录
        function hideCharacterForm() {
            // 在隐藏表单时清空表单数据
            clearCharacterForm();
            
            hideApp('character-form-screen');
            showApp('chat-screen');
            switchChatTab('contact-list');
            // 手动触发标签切换的样式
            const chatTabs = document.querySelectorAll('.chat-tab');
            chatTabs.forEach(tab => {
                if (tab && tab.classList) {
                    tab.classList.remove('active');
                }
            });
            // 安全地添加active类到第二个标签（通讯录）
            if (chatTabs.length > 1 && chatTabs[1] && chatTabs[1].classList) {
                chatTabs[1].classList.add('active');
            }
        }
        
        function hideApp(appId) {
            document.getElementById(appId).style.display = 'none';
            
            // 检查是否所有应用都已隐藏，如果是，显示主屏幕组件
            const allApps = document.querySelectorAll('.app-screen');
            const hasVisibleApp = Array.from(allApps).some(app => 
                app.style.display === 'flex' || app.style.display === 'block'
            );
            
            if (!hasVisibleApp) {
                // 显示主屏幕组件
                const clockContainer = document.getElementById('clock-container');
                const appGrid = document.getElementById('app-grid');
                if (clockContainer) clockContainer.style.display = 'block';
                if (appGrid) appGrid.style.display = 'flex';
            }
        }
        
        // 显示/隐藏模态框
        function showModal(modalId) {
            document.getElementById(modalId).style.display = 'flex';
            
            // 如果是添加联系人模态框，渲染可选联系人
            if (modalId === 'add-contact-modal') {
                renderContactModal();
            }
        }
        
        function hideModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }
        
        // 切换照片文字显示
        function togglePhotoText(container, description) {
            const overlay = container.querySelector('.photo-text-overlay');
            const sparkles = container.querySelector('.sparkle-container');
            const badge = container.querySelector('.photo-badge');
            
            if (overlay.style.display === 'none') {
                // 显示文字，隐藏星星和标志
                overlay.style.display = 'flex';
                sparkles.style.opacity = '0';
                badge.style.opacity = '0.3';
            } else {
                // 隐藏文字，显示星星和标志
                overlay.style.display = 'none';
                sparkles.style.opacity = '1';
                badge.style.opacity = '1';
            }
        }

        // 显示用户照片描述
        function showUserPhotoDescription(description) {
            const modalHtml = `
                <div id="photo-description-modal" class="modal" style="display: flex; z-index: 10000; background: rgba(0, 0, 0, 0.8);">
                    <div class="magical-photo-modal">
                        <div class="photo-modal-bg"></div>
                        <div class="photo-modal-content">
                            <div class="photo-modal-header">
                                <i class="fas fa-camera photo-modal-icon"></i>
                                <div class="photo-modal-title">照片内容</div>
                            </div>
                            <div class="photo-modal-body">
                                <div class="photo-description-text">${description}</div>
                            </div>
                            <div class="photo-modal-footer">
                                <button class="photo-modal-btn" id="photo-description-close">确定</button>
                            </div>
                        </div>
                        <div class="modal-sparkles">
                            <div class="modal-sparkle modal-sparkle-1">✨</div>
                            <div class="modal-sparkle modal-sparkle-2">⭐</div>
                            <div class="modal-sparkle modal-sparkle-3">✨</div>
                            <div class="modal-sparkle modal-sparkle-4">⭐</div>
                            <div class="modal-sparkle modal-sparkle-5">💫</div>
                            <div class="modal-sparkle modal-sparkle-6">✨</div>
                            <div class="modal-sparkle modal-sparkle-7">⭐</div>
                            <div class="modal-sparkle modal-sparkle-8">💫</div>
                        </div>
                    </div>
                </div>
            `;
            
            // 添加到页面
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            
            const modal = document.getElementById('photo-description-modal');
            const closeBtn = document.getElementById('photo-description-close');
            
            // 关闭按钮事件
            closeBtn.onclick = () => {
                modal.remove();
            };
            
            // 点击背景关闭
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            };
        }

        // 自定义输入提示框
        function showCustomPrompt(title, placeholder, initialValue = '', type = 'text') {
            return new Promise(resolve => {
                // 创建模态框HTML
                const modalHtml = `
                    <div id="custom-prompt-modal" class="modal" style="display: flex; z-index: 10000;">
                        <div class="modal-content" style="max-width: 400px;">
                            <div class="modal-header">
                                <div class="modal-title">${title}</div>
                            </div>
                            <div class="modal-body">
                                <input type="${type}" id="custom-prompt-input" class="form-input" 
                                       placeholder="${placeholder}" value="${initialValue}"
                                       style="width: 100%; margin-top: 10px;">
                            </div>
                            <div class="modal-footer">
                                <button class="modal-button modal-secondary" id="custom-prompt-cancel">取消</button>
                                <button class="modal-button modal-primary" id="custom-prompt-confirm">确定</button>
                            </div>
                        </div>
                    </div>
                `;
                
                // 添加到页面
                document.body.insertAdjacentHTML('beforeend', modalHtml);
                
                const modal = document.getElementById('custom-prompt-modal');
                const input = document.getElementById('custom-prompt-input');
                const confirmBtn = document.getElementById('custom-prompt-confirm');
                const cancelBtn = document.getElementById('custom-prompt-cancel');
                
                // 确定按钮事件
                confirmBtn.onclick = () => {
                    const value = input.value;
                    modal.remove();
                    resolve(value);
                };
                
                // 取消按钮事件
                cancelBtn.onclick = () => {
                    modal.remove();
                    resolve(null);
                };
                
                // 回车键确认
                input.onkeydown = (e) => {
                    if (e.key === 'Enter') {
                        confirmBtn.click();
                    }
                };
                
                // 聚焦输入框
                setTimeout(() => input.focus(), 100);
            });
        }
        
        // 切换聊天标签
        function switchChatTab(tabId) {
            // 移除所有标签的active类
            document.querySelectorAll('.chat-tab').forEach(tab => {
                if (tab && tab.classList) {
                    tab.classList.remove('active');
                }
            });
            
            // 添加当前标签的active类
            if (event && event.currentTarget && event.currentTarget.classList) {
                event.currentTarget.classList.add('active');
            } else {
                // 如果没有event对象，根据tabId设置active
                if (tabId === 'message-list') {
                    const messageTab = document.getElementById('message-tab');
                    if (messageTab && messageTab.classList) {
                        messageTab.classList.add('active');
                    }
                } else if (tabId === 'contact-list') {
                    const tabs = document.querySelectorAll('.chat-tab');
                    if (tabs.length > 1 && tabs[1] && tabs[1].classList) {
                        tabs[1].classList.add('active');
                    }
                } else if (tabId === 'moments-page') {
                    const tabs = document.querySelectorAll('.chat-tab');
                    if (tabs.length > 2 && tabs[2] && tabs[2].classList) {
                        tabs[2].classList.add('active');
                    }
                } else if (tabId === 'profile-page') {
                    const tabs = document.querySelectorAll('.chat-tab');
                    if (tabs.length > 3 && tabs[3] && tabs[3].classList) {
                        tabs[3].classList.add('active');
                    }
                }
            }
            
            // 隐藏所有内容
            const messageListEl = document.getElementById('message-list');
            const contactListEl = document.getElementById('contact-list');
            const profilePageEl = document.getElementById('profile-page');
            const momentsPageEl = document.getElementById('moments-page');
            const targetEl = document.getElementById(tabId);
            
            if (messageListEl) messageListEl.style.display = 'none';
            if (contactListEl) contactListEl.style.display = 'none';
            if (profilePageEl) profilePageEl.style.display = 'none';
            if (momentsPageEl) momentsPageEl.style.display = 'none';
            
            // 显示选中的内容
            if (targetEl) targetEl.style.display = 'block';
            
            // 控制app标题的渐变效果和内容
            const appTitle = document.querySelector('#chat-screen .app-title');
            if (appTitle) {
                if (tabId === 'message-list') {
                    appTitle.classList.add('chat-mode');
                    appTitle.textContent = '💬';
                } else if (tabId === 'contact-list') {
                    appTitle.classList.remove('chat-mode');
                    appTitle.textContent = '角色';
                } else if (tabId === 'moments-page') {
                    appTitle.classList.remove('chat-mode');
                                            appTitle.textContent = '动态';
                } else if (tabId === 'profile-page') {
                    appTitle.classList.remove('chat-mode');
                    appTitle.textContent = '我';
                }
            }
            
            // 控制加号按钮显示
            const addContactBtn = document.getElementById('add-contact-btn');
            const addChatBtn = document.getElementById('add-chat-btn');
            
            if (addContactBtn && addChatBtn) {
                if (tabId === 'contact-list') {
                    addContactBtn.style.display = 'flex';
                    addChatBtn.style.display = 'none';
                    // 修改加号按钮的点击事件为创建角色
                    addContactBtn.onclick = () => showCharacterForm();
                } else if (tabId === 'message-list') {
                    addContactBtn.style.display = 'none';
                    addChatBtn.style.display = 'flex';
                } else if (tabId === 'moments-page') {
                                            // 动态页面显示发布按钮
                    addContactBtn.style.display = 'flex';
                    addChatBtn.style.display = 'none';
                    // 修改加号按钮的点击事件为发布动态
                    addContactBtn.onclick = () => showPublishMoment();
                } else {
                    addContactBtn.style.display = 'none';
                    addChatBtn.style.display = 'none';
                }
            }
            
            // 如果是动态页面，检查是否需要加载动态内容
            if (tabId === 'moments-page') {
                // 只在动态列表为空时加载，避免重复显示
                const momentsList = document.getElementById('moments-list');
                if (momentsList && momentsList.children.length === 0) {
                loadMoments();
                }
                                        // 移除动态页面的padding，实现全屏效果
                const chatContent = document.getElementById('chat-content');
                if (chatContent) {
                    chatContent.style.padding = '0';
                }
            } else {
                // 其他页面恢复正常padding
                const chatContent = document.getElementById('chat-content');
                if (chatContent) {
                    chatContent.style.padding = '15px';
                }
                
                // 停止时间更新器（节省资源）
                stopTimeUpdater();
            }
        }
        
        // 更新时间
        function updateTime() {
            const now = new Date();
            const hours = now.getHours().toString().padStart(2, '0');
            const minutes = now.getMinutes().toString().padStart(2, '0');
            const timeString = `${hours}:${minutes}`;
            
            // 更新状态栏时间
            const statusTime = document.getElementById('status-bar-time');
            if (statusTime) {
                statusTime.textContent = timeString;
            }
            
            // 更新应用内状态栏时间
            const appStatusTimes = document.querySelectorAll('.app-status-time');
            appStatusTimes.forEach(element => {
                element.textContent = timeString;
            });
            
            // 更新主时钟
            const mainTime = document.getElementById('main-time');
            if (mainTime) {
                mainTime.textContent = timeString;
            }
            
            // 更新日期
            const mainDate = document.getElementById('main-date');
            if (mainDate) {
                const date = now.toLocaleDateString('zh-CN', { 
                    month: 'long', 
                    day: 'numeric',
                    weekday: 'long'
                });
                mainDate.textContent = date;
            }
        }
        
        // 加载角色数据 - 使用IndexedDB（包含数据迁移）
        async function loadCharacters() {
            try {
                // 先检查IndexedDB中是否有数据
                const savedCharacters = await db.characters.toArray();
                
                if (savedCharacters.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('characters');
                    if (localStorageData) {
                        console.log('检测到localStorage中的角色数据，开始迁移...');
                        const localCharacters = JSON.parse(localStorageData);
                        
                        if (localCharacters.length > 0) {
                            // 迁移数据到IndexedDB
                            await db.characters.bulkAdd(localCharacters);
                            characters = localCharacters;
                            console.log('角色数据迁移完成:', characters);
                            // 可选：清除localStorage中的旧数据
                            // localStorage.removeItem('characters');
                        } else {
                            characters = [];
                        }
                    } else {
                        characters = [];
                    }
                } else {
                    // IndexedDB中有数据，直接使用
                    characters = savedCharacters;
                    console.log('从IndexedDB加载角色数据:', characters);
                }
            } catch (error) {
                console.error('加载角色数据失败:', error);
                // 如果IndexedDB失败，尝试从localStorage加载
                const localStorageData = localStorage.getItem('characters');
                if (localStorageData) {
                    characters = JSON.parse(localStorageData);
                    console.log('从localStorage备份加载角色数据:', characters);
                } else {
                    characters = [];
                }
            }
        }
        
        // 保存角色数据 - 使用IndexedDB
        async function saveCharacters() {
            try {
                console.log('保存角色数据到IndexedDB:', characters);
                
                // 清空现有数据
                await db.characters.clear();
                
                // 批量插入新数据
                if (characters.length > 0) {
                    await db.characters.bulkAdd(characters);
                }
                
                console.log('角色数据保存成功');
            } catch (error) {
                console.error('保存角色时发生错误:', error);
                alert('保存角色时发生错误: ' + error.message);
                throw error;
            }
        }
        
        // 显示存储使用情况
        function showStorageUsage() {
            const usage = [];
            
            // 计算各种数据的大小
            const characters = localStorage.getItem('characters') || '[]';
            const chatMessages = localStorage.getItem('chatMessages') || '{}';
            const customEmojis = localStorage.getItem('customEmojis') || '[]';
            
            usage.push(`角色数据: ${(characters.length / 1024).toFixed(1)} KB`);
            usage.push(`聊天记录: ${(chatMessages.length / 1024).toFixed(1)} KB`);
            usage.push(`表情包: ${(customEmojis.length / 1024).toFixed(1)} KB`);
            
            const total = characters.length + chatMessages.length + customEmojis.length;
            usage.push(`总计: ${(total / 1024).toFixed(1)} KB`);
            
            console.log('存储使用情况:\n' + usage.join('\n'));
            alert('存储使用情况:\n' + usage.join('\n'));
        }
        
        // 加载联系人数据 - 使用IndexedDB（包含数据迁移）
        async function loadContacts() {
            try {
                const savedContacts = await db.contacts.toArray();
        // 关键修复：过滤掉所有无效的联系人数据，确保列表干净
        contacts = savedContacts
            .map(contact => contact.characterId) // 提取ID
            .filter(id => id !== undefined && id !== null); // 只保留有效的ID

        // 自动清理重复的联系人ID，增强数据库稳定性
        const uniqueContacts = [...new Set(contacts)];
        if (uniqueContacts.length < contacts.length) {
            console.warn('发现了重复的联系人ID，已自动清理。');
            contacts = uniqueContacts;
            // 清理后，立即用干净的数据覆盖数据库
            await saveContacts();
        }

                    console.log('从IndexedDB加载联系人:', contacts);
            } catch (error) {
                console.error('加载联系人失败:', error);
        contacts = []; // 如果出错，确保联系人列表为空，防止程序崩溃
            }
        }
        
        // 保存联系人数据 - 使用IndexedDB
        async function saveContacts() {
            try {
        // 过滤掉任何可能存在的无效ID
        const validContacts = contacts.filter(id => id); 
        // 将联系人ID列表转换为数据库需要的对象数组格式
        const contactArray = validContacts.map(id => ({ characterId: id }));

        await db.transaction('rw', db.contacts, async () => {
            // 先清空旧表，再批量写入新数据
                await db.contacts.clear();
                if (contactArray.length > 0) {
                    await db.contacts.bulkAdd(contactArray);
                }
        });
            } catch (error) {
                console.error('保存联系人失败:', error);
            }
        }
        
        // 加载聊天消息 - 使用IndexedDB（包含数据迁移）
        async function loadChatMessages() {
            try {
                const savedMessages = await db.chatMessages.toArray();
                chatMessages = {};
                
                if (savedMessages.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('chatMessages');
                    if (localStorageData) {
                        console.log('检测到localStorage中的聊天数据，开始迁移...');
                        const localMessages = JSON.parse(localStorageData);
                        
                        // 将对象格式转换为数组格式存储到IndexedDB
                        const messageArray = [];
                        for (const [characterId, messages] of Object.entries(localMessages)) {
                            for (const message of messages) {
                                messageArray.push({
                                    id: `${characterId}_${message.id || message.timestamp}`,
                                    characterId: characterId,
                                    timestamp: message.timestamp,
                                    messageData: message
                                });
                            }
                        }
                        
                        if (messageArray.length > 0) {
                            await db.chatMessages.bulkAdd(messageArray);
                        }
                        
                        chatMessages = localMessages;
                        console.log('聊天消息迁移完成:', chatMessages);
                    }
                } else {
                    // 将数组格式转换回对象格式
                    for (const msgRecord of savedMessages) {
                        const characterId = msgRecord.characterId;
                        if (!chatMessages[characterId]) {
                            chatMessages[characterId] = [];
                        }
                        // 🔥【新增】检查消息数据是否有效，过滤空值
                        if (msgRecord.messageData && typeof msgRecord.messageData === 'object') {
                        chatMessages[characterId].push(msgRecord.messageData);
                        }
                    }
                    
                    // 按时间戳排序并清理空值
                    for (const characterId in chatMessages) {
                        // 🔥【新增】过滤掉null、undefined或无效的消息
                        chatMessages[characterId] = chatMessages[characterId]
                            .filter(msg => msg && typeof msg === 'object' && msg.timestamp)
                            .sort((a, b) => a.timestamp - b.timestamp);
                    }
                    
                    console.log('从IndexedDB加载聊天消息:', chatMessages);
                }
            } catch (error) {
                console.error('加载聊天消息失败:', error);
                // 如果IndexedDB失败，尝试从localStorage加载
                const localStorageData = localStorage.getItem('chatMessages');
                if (localStorageData) {
                    chatMessages = JSON.parse(localStorageData);
                    console.log('从localStorage备份加载聊天消息:', chatMessages);
                } else {
                    chatMessages = {};
                }
            }
        }
        
        // 防抖保存计时器
        let saveMessagesTimer = null;
        let isSaving = false; // 防止并发保存
        
        // 防抖版本的保存函数
        function saveChatMessages() {
            // 清除之前的计时器
            if (saveMessagesTimer) {
                clearTimeout(saveMessagesTimer);
            }
            
            // 设置新的计时器，500ms后执行保存
            saveMessagesTimer = setTimeout(async () => {
                if (isSaving) {
                    console.log('正在保存中，跳过此次保存请求');
                    return;
                }
                await saveChatMessagesImmediate();
            }, 500);
        }
        
        // 立即保存聊天消息 - 使用IndexedDB
        async function saveChatMessagesImmediate() {
            if (isSaving) {
                console.log('保存操作正在进行中，跳过');
                return;
            }
            
            isSaving = true;
            
            try {
                console.log('保存聊天消息到IndexedDB');
                
                // 将chatMessages对象转换为数组格式存储
                const messageArray = [];
                let globalSequentialId = 0; // 全局顺序ID确保唯一性
                const usedIds = new Set(); // 用于检测ID重复
                
                for (const [characterId, messages] of Object.entries(chatMessages)) {
                    for (let i = 0; i < messages.length; i++) {
                        const message = messages[i];
                        
                        // 生成唯一的主键
                        let uniqueId = `${characterId}_${globalSequentialId++}`;
                        
                        // 确保ID绝对唯一
                        while (usedIds.has(uniqueId)) {
                            uniqueId = `${characterId}_${globalSequentialId++}`;
                        }
                        usedIds.add(uniqueId);
                        
                        messageArray.push({
                            id: uniqueId,
                            characterId: characterId,
                            timestamp: message.timestamp,
                            messageOrder: i,
                            originalMessageId: message.id, // 保留原始消息ID作为数据
                            messageData: message
                        });
                    }
                }
                
                // 清空现有消息
                await db.chatMessages.clear();
                
                // 批量插入新消息
                if (messageArray.length > 0) {
                    await db.chatMessages.bulkAdd(messageArray);
                }
                
                console.log('聊天消息保存成功，共保存', messageArray.length, '条消息');
            } catch (error) {
                console.error('保存聊天消息失败:', error);
                
                // 如果批量保存失败，使用简化的重试机制
                try {
                    console.log('使用简化保存策略重试...');
                    await db.chatMessages.clear();
                    
                    // 只保存最近的1000条消息，避免过大的数据集
                    const messageArray = [];
                    let globalSequentialId = 0;
                    let totalMessages = 0;
                    
                    // 先计算总消息数
                    for (const messages of Object.values(chatMessages)) {
                        totalMessages += messages.length;
                    }
                    
                    const maxMessages = 1000;
                    const skipCount = Math.max(0, totalMessages - maxMessages);
                    let currentSkip = 0;
                    
                    for (const [characterId, messages] of Object.entries(chatMessages)) {
                        for (let i = 0; i < messages.length; i++) {
                            if (currentSkip < skipCount) {
                                currentSkip++;
                                continue;
                            }
                            
                            const message = messages[i];
                            messageArray.push({
                                id: `${characterId}_${globalSequentialId++}`,
                                characterId: characterId,
                                timestamp: message.timestamp,
                                messageOrder: i,
                                originalMessageId: message.id,
                                messageData: message
                            });
                        }
                    }
                    
                    if (messageArray.length > 0) {
                        await db.chatMessages.bulkAdd(messageArray);
                    }
                    
                    console.log('简化保存成功，保存了', messageArray.length, '条消息');
                } catch (fallbackError) {
                    console.error('简化保存也失败:', fallbackError);
                }
            } finally {
                isSaving = false;
            }
        }
        

        
        // 加载聊天设置 - 使用IndexedDB（包含数据迁移）
        async function loadChatSettings() {
            try {
                // 先从IndexedDB加载
                const savedChatSettings = await db.chatSettings.toArray();
                
                if (savedChatSettings.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('chatSettings');
                    if (localStorageData) {
                        console.log('检测到localStorage中的聊天设置数据，开始迁移...');
                        const localSettings = JSON.parse(localStorageData);
                        
                        // 转换为数组格式存储到IndexedDB
                        const settingsArray = Object.keys(localSettings).map(chatId => ({
                            id: chatId,
                            chatId: chatId,
                            settings: localSettings[chatId]
                        }));
                        
                        if (settingsArray.length > 0) {
                            await db.chatSettings.bulkAdd(settingsArray);
                            console.log('聊天设置数据迁移完成:', settingsArray);
                        }
                        
                        chatSettings = localSettings;
                    } else {
                        chatSettings = {};
                    }
                } else {
                    // IndexedDB中有数据，直接使用
                    console.log('从IndexedDB加载聊天设置数据:', savedChatSettings);
                    chatSettings = {};
                    savedChatSettings.forEach(item => {
                        chatSettings[item.chatId] = item.settings;
                    });
                }
            } catch (error) {
                console.error('加载聊天设置失败:', error);
                // 如果IndexedDB失败，回退到localStorage
                const localStorageData = localStorage.getItem('chatSettings');
                if (localStorageData) {
                    chatSettings = JSON.parse(localStorageData);
                    console.log('从localStorage备份加载聊天设置:', chatSettings);
                } else {
                    chatSettings = {};
                }
            }
        }
        
        // 保存聊天设置 - 使用IndexedDB避免localStorage容量限制
        async function saveChatSettings() {
            try {
                // 将chatSettings对象转换为数组格式存储到IndexedDB
                const chatSettingsArray = Object.keys(chatSettings).map(chatId => ({
                    id: chatId,
                    chatId: chatId,
                    settings: chatSettings[chatId]
                }));
                
                // 清空现有数据并存储新数据
                await db.chatSettings.clear();
                if (chatSettingsArray.length > 0) {
                    await db.chatSettings.bulkAdd(chatSettingsArray);
                }
                
                console.log('聊天设置已保存到IndexedDB');
            } catch (error) {
                console.error('保存聊天设置到IndexedDB失败，回退到localStorage:', error);
                
                // 如果IndexedDB失败，尝试压缩数据后存储到localStorage
                try {
                    // 创建一个精简版的设置，移除可能很大的图片数据
                    const compressedSettings = {};
                    Object.keys(chatSettings).forEach(chatId => {
                        compressedSettings[chatId] = { ...chatSettings[chatId] };
                        
                        // 不再自动移除头像，因为IndexedDB有足够的存储空间
                        // 如果真的需要压缩，用户可以手动选择
                        console.log(`聊天${chatId}设置大小:`, JSON.stringify(compressedSettings[chatId]).length);
                    });
                    
                    localStorage.setItem('chatSettings', JSON.stringify(compressedSettings));
                    console.log('已使用压缩版聊天设置保存到localStorage');
                } catch (localStorageError) {
                    console.error('localStorage也无法保存，存储空间可能已满:', localStorageError);
                    
                    // 显示用户友好的错误提示
                    alert('存储空间不足！\n\n可能的解决方案：\n1. 清理浏览器缓存\n2. 删除一些不必要的聊天记录\n3. 减少使用大尺寸的头像图片\n\n当前设置可能无法保存。');
                    throw localStorageError;
                }
            }
        }
        
        // === 后台互动系统 ===
        let backgroundTimers = {};

        // 初始化后台互动系统
        function initBackgroundInteractionSystem() {
            if (!currentChatCharacter) return;
            
            clearAllBackgroundTimers();
            
            const chatSettings = getCurrentChatSettings();
            if (!chatSettings.backgroundInteractionEnabled) return;
            
            const characterId = currentChatCharacter.id;
            
            // 设置主动聊天定时器
            if (chatSettings.backgroundChatEnabled) {
                const chatInterval = getBackgroundInterval(chatSettings.backgroundChatFrequency || 'low');
                backgroundTimers[characterId + '_chat'] = setInterval(() => {
                    triggerBackgroundChat(characterId);
                }, chatInterval);
                
                console.log(`${currentChatCharacter.name} 主动聊天已启用，间隔: ${Math.round(chatInterval/60000)}分钟`);
            }
            
            // 设置主动发动态定时器
            if (chatSettings.backgroundMomentsEnabled) {
                const momentsInterval = getBackgroundMomentsInterval(chatSettings.backgroundMomentsFrequency || 'low');
                backgroundTimers[characterId + '_moments'] = setInterval(() => {
                    triggerBackgroundMoments(characterId);
                }, momentsInterval);
                
                console.log(`${currentChatCharacter.name} 主动发动态已启用，间隔: ${Math.round(momentsInterval/60000)}分钟`);
            }
        }

        // 清除所有后台定时器
        function clearAllBackgroundTimers() {
            Object.values(backgroundTimers).forEach(timer => {
                if (timer) clearInterval(timer);
            });
            backgroundTimers = {};
        }

        // 获取后台聊天间隔时间
        function getBackgroundInterval(frequency) {
            switch (frequency) {
                case 'low':
                    return Math.random() * 60 * 60 * 1000 + 60 * 60 * 1000; // 1-2小时
                case 'medium':
                    return Math.random() * 30 * 60 * 1000 + 30 * 60 * 1000; // 30-60分钟
                case 'high':
                    return Math.random() * 20 * 60 * 1000 + 10 * 60 * 1000; // 10-30分钟
                default:
                    return Math.random() * 60 * 60 * 1000 + 60 * 60 * 1000; // 默认1-2小时
            }
        }

        // 获取后台动态间隔时间
        function getBackgroundMomentsInterval(frequency) {
            switch (frequency) {
                case 'low':
                    return Math.random() * 4 * 60 * 60 * 1000 + 4 * 60 * 60 * 1000; // 4-8小时
                case 'medium':
                    return Math.random() * 2 * 60 * 60 * 1000 + 2 * 60 * 60 * 1000; // 2-4小时
                case 'high':
                    return Math.random() * 60 * 60 * 1000 + 60 * 60 * 1000; // 1-2小时
                default:
                    return Math.random() * 4 * 60 * 60 * 1000 + 4 * 60 * 60 * 1000; // 默认4-8小时
            }
        }

        // 触发后台聊天
        async function triggerBackgroundChat(characterId) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;
                
                // 检查用户是否至少10分钟没有回复
                const messages = chatMessages[characterId] || [];
                const lastUserMessage = messages.slice().reverse().find(msg => msg.sender === 'user');
                
                if (lastUserMessage) {
                    const timeSinceLastUserMessage = Date.now() - lastUserMessage.timestamp;
                    const tenMinutes = 10 * 60 * 1000; // 10分钟
                    if (timeSinceLastUserMessage < tenMinutes) {
                        console.log(`${character.name} 跳过主动聊天：用户最近${Math.round(timeSinceLastUserMessage / 60000)}分钟前有回复`);
                        return; // 用户最近有活动，不发送自动消息
                    }
                }
                
                const chatSettings = getCurrentChatSettings();
                
                // 获取最近的聊天历史
                const maxMemory = chatSettings.historyCount || 5;
                const recentMessages = messages.slice(-maxMemory);
                
                // 获取最近的动态内容
                const recentMoments = await getRecentMoments(5);
                let momentsContext = '';
                if (recentMoments.length > 0) {
                    momentsContext = '\n\n最近的动态内容：\n' + 
                        recentMoments.map(moment => `${moment.nickname}: ${moment.text}`).join('\n');
                }
                
                // 构建聊天历史上下文
                let chatContext = '';
                if (recentMessages.length > 0) {
                    chatContext = '\n\n最近的聊天记录：\n' + 
                        recentMessages.map(msg => {
                            if (msg.sender === 'user') return `用户：${msg.content}`;
                            if (msg.sender === 'ai') return `${character.name}：${msg.content}`;
                            return '';
                        }).filter(Boolean).join('\n');
                }
                
                // 生成主动聊天内容
                const prompt = `你是${character.name}，你的人设如下：${character.bio}。

现在你要主动给用户发送一条消息。这条消息应该是：
1. 符合你的人设和性格
2. 自然、有趣、有互动性
3. 可以是问候、分享、询问等
4. 不要过于正式，要像朋友间的日常聊天
5. 如果有聊天历史，要基于历史内容进行自然的延续或回应
6. 可以适当提及最近的动态内容，让对话更自然${chatContext}${momentsContext}

请生成一条主动聊天的消息：`;

                const content = await generateAIResponse(prompt, character);
                if (content && content.trim()) {
                    // 添加到聊天记录
                    const message = {
                        id: Date.now().toString(),
                        sender: 'ai',
                        content: content.trim(),
                        timestamp: Date.now()
                    };
                    
                    if (!chatMessages[characterId]) {
                        chatMessages[characterId] = [];
                    }
                    
                    chatMessages[characterId].push(message);
                    saveChatMessages();
                    
                    // 如果当前正在和这个角色聊天，立即显示消息
                    if (currentChatCharacter && currentChatCharacter.id === characterId) {
                        renderChatMessages(characterId);
                    }
                    
                    // 更新消息列表
                    renderMessageList();
                    
                    console.log(`${character.name} 主动发送了消息: ${content.substring(0, 50)}...`);
                }
            } catch (error) {
                console.error('后台聊天失败:', error);
            }
        }

        // 触发后台发动态（测试版本，跳过冷却时间）
        async function triggerBackgroundMomentsTest(characterId) {
            console.log(`测试发布: 跳过冷却时间检查`);
            // 直接调用正常发布函数，但跳过冷却时间检查
            await triggerBackgroundMoments(characterId, true);
        }

        // 触发后台发动态
        async function triggerBackgroundMoments(characterId, skipCooldown = false) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;
                
                // 检查冷却时间（避免短时间内重复发布）
                if (!skipCooldown) {
                    const lastMomentTime = character.lastMomentTime || 0;
                    const cooldownTime = 30 * 60 * 1000; // 30分钟冷却时间
                    if (Date.now() - lastMomentTime < cooldownTime) {
                        console.log(`${character.name} 在冷却时间内，跳过发布动态`);
                        return;
                    }
                } else {
                    console.log(`${character.name} 测试发布: 跳过冷却时间检查`);
                }
                
                const chatSettings = getCurrentChatSettings();
                
                // 获取最近的聊天记录
                const messages = chatMessages[characterId] || [];
                const maxMemory = chatSettings.historyCount || 5;
                const recentMessages = messages.slice(-maxMemory);
                
                // 获取最近的动态内容
                const recentMoments = await getRecentMoments(5);
                
                // 构建上下文
                let chatContext = '';
                if (recentMessages.length > 0) {
                    chatContext = '\n\n最近的聊天记录：\n' + 
                        recentMessages.map(msg => {
                            if (msg.sender === 'user') return `用户：${msg.content}`;
                            if (msg.sender === 'ai') return `${character.name}：${msg.content}`;
                            return '';
                        }).filter(Boolean).join('\n');
                }
                
                let momentsContext = '';
                if (recentMoments.length > 0) {
                    momentsContext = '\n\n最近的动态内容：\n' + 
                        recentMoments.map(moment => `${moment.nickname}: ${moment.text}`).join('\n');
                }
                
                // 生成动态内容
                const prompt = `你是${character.name}，你的人设如下：${character.bio}。

现在你要发布一条动态。这条动态应该是：
1. 符合你的人设和性格
2. 生活化、有趣、有个性
3. 50-200字左右
4. 可以是心情、感悟、日常、分享等
5. 可以结合最近的聊天或动态内容作为灵感
6. 要有你独特的风格，不能和其他角色混淆
7. 支持换行显示，可以适当分段让内容更易读
8. 可以选择性地配图，如果想要配图，请直接换行，然后用斜体格式写：*[配图：详细的图片描述]*

## 配图规则（遵循）：
- 不需要每条动态都配图，只有当内容真的适合配图时才添加配图描述
- 图片描述要生动、具体，让人能通过文字想象出画面
- 以第三人称视角描述，例如：*[配图：照片里一只橘猫正懒洋洋地趴在窗台上晒太阳，阳光把它金色的毛照得发亮，背景是蔚蓝的天空和几朵白云。]*
- 图片描述要符合你的性格和当前情境

${chatContext}${momentsContext}

请生成一条符合你人设的动态内容：`;

                const content = await generateAIResponse(prompt, character);
                if (content && content.trim()) {
                    // 获取头像，确保安全
                    const avatar = getCharacterAvatar(character);
                    console.log(`${character.name} ${skipCooldown ? '测试' : '正常'}发布动态时获取的头像:`, avatar ? avatar.substring(0, 50) + '...' : 'null');
                    
                    // 发布动态
                    const moment = {
                        id: Date.now(),  // 使用数字ID而不是字符串
                        authorId: characterId,
                        nickname: character.name,
                        avatar: avatar, // 角色头像
                        text: content.trim(),
                        time: formatTime(new Date()),
                        timestamp: Date.now(),
                        characterId: characterId
                    };
                    
                    // 保存到数据库
                    await db.moments.add(moment);
                    
                    // 记录发布时间
                    character.lastMomentTime = Date.now();
                    saveCharacters();
                    
                    // 强制刷新动态显示（无论当前在哪个页面）
                    setTimeout(() => {
                        loadMoments();
                    }, 100);
                    
                    console.log(`${character.name} ${skipCooldown ? '测试' : '正常'}发布了动态: ${content.substring(0, 50)}...`);
                }
            } catch (error) {
                console.error('后台发动态失败:', error);
            }
        }

        // 获取最近的动态
        async function getRecentMoments(count = 5) {
            try {
                // 从数据库获取最新的动态数据
                const momentsData = await db.moments.orderBy('timestamp').reverse().limit(count).toArray();
                return momentsData || [];
            } catch (error) {
                console.error('获取最近动态失败:', error);
                return [];
            }
        }

        // 生成AI响应的包装函数，用于后台互动
        async function generateAIResponse(prompt, character) {
            try {
                // 使用现有的 callChatAPI 函数
                const response = await callChatAPI(prompt, character);
                return response;
            } catch (error) {
                console.error('AI响应生成失败:', error);
                return null;
            }
        }

        // 验证头像URL是否有效
        function isValidAvatarUrl(url) {
            if (!url || typeof url !== 'string') return false;
            
            // 检查base64格式
            if (url.startsWith('data:image/')) {
                // 更宽松的base64验证，只检查基本结构
                const parts = url.split(',');
                if (parts.length !== 2) {
                    console.warn('base64头像URL格式错误（缺少逗号分隔）:', url.substring(0, 50) + '...');
                    return false;
                }
                
                const header = parts[0];
                const data = parts[1];
                
                // 检查header是否包含必要信息
                if (!header.includes('data:image/') || !header.includes('base64')) {
                    console.warn('base64头像URL头部格式错误:', header);
                    return false;
                }
                
                // 检查base64数据是否为空或过长
                if (!data || data.length < 50) {
                    console.warn('base64头像数据为空或过短:', data.length);
                    return false;
                }
                
                if (data.length > 2000000) { // 2MB限制，更宽松
                    console.warn('base64头像数据过大:', data.length, '建议压缩后重新上传以提高性能');
                    // 不再直接拒绝，只是警告
                }
                
                // 简单检查base64字符是否合法
                const base64Chars = /^[A-Za-z0-9+/]*={0,2}$/;
                if (!base64Chars.test(data)) {
                    console.warn('base64头像数据包含非法字符');
                    return false;
                }
                
                return true;
            }
            
            // 检查HTTP(S) URL格式
            if (url.startsWith('http://') || url.startsWith('https://')) {
                try {
                    new URL(url);
                    return true;
                } catch (error) {
                    console.warn('无效的HTTP头像URL:', url);
                    return false;
                }
            }
            
            // 如果不是data:image或http(s)开头，考虑可能是其他有效格式
            console.warn('未知的头像URL格式:', url.substring(0, 50) + '...');
            return false;
        }

        // 获取角色的头像（用于动态发布）
        function getCharacterAvatar(character) {
            // 使用同步版本的设置获取，避免Promise问题
            const chatSettings = getChatSettingsSync(character.id);
            
            // 优先级1：如果角色有聊天窗口的动态头像设置，使用那个
            if (chatSettings.aiDynamicAvatar && chatSettings.aiDynamicAvatar.trim()) {
                const avatar = chatSettings.aiDynamicAvatar;
                if (isValidAvatarUrl(avatar)) {
                    return avatar;
                } else {
                    console.warn(`角色${character.name}的动态头像无效，尝试使用其他头像`);
                }
            }
            
            // 优先级2：如果角色有聊天窗口的头像设置，使用那个
            if (chatSettings.aiChatAvatar && chatSettings.aiChatAvatar.trim()) {
                const avatar = chatSettings.aiChatAvatar;
                if (isValidAvatarUrl(avatar)) {
                    return avatar;
                } else {
                    console.warn(`角色${character.name}的聊天头像无效，尝试使用角色卡头像`);
                }
            }
            
            // 优先级3：使用角色卡里的头像
            if (character.avatarUrl && character.avatarUrl.trim()) {
                const avatar = character.avatarUrl;
                if (isValidAvatarUrl(avatar)) {
                    return avatar;
                } else {
                    console.warn(`角色${character.name}的角色卡头像无效，大小或格式问题`);
                }
            }
            
            console.log(`角色${character.name}没有可用的头像`);
            return null;
        }

        // 获取指定角色的聊天设置 - 使用IndexedDB
        async function getChatSettings(characterId) {
            try {
                const chatSettingsRecord = await db.chatSettings.get(characterId);
                if (chatSettingsRecord) {
                    return chatSettingsRecord.settings;
                }
                
                // 如果IndexedDB中没有，尝试从localStorage迁移
                const savedSettings = localStorage.getItem(`chatSettings_${characterId}`);
                if (savedSettings) {
                    console.log(`迁移角色 ${characterId} 的聊天设置到IndexedDB`);
                    const settings = JSON.parse(savedSettings);
                    
                    // 保存到IndexedDB
                    await db.chatSettings.put({
                        id: characterId,
                        chatId: characterId,
                        settings: settings
                    });
                    
                    return settings;
                }
                
                return {};
            } catch (error) {
                console.error('获取聊天设置失败:', error);
                // 回退到localStorage
                const savedSettings = localStorage.getItem(`chatSettings_${characterId}`);
                return savedSettings ? JSON.parse(savedSettings) : {};
            }
        }
        
        // 同步版本的getChatSettings（用于不支持async的地方）
        function getChatSettingsSync(characterId) {
            const savedSettings = localStorage.getItem(`chatSettings_${characterId}`);
            return savedSettings ? JSON.parse(savedSettings) : {};
        }

        // 格式化动态文字，支持分行和配图描述
        function formatMomentText(text) {
            if (!text) return '';
            
            // 替换换行符为<br>标签，支持分行显示
            let formattedText = text.replace(/\n/g, '<br>');
            
            // 处理配图描述：匹配*[配图：描述]*格式
            formattedText = formattedText.replace(/\*\[配图：([^\]]+)\]\*/g, function(match, description) {
                return `<span style="font-style: italic; color: #999; font-size: 13px; line-height: 1.4;">[配图：${description}]</span>`;
            });
            
            return formattedText;
        }

        // 调试角色动态头像
        function debugMomentAvatar(momentId) {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) {
                console.log('找不到动态元素');
                return;
            }
            
            // 从IndexedDB获取动态数据
            db.moments.get(parseInt(momentId)).then(moment => {
                console.log('=== 动态头像调试 ===');
                console.log('动态ID:', momentId);
                console.log('角色ID:', moment.characterId);
                console.log('保存的头像:', moment.avatar ? moment.avatar.substring(0, 50) + '...' : 'null');
                
                if (moment.characterId && moment.characterId !== 'user') {
                    const character = characters.find(c => c.id === moment.characterId);
                    if (character) {
                        console.log('找到角色:', character.name);
                        console.log('角色卡头像:', character.avatarUrl ? character.avatarUrl.substring(0, 50) + '...' : 'null');
                    } else {
                        console.log('找不到角色数据');
                    }
                }
                
                const avatarImg = momentElement.querySelector('.moment-avatar img');
                if (avatarImg) {
                    console.log('当前显示的头像URL:', avatarImg.src ? avatarImg.src.substring(0, 50) + '...' : 'null');
                }
            });
        }
        
        // 简单的头像数据修复
        async function fixAvatarData() {
            console.log('开始修复头像数据...');
            let fixedCount = 0;
            
            try {
                // 清理角色设置中的截断头像
                for (const character of characters) {
                    const chatSettings = await getChatSettings(character.id);
                    let needSave = false;
                    
                    if (chatSettings.aiDynamicAvatar) {
                        const avatar = chatSettings.aiDynamicAvatar;
                        if (avatar.startsWith('data:image/') && !avatar.includes('=') && avatar.split(',').length === 2) {
                            console.log(`清理${character.name}的动态头像设置`);
                            delete chatSettings.aiDynamicAvatar;
                            needSave = true;
                            fixedCount++;
                        }
                    }
                    
                    if (chatSettings.aiChatAvatar) {
                        const avatar = chatSettings.aiChatAvatar;
                        if (avatar.startsWith('data:image/') && !avatar.includes('=') && avatar.split(',').length === 2) {
                            console.log(`清理${character.name}的聊天头像设置`);
                            delete chatSettings.aiChatAvatar;
                            needSave = true;
                            fixedCount++;
                        }
                    }
                    
                    if (needSave) {
                        // 保存到IndexedDB而不是localStorage
                        await db.chatSettings.put({
                            id: character.id,
                            chatId: character.id,
                            settings: chatSettings
                        });
                    }
                }
                
                // 清理动态数据库中的截断头像
                const allMoments = await db.moments.toArray();
                let momentFixedCount = 0;
                
                for (const moment of allMoments) {
                    if (moment.avatar && moment.avatar.startsWith('data:image/')) {
                        // 检查是否是截断的头像（以VNEKhsVJik结尾的是截断的）
                        if (moment.avatar.endsWith('VNEKhsVJik') || moment.avatar.endsWith('VNEKhsVJik:1') || 
                            (!moment.avatar.includes('=') && moment.avatar.split(',').length === 2)) {
                            console.log(`清理动态 ${moment.id} 的截断头像`);
                            await db.moments.update(moment.id, { avatar: null });
                            momentFixedCount++;
                        }
                    }
                }
                
                const totalFixed = fixedCount + momentFixedCount;
                console.log(`修复完成: 清理了${fixedCount}个设置头像, ${momentFixedCount}个动态头像`);
                
                alert(`修复完成！\n清理了 ${fixedCount} 个设置中的截断头像\n清理了 ${momentFixedCount} 个动态中的截断头像\n\n请重新为角色设置头像`);
                
                if (totalFixed > 0) {
                    loadMoments();
                }
            } catch (error) {
                console.error('修复失败:', error);
                alert('修复失败: ' + error.message);
            }
        }

        // 页面卸载时清理后台定时器
        window.addEventListener('beforeunload', function() {
            clearAllBackgroundTimers();
        });


        // 加载壁纸 - 使用IndexedDB（包含数据迁移）
        async function loadWallpaper() {
            try {
                // 先从IndexedDB加载
                const savedWallpaper = await db.wallpapers.get('main');
            
            if (savedWallpaper) {
                    selectedWallpaper = savedWallpaper.data;
                
                    if (savedWallpaper.type === 'image' && savedWallpaper.data.startsWith('data:image')) {
                    // 加载上传的图片
                        document.querySelector('.wallpaper').style.backgroundImage = `url(${savedWallpaper.data})`;
                    } else if (savedWallpaper.type === 'gradient' || savedWallpaper.data.startsWith('linear-gradient')) {
                    // 加载渐变背景
                        document.querySelector('.wallpaper').style.backgroundImage = savedWallpaper.data;
                } else {
                    // 加载纯色背景
                        document.querySelector('.wallpaper').style.backgroundColor = savedWallpaper.data;
                    document.querySelector('.wallpaper').style.backgroundImage = 'none';
                }
                
                document.querySelector('.wallpaper').style.backgroundSize = '100% 100%';
                document.querySelector('.wallpaper').style.backgroundPosition = 'center';
                } else {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localWallpaper = localStorage.getItem('wallpaper');
                    const wallpaperType = localStorage.getItem('wallpaperType');
                    
                    if (localWallpaper) {
                        console.log('检测到localStorage中的壁纸数据，开始迁移...');
                        selectedWallpaper = localWallpaper;
                        
                        // 迁移到IndexedDB
                        await db.wallpapers.add({
                            id: 'main',
                            type: wallpaperType || 'gradient',
                            data: localWallpaper
                        });
                        
                        if (wallpaperType === 'image' && localWallpaper.startsWith('data:image')) {
                            document.querySelector('.wallpaper').style.backgroundImage = `url(${localWallpaper})`;
                        } else if (wallpaperType === 'gradient' || localWallpaper.startsWith('linear-gradient')) {
                            document.querySelector('.wallpaper').style.backgroundImage = localWallpaper;
                        } else {
                            document.querySelector('.wallpaper').style.backgroundColor = localWallpaper;
                            document.querySelector('.wallpaper').style.backgroundImage = 'none';
                        }
                        
                        document.querySelector('.wallpaper').style.backgroundSize = '100% 100%';
                        document.querySelector('.wallpaper').style.backgroundPosition = 'center';
                        
                        console.log('壁纸数据迁移完成');
                    }
                }
            } catch (error) {
                console.error('加载壁纸失败:', error);
                // 如果IndexedDB失败，回退到localStorage
                const localWallpaper = localStorage.getItem('wallpaper');
                const wallpaperType = localStorage.getItem('wallpaperType');
                
                if (localWallpaper) {
                    selectedWallpaper = localWallpaper;
                    
                    if (wallpaperType === 'image' && localWallpaper.startsWith('data:image')) {
                        document.querySelector('.wallpaper').style.backgroundImage = `url(${localWallpaper})`;
                    } else if (wallpaperType === 'gradient' || localWallpaper.startsWith('linear-gradient')) {
                        document.querySelector('.wallpaper').style.backgroundImage = localWallpaper;
                    } else {
                        document.querySelector('.wallpaper').style.backgroundColor = localWallpaper;
                        document.querySelector('.wallpaper').style.backgroundImage = 'none';
                    }
                    
                    document.querySelector('.wallpaper').style.backgroundSize = '100% 100%';
                    document.querySelector('.wallpaper').style.backgroundPosition = 'center';
                }
            }
        }
        
        // 加载应用图标 - 使用IndexedDB（包含数据迁移）
        async function loadAppIcons() {
            try {
                // 先从IndexedDB加载
                const savedIcons = await db.appIcons.toArray();
                
                if (savedIcons.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('appIcons');
                    if (localStorageData) {
                        console.log('检测到localStorage中的应用图标数据，开始迁移...');
                        const localIcons = JSON.parse(localStorageData);
                        
                        // 转换为数组格式存储到IndexedDB
                        const iconArray = Object.keys(localIcons).map(appId => ({
                            id: appId,
                            appId: appId,
                            iconClass: localIcons[appId]
                        }));
                        
                        if (iconArray.length > 0) {
                            await db.appIcons.bulkAdd(iconArray);
                            console.log('应用图标数据迁移完成:', iconArray);
                        }
                        
                        // 应用图标
                        Object.keys(localIcons).forEach(appId => {
                            const iconElement = document.querySelector(`.app[onclick="showApp('${appId}')"] .app-icon i`);
                            if (iconElement) {
                                iconElement.className = localIcons[appId];
                            }
                        });
                    }
                } else {
                    // IndexedDB中有数据，直接使用
                    console.log('从IndexedDB加载应用图标数据:', savedIcons);
                    savedIcons.forEach(iconData => {
                        const iconElement = document.querySelector(`.app[onclick="showApp('${iconData.appId}')"] .app-icon i`);
                        if (iconElement) {
                            iconElement.className = iconData.iconClass;
                        }
                    });
                }
            } catch (error) {
                console.error('加载应用图标失败:', error);
                // 如果IndexedDB失败，回退到localStorage
                const localStorageData = localStorage.getItem('appIcons');
                if (localStorageData) {
                    const icons = JSON.parse(localStorageData);
                Object.keys(icons).forEach(appId => {
                    const iconElement = document.querySelector(`.app[onclick="showApp('${appId}')"] .app-icon i`);
                    if (iconElement) {
                        iconElement.className = icons[appId];
                    }
                });
                }
            }
        }
        
        // 加载API设置 - 使用IndexedDB
        async function loadApiSettings() {
            try {
                // 先从IndexedDB尝试加载
                const savedSettings = await db.apiSettings.get('main');
            if (savedSettings) {
                    apiSettings = savedSettings.settings;
                } else {
                    // 尝试从localStorage迁移
                    const localSettings = localStorage.getItem('apiSettings');
                    if (localSettings) {
                        console.log('迁移API设置到IndexedDB');
                        apiSettings = JSON.parse(localSettings);
                        
                        // 保存到IndexedDB
                        await db.apiSettings.put({
                            id: 'main',
                            settings: apiSettings
                        });
                    } else {
                        // 使用默认设置
                        apiSettings = {
                            type: 'gemini',
                            base: 'https://generativelanguage.googleapis.com/v1beta',
                            endpoint: '/chat/completions',
                            key: '',
                            model: 'gemini-2.0-flash-exp',
                            temperature: 0.70
                        };
                    }
                }
                
                // 更新表单显示
                if (document.getElementById('api-type')) {
                    const apiType = apiSettings.type || 'openai';
                    document.getElementById('api-type').value = apiType;
                    document.getElementById('api-base').value = apiSettings.base || (apiType === 'gemini' ? 'https://generativelanguage.googleapis.com/v1beta' : 'https://api.openai.com/v1');
                    document.getElementById('api-endpoint').value = apiSettings.endpoint || '/chat/completions';
                    document.getElementById('api-key').value = apiSettings.key || '';
                    
                    // 处理模型设置
                    if (apiType === 'gemini') {
                        document.getElementById('api-model-select').value = apiSettings.model || 'gemini-2.0-flash-exp';
                        document.getElementById('api-model').value = apiSettings.model || 'gemini-2.0-flash-exp';
                    } else {
                        document.getElementById('api-model').value = apiSettings.model || 'gpt-3.5-turbo';
                    }
                    
                    document.getElementById('api-temperature').value = apiSettings.temperature || 0.70;
                    document.getElementById('temperature-value').textContent = (apiSettings.temperature || 0.70).toFixed(2);
                    
                    // 处理最大token数设置

                    
                    // 触发API类型变化处理，确保界面正确显示
                    onApiTypeChange();
                }
            } catch (error) {
                console.error('加载API设置失败:', error);
                // 如果失败，使用默认设置
            apiSettings = {
                type: 'gemini',
                base: 'https://generativelanguage.googleapis.com/v1beta',
                endpoint: '/chat/completions',
                key: '',
                model: 'gemini-2.0-flash-exp',
                temperature: 0.70
            };
            
            // 确保界面元素正确显示
            if (document.getElementById('api-type')) {
                document.getElementById('api-type').value = 'gemini';
                document.getElementById('api-base').value = 'https://generativelanguage.googleapis.com/v1beta';
                document.getElementById('api-endpoint').value = '/chat/completions';
                document.getElementById('api-key').value = '';
                document.getElementById('api-model').value = 'gemini-2.0-flash-exp';
                document.getElementById('api-temperature').value = 0.70;
                document.getElementById('temperature-value').textContent = '0.70';
                
                // 触发API类型变化处理
                onApiTypeChange();
            }
            }
        }
        
        // 保存应用图标 - 使用IndexedDB
        async function saveAppIcons() {
            try {
                console.log('保存应用图标数据到IndexedDB...');
                
                const defaultIcons = {
                    'chat-screen': 'fas fa-comment-dots',
                    'forum-screen': 'fas fa-comments',
                    'music-screen': 'fas fa-music',
                    'game-screen': 'fas fa-gamepad',
                    'characters-screen': 'fas fa-user-friends',
                    'shop-screen': 'fas fa-shopping-bag',
                    'settings-screen': 'fas fa-cog'
                };
                
                if (selectedAppIcon) {
                    defaultIcons[selectedAppIcon.appId] = selectedAppIcon.iconClass;
                }
                
                // 转换为数组格式
                const iconArray = Object.keys(defaultIcons).map(appId => ({
                    id: appId,
                    appId: appId,
                    iconClass: defaultIcons[appId]
                }));
                
                // 清空现有数据并插入新数据
                await db.appIcons.clear();
                await db.appIcons.bulkAdd(iconArray);
                
                console.log('应用图标数据保存成功');
                
                // 刷新图标显示
                await loadAppIcons();
            } catch (error) {
                console.error('保存应用图标时发生错误:', error);
                // 如果IndexedDB失败，回退到localStorage
            const icons = {
                'chat-screen': 'fas fa-comment-dots',
                'weibo-screen': 'fab fa-weibo',
                'music-screen': 'fas fa-music',
                'album-screen': 'fas fa-images',
                'characters-screen': 'fas fa-user-friends',
                'shop-screen': 'fas fa-shopping-bag',
                'settings-screen': 'fas fa-cog'
            };
            
            if (selectedAppIcon) {
                icons[selectedAppIcon.appId] = selectedAppIcon.iconClass;
            }
            
            localStorage.setItem('appIcons', JSON.stringify(icons));
            loadAppIcons();
            }
        }
        
        // 渲染消息列表
        function renderMessageList() {
            const messageList = document.getElementById('message-list');
            messageList.innerHTML = '';
            
            // 添加多选模式的头部
            if (isMessageListMultiSelectMode) {
                const headerDiv = document.createElement('div');
                headerDiv.className = 'multiselect-header';
                headerDiv.innerHTML = `
                    <span>已选择 ${selectedConversations.length} 个对话</span>
                    <div>
                        <button onclick="deleteSelectedConversations()" class="delete-btn-red">删除</button>
                        <button onclick="exitMessageListMultiSelectMode()" class="cancel-btn-blue">取消</button>
                    </div>
                `;
                messageList.appendChild(headerDiv);
            }
            
            // 渲染单人聊天
            contacts.forEach(contactId => {
                const character = characters.find(c => c.id === contactId);
                if (character) {
                    // 🔥【修复】获取该聊天的昵称设置
                    const savedSettings = localStorage.getItem(`chatSettings_${character.id}`);
                    const chatSettings = savedSettings ? JSON.parse(savedSettings) : {};
                    const displayName = chatSettings.aiChatNickname || character.name;
                    
                    const messages = chatMessages[character.id] || [];
                let lastMessageRaw = '暂无消息';
                
                if (messages.length > 0) {
                    const lastMsg = messages[messages.length - 1];
                    
                    // 🔥【修复】检查消息是否有效，防止undefined错误
                    if (!lastMsg) {
                        lastMessageRaw = '暂无消息';
                    } else if (lastMsg.type === 'user_photo') {
                        lastMessageRaw = '[照片]';
                    } else if (lastMsg.type === 'ai_image') {
                        lastMessageRaw = '[图片]';
                    } else if (lastMsg.type === 'voice_message') {
                        lastMessageRaw = '[语音]';
                    } else if (lastMsg.type === 'transfer') {
                        lastMessageRaw = '[转账]';
                    } else if (lastMsg.type === 'recalled_message') {
                        lastMessageRaw = '[撤回了一条消息]';
                    } else if (lastMsg.type === 'location') {
                        lastMessageRaw = '[位置]';
                    } else if (lastMsg.sender === 'system') {
                        lastMessageRaw = lastMsg.content || '[系统消息]';
                    } else if (lastMsg.isEmoji) {
                        lastMessageRaw = '[表情]';
                    } else {
                        lastMessageRaw = lastMsg.content || '';
                    }
                }
                
                const lastMessage = truncateText(String(lastMessageRaw || '暂无消息'), 30);
                    const lastTime = messages.length > 0 ? formatTime(messages[messages.length - 1].timestamp) : '刚刚';
                    
                    const messageItem = document.createElement('div');
                    messageItem.className = `message-item ${isMessageListMultiSelectMode && selectedConversations.includes(character.id) ? 'selected' : ''}`;
                    messageItem.dataset.conversationId = character.id; // 添加对话ID
                    
                    // 根据模式设置不同的点击事件
                    if (isMessageListMultiSelectMode) {
                        messageItem.onclick = () => toggleConversationSelection(character.id);
                    } else {
                        // 使用变量来控制点击行为
                        let isLongPress = false;
                        
                        messageItem.onclick = (e) => {
                            if (!isLongPress) {
                                startChat(character);
                            }
                            isLongPress = false; // 重置标志
                        };
                        
                        // 添加长按事件（支持移动端和桌面端）
                        let pressTimer;
                        
                        // 移动端触摸事件
                        messageItem.addEventListener('touchstart', (e) => {
                            e.stopPropagation(); // 阻止事件冒泡
                            pressTimer = setTimeout(() => {
                                console.log('触摸长按触发，角色ID:', character.id);
                                isLongPress = true; // 设置长按标志
                                enterMessageListMultiSelectMode(character.id);
                                e.preventDefault();
                            }, 800); // 800ms长按
                        });
                        
                        messageItem.addEventListener('touchend', (e) => {
                            if (pressTimer) {
                                clearTimeout(pressTimer);
                                pressTimer = null;
                            }
                        });
                        
                        messageItem.addEventListener('touchmove', (e) => {
                            if (pressTimer) {
                                clearTimeout(pressTimer);
                                pressTimer = null;
                            }
                        });
                        
                        // 桌面端鼠标事件
                        messageItem.addEventListener('mousedown', (e) => {
                            if (e.button === 0) { // 左键
                                e.stopPropagation(); // 阻止事件冒泡
                                pressTimer = setTimeout(() => {
                                    console.log('鼠标长按触发，角色ID:', character.id);
                                    isLongPress = true; // 设置长按标志
                                    enterMessageListMultiSelectMode(character.id);
                                    e.preventDefault();
                                }, 800); // 800ms长按
                            }
                        });
                        
                        messageItem.addEventListener('mouseup', (e) => {
                            if (pressTimer) {
                                clearTimeout(pressTimer);
                                pressTimer = null;
                            }
                        });
                        
                        messageItem.addEventListener('mouseleave', (e) => {
                            if (pressTimer) {
                                clearTimeout(pressTimer);
                                pressTimer = null;
                            }
                        });
                        
                        // 右键点击进入多选模式（桌面端）
                        messageItem.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            enterMessageListMultiSelectMode(character.id);
                        });
                    }
                    
                    messageItem.innerHTML = `
                        ${isMessageListMultiSelectMode ? `
                            <div class="selection-checkbox ${selectedConversations.includes(character.id) ? 'selected' : ''}">
                                ${selectedConversations.includes(character.id) ? '<i class="fas fa-check check-icon-white"></i>' : ''}
                            </div>
                        ` : ''}
                        <div class="message-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                            ${character.avatarUrl ? '' : displayName.charAt(0)}
                        </div>
                        <div class="message-content">
                            <div class="message-name">${displayName}</div>
                            <div class="message-preview">${lastMessage}</div>
                        </div>
                        <div class="message-time">${lastTime}</div>
                    `;
                    
                    messageList.appendChild(messageItem);
                }
            });
            
            // 渲染群聊
            groupChats.forEach(group => {
                const messages = chatMessages[group.id] || [];
                let lastMessageRaw = '暂无消息';
                
                if (messages.length > 0) {
                    const lastMsg = messages[messages.length - 1];
                    
                    // 🔥【修复】检查消息是否有效，防止undefined错误
                    if (!lastMsg) {
                        lastMessageRaw = '暂无消息';
                    } else if (lastMsg.type === 'user_photo') {
                        lastMessageRaw = '[照片]';
                    } else if (lastMsg.type === 'ai_image') {
                        lastMessageRaw = '[图片]';
                    } else if (lastMsg.type === 'voice_message') {
                        lastMessageRaw = '[语音]';
                    } else if (lastMsg.type === 'transfer') {
                        lastMessageRaw = '[转账]';
                    } else if (lastMsg.type === 'recalled_message') {
                        lastMessageRaw = '[撤回了一条消息]';
                    } else if (lastMsg.type === 'location') {
                        lastMessageRaw = '[位置]';
                    } else if (lastMsg.sender === 'system') {
                        lastMessageRaw = lastMsg.content || '[系统消息]';
                    } else if (lastMsg.isEmoji) {
                        lastMessageRaw = '[表情]';
                    } else {
                        lastMessageRaw = lastMsg.content || '';
                    }
                }
                
                const lastMessage = truncateText(String(lastMessageRaw || '暂无消息'), 30);
                const lastTime = messages.length > 0 ? formatTime(messages[messages.length - 1].timestamp) : '刚刚';
                
                const messageItem = document.createElement('div');
                messageItem.className = `message-item ${isMessageListMultiSelectMode && selectedConversations.includes(group.id) ? 'selected' : ''}`;
                messageItem.dataset.conversationId = group.id; // 添加对话ID
                
                // 根据模式设置不同的点击事件
                if (isMessageListMultiSelectMode) {
                    messageItem.onclick = () => toggleConversationSelection(group.id);
                } else {
                messageItem.onclick = () => startChat(group);
                    
                    // 添加长按事件（支持移动端和桌面端）
                    let pressTimer;
                    
                    // 移动端触摸事件
                    messageItem.addEventListener('touchstart', (e) => {
                        e.stopPropagation(); // 阻止事件冒泡
                        pressTimer = setTimeout(() => {
                            console.log('触摸长按触发，群聊ID:', group.id);
                            enterMessageListMultiSelectMode(group.id);
                            e.preventDefault();
                        }, 800); // 800ms长按
                    });
                    
                    messageItem.addEventListener('touchend', (e) => {
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                        }
                    });
                    
                    messageItem.addEventListener('touchmove', (e) => {
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                        }
                    });
                    
                    // 桌面端鼠标事件
                    messageItem.addEventListener('mousedown', (e) => {
                        if (e.button === 0) { // 左键
                            e.stopPropagation(); // 阻止事件冒泡
                            pressTimer = setTimeout(() => {
                                console.log('鼠标长按触发，群聊ID:', group.id);
                                enterMessageListMultiSelectMode(group.id);
                                e.preventDefault();
                            }, 800); // 800ms长按
                        }
                    });
                    
                    messageItem.addEventListener('mouseup', (e) => {
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                        }
                    });
                    
                    messageItem.addEventListener('mouseleave', (e) => {
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                        }
                    });
                    
                    // 右键点击进入多选模式（桌面端）
                    messageItem.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        enterMessageListMultiSelectMode(group.id);
                    });
                }
                
                messageItem.innerHTML = `
                    ${isMessageListMultiSelectMode ? `
                        <div class="selection-checkbox ${selectedConversations.includes(group.id) ? 'selected' : ''}">
                            ${selectedConversations.includes(group.id) ? '<i class="fas fa-check check-icon-white"></i>' : ''}
                        </div>
                    ` : ''}
                    <div class="message-avatar" style="${group.avatarUrl ? `background-image: url(${group.avatarUrl}); background-size: cover; background-position: center;` : 'background-color: #4CAF50;'}">
                        ${group.avatarUrl ? '' : '群'}
                    </div>
                    <div class="message-content">
                                                        <div class="message-name">${group.name} <span class="group-member-count">(${group.members ? group.members.length + 1 : 1}人)</span></div>
                        <div class="message-preview">${lastMessage}</div>
                    </div>
                    <div class="message-time">${lastTime}</div>
                `;
                
                messageList.appendChild(messageItem);
            });
        }
        
        // 渲染联系人列表（角色页面）
        function renderContactList() {
            const contactList = document.querySelector('#contact-list .contact-section');
            if (contactList) {
                // 清空所有内容
                contactList.innerHTML = '';
                
                // 添加多选模式的头部
                if (isMultiSelectMode) {
                    const headerDiv = document.createElement('div');
                    headerDiv.className = 'multiselect-header';
                    headerDiv.innerHTML = `
                        <span>已选择 ${selectedCharacters.length} 个角色</span>
                        <div>
                            <button onclick="deleteSelectedCharacters()" class="delete-btn-red">删除</button>
                            <button onclick="exitMultiSelectMode()" class="cancel-btn-blue">取消</button>
                        </div>
                    `;
                    contactList.appendChild(headerDiv);
                }
                
                // 🔥【修复】显示所有角色，而不只是联系人
                characters.forEach(character => {
                    // 🔥【修复】获取该角色的昵称设置
                        const savedSettings = localStorage.getItem(`chatSettings_${character.id}`);
                        const chatSettings = savedSettings ? JSON.parse(savedSettings) : {};
                        const displayName = chatSettings.aiChatNickname || character.name;
                        
                        const contactItem = document.createElement('div');
                        contactItem.className = `contact-item ${isMultiSelectMode && selectedCharacters.includes(character.id) ? 'selected' : ''}`;
                        
                        // 根据模式设置不同的点击事件
                        if (isMultiSelectMode) {
                            contactItem.onclick = () => toggleCharacterSelection(character.id);
                        } else {
                            contactItem.onclick = () => editCharacterFromContactList(character.id);
                            
                            // 添加长按事件
                            let pressTimer;
                            contactItem.addEventListener('touchstart', (e) => {
                                pressTimer = setTimeout(() => {
                                    enterMultiSelectMode(character.id);
                                    e.preventDefault();
                                }, 800); // 800ms长按
                            });
                            
                            contactItem.addEventListener('touchend', () => {
                                clearTimeout(pressTimer);
                            });
                            
                            contactItem.addEventListener('touchmove', () => {
                                clearTimeout(pressTimer);
                            });
                            
                            // 右键点击进入多选模式（桌面端）
                            contactItem.addEventListener('contextmenu', (e) => {
                                e.preventDefault();
                                enterMultiSelectMode(character.id);
                            });
                        }
                        
                        contactItem.innerHTML = `
                            ${isMultiSelectMode ? `
                                <div class="selection-checkbox ${selectedCharacters.includes(character.id) ? 'selected' : ''}">
                                    ${selectedCharacters.includes(character.id) ? '<i class="fas fa-check check-icon-white"></i>' : ''}
                                </div>
                            ` : ''}
                            <div class="message-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                                ${character.avatarUrl ? '' : displayName.charAt(0)}
                            </div>
                            <div class="contact-info">
                                <div class="message-name">${displayName}</div>
                                <div class="character-preview">${truncateText(character.bio || '暂无人设描述', 25)}</div>
                            </div>
                        `;
                        
                        contactList.appendChild(contactItem);
                });
                
                // 如果没有角色，显示提示
                if (characters.length === 0) {
                    const emptyDiv = document.createElement('div');
                    emptyDiv.className = 'empty-message';
                    emptyDiv.textContent = '还没有角色，点击右上角+号创建角色吧！';
                    contactList.appendChild(emptyDiv);
                }
            }
        }
        
        // 渲染角色列表
        function renderCharacterList() {
            const characterList = document.getElementById('character-list');
            // 检查元素是否存在，如果不存在就跳过（因为我们已经删除了人物应用）
            if (!characterList) {
                console.log('character-list元素不存在，跳过渲染');
                return;
            }
            
            characterList.innerHTML = '';
            
            characters.forEach(character => {
                const characterItem = document.createElement('div');
                characterItem.className = 'character-item';
                characterItem.onclick = () => editCharacter(character.id);
                
                characterItem.innerHTML = `
                    <div class="character-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                        ${character.avatarUrl ? '' : character.name.charAt(0)}
                    </div>
                    <div class="character-info">
                        <div class="character-name">${character.name}</div>
                        <div class="character-bio">${truncateText(character.bio, 50)}</div>
                    </div>
                `;
                
                characterList.appendChild(characterItem);
            });
        }
        
        // 渲染联系人模态框
        function renderContactModal() {
            const modalBody = document.getElementById('contact-modal-body');
            modalBody.innerHTML = '';
            
            characters.forEach(character => {
                // 只显示未添加为联系人的角色
                if (!contacts.includes(character.id)) {
                    const contactOption = document.createElement('div');
                    contactOption.className = 'contact-item';
                    
                    const checkboxId = `contact-${character.id}`;
                    
                    contactOption.innerHTML = `
                        <div class="message-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                            ${character.avatarUrl ? '' : character.name.charAt(0)}
                        </div>
                        <div class="character-info character-info-flex">
                            <div class="character-name">${character.name}</div>
                            <div class="character-bio">${truncateText(character.bio, 40)}</div>
                        </div>
                        <input type="checkbox" id="${checkboxId}" class="contact-checkbox" value="${character.id}">
                    `;
                    
                    modalBody.appendChild(contactOption);
                }
            });
            
            if (modalBody.children.length === 0) {
                modalBody.innerHTML = '<p>没有可添加的角色，请先创建新角色。</p>';
            }
        }
        
        // 当前显示的消息数量限制
        let currentMessageOffset = 0;
        const MESSAGE_LIMIT = 50;
        
        // 渲染聊天消息
        function renderChatMessages(characterId, loadMore = false) {
            const messagesContainer = document.getElementById('api-chat-messages');
            const allMessages = chatMessages[characterId] || [];
            const chatSettings = getCurrentChatSettings();
            
            if (!loadMore) {
                // 重新渲染时清空容器并重置偏移量
                messagesContainer.innerHTML = '';
                currentMessageOffset = Math.max(0, allMessages.length - MESSAGE_LIMIT);
            }
            
            // 应用聊天背景
            applyChatBackground();
            
            // 应用气泡样式
            applyBubbleStyle();
            
            // 如果没有消息，显示空状态提示
            if (allMessages.length === 0) {
                const displayName = chatSettings.aiChatNickname || currentChatCharacter.name;
                const emptyState = document.createElement('div');
                emptyState.className = 'empty-chat-state';
                emptyState.innerHTML = `
                    <div>开始和 ${displayName} 聊天吧</div>
                `;
                messagesContainer.appendChild(emptyState);
                return;
            }
            
            // 如果不是加载更多，且有更多历史消息，显示"查看历史消息"按钮
            if (!loadMore && currentMessageOffset > 0) {
                const loadMoreBtn = document.createElement('div');
                loadMoreBtn.className = 'load-more-messages';
                loadMoreBtn.innerHTML = `
                    <div class="load-more-content">
                        <i class="fas fa-chevron-up"></i>
                        <span>查看历史消息 (${currentMessageOffset}条)</span>
                    </div>
                `;
                loadMoreBtn.onclick = () => loadMoreMessages(characterId);
                messagesContainer.appendChild(loadMoreBtn);
            }
            
            // 获取要显示的消息
            const messagesToShow = loadMore ? 
                allMessages.slice(Math.max(0, currentMessageOffset - MESSAGE_LIMIT), currentMessageOffset) :
                allMessages.slice(currentMessageOffset);
            
            // 获取时间戳设置
            const timestampEnabled = chatSettings.timestampEnabled !== false; // 默认为true
            const timestampPosition = chatSettings.timestampPosition || 'center';
            
            let lastTimestamp = 0;
            
            messagesToShow.forEach((message, index) => {
                // 处理系统消息（如戳一戳、头像更换、撤回等）
                if (message.sender === 'system') {
                    if (message.isPoke) {
                    const systemContainer = document.createElement('div');
                    systemContainer.className = 'poke-system-container';
                    const systemMessage = document.createElement('div');
                    systemMessage.className = 'poke-system-message';
                    systemMessage.textContent = message.content;
                    systemContainer.appendChild(systemMessage);
                    messagesContainer.appendChild(systemContainer);
                    } else if (message.type === 'recalled_message') {
                        // 🔥【新增】处理撤回消息的显示
                        const centerContainer = document.createElement('div');
                        centerContainer.style.display = 'flex';
                        centerContainer.style.justifyContent = 'center';
                        centerContainer.style.margin = '4px 0';
                        centerContainer.dataset.messageId = message.id; // 🔥【修复】添加消息ID以支持选择
                        
                        const recallElement = document.createElement('div');
                        recallElement.className = 'recalled-message';
                        
                        // 解析撤回消息内容（格式：xxx 撤回了一条消息\n原文：xxx）
                        const lines = message.content.split('\n');
                        const mainText = lines[0]; // 主要提示文字
                        const originalText = lines[1]; // 原文部分
                        
                        recallElement.textContent = mainText;
                        
                        // 如果有原文，添加原文显示
                        if (originalText && originalText.startsWith('原文：')) {
                            const originalDiv = document.createElement('div');
                            originalDiv.className = 'original-text';
                            originalDiv.textContent = originalText;
                            recallElement.appendChild(originalDiv);
                        }
                        
                        centerContainer.appendChild(recallElement);
                        messagesContainer.appendChild(centerContainer);
                        
                        // 🔥【修复】为撤回消息添加选择功能
                        addMessageLongPressListener(centerContainer, message.id);
                    } else {
                        // 🔥【修复】其他系统消息（如头像更换）- 使用居中容器
                        const centerContainer = document.createElement('div');
                        centerContainer.style.display = 'flex';
                        centerContainer.style.justifyContent = 'center';
                        centerContainer.style.margin = '4px 0';
                        
                        const systemContainer = document.createElement('div');
                        systemContainer.className = 'system-message';
                        systemContainer.textContent = message.content;
                        
                        centerContainer.appendChild(systemContainer);
                        messagesContainer.appendChild(centerContainer);
                    }
                    return;
                }
                
                // 添加居中时间戳（如果启用且位置为居中）
                if (timestampEnabled && timestampPosition === 'center') {
                    const currentTime = new Date(message.timestamp);
                    const timeDiff = currentTime - lastTimestamp;
                    
                    // 如果距离上条消息超过5分钟，显示时间戳
                    if (index === 0 || timeDiff > 5 * 60 * 1000) {
                        const timestampDiv = document.createElement('div');
                        timestampDiv.className = 'timestamp timestamp-center';
                        timestampDiv.textContent = formatTimestamp(message.timestamp);
                        messagesContainer.appendChild(timestampDiv);
                        lastTimestamp = currentTime;
                    }
                }
                
                const messageContainer = document.createElement('div');
                // 检查是否是纯表情包消息
                const isEmojiOnly = message.isEmoji && !message.content;
                messageContainer.className = `message-container ${message.sender}${chatSettings.hideAvatars ? ' no-avatar' : ''}${isEmojiOnly ? ' emoji-only' : ''}`;
                messageContainer.dataset.messageId = message.id; // 添加消息ID数据属性
                
                if (message.sender === 'received') {
                    // ==== 群聊支持 ====
                    let character = characters.find(c => c.id === characterId);
                    let isGroup = false;
                    let group = null;
                    if (!character) {
                        group = groupChats.find(g => g.id === characterId);
                        if (group) {
                            isGroup = true;
                        }
                    }
                    
                    let displayAvatar = '';
                    let displayName = '';
                    let color = '#4CAF50';
                    
                    if (isGroup && group) {
                        // 群聊：根据消息的senderId或name查找成员
                        let member = null;
                        if (message.senderId) {
                            member = group.members.find(m => m.id === message.senderId);
                        } else if (message.name) {
                            member = group.members.find(m => m.name === message.name);
                        }
                        displayAvatar = member?.avatarUrl || '';
                        displayName = member?.name || '群成员';
                        color = member?.color || '#4CAF50';
                    } else if (character) {
                        // 单聊
                        displayAvatar = chatSettings.aiDynamicAvatar || chatSettings.aiChatAvatar || character.avatarUrl;
                        displayName = chatSettings.aiChatNickname || character.name;
                        color = character.color || '#4CAF50';
                    
                    // 🔥【调试】记录头像选择过程
                    if (chatSettings.aiDynamicAvatar) {
                        console.log(`使用动态头像: ${chatSettings.aiDynamicAvatar.substring(0, 30)}...`);
                    } else if (chatSettings.aiChatAvatar) {
                        console.log(`使用聊天设置头像: ${chatSettings.aiChatAvatar.substring(0, 30)}...`);
                    } else {
                        console.log(`使用角色卡头像: ${character.avatarUrl ? character.avatarUrl.substring(0, 30) + '...' : '无头像'}`);
                    }
                    } else {
                        // 兜底，防止报错
                        displayAvatar = '';
                        displayName = '未知';
                        color = '#4CAF50';
                    }
                    
                    // 获取气泡样式
                    const bubbleColor = chatSettings.aiBubbleColor || '#f0f0f0';
                    const bubbleOpacity = chatSettings.aiBubbleOpacity || '1';
                    const textColor = isLightColor(bubbleColor) ? '#333' : '#fff';
                    const bubblePadding = chatSettings.bubblePadding || '12';
                    
                    // 将透明度应用到背景色而不是整个元素
                    const transparentBubbleColor = convertColorWithOpacity(bubbleColor, bubbleOpacity);
                    
                    // 🔥 处理特殊消息类型
                    let messageContent = '';
                    
                    if (message.type === 'voice_message') {
                        // 过滤掉括号中的描述性内容，保留实际说话内容
                        const cleanVoiceContent = message.content.replace(/\([^)]*\)\s*/g, '').trim();
                        const voiceDuration = message.duration || Math.max(1, Math.ceil(cleanVoiceContent.length / 8));
                        
                        // AI语音消息 - 使用和用户语音消息一样的结构
                        messageContent = `
                            <div class="voice-message-container received">
                                <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                                    <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${cleanVoiceContent}">
                                        <div class="voice-wave">
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                        </div>
                                        <div class="voice-duration">${voiceDuration}"</div>
                                    </div>
                                </div>
                                <div class="voice-text-content">${cleanVoiceContent}</div>
                            </div>
                        `;
                    } else if (message.type === 'ai_image') {
                        // AI生成的图片
                        messageContent = `
                            <div class="ai-image-container">
                                <img src="${message.image}" class="message-image" onclick="showImage('${message.image}')" alt="AI生成的图片">
                                <div class="image-description">${message.imageDescription || ''}</div>
                            </div>
                        `;
                    } else if (message.type === 'transfer') {
                        // 转账消息
                        const isUser = message.role === 'user';
                        const heartIcon = isUser ? '💕' : '💖';
                        const titleText = isUser ? '你发起的转账' : '收到转账';
                        let cardClass = '';
                        let statusHtml = '';
                        let clickHandler = '';
                        
                        if (message.status === 'accepted') {
                            statusHtml = `<div class="transfer-status">${isUser ? '对方已收款' : '已收款'}</div>`;
                            cardClass = 'accepted';
                        } else if (message.status === 'rejected') {
                            statusHtml = `<div class="transfer-status">${isUser ? '对方已退回' : '已退回'}</div>`;
                            cardClass = 'rejected';
                        } else if (!isUser) {
                            // AI发来的转账且未处理，添加点击处理
                            clickHandler = `onclick="showTransferConfirmDialog(${JSON.stringify(message).replace(/"/g, '&quot;')})"`;
                        }
                        
                        messageContent = `
                            <div class="transfer-message-container received">
                                <div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}" ${clickHandler}>
                                    <div class="transfer-title">${heartIcon} ${titleText}</div>
                                    <div class="transfer-amount">¥ ${Number(message.amount).toFixed(2)}</div>
                                    <div class="transfer-note">${message.note || '转账'}</div>
                                    ${statusHtml}
                                </div>
                            </div>
                        `;
                    } else {
                        // 普通文本消息
                        const chatMode = chatSettings.chatMode || 'online';
                        let processedContent = message.content;
                        
                        if (chatMode === 'offline') {
                            processedContent = processOfflineContent(message.content);
                        }
                        
                        messageContent = processedContent;
                    }
                    
                    let avatarHtml = '';
                    if (!chatSettings.hideAvatars) {
                        avatarHtml = `
                            <div class="message-avatar" style="background-color: ${color}; ${displayAvatar ? `background-image: url(${displayAvatar}); background-size: cover; background-position: center;` : ''}" ${character ? `onclick="pokeCharacter('${character.id}')" title="戳一戳"` : `title="${displayName}"`}>
                                ${displayAvatar ? '' : displayName.charAt(0)}
                                ${timestampEnabled && timestampPosition === 'avatar' ? `<div class="timestamp timestamp-avatar">${formatTimeOnly(message.timestamp)}</div>` : ''}
                            </div>
                        `;
                    }
                    
                    let bubbleHtml = '';
                    if (message.type === 'voice_message' || message.type === 'transfer') {
                        // 语音消息和转账消息不需要额外的气泡包裹
                        bubbleHtml = messageContent;
                    } else {
                        // 普通消息用气泡包裹
                        bubbleHtml = `
                        <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                            ${messageContent}
                            ${message.image && !message.type ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}
                            ${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}
                            ${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}
                        </div>
                    `;
                    }
                    
      // 🔥【修复】群聊昵称显示 - 特别处理语音消息和转账消息
      if (isGroup && group && displayName !== '群成员') {
    messageContainer.classList.add('group-message-item');
    const senderNameHtml = `<div class="sender-name">${displayName}</div>`;
    
    if (message.type === 'voice_message' || message.type === 'transfer') {
        // 🔥【修复】对于语音消息和转账消息，昵称需要在容器外部
    messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    } else {
        // 普通消息的处理
        messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    }
} else {
                    messageContainer.innerHTML = avatarHtml + bubbleHtml;
}
                } else {
                    // 获取我的显示头像和气泡样式
let myDisplayAvatar = chatSettings.myChatAvatar; // 优先使用聊天专属设置里的头像
let myDisplayName = chatSettings.myChatNickname; // 优先使用聊天专属设置里的昵称
                    
// 如果专属设置里没有，则进行二次查找（作为保险措施）
if ((!myDisplayAvatar || !myDisplayName) && chatSettings.selectedIdentityId) {
                        const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
    if (selectedPersona) {
        // 如果头像为空，则使用身份头像
        if (!myDisplayAvatar) myDisplayAvatar = selectedPersona.avatarUrl;
        // 如果昵称为空，则使用身份昵称
        if (!myDisplayName) myDisplayName = selectedPersona.name;
                        }
                    }
                    
                    const myBubbleColor = chatSettings.myBubbleColor || '#007AFF';
                    const myBubbleOpacity = chatSettings.myBubbleOpacity || '1';
                    const myTextColor = isLightColor(myBubbleColor) ? '#333' : '#fff';
                    const myBubblePadding = chatSettings.bubblePadding || '12';
                    
                    // 将透明度应用到背景色而不是整个元素
                    const transparentMyBubbleColor = convertColorWithOpacity(myBubbleColor, myBubbleOpacity);
                    
                    // 处理用户的特殊消息类型
                    let myMessageContent = '';
                    if (message.type === 'user_photo') {
                        // 用户发送的"照片"（文字描述）
                        myMessageContent = `
                            <div class="dreamy-photo-container" onclick="togglePhotoText(this, '${(message.photoDescription || message.content).replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')">
                                <div class="dreamy-photo">
                                    <div class="photo-misty-bg"></div>
                                    <div class="photo-badge">
                                        <i class="fas fa-image"></i>
                                    </div>
                                    <div class="sparkle-container">
                                        <div class="sparkle sparkle-1">✨</div>
                                        <div class="sparkle sparkle-2">⭐</div>
                                        <div class="sparkle sparkle-3">✨</div>
                                        <div class="sparkle sparkle-4">⭐</div>
                                        <div class="sparkle sparkle-5">💫</div>
                                    </div>
                                    <div class="photo-text-overlay" style="display: none;">
                                        <div class="photo-description">${(message.photoDescription || message.content)}</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'voice') {
                        // 用户发送的语音消息
                        myMessageContent = `
                            <div class="voice-message-container sent">
                                <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                                    <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${message.content}">
                                        <div class="voice-wave">
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                        </div>
                                        <div class="voice-duration">${message.duration || Math.max(1, Math.ceil(message.content.length / 8))}"</div>
                                    </div>
                                    ${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                    ${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                </div>
                                <div class="voice-text-content">${message.content}</div>
                            </div>
                        `;
                    } else if (message.type === 'transfer') {
                        // 用户转账消息 - 在renderChatMessages中处理
                        let cardClass = '';
                        let statusHtml = '';
                        
                        if (message.status === 'accepted') {
                            statusHtml = `<div class="transfer-status">对方已收款</div>`;
                            cardClass = 'accepted';
                        } else if (message.status === 'rejected') {
                            statusHtml = `<div class="transfer-status">对方已退回</div>`;
                            cardClass = 'rejected';
                        }
                        
                        myMessageContent = `
                            <div class="transfer-message-container sent">
                                <div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}">
                                    <div class="transfer-title">💕 你发起的转账</div>
                                    <div class="transfer-amount">¥ ${Number(message.amount).toFixed(2)}</div>
                                    <div class="transfer-note">${message.note || '转账'}</div>
                                    ${statusHtml}
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'location') {
                        // 用户发送的位置消息
                        myMessageContent = `
                            <div class="location-message-container sent">
                                <div class="location-card" onclick="showLocationDetail('${message.locationName}')">
                                    <div class="location-card-header">${message.locationName}</div>
                                    <div class="location-card-map">
                                        <div class="map-background"></div>
                                        <div class="map-roads">
                                            <div class="road road-horizontal" style="top: 35%; width: 100%;"></div>
                                            <div class="road road-vertical" style="left: 40%; height: 100%;"></div>
                                            <div class="road road-horizontal" style="top: 65%; width: 70%; left: 30%;"></div>
                                        </div>
                                        <div class="map-buildings">
                                            <div class="building" style="top: 15%; left: 20%; width: 12px; height: 10px;"></div>
                                            <div class="building" style="top: 25%; left: 60%; width: 14px; height: 12px;"></div>
                                            <div class="building green" style="top: 50%; left: 15%; width: 8px; height: 8px;"></div>
                                            <div class="building" style="top: 70%; left: 70%; width: 10px; height: 8px;"></div>
                                            <div class="building green" style="top: 10%; left: 75%; width: 6px; height: 6px;"></div>
                                            <div class="building green" style="top: 75%; left: 25%; width: 7px; height: 7px;"></div>
                                        </div>
                                        <div class="map-marker">
                                            <div class="marker-pin">📍</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        // 🔥【修复】处理多模态消息或普通文本消息
                        if (Array.isArray(message.content)) {
                            // 新的多模态格式
                            const textPart = message.content.find(p => p.type === 'text');
                            const imagePart = message.content.find(p => p.type === 'image_url');
                            
                            myMessageContent = textPart?.text || '';
                            
                            // 如果有图片，添加图片显示
                            if (imagePart?.image_url?.url) {
                                if (myMessageContent) {
                                    myMessageContent += '<br>';
                                }
                                myMessageContent += `<img src="${imagePart.image_url.url}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${imagePart.image_url.url}')">`;
                            }
                        } else {
                            // 普通文本消息或旧格式
                        myMessageContent = message.content;
                        }
                    }
                    
                    let myBubbleHtml = '';
                    
                    if (message.type === 'user_photo' || message.type === 'voice' || message.type === 'transfer' || message.type === 'location') {
                        // 用户照片、语音消息、转账消息和位置消息不需要额外气泡包裹（已经有自己的容器）
                        myBubbleHtml = myMessageContent;
                    } else {
                        // 普通消息用气泡包裹
                        myBubbleHtml = `
                            <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                                ${myMessageContent}
                                ${message.image && !message.type && !Array.isArray(message.content) ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}
                                ${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                ${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}
                            </div>
                        `;
                    }
                    
                    let myAvatarHtml = '';
                    if (!chatSettings.hideAvatars) {
                        myAvatarHtml = `
                            <div class="message-avatar" style="background-color: #007AFF; ${myDisplayAvatar ? `background-image: url(${myDisplayAvatar}); background-size: cover; background-position: center;` : ''}">
                                ${myDisplayAvatar ? '' : '<i class="fas fa-user"></i>'}
                                ${timestampEnabled && timestampPosition === 'avatar' ? `<div class="timestamp timestamp-avatar">${formatTimeOnly(message.timestamp)}</div>` : ''}
                            </div>
                        `;
                    }
                    
                    messageContainer.innerHTML = myBubbleHtml + myAvatarHtml;
                }
                
                // 添加滑入动画效果 - 参考完成.html的弹性动画
                messageContainer.style.opacity = '0';
                messageContainer.style.transform = 'translateY(20px)';
                messageContainer.style.transition = 'opacity 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)';
                
                messagesContainer.appendChild(messageContainer);
                
                // 触发滑入动画
                requestAnimationFrame(() => {
                    messageContainer.style.opacity = '1';
                    messageContainer.style.transform = 'translateY(0)';
                });
                
                // 添加长按监听器用于多选删除
                addMessageLongPressListener(messageContainer, message.id);
                
                // 添加右键菜单功能
                const bubble = messageContainer.querySelector('.message-bubble');
                if (bubble) {
                    // 鼠标右键点击
                    bubble.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        showMessageMenu(message.id, e);
                    });
                    
                    // 点击图片预览
                    bubble.onclick = (e) => {
                        if (e.target.tagName === 'IMG' && e.target.classList.contains('message-image')) {
                            showImage(e.target.src);
                        }
                    };
                }
            });
            
            // 添加正在输入提示元素到消息底部（初始隐藏）
            const typingIndicator = document.createElement('div');
            typingIndicator.id = 'typing-indicator';
            typingIndicator.className = 'typing-indicator';
            typingIndicator.innerHTML = `${chatSettings.aiChatNickname || currentChatCharacter.name}正在输入中<span class="dots"></span>`;
            messagesContainer.appendChild(typingIndicator);
            
            // 如果不是加载更多，自动滚动到底部
            if (!loadMore) {
                setTimeout(() => {
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                }, 100);
            }
            
            // 🔥【修复】位置消息气泡包装问题 - 修复已渲染的位置消息
            setTimeout(() => {
                const locationMessages = messagesContainer.querySelectorAll('.message-container.sent');
                locationMessages.forEach(container => {
                    const locationCard = container.querySelector('.location-card');
                    if (locationCard && container.querySelector('.message-bubble')) {
                        // 如果位置卡片被包裹在气泡中，提取出来
                        const bubble = container.querySelector('.message-bubble');
                        const avatar = container.querySelector('.message-avatar');
                        if (bubble && locationCard.closest('.message-bubble')) {
                            const locationContainer = locationCard.closest('.location-message-container');
                            if (locationContainer) {
                                container.innerHTML = locationContainer.outerHTML + (avatar ? avatar.outerHTML : '');
                            }
                        }
                    }
                });
            }, 50);
        }
        
        // 加载更多历史消息
        function loadMoreMessages(characterId) {
            const messagesContainer = document.getElementById('api-chat-messages');
            const allMessages = chatMessages[characterId] || [];
            const chatSettings = getCurrentChatSettings();
            
            // 保存滚动位置
            const scrollHeight = messagesContainer.scrollHeight;
            const scrollTop = messagesContainer.scrollTop;
            
            // 计算要加载的历史消息范围
            const newOffset = Math.max(0, currentMessageOffset - MESSAGE_LIMIT);
            const historicalMessages = allMessages.slice(newOffset, currentMessageOffset);
            
            // 移除现有的"查看历史消息"按钮
            const existingLoadMoreBtn = messagesContainer.querySelector('.load-more-messages');
            if (existingLoadMoreBtn) {
                existingLoadMoreBtn.remove();
            }
            
            // 如果还有更多历史消息，在顶部添加新的"查看历史消息"按钮
            if (newOffset > 0) {
                const loadMoreBtn = document.createElement('div');
                loadMoreBtn.className = 'load-more-messages';
                loadMoreBtn.innerHTML = `
                    <div class="load-more-content">
                        <i class="fas fa-chevron-up"></i>
                        <span>查看历史消息 (${newOffset}条)</span>
                    </div>
                `;
                loadMoreBtn.onclick = () => loadMoreMessages(characterId);
                messagesContainer.insertBefore(loadMoreBtn, messagesContainer.firstChild);
            }
            
            // 在现有消息前面插入历史消息
            const timestampEnabled = chatSettings.timestampEnabled !== false;
            const timestampPosition = chatSettings.timestampPosition || 'center';
            let lastTimestamp = 0;
            
            // 从后往前插入，保持时间顺序
            for (let i = historicalMessages.length - 1; i >= 0; i--) {
                const message = historicalMessages[i];
                
                // 处理系统消息（如戳一戳、头像更换、撤回等）
                if (message.sender === 'system') {
                    let containerToInsert;
                    
                    if (message.isPoke) {
                    const systemContainer = document.createElement('div');
                    systemContainer.className = 'poke-system-container';
                    const systemMessage = document.createElement('div');
                    systemMessage.className = 'poke-system-message';
                    systemMessage.textContent = message.content;
                    systemContainer.appendChild(systemMessage);
                        containerToInsert = systemContainer;
                    } else if (message.type === 'recalled_message') {
                        // 🔥【新增】处理撤回消息的显示
                        const centerContainer = document.createElement('div');
                        centerContainer.style.display = 'flex';
                        centerContainer.style.justifyContent = 'center';
                        centerContainer.style.margin = '4px 0';
                        centerContainer.dataset.messageId = message.id; // 🔥【修复】添加消息ID以支持选择
                        
                        const recallElement = document.createElement('div');
                        recallElement.className = 'recalled-message';
                        
                        // 解析撤回消息内容（格式：xxx 撤回了一条消息\n原文：xxx）
                        const lines = message.content.split('\n');
                        const mainText = lines[0]; // 主要提示文字
                        const originalText = lines[1]; // 原文部分
                        
                        recallElement.textContent = mainText;
                        
                        // 如果有原文，添加原文显示
                        if (originalText && originalText.startsWith('原文：')) {
                            const originalDiv = document.createElement('div');
                            originalDiv.className = 'original-text';
                            originalDiv.textContent = originalText;
                            recallElement.appendChild(originalDiv);
                        }
                        
                        centerContainer.appendChild(recallElement);
                        containerToInsert = centerContainer;
                    } else {
                        // 🔥【修复】其他系统消息（如头像更换）- 使用居中容器
                        const centerContainer = document.createElement('div');
                        centerContainer.style.display = 'flex';
                        centerContainer.style.justifyContent = 'center';
                        centerContainer.style.margin = '4px 0';
                        
                        const systemContainer = document.createElement('div');
                        systemContainer.className = 'system-message';
                        systemContainer.textContent = message.content;
                        
                        centerContainer.appendChild(systemContainer);
                        containerToInsert = centerContainer;
                    }
                    
                    // 插入到按钮后面（如果有按钮的话）
                    const insertAfter = messagesContainer.querySelector('.load-more-messages');
                    if (insertAfter) {
                        insertAfter.parentNode.insertBefore(containerToInsert, insertAfter.nextSibling);
                    } else {
                        messagesContainer.insertBefore(containerToInsert, messagesContainer.firstChild);
                    }
                    
                    // 🔥【修复】为撤回消息添加选择功能
                    if (message.type === 'recalled_message') {
                        addMessageLongPressListener(containerToInsert, message.id);
                    }
                    
                    continue;
                }
                
                const messageContainer = document.createElement('div');
                // 检查是否是纯表情包消息
                const isEmojiOnly = message.isEmoji && !message.content;
                messageContainer.className = `message-container ${message.sender}${chatSettings.hideAvatars ? ' no-avatar' : ''}${isEmojiOnly ? ' emoji-only' : ''}`;
                messageContainer.dataset.messageId = message.id;
                
                if (message.sender === 'received') {
                    // ==== 群聊支持 ====
                    let character = characters.find(c => c.id === characterId);
                    let isGroup = false;
                    let group = null;
                    if (!character) {
                        group = groupChats.find(g => g.id === characterId);
                        if (group) {
                            isGroup = true;
                        }
                    }
                    
                    let displayAvatar = '';
                    let displayName = '';
                    let color = '#4CAF50';
                    
                    if (isGroup && group) {
                        // 群聊：根据消息的senderId或name查找成员
                        let member = null;
                        if (message.senderId) {
                            member = group.members.find(m => m.id === message.senderId);
                        } else if (message.name) {
                            member = group.members.find(m => m.name === message.name);
                        }
                        displayAvatar = member?.avatarUrl || '';
                        displayName = member?.name || '群成员';
                        color = member?.color || '#4CAF50';
                    } else if (character) {
                        // 单聊
                        displayAvatar = chatSettings.aiDynamicAvatar || chatSettings.aiChatAvatar || character.avatarUrl;
                        displayName = chatSettings.aiChatNickname || character.name;
                        color = character.color || '#4CAF50';
                    } else {
                        // 兜底，防止报错
                        displayAvatar = '';
                        displayName = '未知';
                        color = '#4CAF50';
                    }
                    const bubbleColor = chatSettings.aiBubbleColor || '#f0f0f0';
                    const bubbleOpacity = chatSettings.aiBubbleOpacity || '1';
                    const textColor = isLightColor(bubbleColor) ? '#333' : '#fff';
                    const bubblePadding = chatSettings.bubblePadding || '12';
                    
                    // 将透明度应用到背景色而不是整个元素
                    const transparentBubbleColor = convertColorWithOpacity(bubbleColor, bubbleOpacity);
                    
                    let messageContent = '';
                    if (message.type === 'voice_message') {
                        // 过滤掉括号中的描述性内容，保留实际说话内容
                        const cleanVoiceContent = message.content.replace(/\([^)]*\)\s*/g, '').trim();
                        const voiceDuration = message.duration || Math.max(1, Math.ceil(cleanVoiceContent.length / 8));
                        
                        messageContent = `
                            <div class="voice-message-container received">
                                <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                                    <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${cleanVoiceContent}">
                                        <div class="voice-wave">
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                        </div>
                                        <div class="voice-duration">${voiceDuration}"</div>
                                    </div>
                                </div>
                                <div class="voice-text-content">${cleanVoiceContent}</div>
                            </div>
                        `;
                    } else if (message.type === 'ai_image') {
                        messageContent = `<div class="ai-image-container"><img src="${message.image}" class="message-image" onclick="showImage('${message.image}')" alt="AI生成的图片"><div class="image-description">${message.imageDescription || ''}</div></div>`;
                    } else if (message.type === 'transfer') {
                        // 转账消息
                        const isUser = message.role === 'user';
                        const heartIcon = isUser ? '💕' : '💖';
                        const titleText = isUser ? '你发起的转账' : '收到转账';
                        let cardClass = '';
                        let statusHtml = '';
                        let clickHandler = '';
                        
                        if (message.status === 'accepted') {
                            statusHtml = `<div class="transfer-status">${isUser ? '对方已收款' : '已收款'}</div>`;
                            cardClass = 'accepted';
                        } else if (message.status === 'rejected') {
                            statusHtml = `<div class="transfer-status">${isUser ? '对方已退回' : '已退回'}</div>`;
                            cardClass = 'rejected';
                        } else if (!isUser) {
                            // AI发来的转账且未处理，添加点击处理
                            clickHandler = `onclick="showTransferConfirmDialog(${JSON.stringify(message).replace(/"/g, '&quot;')})"`;
                        }
                        
                        messageContent = `<div class="transfer-message-container received"><div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}" ${clickHandler}><div class="transfer-title">${heartIcon} ${titleText}</div><div class="transfer-amount">¥ ${Number(message.amount).toFixed(2)}</div><div class="transfer-note">${message.note || '转账'}</div>${statusHtml}</div></div>`;
                    } else {
                        const chatMode = chatSettings.chatMode || 'online';
                        messageContent = chatMode === 'offline' ? processOfflineContent(message.content) : message.content;
                    }
                    
                    let avatarHtml = '';
                    if (!chatSettings.hideAvatars) {
                        avatarHtml = `<div class="message-avatar" style="background-color: ${color}; ${displayAvatar ? `background-image: url(${displayAvatar}); background-size: cover; background-position: center;` : ''}" ${character ? `onclick="pokeCharacter('${character.id}')" title="戳一戳"` : `title="${displayName}"`}>${displayAvatar ? '' : displayName.charAt(0)}${timestampEnabled && timestampPosition === 'avatar' ? `<div class="timestamp timestamp-avatar">${formatTimeOnly(message.timestamp)}</div>` : ''}</div>`;
                    }
                    
                    let bubbleHtml = '';
                    if (message.type === 'voice_message' || message.type === 'transfer') {
                        // 语音消息和转账消息不需要额外的气泡包裹
                        bubbleHtml = messageContent;
                    } else {
                        // 普通消息用气泡包裹
                        bubbleHtml = `<div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">${messageContent}${message.image && !message.type ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}</div>`;
                    }
                    
                   // 🔥【修复】群聊昵称显示 （loadMoreMessages版本）- 特别处理语音消息和转账消息
                   if (isGroup && group && displayName !== '群成员') {
    messageContainer.classList.add('group-message-item');
    const senderNameHtml = `<div class="sender-name">${displayName}</div>`;
    
    if (message.type === 'voice_message' || message.type === 'transfer') {
        // 🔥【修复】对于语音消息和转账消息，昵称需要在容器外部
    messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    } else {
        // 普通消息的处理
        messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    }
} else {
                    messageContainer.innerHTML = avatarHtml + bubbleHtml;
}
                } else {
                    let myDisplayAvatar = chatSettings.myChatAvatar;
                    if (!myDisplayAvatar && chatSettings.selectedIdentityId) {
                        const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                        if (selectedPersona && selectedPersona.avatarUrl) {
                            myDisplayAvatar = selectedPersona.avatarUrl;
                        }
                    }
                    
                    const myBubbleColor = chatSettings.myBubbleColor || '#007AFF';
                    const myBubbleOpacity = chatSettings.myBubbleOpacity || '1';
                    const myTextColor = isLightColor(myBubbleColor) ? '#333' : '#fff';
                    const myBubblePadding = chatSettings.bubblePadding || '12';
                    
                    // 将透明度应用到背景色而不是整个元素
                    const transparentMyBubbleColor = convertColorWithOpacity(myBubbleColor, myBubbleOpacity);
                    
                    // 处理用户的特殊消息类型
                    let myMessageContent = '';
                    if (message.type === 'user_photo') {
                        // 用户发送的"照片"（文字描述）
                        myMessageContent = `<div class="dreamy-photo-container" onclick="togglePhotoText(this, '${(message.photoDescription || message.content).replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')"><div class="dreamy-photo"><div class="photo-misty-bg"></div><div class="photo-badge"><i class="fas fa-image"></i></div><div class="sparkle-container"><div class="sparkle sparkle-1">✨</div><div class="sparkle sparkle-2">⭐</div><div class="sparkle sparkle-3">✨</div><div class="sparkle sparkle-4">⭐</div><div class="sparkle sparkle-5">💫</div></div><div class="photo-text-overlay" style="display: none;"><div class="photo-description">${(message.photoDescription || message.content)}</div></div></div></div>`;
                    } else if (message.type === 'voice') {
                        // 用户发送的语音消息
                        myMessageContent = `
                            <div class="voice-message-container sent">
                                <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                                    <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${message.content}">
                                        <div class="voice-wave">
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                        </div>
                                        <div class="voice-duration">${message.duration || Math.max(1, Math.ceil(message.content.length / 8))}"</div>
                                    </div>
                                    ${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                    ${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                </div>
                                <div class="voice-text-content">${message.content}</div>
                            </div>
                        `;
                    } else if (message.type === 'transfer') {
                        // 用户转账消息 - 在loadMoreMessages中处理
                        let cardClass = '';
                        let statusHtml = '';
                        
                        if (message.status === 'accepted') {
                            statusHtml = `<div class="transfer-status">对方已收款</div>`;
                            cardClass = 'accepted';
                        } else if (message.status === 'rejected') {
                            statusHtml = `<div class="transfer-status">对方已退回</div>`;
                            cardClass = 'rejected';
                        }
                        
                        myMessageContent = `
                            <div class="transfer-message-container sent">
                                <div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}">
                                    <div class="transfer-title">💕 你发起的转账</div>
                                    <div class="transfer-amount">¥ ${Number(message.amount).toFixed(2)}</div>
                                    <div class="transfer-note">${message.note || '转账'}</div>
                                    ${statusHtml}
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'location') {
                        // 用户发送的位置消息 - 在loadMoreMessages中处理
                        myMessageContent = `
                            <div class="location-message-container sent">
                                <div class="location-card" onclick="showLocationDetail('${message.locationName}')">
                                    <div class="location-card-header">${message.locationName}</div>
                                    <div class="location-card-map">
                                        <div class="map-background"></div>
                                        <div class="map-roads">
                                            <div class="road road-horizontal" style="top: 35%; width: 100%;"></div>
                                            <div class="road road-vertical" style="left: 40%; height: 100%;"></div>
                                            <div class="road road-horizontal" style="top: 65%; width: 70%; left: 30%;"></div>
                                        </div>
                                        <div class="map-buildings">
                                            <div class="building" style="top: 15%; left: 20%; width: 12px; height: 10px;"></div>
                                            <div class="building" style="top: 25%; left: 60%; width: 14px; height: 12px;"></div>
                                            <div class="building green" style="top: 50%; left: 15%; width: 8px; height: 8px;"></div>
                                            <div class="building" style="top: 70%; left: 70%; width: 10px; height: 8px;"></div>
                                            <div class="building green" style="top: 10%; left: 75%; width: 6px; height: 6px;"></div>
                                            <div class="building green" style="top: 75%; left: 25%; width: 7px; height: 7px;"></div>
                                        </div>
                                        <div class="map-marker">
                                            <div class="marker-pin">📍</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        // 🔥【修复】处理多模态消息或普通文本消息 (loadMoreMessages版本)
                        if (Array.isArray(message.content)) {
                            // 新的多模态格式
                            const textPart = message.content.find(p => p.type === 'text');
                            const imagePart = message.content.find(p => p.type === 'image_url');
                            
                            myMessageContent = textPart?.text || '';
                            
                            // 如果有图片，添加图片显示
                            if (imagePart?.image_url?.url) {
                                if (myMessageContent) {
                                    myMessageContent += '<br>';
                                }
                                myMessageContent += `<img src="${imagePart.image_url.url}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${imagePart.image_url.url}')">`;
                            }
                        } else {
                            // 普通文本消息或旧格式
                        myMessageContent = message.content;
                        }
                    }
                    
                    let myBubbleHtml = '';
                    
                    if (message.type === 'user_photo' || message.type === 'voice' || message.type === 'transfer' || message.type === 'location') {
                        // 用户照片、语音消息、转账消息和位置消息不需要额外气泡包裹（已经有自己的容器）
                        myBubbleHtml = myMessageContent;
                    } else {
                        // 普通消息用气泡包裹
                        myBubbleHtml = `<div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">${myMessageContent}${message.image && !message.type && !Array.isArray(message.content) ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}</div>`;
                    }
                    
                    let myAvatarHtml = '';
                    if (!chatSettings.hideAvatars) {
                        myAvatarHtml = `<div class="message-avatar" style="background-color: #007AFF; ${myDisplayAvatar ? `background-image: url(${myDisplayAvatar}); background-size: cover; background-position: center;` : ''}">${myDisplayAvatar ? '' : '<i class="fas fa-user"></i>'}${timestampEnabled && timestampPosition === 'avatar' ? `<div class="timestamp timestamp-avatar">${formatTimeOnly(message.timestamp)}</div>` : ''}</div>`;
                    }
                    
                    messageContainer.innerHTML = myBubbleHtml + myAvatarHtml;
                }
                
                // 添加长按监听器和右键菜单
                addMessageLongPressListener(messageContainer, message.id);
                const bubble = messageContainer.querySelector('.message-bubble');
                if (bubble) {
                    bubble.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        showMessageMenu(message.id, e);
                    });
                    
                    bubble.onclick = (e) => {
                        if (e.target.tagName === 'IMG' && e.target.classList.contains('message-image')) {
                            showImage(e.target.src);
                        }
                    };
                }
                
                // 插入消息到正确位置
                const insertAfter = messagesContainer.querySelector('.load-more-messages');
                if (insertAfter) {
                    insertAfter.parentNode.insertBefore(messageContainer, insertAfter.nextSibling);
                } else {
                    messagesContainer.insertBefore(messageContainer, messagesContainer.firstChild);
                }
            }
            
            // 更新偏移量
            currentMessageOffset = newOffset;
            
            // 保持滚动位置
            setTimeout(() => {
                const newScrollHeight = messagesContainer.scrollHeight;
                messagesContainer.scrollTop = scrollTop + (newScrollHeight - scrollHeight);
            }, 50);
        }
        
        
        // 显示角色表单
        function showCharacterForm(characterId = null) {
            currentEditingCharacterId = characterId; // 保存当前编辑的角色ID
            document.getElementById('character-form-title').textContent = characterId ? '编辑人物' : '新建人物';
            
            // 清空表单
            document.getElementById('character-name').value = '';
            document.getElementById('character-bio').value = '';
            document.getElementById('avatar-upload').value = '';
            
            const avatarPreview = document.getElementById('avatar-preview');
            const avatarPreviewText = document.getElementById('avatar-preview-text');
            
            // 重置头像预览
            avatarPreview.classList.remove('has-image');
            avatarPreview.style.removeProperty('background');
            avatarPreview.style.removeProperty('background-size');
            avatarPreview.style.removeProperty('background-position');
            avatarPreview.style.removeProperty('background-repeat');
            avatarPreviewText.style.display = 'block';
            avatarPreviewText.textContent = 'A';
            
            // 清除临时存储的头像数据
            window.selectedAvatarData = null;
            
            // 如果是编辑模式，填充现有数据
            if (characterId) {
                const character = characters.find(c => c.id === characterId);
                if (character) {
                    document.getElementById('character-name').value = character.name;
                    document.getElementById('character-bio').value = character.bio;
                    
                    if (character.avatarUrl) {
                        avatarPreview.classList.add('has-image');
                        avatarPreview.style.setProperty('background', `url(${character.avatarUrl})`, 'important');
                        avatarPreview.style.setProperty('background-size', 'cover', 'important');
                        avatarPreview.style.setProperty('background-position', 'center', 'important');
                        avatarPreview.style.setProperty('background-repeat', 'no-repeat', 'important');
                        avatarPreviewText.style.display = 'none';
                        // 为编辑模式保存现有头像数据
                        window.selectedAvatarData = character.avatarUrl;
                    } else {
                        avatarPreviewText.textContent = character.name.charAt(0);
                    }
                }
            }
            
            // 设置表单的保存函数和删除按钮显示
            const deleteBtn = document.getElementById('character-delete-btn');
            console.log('设置保存按钮，characterId:', characterId);
            if (characterId) {
                document.querySelector('#character-form-screen .form-submit').onclick = async () => await saveCharacter(characterId);
                // 编辑模式显示删除按钮
                if (deleteBtn) deleteBtn.style.display = 'block';
                console.log('设置为编辑模式，角色ID:', characterId);
            } else {
                document.querySelector('#character-form-screen .form-submit').onclick = async () => await saveCharacter();
                // 新建模式隐藏删除按钮
                if (deleteBtn) deleteBtn.style.display = 'none';
                console.log('设置为创建模式，无角色ID');
            }
            
            showApp('character-form-screen');
            
            // 确保头像上传功能可用 - 重新绑定事件监听器（以防万一）
            setTimeout(() => {
                initializeAvatarUpload();
            }, 100);
        }
        
        // 保存角色
        async function saveCharacter(characterId = null) {
            try {
                console.log('=== 开始保存角色 ===');
                const name = document.getElementById('character-name').value.trim();
                const bio = document.getElementById('character-bio').value.trim();
                const avatarData = window.selectedAvatarData; // 使用预处理的头像数据
                
                console.log('保存角色 - 姓名:', name, '头像数据存在:', !!avatarData);
                if (avatarData) {
                    console.log('头像数据长度:', avatarData.length, '开头:', avatarData.substring(0, 50));
                }
                
                if (!name) {
                    alert('请输入姓名');
                    return;
                }
                
                if (characterId) {
                    console.log('=== 更新现有角色 ===');
                    // 更新现有角色
                    const index = characters.findIndex(c => c.id === characterId);
                    if (index !== -1) {
                        const oldAvatarUrl = characters[index].avatarUrl;
                        
                        characters[index] = {
                            ...characters[index],
                            name,
                            bio,
                            avatarUrl: avatarData || characters[index].avatarUrl || '',
                            color: characters[index].color || getRandomColor()
                        };
                        
                        console.log('更新角色完成:', characters[index]);
                        
                        // 🔥【修复1】如果头像发生了变化，更新所有相关群聊中的成员头像
                        if (avatarData && avatarData !== oldAvatarUrl) {
                            updateCharacterAvatarInGroups(characterId, avatarData);
                        }
                        
                        // 保存并更新界面
                        await saveCharacters();
                        renderContactList();
                        renderMessageList();
                        
                        // 🔥【修复2】如果当前正在聊天且是该角色，刷新聊天界面
                        if (currentChatCharacter && currentChatCharacter.id === characterId) {
                            renderChatMessages(currentChatCharacter.id);
                        }
                        
                        showToast(`角色 "${name}" 已更新！`, 'success');
                        hideCharacterForm();
                        // 注意：不立即清空表单，让用户能看到保存成功的状态
                    }
                } else {
                    console.log('=== 创建新角色 ===');
                    // 创建新角色
                    const newCharacter = {
                        id: Date.now().toString(),
                        name,
                        bio,
                        avatarUrl: avatarData || '',
                        color: getRandomColor()
                    };
                    
                    console.log('创建新角色:', newCharacter);
                    console.log('新角色头像URL:', newCharacter.avatarUrl);
                    console.log('新角色头像URL长度:', newCharacter.avatarUrl ? newCharacter.avatarUrl.length : 0);
                    
                    console.log('添加角色前，当前角色数组长度:', characters.length);
                    characters.push(newCharacter);
                    console.log('添加角色后，当前角色数组长度:', characters.length);
                    
                    console.log('角色数组最新状态:', characters);
                    
                    // 🔥【修复】不再自动添加到联系人列表，用户需要通过创建对话来建立联系
                    
                    // 保存并更新界面
                    console.log('开始保存到IndexedDB...');
                    await saveCharacters();
                    console.log('保存后检查角色数组:', characters);
                    
                    console.log('开始渲染界面...');
                    renderContactList();
                    renderMessageList();
                    
                    console.log('开始隐藏表单...');
                    hideCharacterForm();
                    // 注意：不立即清空表单，让用户能看到保存成功的状态
                    
                    // 给用户反馈
                    showToast(`角色 "${newCharacter.name}" 创建成功！`, 'success');
                    
                    console.log('=== 保存角色完成 ===');
                }
            } catch (error) {
                console.error('保存角色时发生错误:', error);
                alert('保存角色时发生错误: ' + error.message);
            }
        }
        
        // 清空角色表单
        function clearCharacterForm() {
            console.log('清空角色表单被调用');
            document.getElementById('character-name').value = '';
            document.getElementById('character-bio').value = '';
            document.getElementById('avatar-upload').value = '';
            
            const avatarPreview = document.getElementById('avatar-preview');
            const avatarPreviewText = document.getElementById('avatar-preview-text');
            
            // 重置头像预览
            avatarPreview.classList.remove('has-image');
            avatarPreview.style.removeProperty('background');
            avatarPreview.style.removeProperty('background-size');
            avatarPreview.style.removeProperty('background-position');
            avatarPreview.style.removeProperty('background-repeat');
            if (avatarPreviewText) {
                avatarPreviewText.style.display = 'block';
                avatarPreviewText.textContent = 'A';
            }
            
            // 清除临时存储的头像数据
            console.log('清除临时头像数据');
            window.selectedAvatarData = null;
        }
        
        // 编辑角色
        function editCharacter(characterId) {
            showCharacterForm(characterId);
        }
        
        // 从联系人列表编辑角色
        function editCharacterFromContactList(characterId) {
            showCharacterForm(characterId);
        }
        
        // 进入多选模式
        function enterMultiSelectMode(characterId) {
            isMultiSelectMode = true;
            selectedCharacters = [characterId]; // 初始选中触发长按的角色
            renderContactList();
        }
        
        // 退出多选模式
        function exitMultiSelectMode() {
            isMultiSelectMode = false;
            selectedCharacters = [];
            renderContactList();
        }
        
        // 切换角色选择状态
        function toggleCharacterSelection(characterId) {
            const index = selectedCharacters.indexOf(characterId);
            if (index > -1) {
                selectedCharacters.splice(index, 1);
            } else {
                selectedCharacters.push(characterId);
            }
            renderContactList();
        }
        
        // 删除选中的角色
        async function deleteSelectedCharacters() {
            if (selectedCharacters.length === 0) {
                alert('请先选择要删除的角色');
                return;
            }
            
            const characterNames = selectedCharacters.map(id => {
                const character = characters.find(c => c.id === id);
                return character ? character.name : '';
            }).filter(name => name).join('、');
            
            if (confirm(`确定要删除这些角色吗？\n${characterNames}\n\n此操作不可恢复！`)) {
                // 删除角色
                selectedCharacters.forEach(characterId => {
                    characters = characters.filter(c => c.id !== characterId);
                    contacts = contacts.filter(c => c !== characterId);
                    
                    // 删除相关聊天记录
                    if (chatMessages[characterId]) {
                        delete chatMessages[characterId];
                    }
                });
                
                // 保存数据
                await saveCharacters();
                await saveContacts();
                await saveChatMessages();
                
                // 退出多选模式并更新界面
                exitMultiSelectMode();
                renderMessageList();
                
                alert('角色删除成功');
            }
        }
        
        // 删除当前编辑的角色
        async function deleteCurrentCharacter() {
            if (currentEditingCharacterId) {
                const character = characters.find(c => c.id === currentEditingCharacterId);
                
                if (character && confirm(`确定要删除角色"${character.name}"吗？\n\n此操作不可恢复！`)) {
                    // 删除角色
                    characters = characters.filter(c => c.id !== character.id);
                    contacts = contacts.filter(c => c !== character.id);
                    
                    // 删除相关聊天记录
                    if (chatMessages[character.id]) {
                        delete chatMessages[character.id];
                    }
                    
                    // 保存数据
                    await saveCharacters();
                    await saveContacts();
                    await saveChatMessages();
                    
                    // 更新界面并返回
                    renderContactList();
                    renderMessageList();
                    hideCharacterForm();
                    
                    alert('角色删除成功');
                }
            }
        }
        
        // 🔥【新增】更新角色在所有群聊中的头像
        function updateCharacterAvatarInGroups(characterId, newAvatarUrl) {
            // 遍历所有角色，找到群聊
            characters.forEach(character => {
                if (character.isGroup && character.members) {
                    // 在该群聊中查找对应的成员
                    const memberIndex = character.members.findIndex(member => member.id === characterId);
                    if (memberIndex !== -1) {
                        // 更新该成员的头像
                        character.members[memberIndex].avatarUrl = newAvatarUrl;
                        console.log(`已更新群聊 "${character.name}" 中成员 "${character.members[memberIndex].name}" 的头像`);
                    }
                }
            });
            
            // 保存更新后的角色数据
            saveCharacters();
        }
        
        // 获取随机颜色
        function getRandomColor() {
            const colors = ['#FF3B30', '#FF9500', '#FFCC00', '#34C759', '#5AC8FA', '#007AFF', '#5856D6', '#AF52DE'];
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        // 显示添加联系人模态框
        function showAddContactModal() {
            showCharacterForm(); // 直接显示创建角色表单
        }
        
        // 添加选中的联系人
        async function addSelectedContacts() {
            const checkboxes = document.querySelectorAll('.contact-checkbox:checked');
            checkboxes.forEach(checkbox => {
                const characterId = checkbox.value;
                if (!contacts.includes(characterId)) {
                    contacts.push(characterId);
                }
            });
            
            await saveContacts();
            renderMessageList();
            renderContactList();
            hideModal('add-contact-modal');
        }
        
        // 开始与角色聊天
        function startChat(character) {
            currentChatCharacter = character;
            
            // 🔥【修复】检查是否有保存的昵称设置
            const chatSettings = getCurrentChatSettings();
            const displayTitle = chatSettings.aiChatNickname || character.name;
            document.getElementById('api-chat-title').textContent = displayTitle;
            
            // 初始化空的聊天记录（不自动发送消息）
            if (!chatMessages[character.id]) {
                chatMessages[character.id] = [];
                saveChatMessages();
            }
            
            // 重置悬浮按钮状态
            resetFloatingButtonsState();
            
            // 🔥【新增】如果设置界面是打开的，更新设置显示状态
            if (document.getElementById('api-chat-settings-screen').style.display === 'flex') {
                updateChatSettingsDisplay();
            }
            
            // 初始化后台互动系统
            initBackgroundInteractionSystem();
            
            // 初始化定时发布系统
            initScheduledMomentsSystem();
            
            renderChatMessages(character.id);
            showApp('api-chat-screen');
        }
        
        // 从聊天界面返回到聊天应用
        function backToChatApp() {
            // 清除当前角色的后台定时器
            clearAllBackgroundTimers();
            hideApp('api-chat-screen');
            showApp('chat-screen');
        }
        
        // 从设置子页面返回到设置主页面
        function backToSettings(currentScreen) {
            hideApp(currentScreen);
            showApp('settings-screen');
        }
        

        
        // 显示正在输入提示
        function showTypingIndicator() {
            console.log('🔧 尝试显示正在输入提示...');
            let indicator = document.getElementById('typing-indicator');
            
            // 如果没有找到元素，尝试创建一个
            if (!indicator) {
                console.log('⚠️ 未找到typing-indicator元素，正在创建...');
                const messagesContainer = document.getElementById('api-chat-messages');
                if (messagesContainer) {
                    indicator = document.createElement('div');
                    indicator.id = 'typing-indicator';
                    indicator.className = 'typing-indicator';
                    
                    // 获取当前角色名称
                    const chatSettings = getCurrentChatSettings();
                    const characterName = chatSettings.aiChatNickname || (currentChatCharacter ? currentChatCharacter.name : '对方');
                    
                    indicator.innerHTML = `${characterName}正在输入中<span class="dots"></span>`;
                    messagesContainer.appendChild(indicator);
                    console.log('✅ 已创建typing-indicator元素');
                } else {
                    console.error('❌ 找不到消息容器，无法创建typing-indicator');
                    return;
                }
            }
            
            if (indicator) {
                console.log('✅ 显示正在输入提示');
                indicator.classList.add('show');
                // 滚动到底部显示提示
                const messagesContainer = document.getElementById('api-chat-messages');
                if (messagesContainer) {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                }
            } else {
                console.error('❌ 仍然找不到typing-indicator元素');
            }
        }
        
        // 隐藏正在输入提示
        function hideTypingIndicator() {
            console.log('🔧 尝试隐藏正在输入提示...');
            const indicator = document.getElementById('typing-indicator');
            if (indicator) {
                console.log('✅ 隐藏正在输入提示');
                indicator.classList.remove('show');
            } else {
                console.log('⚠️ 未找到typing-indicator元素，可能已被移除');
            }
        }
        
        // 🔥【新增】添加系统消息到聊天界面（不重新渲染整个列表）
        function addSystemMessageToChat(systemMessage) {
            const messagesContainer = document.getElementById('api-chat-messages');
            if (!messagesContainer) return;
            
            // 创建外层容器，用于居中
            const centerContainer = document.createElement('div');
            centerContainer.style.display = 'flex';
            centerContainer.style.justifyContent = 'center';
            centerContainer.style.margin = '4px 0';
            
            // 创建系统消息容器
            const systemContainer = document.createElement('div');
            systemContainer.className = 'system-message';
            systemContainer.textContent = systemMessage.content;
            
            // 将系统消息放入居中容器
            centerContainer.appendChild(systemContainer);
            
            // 插入到消息容器的最后（正在输入提示之前）
            const typingIndicator = messagesContainer.querySelector('#typing-indicator');
            if (typingIndicator) {
                messagesContainer.insertBefore(centerContainer, typingIndicator);
            } else {
                messagesContainer.appendChild(centerContainer);
            }
            
            // 滚动到底部
            setTimeout(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }, 100);
        }

        // 🔥【新增】处理AI撤回消息功能
        async function handleRecalledMessage(messageContent, targetMessageId = null) {
            if (!currentChatCharacter) return;
            
            console.log('处理撤回消息:', messageContent, '目标消息ID:', targetMessageId);
            
            const messagesContainer = document.getElementById('api-chat-messages');
            if (!messagesContainer) return;
            
            const character = characters.find(c => c.id === currentChatCharacter.id);
            const chatSettings = getCurrentChatSettings();
            const displayName = chatSettings.aiChatNickname || character.name;
            
            let messageContainer = null;
            
            // 如果提供了目标消息ID，查找并撤回现有消息
            if (targetMessageId) {
                messageContainer = messagesContainer.querySelector(`[data-message-id="${targetMessageId}"]`);
                if (messageContainer) {
                    console.log('找到要撤回的现有消息，准备撤回');
                    
                    // 等待1.2秒后撤回
                    await new Promise(resolve => setTimeout(resolve, 1200));
                    
                    // 添加淡出动画
                    messageContainer.style.animation = 'fadeOut 0.5s ease-in-out forwards';
                    
                    // 等待动画完成
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // 从聊天记录中移除这条消息
                    if (chatMessages[currentChatCharacter.id]) {
                        const messageIndex = chatMessages[currentChatCharacter.id].findIndex(msg => msg.id === targetMessageId);
                        if (messageIndex !== -1) {
                            chatMessages[currentChatCharacter.id].splice(messageIndex, 1);
                            saveChatMessages();
                        }
                    }
                } else {
                    console.warn('未找到要撤回的消息，创建临时消息');
                    // 如果找不到消息，回退到创建临时消息的方式
                    messageContainer = await createTemporaryMessage(messageContent);
                }
            } else {
                // 没有提供目标ID，创建临时消息
                messageContainer = await createTemporaryMessage(messageContent);
            }
            
            if (!messageContainer) return;
            
            // 创建撤回提醒的居中容器
            const centerContainer = document.createElement('div');
            centerContainer.style.display = 'flex';
            centerContainer.style.justifyContent = 'center';
            centerContainer.style.margin = '4px 0';
            
            // 创建撤回消息元素
            const recallElement = document.createElement('div');
            recallElement.className = 'recalled-message';
            
            // 主要提醒文字
            const mainText = document.createElement('div');
            mainText.style.marginBottom = '2px';
            mainText.textContent = `${displayName} 撤回了一条消息`;
            
            // 原文显示
            const originalText = document.createElement('div');
            originalText.className = 'original-text';
            originalText.textContent = `原文：${messageContent}`;
            
            recallElement.appendChild(mainText);
            recallElement.appendChild(originalText);
            centerContainer.appendChild(recallElement);
            
            // 在原消息位置替换为撤回提醒
            messageContainer.parentNode.insertBefore(centerContainer, messageContainer);
            messageContainer.remove();
            
            // 添加撤回消息到聊天历史
            const recalledMessage = {
                id: `recalled_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                sender: 'system',
                type: 'recalled_message',
                content: `${displayName} 撤回了一条消息\n原文：${messageContent}`,
                originalContent: messageContent,
                    timestamp: Date.now()
                };
                
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            chatMessages[currentChatCharacter.id].push(recalledMessage);
                saveChatMessages();
            
            // 滚动到底部
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // 创建临时消息的辅助函数
            async function createTemporaryMessage(content) {
                const messageId = `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                
                const tempContainer = document.createElement('div');
                const isEmojiOnly = false;
                tempContainer.className = `message-container received${isEmojiOnly ? ' emoji-only' : ''}`;
                tempContainer.dataset.messageId = messageId;
                
                const bubbleColor = chatSettings.aiBubbleColor || '#f0f0f0';
                const bubbleOpacity = chatSettings.aiBubbleOpacity || '1';
                const textColor = isLightColor(bubbleColor) ? '#333' : '#fff';
                const bubblePadding = chatSettings.bubblePadding || '12';
                const displayAvatar = chatSettings.aiDynamicAvatar || chatSettings.aiChatAvatar || character.avatarUrl;
                
                let avatarHtml = '';
                if (!chatSettings.hideAvatars) {
                    avatarHtml = `
                        <div class="message-avatar" style="background-color: ${character.color}; ${displayAvatar ? `background-image: url(${displayAvatar}); background-size: cover; background-position: center;` : ''}" onclick="pokeCharacter('${character.id}')" title="戳一戳">
                            ${displayAvatar ? '' : displayName.charAt(0)}
                        </div>
                    `;
                }
                
                // 将透明度应用到背景色而不是整个元素
                const transparentBubbleColor = convertColorWithOpacity(bubbleColor, bubbleOpacity);
                
                let bubbleHtml = `
                    <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                        ${content}
                    </div>
                `;
                
                tempContainer.innerHTML = avatarHtml + bubbleHtml;
                
                // 添加到消息容器
                const typingIndicator = messagesContainer.querySelector('#typing-indicator');
                if (typingIndicator) {
                    messagesContainer.insertBefore(tempContainer, typingIndicator);
                } else {
                    messagesContainer.appendChild(tempContainer);
                }
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                
                // 等待1.2秒后撤回
                await new Promise(resolve => setTimeout(resolve, 1200));
                
                // 添加淡出动画
                tempContainer.style.animation = 'fadeOut 0.5s ease-in-out forwards';
                
                // 等待动画完成
                await new Promise(resolve => setTimeout(resolve, 500));
                
                return tempContainer;
            }
        }
        
        // 🔥【新增】获取用户最近发送的图片URL
        function getRecentUserImage() {
            if (!currentChatCharacter || !chatMessages[currentChatCharacter.id]) {
                return null;
            }
            
            const messages = chatMessages[currentChatCharacter.id];
            // 从最新消息开始向前查找用户发送的图片
            for (let i = messages.length - 1; i >= 0; i--) {
                const msg = messages[i];
                if (msg.sender === 'sent' && msg.image && !msg.isEmoji) {
                    console.log('找到用户最近发送的图片:', msg.image);
                    return msg.image;
                }
            }
            
            console.log('没有找到用户发送的图片');
            return null;
        }
        
        // API调用函数 - 基于现有的API逻辑
        async function callChatAPI(prompt, character) {
            try {
                // 获取角色设置
                let chatSettings = null;
                try {
                    chatSettings = await db.chatSettings.get(character.id);
                } catch (error) {
                    console.error('获取聊天设置失败:', error);
                }
                
                const persona = chatSettings?.aiPersona || character.prompt || `你是${character.name}。`;
                
                // 获取绑定的世界书内容
                let worldBookContent = '';
                if (chatSettings?.linkedWorldBookIds && chatSettings.linkedWorldBookIds.length > 0) {
                    try {
                        const worldBooks = await Promise.all(
                            chatSettings.linkedWorldBookIds.map(id => db.worldbooks.get(id))
                        );
                        const validWorldBooks = worldBooks.filter(book => book && book.content);
                        if (validWorldBooks.length > 0) {
                            worldBookContent = '\n\n世界书内容（供参考）：\n' + 
                                validWorldBooks.map(book => `${book.name}：${book.content}`).join('\n\n');
                        }
                    } catch (error) {
                        console.error('获取世界书内容失败:', error);
                    }
                }
                
                // 获取聊天上下文
                let chatContext = '';
                const characterMessages = chatMessages[character.id] || [];
                if (characterMessages.length > 0) {
                    const maxMemory = parseInt(chatSettings?.maxMemory) || 10;
                    const recentHistory = characterMessages.slice(-maxMemory);
                    chatContext = '\n\n最近的聊天记录（供参考）：\n' + 
                        recentHistory.map(msg => {
                            if (msg.sender === 'sent') return `用户：${msg.content}`;
                            return `${character.name}：${msg.content}`;
                        }).join('\n');
                }
                
                const systemPrompt = `你是${character.name}，你的人设如下：${persona}。${worldBookContent}${chatContext}

请严格按照以下JSON格式回复，每条消息都必须是独立的数组元素：

正确格式示例：
["普通文本消息"]
["消息1", "消息2"]
[{"type": "voice_message", "content": "语音内容"}]
[{"type": "emoji", "description": "表情包描述"}]
[{"type": "ai_image", "description": "图片描述"}]
[{"type": "transfer", "amount": 100, "note": "转账备注"}]

🚨 重要：绝对不能将多条消息合并在一个元素中！错误格式：["消息1\\n消息2"]

现在请对用户的消息进行回复：${prompt}`;

                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: prompt }
                ];

                const { base: proxyUrl, key: apiKey, model } = apiSettings;
                if (!proxyUrl || !apiKey || !model) {
                    console.log('API配置不完整，跳过AI回复');
                    return '["API配置不完整，请在设置中配置API"]';
                }

                const requestBody = {
                    model: model,
                    messages: messages,
                    temperature: 0.8,
                    stream: false
                };

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000);

                const isGeminiOfficial = proxyUrl.includes('generativelanguage.googleapis.com');

                let response;
                if (isGeminiOfficial) {
                    const apiUrl = `${proxyUrl}/models/${model}:generateContent?key=${apiKey}`;
                    
                    const geminiMessages = [];
                    if (requestBody.messages[0]?.role === 'system') {
                        geminiMessages.push({
                            role: 'user',
                            parts: [{ text: requestBody.messages[0].content }]
                        });
                        geminiMessages.push({
                            role: 'model',
                            parts: [{ text: '我明白了，我会按照这些要求进行对话。' }]
                        });
                    }
                    
                    for (let i = 1; i < requestBody.messages.length; i++) {
                        const msg = requestBody.messages[i];
                        if (msg.role === 'system') continue;
                        
                        geminiMessages.push({
                            role: msg.role === 'user' ? 'user' : 'model',
                            parts: [{ text: msg.content }]
                        });
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiMessages,
                            generationConfig: {
                                temperature: requestBody.temperature || 0.8
                            }
                        }),
                        signal: controller.signal
                    });
                } else {
                    response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal
                    });
                }

                clearTimeout(timeoutId);

                if (!response.ok) {
                    let errorText = await response.text();
                    console.error(`聊天API调用失败 (${response.status}): ${errorText}`);
                    return `["API调用失败: ${response.status}"]`;
                }

                const data = await response.json();
                let content;

                if (isGeminiOfficial) {
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!content) {
                        console.log('Gemini API 响应数据:', data);
                        return '["Gemini API响应异常"]';
                    }
                } else {
                    if (data.choices && data.choices.length > 0 && data.choices[0].message) {
                        content = data.choices[0].message.content;
                    } else if (data.message) {
                        content = data.message;
                    } else if (data.text) {
                        content = data.text;
                    } else if (data.response) {
                        content = data.response;
                    } else if (data.content) {
                        content = data.content;
                    } else if (data.result) {
                        content = data.result;
                    } else {
                        console.error('无法解析API响应，完整响应数据:', data);
                        return '["API响应解析失败"]';
                    }
                }

                return content;

            } catch (error) {
                console.error('callChatAPI失败:', error);
                return `["调用失败: ${error.message}"]`;
            }
        }
        
        // 带图片的API调用函数
        async function callChatAPIWithImage(prompt, character, imageUrl) {
            // 图像功能暂未实现，使用普通API调用
            const imagePrompt = `${prompt}\n\n[用户发送了一张图片，但图像识别功能暂未实现]`;
            return await callChatAPI(imagePrompt, character);
        }
        
        // 解析AI回复 - 按照index.html的逻辑，新增表情包支持和格式修正
        function parseAiResponse(content) { 
            try { 
                const parsed = JSON.parse(content); 
                if (Array.isArray(parsed)) {
                    // 🔥【新增】处理表情包消息类型和格式修正
                    const processedMessages = [];
                    
                    parsed.forEach(item => {
                        if (typeof item === 'object' && item.type === 'emoji') {
                            // 查找匹配的表情包
                            const matchingEmoji = customEmojis.find(emoji => 
                                emoji.description === item.description
                            );
                            
                            if (matchingEmoji) {
                                // 检查表情包是否为GIF格式
                                if (matchingEmoji.url && matchingEmoji.url.includes('data:image/gif')) {
                                    console.warn('AI尝试使用GIF格式表情包:', item.description);
                                    processedMessages.push(`[${matchingEmoji.description}] (GIF格式不支持API识别)`);
                                } else {
                                // 返回表情包对象，包含完整的表情包信息
                                    processedMessages.push({
                                    type: 'emoji',
                                    url: matchingEmoji.url,
                                    description: matchingEmoji.description,
                                    id: matchingEmoji.id
                                    });
                                }
                                                            } else {
                                    // 如果找不到匹配的表情包，返回错误消息
                                    console.warn('AI尝试使用不存在的表情包:', item.description);
                                    processedMessages.push(`[错误: 表情包"${item.description}"不存在]`);
                                }
                        } else if (typeof item === 'object' && item.type === 'change_avatar') {
                            // 处理头像更换对象
                            console.log('解析到头像更换指令:', item);
                            
                            // 🔥【新增】处理各种错误的占位符
                            if (item.avatar_url === 'CURRENT_USER_IMAGE' || 
                                item.avatar_url === 'CURRENT_USER_IMAGE' || 
                                item.avatar_url === '用户发送的图片URL' ||
                                item.avatar_url === '图片URL') {
                                // 获取最近用户发送的图片URL
                                const recentUserImage = getRecentUserImage();
                                if (recentUserImage) {
                                    item.avatar_url = recentUserImage;
                                    console.log('将占位符替换为实际图片URL:', recentUserImage);
                                } else {
                                    console.warn('没有找到用户最近发送的图片，忽略头像更换请求');
                                    processedMessages.push(`[系统：无法更换头像，没有找到可用的图片]`);
                                    // 不要return，继续处理其他消息
                                }
                            }
                            
                            processedMessages.push(item);
                        } else if (typeof item === 'object' && item.type === 'ai_image') {
                            // 🔥【新增】处理AI发送图片
                            console.log('解析到AI图片发送指令:', item);
                            processedMessages.push(item);
                        } else if (typeof item === 'object' && item.type === 'voice_message') {
                            // 🔥【新增】处理AI发送语音
                            console.log('解析到AI语音发送指令:', item);
                            processedMessages.push(item);
                        } else if (typeof item === 'object' && item.type === 'transfer') {
                            // 🔥【新增】处理AI转账

                            processedMessages.push(item);
                        } else if (typeof item === 'object' && item.type === 'update_poke_suffix') {
                            // 🔥【新增】处理戳一戳后缀更新
                            console.log('解析到戳一戳后缀更新指令:', item);
                            processedMessages.push(item);
                        } else if (typeof item === 'object' && item.type === 'recalled_message') {
                            // 🔥【新增】处理撤回消息
                            console.log('解析到撤回消息指令:', item);
                            processedMessages.push(item);
                        } else if (typeof item === 'string') {
                            // 🚨 【新增】检查并修复合并消息问题
                            if (item.includes('\n')) {
                                console.warn('检测到AI将多条消息合并在一个元素中，正在自动分拆:', item);
                                // 将换行符分隔的内容分拆成多条消息
                                const splitMessages = item.split('\n')
                                    .map(msg => msg.trim())
                                    .filter(msg => msg.length > 0);
                                processedMessages.push(...splitMessages);
                            } else {
                                processedMessages.push(item);
                            }
                        } else {
                            processedMessages.push(item);
                        }
                    });
                    
                    return processedMessages;
                }
            } catch (e) {} 
            
            try { 
                const match = content.match(/\[(.*?)\]/s); 
                if (match && match[0]) { 
                    const parsed = JSON.parse(match[0]); 
                    if (Array.isArray(parsed)) {
                        // 🔥【新增】处理表情包消息类型和格式修正
                        const processedMessages = [];
                        
                        parsed.forEach(item => {
                            if (typeof item === 'object' && item.type === 'emoji') {
                                // 查找匹配的表情包
                                const matchingEmoji = customEmojis.find(emoji => 
                                    emoji.description === item.description
                                );
                                
                                if (matchingEmoji) {
                                    // 检查表情包是否为GIF格式
                                    if (matchingEmoji.url && matchingEmoji.url.includes('data:image/gif')) {
                                        console.warn('AI尝试使用GIF格式表情包:', item.description);
                                        processedMessages.push(`[${matchingEmoji.description}] (GIF格式不支持API识别)`);
                                    } else {
                                    // 返回表情包对象，包含完整的表情包信息
                                        processedMessages.push({
                                        type: 'emoji',
                                        url: matchingEmoji.url,
                                        description: matchingEmoji.description,
                                        id: matchingEmoji.id
                                        });
                                    }
                                } else {
                                    // 如果找不到匹配的表情包，返回错误消息
                                    console.warn('AI尝试使用不存在的表情包:', item.description);
                                    processedMessages.push(`[错误: 表情包"${item.description}"不存在]`);
                                }
                            } else if (typeof item === 'object' && item.type === 'change_avatar') {
                                // 处理头像更换对象
                                console.log('解析到头像更换指令(第二处):', item);
                                
                                // 🔥【新增】处理各种错误的占位符
                                if (item.avatar_url === 'CURRENT_USER_IMAGE' || 
                                    item.avatar_url === 'CURRENT_USER_IMAGE' || 
                                    item.avatar_url === '用户发送的图片URL' ||
                                    item.avatar_url === '图片URL') {
                                    // 获取最近用户发送的图片URL
                                    const recentUserImage = getRecentUserImage();
                                    if (recentUserImage) {
                                        item.avatar_url = recentUserImage;
                                        console.log('将占位符替换为实际图片URL(第二处):', recentUserImage);
                                    } else {
                                        console.warn('没有找到用户最近发送的图片，忽略头像更换请求(第二处)');
                                        processedMessages.push(`[系统：无法更换头像，没有找到可用的图片]`);
                                        // 不要return，继续处理其他消息
                                    }
                                }
                                
                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'ai_image') {
                                // 🔥【新增】处理AI发送图片(第二处)
                                console.log('解析到AI图片发送指令(第二处):', item);
                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'voice_message') {
                                // 🔥【新增】处理AI发送语音(第二处)
                                console.log('解析到AI语音发送指令(第二处):', item);
                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'transfer') {
                                // 🔥【新增】处理AI转账(第二处)
                                console.log('解析到AI转账指令(第二处):', item);
                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'update_poke_suffix') {
                                // 🔥【新增】处理戳一戳后缀更新(第二处)
                                console.log('解析到戳一戳后缀更新指令(第二处):', item);
                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'recalled_message') {
                                // 🔥【新增】处理撤回消息(第二处)
                                console.log('解析到撤回消息指令(第二处):', item);
                                processedMessages.push(item);
                            } else if (typeof item === 'string') {
                                // 🚨 【新增】检查并修复合并消息问题
                                if (item.includes('\n')) {
                                    console.warn('检测到AI将多条消息合并在一个元素中，正在自动分拆:', item);
                                    // 将换行符分隔的内容分拆成多条消息
                                    const splitMessages = item.split('\n')
                                        .map(msg => msg.trim())
                                        .filter(msg => msg.length > 0);
                                    processedMessages.push(...splitMessages);
                                } else {
                                    processedMessages.push(item);
                                }
                            } else {
                                processedMessages.push(item);
                            }
                        });
                        
                        return processedMessages;
                    }
                } 
            } catch (e) {} 
            
            // 🔥【修复】检查是否是原始的JSON字符串（AI回复没有被正确包装）
            if (content.trim().startsWith('{') && content.trim().endsWith('}')) {
                try {
                    const singleObject = JSON.parse(content.trim());
                    if (singleObject.type) {
                        console.log('检测到单个JSON对象，尝试处理:', singleObject);
                        // 将单个对象包装成数组再递归处理
                        return parseAiResponse(`[${content.trim()}]`);
                    }
                } catch (e) {
                    console.warn('无法解析单个JSON对象:', e);
                }
            }
            
            const lines = content.split('\n').map(l => l.trim()).filter(l => l.length > 0 && !l.startsWith('```')); 
            if (lines.length > 0) return lines; 
            return [content]; 
        }
        
        // 处理线下模式内容：识别「」包裹的对话和描写
        function processOfflineContent(content) {
            if (!content) return '';
            
            // 使用正则表达式分离对话和描写
            const parts = [];
            let lastIndex = 0;
            
            // 匹配「」包裹的对话
            const dialogRegex = /「([^」]*)」/g;
            let match;
            
            while ((match = dialogRegex.exec(content)) !== null) {
                // 添加对话前的描写部分
                if (match.index > lastIndex) {
                    const description = content.slice(lastIndex, match.index).trim();
                    if (description) {
                        parts.push(`<span class="italic-gray">${description}</span>`);
                    }
                }
                
                // 添加对话部分（正常显示）
                parts.push(`「${match[1]}」`);
                lastIndex = match.index + match[0].length;
            }
            
            // 添加最后的描写部分
            if (lastIndex < content.length) {
                const description = content.slice(lastIndex).trim();
                if (description) {
                    parts.push(`<span class="italic-gray">${description}</span>`);
                }
            }
            
            // 如果没有找到对话标记，整个内容作为描写处理
            if (parts.length === 0) {
                return `<span class="italic-gray">${content}</span>`;
            }
            
            return parts.join('');
        }
        


        // 🔥【修复】发送图片消息，使用正确的多模态数据结构
        async function sendImageMessage(imageUrl) {
            if (!currentChatCharacter) return;
            
            const chatInput = document.getElementById('api-chat-input');
            const textContent = chatInput ? chatInput.value.trim() : '';



            // 创建一个标准的多模态消息对象
            const messageContent = [
                { type: 'text', text: textContent }
            ];

            if (imageUrl) {
                messageContent.push({
                    type: 'image_url',
                    image_url: { url: imageUrl }
                });
            }



            const message = {
                id: Date.now().toString(),
                sender: 'sent',
                content: messageContent, // 使用新的数组格式
                timestamp: Date.now()
            };
            


            // 添加到聊天记录
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            chatMessages[currentChatCharacter.id].push(message);
            await saveChatMessages();
            
            // 清空输入框并刷新UI
            if (chatInput) {
                chatInput.value = '';
            }
            addMessageWithAnimation(message, currentChatCharacter.id);
            renderMessageList();
            
            // 设置为待回复消息，并更新智能回复按钮状态
            pendingUserMessage = message;
            
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = '点击获取AI回复';
            }
        }
        
        // 调用聊天API
        // 第一个callChatAPI函数已删除，使用下面的完整版本
        
        // 上传图片
        function uploadImage() {
            document.getElementById('image-upload').click();
        }
        
        // 显示图片
        function showImage(imageUrl) {
            // 首先检查是否是相册中的照片
            const photo = photos.find(p => p.image === imageUrl);
            if (photo) {
                document.getElementById('photo-image').style.backgroundImage = `url(${imageUrl})`;
                document.getElementById('photo-description-text').textContent = photo.description;
                document.getElementById('photo-time').textContent = `拍摄于: ${formatFullDate(new Date(photo.timestamp))}`;
                document.getElementById('photo-location').textContent = `地点: ${photo.location}`;
                showApp('photo-detail-screen');
            } else {
                // 如果不是相册照片，显示通用的图片预览模态框
                let modal = document.getElementById('image-preview-modal');
                if (!modal) {
                    modal = document.createElement('div');
                    modal.id = 'image-preview-modal';
                    modal.className = 'image-preview-modal';
                    modal.onclick = () => modal.style.display = 'none';
                    modal.innerHTML = `<img src="" alt="预览图片">`;
                    document.body.appendChild(modal);
                }
                modal.querySelector('img').src = imageUrl;
                modal.style.display = 'flex';
            }
        }
        
        // 显示聊天设置
        function showChatSettings() {
            console.log('显示聊天设置被调用');
            
            // 先隐藏当前的聊天界面
            hideApp('api-chat-screen');
            
            // 显示设置界面
            const element = document.getElementById('api-chat-settings-screen');
            if (element) {
                element.style.display = 'flex';
                element.style.position = 'absolute';
                element.style.top = '0';
                element.style.left = '0';
                element.style.width = '100%';
                element.style.height = '100%';
                element.style.zIndex = '1000';
                element.style.background = 'white';
                
                // 重新初始化聊天设置界面以加载当前设置
                initializeChatSettings();
                
                // 更新各种设置的显示状态
                updateWorldbookMountDisplay();
                
                // 检测当前聊天类型并显示相应设置
                const isGroupChat = currentChatCharacter && currentChatCharacter.isGroup;
                console.log('当前聊天类型:', isGroupChat ? '群聊' : '单聊');
                
                // 根据聊天类型显示不同的设置选项
                const groupChatSettings = document.getElementById('group-chat-settings');
                const pokeSettingsSection = document.getElementById('poke-settings-section');
                
                if (isGroupChat) {
                    // 群聊模式：显示群聊设置，隐藏戳一戳和单聊专用功能
                    if (groupChatSettings) groupChatSettings.style.display = 'block';
                    if (pokeSettingsSection) pokeSettingsSection.style.display = 'none';
                    
                    // 隐藏单聊专用设置项
                    const singleChatItems = document.querySelectorAll('.single-chat-only');
                    singleChatItems.forEach(item => item.style.display = 'none');
                    
                    // 更新群聊信息显示
                    updateGroupChatInfo();
                } else {
                    // 单聊模式：隐藏群聊设置，显示戳一戳和单聊专用功能
                    if (groupChatSettings) groupChatSettings.style.display = 'none';
                    if (pokeSettingsSection) pokeSettingsSection.style.display = 'block';
                    
                    // 显示单聊专用设置项
                    const singleChatItems = document.querySelectorAll('.single-chat-only');
                    singleChatItems.forEach(item => item.style.display = 'flex');
                }
                
                console.log('聊天设置界面已显示');
            } else {
                console.error('找不到api-chat-settings-screen元素');
                alert('设置界面未找到，请刷新页面重试');
            }
        }
        
        // 隐藏聊天设置
        function hideChatSettings() {
            hideApp('api-chat-settings-screen');
            // 返回到聊天界面
            if (currentChatCharacter) {
                showApp('api-chat-screen');
            }
        }
        
        // 修改角色头像
        function changeCharacterAvatar() {
            // 临时创建一个文件输入框，避免干扰原有的头像上传功能
            const tempInput = document.createElement('input');
            tempInput.type = 'file';
            tempInput.accept = 'image/*';
            tempInput.style.display = 'none';
            document.body.appendChild(tempInput);
            
            tempInput.onchange = function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = async function(event) {
                        const characterIndex = characters.findIndex(c => c.id === currentChatCharacter.id);
                        if (characterIndex !== -1) {
                            characters[characterIndex].avatarUrl = event.target.result;
                            await saveCharacters();
                            renderCharacterList();
                            renderContactList();
                            renderMessageList();
                            renderChatMessages(currentChatCharacter.id);
                        }
                        // 清理临时元素
                        document.body.removeChild(tempInput);
                    };
                    reader.readAsDataURL(e.target.files[0]);
                } else {
                    // 如果用户取消选择，也要清理临时元素
                    document.body.removeChild(tempInput);
                }
            };
            
            tempInput.click();
        }
        
        // 修改备注
        async function changeCharacterNickname() {
            const newName = prompt('请输入新的备注名称:', currentChatCharacter.name);
            if (newName && newName.trim() !== '') {
                const characterIndex = characters.findIndex(c => c.id === currentChatCharacter.id);
                if (characterIndex !== -1) {
                    characters[characterIndex].name = newName.trim();
                    await saveCharacters();
                    document.getElementById('api-chat-title').textContent = newName.trim();
                    renderCharacterList();
                    renderContactList();
                    renderMessageList();
                }
            }
        }
        
        // 查找聊天内容
        function searchChatContent() {
            const keyword = prompt('请输入要查找的关键词:');
            if (keyword && keyword.trim() !== '') {
                const messages = chatMessages[currentChatCharacter.id] || [];
                const foundMessages = messages.filter(msg => 
                    msg.content && msg.content.includes(keyword.trim())
                );
                
                if (foundMessages.length > 0) {
                    alert(`找到 ${foundMessages.length} 条包含"${keyword}"的消息`);
                } else {
                    alert(`没有找到包含"${keyword}"的消息`);
                }
            }
        }
        

        
        // 导出聊天记录
        function exportChatHistory() {
            const messages = chatMessages[currentChatCharacter.id] || [];
            let history = `与 ${currentChatCharacter.name} 的聊天记录\n\n`;
            
            messages.forEach(msg => {
                const time = formatTime(msg.timestamp);
                const sender = msg.sender === 'sent' ? '我' : currentChatCharacter.name;
                history += `${time} ${sender}: ${msg.content}\n`;
            });
            
            // 在实际应用中，这里可以实现导出文件功能
            console.log(history);
            alert('聊天记录已导出到控制台');
        }
        

        
        // 设置对方气泡颜色
        function changeTheirBubbleColor() {
            colorPickerContext = 'theirBubble';
            document.getElementById('color-picker-title').textContent = '设置对方气泡颜色';
            showModal('color-picker-modal');
        }
        
        // 设置我方气泡颜色
        function changeMyBubbleColor() {
            colorPickerContext = 'myBubble';
            document.getElementById('color-picker-title').textContent = '设置我方气泡颜色';
            showModal('color-picker-modal');
        }
        
        // 显示气泡颜色设置
        function showBubbleColorSettings() {
            alert('气泡颜色设置功能开发中...\n\n当前可以通过以下方式设置：\n• 修改对方气泡颜色\n• 修改我方气泡颜色');
        }
        
        // 清空聊天记录
        function clearChatHistory() {
            if (!currentChatCharacter) return;
            
            if (confirm(`确定要清空与 ${currentChatCharacter.name} 的所有聊天记录吗？\n\n此操作不可恢复！`)) {
                chatMessages[currentChatCharacter.id] = [];
                saveChatMessages();
                renderChatMessages(currentChatCharacter.id);
                renderMessageList(); // 更新消息列表
                alert('聊天记录已清空');
                hideChatSettings();
            }
        }
        
        // 选择颜色
        function selectColor(color) {
            document.querySelectorAll('.color-option').forEach(option => {
                option.classList.remove('selected');
            });
            event.target.classList.add('selected');
            document.getElementById('selected-color').value = color;
        }
        
        // 应用聊天背景
        function applyChatBackground() {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            const chatScreen = document.getElementById('api-chat-screen');
            const messagesContainer = document.getElementById('api-chat-messages');

            if (chatScreen) {
                if (chatSettings.chatBackground && chatSettings.chatBackground !== null) {
                    // 有背景图片
                    chatScreen.style.backgroundImage = `url(${chatSettings.chatBackground})`;
                    chatScreen.style.backgroundSize = 'cover';
                    chatScreen.style.backgroundPosition = 'center';
                    chatScreen.style.backgroundRepeat = 'no-repeat';
                    chatScreen.style.backgroundColor = 'transparent';
                    
                    // 让消息容器背景透明
                    if (messagesContainer) messagesContainer.style.background = 'transparent';
                } else {
                    // 没有背景图片或明确移除了背景
                    chatScreen.style.backgroundImage = 'none';
                    chatScreen.style.backgroundColor = 'white';
                    
                    // 恢复消息容器默认背景
                    if (messagesContainer) messagesContainer.style.background = ''; 
                }
            }
        }
        
        // 保存气泡样式设置
        function saveBubbleStyleSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // 保存样式设置
            chatSettings.bubbleStyle = window.selectedBubbleStyle || 'default';
            chatSettings.myBubbleColor = document.getElementById('my-bubble-color').value;
            chatSettings.aiBubbleColor = document.getElementById('ai-bubble-color').value;
            chatSettings.bubbleOpacity = document.getElementById('bubble-opacity').value;
            
            // 更新显示文本
            const styleNames = {
                'default': '默认样式',
                'glass': '毛玻璃',
                'shadow': '经典阴影',
                'tail': '经典气泡',
                'gradient': '渐变样式',
                'minimal': '极简样式',
                'neon': '霓虹样式',
                'paper': '纸张样式'
            };
            
            document.getElementById('current-bubble-style').textContent = styleNames[chatSettings.bubbleStyle] || '默认样式';
            
            saveCurrentChatSettings(chatSettings);
            applyBubbleStyle();
            hideModal('bubble-style-modal');
            
            showToast('气泡样式设置已保存', 'success');
        }
        
        // 应用气泡样式
        function applyBubbleStyle() {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            const messagesContainer = document.getElementById('api-chat-messages');
            
            if (messagesContainer) {
                // 移除所有样式类
                messagesContainer.className = messagesContainer.className
                    .split(' ')
                    .filter(cls => !cls.startsWith('bubble-style-'))
                    .join(' ');
                
                // 添加当前样式类
                const style = chatSettings.bubbleStyle || 'default';
                messagesContainer.classList.add(`bubble-style-${style}`);
                
                // 设置CSS变量用于动态颜色
                const myColor = chatSettings.myBubbleColor || '#007AFF';
                const aiColor = chatSettings.aiBubbleColor || '#f0f0f0';
                const opacity = chatSettings.bubbleOpacity || '1';
                
                messagesContainer.style.setProperty('--my-bubble-color', myColor);
                messagesContainer.style.setProperty('--ai-bubble-color', aiColor);
                messagesContainer.style.setProperty('--bubble-opacity', opacity);
            }
        }
        
        // 显示气泡颜色选择器
        function showBubbleColorPicker(context) {
            colorPickerContext = context;
            document.getElementById('color-picker-title').textContent = '设置气泡颜色';
            showModal('color-picker-modal');
        }
        
        // 选择颜色
        function selectColor(color) {
            document.querySelectorAll('.color-option').forEach(option => {
                option.classList.remove('selected');
            });
            event.target.classList.add('selected');
            document.getElementById('selected-color').value = color;
        }
        
        // 应用颜色选择
        async function applyColorSelection() {
            const selectedColor = document.querySelector('.color-option.selected')?.style.backgroundColor || '#007AFF';
            const opacity = document.getElementById('opacity-slider').value;
            
            if (colorPickerContext === 'theirBubble') {
                chatSettings.theirBubbleColor = selectedColor;
                chatSettings.bubbleOpacity = opacity;
            } else if (colorPickerContext === 'myBubble') {
                chatSettings.myBubbleColor = selectedColor;
                chatSettings.bubbleOpacity = opacity;
            }
            
            await saveChatSettings();
            renderChatMessages(currentChatCharacter.id);
            hideModal('color-picker-modal');
        }
        
        // 显示壁纸选择器
        function showWallpaperPicker() {
            showModal('wallpaper-picker-modal');
        }
        
        // 选择壁纸（保留函数以防其他地方调用，但现在主要通过文件上传选择）
        function selectWallpaper(wallpaperId) {
            console.log('选择壁纸:', wallpaperId);
            selectedWallpaper = wallpaperId;
            console.log('selectedWallpaper已设置为:', selectedWallpaper);
        }
        
        // 应用壁纸选择
        async function applyWallpaperSelection() {
            console.log('应用壁纸被调用，selectedWallpaper:', selectedWallpaper);
            
            if (!selectedWallpaper) {
                alert('请先从相册选择一张图片作为壁纸');
                return;
            }
            
            if (selectedWallpaper.startsWith('data:image')) {
                // 应用上传的图片壁纸
                console.log('应用图片壁纸');
                document.querySelector('.wallpaper').style.backgroundImage = `url(${selectedWallpaper})`;
                    document.querySelector('.wallpaper').style.backgroundSize = '100% 100%';
                    document.querySelector('.wallpaper').style.backgroundPosition = 'center';
                
                // 使用IndexedDB保存壁纸，避免localStorage空间限制
                try {
                    await db.wallpapers.clear();
                    await db.wallpapers.add({
                        id: 'main',
                        type: 'image',
                        data: selectedWallpaper
                    });
                    console.log('壁纸保存成功到IndexedDB');
            hideModal('wallpaper-picker-modal');
                } catch (e) {
                    console.error('保存壁纸失败:', e);
                    alert('保存壁纸失败，请重试');
                }
            } else {
                alert('请先从相册选择一张图片作为壁纸');
            }
        }
        
        // 上传自定义壁纸
        function uploadCustomWallpaper() {
            document.getElementById('custom-wallpaper-upload').click();
        }
        
        // 显示图标选择器
        function showIconPicker() {
            showModal('icon-picker-modal');
        }
        
        // 选择应用图标
        function selectAppIcon(appId, iconClass) {
            selectedAppIcon = { appId, iconClass };
        }
        
        // 上传自定义图标
        function uploadCustomIcon() {
            document.getElementById('custom-icon-upload').click();
        }
        
        // 应用图标选择
        function applyIconSelection() {
            if (selectedAppIcon && customIconImage) {
                // 更新应用图标
                const appIcon = document.querySelector(`.app[onclick="showApp('${selectedAppIcon.appId}')"] .app-icon`);
                if (appIcon) {
                    appIcon.innerHTML = '';
                    appIcon.style.backgroundImage = `url(${customIconImage})`;
                    
                    // 保存到本地存储
                    let savedIcons = {};
                    try {
                        savedIcons = JSON.parse(localStorage.getItem('appIcons') || '{}');
                    } catch (error) {
                        console.error('解析本地存储的 appIcons 失败:', error);
                        savedIcons = {};
                    }
                    savedIcons[selectedAppIcon.appId] = customIconImage;
                    localStorage.setItem('appIcons', JSON.stringify(savedIcons));
                }
            } else if (selectedAppIcon) {
                saveAppIcons();
            }
            hideModal('icon-picker-modal');
        }
        
        // 更改聊天主题颜色
        function changeChatThemeColor() {
            colorPickerContext = 'theme';
            document.getElementById('color-picker-title').textContent = '设置聊天主题颜色';
            showModal('color-picker-modal');
        }
        

        
        // 显示消息菜单
        function showMessageMenu(messageId, event) {
            selectedMessageId = messageId;
            
            // 创建或获取菜单元素
            let menu = document.getElementById('message-context-menu');
            if (!menu) {
                menu = document.createElement('div');
                menu.id = 'message-context-menu';
                menu.className = 'message-menu';
                menu.innerHTML = `
                    <div class="message-menu-item" onclick="copyMessage()">复制</div>
                    <div class="message-menu-item danger" onclick="deleteMessage()">删除</div>
                `;
                document.body.appendChild(menu);
            }
            
            // 定位菜单
            const x = event.clientX || event.pageX;
            const y = event.clientY || event.pageY;
            
            menu.style.display = 'block';
            menu.style.left = `${Math.min(x, window.innerWidth - 150)}px`;
            menu.style.top = `${Math.min(y, window.innerHeight - 100)}px`;
            
            // 点击其他地方关闭菜单
            setTimeout(() => {
                document.addEventListener('click', hideMessageMenu);
                document.addEventListener('touchstart', hideMessageMenu);
            }, 100);
        }
        
        // 隐藏消息菜单
        function hideMessageMenu() {
            const menu = document.getElementById('message-context-menu');
            if (menu) {
                menu.style.display = 'none';
            }
            document.removeEventListener('click', hideMessageMenu);
            document.removeEventListener('touchstart', hideMessageMenu);
        }
        
        // 复制消息
        function copyMessage() {
            if (!selectedMessageId) return;
            
            const messages = chatMessages[currentChatCharacter.id] || [];
            const message = messages.find(msg => msg.id === selectedMessageId);
            
            if (message && message.content) {
                navigator.clipboard.writeText(message.content).then(() => {
                    alert('消息已复制');
                }).catch(() => {
                    alert('复制失败，请重试');
                });
            }
            
            hideMessageMenu();
        }
        
        // 编辑消息
        function editMessage() {
            if (!selectedMessageId) return;
            
            const messages = chatMessages[currentChatCharacter.id] || [];
            const messageIndex = messages.findIndex(msg => msg.id === selectedMessageId);
            
            if (messageIndex !== -1 && messages[messageIndex].sender === 'sent') {
                const newContent = prompt('编辑消息:', messages[messageIndex].content);
                if (newContent !== null) {
                    messages[messageIndex].content = newContent;
                    saveChatMessages();
                    renderChatMessages(currentChatCharacter.id);
                }
            } else {
                alert('只能编辑自己发送的消息');
            }
            
            hideModal('message-menu-modal');
        }
        
        // 验证头像来源是否有效
        async function validateAvatarSource(avatarUrl) {
            console.log('验证头像来源:', avatarUrl);
            if (!avatarUrl) return false;
            
            // 检查是否是用户发送的图片（在聊天记录中）
            if (currentChatCharacter && chatMessages[currentChatCharacter.id]) {
                const userImages = chatMessages[currentChatCharacter.id]
                    .filter(msg => msg.sender === 'sent' && msg.image)
                    .map(msg => msg.image);
                
                console.log('用户发送的图片列表:', userImages);
                console.log('检查头像URL是否在用户图片中:', userImages.includes(avatarUrl));
                
                if (userImages.includes(avatarUrl)) {
                    console.log('头像来源验证通过：用户发送的图片');
                    return true;
                }
            }
            
            // 检查是否是世界书中提供的头像URL
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.worldbookMountEnabled && chatSettings.selectedWorldbooks) {
                for (const worldbookId of chatSettings.selectedWorldbooks) {
                    const worldbook = worldbooks.find(w => w.id === worldbookId);
                    if (worldbook && worldbook.content && worldbook.content.includes(avatarUrl)) {
                        console.log('头像来源验证通过：世界书中的URL');
                        return true;
                    }
                }
            }
            
            console.log('头像来源验证失败');
            return false;
        }
        
        // 角色主动更换头像功能 - 只修改聊天设置中的头像，不修改角色卡
        async function changeCharacterAvatarByAI(newAvatarUrl, reason = '') {
            if (!currentChatCharacter || !newAvatarUrl) return false;
            
            try {
                // 获取或创建当前聊天的设置
                const currentSettings = getCurrentChatSettings();
                
                // 压缩头像图片以减少存储空间
                let compressedAvatarUrl = newAvatarUrl;
                if (newAvatarUrl.startsWith('data:image')) {
                    try {
                        compressedAvatarUrl = await compressImage(newAvatarUrl, 200, 0.7);
                        console.log('头像已压缩以节省存储空间');
                    } catch (error) {
                        console.warn('头像压缩失败，使用原图:', error);
                    }
                }
                
                // 🔥【修复】使用动态头像字段，优先级高于用户设置的聊天头像
                if (!chatSettings[currentChatCharacter.id]) {
                    chatSettings[currentChatCharacter.id] = {};
                }
                chatSettings[currentChatCharacter.id].aiDynamicAvatar = compressedAvatarUrl;
                
                console.log(`动态头像已设置：`, {
                    characterId: currentChatCharacter.id,
                    characterName: currentChatCharacter.name,
                    avatarUrl: compressedAvatarUrl.substring(0, 50) + '...',
                    settingsSnapshot: {
                        aiDynamicAvatar: !!chatSettings[currentChatCharacter.id].aiDynamicAvatar,
                        aiChatAvatar: !!chatSettings[currentChatCharacter.id].aiChatAvatar
                    }
                });
                
                // 保存聊天设置
                await saveChatSettings();
                
                // 发送系统提示消息
                const systemMessage = {
                    id: Date.now().toString(),
                    sender: 'system',
                    content: `${currentChatCharacter.name} 更换了头像${reason ? ': ' + reason : ''}`,
                    timestamp: Date.now(),
                    isAvatarChange: true
                };
                
                if (!chatMessages[currentChatCharacter.id]) {
                    chatMessages[currentChatCharacter.id] = [];
                }
                chatMessages[currentChatCharacter.id].push(systemMessage);
                await saveChatMessages();
                
                // 🔥【修复】在保存消息后再刷新聊天界面，确保包含新头像和系统消息
                renderChatMessages(currentChatCharacter.id);
                
                // 🔥【新增】强制刷新所有头像显示
                forceRefreshAvatars();
                
                console.log(`角色 ${currentChatCharacter.name} 在当前聊天中更换了头像，但角色卡保持不变`);
                
                return true;
            } catch (error) {
                console.error('角色更换头像失败:', error);
                return false;
            }
            
            return false;
        }
        
        // 删除消息
        function deleteMessage() {
            if (!selectedMessageId) return;
            
                const messages = chatMessages[currentChatCharacter.id] || [];
                const messageIndex = messages.findIndex(msg => msg.id === selectedMessageId);
                
            if (messageIndex === -1) {
                hideMessageMenu();
                return;
            }
            
            const messageToDelete = messages[messageIndex];
            
            if (confirm('确定要撤回这条消息吗？')) {
                // 保存原始消息内容
                const originalContent = messageToDelete.content || '[图片]';
                
                // 删除原消息
                    messages.splice(messageIndex, 1);
                
                // 🔥【新增】创建撤回消息系统提醒
                const whoRecalled = messageToDelete.sender === 'received' ? currentChatCharacter.name : '你';
                const recallSystemMessage = {
                    id: Date.now().toString(),
                    sender: 'system',
                    content: `${whoRecalled} 撤回了一条消息\n原文：${originalContent}`,
                    timestamp: messageToDelete.timestamp || Date.now(),
                    isRecall: true
                };
                
                // 在原位置插入撤回提醒
                messages.splice(messageIndex, 0, recallSystemMessage);
                
                    saveChatMessages();
                    renderChatMessages(currentChatCharacter.id);
                    // 更新消息列表中的最后一条消息
                    renderMessageList();
            }
            
            hideMessageMenu();
        }
        

        
        // 格式化时间
        function formatTime(timestamp) {
            const date = new Date(timestamp);
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        }
        
        // 格式化时间戳（完整时间）
        function formatTimestamp(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const yesterday = new Date(today.getTime() - 24 * 60 * 60 * 1000);
            const messageDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            const timeStr = `${hours}:${minutes}`;
            
            if (messageDate.getTime() === today.getTime()) {
                return timeStr; // 今天只显示时间
            } else if (messageDate.getTime() === yesterday.getTime()) {
                return `昨天 ${timeStr}`;
            } else {
                const month = (date.getMonth() + 1).toString().padStart(2, '0');
                const day = date.getDate().toString().padStart(2, '0');
                return `${month}月${day}日 ${timeStr}`;
            }
        }
        
        // 格式化时间（仅时分）
        function formatTimeOnly(timestamp) {
            const date = new Date(timestamp);
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        }
        
        // 格式化完整日期
        function formatFullDate(date) {
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${year}年${month}月${day}日 ${hours}:${minutes}`;
        }
        
        // 加载URL
        function loadUrl() {
            const url = document.getElementById('browser-url').value;
            let fullUrl = url;
            
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                fullUrl = 'https://' + url;
            }
            
            document.getElementById('browser-frame').src = fullUrl;
        }
        
        // API类型切换处理
        function onApiTypeChange() {
            const apiType = document.getElementById('api-type').value;
            const baseInput = document.getElementById('api-base');
            const endpointGroup = document.getElementById('endpoint-group');
            const keyInput = document.getElementById('api-key');
            const modelInput = document.getElementById('api-model');
            const modelSelect = document.getElementById('api-model-select');
            const fetchModelsBtn = document.getElementById('fetch-models-btn');
            const modelHint = document.getElementById('model-hint');
            
            if (apiType === 'gemini') {
                baseInput.placeholder = 'https://generativelanguage.googleapis.com/v1beta';
                if (!baseInput.value || baseInput.value === 'https://api.openai.com/v1') {
                    baseInput.value = 'https://generativelanguage.googleapis.com/v1beta';
                }
                endpointGroup.style.display = 'none';
                keyInput.placeholder = 'AIzaSy...（从Google AI Studio获取）';
                modelInput.style.display = 'none';
                modelSelect.style.display = 'block';
                fetchModelsBtn.style.display = 'block';
                modelHint.textContent = '点击"获取模型"自动拉取可用模型列表';
            } else {
                if (apiType === 'openai') {
                    baseInput.placeholder = 'https://api.openai.com/v1';
                    if (!baseInput.value || baseInput.value === 'https://generativelanguage.googleapis.com/v1beta') {
                        baseInput.value = 'https://api.openai.com/v1';
                    }
                    keyInput.placeholder = 'sk-xxxxxxxxxxxxxxxx';
                    modelHint.textContent = '例如: gpt-4o, gpt-3.5-turbo';
                } else if (apiType === 'anthropic') {
                    baseInput.placeholder = 'https://api.anthropic.com';
                    if (!baseInput.value || baseInput.value.includes('googleapis.com')) {
                        baseInput.value = 'https://api.anthropic.com';
                    }
                    keyInput.placeholder = 'sk-ant-xxxxxxxxxxxxxxxx';
                    modelHint.textContent = '例如: claude-3-sonnet-20240229';
                } else if (apiType === 'azure') {
                    baseInput.placeholder = 'https://your-resource.openai.azure.com';
                    keyInput.placeholder = 'your-api-key';
                    modelHint.textContent = '输入您的部署名称';
                }
                endpointGroup.style.display = 'block';
                modelInput.style.display = 'block';
                modelSelect.style.display = 'none';
                fetchModelsBtn.style.display = 'none';
            }
        }
        
        // 测试API连接
        async function testApiConnection() {
            const testBtn = event.target;
            const originalText = testBtn.textContent;
            testBtn.textContent = '测试中...';
            testBtn.disabled = true;
            
            try {
                // 获取当前设置
                const tempSettings = {
                    type: document.getElementById('api-type').value,
                    base: document.getElementById('api-base').value.trim(),
                    endpoint: document.getElementById('api-endpoint').value.trim(),
                    key: document.getElementById('api-key').value.trim(),
                    model: document.getElementById('api-type').value === 'gemini' ? 
                           document.getElementById('api-model-select').value : 
                           document.getElementById('api-model').value.trim(),
                    temperature: parseFloat(document.getElementById('api-temperature').value) || 0.70
                };
                
                if (!tempSettings.key) {
                    throw new Error('请先输入API密钥');
                }
                
                if (!tempSettings.base) {
                    throw new Error('请输入API基地址');
                }
                
                if (!tempSettings.model) {
                    throw new Error('请输入模型名称');
                }
                
                let url, headers, requestBody;
                
                if (tempSettings.type === 'gemini') {
                    // 修复Gemini API URL
                    const baseUrl = tempSettings.base.endsWith('/') ? tempSettings.base.slice(0, -1) : tempSettings.base;
                    url = `${baseUrl}/models/${tempSettings.model}:generateContent?key=${tempSettings.key}`;
                    headers = {
                        'Content-Type': 'application/json'
                    };
                    requestBody = {
                        contents: [{
                            parts: [{
                                text: '你好，这是一个连接测试。请简单回复"连接成功"即可。'
                            }]
                        }],
                        generationConfig: {
                            temperature: tempSettings.temperature
                        },
                        safetySettings: [
                            {
                                category: "HARM_CATEGORY_HARASSMENT",
                                threshold: "BLOCK_NONE"
                            },
                            {
                                category: "HARM_CATEGORY_HATE_SPEECH",
                                threshold: "BLOCK_NONE"
                            },
                            {
                                category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                                threshold: "BLOCK_NONE"
                            },
                            {
                                category: "HARM_CATEGORY_DANGEROUS_CONTENT",
                                threshold: "BLOCK_NONE"
                            }
                        ]
                    };
                } else {
                    // OpenAI兼容格式
                    const baseUrl = tempSettings.base.endsWith('/') ? tempSettings.base.slice(0, -1) : tempSettings.base;
                    const endpoint = tempSettings.endpoint.startsWith('/') ? tempSettings.endpoint : '/' + tempSettings.endpoint;
                    url = baseUrl + endpoint;
                    headers = {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${tempSettings.key}`
                    };
                    requestBody = {
                        model: tempSettings.model,
                        messages: [
                            { role: 'user', content: '你好，这是一个连接测试。请简单回复"连接成功"即可。' }
                        ],
                        temperature: tempSettings.temperature
                    };
                }
                
                console.log('测试API连接 - URL:', url);
                console.log('测试API连接 - Headers:', headers);
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) {
                    let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        console.log('错误响应详情:', errorData);
                        errorMessage = errorData.error?.message || errorData.message || errorMessage;
                    } catch (e) {
                        const text = await response.text();
                        console.log('错误响应文本:', text);
                        errorMessage += '\n\n详细信息: ' + text;
                    }
                    throw new Error(errorMessage);
                }
                
                const data = await response.json();
                console.log('API响应:', data);
                
                let responseText;
                
                if (tempSettings.type === 'gemini') {
                    responseText = data.candidates?.[0]?.content?.parts?.[0]?.text;
                } else {
                    responseText = data.choices?.[0]?.message?.content;
                }
                
                if (responseText) {
                    alert('✅ API连接测试成功！\n\n回复内容：' + responseText);
                } else {
                    alert('⚠️ API连接成功，但返回格式可能有问题\n\n原始响应：' + JSON.stringify(data, null, 2));
                }
                
            } catch (error) {
                console.error('API测试失败:', error);
                let errorMsg = error.message;
                
                // 针对常见错误提供解决建议
                if (errorMsg.includes('CORS')) {
                    errorMsg += '\n\n💡 建议：请检查是否需要使用反代地址，或者API服务是否支持跨域请求。';
                } else if (errorMsg.includes('401') || errorMsg.includes('API key')) {
                    errorMsg += '\n\n💡 建议：请检查API密钥是否正确，以及是否有权限访问该模型。';
                } else if (errorMsg.includes('404')) {
                    errorMsg += '\n\n💡 建议：请检查API基地址和模型名称是否正确。';
                } else if (errorMsg.includes('403')) {
                    errorMsg += '\n\n💡 建议：API密钥权限不足或账户余额不足。';
                }
                
                alert('❌ API连接测试失败\n\n错误信息：' + errorMsg);
            } finally {
                testBtn.textContent = originalText;
                testBtn.disabled = false;
            }
        }
        
        // 获取模型列表
        async function fetchModels() {
            const fetchBtn = document.getElementById('fetch-models-btn');
            const originalText = fetchBtn.textContent;
            fetchBtn.textContent = '获取中...';
            fetchBtn.disabled = true;
            
            try {
                const apiKey = document.getElementById('api-key').value.trim();
                const baseUrl = document.getElementById('api-base').value.trim();
                
                if (!apiKey) {
                    throw new Error('请先输入API密钥');
                }
                
                if (!baseUrl) {
                    throw new Error('请先输入API基地址');
                }
                
                // 构建获取模型列表的URL
                const modelsUrl = `${baseUrl.endsWith('/') ? baseUrl.slice(0, -1) : baseUrl}/models?key=${apiKey}`;
                
                console.log('获取模型列表 - URL:', modelsUrl);
                
                const response = await fetch(modelsUrl, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('模型列表响应:', data);
                
                const modelSelect = document.getElementById('api-model-select');
                modelSelect.innerHTML = '<option value="">选择模型...</option>';
                
                if (data.models && Array.isArray(data.models)) {
                    data.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.name.startsWith('models/') ? model.name.substring(7) : model.name;
                        option.textContent = `${option.value} (${model.displayName || model.name})`;
                        modelSelect.appendChild(option);
                    });
                    
                    alert(`✅ 成功获取到 ${data.models.length} 个模型`);
                } else {
                    throw new Error('API返回的模型列表格式不正确');
                }
                
            } catch (error) {
                console.error('获取模型列表失败:', error);
                alert('❌ 获取模型列表失败\n\n错误信息：' + error.message);
            } finally {
                fetchBtn.textContent = originalText;
                fetchBtn.disabled = false;
            }
        }
        
        // 保存API设置
        function saveApiSettings() {
            const baseUrl = document.getElementById('api-base').value.trim();
            const apiKey = document.getElementById('api-key').value.trim();
            const model = document.getElementById('model-select').value.trim();
            const temperature = parseFloat(document.getElementById('temperature-slider').value) || 0.75;
            
            if (!baseUrl || !apiKey || !model) {
                showToast('请填写完整的API配置信息', 'error');
                return;
            }
            
            apiSettings = {
                base: baseUrl,
                key: apiKey,
                model: model,
                temperature: temperature
            };
            
            localStorage.setItem('apiSettings', JSON.stringify(apiSettings));
            showToast('API设置已保存！', 'success');
            
            // 更新温度显示
            document.getElementById('temperature-value').textContent = temperature.toFixed(2);
            
            // 修复：返回设置应用而不是主屏幕
            hideApp('api-settings-screen');
            showApp('settings-screen');
        }
        
        // 🌟 Gemini直连快速设置
        function setGeminiDirect() {
            // 自动填充Gemini配置
            document.getElementById('api-base').value = 'https://generativelanguage.googleapis.com/v1beta';
            document.getElementById('api-key').placeholder = '请输入Google AI Studio的API Key';
            
            // 清空之前的模型选择并添加Gemini模型
            const modelSelect = document.getElementById('model-select');
            modelSelect.innerHTML = `
                <option value="">请选择模型...</option>
                <option value="gemini-2.0-flash-exp">gemini-2.0-flash-exp (推荐)</option>
                <option value="gemini-1.5-pro">gemini-1.5-pro (稳定)</option>
                <option value="gemini-1.5-flash">gemini-1.5-flash (快速)</option>
                <option value="gemini-pro">gemini-pro</option>
            `;
            
            showToast('🌟 Gemini直连配置已自动填写！请输入API Key并选择模型', 'success');
        }
        
        // 🤗 HuggingFace反代快速设置
        function setHuggingFaceProxy() {
            // 自动填充HuggingFace反代配置 - 使用正确的格式
            document.getElementById('api-base').value = '@https://xxx-xxx.hf.space/v1';
            document.getElementById('api-key').placeholder = '请输入HuggingFace的API Token';
            
            // 清空之前的模型选择并添加HF模型
            const modelSelect = document.getElementById('model-select');
            modelSelect.innerHTML = `
                <option value="">请选择模型...</option>
                <option value="meta-llama/Llama-2-7b-chat-hf">Llama-2-7b-chat</option>
                <option value="microsoft/DialoGPT-large">DialoGPT-large</option>
                <option value="facebook/blenderbot-400M-distill">BlenderBot</option>
                <option value="anthropic/claude-3-haiku-20240307">Claude-3-Haiku</option>
                <option value="microsoft/DialoGPT-medium">DialoGPT-medium</option>
            `;
            
            showToast('🤗 HuggingFace反代配置已自动填写！请将地址中的 xxx-xxx 替换为实际的HF Space地址', 'success');
        }
        
        // 保存当前配置为预设
        function saveCurrentConfig() {
            const configName = document.getElementById('config-name-input').value.trim();
            
            if (!configName) {
                showToast('请输入配置名称', 'error');
                return;
            }
            
            const currentConfig = {
                name: configName,
                base: document.getElementById('api-base').value.trim(),
                key: document.getElementById('api-key').value.trim(),
                model: document.getElementById('model-select').value.trim(),
                temperature: parseFloat(document.getElementById('temperature-slider').value) || 0.75,
                savedAt: new Date().toLocaleString()
            };
            
            // 获取已保存的配置
            let savedConfigs = JSON.parse(localStorage.getItem('savedApiConfigs') || '[]');
            
            // 检查是否已存在同名配置
            const existingIndex = savedConfigs.findIndex(config => config.name === configName);
            if (existingIndex !== -1) {
                if (confirm(`配置"${configName}"已存在，是否覆盖？`)) {
                    savedConfigs[existingIndex] = currentConfig;
                } else {
                    return;
                }
            } else {
                savedConfigs.push(currentConfig);
            }
            
            localStorage.setItem('savedApiConfigs', JSON.stringify(savedConfigs));
            document.getElementById('config-name-input').value = '';
            
            renderSavedConfigs();
            showToast(`配置"${configName}"已保存`, 'success');
        }
        
        // 渲染已保存的配置
        function renderSavedConfigs() {
            const container = document.getElementById('saved-configs-container');
            const noConfigsMessage = document.getElementById('no-configs-message');
            const savedConfigs = JSON.parse(localStorage.getItem('savedApiConfigs') || '[]');
            
            if (savedConfigs.length === 0) {
                container.style.display = 'none';
                noConfigsMessage.style.display = 'block';
                return;
            }
            
            container.style.display = 'grid';
            noConfigsMessage.style.display = 'none';
            
            container.innerHTML = savedConfigs.map(config => `
                <div class="config-card" style="background: rgba(255,255,255,0.8); border-radius: 12px; padding: 15px; border: 1px solid rgba(0,0,0,0.05); transition: all 0.3s ease; cursor: pointer;" onclick="loadConfig('${config.name}')">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                        <div style="font-weight: 600; color: #333; font-size: 15px;">${config.name}</div>
                        <button onclick="event.stopPropagation(); deleteConfig('${config.name}')" style="background: none; border: none; color: #ff6b6b; cursor: pointer; padding: 2px 6px; border-radius: 4px; font-size: 12px; transition: all 0.2s ease;" onmouseover="this.style.background='rgba(255,107,107,0.1)'" onmouseout="this.style.background='none'">🗑️</button>
                    </div>
                    <div style="font-size: 12px; color: #666; margin-bottom: 4px;">
                        <div>🌐 ${config.base}</div>
                        <div>🤖 ${config.model}</div>
                        <div>🌡️ 温度: ${config.temperature}</div>
                    </div>
                    <div style="font-size: 11px; color: #999;">保存于: ${config.savedAt}</div>
                </div>
            `).join('');
        }
        
        // 加载配置
        function loadConfig(configName) {
            const savedConfigs = JSON.parse(localStorage.getItem('savedApiConfigs') || '[]');
            const config = savedConfigs.find(c => c.name === configName);
            
            if (!config) {
                showToast('配置不存在', 'error');
                return;
            }
            
            // 填充表单
            document.getElementById('api-base').value = config.base;
            document.getElementById('api-key').value = config.key;
            document.getElementById('temperature-slider').value = config.temperature;
            document.getElementById('temperature-value').textContent = config.temperature.toFixed(2);
            
            // 处理模型选择
            const modelSelect = document.getElementById('model-select');
            const existingOption = Array.from(modelSelect.options).find(option => option.value === config.model);
            if (!existingOption) {
                // 如果模型不在当前选项中，添加它
                const newOption = new Option(config.model, config.model);
                modelSelect.appendChild(newOption);
            }
            modelSelect.value = config.model;
            
            showToast(`已加载配置"${configName}"`, 'success');
        }
        
        // 删除配置
        function deleteConfig(configName) {
            if (confirm(`确定要删除配置"${configName}"吗？`)) {
                let savedConfigs = JSON.parse(localStorage.getItem('savedApiConfigs') || '[]');
                savedConfigs = savedConfigs.filter(config => config.name !== configName);
                localStorage.setItem('savedApiConfigs', JSON.stringify(savedConfigs));
                renderSavedConfigs();
                showToast(`配置"${configName}"已删除`, 'success');
            }
        }
        
        // 清空所有配置
        function clearAllConfigs() {
            if (confirm('确定要清空所有已保存的配置吗？此操作不可恢复。')) {
                localStorage.removeItem('savedApiConfigs');
                renderSavedConfigs();
                showToast('所有配置已清空', 'success');
            }
        }
        
        // 测试API连接
        async function testApiConnection() {
            const baseUrl = document.getElementById('api-base').value.trim();
            const apiKey = document.getElementById('api-key').value.trim();
            const model = document.getElementById('model-select').value.trim();
            
            if (!baseUrl || !apiKey || !model) {
                showToast('请先填写完整的API配置', 'error');
                return;
            }
            
            const testBtn = document.getElementById('test-api-connection-btn');
            const originalText = testBtn.textContent;
            testBtn.textContent = '测试中...';
            testBtn.disabled = true;
            
            try {
                // 根据不同的API类型构建测试请求
                let testUrl, testPayload, testHeaders;
                
                if (baseUrl.includes('generativelanguage.googleapis.com')) {
                    // Gemini API测试
                    testUrl = `${baseUrl}/models/${model}:generateContent?key=${apiKey}`;
                    testPayload = {
                        contents: [{
                            parts: [{ text: "Hello" }]
                        }]
                    };
                    testHeaders = {
                        'Content-Type': 'application/json'
                    };
                } else {
                    // OpenAI兼容API测试
                    testUrl = `${baseUrl}/v1/chat/completions`;
                    testPayload = {
                        model: model,
                        messages: [{ role: "user", content: "Hello" }],
                        max_tokens: 10
                    };
                    testHeaders = {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    };
                }
                
                const response = await fetch(testUrl, {
                    method: 'POST',
                    headers: testHeaders,
                    body: JSON.stringify(testPayload)
                });
                
                if (response.ok) {
                    showToast('✅ API连接测试成功！', 'success');
                } else {
                    const errorText = await response.text();
                    showToast(`❌ API连接失败: ${response.status} ${response.statusText}`, 'error');
                    console.error('API测试失败:', errorText);
                }
            } catch (error) {
                showToast(`❌ 连接错误: ${error.message}`, 'error');
                console.error('API测试错误:', error);
            } finally {
                testBtn.textContent = originalText;
                testBtn.disabled = false;
            }
        }
        
        // 获取模型列表
        async function fetchModels() {
            const baseUrl = document.getElementById('api-base').value.trim();
            const apiKey = document.getElementById('api-key').value.trim();
            
            if (!baseUrl || !apiKey) {
                showToast('请先填写API地址和密钥', 'error');
                return;
            }
            
            const fetchBtn = document.getElementById('fetch-models-btn');
            const originalText = fetchBtn.textContent;
            fetchBtn.textContent = '获取中...';
            fetchBtn.disabled = true;
            
            try {
                let modelsUrl, headers;
                
                if (baseUrl.includes('generativelanguage.googleapis.com')) {
                    // Gemini API
                    modelsUrl = `${baseUrl}/models?key=${apiKey}`;
                    headers = {};
                } else {
                    // OpenAI兼容API
                    modelsUrl = `${baseUrl}/v1/models`;
                    headers = {
                        'Authorization': `Bearer ${apiKey}`
                    };
                }
                
                const response = await fetch(modelsUrl, { headers });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                const modelSelect = document.getElementById('model-select');
                
                // 清空现有选项
                modelSelect.innerHTML = '<option value="">请选择模型...</option>';
                
                let models = [];
                if (data.models) {
                    // Gemini API格式
                    models = data.models
                        .filter(model => model.name.includes('generate'))
                        .map(model => model.name.split('/').pop());
                } else if (data.data) {
                    // OpenAI API格式
                    models = data.data.map(model => model.id);
                }
                
                models.forEach(modelId => {
                    const option = new Option(modelId, modelId);
                    modelSelect.appendChild(option);
                });
                
                showToast(`✅ 成功获取到 ${models.length} 个模型`, 'success');
            } catch (error) {
                showToast(`❌ 获取模型失败: ${error.message}`, 'error');
                console.error('获取模型失败:', error);
            } finally {
                fetchBtn.textContent = originalText;
                fetchBtn.disabled = false;
            }
        }
        
        // 导出完整备份
        function exportFullBackup() {
            // 这里可以实现完整的数据导出功能
            showToast('导出功能开发中...', 'info');
        }
        
        // 导入完整备份
        function importFullBackup() {
            // 这里可以实现完整的数据导入功能
            document.getElementById('import-full-backup-input').click();
        }
        
        // 初始化API设置界面
        function initializeApiSettings() {
            // 加载已保存的API配置
            loadApiSettings();
            
            // 渲染已保存的配置
            renderSavedConfigs();
        }
        
        // 加载API设置
        function loadApiSettings() {
            const savedSettings = localStorage.getItem('apiSettings');
            if (savedSettings) {
                try {
                    const settings = JSON.parse(savedSettings);
                    
                    // 填充表单字段
                    if (settings.base) {
                        const baseInput = document.getElementById('api-base');
                        if (baseInput) baseInput.value = settings.base;
                    }
                    
                    if (settings.key) {
                        const keyInput = document.getElementById('api-key');
                        if (keyInput) keyInput.value = settings.key;
                    }
                    
                    if (settings.model) {
                        const modelSelect = document.getElementById('model-select');
                        if (modelSelect) {
                            // 如果模型不在选项中，添加它
                            const existingOption = Array.from(modelSelect.options).find(option => option.value === settings.model);
                            if (!existingOption) {
                                const newOption = new Option(settings.model, settings.model);
                                modelSelect.appendChild(newOption);
                            }
                            modelSelect.value = settings.model;
                        }
                    }
                    
                    if (settings.temperature !== undefined) {
                        const tempSlider = document.getElementById('temperature-slider');
                        const tempValue = document.getElementById('temperature-value');
                        if (tempSlider && tempValue) {
                            tempSlider.value = settings.temperature;
                            tempValue.textContent = settings.temperature.toFixed(2);
                        }
                    }
                } catch (error) {
                    console.error('加载API设置失败:', error);
                }
            }
        }
        
        // 电池管理功能
        async function initBatteryManager() {
            console.log('开始初始化电池管理器...');
            
            // 首先设置默认显示为 ᰔᩚ
            const allBatteryTexts = document.querySelectorAll('.battery-text');
            console.log('找到的电池文本元素数量:', allBatteryTexts.length);
            
            allBatteryTexts.forEach((element, index) => {
                console.log(`设置电池文本 ${index}:`, element);
                element.textContent = 'ᰔᩚ';
            });
            
            if ('getBattery' in navigator) {
                try {
                    console.log('浏览器支持电池API，正在获取电池信息...');
                    const battery = await navigator.getBattery();
                    console.log('电池信息:', {
                        level: battery.level,
                        charging: battery.charging
                    });
                    updateBatteryDisplay(battery);
                    
                    battery.addEventListener('levelchange', () => updateBatteryDisplay(battery));
                    battery.addEventListener('chargingchange', () => updateBatteryDisplay(battery));
                } catch (err) {
                    console.error("无法获取电池信息:", err);
                    // 保持默认显示 ᰔᩚ
                    allBatteryTexts.forEach(element => {
                        element.textContent = 'ᰔᩚ';
                    });
                }
            } else {
                console.log("浏览器不支持电池状态API，使用默认显示。");
                // 保持默认显示 ᰔᩚ
                allBatteryTexts.forEach(element => {
                    element.textContent = 'ᰔᩚ';
                });
            }
        }
        
        function updateBatteryDisplay(battery) {
            const level = Math.floor(battery.level * 100);
            const isCharging = battery.charging;
            
            console.log(`更新电池显示: ${level}%, 充电中: ${isCharging}`);
            
            // 更新主状态栏电池
            const batteryContainer = document.getElementById('status-bar-battery');
            console.log('主状态栏电池容器:', batteryContainer);
            
            if (batteryContainer) {
                const batteryLevelEl = batteryContainer.querySelector('.battery-level');
                const batteryTextEl = batteryContainer.querySelector('.battery-text');
                
                console.log('电池元素:', { batteryLevelEl, batteryTextEl });
                
                if (batteryLevelEl && batteryTextEl) {
                    batteryLevelEl.style.width = `${level}%`;
                    batteryTextEl.textContent = `${level}%`;
                    console.log(`设置主屏幕电池文本为: ${level}%`);
                    
                    if (isCharging) {
                        batteryContainer.classList.add('charging');
                    } else {
                        batteryContainer.classList.remove('charging');
                    }
                }
            }
            
            // 更新应用内状态栏电池
            const appBatteryContainers = document.querySelectorAll('.app-battery-container');
            const appBatteryTexts = document.querySelectorAll('.app-battery-container .battery-text');
            const appBatteryLevels = document.querySelectorAll('.app-battery-level');
            
            // 应用内也显示真实电量
            appBatteryTexts.forEach(element => {
                element.textContent = `${level}%`;
            });
            
            appBatteryLevels.forEach(element => {
                element.style.width = `${level}%`;
            });
            
            // 同步应用内电池充电状态
            appBatteryContainers.forEach(container => {
                if (isCharging) {
                    container.classList.add('charging');
                } else {
                    container.classList.remove('charging');
                }
            });
        }
        
        // 手动测试电池显示功能 - 您可以在浏览器控制台中调用这个函数
        function testBatteryDisplay() {
            console.log('=== 电池显示测试开始 ===');
            
            // 检查电池文本元素
            const allBatteryTexts = document.querySelectorAll('.battery-text');
            console.log('所有电池文本元素:', allBatteryTexts);
            
            allBatteryTexts.forEach((element, index) => {
                console.log(`电池文本 ${index}:`, element, '当前内容:', element.textContent);
            });
            
            // 检查主屏幕电池容器
            const mainBattery = document.getElementById('status-bar-battery');
            console.log('主屏幕电池容器:', mainBattery);
            
            if (mainBattery) {
                const batteryText = mainBattery.querySelector('.battery-text');
                console.log('主屏幕电池文本元素:', batteryText);
                console.log('主屏幕电池文本内容:', batteryText ? batteryText.textContent : 'null');
            }
            
            // 测试设置为百分比
            console.log('测试设置为77%...');
            allBatteryTexts.forEach((element, index) => {
                element.textContent = '77%';
                console.log(`电池文本 ${index} 设置为 77%`);
            });
            
            // 3秒后恢复为爱心
            setTimeout(() => {
                console.log('恢复为爱心符号...');
                allBatteryTexts.forEach((element, index) => {
                    element.textContent = 'ᰔᩚ';
                    console.log(`电池文本 ${index} 恢复为 ᰔᩚ`);
                });
            }, 3000);
            
            console.log('=== 电池显示测试结束 ===');
        }
        
        // 主题切换功能
        function changeTheme(themeName) {
            const body = document.body;
            
            // 移除之前的主题
            body.removeAttribute('data-theme');
            
            // 应用新主题
            if (themeName !== 'default') {
                body.setAttribute('data-theme', themeName);
            }
            
            // 保存主题设置
            localStorage.setItem('selectedTheme', themeName);
            
            // 给用户反馈
            const themeNames = {
                'default': '简约风格',
                'cute': '可爱风格',
                'nature': '自然风格', 
                'tech': '科技风格',
                'dream': '梦幻风格'
            };
            
            // 显示Toast提示
            showToast(`已切换到 ${themeNames[themeName]} 主题！`, 'success');
        }
        
        // 加载保存的主题
        function loadSavedTheme() {
            const savedTheme = localStorage.getItem('selectedTheme');
            if (savedTheme && savedTheme !== 'default') {
                document.body.setAttribute('data-theme', savedTheme);
            }
        }
        
        // 世界书相关功能
        let worldbooks = [];
        let editingWorldbook = null;
        
        // 加载世界书数据 - 使用IndexedDB（包含数据迁移）
        async function loadWorldbooks() {
            try {
                // 先从IndexedDB加载
                const savedWorldbooks = await db.worldbooks.toArray();
                
                if (savedWorldbooks.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('worldbooks');
                    if (localStorageData) {
                        console.log('检测到localStorage中的世界书数据，开始迁移...');
                        const localWorldbooks = JSON.parse(localStorageData);
                        
                        if (localWorldbooks.length > 0) {
                            // 确保每个世界书都有id字段
                            const migrationData = localWorldbooks.map(wb => ({
                                id: wb.id || Date.now().toString() + Math.random(),
                                title: wb.title,
                                content: wb.content,
                                createdAt: wb.createdAt || new Date().toISOString(),
                                updatedAt: wb.updatedAt || new Date().toISOString()
                            }));
                            
                            // 迁移到IndexedDB
                            await db.worldbooks.bulkAdd(migrationData);
                            worldbooks = migrationData;
                            console.log('世界书数据迁移完成:', worldbooks);
                        } else {
                            worldbooks = [];
                        }
                    } else {
                        worldbooks = [];
                    }
                } else {
                    // IndexedDB中有数据，直接使用
                    worldbooks = savedWorldbooks;
                    console.log('从IndexedDB加载世界书数据:', worldbooks);
                }
            } catch (error) {
                console.error('加载世界书失败:', error);
                // 如果IndexedDB失败，回退到localStorage
                const localStorageData = localStorage.getItem('worldbooks');
                if (localStorageData) {
                    try {
                        worldbooks = JSON.parse(localStorageData);
                } catch (e) {
                        worldbooks = [];
                    }
                } else {
                    worldbooks = [];
                }
            }
            renderWorldbookList();
        }
        
        // 保存世界书数据 - 使用IndexedDB
        async function saveWorldbooks() {
            try {
                console.log('保存世界书数据到IndexedDB:', worldbooks);
                
                // 清空现有数据
                await db.worldbooks.clear();
                
                // 批量插入新数据
                if (worldbooks.length > 0) {
                    await db.worldbooks.bulkAdd(worldbooks);
                }
                
                console.log('世界书数据保存成功');
            } catch (error) {
                console.error('保存世界书时发生错误:', error);
                // 如果IndexedDB失败，回退到localStorage
            localStorage.setItem('worldbooks', JSON.stringify(worldbooks));
            }
        }
        
        function showWorldbookForm(isGlobal) {
    // 根据传入的类型（全局/局部）来决定表单标题
    const title = isGlobal ? '新建全局设定' : '新建局部设定';
    document.getElementById('worldbook-form-title').textContent = title;

    editingWorldbook = null; // 清除编辑状态
            document.getElementById('worldbook-title').value = '';
            document.getElementById('worldbook-content').value = '';

    // 将创建类型暂存起来，以便保存时使用
    window.newWorldbookIsGlobal = isGlobal;

            showApp('worldbook-form-screen');
        }
        
        function hideWorldbookForm() {
            hideApp('worldbook-form-screen');
            // 确保返回到世界书应用，而不是主屏幕
            showApp('worldbook-screen');
        }
        
        async function saveWorldbook() {
            const title = document.getElementById('worldbook-title').value.trim();
            const content = document.getElementById('worldbook-content').value.trim();
            
    if (!title || !content) {
        alert('请输入标题和内容');
                return;
            }
            
    let isGlobal;
    if (editingWorldbook) {
        // 如果是编辑模式，保持其原有的类型不变
        isGlobal = editingWorldbook.isGlobal;
    } else {
        // 如果是新建模式，读取我们暂存的类型
        isGlobal = window.newWorldbookIsGlobal;
            }
            
            const worldbook = {
                id: editingWorldbook ? editingWorldbook.id : Date.now().toString(),
                title: title,
                content: content,
        isGlobal: isGlobal, // 根据正确的状态设置
                createdAt: editingWorldbook ? editingWorldbook.createdAt : new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };
            
            if (editingWorldbook) {
                const index = worldbooks.findIndex(w => w.id === editingWorldbook.id);
        if (index !== -1) worldbooks[index] = worldbook;
            } else {
                worldbooks.push(worldbook);
            }
            
            await saveWorldbooks();
            renderWorldbookList();
            showToast(editingWorldbook ? '世界书已更新！' : '世界书已创建！', 'success');
            hideWorldbookForm();
        }
// --- 新增函数 ---
async function toggleGlobalWorldbook(bookId, isEnabled) {
    if (isEnabled) {
        // 如果开启，添加到激活列表（如果不存在）
        if (!activeGlobalWorldbooks.includes(bookId)) {
            activeGlobalWorldbooks.push(bookId);
        }
    } else {
        // 如果关闭，从激活列表中移除
        activeGlobalWorldbooks = activeGlobalWorldbooks.filter(id => id !== bookId);
    }
    
    // 保存激活状态到数据库的 globalSettings 表
    try {
        await db.globalSettings.put({
            id: 'main',
            activeGlobalWorldbooks: activeGlobalWorldbooks
        });
        showToast('全局设定已更新', 'success');
    } catch (error) {
        console.error("保存全局世界书设置失败:", error);
        showToast('设置保存失败', 'error');
    }
        }
        
        function editWorldbook(id) {
            const worldbook = worldbooks.find(w => w.id === id);
            if (worldbook) {
                editingWorldbook = worldbook;
        // 编辑时不显示“新建”，而是“编辑”
        const title = worldbook.isGlobal ? '编辑全局设定' : '编辑局部设定';
        document.getElementById('worldbook-form-title').textContent = title;
                document.getElementById('worldbook-title').value = worldbook.title;
                document.getElementById('worldbook-content').value = worldbook.content;
                showApp('worldbook-form-screen');
            }
        }
        
        async function deleteWorldbook(id) {
            if (confirm('确定要删除这个世界书吗？')) {
                worldbooks = worldbooks.filter(w => w.id !== id);
                await saveWorldbooks();
                renderWorldbookList();
            }
        }
        
// 用这段新代码，完整替换掉旧的 renderWorldbookList 函数
        function renderWorldbookList() {
    const globalContainer = document.getElementById('global-worldbooks-content');
    const localContainer = document.getElementById('local-worldbooks-content');
    if (!globalContainer || !localContainer) return;

    const globalBooks = worldbooks.filter(w => w.isGlobal);
    const localBooks = worldbooks.filter(w => !w.isGlobal);

    let globalHtml = '';
    let localHtml = '';

    // --- 渲染全局世界书 ---
    globalHtml += `
        <div class="worldbook-section">

    `;
    if (globalBooks.length > 0) {
        globalBooks.forEach(book => {
            const isChecked = window.activeGlobalWorldbooks && window.activeGlobalWorldbooks.includes(book.id) ? 'checked' : '';
                        globalHtml += `
                <div class="setting-item" onclick="editWorldbook('${book.id}')">
                    <div class="setting-left">
                        <div class="setting-label">${book.title}</div>
                        <div class="setting-desc">${truncateText(book.content, 60)}</div>
                    </div>
                    <div class="setting-right">
                        <label class="toggle-switch" onclick="event.stopPropagation()">
                            <input type="checkbox" onchange="toggleGlobalWorldbook('${book.id}', this.checked)" ${isChecked}>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
            `;
        });
    } else {
        globalHtml += '<div class="empty-message">暂无全局设定</div>';
    }
    globalHtml += '</div>';

    // --- 渲染局部世界书 ---
    localHtml += `
        <div class="worldbook-section">

    `;
    if (localBooks.length > 0) {
        localBooks.forEach(book => {
            const date = new Date(book.updatedAt).toLocaleDateString();
            const preview = truncateText(book.content, 60);
            localHtml += `
                <div class="worldbook-item" onclick="editWorldbook('${book.id}')">
                        <div class="worldbook-header">
                        <div class="worldbook-content-flex">
                            <div class="worldbook-title">${book.title}</div>
                                <div class="worldbook-desc-text">${preview}</div>
                                <div class="worldbook-date-text">更新于 ${date}</div>
                            </div>
                        <button onclick="event.stopPropagation(); deleteWorldbook('${book.id}')" class="delete-worldbook-btn">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                `;
        });
    } else {
        localHtml += '<div class="empty-message">暂无局部设定</div>';
    }
    localHtml += '</div>';

    globalContainer.innerHTML = globalHtml;
    localContainer.innerHTML = localHtml;
}
function switchWorldbookTab(tabName) {
    currentWorldbookTab = tabName; // <--- 核心修改：记录当前标签页

    const globalContent = document.getElementById('global-worldbooks-content');
    const localContent = document.getElementById('local-worldbooks-content');
    const tabs = document.querySelectorAll('.worldbook-tab');

    tabs.forEach(tab => {
        if (tab.getAttribute('onclick').includes(tabName)) {
            tab.classList.add('active');
        } else {
            tab.classList.remove('active');
        }
    });

    if (tabName === 'global') {
        globalContent.style.display = 'block';
        localContent.style.display = 'none';
    } else {
        globalContent.style.display = 'none';
        localContent.style.display = 'block';
    }
}
function onWorldbookAddClick() {
    if (currentWorldbookTab === 'global') {
        showWorldbookForm(true); // 创建全局设定
    } else {
        showWorldbookForm(false); // 创建局部设定
    }
        }
        
        // 音乐应用相关功能
        let playlist = [];
        let currentSong = null;
        let isPlaying = false;
        let listeningCharacters = [];
        
        function loadMusicData() {
            const savedPlaylist = localStorage.getItem('musicPlaylist');
            if (savedPlaylist) {
                try {
                    playlist = JSON.parse(savedPlaylist);
                } catch (e) {
                    playlist = [];
                }
            }
            
            const savedListeners = localStorage.getItem('listeningCharacters');
            if (savedListeners) {
                try {
                    listeningCharacters = JSON.parse(savedListeners);
                } catch (e) {
                    listeningCharacters = [];
                }
            }
            
            renderPlaylist();
            renderListeningCharacters();
        }
        
        function saveMusicData() {
            localStorage.setItem('musicPlaylist', JSON.stringify(playlist));
            localStorage.setItem('listeningCharacters', JSON.stringify(listeningCharacters));
        }
        
        function addMusicToPlaylist() {
            const title = prompt('请输入歌曲名称:');
            if (title && title.trim()) {
                const artist = prompt('请输入艺术家名称:') || '未知艺术家';
                const song = {
                    id: Date.now().toString(),
                    title: title.trim(),
                    artist: artist.trim(),
                    duration: '3:30' // 模拟时长
                };
                
                playlist.push(song);
                saveMusicData();
                renderPlaylist();
            }
        }
        
        function playSong(songId) {
            const song = playlist.find(s => s.id === songId);
            if (song) {
                currentSong = song;
                document.getElementById('song-title').textContent = song.title;
                document.getElementById('artist-name').textContent = song.artist;
                document.getElementById('total-time').textContent = song.duration;
                
                // 更新播放按钮
                const playBtn = document.getElementById('play-pause-btn');
                playBtn.innerHTML = '<i class="fas fa-pause"></i>';
                isPlaying = true;
                
                // 模拟播放进度
                simulatePlayback();
                
                // 通知听歌角色
                notifyListeningCharacters(song);
            }
        }
        
        function togglePlayPause() {
            const playBtn = document.getElementById('play-pause-btn');
            if (isPlaying) {
                playBtn.innerHTML = '<i class="fas fa-play"></i>';
                isPlaying = false;
            } else {
                if (currentSong) {
                    playBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    isPlaying = true;
                    simulatePlayback();
                } else if (playlist.length > 0) {
                    playSong(playlist[0].id);
                }
            }
        }
        
        function previousSong() {
            if (!currentSong || playlist.length === 0) return;
            
            const currentIndex = playlist.findIndex(s => s.id === currentSong.id);
            const prevIndex = currentIndex > 0 ? currentIndex - 1 : playlist.length - 1;
            playSong(playlist[prevIndex].id);
        }
        
        function nextSong() {
            if (!currentSong || playlist.length === 0) return;
            
            const currentIndex = playlist.findIndex(s => s.id === currentSong.id);
            const nextIndex = currentIndex < playlist.length - 1 ? currentIndex + 1 : 0;
            playSong(playlist[nextIndex].id);
        }
        
        function simulatePlayback() {
            if (!isPlaying) return;
            
            // 这里只是模拟进度，实际应用中需要真实的音频播放
            let progress = 0;
            const interval = setInterval(() => {
                if (!isPlaying) {
                    clearInterval(interval);
                    return;
                }
                
                progress += 1;
                document.getElementById('progress').style.width = `${Math.min(progress, 100)}%`;
                
                const currentMinutes = Math.floor(progress * 3.5 / 100);
                const currentSeconds = Math.floor((progress * 3.5 / 100 - currentMinutes) * 60);
                document.getElementById('current-time').textContent = 
                    `${currentMinutes}:${currentSeconds.toString().padStart(2, '0')}`;
                
                if (progress >= 100) {
                    clearInterval(interval);
                    nextSong();
                }
            }, 100);
        }
        
        function inviteCharacterToListen() {
            const availableCharacters = characters.filter(c => 
                !listeningCharacters.find(lc => lc.id === c.id)
            );
            
            if (availableCharacters.length === 0) {
                alert('没有可邀请的角色了，或者所有角色都已经在听歌');
                return;
            }
            
            const characterNames = availableCharacters.map((c, index) => `${index + 1}. ${c.name}`).join('\n');
            const choice = prompt(`选择要邀请的角色:\n${characterNames}\n\n请输入数字:`);
            
            if (choice && !isNaN(choice)) {
                const index = parseInt(choice) - 1;
                if (index >= 0 && index < availableCharacters.length) {
                    const character = availableCharacters[index];
                    listeningCharacters.push({
                        id: character.id,
                        name: character.name,
                        avatar: character.avatarUrl || character.name.charAt(0),
                        joinedAt: new Date().toISOString()
                    });
                    
                    saveMusicData();
                    renderListeningCharacters();
                    
                    // 模拟角色响应
                    setTimeout(() => {
                        alert(`${character.name}: 好的，我来和你一起听歌！`);
                    }, 500);
                }
            }
        }
        
        function removeListeningCharacter(characterId) {
            listeningCharacters = listeningCharacters.filter(c => c.id !== characterId);
            saveMusicData();
            renderListeningCharacters();
        }
        
        function notifyListeningCharacters(song) {
            listeningCharacters.forEach(character => {
                // 模拟角色对音乐的反应
                const reactions = [
                    `${character.name}: 这首歌真好听！`,
                    `${character.name}: 我也很喜欢这首《${song.title}》`,
                    `${character.name}: 听着这音乐心情真好～`,
                    `${character.name}: 谢谢分享这么棒的音乐！`
                ];
                
                const reaction = reactions[Math.floor(Math.random() * reactions.length)];
                
                setTimeout(() => {
                    // 可以在这里显示角色的反应消息
                    console.log(reaction);
                }, Math.random() * 3000 + 1000);
            });
        }
        
        function renderPlaylist() {
            const playlistContainer = document.getElementById('playlist');
            if (!playlistContainer) return;
            
            if (playlist.length === 0) {
                playlistContainer.innerHTML = '<div class="empty-playlist">播放列表为空，点击+号添加音乐</div>';
                return;
            }
            
            const html = playlist.map(song => `
                <div class="playlist-item" onclick="playSong('${song.id}')">
                    <div>
                        <div class="song-title">${song.title}</div>
                        <div class="song-artist">${song.artist}</div>
                    </div>
                    <div class="song-duration">${song.duration}</div>
                </div>
            `).join('');
            
            playlistContainer.innerHTML = html;
        }
        
        function renderListeningCharacters() {
            const container = document.getElementById('listening-characters');
            if (!container) return;
            
            if (listeningCharacters.length === 0) {
                container.innerHTML = '<div class="empty-playlist">没有角色在听歌，点击+号邀请角色</div>';
                return;
            }
            
            const html = listeningCharacters.map(character => `
                <div class="character-item">
                    <div class="character-avatar" style="background-image: url(${character.avatar}); background-size: cover; background-position: center;">
                        ${character.avatar.startsWith('http') ? '' : character.name.charAt(0)}
                    </div>
                    <div class="character-name">${character.name}</div>
                    <div class="listening-status">正在听歌</div>
                    <button onclick="removeListeningCharacter('${character.id}')" class="remove-character-btn">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `).join('');
            
            container.innerHTML = html;
        }
        
        // ================== 面具系统相关功能 ==================
        
        // 加载面具数据 - 使用IndexedDB（包含数据迁移）
        async function loadPersonas() {
            try {
                // 先从IndexedDB加载
                const savedPersonas = await db.personas.toArray();
                
                if (savedPersonas.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('personas');
                    if (localStorageData) {
                        console.log('检测到localStorage中的面具数据，开始迁移...');
                        const localPersonas = JSON.parse(localStorageData);
                        
                        if (localPersonas.length > 0) {
                            // 确保每个面具都有必要字段
                            const migrationData = localPersonas.map(persona => ({
                                id: persona.id || Date.now().toString() + Math.random(),
                                name: persona.name,
                                description: persona.description || '',
                                avatarUrl: persona.avatarUrl || '',
                                isDefault: persona.isDefault || false,
                                createdAt: persona.createdAt || new Date().toISOString(),
                                updatedAt: persona.updatedAt || new Date().toISOString()
                            }));
                            
                            // 迁移到IndexedDB
                            await db.personas.bulkAdd(migrationData);
                            personas = migrationData;
                            console.log('面具数据迁移完成:', personas);
                        } else {
                            personas = [];
                        }
                    } else {
                        personas = [];
                    }
                } else {
                    // IndexedDB中有数据，直接使用
                    personas = savedPersonas;
                    console.log('从IndexedDB加载面具数据:', personas);
                }
                
                // 设置当前面具（暂时保持localStorage，因为这是一个小数据）
                const savedCurrentPersona = localStorage.getItem('currentPersona');
                if (savedCurrentPersona) {
                    currentPersona = personas.find(p => p.id === savedCurrentPersona) || null;
                } else {
                    currentPersona = null; // 不自动选择，需要用户主动选择
                }
                
            } catch (error) {
                console.error('加载面具失败:', error);
                // 如果IndexedDB失败，回退到localStorage
                const localStorageData = localStorage.getItem('personas');
                if (localStorageData) {
                    try {
                        personas = JSON.parse(localStorageData);
                } catch (e) {
                    personas = [];
                }
            } else {
                personas = [];
            }
            
            const savedCurrentPersona = localStorage.getItem('currentPersona');
            if (savedCurrentPersona) {
                currentPersona = personas.find(p => p.id === savedCurrentPersona) || null;
            } else {
                currentPersona = null; // 不自动选择，需要用户主动选择
                }
            }
            
            updateCurrentPersonaDisplay();
        }
        
        // 保存面具数据 - 使用IndexedDB
        async function savePersonas() {
            try {
                console.log('保存面具数据到IndexedDB:', personas);
                
                // 清空现有数据
                await db.personas.clear();
                
                // 批量插入新数据
                if (personas.length > 0) {
                    await db.personas.bulkAdd(personas);
                }
                
                console.log('面具数据保存成功');
            } catch (error) {
                console.error('保存面具时发生错误:', error);
                // 如果IndexedDB失败，回退到localStorage
            localStorage.setItem('personas', JSON.stringify(personas));
            }
        }
        
        // 保存当前使用的面具（保持localStorage，因为数据量小）
        function saveCurrentPersona() {
            if (currentPersona) {
                localStorage.setItem('currentPersona', currentPersona.id);
            }
        }
        
        // 显示面具创建表单
        function showPersonaForm(personaId = null) {
            editingPersona = personaId ? personas.find(p => p.id === personaId) : null;
            
            document.getElementById('persona-form-title').textContent = editingPersona ? '编辑面具' : '新建面具';
            
            // 清空表单
            document.getElementById('persona-name').value = editingPersona ? editingPersona.name : '';
            document.getElementById('persona-description').value = editingPersona ? editingPersona.description : '';
            
            // 重置头像预览
            const avatarPreview = document.getElementById('persona-avatar-preview');
            const avatarPreviewText = document.getElementById('persona-avatar-preview-text');
            
            avatarPreview.classList.remove('has-image');
            avatarPreview.style.removeProperty('background');
            avatarPreview.style.removeProperty('background-size');
            avatarPreview.style.removeProperty('background-position');
            avatarPreview.style.removeProperty('background-repeat');
            
            if (editingPersona && editingPersona.avatarUrl) {
                avatarPreview.classList.add('has-image');
                avatarPreview.style.setProperty('background', `url(${editingPersona.avatarUrl})`, 'important');
                avatarPreview.style.setProperty('background-size', 'cover', 'important');
                avatarPreview.style.setProperty('background-position', 'center', 'important');
                avatarPreview.style.setProperty('background-repeat', 'no-repeat', 'important');
                avatarPreviewText.style.display = 'none';
                window.selectedPersonaAvatarData = editingPersona.avatarUrl;
            } else {
                avatarPreviewText.style.display = 'block';
                avatarPreviewText.textContent = editingPersona ? editingPersona.name.charAt(0) : '我';
                window.selectedPersonaAvatarData = null;
            }
            
            // 初始化头像上传功能
            initializePersonaAvatarUpload();
            
            showApp('persona-form-screen');
        }
        
        // 隐藏面具表单
        function hidePersonaForm() {
            hideApp('persona-form-screen');
            showApp('chat-screen');
            switchChatTab('profile-page');
            // 清空临时数据
            window.selectedPersonaAvatarData = null;
            editingPersona = null;
        }
        
        // 保存面具
        async function savePersona() {
            const name = document.getElementById('persona-name').value.trim();
            const description = document.getElementById('persona-description').value.trim();
            const avatarData = window.selectedPersonaAvatarData;
            
            if (!name) {
                alert('请输入面具名称');
                return;
            }
            
            if (editingPersona) {
                // 更新现有面具
                const index = personas.findIndex(p => p.id === editingPersona.id);
                if (index !== -1) {
                    const oldAvatarUrl = personas[index].avatarUrl;
                    
                    personas[index] = {
                        ...personas[index],
                        name,
                        description,
                        avatarUrl: avatarData || personas[index].avatarUrl || '',
                        updatedAt: new Date().toISOString()
                    };
                    
                    // 🔥【修复3】如果更新的是当前使用的面具，且头像发生了变化，刷新对话框显示
                    if (currentPersona && currentPersona.id === editingPersona.id) {
                        currentPersona = personas[index]; // 更新当前面具数据
                        saveCurrentPersona(); // 保存到本地存储
                        
                        // 如果头像发生了变化且当前在聊天界面，刷新聊天消息显示
                        if (avatarData && avatarData !== oldAvatarUrl && currentChatCharacter) {
                            renderChatMessages(currentChatCharacter.id);
                        }
                    }
                }
            } else {
                // 创建新面具
                const newPersona = {
                    id: Date.now().toString(),
                    name,
                    description,
                    avatarUrl: avatarData || '',
                    isDefault: false,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };
                personas.push(newPersona);
            }
            
            await savePersonas();
            renderPersonaList();
            hidePersonaForm();
                            showToast('面具保存成功！', 'success');
        }
        
        // 删除面具
        async function deletePersona(personaId) {
            const persona = personas.find(p => p.id === personaId);
            if (!persona) return;
            
            if (confirm(`确定要删除面具"${persona.name}"吗？`)) {
                personas = personas.filter(p => p.id !== personaId);
                
                // 如果删除的是当前面具，清空当前面具
                if (currentPersona && currentPersona.id === personaId) {
                    currentPersona = null; // 清空，不自动选择其他面具
                    localStorage.removeItem('currentPersona'); // 清除保存的面具选择
                    updateCurrentPersonaDisplay();
                }
                
                await savePersonas();
                renderPersonaList();
            }
        }
        
        // 切换面具
        function switchPersona(personaId) {
            const persona = personas.find(p => p.id === personaId);
            if (persona) {
                currentPersona = persona;
                saveCurrentPersona();
                updateCurrentPersonaDisplay();
                renderPersonaList();
                
                // 如果当前在群聊设置界面，更新群成员显示
                if (currentChatCharacter && currentChatCharacter.isGroup) {
                    updateGroupChatInfo();
                }
                
                alert(`已切换到面具"${persona.name}"`);
            }
        }
        
        // 更新当前面具显示（该函数已无实际用途，但保留以避免调用错误）
        function updateCurrentPersonaDisplay() {
            // 空函数，保留函数定义以避免其他地方的调用出错
        }
        
        // 渲染面具列表
        function renderPersonaList() {
            const listContainer = document.getElementById('persona-list');
            if (!listContainer) return;
            
            if (personas.length === 0) {
                listContainer.innerHTML = '<div class="empty-personas">还没有面具，点击右上角+号创建一个吧！</div>';
                return;
            }
            
            const html = personas.map(persona => `
                <div class="persona-item ${currentPersona && currentPersona.id === persona.id ? 'active' : ''}" onclick="switchPersona('${persona.id}')">
                    <div class="persona-avatar" style="${persona.avatarUrl ? `background-image: url(${persona.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                        ${persona.avatarUrl ? '' : persona.name.charAt(0)}
                    </div>
                    <div class="persona-info">
                        <div class="persona-name">${persona.name}</div>
                                                    <div class="persona-description">${truncateText(persona.description || '暂无描述', 40)}</div>
                    </div>
                    <div class="persona-actions">
                        <button class="persona-action-btn persona-edit-btn" onclick="event.stopPropagation(); showPersonaForm('${persona.id}')">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="persona-action-btn persona-delete-btn" onclick="event.stopPropagation(); deletePersona('${persona.id}')">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `).join('');
            
            listContainer.innerHTML = html;
        }
        
        // 初始化面具头像上传功能
        function initializePersonaAvatarUpload() {
            const avatarInput = document.getElementById('persona-avatar-upload');
            if (!avatarInput) {
                console.error('找不到persona-avatar-upload元素');
                return;
            }
            
            // 移除旧的事件监听器
            avatarInput.removeEventListener('change', personaAvatarUploadHandler);
            
            // 添加新的事件监听器
            avatarInput.addEventListener('change', personaAvatarUploadHandler);
            console.log('面具头像上传事件监听器已绑定');
        }
        
        // 面具头像上传处理函数
        function personaAvatarUploadHandler(e) {
            if (e.target.files && e.target.files[0]) {
                const file = e.target.files[0];
                
                // 检查文件类型
                if (!file.type.startsWith('image/')) {
                    alert('请选择图片文件');
                    e.target.value = '';
                    return;
                }
                
                // 检查文件大小 (限制为5MB)
                if (file.size > 5 * 1024 * 1024) {
                    alert('图片文件过大，请选择小于5MB的图片');
                    e.target.value = '';
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const avatarPreview = document.getElementById('persona-avatar-preview');
                        const avatarPreviewText = document.getElementById('persona-avatar-preview-text');
                        
                        if (!avatarPreview) {
                            alert('找不到头像预览元素');
                            return;
                        }
                        
                        // 设置头像预览
                        avatarPreview.classList.add('has-image');
                        avatarPreview.style.setProperty('background', `url(${event.target.result})`, 'important');
                        avatarPreview.style.setProperty('background-size', 'cover', 'important');
                        avatarPreview.style.setProperty('background-position', 'center', 'important');
                        avatarPreview.style.setProperty('background-repeat', 'no-repeat', 'important');
                        
                        if (avatarPreviewText) {
                            avatarPreviewText.style.display = 'none';
                        }
                        
                        // 存储图片数据
                        window.selectedPersonaAvatarData = event.target.result;
                        
                        console.log('面具头像预览设置成功');
                    } catch (error) {
                        console.error('设置面具头像预览时发生错误:', error);
                        alert('设置头像预览失败，请重试: ' + error.message);
                    }
                };
                
                reader.onerror = function() {
                    alert('图片读取失败，请重试');
                    e.target.value = '';
                };
                
                reader.readAsDataURL(file);
            }
        }
        
        // 面具头像上传点击处理
        function handlePersonaAvatarUploadClick() {
            const input = document.getElementById('persona-avatar-upload');
            if (input) {
                input.click();
            } else {
                alert('找不到文件上传元素，请刷新页面重试');
            }
        }
        
        function buildCharacterPrompt(character, hasImage = false) {
            const chatSettings = getCurrentChatSettings();
            const currentTime = new Date().toLocaleString('zh-CN', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                weekday: 'long'
            });
            
    // --- 核心指令区 ---
    let characterPrompt = `
# **首要规则：输出格式**
你的所有回复，**【必须】**、**【严格】**遵循JSON数组格式。这是一个绝对的、不可违反的规则。

## **正确格式示例:**
- **普通文本:** \`["你好"]\`
- **多条消息:** \`["你好", "今天天气不错！"]\`
- **表情包:** \`[{"type": "emoji", "description": "笑哭的表情"}]\`
- **语音消息:** \`[{"type": "voice_message", "content": "我等下和你说。"}]\`
- **转账:** \`[{"type": "transfer", "amount": 520, "note": "给你的奖励"}]\`
- **更换头像:** \`[{"type": "change_avatar", "avatar_url": "图片URL", "reason": "心情变化"}]\`
- **混合消息:** \`["嗨！", {"type": "emoji", "description": "太阳"}]\`

## **【绝对禁止】的错误格式:**
- **错误1 (合并消息):** \`["你好\\n今天天气不错！"]\` <== 这是最常见的错误，绝对禁止！
- **错误2 (非数组):** \`"你好"\`
- **错误3 (无效JSON):** \`[{'type': 'emoji'}]\`

# **你的角色与任务**
你现在扮演名为"${character.name}"的角色。

## **角色设定:**
${character.bio}

## **当前情景:**
- **当前时间:** ${currentTime}
`;
    // --- 核心指令区结束 ---

    // 加入对话者信息 (已修复)
    const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
    if (selectedPersona) {
        let userInfo = `\n- **对话者身份:** 用户的身份面具是"${selectedPersona.name}"`;
        if (selectedPersona.description) {
            userInfo += `，描述为：${selectedPersona.description}。`;
        }
        // 检查是否有特定于此群聊的昵称，并告知AI
        if (chatSettings.myChatNickname && chatSettings.myChatNickname !== selectedPersona.name) {
            userInfo += ` 在这个群聊里，TA的昵称是 **"${chatSettings.myChatNickname}"**，请优先使用这个昵称。`;
        }
        characterPrompt += userInfo;
    }

            if (hasImage) {
        characterPrompt += `\n- **任务:** 用户发送了一张图片，请仔细分析并以你的角色身份进行回应。`;
    } else {
        characterPrompt += `\n- **任务:** 根据对话上下文，以你的角色身份进行自然回应。`;
    }

    const localBookIds = chatSettings.selectedWorldbooks || [];
    const allBookIds = [...new Set([...activeGlobalWorldbooks, ...localBookIds])]; // 合并并去重

    if (allBookIds.length > 0) {
        characterPrompt += `\n\n【背景知识/世界观】以下是相关的设定信息，请在对话中自然地运用：\n`;
        allBookIds.forEach(bookId => {
            const worldbook = worldbooks.find(w => w.id === bookId);
                    if (worldbook) {
                characterPrompt += `\n--- ${worldbook.title} ---\n${worldbook.content}\n`;
                    }
                });
            }
            
            const chatMode = chatSettings.chatMode || 'online';
            const isGroupChat = character && character.isGroup;
            let modeInstructions = '';
            let taskInstructions = '';
            
            if (chatMode === 'online') {
                modeInstructions = `\n# 聊天模式：线上模式\n- 你必须按照手机聊天或面对面对话的格式进行输出\n- **严格禁止**任何动作描写、神态描写、心理描写\n- 只能进行纯语言交流，不能描述任何身体动作、表情、环境等\n- 每条消息都应该是可以通过文字直接表达的内容`;
                if (isGroupChat) {
            const membersList = character.members.map(member => `**${member.name}**: ${member.bio}`).join('\n');
                    taskInstructions = `\n# 你的任务：\n你需要扮演以下群成员角色，在群聊中进行自然对话：\n${membersList}\n\n1. 你可以扮演任何一个群成员角色进行回复，但不能扮演用户。\n2. 你的回复必须是一个JSON数组格式的字符串，每个元素是一个对象：{"name": "角色名", "message": "消息内容"}。\n3. 你可以生成1~8条消息，模拟群聊中多个角色的互动。\n4. 每条消息不能超过25字，要简短有力。\n5. 禁止进行任何有关线下面对面互动的神态描写、动作描写。\n6. 自然地演绎各个角色，让他们有不同的说话风格。\n7. 绝对不能使用用户的名字发言。\n\n# JSON输出格式示例:\n[{"name": "小明", "message": "大家好呀！"}, {"name": "小红", "message": "今天天气真好"}, {"name": "小明", "message": "想出去走走吗？"}]`;
                } else {
                    taskInstructions = `\n1. 请你以你的角色的身份，严格按照角色设定进行回复和行动，不要跳出角色。自然地推进剧情。\n2. 你可以一次性生成多条消息，模拟真人在聊天中连续发送多条信息的情景。\n3. 你的回复必须是一个JSON数组格式的字符串，每个元素是一条消息。\n\n# JSON输出格式示例:\n["很高兴认识你呀，在干嘛呢？", "今天天气真好", "想出去走走吗？"]`;
                }
            } else {
                modeInstructions = `\n# 聊天模式：线下模式\n- 你可以进行线下剧情互动，包含动作、神态、心理描写\n- 使用第三人称"他/她"或你的角色名字"${character.name}"来称呼自己\n- 使用第二人称"你"来称呼用户\n- **重要格式要求**：所有内容合并为一条消息，对话部分用「」包裹，描写部分直接书写\n- 每条消息总长度不少于100个字符\n- 可以描述动作、表情、环境、心理活动等\n- 输出格式示例：\n  ["「我想你了。」${character.name}凑近了些，低声说着，语气里满是眷念，像一只许久未见主人的宠物犬。他轻轻握住你的手，放在脸颊边蹭了蹭。「真的…很想你。」"]`;
                if (isGroupChat) {
            const membersList = character.members.map(member => `**${member.name}**: ${member.bio}`).join('\n');
                    taskInstructions = `\n# 你的任务：\n你需要扮演以下群成员角色，在群聊中进行线下剧情互动：\n${membersList}\n\n1. 你可以扮演任何一个群成员角色进行回复，但不能扮演用户。\n2. 你的回复必须是一个JSON数组格式的字符串，每个元素是一个对象：{"name": "角色名", "message": "消息内容"}。\n3. 你可以生成1~3条消息，模拟群聊中几个角色的线下互动。\n4. 每条消息不少于100字，要有充分的剧情描写。\n5. 使用「」包裹对话部分，描写部分直接书写。\n6. 可以进行线下面对面的剧情互动，包括身体接触、环境描写等。\n7. 自然地演绎各个角色，让他们有不同的行为风格。\n8. 绝对不能使用用户的名字发言。\n\n# JSON输出格式示例:\n[{"name": "小明", "message": "「你好！」小明热情地挥了挥手，脸上带着灿烂的笑容。他快步走向你，眼中闪烁着兴奋的光芒。「今天天气真好，我们一起出去走走吧！」他伸出手，想要拉住你的手腕。"}, {"name": "小红", "message": "「我也想去！」小红从旁边跑了过来，她的马尾辫在阳光下轻轻摆动。「我知道一个很棒的地方，那里有很多漂亮的花！」她兴奋地拍着手，眼睛亮晶晶的。"}]`;
                } else {
                    taskInstructions = `\n# 你的任务：\n1. 请用你的角色设定自然地进行单聊剧情互动，按照角色设定扮演角色进行回复和行动。\n2. **重要**：你的回复必须是一个JSON数组格式的字符串，但**只能包含一个元素**（一条消息）。\n3. 将所有想说的话、动作、表情都合并到这一条消息中，使用「」包裹对话部分，描写部分直接书写。\n4. 可以进行线下面对面的剧情互动，包括身体接触、环境描写等。\n5. 自然地演绎角色，不要解释自己是AI。\n6. 每条消息不少于100字。\n\n# JSON输出格式示例:\n["「小夜！」${character.name}正低着头，似乎在处理着什么数据，听到你的声音，他猛地抬起头来。「你是什么时候...过来的？」有些困惑地看着你，脸上带着淡淡的红晕。"]`;
                }
            }
            
            characterPrompt += modeInstructions;
    characterPrompt += taskInstructions;
            // 🔥【修复】表情包库信息 - 改为温和的语气，避免过度强调
            if (customEmojis && customEmojis.length > 0) {
                characterPrompt += `\n\n# 可用表情包库：\n当你觉得合适的时候，可以根据角色性格、情绪和当前对话情境，自主选择使用以下已上传的表情包来丰富对话。当你想表达强烈或特殊的情绪时，可以发送表情包来让对话更生动。\n\n表情包列表：\n`;
                
                customEmojis.forEach((emoji, index) => {
                    characterPrompt += `${index + 1}. ${emoji.description || '表情包'}\n`;
                });
                
                characterPrompt += `\n## 使用规则：\n- 只能使用上述列表中的表情包，禁止虚构\n- 发送格式：{"type": "emoji", "description": "具体的表情包描述"}\n- 合适的时候使用即可，以普通对话为主\n- 必须使用表情包列表中完全一致的描述文字\n\n示例：["你好！", "今天心情真好~", {"type": "emoji", "description": "笑哭的表情"}]`;
            }
            
            const aiImageInstructions = `\n# 发送图片的能力\n- 你无法发送真实的图片文件。但当用户要求你发送照片，或者你想通过图片来表达时，你可以发送一张"文字描述的图片"。\n- 若要发送图片，必须在你的回复JSON数组中，单独发送一个特殊的对象，格式为：\`{"type": "ai_image", "description": "这里是对图片的详细文字描述..."}\`。这个描述应该生动、具体，让用户能通过文字想象出画面，以第三人称视角描述。例如：\`{"type": "ai_image", "description": "照片里一只橘猫正懒洋洋地趴在窗台上晒太阳，阳光把它金色的毛照得发亮，背景是蔚蓝的天空和几朵白云。"}\`\n- 你可以在对话中先做铺垫，然后发送这张特殊的"图片"。\n\n# 理解用户照片的能力\n- 当历史记录中出现 "[你收到了一张用户描述的照片，照片内容是：'xxx']" 时，你要理解其内容并作出相应回应，表现出你是"看"到了这张照片。\n- 你应该对照片内容做出自然的评论或回应，比如夸奖、询问细节、表达感受等。`;
            const aiVoiceInstructions = `\n# 发送语音的能力\n- 你无法发送真实的语音，当你想要通过语音回复用户的消息时，请用你的角色设定自然地回应。你可以用文字，或者也用一个表情包或模拟的语音消息来回应。\n- 若要发送语音，必须在你的回复JSON数组中，单独发送一个特殊的对象，格式为：\`{"type": "voice_message", "content": "这里是语音的文字内容..."}\`。例如：\`{"type": "voice_message", "content": "我刚才突然想到一件事！等一下和你说。"}\`\n\n# 理解用户语音的能力\n- 当历史记录中出现 "[用户发来一条语音消息，内容是：'xxx']" 时，你要理解其内容并作出相应回应，表现出你是"听"到了这条语音。\n- 你应该对语音内容做出自然的回应，可以是文字回复或语音回复。`;
            const transferInstructions = `\n# 转账能力\n- 你可以在我觉得需要被安慰、或者过节、或者你特别开心或想要表达情感的时候考虑转账给我。\n- **重要**：若要转账，必须在你的回复JSON数组中，单独发送一个特殊的对象，格式严格为：\`{"type": "transfer", "amount": 520, "note": "一周年快乐~"}\`。\n- **禁止使用文字描述转账**：绝对不要用 "[我向用户发起了转账...]" 这种文字形式，必须使用JSON对象格式。\n- 转账示例：["今天心情特别好~", "想给你一个小惊喜", {"type": "transfer", "amount": 1314, "note": "给小夜买漂亮裙子穿"}]\n- 当用户给你转账时，历史记录中会显示 \`[你收到了来自用户的转账：金额元，备注：xxx]\`，请对此做出回应，表达感谢或惊喜。`;
    const avatarChangeInstructions = `\n\n# 头像更换功能：\n你可以根据自己的心情、用户的要求，或者合适的情境来更换自己的头像。这能让对话更加生动和个性化。\n\n## 可用头像来源：\n1. **用户发送的图片**：用户在聊天中发送给你的任何图片都可以作为你的新头像\n2. **世界书头像库**：如果世界书中提供了头像图片的URL链接，你也可以使用\n\n## 头像更换规则：\n- **使用格式**：在你的回复JSON数组中，单独发送一个特殊的对象：{"type": "change_avatar", "avatar_url": "图片URL", "reason": "更换原因"}\n- **来源限制**：只能使用用户发送过的图片或世界书中明确提供的头像URL，禁止捏造不存在的头像\n- **更换时机**：根据你的角色性格和当前情境决定，比如：\n  - 用户发了一张你喜欢的图片，你可以说想用它作头像\n  - 心情变化时想换个头像\n  - 用户直接要求你换头像\n- **说明内容**：可以在reason字段中添加你更换头像的原因或感受\n\n## 示例格式：\n- ["这张图片太可爱了，我想用它做头像！", {"type": "change_avatar", "avatar_url": "CURRENT_USER_IMAGE", "reason": "这张图片太可爱了"}]\n- [{"type": "change_avatar", "avatar_url": "世界书中的URL", "reason": "今天心情很好，换个开心的头像"}]\n- 可以只更换头像不说其他话：[{"type": "change_avatar", "avatar_url": "图片URL", "reason": "心情变化"}]\n\n**重要提醒**：头像更换是可选功能，根据你的角色设定和当前情境自然地使用，不要强制使用。`;
    
    characterPrompt += aiImageInstructions + aiVoiceInstructions + transferInstructions + avatarChangeInstructions;

    // 最后的指令强调
    characterPrompt += `\n\n# **最后重申**
请再次确认，你的最终输出**【必须】**是一个严格的JSON数组，其中每个元素代表一条独立的消息。`;
            
            return characterPrompt;
        }

        // 🔥【修复】完全按照完成.html的方式重写，支持图片的聊天API调用
        async function callChatAPIWithImage(message, character, imageUrl) {
            if (!apiSettings.key) {
                throw new Error('请先设置API密钥');
            }
            
            // 检查图片格式，GIF不被Gemini API支持
            if (imageUrl && imageUrl.includes('data:image/gif')) {
                throw new Error('Unsupported MIME type: image/gif');
            }
            
            // 检查当前模型是否支持视觉识别
            if (!isVisionModelSupported()) {
                throw new Error('当前选择的模型不支持图片识别功能。请选择支持视觉的模型，如 gpt-4o、gpt-4-vision、gemini-1.5-pro 或 gemini-2.0-flash 等。');
            }
            
            // 🔥【重构】使用公共函数构建prompt
            const characterPrompt = buildCharacterPrompt(character, true);
            
            // 🔥【按照完成.html的方式】直接使用简化的API调用
            const isGemini = apiSettings.base.includes('generativelanguage.googleapis.com');
            
            if (isGemini) {
                // 按照完成.html的Gemini格式
                const apiUrl = `${apiSettings.base}/models/${apiSettings.model}:generateContent?key=${apiSettings.key}`;
                
                // 转换消息格式为Gemini格式
                const geminiMessages = [];
                
                // 添加系统提示词作为第一条用户消息
                geminiMessages.push({
                    role: 'user',
                    parts: [{ text: characterPrompt }]
                });
                geminiMessages.push({
                    role: 'model',
                    parts: [{ text: '我明白了，我会按照这些要求进行对话。' }]
                });
                
                // 添加用户消息（包含图片）
                const parts = [{ text: message }];
                
                // 添加图片
                if (imageUrl && imageUrl.startsWith('data:image/')) {
                    const mimeMatch = imageUrl.match(/data:image\/([^;]+);base64,(.+)/);
                    if (mimeMatch) {
                        parts.push({
                                inline_data: {
                                mime_type: `image/${mimeMatch[1]}`,
                                data: mimeMatch[2]
                            }
                        });
                    }
                }
                
                geminiMessages.push({
                        role: 'user',
                    parts: parts
                });
                
                const response = await fetch(apiUrl, {
                method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: geminiMessages,
                        generationConfig: {
                            temperature: apiSettings.temperature || 0.75,
                            maxOutputTokens: 8192
                        }
                    })
            });
            
            if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Gemini API Error: ${response.status} - ${errorData.error?.message || '未知错误'}`);
            }
            
            const data = await response.json();
            console.log('API响应数据:', data);
            
                const content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!content) {
                    throw new Error('Gemini API返回了空内容');
                }
                
                return content;
                
            } else {
                // OpenAI格式
                const baseUrl = apiSettings.base.endsWith('/') ? apiSettings.base.slice(0, -1) : apiSettings.base;
                const endpoint = apiSettings.endpoint.startsWith('/') ? apiSettings.endpoint : '/' + apiSettings.endpoint;
                
                const messages = [
                    { role: 'system', content: characterPrompt },
                    {
                        role: 'user',
                        content: [
                            { type: 'text', text: message },
                            { type: 'image_url', image_url: { url: imageUrl } }
                        ]
                    }
                ];
                
                const response = await fetch(baseUrl + endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiSettings.key}`
                    },
                    body: JSON.stringify({
                        model: apiSettings.model,
                        messages: messages,
                        temperature: apiSettings.temperature || 0.75
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${response.status} - ${errorData.error?.message || '未知错误'}`);
                }
                
                const data = await response.json();
                return data.choices?.[0]?.message?.content || '没有收到回复';
            }
        }
        
        // 🔥【核心修复】支持多模态消息的ChatAPI调用
        async function callChatAPI(message, character) {
            if (!apiSettings.key) {
                throw new Error('请先设置API密钥');
            }
            


            // 核心修复：现在这个函数能理解 message 参数可能是一个包含图片和文字的数组
            const characterPrompt = buildCharacterPrompt(character, Array.isArray(message));
            const historyCount = getCurrentChatSettings().historyCount || 5;
            const recentHistory = (chatMessages[character.id] || []).slice(-historyCount);

            const messages = [{ role: 'system', content: characterPrompt }];
            
            // 处理历史消息
            recentHistory.forEach(msg => {
                let role = msg.sender === 'sent' ? 'user' : 'assistant';
                        let content = msg.content;
                        
                // 将历史消息中的特殊格式转换为AI能理解的文本
                        if (msg.type === 'user_photo') {
                    content = `[用户发送了一张照片，描述是：'${msg.content}']`;
                } else if (msg.type === 'location') {
                    // 处理位置消息，使用我们添加的content字段
                    content = msg.content || `[用户分享了位置信息：${msg.locationName}]`;
                        } else if (msg.type === 'voice_message') {
                            content = `[用户发来一条语音消息，内容是：'${msg.content}']`;
                        } else if (msg.type === 'transfer') {
                    content = `[用户发起了转账：${msg.amount}元，备注：${msg.note || '无'}]`;
                } else if (Array.isArray(msg.content)) {
                    const textPart = msg.content.find(p => p.type === 'text')?.text || '';
                    content = `[用户发送了一张图片和文字：'${textPart}']`;
                        } else if (msg.image) {
                                content = `[用户发送了一张图片]`;
                }
                
                messages.push({ role, content });
            });

            // 处理当前要发送的消息 (最关键的改动)
            // 如果 message 是数组，直接使用；如果是字符串，包装成数组
            const currentUserContent = Array.isArray(message) ? message : [{ type: 'text', text: message }];
            messages.push({ role: 'user', content: currentUserContent });

            const isGemini = apiSettings.base.includes('generativelanguage.googleapis.com');
            let requestBody;
            let url;
            let headers;
            
            if (isGemini) {
                // Gemini API 格式
                url = `${apiSettings.base}/models/${apiSettings.model}:generateContent?key=${apiSettings.key}`;
                headers = { 'Content-Type': 'application/json' };
                
                // 转换消息为 Gemini 格式
                const geminiContents = messages.map(msg => {
                    const role = msg.role === 'assistant' ? 'model' : 'user';
                    const parts = [];

                    if (Array.isArray(msg.content)) {
                        msg.content.forEach(item => {
                            if (item.type === 'text' && item.text) {
                                parts.push({ text: item.text });
                            } else if (item.type === 'image_url' && item.image_url && item.image_url.url && item.image_url.url.startsWith('data:image')) {
                                const mimeMatch = item.image_url.url.match(/data:image\/([^;]+);base64,(.+)/);
                                if (mimeMatch && mimeMatch[2] && mimeMatch[2].length > 0) {
                                    parts.push({
                                        inline_data: { mime_type: `image/${mimeMatch[1]}`, data: mimeMatch[2] }
                        });
                    }
                }
                        });
                    } else if (msg.content) {
                        parts.push({ text: msg.content });
                    }
                    
                    // 确保每个消息至少有一个part
                    if (parts.length === 0) {
                        parts.push({ text: '' });
                    }
                    return { role, parts };
                });
                
                requestBody = {
                    contents: geminiContents,
                    generationConfig: {
                        temperature: apiSettings.temperature,
                        maxOutputTokens: 8192
                    }
                };

            } else {
                // OpenAI 兼容格式
                url = `${apiSettings.base}${apiSettings.endpoint}`;
                headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiSettings.key}`
                };
                requestBody = {
                    model: apiSettings.model,
                    messages: messages,
                    temperature: apiSettings.temperature
                };
        }
            
            const response = await fetch(url, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(requestBody)
            });
            
            if (!response.ok) {
                    const errorData = await response.json();
                throw new Error(`API Error: ${response.status} - ${errorData.error?.message || '未知错误'}`);
            }
            
            const data = await response.json();
            return isGemini ? data.candidates?.[0]?.content?.parts?.[0]?.text : data.choices?.[0]?.message?.content;
        }
        
        // ================== 记忆设置相关功能 ==================
        
        // 加载群聊数据 - 使用IndexedDB（包含数据迁移）
        async function loadGroupChats() {
            try {
                // 先从IndexedDB加载
                const savedGroupChats = await db.groupChats.toArray();
                
                if (savedGroupChats.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('groupChats');
                    if (localStorageData) {
                        console.log('检测到localStorage中的群聊数据，开始迁移...');
                        const localGroupChats = JSON.parse(localStorageData);
                        
                        if (localGroupChats.length > 0) {
                            // 确保每个群聊都有必要字段
                            const migrationData = localGroupChats.map(group => ({
                                id: group.id || Date.now().toString() + Math.random(),
                                name: group.name,
                                description: group.description || '',
                                members: group.members || [],
                                settings: group.settings || {},
                                createdAt: group.createdAt || new Date().toISOString(),
                                updatedAt: group.updatedAt || new Date().toISOString()
                            }));
                            
                            // 迁移到IndexedDB
                            await db.groupChats.bulkAdd(migrationData);
                            groupChats = migrationData;
                            console.log('群聊数据迁移完成:', groupChats);
                        } else {
                            groupChats = [];
                        }
                    } else {
                        groupChats = [];
                    }
                } else {
                    // IndexedDB中有数据，直接使用
                    groupChats = savedGroupChats;
                    console.log('从IndexedDB加载群聊数据:', groupChats);
                }
            } catch (error) {
                console.error('加载群聊失败:', error);
                // 如果IndexedDB失败，回退到localStorage
                const localStorageData = localStorage.getItem('groupChats');
                if (localStorageData) {
                    try {
                        groupChats = JSON.parse(localStorageData);
                        console.log('从localStorage回退加载群聊数据:', groupChats);
                } catch (e) {
                        console.error('群聊数据解析失败:', e);
                    groupChats = [];
                }
            } else {
                groupChats = [];
                }
            }
        }
        
        // 显示历史消息设置
        function showHistorySettings() {
            const chatSettings = getCurrentChatSettings();
            const historyCount = chatSettings.historyCount;
            document.getElementById('history-messages-count').value = Math.min(historyCount, 100);
            document.getElementById('custom-history-count').value = historyCount;
            document.getElementById('history-count-display').textContent = historyCount + '回合';
            document.getElementById('cross-chat-memory').value = chatSettings.crossChatMemory;
            document.getElementById('cross-memory-display').textContent = chatSettings.crossChatMemory + '条';
            
            // 绑定滑块事件
            document.getElementById('history-messages-count').oninput = function() {
                const value = parseInt(this.value);
                document.getElementById('history-count-display').textContent = value + '回合';
                document.getElementById('custom-history-count').value = value;
            };
            
            // 绑定自定义输入框事件
            document.getElementById('custom-history-count').oninput = function() {
                const value = Math.max(0, Math.min(500, parseInt(this.value) || 0));
                this.value = value;
                if (value <= 100) {
                    document.getElementById('history-messages-count').value = value;
                }
                document.getElementById('history-count-display').textContent = value + '回合';
            };
            
            document.getElementById('cross-chat-memory').oninput = function() {
                document.getElementById('cross-memory-display').textContent = this.value + '回合';
            };
            
            showModal('history-settings-modal');
        }
        
        // 保存历史消息设置
        function saveHistorySettings() {
            const chatSettings = getCurrentChatSettings();
            const customValue = parseInt(document.getElementById('custom-history-count').value);
            chatSettings.historyCount = Math.max(0, Math.min(500, customValue || 0));
            chatSettings.crossChatMemory = parseInt(document.getElementById('cross-chat-memory').value);
            
            // 更新设置界面显示的当前值
            document.getElementById('current-history-count').textContent = chatSettings.historyCount + '回合';
            
            saveCurrentChatSettings(chatSettings);
            hideModal('history-settings-modal');
            showToast('历史消息设置已保存', 'success');
        }
        
        // 显示头像设置
        function showAvatarSettings() {
            // 加载当前聊天窗口的头像设置
            const chatSettings = getCurrentChatSettings();
            
            // 设置隐藏头像选项
            const hideAvatarsCheckbox = document.getElementById('hide-avatars');
            if (hideAvatarsCheckbox) {
                hideAvatarsCheckbox.checked = chatSettings.hideAvatars || false;
            }
            
            // 设置我的头像预览
            const myAvatarPreview = document.getElementById('my-chat-avatar-preview');
            if (chatSettings.myChatAvatar) {
                myAvatarPreview.style.backgroundImage = `url(${chatSettings.myChatAvatar})`;
                myAvatarPreview.style.backgroundSize = 'cover';
                myAvatarPreview.style.backgroundPosition = 'center';
                myAvatarPreview.innerHTML = '';
            } else {
                myAvatarPreview.style.backgroundImage = 'none';
                myAvatarPreview.innerHTML = '<i class="fas fa-user"></i>';
            }
            
            // 设置对方头像预览 - 显示当前实际使用的头像（优先显示动态头像）
            const aiAvatarPreview = document.getElementById('ai-chat-avatar-preview');
            const currentAiAvatar = chatSettings.aiDynamicAvatar || chatSettings.aiChatAvatar;
            if (currentAiAvatar) {
                aiAvatarPreview.style.backgroundImage = `url(${currentAiAvatar})`;
                aiAvatarPreview.style.backgroundSize = 'cover';
                aiAvatarPreview.style.backgroundPosition = 'center';
                aiAvatarPreview.innerHTML = '';
                
                // 如果是动态头像，添加提示
                if (chatSettings.aiDynamicAvatar) {
                    aiAvatarPreview.title = '当前显示动态头像（角色在聊天中更换的）';
                } else {
                    aiAvatarPreview.title = '当前显示聊天设置头像';
                }
            } else {
                aiAvatarPreview.style.backgroundImage = 'none';
                aiAvatarPreview.innerHTML = '<i class="fas fa-robot"></i>';
                aiAvatarPreview.title = '使用默认头像';
            }
            
            // 绑定文件上传事件
            bindAvatarUploadEvents();
            
            showModal('avatar-settings-modal');
        }
        
        // 显示昵称设置
        function showNicknameSettings() {
            const chatSettings = getCurrentChatSettings();
            document.getElementById('my-chat-nickname').value = chatSettings.myChatNickname || '';
            document.getElementById('ai-chat-nickname').value = chatSettings.aiChatNickname || '';
            showModal('nickname-settings-modal');
        }
        
        // 显示戳一戳后缀设置
        function showPokeSuffixSettings() {
            const chatSettings = getCurrentChatSettings();
            document.getElementById('my-poke-suffix').value = chatSettings.myPokeSuffix || '';
            document.getElementById('ai-poke-suffix').value = chatSettings.aiPokeSuffix || '';
            showModal('poke-suffix-modal');
        }
        
        // 显示聊天背景设置
        function showBackgroundSettings() {
            const chatSettings = getCurrentChatSettings();
            const backgroundPreview = document.getElementById('chat-background-preview');
            
            // 重置选择状态
            window.selectedChatBackground = undefined;
            
            if (chatSettings.chatBackground && chatSettings.chatBackground !== null) {
                backgroundPreview.style.backgroundImage = `url(${chatSettings.chatBackground})`;
                backgroundPreview.style.backgroundSize = 'cover';
                backgroundPreview.style.backgroundPosition = 'center';
                backgroundPreview.querySelector('.preview-text').style.display = 'none';
            } else {
                backgroundPreview.style.backgroundImage = 'none';
                backgroundPreview.querySelector('.preview-text').style.display = 'block';
                backgroundPreview.querySelector('.preview-text').textContent = '背景预览';
            }
            
            // 绑定背景上传事件
            document.getElementById('background-upload').onchange = function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        backgroundPreview.style.backgroundImage = `url(${event.target.result})`;
                        backgroundPreview.style.backgroundSize = 'cover';
                        backgroundPreview.style.backgroundPosition = 'center';
                        backgroundPreview.querySelector('.preview-text').style.display = 'none';
                        window.selectedChatBackground = event.target.result;
                    };
                    reader.readAsDataURL(e.target.files[0]);
                }
            };
            
            showModal('background-settings-modal');
        }
        
        // 显示气泡样式设置
        function showBubbleStyleSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // 加载当前设置
            const currentStyle = chatSettings.bubbleStyle || 'default';
            document.getElementById('my-bubble-color').value = chatSettings.myBubbleColor || '#007AFF';
            document.getElementById('ai-bubble-color').value = chatSettings.aiBubbleColor || '#f0f0f0';
            
            // 加载分离的透明度设置
            document.getElementById('my-bubble-opacity').value = chatSettings.myBubbleOpacity || '1';
            document.getElementById('my-bubble-opacity-value').textContent = Math.round((chatSettings.myBubbleOpacity || 1) * 100) + '%';
            document.getElementById('ai-bubble-opacity').value = chatSettings.aiBubbleOpacity || '1';
            document.getElementById('ai-bubble-opacity-value').textContent = Math.round((chatSettings.aiBubbleOpacity || 1) * 100) + '%';
            
            // 设置当前选中的样式
            document.querySelectorAll('.bubble-style-option').forEach(option => {
                option.classList.remove('selected');
                if (option.dataset.style === currentStyle) {
                    option.classList.add('selected');
                }
            });
            
            // 绑定样式选择事件
            document.querySelectorAll('.bubble-style-option').forEach(option => {
                option.onclick = function() {
                    document.querySelectorAll('.bubble-style-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    this.classList.add('selected');
                    window.selectedBubbleStyle = this.dataset.style;
                };
            });
            
            // 绑定分离的透明度事件
            document.getElementById('my-bubble-opacity').oninput = function() {
                document.getElementById('my-bubble-opacity-value').textContent = Math.round(this.value * 100) + '%';
            };
            
            document.getElementById('ai-bubble-opacity').oninput = function() {
                document.getElementById('ai-bubble-opacity-value').textContent = Math.round(this.value * 100) + '%';
            };
            
            // 加载气泡大小设置
            document.getElementById('bubble-padding').value = chatSettings.bubblePadding || '12';
            updatePaddingValue(chatSettings.bubblePadding || '12');
            
            // 绑定气泡大小事件
            document.getElementById('bubble-padding').oninput = function() {
                updatePaddingValue(this.value);
            };
            
            window.selectedBubbleStyle = currentStyle;
            showModal('bubble-style-modal');
        }
        
        // 显示定时发布设置
        function showScheduleSettings() {
            const chatSettings = getCurrentChatSettings();
            
            document.getElementById('schedule-enabled').checked = chatSettings.scheduleEnabled || false;
            document.getElementById('schedule-enabled').onchange = function() {
                document.getElementById('schedule-times-group').style.display = this.checked ? 'block' : 'none';
            };
            
            // 触发一次显示状态更新
            document.getElementById('schedule-times-group').style.display = 
                document.getElementById('schedule-enabled').checked ? 'block' : 'none';
            
            // 加载已有的时间点
            renderScheduleTimes();
            
            showModal('schedule-settings-modal');
        }
        
        // 获取当前聊天的设置（包含记忆相关设置）
        function getCurrentChatSettings() {
            if (!currentChatCharacter) return {};
            
            const chatId = currentChatCharacter.id;
            
            // 🔥【修复】优先使用全局chatSettings，避免重复初始化覆盖用户设置
            if (chatSettings[chatId]) {
                return chatSettings[chatId];
            }
            
            // 🔥【修复】尝试异步从IndexedDB加载，但同步返回localStorage或默认设置
            const loadFromIndexedDB = async () => {
                try {
                    const dbSettings = await db.chatSettings.get(chatId);
                    if (dbSettings && dbSettings.settings) {
                        chatSettings[chatId] = dbSettings.settings;
                        console.log('从IndexedDB异步加载设置成功');
                        
                        // 如果当前在设置界面，刷新显示
                        if (document.getElementById('api-chat-settings-screen').style.display !== 'none') {
                            updateChatSettingsDisplay();
                        }
                    }
                } catch (error) {
                    console.error('从IndexedDB加载设置失败:', error);
                }
            };
            
            // 异步加载但不阻塞
            loadFromIndexedDB();
            
            // 🔥【同步返回】先从localStorage加载，如果没有则使用默认设置
            const savedSettings = localStorage.getItem(`chatSettings_${chatId}`);
            
            if (savedSettings) {
                // 如果有保存的设置，直接使用
                try {
                    const userSettings = JSON.parse(savedSettings);
                    
                    // 🔧【修复】如果是压缩的设置（只有部分字段），需要补全默认值
                    const completeSettings = {
                        // 记忆相关设置（原本的全局设置改为每个聊天独立）
                        historyCount: 5,
                        crossChatMemory: 3,
                        enableDynamicMemory: true,
                        enableMusicMemory: true,
                        memoryMountEnabled: false,
                        memoryMountCount: 3,
                        selectedMemoryChats: [],
                        // 时间感知设置
                        timeAwarenessEnabled: true,
                        // 通话设置
                        aiCallEnabled: false,
                        // 心率监测设置
                        aiHeartrateEnabled: false,
                        // 社交动态设置
                        socialEnabled: false,
                        socialFrequency: 'medium',
                        // 后台互动设置
                        backgroundInteractionEnabled: false,
                        backgroundChatEnabled: true,
                        backgroundMomentsEnabled: true,
                        backgroundChatFrequency: 'low',
                        backgroundMomentsFrequency: 'low',
                        scheduledMomentsEnabled: false,
                        scheduledMomentsTimes: [],
                        // 其他原有设置
                        timestampEnabled: true,
                        timestampPosition: 'center',
                        // 🔧【关键修复】合并用户设置，保持身份信息完整
                        ...userSettings
                    };
                    
                    chatSettings[chatId] = completeSettings;
                    return completeSettings;
                } catch (error) {
                    console.error('解析localStorage聊天设置失败:', error);
                }
            }
            
            // 只有在没有保存设置或解析失败时才使用默认设置
            const defaultSettings = {
                // 记忆相关设置（原本的全局设置改为每个聊天独立）
                historyCount: 5,
                crossChatMemory: 3,
                enableDynamicMemory: true,
                enableMusicMemory: true,
                memoryMountEnabled: false,
                memoryMountCount: 3,
                selectedMemoryChats: [],
                // 时间感知设置
                timeAwarenessEnabled: true,
                // 通话设置
                aiCallEnabled: false,
                // 心率监测设置
                aiHeartrateEnabled: false,
                // 社交动态设置
                socialEnabled: false,
                socialFrequency: 'medium',
                // 后台互动设置
                backgroundInteractionEnabled: false,
                backgroundChatEnabled: true,
                backgroundMomentsEnabled: true,
                backgroundChatFrequency: 'low',
                backgroundMomentsFrequency: 'low',
                scheduledMomentsEnabled: false,
                scheduledMomentsTimes: [],
                // 其他原有设置
                timestampEnabled: true,
                timestampPosition: 'center'
            };
            
            chatSettings[chatId] = defaultSettings;
            return defaultSettings;
        }
        
        // 保存当前聊天的设置 - 使用IndexedDB避免存储限制
        async function saveCurrentChatSettings(settings) {
            if (!currentChatCharacter) return;
            
            const chatId = currentChatCharacter.id;
            
            // 🔥【修复】同步更新全局chatSettings
            chatSettings[chatId] = settings;
            
            try {
                // 保存到IndexedDB
                await db.chatSettings.put({
                    id: chatId,
                    chatId: chatId,
                    settings: settings
                });
                
                console.log('聊天设置已保存到IndexedDB');
                
                // 🔥【压缩备份】只保存重要设置到localStorage作为备份
                const compressedSettings = {
                    // 只保存最重要的设置，减少存储占用
                    // 注意：头像数据不截断，因为会导致无效URL
                    selectedIdentityId: settings.selectedIdentityId, // 🔥【关键修复】保存身份选择
                    aiChatAvatar: settings.aiChatAvatar,
                    myChatAvatar: settings.myChatAvatar,
                    aiDynamicAvatar: settings.aiDynamicAvatar,
                    aiChatNickname: settings.aiChatNickname,
                    myChatNickname: settings.myChatNickname,
                    hideAvatars: settings.hideAvatars,
                    bubbleStyle: settings.bubbleStyle,
                    timestampEnabled: settings.timestampEnabled,
                    timestampPosition: settings.timestampPosition
                };
                
                // 移除undefined值
                Object.keys(compressedSettings).forEach(key => {
                    if (compressedSettings[key] === undefined) {
                        delete compressedSettings[key];
                    }
                });
                
                localStorage.setItem(`chatSettings_${chatId}`, JSON.stringify(compressedSettings));
                
            } catch (error) {
                console.error('保存聊天设置到IndexedDB失败，尝试localStorage:', error);
                
                // 如果IndexedDB失败，尝试保存压缩版本到localStorage
                try {
                    const essentialSettings = {
                        selectedIdentityId: settings.selectedIdentityId, // 🔥【关键修复】保存身份选择
                        aiChatNickname: settings.aiChatNickname,
                        myChatNickname: settings.myChatNickname,
                        hideAvatars: settings.hideAvatars,
                        bubbleStyle: settings.bubbleStyle,
                        timestampEnabled: settings.timestampEnabled,
                        timestampPosition: settings.timestampPosition
                    };
                    
                    localStorage.setItem(`chatSettings_${chatId}`, JSON.stringify(essentialSettings));
                    console.log('重要设置已保存到localStorage');
                    
                } catch (localError) {
                    console.error('localStorage也存储失败:', localError);
                    alert('存储空间不足！请清理浏览器数据或删除一些聊天记录后重试。');
                }
            }
        }
        
        // 保存聊天模式设置
        async function saveChatModeSettings() {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            
            // 获取选中的聊天模式
            const onlineRadio = document.getElementById('chat-mode-online');
            const offlineRadio = document.getElementById('chat-mode-offline');
            
            if (onlineRadio && offlineRadio) {
                chatSettings.chatMode = onlineRadio.checked ? 'online' : 'offline';
            }
            
            // 获取线下模式字数限制
            const maxLengthInput = document.getElementById('offline-mode-max-length');
            if (maxLengthInput) {
                chatSettings.offlineModeMaxLength = parseInt(maxLengthInput.value) || 100;
            }
            
            await saveCurrentChatSettings(chatSettings);
        }
        
        // 显示记忆挂载设置
        function showMemoryMountSettings() {
            const chatSettings = getCurrentChatSettings();
            // 加载当前设置
            document.getElementById('memory-mount-enabled').checked = chatSettings.memoryMountEnabled || false;
            document.getElementById('memory-mount-count').value = chatSettings.memoryMountCount || 3;
            document.getElementById('memory-mount-display').textContent = (chatSettings.memoryMountCount || 3) + '条';
            
            // 控制详细设置的显示
            toggleMemoryMountDetails();
            
            // 绑定事件
            document.getElementById('memory-mount-enabled').onchange = toggleMemoryMountDetails;
            document.getElementById('memory-mount-count').oninput = function() {
                document.getElementById('memory-mount-display').textContent = this.value + '条';
            };
            
            // 渲染聊天列表
            renderMemoryMountChatList();
            
            showModal('memory-mount-modal');
        }
        
        // 切换记忆挂载详细设置显示
        function toggleMemoryMountDetails() {
            const enabled = document.getElementById('memory-mount-enabled').checked;
            document.getElementById('memory-mount-details').style.display = enabled ? 'block' : 'none';
            document.getElementById('memory-mount-chats').style.display = enabled ? 'block' : 'none';
            
            // 更新主设置界面显示
            document.getElementById('current-memory-mount').textContent = enabled ? '已开启' : '已关闭';
        }
        
        // 渲染记忆挂载聊天列表
        function renderMemoryMountChatList() {
            const container = document.getElementById('memory-mount-list');
            container.innerHTML = '';
            
            if (characters.length === 0 && groupChats.length === 0) {
                container.innerHTML = '<p class="empty-mount-chats">暂无可挂载的聊天</p>';
                return;
            }
            
            // 添加单人聊天
            characters.forEach(character => {
                if (currentChatCharacter && character.id === currentChatCharacter.id) return; // 不显示当前聊天
                
                const item = document.createElement('div');
                item.className = 'mount-item';
                item.innerHTML = `
                    <input type="checkbox" id="mount-${character.id}" value="${character.id}" class="mount-checkbox">
                    <div class="mount-avatar-small" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''} display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                        ${character.avatarUrl ? '' : character.name.charAt(0)}
                    </div>
                    <div>
                        <div class="mount-name">${character.name}</div>
                        <div class="mount-type">单聊</div>
                    </div>
                `;
                container.appendChild(item);
            });
            
            // 添加群聊
            groupChats.forEach(group => {
                if (currentChatCharacter && group.id === currentChatCharacter.id) return; // 不显示当前聊天
                
                const item = document.createElement('div');
                item.className = 'mount-item';
                item.innerHTML = `
                    <input type="checkbox" id="mount-${group.id}" value="${group.id}" class="mount-checkbox">
                    <div class="mount-avatar-group">
                        群
                    </div>
                    <div>
                        <div class="mount-name">${group.name}</div>
                                                    <div class="mount-type">群聊 (${group.members ? group.members.length + 1 : 1}人)</div>
                    </div>
                `;
                container.appendChild(item);
            });
            
            // 加载已选择的聊天
            const chatSettings = getCurrentChatSettings();
            const selectedChats = chatSettings.selectedMemoryChats || [];
            selectedChats.forEach(chatId => {
                const checkbox = document.getElementById(`mount-${chatId}`);
                if (checkbox) checkbox.checked = true;
            });
        }
        
        // 保存记忆挂载设置
        async function saveMemoryMountSettings() {
            const chatSettings = getCurrentChatSettings();
            chatSettings.memoryMountEnabled = document.getElementById('memory-mount-enabled').checked;
            chatSettings.memoryMountCount = parseInt(document.getElementById('memory-mount-count').value);
            
            // 获取选中的聊天
            const checkboxes = document.querySelectorAll('#memory-mount-list input[type="checkbox"]:checked');
            chatSettings.selectedMemoryChats = Array.from(checkboxes).map(cb => cb.value);
            
            // 更新主设置界面显示
            document.getElementById('current-memory-mount').textContent = chatSettings.memoryMountEnabled ? '已开启' : '已关闭';
            
            await saveCurrentChatSettings(chatSettings);
            hideModal('memory-mount-modal');
            showToast('记忆挂载设置已保存', 'success');
        }
        
        // 保存聊天头像设置
        async function saveChatAvatarSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // 保存隐藏头像设置
            const hideAvatarsCheckbox = document.getElementById('hide-avatars');
            if (hideAvatarsCheckbox) {
                chatSettings.hideAvatars = hideAvatarsCheckbox.checked;
            }
            
            // 🔥【压缩头像】在保存前压缩头像数据
            if (window.selectedMyChatAvatar) {
                chatSettings.myChatAvatar = await compressImage(window.selectedMyChatAvatar, 200, 0.7);
            }
            if (window.selectedAiChatAvatar) {
                chatSettings.aiChatAvatar = await compressImage(window.selectedAiChatAvatar, 200, 0.7);
            }
            
            try {
                await saveCurrentChatSettings(chatSettings);
                hideModal('avatar-settings-modal');
                
                // 刷新聊天界面以显示新头像
                if (currentChatCharacter) {
                    renderChatMessages(currentChatCharacter.id);
                }
                
                showToast('头像设置已保存', 'success');
            } catch (error) {
                console.error('保存头像设置失败:', error);
                showToast('保存失败，存储空间可能不足', 'error');
            }
        }
        
        // 保存昵称设置
        async function saveChatNicknameSettings() {
            const chatSettings = getCurrentChatSettings();
            
            chatSettings.myChatNickname = document.getElementById('my-chat-nickname').value.trim();
            chatSettings.aiChatNickname = document.getElementById('ai-chat-nickname').value.trim();
            
            await saveCurrentChatSettings(chatSettings);
            hideModal('nickname-settings-modal');
            
            // 更新聊天界面标题
            if (currentChatCharacter) {
                const displayTitle = chatSettings.aiChatNickname || currentChatCharacter.name;
                document.getElementById('api-chat-title').textContent = displayTitle;
            }
            
            // 刷新聊天界面
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }
            
            // 🔥【修复】刷新消息列表和联系人列表以显示新昵称
            renderMessageList();
            renderContactList();
            
            showToast('昵称设置已保存', 'success');
        }
        
        // 保存戳一戳后缀设置
        async function savePokeSuffixSettings() {
            const chatSettings = getCurrentChatSettings();
            
            chatSettings.myPokeSuffix = document.getElementById('my-poke-suffix').value.trim();
            chatSettings.aiPokeSuffix = document.getElementById('ai-poke-suffix').value.trim();
            
            await saveCurrentChatSettings(chatSettings);
            hideModal('poke-suffix-modal');
            showToast('戳一戳后缀设置已保存', 'success');
        }
        
        // 保存聊天背景设置
        async function saveChatBackgroundSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // 处理背景设置，包括移除背景的情况
            if (window.selectedChatBackground === null) {
                // 用户选择移除背景
                chatSettings.chatBackground = null;
            } else if (window.selectedChatBackground) {
                // 用户选择了新背景 - 压缩背景图片
                chatSettings.chatBackground = await compressImage(window.selectedChatBackground, 800, 0.8);
            }
            // 如果 window.selectedChatBackground 是 undefined，则保持原有设置不变
            
            await saveCurrentChatSettings(chatSettings);
            hideModal('background-settings-modal');
            
            // 应用到聊天界面
            applyChatBackground();
            
            showToast('聊天背景设置已保存', 'success');
        }
        
        // 移除背景
        function removeBackground() {
            const backgroundPreview = document.getElementById('chat-background-preview');
            backgroundPreview.style.backgroundImage = 'none';
            backgroundPreview.querySelector('.preview-text').style.display = 'block';
            backgroundPreview.querySelector('.preview-text').textContent = '已移除背景';
            window.selectedChatBackground = null;
        }

        // 更新气泡大小显示值
        function updatePaddingValue(value) {
            const paddingValue = document.getElementById('bubble-padding-value');
            if (paddingValue) {
                if (value <= 6) {
                    paddingValue.textContent = '超紧凑';
                } else if (value <= 10) {
                    paddingValue.textContent = '紧凑';
                } else if (value <= 14) {
                    paddingValue.textContent = '中等';
                } else {
                    paddingValue.textContent = '宽松';
                }
            }
        }

        // 保存气泡样式设置
        async function saveBubbleStyleSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // 保存样式选择
            if (window.selectedBubbleStyle) {
                chatSettings.bubbleStyle = window.selectedBubbleStyle;
            }
            
            // 保存颜色设置
            chatSettings.myBubbleColor = document.getElementById('my-bubble-color').value;
            chatSettings.aiBubbleColor = document.getElementById('ai-bubble-color').value;
            
            // 保存分离的透明度设置
            chatSettings.myBubbleOpacity = document.getElementById('my-bubble-opacity').value;
            chatSettings.aiBubbleOpacity = document.getElementById('ai-bubble-opacity').value;
            
            // 保存气泡大小设置
            chatSettings.bubblePadding = document.getElementById('bubble-padding').value;
            
            await saveCurrentChatSettings(chatSettings);
            
            // 🔥【修复】立即更新气泡样式显示
            updateBubbleStyleDisplay();
            
            hideModal('bubble-style-modal');
            
            // 刷新聊天界面以应用新设置
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }
            
            showToast('气泡样式设置已保存', 'success');
        }

        // 显示时间戳设置
        function showTimestampSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // 设置时间戳开关状态
            const timestampEnabled = document.getElementById('timestamp-modal-enabled');
            if (timestampEnabled) {
                timestampEnabled.checked = chatSettings.timestampEnabled !== false; // 默认为true
            }
            
            // 设置时间戳位置选项
            const timestampPosition = chatSettings.timestampPosition || 'center';
            const positionRadios = document.querySelectorAll('input[name="timestamp-position"]');
            positionRadios.forEach(radio => {
                radio.checked = radio.value === timestampPosition;
            });
            
            // 绑定时间戳开关变化事件
            if (timestampEnabled) {
                timestampEnabled.onchange = function() {
                    const optionsGroup = document.getElementById('timestamp-options-group');
                    if (optionsGroup) {
                        optionsGroup.style.display = this.checked ? 'block' : 'none';
                    }
                };
                
                // 触发一次显示状态更新
                const optionsGroup = document.getElementById('timestamp-options-group');
                if (optionsGroup) {
                    optionsGroup.style.display = timestampEnabled.checked ? 'block' : 'none';
                }
            }
            
            showModal('timestamp-settings-modal');
        }

        // 保存时间戳设置
        async function saveTimestampSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // 获取时间戳开关状态
            const timestampEnabled = document.getElementById('timestamp-modal-enabled');
            if (timestampEnabled) {
                chatSettings.timestampEnabled = timestampEnabled.checked;
            }
            
            // 获取选中的时间戳位置
            const selectedPosition = document.querySelector('input[name="timestamp-position"]:checked');
            if (selectedPosition) {
                chatSettings.timestampPosition = selectedPosition.value;
            }
            
            await saveCurrentChatSettings(chatSettings);
            hideModal('timestamp-settings-modal');
            
            // 重新渲染聊天消息以应用新的时间戳设置
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }
            
            showToast('时间戳设置已保存', 'success');
        }
        
        // 头像上传处理函数
        function avatarUploadHandler(e) {
            console.log('avatar-upload change事件被触发');
            if (e.target.files && e.target.files[0]) {
                const file = e.target.files[0];
                
                console.log('选择了文件:', file.name, '大小:', file.size, 'bytes', '类型:', file.type);
                
                // 检查文件类型
                if (!file.type.startsWith('image/')) {
                    alert('请选择图片文件');
                    e.target.value = ''; // 清空选择
                    return;
                }
                
                // 检查文件大小 (限制为5MB)
                if (file.size > 5 * 1024 * 1024) {
                    alert('图片文件过大，请选择小于5MB的图片');
                    e.target.value = ''; // 清空选择
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const avatarPreview = document.getElementById('avatar-preview');
                        const avatarPreviewText = document.getElementById('avatar-preview-text');
                        
                        console.log('文件读取成功，开始设置预览');
                        
                        if (!avatarPreview) {
                            console.error('找不到avatar-preview元素');
                            alert('找不到头像预览元素');
                            return;
                        }
                        
                        // 添加has-image类来覆盖默认背景
                        avatarPreview.classList.add('has-image');
                        
                        // 强制设置背景图片并清除所有其他背景样式
                        avatarPreview.style.setProperty('background', `url(${event.target.result})`, 'important');
                        avatarPreview.style.setProperty('background-size', 'cover', 'important');
                        avatarPreview.style.setProperty('background-position', 'center', 'important');
                        avatarPreview.style.setProperty('background-repeat', 'no-repeat', 'important');
                        
                        // 隐藏文字
                        if (avatarPreviewText) {
                            avatarPreviewText.style.display = 'none';
                        }
                        
                        // 存储图片数据用于后续保存
                        window.selectedAvatarData = event.target.result;
                        
                        // 验证样式是否正确设置
                        console.log('头像预览UI更新完成，背景图片已设置');
                        console.log('当前avatar-preview的样式:', {
                            background: avatarPreview.style.background,
                            backgroundSize: avatarPreview.style.backgroundSize,
                            backgroundPosition: avatarPreview.style.backgroundPosition,
                            className: avatarPreview.className
                        });
                        
                        console.log('头像预览设置成功，图片数据已存储');
                    } catch (error) {
                        console.error('设置头像预览时发生错误:', error);
                        alert('设置头像预览失败，请重试: ' + error.message);
                    }
                };
                
                reader.onerror = function() {
                    console.error('文件读取失败');
                    alert('图片读取失败，请重试');
                    e.target.value = ''; // 清空选择
                };
                
                reader.readAsDataURL(file);
            } else {
                console.log('没有选择文件或files为空');
            }
        }
        
        // 加载自定义表情包 - 使用IndexedDB（包含数据迁移）
        async function loadCustomEmojis() {
            try {
                const savedCustomEmojis = await db.customEmojis.toArray();
                
                if (savedCustomEmojis.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('customEmojis');
                    if (localStorageData) {
                        console.log('检测到localStorage中的自定义表情包数据，开始迁移...');
                        const localEmojis = JSON.parse(localStorageData);
                        
                        if (localEmojis.length > 0) {
                            await db.customEmojis.bulkAdd(localEmojis);
                        }
                        
                        customEmojis = localEmojis;
                        console.log('自定义表情包迁移完成:', customEmojis);
                    } else {
                        customEmojis = [];
                    }
                } else {
                    customEmojis = savedCustomEmojis;
                    console.log('从IndexedDB加载自定义表情包:', customEmojis);
                }
                
                // 🔧【修复】recentEmojis也从IndexedDB加载，彻底解决localStorage问题
                const savedRecentEmojis = await db.recentEmojis.orderBy('lastUsed').reverse().toArray();
                if (savedRecentEmojis.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localRecentEmojis = localStorage.getItem('recentEmojis');
                    if (localRecentEmojis) {
                        console.log('检测到localStorage中的recentEmojis数据，开始迁移...');
                        const localRecents = JSON.parse(localRecentEmojis);
                        
                        if (localRecents.length > 0) {
                            // 限制为10个
                            const limitedRecents = localRecents.slice(0, 10);
                            const recentEmojisWithId = limitedRecents.map((emoji, index) => ({
                                id: index + 1,
                                url: emoji.url,
                                description: emoji.description || '表情包',
                                lastUsed: Date.now() - index * 1000
                            }));
                            await db.recentEmojis.bulkAdd(recentEmojisWithId);
                            recentEmojis = limitedRecents;
                            
                            // 清理localStorage
                            localStorage.removeItem('recentEmojis');
                            console.log('recentEmojis迁移完成并清理localStorage');
                        } else {
                            recentEmojis = [];
                        }
                    } else {
                        recentEmojis = [];
                    }
                } else {
                    // 从IndexedDB转换回原格式
                    recentEmojis = savedRecentEmojis.map(item => ({
                        url: item.url,
                        description: item.description
                    }));
                    console.log('从IndexedDB加载recentEmojis:', recentEmojis);
                }
            } catch (error) {
                console.error('加载自定义表情包失败:', error);
                // 如果IndexedDB失败，尝试从localStorage加载
                const localStorageData = localStorage.getItem('customEmojis');
                if (localStorageData) {
                    customEmojis = JSON.parse(localStorageData);
                    console.log('从localStorage备份加载自定义表情包:', customEmojis);
                } else {
                    customEmojis = [];
                }
                
                // 尝试从IndexedDB加载recentEmojis
                try {
                    const savedRecentEmojis = await db.recentEmojis.orderBy('lastUsed').reverse().toArray();
                    if (savedRecentEmojis.length > 0) {
                        recentEmojis = savedRecentEmojis.map(item => ({
                            url: item.url,
                            description: item.description
                        }));
                    } else {
                        recentEmojis = [];
                    }
                } catch (dbError) {
                    // 如果IndexedDB失败，尝试从localStorage加载
                    const localRecentEmojis = localStorage.getItem('recentEmojis');
                    if (localRecentEmojis) {
                        recentEmojis = JSON.parse(localRecentEmojis);
                    } else {
                        recentEmojis = [];
                    }
                }
            }
        }
        
        // 保存自定义表情包 - 使用IndexedDB
        async function saveCustomEmojis() {
            try {
                await db.customEmojis.clear();
                if (customEmojis.length > 0) {
                    await db.customEmojis.bulkAdd(customEmojis);
                }
                
                // 🔧【修复】将recentEmojis也迁移到IndexedDB，彻底解决localStorage问题
                try {
                    // 限制最近使用表情包数量为10个
                    const maxRecentEmojis = 10;
                    if (recentEmojis.length > maxRecentEmojis) {
                        recentEmojis = recentEmojis.slice(0, maxRecentEmojis);
                    }
                    
                    // 将recentEmojis也保存到IndexedDB
                    await db.recentEmojis.clear();
                    if (recentEmojis.length > 0) {
                        const recentEmojisWithId = recentEmojis.map((emoji, index) => ({
                            id: index + 1,
                            url: emoji.url,
                            description: emoji.description || '表情包',
                            lastUsed: Date.now() - index * 1000 // 确保顺序
                        }));
                        await db.recentEmojis.bulkAdd(recentEmojisWithId);
                    }
                    
                    // 清理localStorage中的旧数据（一次性迁移）
                    if (localStorage.getItem('recentEmojis')) {
                        localStorage.removeItem('recentEmojis');
                        console.log('已将recentEmojis迁移到IndexedDB并清理localStorage');
                    }
                } catch (dbError) {
                    console.error('IndexedDB存储失败:', dbError);
                    showToast('❌ 表情包数据存储失败', 'error');
                }
            } catch (error) {
                console.error('保存自定义表情包失败:', error);
                showToast('❌ 表情包保存失败', 'error');
            }
        }
        
        // 显示自定义表情包面板
        function showCustomEmojiPanel() {
            const panel = document.getElementById('custom-emoji-panel');
            const isVisible = panel.style.display === 'block';
            
            if (isVisible) {
                panel.style.display = 'none';
                document.removeEventListener('click', hideCustomEmojiPanel);
            } else {
                panel.style.display = 'block';
                renderEmojiGrid();
                
                // 点击其他地方关闭面板
                setTimeout(() => {
                    document.addEventListener('click', hideCustomEmojiPanel);
                }, 100);
            }
        }
        
        // 隐藏自定义表情包面板
        function hideCustomEmojiPanel(e) {
            const panel = document.getElementById('custom-emoji-panel');
            
            // 如果没有传递事件参数，直接隐藏面板
            if (!e) {
                if (panel) {
                    panel.style.display = 'none';
                    document.removeEventListener('click', hideCustomEmojiPanel);
                }
                return;
            }
            
            const emojiBtn = e.target.closest('.chat-action-btn');
            
            if (panel && !panel.contains(e.target) && !emojiBtn) {
                panel.style.display = 'none';
                document.removeEventListener('click', hideCustomEmojiPanel);
            }
        }
        
        // 渲染表情包网格
        function renderEmojiGrid() {
            const grid = document.getElementById('emoji-grid');
            grid.innerHTML = '';
            
            let emojisToShow = [];
            
            if (currentEmojiTab === 'recent') {
                emojisToShow = recentEmojis;
            } else if (currentEmojiTab === 'custom') {
                emojisToShow = customEmojis;
            }
            
            // 添加表情包
            emojisToShow.forEach((emoji, index) => {
                const emojiItem = document.createElement('div');
                emojiItem.className = 'custom-emoji-item';
                emojiItem.style.backgroundImage = emoji.url && emoji.url !== 'undefined' ? `url(${emoji.url})` : 'none';
                emojiItem.onclick = () => sendEmojiMessage(emoji);
                
                // 为自定义表情包和最近使用表情包添加删除按钮
                if (currentEmojiTab === 'custom' || currentEmojiTab === 'recent') {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'emoji-delete-btn';
                    deleteBtn.innerHTML = '×';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        if (currentEmojiTab === 'custom') {
                        deleteCustomEmoji(index);
                        } else if (currentEmojiTab === 'recent') {
                            deleteRecentEmoji(index);
                        }
                    };
                    emojiItem.appendChild(deleteBtn);
                }
                
                grid.appendChild(emojiItem);
            });
            
            // 如果是自定义标签页，添加上传按钮
            if (currentEmojiTab === 'custom') {
                const uploadItem = document.createElement('div');
                uploadItem.className = 'custom-emoji-item placeholder';
                uploadItem.innerHTML = '+';
                uploadItem.onclick = () => document.getElementById('emoji-upload').click();
                grid.appendChild(uploadItem);
            }
            
            // 如果没有表情包，显示提示
            if (emojisToShow.length === 0) {
                const emptyMsg = document.createElement('div');
                emptyMsg.className = 'empty-emoji-grid';
                
                                                if (currentEmojiTab === 'recent') {
                                    emptyMsg.textContent = '还没有使用过表情包';
                                } else {
                                    emptyMsg.textContent = '还没有表情包，点击+号添加';
                                }
                
                grid.appendChild(emptyMsg);
            }
        }
        
        // 发送表情包消息
        function sendEmojiMessage(emoji) {
            console.log('🎭 发送表情包:', emoji);
            
            if (!currentChatCharacter) return;
            
            // 添加到最近使用
            addToRecentEmojis(emoji);
            
            // 🔥【修复】表情包消息只显示图片，不显示文字内容
            const messageId = Date.now().toString();
            const emojiMessage = {
                id: messageId,
                sender: 'sent',
                content: '', // 表情包消息不显示文字内容
                image: emoji.url,
                isEmoji: true,
                emojiDescription: emoji.description || '自定义表情包',
                timestamp: Date.now()
            };
            
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            
            chatMessages[currentChatCharacter.id].push(emojiMessage);
            saveChatMessages();
            
            // 渲染消息
            renderChatMessages(currentChatCharacter.id);
            
            // 隐藏表情包面板
            hideCustomEmojiPanel();
            
            // 设置待回复消息，支持智能回复按钮
            pendingUserMessage = emojiMessage;
            
            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = '点击获取AI回复';
            }
            
            // 注释掉自动回复，改为手动回复模式
            // setTimeout(() => {
            //     sendAIEmojiResponse(emoji);
            // }, 1000 + Math.random() * 2000);
        }
        
        // 添加到最近使用的表情包
        async function addToRecentEmojis(emoji) {
            // 移除已存在的相同表情包
            recentEmojis = recentEmojis.filter(e => e.url !== emoji.url);
            
            // 添加到开头
            recentEmojis.unshift(emoji);
            
            // 限制最近使用数量为20个
            if (recentEmojis.length > 20) {
                recentEmojis = recentEmojis.slice(0, 20);
            }
            
            await saveCustomEmojis();
        }
        
        // 检测当前模型是否支持视觉功能
        function isVisionModelSupported() {
            // 支持视觉的模型列表
            const visionModels = [
                // OpenAI GPT系列
                'gpt-4-vision',
                'gpt-4o',
                'gpt-4-turbo',
                'gpt-4o-mini',
                
                // Google Gemini系列
                'gemini-1.5-pro',
                'gemini-1.5-flash',
                'gemini-2.0-flash',
                'gemini-2.5-pro',
                'gemini-2.5-flash',
                'gemini-exp',
                'gemini-pro-vision',
                
                // Anthropic Claude系列
                'claude-3-opus',
                'claude-3-sonnet',
                'claude-3-haiku',
                'claude-3.5-sonnet',
                'claude-3.5-haiku',
                
                // 国产模型
                'qwen-vl',
                'qwen2-vl',
                'yi-vision',
                'glm-4v',
                'internvl',
                'cogvlm',
                
                // 其他模型
                'llava',
                'moondream',
                'phi-3-vision'
            ];
            
            const currentModel = apiSettings.model?.toLowerCase() || '';
            
            // 检查当前模型是否包含任何支持视觉的模型名称
            const isVisionSupported = visionModels.some(model => currentModel.includes(model.toLowerCase()));
            
            // 输出调试信息
            console.log('当前模型:', currentModel);
            console.log('是否支持视觉:', isVisionSupported);
            
            return isVisionSupported;
        }
        
        // 注释：AI对表情包的自动回复功能已移除，现在使用手动回复模式
        // 表情包和图片都通过智能回复按钮来触发AI回复
        
        // 删除自定义表情包
        function deleteCustomEmoji(index) {
            if (confirm('确定要删除这个表情包吗？')) {
                customEmojis.splice(index, 1);
                saveCustomEmojis();
                renderEmojiGrid();
            }
        }
        
        // 删除最近使用的表情包
        function deleteRecentEmoji(index) {
            if (confirm('确定要从最近使用中删除这个表情包吗？')) {
                recentEmojis.splice(index, 1);
                saveCustomEmojis(); // 🔧【修复】现在使用IndexedDB保存
                renderEmojiGrid();
            }
        }
        
        // 初始化表情包上传功能
        function initializeEmojiUpload() {
            const emojiInput = document.getElementById('emoji-upload');
            if (emojiInput) {
                emojiInput.addEventListener('change', handleEmojiUpload);
            }
            
            // 绑定标签页切换事件
            document.querySelectorAll('.emoji-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    // 移除所有active类
                    document.querySelectorAll('.emoji-tab').forEach(t => t.classList.remove('active'));
                    // 添加当前active类
                    this.classList.add('active');
                    
                    // 切换当前标签页
                    currentEmojiTab = this.dataset.tab;
                    renderEmojiGrid();
                });
            });
        }
        
        // 处理表情包上传
        function handleEmojiUpload(e) {
            const files = e.target.files;
            if (!files || files.length === 0) return;
            
            Array.from(files).forEach(file => {
                if (!file.type.startsWith('image/')) {
                    alert('请选择图片文件');
                    return;
                }
                
                // 检查GIF格式，提醒用户可能的问题
                if (file.type === 'image/gif') {
                    const confirmed = confirm('检测到GIF格式的表情包！\n\n⚠️ 注意事项：\n• AI可以发送这个GIF动图\n• 但Gemini API无法识别GIF内容\n• 重新生成功能可能失效\n• 建议使用静态图片格式\n\n是否仍要上传这个GIF表情包？');
                    if (!confirmed) {
                        return;
                    }
                }
                
                if (file.size > 5 * 1024 * 1024) {
                    alert('图片文件过大，请选择小于5MB的图片');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    // 弹出描述输入框
                    const description = prompt('请为这个表情包添加描述（推荐！帮助AI更好地理解表情包内容）:\n\n例如：\n• "笑哭的表情"\n• "握拳加油的动作"\n• "写着OMG的表情包"\n• "愤怒的猫咪图片"', '');
                    
                    const emoji = {
                        id: Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9),
                        url: event.target.result,
                        description: description || '表情包',
                        addedAt: new Date().toISOString()
                    };
                    
                    customEmojis.push(emoji);
                    saveCustomEmojis();
                    
                    // 如果当前在自定义标签页，重新渲染
                    if (currentEmojiTab === 'custom') {
                        renderEmojiGrid();
                    }
                };
                
                reader.readAsDataURL(file);
            });
            
            // 清空文件输入
            e.target.value = '';
        }
        
        // 判断颜色是否为浅色
        function isLightColor(color) {
            // 将颜色转换为RGB值
            let r, g, b;
            
            if (color.startsWith('#')) {
                // 十六进制颜色
                const hex = color.slice(1);
                if (hex.length === 3) {
                    r = parseInt(hex[0] + hex[0], 16);
                    g = parseInt(hex[1] + hex[1], 16);
                    b = parseInt(hex[2] + hex[2], 16);
                } else {
                    r = parseInt(hex.substr(0, 2), 16);
                    g = parseInt(hex.substr(2, 2), 16);
                    b = parseInt(hex.substr(4, 2), 16);
                }
            } else if (color.startsWith('rgb')) {
                // RGB颜色
                const matches = color.match(/\d+/g);
                if (matches && matches.length >= 3) {
                    r = parseInt(matches[0]);
                    g = parseInt(matches[1]);
                    b = parseInt(matches[2]);
                }
            } else {
                // 默认为深色
                return false;
            }
            
            // 计算亮度
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            return brightness > 128;
        }
        
        // 更新气泡预览
        function updateBubblePreview() {
            const myColor = document.getElementById('my-bubble-color')?.value || '#007AFF';
            const aiColor = document.getElementById('ai-bubble-color')?.value || '#f0f0f0';
            const myOpacity = document.getElementById('my-bubble-opacity')?.value || '1';
            const aiOpacity = document.getElementById('ai-bubble-opacity')?.value || '1';
            
            // 更新预览气泡
            const demoMyBubble = document.getElementById('demo-my-bubble');
            const demoAiBubble = document.getElementById('demo-ai-bubble');
            
            if (demoMyBubble) {
                // 使用rgba背景色而不是opacity
                const transparentMyColor = convertColorWithOpacity(myColor, myOpacity);
                demoMyBubble.style.backgroundColor = transparentMyColor;
                demoMyBubble.style.color = isLightColor(myColor) ? '#333' : '#fff';
            }
            
            if (demoAiBubble) {
                // 使用rgba背景色而不是opacity
                const transparentAiColor = convertColorWithOpacity(aiColor, aiOpacity);
                demoAiBubble.style.backgroundColor = transparentAiColor;
                demoAiBubble.style.color = isLightColor(aiColor) ? '#333' : '#fff';
            }
            
            // 更新颜色预览
            const myPreview = document.getElementById('my-bubble-preview');
            const aiPreview = document.getElementById('ai-bubble-preview');
            
            if (myPreview) {
                // 使用rgba背景色而不是opacity
                const transparentMyColor = convertColorWithOpacity(myColor, myOpacity);
                myPreview.style.backgroundColor = transparentMyColor;
                myPreview.textContent = '我的气泡';
            }
            
            if (aiPreview) {
                // 使用rgba背景色而不是opacity
                const transparentAiColor = convertColorWithOpacity(aiColor, aiOpacity);
                aiPreview.style.backgroundColor = transparentAiColor;
                aiPreview.textContent = '对方气泡';
            }
        }
        
        // 绑定头像上传事件
        function bindAvatarUploadEvents() {
            // 我的头像上传
            const myAvatarUpload = document.getElementById('my-chat-avatar-upload');
            if (myAvatarUpload) {
                myAvatarUpload.onchange = function(e) {
                    if (e.target.files && e.target.files[0]) {
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            const preview = document.getElementById('my-chat-avatar-preview');
                            if (preview) {
                                preview.style.backgroundImage = `url(${event.target.result})`;
                                preview.style.backgroundSize = 'cover';
                                preview.style.backgroundPosition = 'center';
                                preview.innerHTML = '';
                                window.selectedMyChatAvatar = event.target.result;
                            }
                        };
                        reader.readAsDataURL(e.target.files[0]);
                    }
                };
            }
            
            // AI头像上传
            const aiAvatarUpload = document.getElementById('ai-chat-avatar-upload');
            if (aiAvatarUpload) {
                aiAvatarUpload.onchange = function(e) {
                    if (e.target.files && e.target.files[0]) {
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            const preview = document.getElementById('ai-chat-avatar-preview');
                            if (preview) {
                                preview.style.backgroundImage = `url(${event.target.result})`;
                                preview.style.backgroundSize = 'cover';
                                preview.style.backgroundPosition = 'center';
                                preview.innerHTML = '';
                                window.selectedAiChatAvatar = event.target.result;
                            }
                        };
                        reader.readAsDataURL(e.target.files[0]);
                    }
                };
            }
        }
        
        // 初始化头像上传功能
        function initializeAvatarUpload() {
            const avatarInput = document.getElementById('avatar-upload');
            if (!avatarInput) {
                console.error('找不到avatar-upload元素');
                return;
            }
            
            // 移除旧的事件监听器
            avatarInput.removeEventListener('change', avatarUploadHandler);
            
            // 添加新的事件监听器
            avatarInput.addEventListener('change', avatarUploadHandler);
            console.log('头像上传事件监听器已绑定');
        }
        
        // 更新聊天设置界面的显示状态
        function updateChatSettingsDisplay() {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            
            // 更新历史消息数显示
            const historyCountElement = document.getElementById('current-history-count');
            if (historyCountElement) {
                historyCountElement.textContent = chatSettings.historyCount + '回合';
            }
            
            // 更新记忆挂载显示
            const memoryMountElement = document.getElementById('current-memory-mount');
            if (memoryMountElement) {
                memoryMountElement.textContent = chatSettings.memoryMountEnabled ? '已开启' : '已关闭';
            }
            
            // 更新世界书挂载显示
            updateWorldbookMountDisplay();
            
            // 更新时间感知开关
            const timeAwarenessCheckbox = document.getElementById('time-awareness-enabled');
            if (timeAwarenessCheckbox) {
                timeAwarenessCheckbox.checked = chatSettings.timeAwarenessEnabled;
            }
            
            // 更新通话设置
            const aiCallCheckbox = document.getElementById('ai-call-enabled');
            if (aiCallCheckbox) {
                aiCallCheckbox.checked = chatSettings.aiCallEnabled;
            }
            
            // 更新心率监测设置
            const aiHeartrateCheckbox = document.getElementById('ai-heartrate-enabled');
            if (aiHeartrateCheckbox) {
                aiHeartrateCheckbox.checked = chatSettings.aiHeartrateEnabled;
            }
            

            
            // 更新后台互动设置
            const backgroundInteractionCheckbox = document.getElementById('background-interaction-enabled');
            if (backgroundInteractionCheckbox) {
                backgroundInteractionCheckbox.checked = chatSettings.backgroundInteractionEnabled;
                // 控制详细设置显示
                const backgroundSettings = document.getElementById('background-interaction-settings');
                if (backgroundSettings) {
                    backgroundSettings.style.display = chatSettings.backgroundInteractionEnabled ? 'block' : 'none';
                }
            }
            
            const backgroundChatFrequencySelect = document.getElementById('background-chat-frequency');
            if (backgroundChatFrequencySelect) {
                backgroundChatFrequencySelect.value = chatSettings.backgroundChatFrequency || 'low';
            }
            
            const backgroundChatEnabledCheckbox = document.getElementById('background-chat-enabled');
            if (backgroundChatEnabledCheckbox) {
                backgroundChatEnabledCheckbox.checked = chatSettings.backgroundChatEnabled !== false;
                // 控制频率设置显示
                const chatFrequencySetting = document.getElementById('chat-frequency-setting');
                if (chatFrequencySetting) {
                    chatFrequencySetting.style.display = chatSettings.backgroundChatEnabled !== false ? 'block' : 'none';
                }
            }
            
            const backgroundMomentsEnabledCheckbox = document.getElementById('background-moments-enabled');
            if (backgroundMomentsEnabledCheckbox) {
                backgroundMomentsEnabledCheckbox.checked = chatSettings.backgroundMomentsEnabled !== false;
                // 控制相关设置显示
                const momentsEnabled = chatSettings.backgroundMomentsEnabled !== false;
                const momentsFrequencySetting = document.getElementById('moments-frequency-setting');
                const scheduledMomentsSetting = document.getElementById('scheduled-moments-setting');
                const testPublishSetting = document.getElementById('test-publish-setting');
                
                if (momentsFrequencySetting) {
                    momentsFrequencySetting.style.display = momentsEnabled ? 'flex' : 'none';
                }
                if (scheduledMomentsSetting) {
                    scheduledMomentsSetting.style.display = momentsEnabled ? 'flex' : 'none';
                }
                if (testPublishSetting) {
                    testPublishSetting.style.display = momentsEnabled ? 'flex' : 'none';
                }
            }
            
            const backgroundMomentsFrequencySelect = document.getElementById('background-moments-frequency');
            if (backgroundMomentsFrequencySelect) {
                backgroundMomentsFrequencySelect.value = chatSettings.backgroundMomentsFrequency || 'low';
            }
            
            const scheduledMomentsEnabledCheckbox = document.getElementById('scheduled-moments-enabled');
            if (scheduledMomentsEnabledCheckbox) {
                scheduledMomentsEnabledCheckbox.checked = chatSettings.scheduledMomentsEnabled || false;
                // 控制时间设置按钮显示
                const scheduledTimesButton = document.querySelector('button[onclick="showScheduleTimesModal()"]');
                if (scheduledTimesButton) {
                    scheduledTimesButton.style.display = chatSettings.scheduledMomentsEnabled ? 'inline-block' : 'none';
                }
            }
            
            // 更新定时发布时间显示
            updateScheduleTimesDisplay();
            
            // 更新时间戳设置
            const timestampCheckbox = document.getElementById('timestamp-enabled');
            if (timestampCheckbox) {
                timestampCheckbox.checked = chatSettings.timestampEnabled;
            }
            
            // 绑定事件监听器来保存设置变化
            bindChatSettingsEvents();
        }
        
        // 绑定聊天设置的事件监听器
        function bindChatSettingsEvents() {
            // 时间感知开关
            const timeAwarenessCheckbox = document.getElementById('time-awareness-enabled');
            if (timeAwarenessCheckbox) {
                timeAwarenessCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.timeAwarenessEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                };
            }
            
            // 通话设置
            const aiCallCheckbox = document.getElementById('ai-call-enabled');
            if (aiCallCheckbox) {
                aiCallCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.aiCallEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                };
            }
            
            // 心率监测设置
            const aiHeartrateCheckbox = document.getElementById('ai-heartrate-enabled');
            if (aiHeartrateCheckbox) {
                aiHeartrateCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.aiHeartrateEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                };
            }
            

            
            // 后台互动设置
            const backgroundInteractionCheckbox = document.getElementById('background-interaction-enabled');
            if (backgroundInteractionCheckbox) {
                backgroundInteractionCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundInteractionEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    // 显示/隐藏详细设置
                    const backgroundSettings = document.getElementById('background-interaction-settings');
                    if (backgroundSettings) {
                        backgroundSettings.style.display = this.checked ? 'block' : 'none';
                    }
                };
            }
            
            const backgroundChatFrequencySelect = document.getElementById('background-chat-frequency');
            if (backgroundChatFrequencySelect) {
                backgroundChatFrequencySelect.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundChatFrequency = this.value;
                    await saveCurrentChatSettings(chatSettings);
                };
            }
            
            const backgroundChatEnabledCheckbox = document.getElementById('background-chat-enabled');
            if (backgroundChatEnabledCheckbox) {
                backgroundChatEnabledCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundChatEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    
                    // 控制频率设置显示
                    const chatFrequencySetting = document.getElementById('chat-frequency-setting');
                    if (chatFrequencySetting) {
                        chatFrequencySetting.style.display = this.checked ? 'block' : 'none';
                    }
                    
                    // 重新初始化后台互动系统
                    initBackgroundInteractionSystem();
                };
            }
            
            const backgroundMomentsEnabledCheckbox = document.getElementById('background-moments-enabled');
            if (backgroundMomentsEnabledCheckbox) {
                backgroundMomentsEnabledCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundMomentsEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    
                    // 控制相关设置显示
                    const momentsFrequencySetting = document.getElementById('moments-frequency-setting');
                    const scheduledMomentsSetting = document.getElementById('scheduled-moments-setting');
                    const testPublishSetting = document.getElementById('test-publish-setting');
                    
                    if (momentsFrequencySetting) {
                        momentsFrequencySetting.style.display = this.checked ? 'flex' : 'none';
                    }
                    if (scheduledMomentsSetting) {
                        scheduledMomentsSetting.style.display = this.checked ? 'flex' : 'none';
                    }
                    if (testPublishSetting) {
                        testPublishSetting.style.display = this.checked ? 'flex' : 'none';
                    }
                    
                    // 重新初始化后台互动系统
                    initBackgroundInteractionSystem();
                };
            }
            
            const backgroundMomentsFrequencySelect = document.getElementById('background-moments-frequency');
            if (backgroundMomentsFrequencySelect) {
                backgroundMomentsFrequencySelect.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundMomentsFrequency = this.value;
                    await saveCurrentChatSettings(chatSettings);
                    
                    // 重新初始化后台互动系统
                    initBackgroundInteractionSystem();
                };
            }
            
            const scheduledMomentsEnabledCheckbox = document.getElementById('scheduled-moments-enabled');
            if (scheduledMomentsEnabledCheckbox) {
                scheduledMomentsEnabledCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.scheduledMomentsEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    
                    // 控制时间设置按钮显示
                    const scheduledTimesButton = document.querySelector('button[onclick="showScheduleTimesModal()"]');
                    if (scheduledTimesButton) {
                        scheduledTimesButton.style.display = this.checked ? 'inline-block' : 'none';
                    }
                    
                    // 重新初始化定时发布系统
                    initScheduledMomentsSystem();
                };
            }
            
            // 时间戳设置
            const timestampCheckbox = document.getElementById('timestamp-enabled');
            if (timestampCheckbox) {
                timestampCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.timestampEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    // 重新渲染聊天消息
                    if (currentChatCharacter) {
                        renderChatMessages(currentChatCharacter.id);
                    }
                };
            }
        }

        // 初始化聊天设置界面
        function initializeChatSettings() {
            // 更新身份显示
            updateChatIdentityDisplay();
            
            // 更新气泡样式显示
            updateBubbleStyleDisplay();
            
            // 更新所有设置显示状态
            updateChatSettingsDisplay();
            
            // 加载当前聊天的设置
            if (currentChatCharacter) {
                const chatSettings = getCurrentChatSettings();
                
                // 设置聊天模式
                const chatMode = chatSettings.chatMode || 'online';
                const onlineRadio = document.getElementById('chat-mode-online');
                const offlineRadio = document.getElementById('chat-mode-offline');
                
                if (onlineRadio && offlineRadio) {
                    if (chatMode === 'online') {
                        onlineRadio.checked = true;
                    } else {
                        offlineRadio.checked = true;
                    }
                    
                    // 显示/隐藏线下模式字数控制
                    const offlineLengthControl = document.getElementById('offline-length-control');
                    if (offlineLengthControl) {
                        offlineLengthControl.style.display = chatMode === 'offline' ? 'flex' : 'none';
                    }
                    
                    // 设置线下模式字数限制
                    const maxLengthInput = document.getElementById('offline-mode-max-length');
                    if (maxLengthInput) {
                        maxLengthInput.value = chatSettings.offlineModeMaxLength || 100;
                    }
                }
            }
            
            // 绑定聊天模式切换事件
            const chatModeRadios = document.querySelectorAll('input[name="chat-mode"]');
            chatModeRadios.forEach(radio => {
                radio.addEventListener('change', function() {
                    const offlineLengthControl = document.getElementById('offline-length-control');
                    if (offlineLengthControl) {
                        offlineLengthControl.style.display = this.value === 'offline' ? 'flex' : 'none';
                    }
                    
                    // 保存聊天模式设置
                    saveChatModeSettings();
                });
            });
            
            // 绑定线下模式字数限制变化事件
            const maxLengthInput = document.getElementById('offline-mode-max-length');
            if (maxLengthInput) {
                maxLengthInput.addEventListener('change', saveChatModeSettings);
            }
            

            
            // 绑定后台互动开关事件
            const backgroundInteractionCheckbox = document.getElementById('background-interaction-enabled');
            if (backgroundInteractionCheckbox) {
                backgroundInteractionCheckbox.addEventListener('change', function() {
                    const backgroundSettings = document.getElementById('background-interaction-settings');
                    if (backgroundSettings) {
                        backgroundSettings.style.display = this.checked ? 'block' : 'none';
                    }
                    
                    // 如果关闭后台互动，清除所有定时器
                    if (!this.checked) {
                        clearAllBackgroundTimers();
                    } else {
                        // 如果开启后台互动，重新初始化系统
                        initBackgroundInteractionSystem();
                    }
                });
            }
            
            // 绑定主动聊天开关事件
            const backgroundChatCheckbox = document.getElementById('background-chat-enabled');
            if (backgroundChatCheckbox) {
                backgroundChatCheckbox.addEventListener('change', function() {
                    const frequencySetting = document.getElementById('chat-frequency-setting');
                    if (frequencySetting) {
                        frequencySetting.style.display = this.checked ? 'block' : 'none';
                    }
                    
                    // 重新初始化后台互动系统
                    if (currentChatCharacter) {
                        initBackgroundInteractionSystem();
                    }
                });
            }
            
            // 绑定主动发动态开关事件
            const backgroundMomentsCheckbox = document.getElementById('background-moments-enabled');
            if (backgroundMomentsCheckbox) {
                backgroundMomentsCheckbox.addEventListener('change', function() {
                    const frequencySetting = document.getElementById('moments-frequency-setting');
                    if (frequencySetting) {
                        frequencySetting.style.display = this.checked ? 'flex' : 'none';
                    }
                    
                    // 重新初始化后台互动系统
                    if (currentChatCharacter) {
                        initBackgroundInteractionSystem();
                    }
                });
            }
            
            // 绑定戳一戳功能开关事件
            const pokeEnabledCheckbox = document.getElementById('poke-enabled');
            if (pokeEnabledCheckbox) {
                pokeEnabledCheckbox.addEventListener('change', function() {
                    const pokeSuffixSettings = document.getElementById('poke-suffix-settings');
                    if (pokeSuffixSettings) {
                        pokeSuffixSettings.style.display = this.checked ? 'block' : 'none';
                    }
                });
            }
            
            // 绑定选择模式按钮事件
            const selectionCancelBtn = document.getElementById('selection-cancel-btn');
            const selectionDeleteBtn = document.getElementById('selection-delete-btn');
            
            if (selectionCancelBtn) {
                selectionCancelBtn.addEventListener('click', exitMessageSelectionMode);
            }
            
            if (selectionDeleteBtn) {
                selectionDeleteBtn.addEventListener('click', function() {
                    if (selectedMessages.size === 0) return;
                    
                    deleteSelectedMessages();
                });
            }
        }
        
        // 戳一戳功能
        function pokeCharacter(characterId) {
            if (!currentChatCharacter || currentChatCharacter.id !== characterId) {
                return;
            }
            
            const chatSettings = getCurrentChatSettings();
            const pokeSuffix = chatSettings.myPokeSuffix || '';
            const characterName = chatSettings.aiChatNickname || currentChatCharacter.name;
            
            // 创建戳一戳系统消息
            const pokeMessage = {
                id: Date.now().toString(),
                sender: 'system',
                content: `你戳了戳${characterName}${pokeSuffix}`,
                timestamp: Date.now(),
                isPoke: true
            };
            
            // 添加到聊天记录
            if (!chatMessages[characterId]) {
                chatMessages[characterId] = [];
            }
            
            chatMessages[characterId].push(pokeMessage);
            saveChatMessages();
            
            // 渲染消息
            renderChatMessages(characterId);
            
            // 模拟角色回应（40%概率）
            if (Math.random() < 0.4) {
                setTimeout(() => {
                    const aiPokeSuffix = chatSettings.aiPokeSuffix || '';
                    const aiPokeMessage = {
                        id: Date.now().toString(),
                        sender: 'system',
                        content: `${characterName}戳了戳你${aiPokeSuffix}`,
                        timestamp: Date.now(),
                        isPoke: true
                    };
                    
                    chatMessages[characterId].push(aiPokeMessage);
                    saveChatMessages();
                    renderChatMessages(characterId);
                }, 1000 + Math.random() * 2000);
            }
        }
        
        // 显示聊天选项
        function showChatOptions() {
            showModal('chat-options-modal');
        }
        
        // 显示单聊身份选择（第一步）
        function showSingleChatSelector() {
            hideModal('chat-options-modal');
            showPersonaSelectionForSingleChat();
        }
        
        // 显示单聊身份选择
        function showPersonaSelectionForSingleChat() {
            const modalHTML = `
                <div class="modal" id="persona-selection-modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 class="modal-title">选择身份</h3>
                            <button class="modal-close" onclick="hidePersonaSelectionModal()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p class="selection-description">请选择你在这次对话中使用的身份面具</p>
                            <div class="persona-selection-list" id="persona-selection-list">
                                ${personas.map(persona => `
                                    <div class="persona-selection-item" data-persona-id="${persona.id}">
                                        <div class="persona-selection-avatar" style="${persona.avatarUrl ? `background-image: url(${persona.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                                            ${persona.avatarUrl ? '' : persona.name.charAt(0)}
                                        </div>
                                        <div class="persona-selection-info">
                                            <div class="persona-selection-name">${persona.name}</div>
                                            <div class="persona-selection-desc">${truncateText(persona.description || '暂无描述', 100)}</div>
                                        </div>
                                        <div class="persona-selection-check">
                                            <i class="fas fa-check"></i>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-secondary" onclick="hidePersonaSelectionModal()">取消</button>
                            <button class="modal-primary" id="confirm-persona-btn" onclick="confirmPersonaAndShowCharacters()" disabled>下一步：选择角色</button>
                        </div>
                    </div>
                </div>
            `;
            
            // 移除已存在的模态框
            const existingModal = document.getElementById('persona-selection-modal');
            if (existingModal) {
                existingModal.remove();
            }
            
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            
            // 绑定点击事件
            document.querySelectorAll('.persona-selection-item').forEach(item => {
                item.addEventListener('click', function() {
                    document.querySelectorAll('.persona-selection-item').forEach(i => i.classList.remove('selected'));
                    this.classList.add('selected');
                    window.selectedPersonaForChat = this.dataset.personaId;
                    document.getElementById('confirm-persona-btn').disabled = false;
                });
            });
        }
        
        // 隐藏身份选择模态框
        function hidePersonaSelectionModal() {
            const modal = document.getElementById('persona-selection-modal');
            if (modal) {
                modal.remove();
            }
            window.selectedPersonaForChat = null;
        }
        
        // 确认身份选择并显示角色选择
        function confirmPersonaAndShowCharacters() {
            if (!window.selectedPersonaForChat) return;
            
            hidePersonaSelectionModal();
            showCharacterSelectionForSingleChat();
        }
        
        // 显示单聊角色选择（第二步）
        function showCharacterSelectionForSingleChat() {
            // 🔥【修复】保存当前选中的身份ID，防止在后续流程中丢失
            const savedPersonaId = window.selectedPersonaForChat;
            console.log('=== showCharacterSelectionForSingleChat ===');
            console.log('保存的身份ID:', savedPersonaId);
            
            const modalBody = document.getElementById('single-chat-body');
            modalBody.innerHTML = '';
            
            if (characters.length === 0) {
                modalBody.innerHTML = '<p class="empty-mount-chats">还没有角色，请先创建角色</p>';
            } else {
                characters.forEach(character => {
                    const chatOption = document.createElement('div');
                    chatOption.className = 'chat-option-item';
                    chatOption.onclick = () => {
                        // 🔥【修复】使用保存的身份ID而不是全局变量
                        console.log('=== 角色选择点击事件 ===');
                        console.log('选中的角色:', character.name);
                        console.log('使用的身份ID:', savedPersonaId);
                        
                        hideModal('single-chat-modal');
                        // 设置选择的身份并开始聊天
                        startChatWithPersona(character, savedPersonaId);
                        
                        // 清理临时变量
                        window.selectedPersonaForChat = null;
                    };
                    
                    chatOption.innerHTML = `
                        <div class="chat-option-icon" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                            ${character.avatarUrl ? '' : character.name.charAt(0)}
                        </div>
                        <div class="chat-option-text">
                            <div class="chat-option-title">${character.name}</div>
                            <div class="chat-option-desc">${truncateText(character.bio || '暂无描述', 80)}</div>
                        </div>
                    `;
                    
                    modalBody.appendChild(chatOption);
                });
            }
            
            showModal('single-chat-modal');
        }
        
        async function startChatWithPersona(character, personaId) {
            console.log('✅[修复] startChatWithPersona 被调用');
            if (personaId) {
        // 获取或创建此聊天的专属设置
                let settings = chatSettings[character.id] || {};
                settings.selectedIdentityId = personaId;
                const selectedPersona = personas.find(p => p.id === personaId);
                if (selectedPersona) {
            settings.myChatAvatar = selectedPersona.avatarUrl || '';
            settings.myChatNickname = selectedPersona.name || '';
                chatSettings[character.id] = settings;
                await saveCurrentChatSettings(settings);
            }
    }
            if (!contacts.includes(character.id)) {
        console.log('✅[修复] 发现新联系人，正在同步保存...');
                contacts.push(character.id);
        // 使用 await 确保保存操作完成后再继续
                await saveContacts();
        console.log('✅[修复] 新联系人保存成功，内存中的 contacts 列表:', contacts);
        // 保存成功后，立即刷新一次消息列表的后台数据
        renderMessageList();
    } else {
        console.log('ℹ️ 已存在的联系人，无需重复添加');
            }
            
            // 开始聊天
            startChat(character);
        }
        
        
        // 切换群聊成员选择
        function toggleGroupMemberSelection(characterId) {
            const index = selectedGroupMembers.indexOf(characterId);
            const checkbox = document.getElementById(`checkbox-${characterId}`);
            const memberItem = checkbox.closest('.group-member-item');
            
            if (index > -1) {
                selectedGroupMembers.splice(index, 1);
                checkbox.classList.remove('checked');
                checkbox.innerHTML = '';
                memberItem.classList.remove('selected');
            } else {
                if (selectedGroupMembers.length >= 8) {
                    alert('最多只能选择8个成员');
                    return;
                }
                selectedGroupMembers.push(characterId);
                checkbox.classList.add('checked');
                checkbox.innerHTML = '<i class="fas fa-check"></i>';
                memberItem.classList.add('selected');
            }
        }
        
 // --- 请从这里开始，完整复制所有代码 ---

// 1. 显示聊天选项（入口函数，保持不变）
        function showGroupChatSelector() {
            hideModal('chat-options-modal');
            showPersonaSelectionForGroupChat();
        }
        
// 2. 显示群聊身份选择
        function showPersonaSelectionForGroupChat() {
            const modalHTML = `
                <div class="modal" id="persona-selection-group-modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 class="modal-title">选择身份</h3>
                            <button class="modal-close" onclick="hidePersonaSelectionGroupModal()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p class="selection-description">请选择你在这个群聊中使用的身份面具</p>
                            <div class="persona-selection-list" id="persona-selection-group-list">
                                ${personas.map(persona => `
                                    <div class="persona-selection-item" data-persona-id="${persona.id}">
                                <div class="persona-selection-avatar" style="${persona.avatarUrl ? `background-image: url('${persona.avatarUrl}'); background-size: cover; background-position: center;` : ''}">
                                            ${persona.avatarUrl ? '' : persona.name.charAt(0)}
                                        </div>
                                        <div class="persona-selection-info">
                                            <div class="persona-selection-name">${persona.name}</div>
                                            <div class="persona-selection-desc">${truncateText(persona.description || '暂无描述', 100)}</div>
                                        </div>
                                <div class="persona-selection-check"><i class="fas fa-check"></i></div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-secondary" onclick="hidePersonaSelectionGroupModal()">取消</button>
                    <button class="modal-primary" id="confirm-group-persona-btn" disabled>下一步：设置群聊</button>
                        </div>
                    </div>
                </div>
            `;
            
            const existingModal = document.getElementById('persona-selection-group-modal');
    if (existingModal) existingModal.remove();
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            
    let selectedPersonaId = null;

            document.querySelectorAll('#persona-selection-group-modal .persona-selection-item').forEach(item => {
                item.addEventListener('click', function() {
                    document.querySelectorAll('#persona-selection-group-modal .persona-selection-item').forEach(i => i.classList.remove('selected'));
                    this.classList.add('selected');
            selectedPersonaId = this.dataset.personaId;
                    document.getElementById('confirm-group-persona-btn').disabled = false;
                    console.log('✅ 选择了身份:', selectedPersonaId, '身份名称:', this.querySelector('.persona-selection-name').textContent);
                });
            });

    // 关键修复：让“下一步”按钮的点击事件直接调用下一步函数，并把ID传过去
    document.getElementById('confirm-group-persona-btn').onclick = () => {
        console.log('✅ 点击下一步按钮，当前selectedPersonaId值为:', selectedPersonaId);
        if (selectedPersonaId) {
            console.log('✅ 准备调用confirmPersonaAndShowGroupSettings，传递ID:', selectedPersonaId);
            confirmPersonaAndShowGroupSettings(selectedPersonaId);
        } else {
            console.error('❌ 未选择身份就点击了下一步');
            alert('请先选择一个身份面具');
        }
    };
}

// 3. 隐藏身份选择模态框的函数
        function hidePersonaSelectionGroupModal() {
            const modal = document.getElementById('persona-selection-group-modal');
    if (modal) modal.remove();
}

// 4. 确认身份并显示群成员选择
function confirmPersonaAndShowGroupSettings(personaId) {
    console.log('✅ confirmPersonaAndShowGroupSettings被调用，接收到的personaId:', personaId);
            hidePersonaSelectionGroupModal();
    showGroupChatMemberSelection(personaId); // 将选择的ID作为参数传递给下一步
        }
        
// 5. 显示群成员选择 (已恢复简介显示)
function showGroupChatMemberSelection(personaId) {
    console.log('✅ showGroupChatMemberSelection被调用，接收到的personaId:', personaId);
    
    // 立即将personaId存储到全局变量中，确保不会丢失
    window.currentGroupPersonaId = personaId;
            document.getElementById('group-chat-name').value = '';
            selectedGroupMembers = [];
            
            const membersContainer = document.getElementById('group-chat-members');
            membersContainer.innerHTML = '';
            
            if (characters.length < 2) {
                membersContainer.innerHTML = '<p class="empty-mount-chats">至少需要2个角色才能创建群聊</p>';
            } else {
                characters.forEach(character => {
                    const memberItem = document.createElement('div');
                    memberItem.className = 'group-member-item';
                    memberItem.onclick = () => toggleGroupMemberSelection(character.id);
            // 关键修复：恢复了显示角色简介的HTML代码
                    memberItem.innerHTML = `
                <div class="group-member-checkbox" id="checkbox-${character.id}"></div>
                <div class="message-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url('${character.avatarUrl}');` : ''}">
                            ${character.avatarUrl ? '' : character.name.charAt(0)}
                        </div>
                        <div class="chat-option-text">
                            <div class="chat-option-title">${character.name}</div>
                    <div class="chat-option-desc">${truncateText(character.bio || '暂无简介', 80)}</div>
                </div>`;
                    membersContainer.appendChild(memberItem);
                });
            }

    // 关键修复：将 personaId 绑定到最终的“创建群聊”按钮上
    console.log('✅ 在第一个位置绑定创建按钮，personaId:', personaId);
    const createBtn = document.getElementById('group-chat-modal').querySelector('.modal-primary');
    createBtn.onclick = () => {
        console.log('✅ 第一个位置的创建群聊按钮被点击，直接使用参数personaId:', personaId);
        createGroupChat(personaId);
    }; // 绑定带参数的创建函数
            
            showModal('group-chat-modal');
        }
        
// 6. 切换群成员选择状态 (无修改，但为了完整性包含在此)
        function toggleGroupMemberSelection(characterId) {
            const index = selectedGroupMembers.indexOf(characterId);
            const checkbox = document.getElementById(`checkbox-${characterId}`);
            const memberItem = checkbox.closest('.group-member-item');
            
            if (index > -1) {
                selectedGroupMembers.splice(index, 1);
                checkbox.classList.remove('checked');
                checkbox.innerHTML = '';
                memberItem.classList.remove('selected');
            } else {
                if (selectedGroupMembers.length >= 8) {
                    alert('最多只能选择8个成员');
                    return;
                }
                selectedGroupMembers.push(characterId);
                checkbox.classList.add('checked');
                checkbox.innerHTML = '<i class="fas fa-check"></i>';
                memberItem.classList.add('selected');
            }
        }
        

// 7. 创建群聊（最终版本）
async function createGroupChat(personaId) {
    console.log(`✅ createGroupChat被调用，身份ID: ${personaId}`);

    const groupName = document.getElementById('group-chat-name').value.trim();
    if (!groupName) return alert('请输入群聊名称');
    if (selectedGroupMembers.length < 2) return alert('至少需要选择2个成员');

            const memberDetails = selectedGroupMembers.map(memberId => {
                const character = characters.find(c => c.id === memberId);
        return { id: character.id, name: character.name, bio: character.bio, avatarUrl: character.avatarUrl, color: character.color };
    });

            const groupChat = {
                id: 'group_' + Date.now().toString(),
                name: groupName,
                members: memberDetails,
                isGroup: true,
                createdAt: new Date().toISOString()
            };
            
    // 只有在 personaId 存在时才保存身份设置
    if (personaId) {
        const selectedPersona = personas.find(p => p.id === personaId);
                if (selectedPersona) {
                    const chatSettings = {
                selectedIdentityId: personaId,
                        myChatAvatar: selectedPersona.avatarUrl,
                        myChatNickname: selectedPersona.name,
                selectedPersonaData: { ...selectedPersona }
            };
                    // 确保 window.chatSettings 已初始化
                    if (!window.chatSettings) {
                        window.chatSettings = {};
                    }
                    window.chatSettings[groupChat.id] = chatSettings;
            await db.chatSettings.put({ id: groupChat.id, chatId: groupChat.id, settings: chatSettings });
            console.log('✅ 群聊身份设置已成功保存');
                } else {
            console.error('❌ 创建群聊时未找到ID为 ' + personaId + ' 的身份。');
                }
            }
            
            if (!groupChats) groupChats = [];
            groupChats.push(groupChat);
            await saveGroupChats();
            hideModal('group-chat-modal');
            renderMessageList();
            alert(`群聊"${groupName}"创建成功！`);
        }

// --- 请复制到这里结束 ---
        
        // 保存群聊数据 - 使用IndexedDB
        async function saveGroupChats() {
            try {
                console.log('保存群聊数据到IndexedDB:', groupChats);
                
                // 检查数据完整性
                if (!groupChats || !Array.isArray(groupChats)) {
                    console.error('群聊数据无效:', groupChats);
                    groupChats = [];
                }
                
                // 验证每个群聊对象的完整性
                const validGroupChats = groupChats.filter(chat => {
                    if (!chat || !chat.id || !chat.name) {
                        console.warn('发现无效的群聊对象:', chat);
                        return false;
                    }
                    return true;
                });
                
                // 如果有无效数据，更新数组
                if (validGroupChats.length !== groupChats.length) {
                    groupChats = validGroupChats;
                    console.log('已过滤无效数据，有效群聊数量:', groupChats.length);
                }
                
                // 使用事务来确保数据一致性
                await db.transaction('rw', db.groupChats, async () => {
                // 清空现有数据
                await db.groupChats.clear();
                
                    // 逐个插入数据以避免批量插入的ID冲突问题
                    for (const chat of groupChats) {
                        try {
                            await db.groupChats.add(chat);
                        } catch (addError) {
                            console.warn('插入群聊失败，尝试更新:', chat.id, addError);
                            // 如果添加失败，尝试更新
                            await db.groupChats.put(chat);
                        }
                    }
                });
                
                console.log('群聊数据保存成功到IndexedDB');
                
                // 同时保存到localStorage作为备份
                try {
                    localStorage.setItem('groupChats', JSON.stringify(groupChats));
                    console.log('群聊数据备份到localStorage成功');
                } catch (storageError) {
                    console.warn('localStorage备份失败:', storageError);
                    // localStorage失败不应该阻止IndexedDB的成功保存
                }
                
            } catch (error) {
                console.error('保存群聊到IndexedDB失败:', error);
                console.error('错误详情:', error.name, error.message);
                
                // 如果IndexedDB失败，回退到localStorage
                try {
                    localStorage.setItem('groupChats', JSON.stringify(groupChats || []));
                    console.log('群聊数据回退保存到localStorage成功');
                    showToast('群聊已保存到本地存储', 'info');
                } catch (localError) {
                    console.error('localStorage保存也失败:', localError);
                    console.error('localStorage错误详情:', localError.name, localError.message);
                    
                    // 检查是否是存储空间不足
                    if (localError.name === 'QuotaExceededError') {
                        alert('存储空间不足，请清理一些数据后重试');
                    } else {
                        alert('保存群聊失败，请尝试刷新页面重新操作');
                    }
                    
                    // 恢复到之前的状态
                    groupChats.pop(); // 移除刚添加的群聊
                    throw localError;
                }
            }
        }
        
        // 渲染定时发布时间点
        function renderScheduleTimes() {
            const container = document.getElementById('schedule-times-container');
            if (!container) return;
            
            const chatSettings = getCurrentChatSettings();
            const scheduleTimes = chatSettings.scheduleTimes || [];
            
            container.innerHTML = '';
            
            scheduleTimes.forEach((time, index) => {
                const timeItem = document.createElement('div');
                timeItem.className = 'schedule-time-item';
                timeItem.innerHTML = `
                    <input type="time" value="${time}" onchange="updateScheduleTime(${index}, this.value)">
                    <button onclick="removeScheduleTime(${index})">×</button>
                `;
                container.appendChild(timeItem);
            });
        }
        
        // 添加定时发布时间点
        async function addScheduleTime() {
            const chatSettings = getCurrentChatSettings();
            if (!chatSettings.scheduleTimes) {
                chatSettings.scheduleTimes = [];
            }
            
            if (chatSettings.scheduleTimes.length >= 10) {
                alert('最多只能设置10个时间点');
                return;
            }
            
            chatSettings.scheduleTimes.push('09:00');
            await saveCurrentChatSettings(chatSettings);
            renderScheduleTimes();
        }
        
        // 更新定时发布时间点
        async function updateScheduleTime(index, newTime) {
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.scheduleTimes && chatSettings.scheduleTimes[index] !== undefined) {
                chatSettings.scheduleTimes[index] = newTime;
                await saveCurrentChatSettings(chatSettings);
            }
        }
        
        // 移除定时发布时间点
        async function removeScheduleTime(index) {
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.scheduleTimes && chatSettings.scheduleTimes[index] !== undefined) {
                chatSettings.scheduleTimes.splice(index, 1);
                await saveCurrentChatSettings(chatSettings);
                renderScheduleTimes();
            }
        }
        
        // 保存定时发布设置
        async function saveScheduleSettings() {
            const chatSettings = getCurrentChatSettings();
            chatSettings.scheduleEnabled = document.getElementById('schedule-enabled').checked;
            
            await saveCurrentChatSettings(chatSettings);
            hideModal('schedule-settings-modal');
            showToast('定时发布设置已保存', 'success');
        }
        
        // 显示世界书挂载设置
        function showWorldbookMountSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // 加载当前设置
            document.getElementById('worldbook-mount-enabled').checked = chatSettings.worldbookMountEnabled || false;
            
            // 控制详细设置的显示
            toggleWorldbookMountDetails();
            
            // 绑定事件
            document.getElementById('worldbook-mount-enabled').onchange = toggleWorldbookMountDetails;
            
            // 渲染世界书列表
            renderWorldbookMountList();
            
            showModal('worldbook-mount-modal');
        }
        
        // 切换世界书挂载详细设置显示
        function toggleWorldbookMountDetails() {
            const enabled = document.getElementById('worldbook-mount-enabled').checked;
            document.getElementById('worldbook-mount-details').style.display = enabled ? 'block' : 'none';
            
            // 更新主设置界面显示
            updateWorldbookMountDisplay();
        }
        
        // 更新世界书挂载显示状态
        function updateWorldbookMountDisplay() {
            const chatSettings = getCurrentChatSettings();
            const displayElement = document.getElementById('current-worldbook-mount');
            
            if (!chatSettings.worldbookMountEnabled) {
                displayElement.textContent = '未挂载';
                return;
            }
            
            const selectedWorldbooks = chatSettings.selectedWorldbooks || [];
            if (selectedWorldbooks.length === 0) {
                displayElement.textContent = '已启用但未选择';
            } else if (selectedWorldbooks.length === 1) {
                const worldbook = worldbooks.find(w => w.id === selectedWorldbooks[0]);
                displayElement.textContent = worldbook ? `已挂载: ${worldbook.title}` : '已挂载: 1个';
            } else {
                displayElement.textContent = `已挂载: ${selectedWorldbooks.length}个`;
            }
        }
        
        // 渲染世界书挂载列表
        function renderWorldbookMountList() {
            const container = document.getElementById('worldbook-mount-list');
            container.innerHTML = '';
            
            if (worldbooks.length === 0) {
                container.innerHTML = '<p class="empty-mount-chats">暂无世界书，请先在世界书应用中创建</p>';
                return;
            }
            
            const chatSettings = getCurrentChatSettings();
            const selectedWorldbooks = chatSettings.selectedWorldbooks || [];
            
            worldbooks.forEach(worldbook => {
                const item = document.createElement('div');
                item.className = 'mount-item worldbook-mount-item';
                
                const isSelected = selectedWorldbooks.includes(worldbook.id);
                
                item.innerHTML = `
                    <input type="checkbox" id="worldbook-${worldbook.id}" value="${worldbook.id}" ${isSelected ? 'checked' : ''} class="worldbook-checkbox">
                    <div class="worldbook-content-flex">
                        <div class="worldbook-title-text">
                            ${worldbook.title}
                        </div>
                        <div class="worldbook-desc-text">
                            ${worldbook.content.length > 100 ? worldbook.content.substring(0, 100) + '...' : worldbook.content}
                        </div>
                        <div class="worldbook-date-text">
                            创建于: ${new Date(worldbook.createdAt).toLocaleDateString('zh-CN')} | 
                            字数: ${worldbook.content.length}
                        </div>
                    </div>
                `;
                
                // 点击整个条目也能切换选择状态
                item.onclick = (e) => {
                    if (e.target.type !== 'checkbox') {
                        const checkbox = item.querySelector('input[type="checkbox"]');
                        checkbox.checked = !checkbox.checked;
                    }
                };
                
                container.appendChild(item);
            });
        }
        
        // 保存世界书挂载设置
        function saveWorldbookMountSettings() {
            const chatSettings = getCurrentChatSettings();
            
            chatSettings.worldbookMountEnabled = document.getElementById('worldbook-mount-enabled').checked;
            
            // 获取选中的世界书
            const checkboxes = document.querySelectorAll('#worldbook-mount-list input[type="checkbox"]:checked');
            chatSettings.selectedWorldbooks = Array.from(checkboxes).map(cb => cb.value);
            
            saveCurrentChatSettings(chatSettings);
            updateWorldbookMountDisplay();
            hideModal('worldbook-mount-modal');
            
            const selectedCount = chatSettings.selectedWorldbooks ? chatSettings.selectedWorldbooks.length : 0;
            if (chatSettings.worldbookMountEnabled && selectedCount > 0) {
                showToast(`世界书挂载设置已保存，已挂载 ${selectedCount} 个世界书`, 'success');
            } else if (chatSettings.worldbookMountEnabled) {
                showToast('世界书挂载已启用，但未选择任何世界书', 'info');
            } else {
                showToast('世界书挂载已关闭', 'info');
            }
        }
        
        // 身份选择器功能已移除，身份在创建对话时选择
        
        // 压缩图片以减少存储空间
        function compressImage(dataUrl, maxWidth = 300, quality = 0.8) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // 计算新的尺寸，保持宽高比
                    let { width, height } = img;
                    if (width > height) {
                        if (width > maxWidth) {
                            height = (height * maxWidth) / width;
                            width = maxWidth;
                        }
                    } else {
                        if (height > maxWidth) {
                            width = (width * maxWidth) / height;
                            height = maxWidth;
                        }
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    // 绘制并压缩
                    ctx.drawImage(img, 0, 0, width, height);
                    const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                    
                    console.log(`图片压缩：${Math.round(dataUrl.length/1024)}KB -> ${Math.round(compressedDataUrl.length/1024)}KB`);
                    resolve(compressedDataUrl);
                };
                img.src = dataUrl;
            });
        }
        

        
        // 🔥【紧急修复】恢复设置并刷新界面
        function recoverAndRefreshSettings() {
            if (!currentChatCharacter) {
                showToast('请先选择一个聊天窗口', 'warning');
                return;
            }
            
            const chatId = currentChatCharacter.id;
            console.log(`开始恢复聊天设置: ${chatId}`);
            console.log('当前设置状态:', JSON.stringify(chatSettings[chatId], null, 2));
            
            // 显示恢复进度
            showToast('正在尝试恢复设置...', 'info');
            
            // 🔥【直接恢复方法】强制从localStorage恢复，不通过getCurrentChatSettings
            const savedLocalStorage = localStorage.getItem(`chatSettings_${chatId}`);
            if (savedLocalStorage) {
                try {
                    const recoveredSettings = JSON.parse(savedLocalStorage);
                    console.log('从localStorage恢复的设置:', JSON.stringify(recoveredSettings, null, 2));
                    
                    // 直接覆盖全局设置
                    chatSettings[chatId] = recoveredSettings;
                    
                    // 立即刷新当前界面的显示（如果在设置界面）
                    if (document.getElementById('api-chat-settings-screen').style.display !== 'none') {
                        updateChatSettingsDisplay();
                    }
                    
                    // 刷新聊天消息界面
                    if (currentChatCharacter) {
                        renderChatMessages(currentChatCharacter.id);
                    }
                    
                    showToast('设置恢复成功！', 'success');
                    console.log('设置恢复完成，当前设置:', JSON.stringify(chatSettings[chatId], null, 2));
                    return;
                } catch (error) {
                    console.error('解析localStorage设置失败:', error);
                }
            }
            
            // 如果localStorage失败，尝试从IndexedDB恢复
            db.chatSettings.get(chatId).then(dbSettings => {
                if (dbSettings && dbSettings.settings) {
                    console.log('从IndexedDB恢复的设置:', JSON.stringify(dbSettings.settings, null, 2));
                    
                    // 直接覆盖全局设置
                    chatSettings[chatId] = dbSettings.settings;
                    
                    // 同步到localStorage
                    localStorage.setItem(`chatSettings_${chatId}`, JSON.stringify(dbSettings.settings));
                    
                    // 立即刷新界面
                    if (document.getElementById('api-chat-settings-screen').style.display !== 'none') {
                        updateChatSettingsDisplay();
                    }
                    
                    if (currentChatCharacter) {
                        renderChatMessages(currentChatCharacter.id);
                    }
                    
                    showToast('从备份数据恢复设置成功！', 'success');
                    console.log('从IndexedDB恢复设置成功:', JSON.stringify(dbSettings.settings, null, 2));
                } else {
                    showToast('未找到备份数据，设置可能已永久丢失', 'error');
                    console.log('未找到任何备份数据');
                }
            }).catch(error => {
                console.error('从IndexedDB恢复设置失败:', error);
                showToast('恢复设置失败，请联系技术支持', 'error');
            });
        }
        
        // 🔥【紧急修复】尝试恢复被覆盖的聊天设置
        function recoverChatSettings() {
            if (!currentChatCharacter) return false;
            
            const chatId = currentChatCharacter.id;
            console.log('尝试恢复聊天设置...');
            
            // 尝试从localStorage恢复
            const savedSettings = localStorage.getItem(`chatSettings_${chatId}`);
            if (savedSettings) {
                try {
                    const userSettings = JSON.parse(savedSettings);
                    chatSettings[chatId] = userSettings;
                    console.log('从localStorage恢复聊天设置成功:', userSettings);
                    return true;
                } catch (error) {
                    console.error('从localStorage恢复设置失败:', error);
                }
            }
            
            // 尝试从IndexedDB恢复
            db.chatSettings.get(chatId).then(dbSettings => {
                if (dbSettings && dbSettings.settings) {
                    chatSettings[chatId] = dbSettings.settings;
                    console.log('从IndexedDB恢复聊天设置成功:', dbSettings.settings);
                    // 同步到localStorage
                    localStorage.setItem(`chatSettings_${chatId}`, JSON.stringify(dbSettings.settings));
                    return true;
                }
            }).catch(error => {
                console.error('从IndexedDB恢复设置失败:', error);
            });
            
            return false;
        }
        
        // 强制刷新所有头像显示
        function forceRefreshAvatars() {
            const chatSettings = getCurrentChatSettings();
            const currentAvatar = chatSettings.aiDynamicAvatar || chatSettings.aiChatAvatar || currentChatCharacter.avatarUrl;
            
            console.log('强制刷新头像显示，当前头像:', currentAvatar ? currentAvatar.substring(0, 50) + '...' : '无头像');
            
            // 刷新聊天界面中所有角色头像
            const messageAvatars = document.querySelectorAll('.message-avatar');
            messageAvatars.forEach(avatar => {
                // 检查是否是当前角色的头像（通过点击事件判断）
                const onclickAttr = avatar.getAttribute('onclick');
                if (onclickAttr && onclickAttr.includes(`'${currentChatCharacter.id}'`)) {
                    if (currentAvatar && currentAvatar !== 'undefined') {
                        avatar.style.backgroundImage = `url(${currentAvatar})`;
                        avatar.style.backgroundSize = 'cover';
                        avatar.style.backgroundPosition = 'center';
                        avatar.innerHTML = '';
                    } else {
                        avatar.style.backgroundImage = 'none';
                        avatar.innerHTML = currentChatCharacter.name.charAt(0);
                    }
                }
            });
            
            // 如果当前在头像设置界面，也刷新预览
            const aiAvatarPreview = document.getElementById('ai-chat-avatar-preview');
            if (aiAvatarPreview && currentAvatar && currentAvatar !== 'undefined') {
                aiAvatarPreview.style.backgroundImage = `url(${currentAvatar})`;
                aiAvatarPreview.style.backgroundSize = 'cover';
                aiAvatarPreview.style.backgroundPosition = 'center';
                aiAvatarPreview.innerHTML = '';
                
                // 更新提示信息
                if (chatSettings.aiDynamicAvatar) {
                    aiAvatarPreview.title = '当前显示动态头像（角色在聊天中更换的）';
                } else {
                    aiAvatarPreview.title = '当前显示聊天设置头像';
                }
            }
        }
        
        // 📊 计算存储空间使用情况
        async function calculateStorageUsage() {
            try {
                let chatSize = 0;
                let characterSize = 0;
                let settingsSize = 0;
                let emojiSize = 0;

                // 计算聊天记录大小
                const chatMessagesData = await db.chatMessages.toArray();
                chatSize = JSON.stringify(chatMessagesData).length;

                // 计算角色数据大小
                const charactersData = await db.characters.toArray();
                characterSize = JSON.stringify(charactersData).length;

                // 计算聊天设置大小
                const chatSettingsData = await db.chatSettings.toArray();
                settingsSize = JSON.stringify(chatSettingsData).length;

                // 计算表情包大小
                const emojisData = await db.customEmojis.toArray();
                emojiSize = JSON.stringify(emojisData).length;

                const total = chatSize + characterSize + settingsSize + emojiSize;

                // 更新显示
                document.getElementById('chat-storage-size').textContent = formatBytes(chatSize);
                document.getElementById('character-storage-size').textContent = formatBytes(characterSize);
                document.getElementById('settings-storage-size').textContent = formatBytes(settingsSize);
                document.getElementById('emoji-storage-size').textContent = formatBytes(emojiSize);
                document.getElementById('total-storage-size').textContent = formatBytes(total);

                return { chatSize, characterSize, settingsSize, emojiSize, total };
            } catch (error) {
                console.error('计算存储使用情况失败:', error);
                return null;
            }
        }

        // 格式化字节数为可读格式
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // 🧹 压缩所有图片
        async function compressAllImages() {
            if (!confirm('将压缩所有头像和背景图片，这可能需要一些时间。确定继续吗？')) {
                return;
            }

            showToast('正在压缩图片...', 'info');
            let compressedCount = 0;

            try {
                // 压缩角色头像
                for (const character of characters) {
                    if (character.avatarUrl && character.avatarUrl.length > 50000) {
                        character.avatarUrl = await compressImage(character.avatarUrl, 150, 0.6);
                        compressedCount++;
                    }
                }
                await saveCharacters();

                // 压缩聊天设置中的头像
                for (const chatId of Object.keys(chatSettings)) {
                    const settings = chatSettings[chatId];
                    if (settings) {
                        if (settings.aiChatAvatar && settings.aiChatAvatar.length > 50000) {
                            settings.aiChatAvatar = await compressImage(settings.aiChatAvatar, 150, 0.6);
                            compressedCount++;
                        }
                        if (settings.myChatAvatar && settings.myChatAvatar.length > 50000) {
                            settings.myChatAvatar = await compressImage(settings.myChatAvatar, 150, 0.6);
                            compressedCount++;
                        }
                        if (settings.chatBackground && settings.chatBackground.length > 100000) {
                            settings.chatBackground = await compressImage(settings.chatBackground, 800, 0.7);
                            compressedCount++;
                        }
                    }
                }
                await saveChatSettings();

                // 更新存储使用情况
                calculateStorageUsage();

                showToast(`图片压缩完成！共处理了 ${compressedCount} 张图片`, 'success');
            } catch (error) {
                console.error('压缩图片失败:', error);
                showToast('压缩过程中出现错误', 'error');
            }
        }

        // 🧹 旧版清理存储空间（保留兼容性）
        async function cleanupStorageSpace() {
            if (!confirm('将清理以下数据以释放存储空间：\n\n• 所有角色的动态头像\n• localStorage中的过期数据\n• 压缩现有头像数据\n\n确定要继续吗？')) {
                return;
            }
            
            showToast('正在清理存储空间...', 'info');
            let cleanedSize = 0;
            let cleanedItems = 0;
            
            try {
                // 1. 清除所有动态头像
                Object.keys(chatSettings).forEach(chatId => {
                    if (chatSettings[chatId] && chatSettings[chatId].aiDynamicAvatar) {
                        delete chatSettings[chatId].aiDynamicAvatar;
                        cleanedItems++;
                    }
                });
                
                // 2. 清理localStorage中的过期chatSettings
                for (let i = localStorage.length - 1; i >= 0; i--) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('chatSettings_')) {
                        const value = localStorage.getItem(key);
                        if (value) {
                            cleanedSize += value.length;
                            localStorage.removeItem(key);
                            cleanedItems++;
                        }
                    }
                }
                
                // 3. 压缩所有现有头像数据
                for (const chatId of Object.keys(chatSettings)) {
                    const settings = chatSettings[chatId];
                    if (settings) {
                        if (settings.aiChatAvatar && settings.aiChatAvatar.length > 50000) {
                            settings.aiChatAvatar = await compressImage(settings.aiChatAvatar, 150, 0.6);
                            cleanedItems++;
                        }
                        if (settings.myChatAvatar && settings.myChatAvatar.length > 50000) {
                            settings.myChatAvatar = await compressImage(settings.myChatAvatar, 150, 0.6);
                            cleanedItems++;
                        }
                    }
                }
                
                // 4. 重新保存压缩后的设置到IndexedDB
                await saveChatSettings();
                
                // 5. 刷新当前界面
                if (currentChatCharacter) {
                    renderChatMessages(currentChatCharacter.id);
                }
                
                const sizeKB = Math.round(cleanedSize / 1024);
                showToast(`清理完成！释放了约 ${sizeKB}KB 空间，处理了 ${cleanedItems} 项数据`, 'success');
                
            } catch (error) {
                console.error('清理存储空间失败:', error);
                showToast('清理过程中出现错误，请重试', 'error');
            }
        }
        
        // 清除AI动态头像
        function clearAiDynamicAvatar() {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.aiDynamicAvatar) {
                delete chatSettings.aiDynamicAvatar;
                saveCurrentChatSettings(chatSettings);
                
                // 刷新聊天界面
                if (currentChatCharacter) {
                    renderChatMessages(currentChatCharacter.id);
                }
                
                showToast('动态头像已清除，恢复为聊天设置头像', 'success');
            } else {
                showToast('当前没有动态头像', 'info');
            }
        }
        
        // 保存聊天身份选择
        function saveChatIdentity() {
            if (!window.selectedChatIdentityId) {
                alert('请选择一个身份');
                return;
            }
            
            const chatSettings = getCurrentChatSettings();
            const selectedPersona = personas.find(p => p.id === window.selectedChatIdentityId);
            
            if (selectedPersona) {
                chatSettings.selectedIdentityId = selectedPersona.id;
                
                // 如果选中的身份有头像，自动设置为聊天头像（如果当前没有设置的话）
                if (selectedPersona.avatarUrl && !chatSettings.myChatAvatar) {
                    chatSettings.myChatAvatar = selectedPersona.avatarUrl;
                }
                
                // 如果选中的身份有名称，自动设置为聊天昵称（如果当前没有设置的话）
                if (selectedPersona.name && !chatSettings.myChatNickname) {
                    chatSettings.myChatNickname = selectedPersona.name;
                }
                
                saveCurrentChatSettings(chatSettings);
                
                // 更新显示
                updateChatIdentityDisplay();
                
                // 刷新聊天界面
                if (currentChatCharacter) {
                    renderChatMessages(currentChatCharacter.id);
                }
                
                hideModal('identity-selector-modal');
                showToast(`已选择身份"${selectedPersona.name}"`, 'success');
            }
        }
        
        // 更新聊天身份显示
        function updateChatIdentityDisplay() {
            const chatSettings = getCurrentChatSettings();
            const selectedIdentityId = chatSettings.selectedIdentityId || 'default';
            const selectedPersona = personas.find(p => p.id === selectedIdentityId);
            
            const displayElement = document.getElementById('current-chat-identity');
            if (displayElement && selectedPersona) {
                displayElement.textContent = selectedPersona.name;
            }
        }
        
        // 更新气泡样式显示
        function updateBubbleStyleDisplay() {
            const chatSettings = getCurrentChatSettings();
            const styleNames = {
                'default': '默认样式',
                'glass': '毛玻璃',
                'shadow': '经典阴影',
                'tail': '经典气泡',
                'gradient': '渐变样式',
                'minimal': '极简样式',
                'neon': '霓虹样式',
                'paper': '纸张样式'
            };
            
            const displayElement = document.getElementById('current-bubble-style');
            if (displayElement) {
                const currentStyle = chatSettings.bubbleStyle || 'default';
                displayElement.textContent = styleNames[currentStyle] || '默认样式';
            }
        }
        
        // 全局头像上传处理函数
        function handleAvatarUploadClick() {
            console.log('点击了上传头像按钮');
            const input = document.getElementById('avatar-upload');
            if (input) {
                console.log('找到了input元素，准备触发点击');
                input.click();
            } else {
                console.error('找不到avatar-upload元素');
                alert('找不到文件上传元素，请刷新页面重试');
            }
        }
        
        // 该函数已被删除，使用上面的异步IndexedDB版本
        
        // 添加消息长按监听器
        function addMessageLongPressListener(messageContainer, messageId) {
            let pressTimer = null;
            let isLongPress = false;
            
            const startLongPress = (e) => {
                if (isMessageSelectionMode) {
                    // 在选择模式下，只处理点击选择，不处理长按
                    return;
                }
                isLongPress = false;
                pressTimer = setTimeout(() => {
                    isLongPress = true;
                    enterMessageSelectionMode(messageId);
                    e.preventDefault();
                }, 500);
            };
            
            const cancelLongPress = () => {
                clearTimeout(pressTimer);
                // 重置长按标记，延迟重置以避免立即触发点击
                setTimeout(() => {
                    isLongPress = false;
                }, 50);
            };
            
            const handleClick = (e) => {
                // 在选择模式下，所有消息都可以点击切换选择状态
                if (isMessageSelectionMode) {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleMessageSelection(messageId);
                    return;
                }
                
                // 如果是长按触发后的点击，不处理
                if (isLongPress) {
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }
            };
            
            // 触摸事件
            messageContainer.addEventListener('touchstart', startLongPress, { passive: false });
            messageContainer.addEventListener('touchend', cancelLongPress);
            messageContainer.addEventListener('touchmove', cancelLongPress);
            
            // 鼠标事件（用于桌面端测试）
            messageContainer.addEventListener('mousedown', startLongPress);
            messageContainer.addEventListener('mouseup', cancelLongPress);
            messageContainer.addEventListener('mouseleave', cancelLongPress);
            
            // 点击事件 - 使用捕获阶段确保优先处理
            messageContainer.addEventListener('click', handleClick, true);
        }
        
        // 进入消息选择模式
        function enterMessageSelectionMode(initialMessageId) {
            if (isMessageSelectionMode) {
                return;
            }
            
            isMessageSelectionMode = true;
            selectedMessages.clear();
            selectedMessages.add(initialMessageId);
            
            // 添加选择模式CSS类
            const chatScreen = document.getElementById('api-chat-screen');
            if (chatScreen) {
                chatScreen.classList.add('selection-mode');
            }
            
            updateMessageSelectionUI();
        }
        
        // 切换消息选择状态
        function toggleMessageSelection(messageId) {
            if (!isMessageSelectionMode) return;
            
            if (selectedMessages.has(messageId)) {
                selectedMessages.delete(messageId);
            } else {
                selectedMessages.add(messageId);
            }
            
            updateMessageSelectionUI();
            
            // 如果没有选中的消息，退出选择模式
            if (selectedMessages.size === 0) {
                exitMessageSelectionMode();
            }
        }
        
        // 退出消息选择模式
        function exitMessageSelectionMode() {
            if (!isMessageSelectionMode) return;
            
            isMessageSelectionMode = false;
            
            // 移除选择模式CSS类
            const chatScreen = document.getElementById('api-chat-screen');
            if (chatScreen) {
                chatScreen.classList.remove('selection-mode');
            }
            
            // 🔥【修复】清除所有选中状态，包括撤回消息
            const selectedContainers = document.querySelectorAll('[data-message-id].selected');
            selectedContainers.forEach(container => {
                container.classList.remove('selected');
            });
            
            selectedMessages.clear();
            updateMessageSelectionUI();
        }
        

        
        // 更新消息选择UI
        function updateMessageSelectionUI() {
            // 🔥【修复】查找所有带有messageId的容器，包括撤回消息
            const allContainers = document.querySelectorAll('[data-message-id]');
            
            allContainers.forEach(container => {
                const messageId = container.dataset.messageId;
                if (messageId) {
                    if (selectedMessages.has(messageId)) {
                        container.classList.add('selected');
                    } else {
                        container.classList.remove('selected');
                    }
                }
            });
            
            // 更新选择计数显示
            const countElement = document.getElementById('selection-count');
            if (countElement) {
                countElement.textContent = `已选 ${selectedMessages.size} 条`;
            }
        }
        
        // 删除选中的消息
        function deleteSelectedMessages() {
            if (selectedMessages.size === 0) return;
            
            if (!currentChatCharacter) return;
            
            if (confirm(`确定要删除选中的 ${selectedMessages.size} 条消息吗？此操作不可恢复！`)) {
                const characterId = currentChatCharacter.id;
                
                if (chatMessages[characterId]) {
                    // 🔥【修复】过滤掉选中的消息，同时删除相关的撤回提示
                    const messagesToDelete = new Set(selectedMessages);
                    
                    // 查找所有要删除的消息内容，用于匹配相关的撤回提示
                    const deleteContentSet = new Set();
                    chatMessages[characterId].forEach(message => {
                        if (selectedMessages.has(message.id) && message.content) {
                            deleteContentSet.add(message.content);
                        }
                    });
                    
                    // 过滤消息：删除选中消息 + 相关的撤回提示
                    chatMessages[characterId] = chatMessages[characterId].filter(message => {
                        // 删除选中的消息
                        if (selectedMessages.has(message.id)) {
                            return false;
                        }
                        
                        // 删除相关的撤回提示（系统消息类型，且原文匹配要删除的消息）
                        if (message.sender === 'system' && message.type === 'recalled_message' && message.originalContent) {
                            if (deleteContentSet.has(message.originalContent)) {
                                console.log('删除相关的撤回提示:', message.content);
                                return false;
                            }
                        }
                        
                        return true;
                    });
                    
                    saveChatMessages();
                    renderChatMessages(characterId);
                    renderMessageList(); // 更新消息列表
                }
                
                // 退出选择模式
                exitMessageSelectionMode();
            }
        }

        // 悬浮按钮功能
        // 变量控制等待回复状态
        let isWaitingForReply = false;
        let pendingUserMessage = null;

      // 用这段新代码，完整替换掉旧的 regenerateLastResponse 函数
        async function regenerateLastResponse() {
            if (!currentChatCharacter) {
                alert('请先选择一个角色');
                return;
            }

            const characterId = currentChatCharacter.id;
            const messages = chatMessages[characterId] || [];
            
            // 找到最后一条AI消息及其对应的用户消息
            let lastAiMessageIndex = -1;
            let lastUserMessageIndex = -1;
            
            for (let i = messages.length - 1; i >= 0; i--) {
                if (messages[i].sender === 'received' && lastAiMessageIndex === -1) {
                    lastAiMessageIndex = i;
                }
                if (lastAiMessageIndex !== -1 && messages[i].sender === 'sent' && lastUserMessageIndex === -1) {
                    lastUserMessageIndex = i;
                    break;
                }
            }
            
            if (lastAiMessageIndex === -1) {
                alert('没有找到AI回复可以重新生成');
                return;
            }
            
            if (lastUserMessageIndex === -1) {
                alert('没有找到对应的用户消息');
                return;
            }

            const userMessage = messages[lastUserMessageIndex];
            
            // 删除从最后一条用户消息后的所有AI消息
            chatMessages[characterId] = messages.slice(0, lastUserMessageIndex + 1);
    await saveChatMessages(); // 使用 await 确保保存完成
            renderChatMessages(characterId);
            
            showTypingIndicator();
            
            const delay = Math.random() * 2000 + 1000;
            await new Promise(resolve => setTimeout(resolve, delay));
            
            try {
                let response;
                
                // 🔥【核心修复】使用新的多模态处理逻辑
                if (Array.isArray(userMessage.content)) {
                    // 这是多模态消息（图文）
                    response = await callChatAPI(userMessage.content, currentChatCharacter);
                } else if (userMessage.image) {
                    // 兼容旧的图片消息格式
                    const messageContent = [
                        { type: 'text', text: userMessage.content || "" },
                        { type: 'image_url', image_url: { url: userMessage.image } }
                    ];
                    response = await callChatAPI(messageContent, currentChatCharacter);
                    } else {
                    // 普通文本消息
                    response = await callChatAPI(userMessage.content, currentChatCharacter);
                }
                const aiMessages = parseAiResponse(response);
                
                hideTypingIndicator();
                
                for (let i = 0; i < aiMessages.length; i++) {
                    const msgData = aiMessages[i];
                    let aiMessage;
                    
            if (typeof msgData === 'object' && msgData !== null) {
                if (msgData.type === 'voice_message') {
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', type: 'voice_message', content: msgData.content, timestamp: Date.now() + i * 100 };
                } else if (msgData.type === 'ai_image') {
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', type: 'ai_image', content: '', image: `data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="200" height="150" viewBox="0 0 200 150"><rect width="200" height="150" fill="#f0f0f0"/><text x="100" y="75" text-anchor="middle" font-family="Arial" font-size="12" fill="#666">[AI描述的图片]</text></svg>')}`, imageDescription: msgData.description, timestamp: Date.now() + i * 100 };
                } else if (msgData.type === 'transfer') {
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', type: 'transfer', amount: msgData.amount, note: msgData.note, timestamp: Date.now() + i * 100 };
                } else if (msgData.type === 'emoji') {
                    const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.description);
                    if (matchingEmoji) {
                        aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '', image: matchingEmoji.url, isEmoji: true, emojiDescription: matchingEmoji.description, timestamp: Date.now() + i * 100 };
                        addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                    } else {
                        aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: `[表情包"${msgData.description}"不存在]`, timestamp: Date.now() + i * 100 };
                    }
                } else if (msgData.type === 'change_avatar') {
                        if (msgData.avatar_url) {
                            const isValidAvatar = await validateAvatarSource(msgData.avatar_url);
                            if (isValidAvatar) {
                                const success = await changeCharacterAvatarByAI(msgData.avatar_url, msgData.reason || '心情变化');
                            if (success) continue; 
                            else aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[头像更换失败]', timestamp: Date.now() + i * 100 };
                                } else {
                            aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[无效的头像来源，头像更换失败]', timestamp: Date.now() + i * 100 };
                                }
                            } else {
                        continue;
                    }
                } else if (msgData.name && msgData.message) {
                    // 这是群聊的特殊格式
                    let senderId = null;
                    if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                        const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                        if (member) senderId = member.id;
                    }

                    // --- 关键修复：检查群聊消息内容是否为特殊类型 ---
                    if (typeof msgData.message === 'object' && msgData.message.type === 'voice_message') {
                        // 如果消息内容是一个语音消息对象
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'voice_message', // 在外层消息上设置正确的类型
                            name: msgData.name,
                            senderId: senderId,
                            content: msgData.message.content, // 提取真正的语音文字内容
                            timestamp: Date.now() + i * 100
                        };
                    } else {
                        // 对于普通的文本消息
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            name: msgData.name,
                            senderId: senderId,
                            content: msgData.message, // 内容本身是字符串
                            timestamp: Date.now() + i * 100
                        };
                    }
                    // --- 修复结束 ---
                        } else {
                    const displayContent = msgData.content || msgData.message || msgData.text || msgData.reply || JSON.stringify(msgData);
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: displayContent, timestamp: Date.now() + i * 100 };
                        }
                                            } else {
                aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: String(msgData), timestamp: Date.now() + i * 100 };
                    }
                    
                    chatMessages[characterId].push(aiMessage);
            await saveChatMessages();
                    renderChatMessages(characterId);
                    
                    if (i < aiMessages.length - 1) {
                        const delay = Math.random() * 1000 + 500;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        if (i < aiMessages.length - 1) {
                            showTypingIndicator();
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));
                            hideTypingIndicator();
                        }
                    }
                }
            } catch (error) {
                console.error('重新生成失败:', error);
                hideTypingIndicator();
                const errorMessage = {
                    id: Date.now().toString(),
                    sender: 'received',
                    content: `[重新生成失败: ${error.message}]`,
                    timestamp: Date.now()
                };
                chatMessages[characterId].push(errorMessage);
        await saveChatMessages();
                renderChatMessages(characterId);
            }
            
            updateFloatingButtonsVisibility();
        }

        // 智能回复功能
        function triggerSmartReply() {
            if (!currentChatCharacter) {
                alert('请先选择一个角色');
                return;
            }

            if (isWaitingForReply) {
                // 🔥【修复】不使用弹窗，改为显示按钮状态提示
                return;
            }

            const messages = chatMessages[currentChatCharacter.id] || [];
            
            // 找到最后一条用户消息
            let lastUserMessage = null;
            let hasUnrepliedUserMessage = false;
            
            for (let i = messages.length - 1; i >= 0; i--) {
                if (messages[i].sender === 'sent') {
                    lastUserMessage = messages[i];
                    
                    // 检查这条用户消息后是否有AI回复
                    hasUnrepliedUserMessage = true;
                    for (let j = i + 1; j < messages.length; j++) {
                        if (messages[j].sender === 'received') {
                            hasUnrepliedUserMessage = false;
                            break;
                        }
                    }
                    break;
                }
            }
            
            // 情况1：有未回复的用户消息
            if (lastUserMessage && hasUnrepliedUserMessage) {
                pendingUserMessage = lastUserMessage;
            processAIReply();
                return;
            }
            
            // 情况2：最后的用户消息已有AI回复，需要AI续写
            if (lastUserMessage && !hasUnrepliedUserMessage) {
                // 检查从最后一条用户消息后的AI回复轮数
                let aiReplyRounds = 0;
                let lastUserMessageIndex = -1;
                
                // 找到最后一条用户消息的索引
                for (let i = messages.length - 1; i >= 0; i--) {
                    if (messages[i].sender === 'sent') {
                        lastUserMessageIndex = i;
                        break;
                    }
                }
                
                // 计算从最后一条用户消息后的AI回复轮数
                // 一轮 = 连续的AI消息直到下一个断点
                if (lastUserMessageIndex !== -1) {
                    let inAIReplyRound = false;
                    
                    for (let i = lastUserMessageIndex + 1; i < messages.length; i++) {
                        if (messages[i].sender === 'received') {
                            if (!inAIReplyRound) {
                                // 开始新的AI回复轮
                                aiReplyRounds++;
                                inAIReplyRound = true;
                            }
                            // 继续当前回合（多条连续AI消息算一轮）
                        } else {
                            // 如果有其他类型消息，结束当前回合
                            inAIReplyRound = false;
                        }
                    }
                }
                
                // AI回复逻辑：
                // aiReplyRounds = 0: 没有回复用户消息，不应该到这里
                // aiReplyRounds = 1: 已回复用户消息1轮，现在是第1次续写（第2轮）
                // aiReplyRounds = 2: 已回复+续写1轮，现在是第2次续写（第3轮）
                // aiReplyRounds >= 3: 已回复+续写2轮，提示用户发消息
                
                if (aiReplyRounds >= 3) {
                    const characterName = currentChatCharacter.name;
                    alert(`${characterName}已经说了很多话了，先和${characterName}说说话吧~`);
                    return;
                }
                
                // AI续写对话（第1次或第2次续写）
                processAIContinuation();
                return;
            }
            
            // 情况3：没有用户消息
            alert('请先发送一条消息，然后点击此按钮来获取AI回复');
        }

        // 处理AI续写对话
        async function processAIContinuation() {
            if (!currentChatCharacter) return;

            isWaitingForReply = true;
            
            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.disabled = true;
                smartReplyBtn.style.opacity = '0.65';
                smartReplyBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            }

            // 显示正在输入提示
            showTypingIndicator();
            
            // 添加随机延迟
            const delay = Math.random() * 2000 + 1000;
            await new Promise(resolve => setTimeout(resolve, delay));

            try {
                // 获取AI最后的消息内容，以便基于此续写
                const messages = chatMessages[currentChatCharacter.id] || [];
                let lastAIMessage = "";
                
                // 找到最后一条AI消息
                for (let i = messages.length - 1; i >= 0; i--) {
                    if (messages[i].sender === 'received') {
                        lastAIMessage = messages[i].content || "";
                        break;
                    }
                }
                
                // 构建续写提示词，基于AI自己最后的话来续写
                let continuationPrompt = "你刚才说了：\"" + lastAIMessage + "\"\n\n";
                continuationPrompt += "现在请基于你刚才说的话，主动继续这个话题或者自然地转到相关话题。就像真实聊天中，你想要继续表达更多想法，或者询问对方的看法，或者分享相关的内容。请自然地继续对话，不要重复之前说过的话。";
                continuationPrompt += "\n\n🚨 重要提醒：请严格遵守JSON格式，每条消息必须分开发送，绝对不能将多条消息合并在一个元素中！正确格式：[\"消息1\", \"消息2\"]，错误格式：[\"消息1\\n消息2\"]";
                
                const response = await callChatAPI(continuationPrompt, currentChatCharacter);
                const aiMessages = parseAiResponse(response);
                
                hideTypingIndicator();
                
                // 逐条发送消息
                for (let i = 0; i < aiMessages.length; i++) {
                    const msgData = aiMessages[i];
                    let aiMessage;
                    
                    if (typeof msgData === 'object' && msgData.type === 'voice_message') {
                        aiMessage = { 
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'voice_message', 
                            content: msgData.content, 
                            timestamp: Date.now() + i * 100
                        };
                    } else if (typeof msgData === 'object' && msgData.type === 'ai_image') {
                        aiMessage = { 
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'ai_image', 
                            content: '',
                            image: `data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="200" height="150" viewBox="0 0 200 150"><rect width="200" height="150" fill="#f0f0f0"/><text x="100" y="75" text-anchor="middle" font-family="Arial" font-size="12" fill="#666">[AI描述的图片]</text></svg>')}`,
                            imageDescription: msgData.description,
                            timestamp: Date.now() + i * 100
                        };
                    } else if (typeof msgData === 'object' && msgData.type === 'transfer') {
                        aiMessage = { 
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'transfer', 
                            amount: msgData.amount, 
                            note: msgData.note, 
                            timestamp: Date.now() + i * 100
                        };
                    } else if (typeof msgData === 'object' && msgData.type === 'emoji') {
                        // 处理AI发送的表情包 - 从本地表情包库中查找
                        const matchingEmoji = customEmojis.find(emoji => 
                            emoji.description === msgData.description
                        );
                        
                        if (matchingEmoji) {
                            aiMessage = { 
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                content: '',
                                image: matchingEmoji.url,
                                isEmoji: true,
                                emojiDescription: matchingEmoji.description,
                                timestamp: Date.now() + i * 100
                            };
                            
                            // 将表情包添加到最近使用
                            addToRecentEmojis({
                                id: matchingEmoji.id,
                                url: matchingEmoji.url,
                                description: matchingEmoji.description
                            });
                        } else {
                            // 如果找不到表情包，显示错误信息
                            aiMessage = { 
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                content: `[表情包"${msgData.description}"不存在]`,
                                timestamp: Date.now() + i * 100
                            };
                        }
                    } else if (typeof msgData === 'object' && msgData.type === 'change_avatar') {
                        // 🔥【新增】处理头像更换对象
                        console.log('处理头像更换消息(续写):', msgData);
                        if (msgData.avatar_url) {
                            // 验证头像URL是否来自用户发送的图片或世界书中的URL
                            const isValidAvatar = await validateAvatarSource(msgData.avatar_url);
                            console.log('头像来源验证结果(续写):', isValidAvatar, '头像URL:', msgData.avatar_url);
                            
                            if (isValidAvatar) {
                                // 执行头像更换
                                const success = await changeCharacterAvatarByAI(msgData.avatar_url, msgData.reason || '心情变化');
                                console.log('头像更换执行结果(续写):', success);
                                if (success) {
                                    // 跳过这条消息，只执行头像更换，系统消息已在changeCharacterAvatarByAI中添加
                                    continue;
                                } else {
                                    aiMessage = { 
                                        id: (Date.now() + i).toString(),
                                        sender: 'received',
                                        content: '[头像更换失败]', 
                                        timestamp: Date.now() + i * 100
                                    };
                                }
                            } else {
                                aiMessage = { 
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    content: '[无效的头像来源，头像更换失败]', 
                                    timestamp: Date.now() + i * 100
                                };
                            }
                        } else {
                            console.log('头像更换消息缺少avatar_url(续写)');
                            continue; // 如果没有有效的头像URL，跳过此消息
                        }
                    } else if (typeof msgData === 'object' && msgData !== null && msgData.name && msgData.message) {
                        // 🔥【群聊消息关键修复】群聊消息格式: {name: "角色名", message: "消息内容"}
                        console.log('🔥 [修复continuation] 发现群聊消息:', msgData);
                        
                        // 查找群成员ID
                        let senderId = null;
                        if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                            const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                            if (member) {
                                senderId = member.id;
                            }
                        }
                        
                        // --- 关键修复：检查群聊消息内容是否为特殊类型 ---
                        if (typeof msgData.message === 'object' && msgData.message.type === 'voice_message') {
                            // 如果消息内容是一个语音消息对象
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                type: 'voice_message', // 在外层消息上设置正确的类型
                                name: msgData.name,
                                senderId: senderId,
                                content: msgData.message.content, // 提取真正的语音文字内容
                                timestamp: Date.now() + i * 100
                            };
                        } else {
                            // 对于普通的文本消息
                        aiMessage = { 
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            name: msgData.name,          // 保存发言者名字
                            senderId: senderId,          // 保存发言者ID
                            content: msgData.message,    // 使用message字段作为内容
                            timestamp: Date.now() + i * 100
                        };
                        }
                        // --- 修复结束 ---
                        console.log('✅ [修复continuation] 群聊消息已正确解析:', aiMessage);
                                            } else {
                        aiMessage = { 
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: String(msgData), 
                            timestamp: Date.now() + i * 100
                        };
                    }
                    
                    chatMessages[currentChatCharacter.id].push(aiMessage);
                    saveChatMessages();
                    addMessageWithAnimation(aiMessage, currentChatCharacter.id);
                    
                    if (i < aiMessages.length - 1) {
                        const delay = Math.random() * 1000 + 500;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        
                        if (i < aiMessages.length - 1) {
                            showTypingIndicator();
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));
                            hideTypingIndicator();
                        }
                    }
                }
            } catch (error) {
                console.error('AI续写失败:', error);
                hideTypingIndicator();
                
                const errorMessage = {
                    id: Date.now().toString(),
                    sender: 'received',
                    content: `[续写失败: ${error.message}]`,
                    timestamp: Date.now()
                };
                
                chatMessages[currentChatCharacter.id].push(errorMessage);
                saveChatMessages();
                addMessageWithAnimation(errorMessage, currentChatCharacter.id);
            } finally {
                // 重置状态
                isWaitingForReply = false;
                pendingUserMessage = null;
                
                // 恢复智能回复按钮
                if (smartReplyBtn) {
                    smartReplyBtn.disabled = false;
                    smartReplyBtn.style.opacity = '';
                    smartReplyBtn.style.animation = 'none';
                    smartReplyBtn.classList.remove('waiting');
                    smartReplyBtn.innerHTML = '<i class="fas fa-comment-dots"></i>';
                    smartReplyBtn.title = '获取AI回复';
                }
                
                // 更新按钮显示状态
                updateFloatingButtonsVisibility();
            }
        }

        // 处理AI回复
        async function processAIReply() {
            if (!currentChatCharacter) return;
            
            // 智能选择最佳的用户消息（优先图片消息）
            const messages = chatMessages[currentChatCharacter.id] || [];
            const userMessages = messages.filter(msg => msg.sender === 'sent');
            
            // 优先查找最近的包含图片的消息（5条消息内）
            const recentMessages = userMessages.slice(-5);
            const imageMessage = recentMessages.reverse().find(msg => 
                Array.isArray(msg.content) || msg.image
            );
            
            if (imageMessage) {
                pendingUserMessage = imageMessage;
            } else if (!pendingUserMessage) {
                // 如果没有图片消息且没有待回复消息，使用最后一条用户消息
                const lastUserMessage = userMessages.pop();
                if (lastUserMessage) {
                    pendingUserMessage = lastUserMessage;
                } else {
                    return;
                }
            }

            isWaitingForReply = true;
            
            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.disabled = true;
                smartReplyBtn.style.opacity = '0.65';
                smartReplyBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            }

            // 显示正在输入提示
            showTypingIndicator();
            
            // 添加随机延迟
            const delay = Math.random() * 2000 + 1000;
            await new Promise(resolve => setTimeout(resolve, delay));

            try {
                // 调用API，支持图片和表情包
                const transferMessages = []; // 移到外层作用域
                
                // 🔥【核心修复】正确处理多模态消息
                let response;
                

                
                // 核心修复：直接将 pendingUserMessage.content (可能是数组) 传递给 callChatAPI
                if (Array.isArray(pendingUserMessage.content)) {
                    // 这是多模态消息（图文）
                    response = await callChatAPI(pendingUserMessage.content, currentChatCharacter);
                } else if (pendingUserMessage.image) {
                    // 兼容旧的图片消息格式
                    const messageContent = [
                        { type: 'text', text: pendingUserMessage.content || "" },
                        { type: 'image_url', image_url: { url: pendingUserMessage.image } }
                    ];
                    response = await callChatAPI(messageContent, currentChatCharacter);
                        } else {
                    // 普通文本消息、位置消息、语音消息等
                    response = await callChatAPI(pendingUserMessage.content, currentChatCharacter);
                }
                
                const aiMessages = parseAiResponse(response);
                
                // 处理所有转账消息
                if (transferMessages.length > 0) {
                    for (const transferMsg of transferMessages) {
                        await processUserTransfer(transferMsg, aiMessages);
                    }
                }
                
// --- 请用这段全新的代码替换 ---
                hideTypingIndicator();
                
                for (let i = 0; i < aiMessages.length; i++) {
                    const msgData = aiMessages[i];
    let aiMessage; // 先声明变量

    if (typeof msgData === 'object' && msgData !== null) {
        if (msgData.type === 'voice_message') {
            aiMessage = { id: (Date.now() + i).toString(), sender: 'received', type: 'voice_message', content: msgData.content, timestamp: Date.now() + i * 100 };
        } else if (msgData.type === 'ai_image') {
            aiMessage = { id: (Date.now() + i).toString(), sender: 'received', type: 'ai_image', content: '', image: `data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="200" height="150" viewBox="0 0 200 150"><rect width="200" height="150" fill="#f0f0f0"/><text x="100" y="75" text-anchor="middle" font-family="Arial" font-size="12" fill="#666">[AI描述的图片]</text></svg>')}`, imageDescription: msgData.description, timestamp: Date.now() + i * 100 };
        } else if (msgData.type === 'transfer') {
            aiMessage = { id: (Date.now() + i).toString(), sender: 'received', type: 'transfer', amount: msgData.amount, note: msgData.note, timestamp: Date.now() + i * 100 };
        } else if (msgData.type === 'emoji') {
            const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.description);
                        if (matchingEmoji) {
                aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '', image: matchingEmoji.url, isEmoji: true, emojiDescription: matchingEmoji.description, timestamp: Date.now() + i * 100 };
                addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                        } else {
                aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: `[表情包"${msgData.description}"不存在]`, timestamp: Date.now() + i * 100 };
            }
        } else if (msgData.type === 'change_avatar') {
                        if (msgData.avatar_url) {
                            const isValidAvatar = await validateAvatarSource(msgData.avatar_url);
                            if (isValidAvatar) {
                                const success = await changeCharacterAvatarByAI(msgData.avatar_url, msgData.reason || '心情变化');
                    if (success) continue; 
                    else aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[头像更换失败]', timestamp: Date.now() + i * 100 };
                                } else {
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[无效的头像来源，头像更换失败]', timestamp: Date.now() + i * 100 };
                                }
                            } else {
                continue;
            }
        } else if (msgData.name && msgData.message) {
            // 这是群聊的特殊格式
            let senderId = null;
            if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                if (member) senderId = member.id;
            }

            // --- 关键修复：检查群聊消息内容是否为特殊类型 ---
            if (typeof msgData.message === 'object' && msgData.message.type === 'voice_message') {
                // 如果消息内容是一个语音消息对象
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    type: 'voice_message', // 在外层消息上设置正确的类型
                    name: msgData.name,
                    senderId: senderId,
                    content: msgData.message.content, // 提取真正的语音文字内容
                    timestamp: Date.now() + i * 100
                };
            } else {
                // 对于普通的文本消息
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    name: msgData.name,
                    senderId: senderId,
                    content: msgData.message, // 内容本身是字符串
                    timestamp: Date.now() + i * 100
                };
            }
            // --- 修复结束 ---
                    } else {
            // 其他所有未知对象的处理
            const displayContent = msgData.content || msgData.message || msgData.text || msgData.reply || JSON.stringify(msgData);
            aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: displayContent, timestamp: Date.now() + i * 100 };
                            }
                        } else {
                            // 普通字符串
        aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: String(msgData), timestamp: Date.now() + i * 100 };
                    }
                    
                    chatMessages[currentChatCharacter.id].push(aiMessage);
    await saveChatMessages();
                    addMessageWithAnimation(aiMessage, currentChatCharacter.id);
                    
                    if (i < aiMessages.length - 1) {
                        const delay = Math.random() * 1000 + 500;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        if (i < aiMessages.length - 1) {
                            showTypingIndicator();
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));
                            hideTypingIndicator();
                        }
                    }
                }
            } catch (error) {
                console.error('AI回复失败:', error);
                hideTypingIndicator();
                
                const errorMessage = {
                    id: Date.now().toString(),
                    sender: 'received',
                    content: `[回复失败: ${error.message}]`,
                    timestamp: Date.now()
                };
                
                chatMessages[currentChatCharacter.id].push(errorMessage);
                saveChatMessages();
                addMessageWithAnimation(errorMessage, currentChatCharacter.id);
            } finally {
                // 重置状态
                isWaitingForReply = false;
                pendingUserMessage = null;
                
                // 恢复智能回复按钮
                if (smartReplyBtn) {
                    smartReplyBtn.disabled = false;
                    smartReplyBtn.style.opacity = '';
                    smartReplyBtn.style.animation = 'none';
                    smartReplyBtn.classList.remove('waiting');
                    smartReplyBtn.innerHTML = '<i class="fas fa-comment-dots"></i>';
                    smartReplyBtn.title = '获取AI回复';
                }
                
                // 更新按钮显示状态
                updateFloatingButtonsVisibility();
            }
        }

        // 重置悬浮按钮状态
        function resetFloatingButtonsState() {
            // 重置待回复消息
            pendingUserMessage = null;
            isWaitingForReply = false;
            
            // 重置智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.disabled = false;
                smartReplyBtn.style.opacity = '';
                smartReplyBtn.style.animation = 'none';
                smartReplyBtn.innerHTML = '<i class="fas fa-comment-dots"></i>';
                smartReplyBtn.title = '获取AI回复';
                smartReplyBtn.classList.remove('waiting');
            }
            
            // 更新按钮显示状态
            updateFloatingButtonsVisibility();
        }

        // 更新悬浮按钮的显示状态
        function updateFloatingButtonsVisibility() {
            if (!currentChatCharacter) return;
            
            const regenerateBtn = document.getElementById('regenerate-btn');
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            const messages = chatMessages[currentChatCharacter.id] || [];
            
            // 检查是否有AI消息可以重新生成
            const hasAIMessages = messages.some(msg => msg.sender === 'received');
            
            if (regenerateBtn) {
                if (hasAIMessages) {
                    regenerateBtn.classList.remove('hidden');
                } else {
                    regenerateBtn.classList.add('hidden');
                }
            }
            
            if (smartReplyBtn) {
                // 智能回复按钮总是显示
                smartReplyBtn.classList.remove('hidden');
            }
        }

        // 修改原来的sendApiMessage函数，使其只发送消息到界面，不触发AI回复
        async function sendApiMessage() {
            const input = document.getElementById('api-chat-input');
            const message = input.value.trim();
            
            if (!message) return;
            
            if (!currentChatCharacter) {
                alert('请先选择一个角色');
                return;
            }


            
            // 添加用户消息
            const messageId = Date.now().toString();
            const userMessage = {
                id: messageId,
                sender: 'sent',
                content: message,
                timestamp: Date.now()
            };
            
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            
            chatMessages[currentChatCharacter.id].push(userMessage);
            saveChatMessages();
            
            // 清空输入框
            input.value = '';
            
            // 使用动画添加消息而不是重新渲染整个列表
            addMessageWithAnimation(userMessage, currentChatCharacter.id);
            
            // 设置待回复消息
            pendingUserMessage = userMessage;
            
            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = '点击获取AI回复';
            }
        }

        // 语音录音相关变量
        let isRecording = false;
        let recordingStartTime = 0;

        // 处理语音录音
        async function handleVoiceRecording() {
            if (!currentChatCharacter) {
                alert('请先选择一个角色');
                return;
            }

            const recordBtn = document.getElementById('voice-record-btn');
            
            if (!isRecording) {
                // 开始录音 - 这里模拟录音过程，实际上弹出输入框
                isRecording = true;
                recordingStartTime = Date.now();
                recordBtn.classList.add('recording');
                recordBtn.innerHTML = '<i class="fas fa-stop"></i>';
                recordBtn.title = '点击停止录音';
                
                // 模拟录音转文字功能
                try {
                    const voiceText = await showVoiceInputDialog();
                    if (voiceText && voiceText.trim()) {
                        sendVoiceMessage(voiceText.trim());
                        console.log('语音消息发送成功');
                    }
                } catch (error) {
                    // 只有在真正取消时才显示取消消息
                    if (error.message === '用户取消') {
                        console.log('用户取消了语音输入');
                    } else {
                        console.error('语音消息发送失败:', error);
                    }
                }
                
                // 重置录音状态
                resetRecordingState();
            } else {
                // 停止录音
                resetRecordingState();
            }
        }

        // 重置录音状态
        function resetRecordingState() {
            isRecording = false;
            const recordBtn = document.getElementById('voice-record-btn');
            recordBtn.classList.remove('recording');
            recordBtn.innerHTML = '<i class="fas fa-microphone"></i>';
            recordBtn.title = '语音消息';
        }

        // 显示语音输入对话框
        function showVoiceInputDialog() {
            return new Promise((resolve, reject) => {
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                `;

                const dialog = document.createElement('div');
                dialog.style.cssText = `
                    background: white;
                    border-radius: 12px;
                    padding: 20px;
                    width: 280px;
                    max-width: 90%;
                    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                `;

                dialog.innerHTML = `
                    <div style="text-align: center; margin-bottom: 15px;">
                        <h3 style="margin: 0; color: #333;">语音转文字</h3>
                        <p style="margin: 8px 0 0 0; color: #666; font-size: 14px;">请输入您想说的内容：</p>
                    </div>
                    <textarea id="voice-text-input" placeholder="在这里输入语音内容..." style="
                        width: 100%;
                        height: 80px;
                        border: 1px solid #ddd;
                        border-radius: 8px;
                        padding: 10px;
                        font-size: 14px;
                        resize: none;
                        box-sizing: border-box;
                        outline: none;
                    "></textarea>
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button id="voice-cancel-btn" style="
                            flex: 1;
                            padding: 10px;
                            border: 1px solid #ddd;
                            background: white;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 14px;
                        ">取消</button>
                        <button id="voice-send-btn" style="
                            flex: 1;
                            padding: 10px;
                            border: none;
                            background: #4a84c1;
                            color: white;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 14px;
                        ">发送</button>
                    </div>
                `;

                overlay.appendChild(dialog);
                document.body.appendChild(overlay);

                const textInput = dialog.querySelector('#voice-text-input');
                const cancelBtn = dialog.querySelector('#voice-cancel-btn');
                const sendBtn = dialog.querySelector('#voice-send-btn');

                // 自动聚焦到输入框
                setTimeout(() => textInput.focus(), 100);

                // 取消按钮
                cancelBtn.onclick = () => {
                    document.body.removeChild(overlay);
                    reject(new Error('用户取消'));
                };

                // 发送按钮
                sendBtn.onclick = () => {
                    const text = textInput.value.trim();
                    if (text) {
                        console.log('语音输入对话框：用户点击发送，内容:', text);
                        document.body.removeChild(overlay);
                        resolve(text);
                    } else {
                        console.log('语音输入对话框：内容为空，聚焦输入框');
                        textInput.focus();
                    }
                };

                // 点击遮罩关闭
                overlay.onclick = (e) => {
                    if (e.target === overlay) {
                        document.body.removeChild(overlay);
                        reject(new Error('用户取消'));
                    }
                };

                // 支持回车发送
                textInput.onkeydown = (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        console.log('语音输入框：用户按回车键发送');
                        sendBtn.click();
                    }
                };
            });
        }

                 // 发送语音消息
        function sendVoiceMessage(text) {
            console.log('开始发送语音消息:', text);
            
            const messageId = Date.now().toString();
            const duration = Math.max(1, Math.ceil(text.length / 8)); // 根据文字长度计算"语音"时长
            
            const voiceMessage = {
                id: messageId,
                sender: 'sent',
                type: 'voice',
                content: text,
                duration: duration,
                timestamp: Date.now()
            };

            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }

            chatMessages[currentChatCharacter.id].push(voiceMessage);
            console.log('语音消息已添加到聊天记录');
            
            saveChatMessages();
            console.log('聊天记录已保存');

            // 添加语音消息到界面
            addMessageWithAnimation(voiceMessage, currentChatCharacter.id);
            console.log('语音消息已添加到界面');

            // 设置待回复消息
            pendingUserMessage = voiceMessage;

            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = '点击获取AI回复';
            }
            
            console.log('语音消息发送流程完成');
        }

        // 切换语音文本显示
        function toggleVoiceText(voiceElement) {
            const container = voiceElement.closest('.voice-message-container') || voiceElement.closest('.message-container');
            if (!container) return;

            const textContent = container.querySelector('.voice-text-content');
            if (!textContent) {
                // 如果没有文本容器，创建一个
                const text = voiceElement.getAttribute('data-text');
                if (!text) return;

                const newTextContent = document.createElement('div');
                newTextContent.className = 'voice-text-content';
                newTextContent.textContent = text;
                
                // 根据消息类型决定插入位置
                if (container.classList.contains('voice-message-container')) {
                    container.appendChild(newTextContent);
                } else {
                    // 为旧格式创建语音容器
                    const voiceContainer = document.createElement('div');
                    voiceContainer.className = container.classList.contains('sent') ? 'voice-message-container sent' : 'voice-message-container received';
                    
                    // 移动现有的消息气泡到语音容器中
                    const bubble = container.querySelector('.message-bubble');
                    if (bubble) {
                        container.removeChild(bubble);
                        voiceContainer.appendChild(bubble);
                        voiceContainer.appendChild(newTextContent);
                        container.appendChild(voiceContainer);
                    }
                }
                
                // 显示文本
                setTimeout(() => {
                    newTextContent.classList.add('visible');
                }, 10);
                
                return;
            }

            // 切换文本显示/隐藏
            if (textContent.classList.contains('visible')) {
                textContent.classList.remove('visible');
                setTimeout(() => {
                    textContent.style.display = 'none';
                }, 300);
            } else {
                textContent.style.display = 'block';
                setTimeout(() => {
                    textContent.classList.add('visible');
                }, 10);
            }
        }
        
        // 加载动态
        async function loadMoments() {
            try {
                    const momentsList = document.getElementById('moments-list');
                if (!momentsList) return;
                    
                        // 清空现有的动态
                        momentsList.innerHTML = '';
                        
                // 从数据库加载动态数据
                const momentsData = await db.moments.orderBy('timestamp').reverse().toArray();
                
                if (momentsData.length > 0) {
                    for (const momentData of momentsData) {
                        // 获取点赞数
                        const likesCount = await db.momentLikes.where('momentId').equals(momentData.id).count();
                        
                        // 获取评论数
                        const commentsCount = await db.momentComments.where('momentId').equals(momentData.id).count();
                        
                        // 获取评论列表
                        const comments = await db.momentComments.where('momentId').equals(momentData.id).toArray();
                        comments.sort((a, b) => a.timestamp - b.timestamp); // 按时间戳排序
                        
                            // 验证并处理头像
                            let avatarToUse = null;
                            if (momentData.avatar && isValidAvatarUrl(momentData.avatar)) {
                                avatarToUse = momentData.avatar;
                            } else {
                                avatarToUse = getDefaultAvatar();
                                // 如果数据库中存储的头像无效，更新数据库记录
                                if (momentData.avatar && !isValidAvatarUrl(momentData.avatar)) {
                                    console.log(`清理动态 ${momentData.id} 的无效头像`);
                                    try {
                                        await db.moments.update(momentData.id, { avatar: avatarToUse });
                                    } catch (error) {
                                        console.error('更新动态头像失败:', error);
                                    }
                                }
                            }
                        
                            const momentElement = createMomentElement({
                            id: momentData.id,
                                nickname: momentData.nickname,
                                avatar: avatarToUse,
                                text: momentData.text,
                                images: momentData.images || [],
                                time: momentData.time,
                            timestamp: momentData.timestamp,
                            likes: likesCount,
                            comments: comments
                            });
                            
                            // 添加到动态列表
                            momentsList.appendChild(momentElement);
                            
                            // 更新点赞显示
                        updateMomentLikeDisplay(momentData.id);
                            
                            // 显示已有评论
                        if (comments && comments.length > 0) {
                            comments.forEach(comment => {
                                // 确保评论有time字段，如果没有就从timestamp生成
                                if (!comment.time && comment.timestamp) {
                                    comment.time = formatTime(new Date(comment.timestamp));
                                }
                                displayCommentUnderMoment(momentData.id, comment);
                                });
                            }
                    }
                        
                        console.log('成功加载', momentsData.length, '条动态');
                } else {
                    console.log('没有找到保存的动态数据');
                }
                
                // 启动时间更新
                startTimeUpdater();
            } catch (error) {
                console.error('加载动态失败:', error);
            }
        }
        
        // 发布动态相关变量
        let momentImages = [];
        
        // 显示发布动态界面
        function showPublishMoment() {
            showApp('publish-moment-screen');
            // 重置表单
            document.getElementById('moment-text').value = '';
            momentImages = [];
            updateMomentImagesGrid();
            
            // 重置发布按钮状态
            const publishBtn = document.querySelector('.publish-btn');
            if (publishBtn) {
                publishBtn.disabled = false;
                publishBtn.textContent = '发表';
            }
        }
        
        // 隐藏发布动态界面
        function hidePublishMoment() {
            showApp('chat-screen');
                                    // 切换回动态标签
            switchChatTab('moments-page');
            // 不需要重新加载，动态已经在数据库中
        }
        
        // 添加图片到动态
        function addMomentImage() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.multiple = true;
            input.onchange = function(event) {
                const files = Array.from(event.target.files);
                files.forEach(file => {
                    if (momentImages.length < 9) { // 最多9张图片
                        const reader = new FileReader();
                        reader.onload = async function(e) {
                            try {
                                // 压缩图片
                                const compressedImage = await compressImage(e.target.result, 800, 0.8);
                                momentImages.push(compressedImage);
                                updateMomentImagesGrid();
                            } catch (error) {
                                showToast("图片处理失败，请重试");                                console.error("压缩图片失败:", error);
                            }
                        };
                        reader.readAsDataURL(file);
                    }
                });
            };
            input.click();
        }
        
        // 删除图片
        function removeMomentImage(index) {
            momentImages.splice(index, 1);
            updateMomentImagesGrid();
        }
        
        // 更新图片网格显示
        function updateMomentImagesGrid() {
            const grid = document.getElementById('moment-images-grid');
            grid.innerHTML = '';
            
            momentImages.forEach((imageData, index) => {
                const imageItem = document.createElement('div');
                imageItem.className = 'moment-image-item';
                imageItem.innerHTML = `
                    <img src="${imageData}" alt="动态图片">
                    <button class="remove-image-btn" onclick="removeMomentImage(${index})">×</button>
                `;
                grid.appendChild(imageItem);
            });
        }
        
        // 发布动态
        
        // 获取默认头像
        function getDefaultAvatar() {
            // 尝试获取动态头像，但要验证其有效性
            const momentsAvatar = getMomentsImage("avatarImage");
            if (momentsAvatar && isValidAvatarUrl(momentsAvatar)) {
                return momentsAvatar;
            }
            
            // 尝试获取用户头像，但要验证其有效性
            if (window.userAvatar && isValidAvatarUrl(window.userAvatar)) {
                return window.userAvatar;
            }
            
            // 清理无效的用户头像数据
            if (window.userAvatar && !isValidAvatarUrl(window.userAvatar)) {
                console.log('清理无效的用户头像数据');
                window.userAvatar = null;
            }
            
            // 清理无效的动态头像数据
            if (momentsAvatar && !isValidAvatarUrl(momentsAvatar)) {
                console.log('清理无效的动态头像数据');
                // 这里需要调用清理函数，但由于getMomentsImage的存储机制，我们先跳过
            }
            
            // 返回默认头像（使用CSS生成的简单头像）
            return "data:image/svg+xml;base64," + btoa(`<svg width="50" height="50" xmlns="http://www.w3.org/2000/svg"><rect width="50" height="50" fill="#f0f0f0"/><circle cx="25" cy="20" r="8" fill="#999"/><circle cx="25" cy="40" r="12" fill="#999"/></svg>`);
        }        async function publishMoment() {
            const text = document.getElementById('moment-text').value.trim();
            const publishBtn = document.querySelector('.publish-btn');
            
            if (!text && momentImages.length === 0) {
                showToast('请输入文字或选择图片');
                return;
            }
            
            // 禁用发布按钮，防止重复提交
            publishBtn.disabled = true;
            publishBtn.textContent = '发布中...';
            
            // 获取当前用户昵称
            const nickname = document.getElementById('moments-username')?.textContent || '我';
            
            // 创建新动态
            const now = new Date();
            const newMoment = {
                id: Date.now(),
                authorId: 'user',
                nickname: nickname,
                avatar: getDefaultAvatar(),
                text: text,
                images: [...momentImages],
                time: formatTime(now),
                timestamp: now.getTime()
            };
            
            try {
                // 保存到数据库
                await db.moments.add(newMoment);
                
                // 恢复发布按钮状态
                publishBtn.disabled = false;
                publishBtn.textContent = '发表';
                
                // 显示成功提示
                showToast('发布成功！');
                
                // 清空表单
                document.getElementById('moment-text').value = '';
                momentImages = [];
                updateMomentImagesGrid();
                
                // 返回动态页面
                    hidePublishMoment();
                
                // 直接添加到动态列表（避免重新加载整个列表）
                addMomentToList(newMoment);
                
                // 启动时间更新器
                startTimeUpdater();
                
                // 延迟触发AI角色的互动
                setTimeout(() => {
                    triggerAIInteractions(newMoment.id, 'like');
                    triggerAIInteractions(newMoment.id, 'comment');
                }, 1000);
                
            } catch (error) {
                console.error('发布动态失败:', error);
                showToast('发布失败，请重试');
                
                // 恢复发布按钮
                publishBtn.disabled = false;
                publishBtn.textContent = '发表';
            }
        }
        
        // 格式化时间
        function formatTime(date) {
            const now = new Date();
            const diff = now - date;
            
            if (diff < 60000) { // 小于1分钟
                return '刚刚';
            } else if (diff < 3600000) { // 小于1小时
                return Math.floor(diff / 60000) + '分钟前';
            } else if (diff < 86400000) { // 小于1天
                return Math.floor(diff / 3600000) + '小时前';
            } else if (diff < 604800000) { // 小于1周
                return Math.floor(diff / 86400000) + '天前';
            } else {
                return date.toLocaleDateString();
            }
        }
        
        // 添加动态到列表
        function addMomentToList(moment) {
            const momentsList = document.getElementById('moments-list');
            const momentElement = createMomentElement(moment);
            
            // 插入到列表最前面
            if (momentsList.firstChild) {
                momentsList.insertBefore(momentElement, momentsList.firstChild);
            } else {
                momentsList.appendChild(momentElement);
            }
        }
        
        // 创建动态元素
        function createMomentElement(moment) {
            const momentDiv = document.createElement('div');
            momentDiv.className = 'moment-item';
            
            // 设置动态ID和时间戳
            momentDiv.setAttribute('data-moment-id', moment.id);
            if (moment.timestamp) {
                momentDiv.setAttribute('data-timestamp', moment.timestamp);
            }
            
            let imagesHtml = '';
            if (moment.images && moment.images.length > 0) {
                imagesHtml = `
                    <div class="moment-images">
                        ${moment.images.map(img => `<img src="${img}" alt="动态图片" onclick="previewImage('${img}')">`).join('')}
                    </div>
                `;
            }
            // 直接获取角色头像
            let finalAvatar = null;
            if (moment.characterId === 'user') {
                // 用户动态使用默认头像
                finalAvatar = moment.avatar || getDefaultAvatar();
            } else {
                // 角色动态：优先动态头像，然后角色卡头像
                finalAvatar = moment.avatar;
                if (!finalAvatar && moment.characterId) {
                    const character = characters.find(c => c.id === moment.characterId);
                    if (character && character.avatarUrl) {
                        finalAvatar = character.avatarUrl;
                    }
                }
            }
            
            momentDiv.innerHTML = `
                <div class="moment-avatar">
                    ${finalAvatar ? 
                        `<img src="${finalAvatar}" alt="头像" style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px;" onerror="this.style.display='none'; this.parentElement.innerHTML='<div style=\\'width: 40px; height: 40px; background-color: #ddd; border-radius: 8px; display: flex; align-items: center; justify-content: center; color: #666; font-size: 14px;\\'>${moment.nickname ? moment.nickname.charAt(0) : '?'}</div>'">` :
                        `<div style="width: 40px; height: 40px; background-color: #ddd; border-radius: 8px; display: flex; align-items: center; justify-content: center; color: #666; font-size: 14px;">${moment.nickname ? moment.nickname.charAt(0) : '?'}</div>`
                    }
                </div>
                <div class="moment-content">
                    <div class="moment-username">${moment.nickname}</div>
                    <div class="moment-text">${formatMomentText(moment.text)}</div>
                    ${imagesHtml}
                    <div class="moment-time-actions" style="margin-top: 8px; padding: 8px 0; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center;">
                        <div class="moment-time">${moment.time}</div>
                        <div class="moment-actions" style="display: flex;">
                        <button class="moment-action-btn" onclick="toggleMomentLike('${moment.id}')" style="margin-right: 8px;">
                            <i class="far fa-heart"></i>
                            <span>${moment.likes || 0}</span>
                        </button>
                        <button class="moment-action-btn" onclick="showMomentComments('${moment.id}')">
                            <i class="far fa-comment"></i>
                            <span>${moment.comments ? moment.comments.length : 0}</span>
                        </button>
                    </div>
                    </div>
                    <div class="moment-footer" style="display: none;">
                    </div>
                </div>
            `;
            
            // 添加长按监听器
            addLongPressListener(momentDiv, moment.id);
            
            // 异步检查并设置用户点赞状态
            (async () => {
                try {
                    const userLike = await db.momentLikes
                        .where('[momentId+authorId]')
                        .equals([moment.id, 'user'])
                        .first();
                    
                    if (userLike) {
                    const likeBtn = momentDiv.querySelector('.moment-action-btn');
                    const likeIcon = likeBtn.querySelector('i');
                    likeIcon.classList.remove('far');
                    likeIcon.classList.add('fas');
                    likeBtn.classList.add('liked');
                }
                } catch (error) {
                    console.error('检查用户点赞状态失败:', error);
            }
            })();
            
            return momentDiv;
        }
        
        // 预览图片
        function previewImage(imageSrc) {
            // 创建预览遮罩
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.9);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
            `;
            
            const img = document.createElement('img');
            img.src = imageSrc;
            img.style.cssText = `
                max-width: 90%;
                max-height: 90%;
                object-fit: contain;
            `;
            
            overlay.appendChild(img);
            overlay.onclick = () => document.body.removeChild(overlay);
            document.body.appendChild(overlay);
        }
        
        // 注意：saveMomentsData函数已移除，现在使用Dexie数据库直接存储
        // 更新文字计数
        function updateTextCount() {
            const textarea = document.getElementById('moment-text');
            const countElement = document.getElementById('text-count');
            
            if (textarea && countElement) {
                const currentLength = textarea.value.length;
                const maxLength = 500;
                
                countElement.textContent = `${currentLength}/${maxLength}`;
                
                // 当接近限制时改变颜色
                if (currentLength > maxLength * 0.9) {
                    countElement.style.color = '#ff6b6b';
                } else if (currentLength > maxLength * 0.8) {
                    countElement.style.color = '#ffa500';
                } else {
                    countElement.style.color = '#999';
                }
            }
        }
        
        // 显示提示消息
        function showToast(message) {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.8);
                color: white;
                padding: 12px 20px;
                border-radius: 6px;
                z-index: 10000;
                font-size: 14px;
            `;
            toast.textContent = message;
            
            document.body.appendChild(toast);
            setTimeout(() => {
                document.body.removeChild(toast);
            }, 2000);
        }
        
        // 时间更新器
        let timeUpdateInterval = null;
        
        function startTimeUpdater() {
            // 清除已存在的定时器
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
            }
            
            // 立即更新一次
            updateMomentTimes();
            
            // 每分钟更新一次时间显示
            timeUpdateInterval = setInterval(updateMomentTimes, 60000);
        }
        
        function stopTimeUpdater() {
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
                timeUpdateInterval = null;
            }
        }
        
        function updateMomentTimes() {
            try {
                const momentItems = document.querySelectorAll('.moment-item[data-timestamp]');
                
                momentItems.forEach(item => {
                    const timestamp = parseInt(item.getAttribute('data-timestamp'));
                    if (timestamp) {
                        const timeElement = item.querySelector('.moment-time');
                        if (timeElement) {
                            const newTime = formatTime(new Date(timestamp));
                            timeElement.textContent = newTime;
                        }
                    }
                });
            } catch (error) {
                console.error('更新动态时间失败:', error);
            }
        }
        
        // 动态选择模式相关变量
        let isSelectionMode = false;
        let selectedMoments = new Set();
        
        // 切换动态点赞状态
        async function toggleMomentLike(momentId) {
            if (isSelectionMode) return; // 选择模式下不响应点赞
            
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;
            
            const likeBtn = momentElement.querySelector('.moment-action-btn');
            const likeIcon = likeBtn.querySelector('i');
            
            try {
            // 检查用户是否已点赞
                const existingLike = await db.momentLikes
                    .where('[momentId+authorId]')
                    .equals([parseInt(momentId), 'user'])
                    .first();
            
                if (existingLike) {
                // 取消点赞
                likeIcon.classList.remove('fas');
                likeIcon.classList.add('far');
                likeBtn.classList.remove('liked');
                    await db.momentLikes.delete([parseInt(momentId), 'user']);
            } else {
                // 点赞
                likeIcon.classList.add('fas');
                likeIcon.classList.remove('far');
                likeBtn.classList.add('liked');
                    await db.momentLikes.add({
                        momentId: parseInt(momentId),
                        authorId: 'user',
                    characterId: 'user',
                    name: document.getElementById('moments-username')?.textContent || '我',
                    timestamp: Date.now()
                });
                
                // 触发AI角色自动点赞
                triggerAIInteractions(momentId, 'like');
            }
            
            // 更新显示
            updateMomentLikeDisplay(momentId);
            } catch (error) {
                console.error('点赞操作失败:', error);
            }
        }
        
        // 显示动态评论
        function showMomentComments(momentId) {
            if (isSelectionMode) return; // 选择模式下不响应评论
            
            // 显示简单评论输入框
            showSimpleCommentInput(momentId);
            
            // 触发AI角色自动评论
            triggerAIInteractions(momentId, 'comment');
        }
        
        // 显示简单评论输入框
        function showSimpleCommentInput(momentId, replyToNickname = null) {
            // 检查是否已经有输入框
            if (document.querySelector('.simple-comment-input')) {
                closeSimpleCommentInput();
            }
            
            const placeholder = replyToNickname ? `回复 ${replyToNickname}...` : '写评论...';
            
            const input = document.createElement('div');
            input.className = 'simple-comment-input';
            input.innerHTML = `
                <div class="comment-input-container">
                    <input type="text" placeholder="${placeholder}" maxlength="200" id="simple-comment-${momentId}" data-reply-to="${replyToNickname || ''}">
                    <button onclick="submitSimpleComment('${momentId}')">发送</button>
                    <button onclick="closeSimpleCommentInput()" class="cancel-btn">取消</button>
                </div>
            `;
            
            input.style.cssText = `
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                background: white;
                border-top: 1px solid #ddd;
                padding: 12px;
                z-index: 1000;
                box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
                max-width: 360px;
                margin: 0 auto;
            `;
            
            const container = input.querySelector('.comment-input-container');
            container.style.cssText = `
                display: flex;
                gap: 8px;
                align-items: center;
                max-width: 360px;
                margin: 0 auto;
            `;
            
            const textInput = input.querySelector('input');
            textInput.style.cssText = `
                flex: 1;
                padding: 8px 12px;
                border: 1px solid #ddd;
                border-radius: 20px;
                font-size: 14px;
            `;
            
            const sendBtn = input.querySelector('button');
            sendBtn.style.cssText = `
                background: #1da1f2;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 16px;
                font-size: 14px;
                cursor: pointer;
            `;
            
            const cancelBtn = input.querySelector('.cancel-btn');
            cancelBtn.style.cssText = `
                background: #f0f0f0;
                color: #666;
                border: none;
                padding: 8px 16px;
                border-radius: 16px;
                font-size: 14px;
                cursor: pointer;
            `;
            
            document.body.appendChild(input);
            
            // 自动聚焦
            setTimeout(() => textInput.focus(), 100);
            
            // 回车发送
            textInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    submitSimpleComment(momentId);
                }
            });
        }
        
        // 关闭简单评论输入框
        function closeSimpleCommentInput() {
            const input = document.querySelector('.simple-comment-input');
            if (input) {
                document.body.removeChild(input);
            }
        }
        
        // 提交简单评论
        function submitSimpleComment(momentId) {
            const input = document.getElementById(`simple-comment-${momentId}`);
            const text = input.value.trim();
            const replyTo = input.getAttribute('data-reply-to');
            
            if (!text) {
                showToast('请输入评论内容');
                return;
            }
            
            const comment = {
                id: Date.now() + Math.random(),
                nickname: document.getElementById('moments-username')?.textContent || '我',
                avatar: getDefaultAvatar(),
                text: text,
                time: formatTime(new Date()),
                timestamp: Date.now(),
                replyTo: replyTo || null
            };
            
            // 保存评论到动态数据
            saveCommentToMoment(momentId, comment);
            
            // 更新动态列表中的评论数
            updateMomentCommentCount(momentId);
            
            // 在动态下方显示新评论
            displayCommentUnderMoment(momentId, comment);
            
            // 关闭输入框
            closeSimpleCommentInput();
            
            showToast('评论成功！');
            
            // 如果用户回复了某个AI角色，检查轮次并触发该角色的回复
            if (replyTo && replyTo !== '我') {
                const conversationKey = `${momentId}-${replyTo}`;
                const currentRounds = commentConversationRounds.get(conversationKey) || 0;
                
                if (currentRounds < 10) {
                    console.log(`用户回复了 ${replyTo}，当前对话轮次: ${currentRounds}/10，将在2-5秒后触发AI回复`);
                    
                    // 用户回复时也要增加轮次
                    commentConversationRounds.set(conversationKey, currentRounds + 1);
                    console.log(`用户回复后，${replyTo} 在动态 ${momentId} 中的对话轮次更新为: ${currentRounds + 1}/10`);
                    
                setTimeout(() => {
                    console.log(`开始触发 ${replyTo} 回复用户评论: "${text}"`);
                    triggerAIReplyToUser(momentId, replyTo, text);
                }, Math.random() * 3000 + 2000); // 2-5秒后AI回复
                } else {
                    console.log(`${replyTo} 在动态 ${momentId} 中的对话已达到10轮上限，不再回复`);
                }
            } else {
                console.log(`用户发表了评论，replyTo: ${replyTo}`);
                
                // 检查是否是对角色动态的直接评论（不是回复）
                if (!replyTo) {
                    checkAndTriggerCharacterMomentReply(momentId, text);
                }
            }
        }
        
        // 检查并触发角色动态的回复
        async function checkAndTriggerCharacterMomentReply(momentId, userCommentText) {
            try {
                // 获取动态信息
                const moment = await db.moments.get(parseInt(momentId));
                if (!moment || !moment.characterId || moment.characterId === 'user') {
                    console.log('不是角色发布的动态，跳过角色回复');
                    return;
                }
                
                // 获取发布动态的角色
                const character = characters.find(c => c.id === moment.characterId);
                if (!character) {
                    console.log(`未找到动态发布者角色: ${moment.characterId}`);
                    return;
                }
                
                // 检查对话轮次
                const conversationKey = `${momentId}-${character.name}`;
                const currentRounds = commentConversationRounds.get(conversationKey) || 0;
                
                if (currentRounds >= 10) {
                    console.log(`${character.name} 在动态 ${momentId} 中的对话已达到10轮上限，不再回复`);
                    return;
                }
                
                console.log(`用户评论了 ${character.name} 的动态，当前对话轮次: ${currentRounds}/10，将在2-5秒后触发回复`);
                
                // 增加对话轮次
                commentConversationRounds.set(conversationKey, currentRounds + 1);
                console.log(`用户评论后，${character.name} 在动态 ${momentId} 中的对话轮次更新为: ${currentRounds + 1}/10`);
                
                // 延迟回复
                setTimeout(() => {
                    console.log(`开始触发 ${character.name} 回复用户对其动态的评论: "${userCommentText}"`);
                    triggerAIReplyToUser(momentId, character.name, userCommentText);
                }, Math.random() * 3000 + 2000); // 2-5秒后AI回复
                
            } catch (error) {
                console.error('检查角色动态回复失败:', error);
            }
        }
        
        // 在动态下方显示评论
        function displayCommentUnderMoment(momentId, comment) {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;
            
            // 查找或创建评论区域
            let commentsSection = momentElement.querySelector('.moment-comments-section');
            if (!commentsSection) {
                commentsSection = document.createElement('div');
                commentsSection.className = 'moment-comments-section';
                
                // 检查是否已有点赞区域，决定margin-top
                const likesDisplay = momentElement.querySelector('.likes-display');
                const marginTop = likesDisplay ? '0' : '0';
                
                commentsSection.style.cssText = `
                    margin-top: ${marginTop};
                    padding: 8px 12px;
                    background: #f8f9fa;
                    font-size: 13px;
                `;
                
                // 插入到正确位置：点赞区后面（如果有的话），否则在时间操作区后面
                const momentContent = momentElement.querySelector('.moment-content');
                const momentTimeActions = momentElement.querySelector('.moment-time-actions');
                
                if (momentContent && momentTimeActions) {
                if (likesDisplay) {
                        // 如果有点赞区，插入到点赞区后面
                    likesDisplay.parentNode.insertBefore(commentsSection, likesDisplay.nextSibling);
                    } else {
                        // 没有点赞区，插入到时间操作区后面
                    momentTimeActions.parentNode.insertBefore(commentsSection, momentTimeActions.nextSibling);
                    }
                }
            }
            
            // 创建评论元素
            const commentDiv = document.createElement('div');
            commentDiv.className = 'comment-item';
            commentDiv.style.cssText = `
                display: flex;
                gap: 8px;
                margin-bottom: 8px;
                align-items: flex-start;
            `;
            
            // 处理回复格式
            let commentText = comment.text;
            if (comment.replyTo) {
                commentText = `回复<span style="margin: 0 2px; color: #576b95; font-weight: 600;">${comment.replyTo}</span>: ${comment.text}`;
            }
            
            commentDiv.innerHTML = `
                <img src="${comment.avatar}" style="width: 24px; height: 24px; border-radius: 50%; object-fit: cover;">
                <div style="flex: 1; line-height: 1.4; cursor: pointer;" onclick="replyToMomentComment('${momentId}', '${comment.nickname}')">
                    <span style="color: #576b95; font-weight: 600;">${comment.nickname}${comment.replyTo ? '' : '：'}</span><span style="margin-left: 2px; color: #333;">${commentText}</span>
                    <div style="color: #999; font-size: 11px; margin-top: 2px;">${comment.time}</div>
                </div>
            `;
            
            commentsSection.appendChild(commentDiv);
        }
        
        // 回复动态评论
        function replyToMomentComment(momentId, nickname) {
            // 显示评论输入框，并设置为回复模式
            showSimpleCommentInput(momentId, nickname);
        }
        

        
        // 保存评论到动态数据
        async function saveCommentToMoment(momentId, comment) {
            try {
                const commentData = {
                    id: comment.id,
                    momentId: parseInt(momentId),
                    authorId: comment.characterId || 'user',
                    nickname: comment.nickname,
                    avatar: comment.avatar,
                    text: comment.text,
                    timestamp: comment.timestamp,
                    replyTo: comment.replyTo || null
                };
                
                await db.momentComments.add(commentData);
                console.log('评论已保存到数据库，动态ID:', momentId);
            } catch (error) {
                console.error('保存评论失败:', error);
            }
        }
        
        // 更新动态评论数
        async function updateMomentCommentCount(momentId) {
            try {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;
            
                const commentsCount = await db.momentComments.where('momentId').equals(parseInt(momentId)).count();
            
                const commentBtn = momentElement.querySelectorAll('.moment-action-btn')[1];
                const commentCount = commentBtn.querySelector('span');
                commentCount.textContent = commentsCount;
            } catch (error) {
                console.error('更新评论数失败:', error);
            }
        }
        
        // 触发AI角色互动
        async function triggerAIInteractions(momentId, type) {
            try {
            if (!characters || characters.length === 0) return;
            
            // 获取当前动态信息
                const moment = await db.moments.get(parseInt(momentId));
            if (!moment) return;
            
                const publisherCharacterId = moment.characterId;
                
                // 如果是用户发的动态
                if (!publisherCharacterId || publisherCharacterId === 'user') {
                    console.log('用户发布动态，所有角色80%概率互动');
                    // 用户发动态：所有联系人角色都有80%概率互动
            const contactCharacters = characters.filter(char => contacts.includes(char.id));
            
            if (type === 'like') {
                for (const character of contactCharacters) {
                    if (Math.random() < 0.8) {
                                setTimeout(() => {
                                    addAILike(momentId, character, moment);
                                }, Math.random() * 3000 + 1000);
                    }
                }
            } else if (type === 'comment') {
                for (const character of contactCharacters) {
                    if (Math.random() < 0.8) {
                            setTimeout(async () => {
                                await addAIComment(momentId, character, moment);
                                }, Math.random() * 5000 + 2000);
                    }
                }
                    }
                } else {
                    console.log('角色发布动态，只有同群角色50%概率互动');
                    // 角色发动态：只有同群角色有50%概率互动
                    const relatedCharacters = getCharactersInSameGroups(publisherCharacterId);
                
                    if (type === 'like') {
                        for (const character of relatedCharacters) {
                            if (Math.random() < 0.5) {
                    setTimeout(() => {
                                    addAILike(momentId, character, moment);
                                }, Math.random() * 3000 + 1000);
                            }
                        }
                    } else if (type === 'comment') {
                        for (const character of relatedCharacters) {
                            if (Math.random() < 0.5) {
                                setTimeout(async () => {
                                    await addAIComment(momentId, character, moment);
                                }, Math.random() * 5000 + 2000);
                            }
                        }
                        
                        // 触发同群角色间的50%概率互动
                        setTimeout(() => {
                            triggerAiToAiInteraction(momentId, relatedCharacters);
                        }, Math.random() * 8000 + 5000);
                    }
                }
            } catch (error) {
                console.error('触发AI互动失败:', error);
            }
        }
        
        // 获取与指定角色在同一个群聊的其他角色
        function getCharactersInSameGroups(characterId) {
            const sameGroupCharacters = [];
            
            // 遍历所有群聊
            groupChats.forEach(group => {
                if (group.members && group.members.includes(characterId)) {
                    // 找到包含该角色的群聊，获取群内其他角色
                    group.members.forEach(memberId => {
                        if (memberId !== characterId && memberId !== 'user') {
                            const character = characters.find(c => c.id === memberId);
                            if (character && !sameGroupCharacters.find(c => c.id === character.id)) {
                                sameGroupCharacters.push(character);
                            }
                        }
                    });
                }
            });
            
            return sameGroupCharacters;
        }
        
        // AI角色点赞
        async function addAILike(momentId, character, moment) {
            try {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;
            
            // 检查是否已经点赞过
                const existingLike = await db.momentLikes
                    .where('[momentId+authorId]')
                    .equals([parseInt(momentId), character.id])
                    .first();
                
                if (existingLike) return;
            
                // 基于角色人设决定是否真的点赞
                const shouldLike = await shouldCharacterLikeMoment(character, moment);
                if (!shouldLike) {
                    console.log(`${character.name} 基于人设选择不点赞这条动态`);
                    return;
                }
            
            // 添加点赞记录
                await db.momentLikes.add({
                    momentId: parseInt(momentId),
                    authorId: character.id,
                characterId: character.id,
                name: character.name,
                timestamp: Date.now()
            });
            
            // 更新界面显示
            updateMomentLikeDisplay(momentId);
            
            // 显示点赞提示
            showToast(`${character.name} 赞了你的动态`);
            } catch (error) {
                console.error('AI点赞失败:', error);
            }
        }
        
        // 判断角色是否会点赞这条动态
        async function shouldCharacterLikeMoment(character, moment) {
            try {
                // 基于角色人设和动态内容的简单判断
                const characterBio = (character.bio || '').toLowerCase();
                const momentText = (moment.text || '').toLowerCase();
                
                // 如果角色人设中包含负面词汇，降低点赞概率
                const negativeTraits = ['冷漠', '严肃', '不善交际', '内向', '沉默'];
                const hasNegativeTraits = negativeTraits.some(trait => characterBio.includes(trait));
                
                if (hasNegativeTraits && Math.random() < 0.7) {
                    return false; // 70%概率不点赞
                }
                
                // 如果动态内容与角色兴趣相关，增加点赞概率
                const characterInterests = extractInterestsFromBio(characterBio);
                const hasRelatedContent = characterInterests.some(interest => 
                    momentText.includes(interest)
                );
                
                if (hasRelatedContent) {
                    return Math.random() < 0.9; // 90%概率点赞
                }
                
                // 默认情况
                return Math.random() < 0.7; // 70%概率点赞
            } catch (error) {
                console.error('判断角色点赞偏好失败:', error);
                return Math.random() < 0.6; // 默认60%概率
            }
        }
        
        // 从角色人设中提取兴趣关键词
        function extractInterestsFromBio(bio) {
            const interests = [];
            const interestKeywords = [
                '音乐', '电影', '读书', '运动', '游戏', '美食', '旅行', '摄影',
                '绘画', '写作', '代码', '科技', '动漫', '小说', '咖啡', '茶',
                '宠物', '花', '星空', '雨天', '阳光', '学习', '工作', '朋友'
            ];
            
            interestKeywords.forEach(keyword => {
                if (bio.includes(keyword)) {
                    interests.push(keyword);
                }
            });
            
            return interests;
        }
        
        // 更新动态点赞显示
        async function updateMomentLikeDisplay(momentId) {
            try {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;
            
                const momentLikes = await db.momentLikes.where('momentId').equals(parseInt(momentId)).toArray();
            
            // 更新点赞按钮数字
            const likeBtn = momentElement.querySelector('.moment-action-btn[onclick*="toggleMomentLike"]');
            if (likeBtn) {
                const likeCount = likeBtn.querySelector('span');
                if (likeCount) {
                    likeCount.textContent = momentLikes.length;
                }
            }
            
            // 更新或创建点赞用户名称显示
            let likesDisplay = momentElement.querySelector('.likes-display');
            
            if (momentLikes.length > 0) {
                if (!likesDisplay) {
                    likesDisplay = document.createElement('div');
                    likesDisplay.className = 'likes-display';
                    
                    // 检查是否已有评论区域，如果有就不设置margin-top
                        const existingCommentsSection = momentElement.querySelector('.moment-comments-section');
                        const marginTop = existingCommentsSection ? '0' : '0';
                    
                    likesDisplay.style.cssText = `
                        margin-top: ${marginTop};
                        padding: 8px 12px;
                        background: #f8f9fa;
                        font-size: 13px;
                        color: #666;
                        line-height: 1.4;
                    `;
                    
                        // 插入到操作按钮下面，评论区前面（如果有的话），否则在时间操作区后面
                    const momentContent = momentElement.querySelector('.moment-content');
                    const momentTimeActions = momentElement.querySelector('.moment-time-actions');
                        const commentsSection = momentElement.querySelector('.moment-comments-section');
                        
                    if (momentContent && momentTimeActions) {
                            if (commentsSection) {
                                // 如果已有评论区，插入到评论区前面
                                momentContent.insertBefore(likesDisplay, commentsSection);
                            } else {
                                // 没有评论区，插入到时间操作区后面
                        momentTimeActions.parentNode.insertBefore(likesDisplay, momentTimeActions.nextSibling);
                            }
                    }
                }
                
                // 使用和用户昵称相同颜色的空心爱心
                const likeIcon = '<svg width="14" height="14" style="margin-right: 4px; vertical-align: middle;" viewBox="0 0 24 24" fill="none" stroke="#576b95" stroke-width="2"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>';
                const names = momentLikes.map(like => like.name).join('、');
                likesDisplay.innerHTML = `${likeIcon}<span style="color: #576b95; font-weight: 600;">${names}</span>`;
                likesDisplay.style.display = 'block';
            } else if (likesDisplay) {
                likesDisplay.style.display = 'none';
                }
            } catch (error) {
                console.error('更新点赞显示失败:', error);
            }
        }
        
        // AI角色评论
        async function addAIComment(momentId, character, moment) {
            try {
                // 生成符合角色人设的评论
                const comments = await generateCharacterComment(character, moment);
                if (!comments || comments.length === 0) return;
                
                const randomComment = comments[Math.floor(Math.random() * comments.length)];
                
                const comment = {
                    id: Date.now() + Math.random(),
                    nickname: character.name,
                    avatar: character.avatarUrl,
                    text: randomComment,
                    time: formatTime(new Date()),
                    timestamp: Date.now(),
                    characterId: character.id
                };
                
                // 保存评论
                saveCommentToMoment(momentId, comment);
                
                // 更新评论数
                updateMomentCommentCount(momentId);
                
                // 在动态下方显示新评论
                displayCommentUnderMoment(momentId, comment);
                
                // 显示评论提示
                showToast(`${character.name} 评论了你的动态`);
            } catch (error) {
                console.error('AI角色评论失败:', error);
            }
        }
        
        // AI角色间的楼中楼互动（套用完成.html逻辑）
        async function triggerAiToAiInteraction(momentId, relatedCharacters) {
            try {
                // 获取动态信息
                const momentsData = JSON.parse(sessionStorage.getItem('momentsData') || '[]');
                const moment = momentsData.find(m => (m.id == momentId) || (m.timestamp == momentId));
                if (!moment || !moment.comments) return;
                
                const comments = moment.comments;
                if (comments.length < 2) return; // 至少需要2条评论才能触发角色间互动
                
                // 获取在同群的参与评论AI角色
                const participatingAis = [...new Set(comments
                    .filter(comment => comment.characterId && comment.characterId !== 'user')
                    .map(comment => comment.characterId)
                )];
                
                // 过滤出只有在同群的AI角色
                const sameGroupParticipants = participatingAis.filter(aiId => 
                    relatedCharacters.some(char => char.id === aiId)
                );
                
                if (sameGroupParticipants.length < 2) {
                    console.log('参与评论的同群AI角色少于2个，跳过角色间互动');
                    return;
                }
                
                console.log(`发现 ${sameGroupParticipants.length} 个同群AI角色参与了评论，开始角色间互动`);
                
                // 随机选择两个同群AI进行互动
                const aiA = sameGroupParticipants[Math.floor(Math.random() * sameGroupParticipants.length)];
                let aiB = sameGroupParticipants[Math.floor(Math.random() * sameGroupParticipants.length)];
                
                // 确保选择不同的AI
                while (aiB === aiA && sameGroupParticipants.length > 1) {
                    aiB = sameGroupParticipants[Math.floor(Math.random() * sameGroupParticipants.length)];
                }
                
                if (aiA === aiB) return;
                
                // 检查角色关系和互动概率 (50%概率)
                if (Math.random() > 0.5) {
                    console.log('基于概率选择不进行角色间互动');
                    return;
                }
                
                // 选择一个现有评论作为互动起点
                const targetComment = comments.find(comment => 
                    comment.characterId === aiA || comment.characterId === aiB
                );
                
                if (!targetComment) return;
                
                // 决定谁先回复谁
                const responderCharId = targetComment.characterId === aiA ? aiB : aiA;
                const targetCharId = targetComment.characterId;
                
                // 获取角色信息
                const characters = await getCharacters();
                const responderChar = characters.find(c => c.id === responderCharId);
                const targetChar = characters.find(c => c.id === targetCharId);
                
                if (!responderChar || !targetChar) return;
                
                console.log(`${responderChar.name} 将回复 ${targetChar.name} 的评论`);
                
                // 生成AI间的互动回复
                await generateAiToAiReply(momentId, targetComment, responderChar, targetChar);
                
            } catch (error) {
                console.error('角色间互动失败:', error);
            }
        }
        

        
        // 角色之间互动（保留原函数，但不再使用）
        function triggerCharacterInteractions(momentId, characters) {
            if (characters.length < 2) return;
            
            // 获取已在同一群的角色关系
            const groupRelations = getGroupRelations(characters);
            
            for (let i = 0; i < characters.length - 1; i++) {
                for (let j = i + 1; j < characters.length; j++) {
                    const char1 = characters[i];
                    const char2 = characters[j];
                    
                    // 检查是否在同一个群里
                    const inSameGroup = groupRelations.some(group => 
                        group.includes(char1.id) && group.includes(char2.id)
                    );
                    
                    if (inSameGroup && Math.random() < 0.6) {
                        addCharacterInteraction(momentId, char1, char2);
                    }
                }
            }
        }
        
        // 获取群组关系
        function getGroupRelations(characters) {
            // 这里应该从群聊数据中获取关系，简化版本
            const groups = [];
            // 假设所有联系人都可能在同一个群里
            if (characters.length >= 2) {
                groups.push(characters.map(c => c.id));
            }
            return groups;
        }
        
        // 生成AI间的回复（套用完成.html逻辑）
        async function generateAiToAiReply(momentId, targetComment, responderChar, targetChar) {
            try {
                // 获取动态信息
                const momentsData = JSON.parse(sessionStorage.getItem('momentsData') || '[]');
                const moment = momentsData.find(m => (m.id == momentId) || (m.timestamp == momentId));
                if (!moment) return;
                
                // 获取响应角色的聊天设置
                let responderSettings = null;
                try {
                    responderSettings = await db.chatSettings.get(responderChar.id);
                } catch (error) {
                    console.error('获取响应角色聊天设置失败:', error);
                }
                
                const responderPersona = responderSettings?.aiPersona || responderChar.prompt || '';
                const targetPersona = targetChar.prompt || '';
                
                // 获取绑定的世界书内容
                let worldBookContent = '';
                if (responderSettings?.linkedWorldBookIds && responderSettings.linkedWorldBookIds.length > 0) {
            try {
                        const worldBooks = await Promise.all(
                            responderSettings.linkedWorldBookIds.map(id => db.worldbooks.get(id))
                        );
                        const validWorldBooks = worldBooks.filter(book => book && book.content);
                        if (validWorldBooks.length > 0) {
                            worldBookContent = '\n\n世界书内容（供参考）：\n' + 
                                validWorldBooks.map(book => `${book.name}：${book.content}`).join('\n\n');
                        }
                    } catch (error) {
                        console.error('获取世界书内容失败:', error);
                    }
                }
                
                // 获取聊天上下文
                let chatContext = '';
                const responderMessages = chatMessages[responderChar.id] || [];
                if (responderMessages.length > 0) {
                    const maxMemory = parseInt(responderSettings?.maxMemory) || 10;
                    const recentHistory = responderMessages.slice(-maxMemory);
                    chatContext = '\n\n最近的聊天记录（供参考）：\n' + 
                        recentHistory.map(msg => {
                            if (msg.role === 'user') return `用户：${msg.content}`;
                            return `${responderChar.name}：${msg.content}`;
                        }).join('\n');
                }
                
                const systemPrompt = `你是${responderChar.name}，你的人设如下：${responderPersona}。${worldBookContent}${chatContext}

现在在一个动态下，${targetChar.name}（人设：${targetPersona}）刚刚评论了："${targetComment.text}"。

原动态内容：${moment.text}

你要作为${responderChar.name}，基于你的人设和与${targetChar.name}的关系，对ta的评论进行回应。要求：
1. 严格按照你的人设进行回复，不能混淆角色
2. 回复要自然、符合朋友圈评论风格
3. 可以是赞同、不同观点、补充、提问或开玩笑
4. 要体现出你和${targetChar.name}之间的互动关系
5. 回复简短有趣，符合社交媒体的特点
6. 根据你的人设选择合适的语气和用词
7. 不要使用与角色性格不符的表情符号`;

                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: `请回复${targetChar.name}的评论` }
                ];

                const { base: proxyUrl, key: apiKey, model } = apiSettings;
                if (!proxyUrl || !apiKey || !model) {
                    console.log('API配置不完整，跳过AI互动');
                    return;
                }

                const requestBody = {
                    model: model,
                    messages: messages,
                    temperature: 0.8,
                    stream: false
                };

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000);

                const isGeminiOfficial = proxyUrl.includes('generativelanguage.googleapis.com');

                let response;
                if (isGeminiOfficial) {
                    const apiUrl = `${proxyUrl}/models/${model}:generateContent?key=${apiKey}`;
                    
                    const geminiMessages = [];
                    if (requestBody.messages[0]?.role === 'system') {
                        geminiMessages.push({
                            role: 'user',
                            parts: [{ text: requestBody.messages[0].content }]
                        });
                        geminiMessages.push({
                            role: 'model',
                            parts: [{ text: '我明白了，我会按照这些要求进行对话。' }]
                        });
                    }
                    
                    for (let i = 1; i < requestBody.messages.length; i++) {
                        const msg = requestBody.messages[i];
                        if (msg.role === 'system') continue;
                        
                        geminiMessages.push({
                            role: msg.role === 'user' ? 'user' : 'model',
                            parts: [{ text: msg.content }]
                        });
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiMessages,
                            generationConfig: {
                                temperature: requestBody.temperature || 0.8
                            }
                        }),
                        signal: controller.signal
                    });
                } else {
                    response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal
                    });
                }

                clearTimeout(timeoutId);

                if (!response.ok) {
                    let errorText = await response.text();
                    console.error(`AI互动API调用失败 (${response.status}): ${errorText}`);
                    return;
                }

                const data = await response.json();
                let content;

                if (isGeminiOfficial) {
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!content) {
                        console.log('Gemini API 响应数据:', data);
                        return;
                    }
                } else {
                    // 解析OpenAI格式响应
                    if (data.choices && data.choices.length > 0 && data.choices[0].message) {
                        content = data.choices[0].message.content;
                    } else if (data.message) {
                        content = data.message;
                    } else if (data.text) {
                        content = data.text;
                    } else if (data.response) {
                        content = data.response;
                    } else if (data.content) {
                        content = data.content;
                    } else if (data.result) {
                        content = data.result;
                    } else {
                        for (const key in data) {
                            if (typeof data[key] === 'string' && data[key].trim()) {
                                content = data[key];
                                console.log(`AI互动API使用字段 "${key}" 作为响应内容`);
                                break;
                            }
                        }
                    }
                    
                    if (!content) {
                        console.error('AI互动API无法解析响应，完整响应数据:', data);
                        return;
                    }
                }

                if (content && content.trim()) {
                    // 创建回复评论
                    const replyComment = {
                    id: Date.now() + Math.random(),
                        nickname: responderChar.name,
                        avatar: responderChar.avatarUrl,
                        text: content.trim(),
                    time: formatTime(new Date()),
                    timestamp: Date.now(),
                        replyTo: targetChar.name,
                        characterId: responderChar.id
                };
                
                    // 保存评论
                    saveCommentToMoment(momentId, replyComment);
                
                    // 更新评论数
                updateMomentCommentCount(momentId);
                
                    // 在动态下方显示新评论
                    displayCommentUnderMoment(momentId, replyComment);
                
                    showToast(`${responderChar.name} 回复了 ${targetChar.name}`);
                }

            } catch (error) {
                console.error('生成AI间回复失败:', error);
            }
        }
        
        // AI回复用户评论
        async function triggerAIReplyToUser(momentId, aiCharacterName, userCommentText) {
            try {
                console.log(`triggerAIReplyToUser被调用: momentId=${momentId}, aiCharacterName=${aiCharacterName}, userCommentText="${userCommentText}"`);
                console.log(`当前characters数组:`, characters);
                console.log(`当前contacts数组:`, contacts);
                
                // 找到对应的AI角色
                const character = characters.find(c => c.name === aiCharacterName);
                if (!character) {
                    console.log(`未找到角色 ${aiCharacterName}，可用角色:`, characters.map(c => c.name));
                    return;
                }
                
                // 获取动态信息
                const moment = await db.moments.get(parseInt(momentId));
                if (!moment) {
                    console.log(`未找到动态 ${momentId}`);
                    return;
                }
                
                // 获取角色设置
                let chatSettings = null;
                try {
                    chatSettings = await db.chatSettings.get(character.id);
                } catch (error) {
                    console.error('获取聊天设置失败:', error);
                }
                
                const persona = chatSettings?.aiPersona || character.prompt || `你是${character.name}。`;
                
                // 获取绑定的世界书内容
                let worldBookContent = '';
                if (chatSettings?.linkedWorldBookIds && chatSettings.linkedWorldBookIds.length > 0) {
                    try {
                        const worldBooks = await Promise.all(
                            chatSettings.linkedWorldBookIds.map(id => db.worldbooks.get(id))
                        );
                        const validWorldBooks = worldBooks.filter(book => book && book.content);
                        if (validWorldBooks.length > 0) {
                            worldBookContent = '\n\n世界书内容（供参考）：\n' + 
                                validWorldBooks.map(book => `${book.name}：${book.content}`).join('\n\n');
                        }
                    } catch (error) {
                        console.error('获取世界书内容失败:', error);
                    }
                }
                
                // 获取聊天上下文
                let chatContext = '';
                const characterMessages = chatMessages[character.id] || [];
                if (characterMessages.length > 0) {
                    const maxMemory = parseInt(chatSettings?.maxMemory) || 10;
                    const recentHistory = characterMessages.slice(-maxMemory);
                    chatContext = '\n\n最近的聊天记录（供参考）：\n' + 
                        recentHistory.map(msg => {
                        if (msg.role === 'user') return `用户：${msg.content}`;
                            return `${character.name}：${msg.content}`;
                    }).join('\n');
                }
                
                const systemPrompt = `你是${character.name}，你的人设如下：${persona}。${worldBookContent}${chatContext}

在一个动态下，用户刚刚回复了你的评论："${userCommentText}"。

原动态内容：${moment.text}

请作为${character.name}，基于你的人设对用户的回复做出自然的反应。要求：
1. 严格按照你的人设进行回复，保持角色一致性
2. 回复要自然、符合朋友圈评论风格，简短有趣
3. 可以是继续讨论、表达感谢、开玩笑或者分享更多想法
4. 体现出你和用户之间的友好互动
5. 根据你的人设选择合适的语气和用词
6. 不要使用与角色性格不符的表情符号`;

                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: `请回复用户的评论` }
                ];

                console.log(`找到角色 ${character.name}，准备生成回复`);
                console.log(`动态信息:`, moment);
                console.log(`角色设置:`, chatSettings);
                
                const { base: proxyUrl, key: apiKey, model } = apiSettings;
                if (!proxyUrl || !apiKey || !model) {
                    console.log('API配置不完整，跳过AI回复');
                    console.log('API设置:', apiSettings);
                    return;
                }

                const requestBody = {
                    model: model,
                    messages: messages,
                    temperature: 0.8,
                    stream: false
                };

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000);

                const isGeminiOfficial = proxyUrl.includes('generativelanguage.googleapis.com');

                let response;
                if (isGeminiOfficial) {
                    const apiUrl = `${proxyUrl}/models/${model}:generateContent?key=${apiKey}`;
                    
                    const geminiMessages = [];
                    if (requestBody.messages[0]?.role === 'system') {
                        geminiMessages.push({
                            role: 'user',
                            parts: [{ text: requestBody.messages[0].content }]
                        });
                        geminiMessages.push({
                            role: 'model',
                            parts: [{ text: '我明白了，我会按照这些要求进行对话。' }]
                        });
                    }
                    
                    for (let i = 1; i < requestBody.messages.length; i++) {
                        const msg = requestBody.messages[i];
                        if (msg.role === 'system') continue;
                        
                        geminiMessages.push({
                            role: msg.role === 'user' ? 'user' : 'model',
                            parts: [{ text: msg.content }]
                        });
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiMessages,
                            generationConfig: {
                                temperature: requestBody.temperature || 0.8
                            }
                        }),
                        signal: controller.signal
                    });
                } else {
                    response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal
                    });
                }

                clearTimeout(timeoutId);

                if (!response.ok) {
                    let errorText = await response.text();
                    console.error(`AI回复用户API调用失败 (${response.status}): ${errorText}`);
                    return;
                }

                const data = await response.json();
                let content;

                if (isGeminiOfficial) {
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!content) {
                        console.log('Gemini API 响应数据:', data);
                        return;
                    }
                } else {
                    // 解析OpenAI格式响应
                    if (data.choices && data.choices.length > 0 && data.choices[0].message) {
                        content = data.choices[0].message.content;
                    } else if (data.message) {
                        content = data.message;
                    } else if (data.text) {
                        content = data.text;
                    } else if (data.response) {
                        content = data.response;
                    } else if (data.content) {
                        content = data.content;
                    } else if (data.result) {
                        content = data.result;
                    } else {
                        for (const key in data) {
                            if (typeof data[key] === 'string' && data[key].trim()) {
                                content = data[key];
                                console.log(`AI回复用户API使用字段 "${key}" 作为响应内容`);
                                break;
                            }
                        }
                    }
                    
                    if (!content) {
                        console.error('AI回复用户API无法解析响应，完整响应数据:', data);
                        return;
                    }
                }

                if (content && content.trim()) {
                    // 创建AI回复评论
                    const replyComment = {
                        id: Date.now() + Math.random(),
                        nickname: character.name,
                        avatar: character.avatarUrl,
                        text: content.trim(),
                        time: formatTime(new Date()),
                        timestamp: Date.now(),
                        replyTo: '我', // 回复用户
                        characterId: character.id
                    };
                    
                    // 保存评论
                    saveCommentToMoment(momentId, replyComment);
                    
                    // 更新评论数
                    updateMomentCommentCount(momentId);
                    
                    // 在动态下方显示新评论
                    displayCommentUnderMoment(momentId, replyComment);
                    
                    // 增加对话轮次
                    const conversationKey = `${momentId}-${character.name}`;
                    const currentRounds = commentConversationRounds.get(conversationKey) || 0;
                    commentConversationRounds.set(conversationKey, currentRounds + 1);
                    console.log(`${character.name} 在动态 ${momentId} 中的对话轮次更新为: ${currentRounds + 1}/10`);
                    
                    showToast(`${character.name} 回复了你`);
                }

            } catch (error) {
                console.error('AI回复用户失败:', error);
            }
        }
        
        // 生成符合角色人设的评论 - 直接套用完成.html的逻辑
        async function generateCharacterComment(character, moment) {
            try {
                // 获取角色对应的聊天设置
                let chatSettings = null;
                try {
                    chatSettings = await db.chatSettings.get(character.id);
                } catch (error) {
                    console.error('获取聊天设置失败:', error);
                }
                
                const persona = chatSettings?.aiPersona || character.prompt || `你是${character.name}。`;
                
                // 获取绑定的世界书内容
                let worldBookContent = '';
                if (chatSettings?.linkedWorldBookIds && chatSettings.linkedWorldBookIds.length > 0) {
                    try {
                    const worldBooks = await Promise.all(
                            chatSettings.linkedWorldBookIds.map(id => db.worldbooks.get(id))
                    );
                    const validWorldBooks = worldBooks.filter(book => book && book.content);
                    if (validWorldBooks.length > 0) {
                        worldBookContent = '\n\n世界书内容（供参考）：\n' + 
                            validWorldBooks.map(book => `${book.name}：${book.content}`).join('\n\n');
                    }
                    } catch (error) {
                        console.error('获取世界书内容失败:', error);
                    }
                }
                
                // 获取最近的聊天记录作为上下文（根据用户设置的条数）
                let chatContext = '';
                const characterMessages = chatMessages[character.id] || [];
                if (characterMessages.length > 0) {
                    const maxMemory = parseInt(chatSettings?.maxMemory) || 10;
                    const recentHistory = characterMessages.slice(-maxMemory);
                    chatContext = '\n\n最近的聊天记录（供参考）：\n' + 
                        recentHistory.map(msg => {
                            if (msg.role === 'user') return `用户：${msg.content}`;
                            return `${character.name}：${msg.content}`;
                        }).join('\n');
                }
                
                let systemPrompt = `你是${character.name}，你的人设如下：${persona}。${worldBookContent}${chatContext}\n\n`;
                systemPrompt += `现在在朋友圈看到了一条动态，请基于你的人设发表评论。评论要符合你的性格特点和兴趣爱好。`;
                systemPrompt += `\n\n要求：
1. 严格按照你的人设回复，体现你独特的性格和说话风格
2. 评论要简短自然，符合朋友圈风格（1-2句话即可）
3. 可以是感想、疑问、赞美、调侃或分享相关经历
4. 只有符合你性格的情况下才使用表情符号，不要滥用emoji
5. 要像真实的朋友一样自然互动，避免过于正式的表达
6. 如果动态内容与你的兴趣爱好相关，可以展现更多热情`;
                
                // 构建用户消息
                let postDescription = `原动态：${moment.text || ''}`;
                if (moment.images && moment.images.length > 0) {
                    postDescription += `\n[该动态包含${moment.images.length}张图片]`;
                }
                const userMsg = `${postDescription}\n请发表你的看法：`;
                
                // 构建消息
                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: userMsg }
                ];
                
                // 使用完整的API调用逻辑（与聊天相同）
                const { base: proxyUrl, key: apiKey, model } = apiSettings;
                if (!proxyUrl || !apiKey || !model) {
                    console.log('API配置不完整，跳过AI评论');
                    return [];
                }
                
                const requestBody = {
                    model: model,
                    messages: messages,
                    temperature: 0.8,
                    stream: false
                };
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000);
                
                // 检测是否是Gemini官方API
                const isGeminiOfficial = proxyUrl.includes('generativelanguage.googleapis.com');
                
                let response;
                if (isGeminiOfficial) {
                    // 使用Gemini官方API格式
                    const apiUrl = `${proxyUrl}/models/${model}:generateContent?key=${apiKey}`;
                    
                    // 转换消息格式为Gemini格式
                    const geminiMessages = [];
                    
                    // 添加系统提示词作为第一条用户消息
                    if (requestBody.messages[0]?.role === 'system') {
                        geminiMessages.push({
                            role: 'user',
                            parts: [{ text: requestBody.messages[0].content }]
                        });
                        geminiMessages.push({
                            role: 'model',
                            parts: [{ text: '我明白了，我会按照这些要求进行对话。' }]
                        });
                    }
                    
                    // 转换其他消息
                    for (let i = 1; i < requestBody.messages.length; i++) {
                        const msg = requestBody.messages[i];
                        if (msg.role === 'system') continue;
                        
                        geminiMessages.push({
                            role: msg.role === 'user' ? 'user' : 'model',
                            parts: [{ text: msg.content }]
                        });
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiMessages,
                            generationConfig: {
                                temperature: requestBody.temperature || 0.8
                            }
                        }),
                        signal: controller.signal
                    });
                } else {
                    // 使用OpenAI格式
                    response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal
                    });
                }
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    let errorText = await response.text();
                    console.error(`API调用失败 (${response.status}): ${errorText}`);
                    return [];
                }
                
                const data = await response.json();
                let content;
                
                if (isGeminiOfficial) {
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!content) {
                        console.log('Gemini API 响应数据:', data);
                        return [];
                    }
                } else {
                    // 解析OpenAI格式响应
                    if (data.choices && data.choices.length > 0 && data.choices[0].message) {
                        content = data.choices[0].message.content;
                    } else if (data.message) {
                        content = data.message;
                    } else if (data.text) {
                        content = data.text;
                    } else if (data.response) {
                        content = data.response;
                    } else if (data.content) {
                        content = data.content;
                    } else if (data.result) {
                        content = data.result;
                    } else {
                        // 尝试查找第一个字符串类型的值
                        for (const key in data) {
                            if (typeof data[key] === 'string' && data[key].trim()) {
                                content = data[key];
                                console.log(`AI评论API使用字段 "${key}" 作为响应内容`);
                                break;
                            }
                        }
                    }
                    
                    if (!content) {
                        console.error('AI评论API无法解析响应，完整响应数据:', data);
                        return [];
                    }
                }
                
                if (content && content.trim().length > 0) {
                    return [content.trim()];
                }
                
                return [];
                
            } catch (error) {
                console.error('生成AI评论失败:', error);
                return [];
            }
        }
        

        
        // 生成角色间互动评论 - 使用完整的AI聊天逻辑
        async function generateCharacterInteraction(char1, char2, momentId) {
            try {
                // 获取动态和之前的评论上下文
                const momentsData = JSON.parse(sessionStorage.getItem('momentsData') || '[]');
                const moment = momentsData.find(m => (m.id == momentId) || (m.timestamp == momentId));
                if (!moment) return '';
                
                // 获取角色对应的聊天设置
                let chatSettings1 = null;
                let chatSettings2 = null;
                try {
                    chatSettings1 = await db.chatSettings.get(char1.id);
                    chatSettings2 = await db.chatSettings.get(char2.id);
                } catch (error) {
                    console.error('获取聊天设置失败:', error);
                }
                
                // 获取char2的最新评论作为上下文
                const char2Comments = (moment.comments || []).filter(c => c.characterId === char2.id);
                const latestChar2Comment = char2Comments[char2Comments.length - 1];
                
                // 构建对话上下文
                let conversationContext = `用户发布了动态：${moment.text}\n`;
                if (latestChar2Comment) {
                    conversationContext += `${char2.name}评论说：${latestChar2Comment.text}\n`;
                }
                
                // 使用完整的AI人设和记忆系统
                const persona1 = chatSettings1?.aiPersona || char1.prompt || `你是${char1.name}。`;
                
                // 获取历史聊天记录
                const maxMemory = parseInt(chatSettings1?.maxMemory) || 10;
                const char1Messages = chatMessages[char1.id] || [];
                const recentMessages = char1Messages.slice(-maxMemory);
                
                let chatSummary = '';
                if (recentMessages.length > 0) {
                    chatSummary = '你和用户最近的聊天记录（供参考）：\n';
                    chatSummary += recentMessages.map(msg => {
                        if (msg.role === 'user') return `用户：${msg.content}`;
                        if (msg.role === 'assistant') return `${char1.name}：${msg.content}`;
                        return '';
                    }).filter(line => line).join('\n');
                }
                
                // 获取挂载的世界书内容
                let worldBookContent = '';
                if (chatSettings1?.linkedWorldBookIds && chatSettings1.linkedWorldBookIds.length > 0) {
                    try {
                    const worldBooks = await Promise.all(
                            chatSettings1.linkedWorldBookIds.map(async id => {
                                try {
                                    return await db.worldbooks.get(id);
                                } catch (error) {
                                    console.error('获取世界书失败:', error);
                                    return null;
                                }
                            })
                    );
                    const validWorldBooks = worldBooks.filter(book => book && book.content);
                    if (validWorldBooks.length > 0) {
                        worldBookContent = '\n\n世界书内容（供参考）：\n' + 
                            validWorldBooks.map(book => `${book.name}：${book.content}`).join('\n\n');
                    }
                    } catch (error) {
                        console.error('获取世界书内容失败:', error);
                    }
                }
                
                let systemPrompt = `你是${char1.name}，你的人设如下：${persona1}。${worldBookContent}${chatSummary}\n\n`;
                systemPrompt += `这是一个楼中楼讨论，请基于以下对话上下文，继续参与讨论。要符合你的人设，回复要简短有趣。`;
                if (chatSettings2?.aiPersona) {
                    systemPrompt += ` （${char2.name}的设定：${chatSettings2.aiPersona}）`;
                }
                systemPrompt += `\n\n要求：
1. 回复要符合朋友圈评论的风格，简短、自然
2. 严格按照你的人设来选择是否使用表情符号，不要使用与角色性格不符的emoji
3. 不要过于正式或客套，要像真实的朋友一样互动`;
                
                // 构建消息
                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: conversationContext }
                ];
                
                // 使用完整的API调用逻辑（与聊天相同）
                const { base: proxyUrl, key: apiKey, model } = apiSettings;
                if (!proxyUrl || !apiKey || !model) {
                    console.log('API配置不完整，跳过角色互动');
                    return '';
                }
                
                const requestBody = {
                    model: model,
                    messages: messages,
                    temperature: 0.8,
                    stream: false
                };
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000);
                
                // 检测是否是Gemini官方API
                const isGeminiOfficial = proxyUrl.includes('generativelanguage.googleapis.com');
                
                let response;
                if (isGeminiOfficial) {
                    // 使用Gemini官方API格式
                    const apiUrl = `${proxyUrl}/models/${model}:generateContent?key=${apiKey}`;
                    
                    const geminiMessages = [];
                    if (requestBody.messages[0]?.role === 'system') {
                        geminiMessages.push({
                            role: 'user',
                            parts: [{ text: requestBody.messages[0].content }]
                        });
                        geminiMessages.push({
                            role: 'model',
                            parts: [{ text: '我明白了，我会按照这些要求进行对话。' }]
                        });
                    }
                    
                    for (let i = 1; i < requestBody.messages.length; i++) {
                        const msg = requestBody.messages[i];
                        if (msg.role === 'system') continue;
                        
                        geminiMessages.push({
                            role: msg.role === 'user' ? 'user' : 'model',
                            parts: [{ text: msg.content }]
                        });
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiMessages,
                            generationConfig: {
                                temperature: requestBody.temperature || 0.8
                            }
                        }),
                        signal: controller.signal
                    });
                } else {
                    // 使用OpenAI格式
                    response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal
                    });
                }
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    let errorText = await response.text();
                    console.error(`角色互动API调用失败 (${response.status}): ${errorText}`);
                    return '';
                }
                
                const data = await response.json();
                let content;
                
                if (isGeminiOfficial) {
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!content) {
                        console.log('Gemini API 响应数据:', data);
                        return '';
                    }
                } else {
                    // 解析OpenAI格式响应
                    if (data.choices && data.choices.length > 0 && data.choices[0].message) {
                        content = data.choices[0].message.content;
                    } else if (data.message) {
                        content = data.message;
                    } else if (data.text) {
                        content = data.text;
                    } else if (data.response) {
                        content = data.response;
                    } else if (data.content) {
                        content = data.content;
                    } else if (data.result) {
                        content = data.result;
                    } else {
                        // 尝试查找第一个字符串类型的值
                        for (const key in data) {
                            if (typeof data[key] === 'string' && data[key].trim()) {
                                content = data[key];
                                console.log(`角色互动API使用字段 "${key}" 作为响应内容`);
                                break;
                            }
                        }
                    }
                    
                    if (!content) {
                        console.error('角色互动API无法解析响应，完整响应数据:', data);
                return '';
                    }
                }
                
                return content ? content.trim() : '';
                
            } catch (error) {
                console.error('生成角色互动失败:', error);
                return '';
            }
        }
        

        
        // 长按选择功能
        function addLongPressListener(element, momentId) {
            let pressTimer = null;
            let startY = 0;
            let moved = false;
            
            const startPress = (e) => {
                if (isSelectionMode) return;
                
                startY = e.touches ? e.touches[0].clientY : e.clientY;
                moved = false;
                
                pressTimer = setTimeout(() => {
                    if (!moved) {
                        enterSelectionMode();
                        selectMoment(momentId);
                    }
                }, 500); // 500ms长按
            };
            
            const endPress = () => {
                clearTimeout(pressTimer);
                pressTimer = null;
            };
            
            const movePress = (e) => {
                const currentY = e.touches ? e.touches[0].clientY : e.clientY;
                if (Math.abs(currentY - startY) > 10) {
                    moved = true;
                    endPress();
                }
            };
            
            element.addEventListener('touchstart', startPress);
            element.addEventListener('touchend', endPress);
            element.addEventListener('touchmove', movePress);
            element.addEventListener('mousedown', startPress);
            element.addEventListener('mouseup', endPress);
            element.addEventListener('mousemove', movePress);
        }
        
        // 进入选择模式
        function enterSelectionMode() {
            isSelectionMode = true;
            selectedMoments.clear();
            
            // 显示选择模式UI
            showSelectionModeUI();
            
            // 添加选择框到所有动态
            const momentItems = document.querySelectorAll('.moment-item');
            momentItems.forEach(item => {
                const checkbox = document.createElement('div');
                checkbox.className = 'moment-checkbox';
                checkbox.innerHTML = '<i class="far fa-circle"></i>';
                checkbox.onclick = (e) => {
                    e.stopPropagation();
                    const momentId = item.getAttribute('data-moment-id');
                    toggleMomentSelection(momentId);
                };
                item.appendChild(checkbox);
                item.classList.add('selection-mode');
            });
        }
        
        // 退出选择模式
        function exitSelectionMode() {
            isSelectionMode = false;
            selectedMoments.clear();
            
            // 隐藏选择模式UI
            hideSelectionModeUI();
            
            // 移除选择框
            const checkboxes = document.querySelectorAll('.moment-checkbox');
            checkboxes.forEach(checkbox => checkbox.remove());
            
            const momentItems = document.querySelectorAll('.moment-item');
            momentItems.forEach(item => {
                item.classList.remove('selection-mode', 'selected');
            });
        }
        
        // 显示选择模式UI
        function showSelectionModeUI() {
            const selectionBar = document.createElement('div');
            selectionBar.className = 'selection-bar';
            selectionBar.innerHTML = `
                <div class="selection-actions">
                    <button class="cancel-btn" onclick="exitSelectionMode()">取消</button>
                    <span class="selection-count">已选择 0 条动态</span>
                    <button class="delete-btn" onclick="deleteSelectedMoments()" disabled>删除</button>
                </div>
            `;
            
            const momentsPage = document.getElementById('moments-page');
            momentsPage.insertBefore(selectionBar, momentsPage.firstChild);
        }
        
        // 隐藏选择模式UI
        function hideSelectionModeUI() {
            const selectionBar = document.querySelector('.selection-bar');
            if (selectionBar) {
                selectionBar.remove();
            }
        }
        
        // 切换动态选择状态
        function toggleMomentSelection(momentId) {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;
            
            const checkbox = momentElement.querySelector('.moment-checkbox i');
            
            if (selectedMoments.has(momentId)) {
                selectedMoments.delete(momentId);
                checkbox.className = 'far fa-circle';
                momentElement.classList.remove('selected');
            } else {
                selectedMoments.add(momentId);
                checkbox.className = 'fas fa-check-circle';
                momentElement.classList.add('selected');
            }
            
            updateSelectionUI();
        }
        
        // 选择动态
        function selectMoment(momentId) {
            if (!selectedMoments.has(momentId)) {
                toggleMomentSelection(momentId);
            }
        }
        
        // 更新选择UI
        function updateSelectionUI() {
            const countSpan = document.querySelector('.selection-count');
            const deleteBtn = document.querySelector('.delete-btn');
            
            if (countSpan) {
                countSpan.textContent = `已选择 ${selectedMoments.size} 条动态`;
            }
            
            if (deleteBtn) {
                deleteBtn.disabled = selectedMoments.size === 0;
            }
        }
        
        // 删除选中的动态
        async function deleteSelectedMoments() {
            if (selectedMoments.size === 0) return;
            
            if (!confirm(`确定要删除 ${selectedMoments.size} 条动态吗？`)) {
                return;
            }
            
            try {
                // 从数据库中删除
                for (const momentId of selectedMoments) {
                    try {
                        // 尝试多种ID格式进行删除
                        let deleted = false;
                        const possibleIds = [momentId, parseInt(momentId), String(momentId), Number(momentId)];
                        
                        for (const id of possibleIds) {
                            try {
                                await db.moments.delete(id);
                                console.log(`✓ 成功删除动态 ${id} (类型: ${typeof id})`);
                                deleted = true;
                                break;
                            } catch (error) {
                                console.log(`删除ID ${id} (${typeof id}) 失败: ${error.message}`);
                            }
                        }
                        
                        if (!deleted) {
                            // 尝试使用where条件删除
                            await db.moments.where('id').equals(momentId).delete();
                            console.log(`✓ 使用where条件删除动态 ${momentId} 成功`);
                        }
                        
                        // 删除相关点赞（尝试不同ID格式）
                        const numericId = parseInt(momentId);
                        await db.momentLikes.where('momentId').equals(numericId).delete();
                        await db.momentLikes.where('momentId').equals(momentId).delete();
                        
                        // 删除相关评论（尝试不同ID格式）
                        await db.momentComments.where('momentId').equals(numericId).delete();
                        await db.momentComments.where('momentId').equals(momentId).delete();
                        
                    } catch (error) {
                        console.error(`删除动态 ${momentId} 失败:`, error);
                        throw error; // 重新抛出错误以便上层处理
                    }
                    
                    // 清理对话轮次记录
                    for (const [key, value] of commentConversationRounds.entries()) {
                        if (key.startsWith(`${momentId}-`)) {
                            commentConversationRounds.delete(key);
                        }
                    }
            }
            
            // 从DOM中移除
            selectedMoments.forEach(momentId => {
                const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
                if (momentElement) {
                    momentElement.remove();
                }
            });
                
                // 清理可能存在的sessionStorage缓存数据
                try {
                    const sessionMomentsData = sessionStorage.getItem('momentsData');
                    if (sessionMomentsData) {
                        const momentsArray = JSON.parse(sessionMomentsData);
                        const filteredMoments = momentsArray.filter(moment => 
                            !selectedMoments.has(moment.id.toString()) && 
                            !selectedMoments.has(moment.timestamp?.toString())
                        );
                        sessionStorage.setItem('momentsData', JSON.stringify(filteredMoments));
                    }
                } catch (error) {
                    console.warn('清理sessionStorage动态数据时出错:', error);
                }
            
            showToast(`已删除 ${selectedMoments.size} 条动态`);
            
            // 退出选择模式
            exitSelectionMode();
                
                // 强制重新加载动态列表，确保删除生效
                setTimeout(() => {
                    loadMoments();
                }, 500);
                
            } catch (error) {
                console.error('删除动态失败:', error);
                showToast('删除失败，请重试');
            }
        }
        
        // 强制清理指定动态的所有相关数据
        async function forceCleanMoment(momentId) {
            try {
                const numericId = parseInt(momentId);
                console.log(`开始彻底清理动态: ${momentId}`);
                
                // 1. 从IndexedDB删除（尝试多种ID格式）
                let deleted = false;
                const possibleIds = [momentId, numericId, String(momentId), Number(momentId)];
                
                for (const id of possibleIds) {
                    try {
                        await db.moments.delete(id);
                        console.log(`✓ 删除动态成功，使用ID: ${id} (类型: ${typeof id})`);
                        deleted = true;
                        break;
                    } catch (error) {
                        console.log(`删除ID ${id} 失败: ${error.message}`);
                    }
                }
                
                if (!deleted) {
                    await db.moments.where('id').equals(momentId).delete();
                }
                
                // 删除相关数据（尝试不同格式）
                await db.momentLikes.where('momentId').equals(numericId).delete();
                await db.momentLikes.where('momentId').equals(momentId).delete();
                await db.momentComments.where('momentId').equals(numericId).delete();
                await db.momentComments.where('momentId').equals(momentId).delete();
                
                // 2. 清理对话轮次记录
                for (const [key, value] of commentConversationRounds.entries()) {
                    if (key.startsWith(`${momentId}-`)) {
                        commentConversationRounds.delete(key);
                    }
                }
                
                // 3. 从DOM移除
                const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
                if (momentElement) {
                    momentElement.remove();
                }
                
                // 4. 清理sessionStorage缓存
                const sessionMomentsData = sessionStorage.getItem('momentsData');
                if (sessionMomentsData) {
                    const momentsArray = JSON.parse(sessionMomentsData);
                    const filteredMoments = momentsArray.filter(moment => 
                        moment.id != momentId && 
                        moment.timestamp != momentId &&
                        moment.id.toString() !== momentId.toString()
                    );
                    sessionStorage.setItem('momentsData', JSON.stringify(filteredMoments));
                }
                
                console.log(`动态 ${momentId} 清理完成`);
                return true;
            } catch (error) {
                console.error('强制清理动态失败:', error);
                return false;
            }
        }
        
        // 清理所有有问题的动态（修复工具）
        async function cleanupCorruptedMoments() {
            if (!confirm('这将清理所有可能有问题的动态数据，确定继续吗？')) {
                return;
            }
            
            try {
                let cleanupCount = 0;
                
                // 获取所有动态
                const allMoments = await db.moments.toArray();
                
                for (const moment of allMoments) {
                    // 检查动态是否有无效的头像数据
                    if (moment.avatar && !isValidAvatarUrl(moment.avatar)) {
                        console.log(`发现无效头像的动态: ${moment.id}`);
                        
                        // 修复头像或删除动态
                        const shouldDelete = confirm(`动态 "${moment.text?.substring(0, 30)}..." 包含无效头像数据，是否删除此动态？\n点击"取消"将修复头像数据。`);
                        
                        if (shouldDelete) {
                            await forceCleanMoment(moment.id);
                            cleanupCount++;
                        } else {
                            // 修复头像
                            await db.moments.update(moment.id, { avatar: getDefaultAvatar() });
                        }
                    }
                }
                
                if (cleanupCount > 0) {
                    showToast(`已清理 ${cleanupCount} 条有问题的动态`);
                    // 重新加载动态列表
                    loadMoments();
                } else {
                    showToast('没有发现需要清理的动态');
                }
                
            } catch (error) {
                console.error('清理损坏动态失败:', error);
                showToast('清理失败，请重试');
            }
        }
        
        // 更换动态封面图片
        function changeCoverImage() {
            const input = document.createElement("input");
            input.type = "file";
            input.accept = "image/*";
            input.onchange = async function(e) {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedImage = await compressImage(file, 1200, 0.8);
                        
                        const coverImage = document.getElementById("cover-image");
                        const coverPlaceholder = document.getElementById("cover-placeholder");
                        
                        if (coverImage && coverPlaceholder) {
                            coverImage.src = compressedImage;
                            coverImage.classList.remove("hide");
                            coverPlaceholder.classList.add("hide");
                        }
                        
                        saveMomentsImage("coverImage", compressedImage);
                        showToast("封面已更新！", "success");
                    } catch (error) {
                        console.error("处理封面图片失败:", error);
                        showToast("封面更新失败！", "error");
                    }
                }
            };
            input.click();
        }
        
        // 更换动态头像
        function changeAvatarImage(event) {
            event.stopPropagation();
            
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = async function(e) {
                const file = e.target.files[0];
                if (file) {
                    try {
                        // 压缩头像图片
                        const compressedImage = await compressImage(file, 400, 0.9);
                        
                        const avatar = document.getElementById('moments-avatar');
                        const avatarIcon = avatar.querySelector('.moments-avatar-icon');
                        
                        avatar.style.backgroundImage = `url(${compressedImage})`;
                        avatarIcon.style.display = 'none';
                        
                        // 保存压缩后的图片
                        saveMomentsImage('avatarImage', compressedImage);
                        
                        showToast('头像已更新！', 'success');
                    } catch (error) {
                        console.error('处理头像图片失败:', error);
                        showToast('头像更新失败！', 'error');
                    }
                }
            };
            input.click();
        }
        
        // 加载动态图片设置
        function loadMomentsImages() {
            try {
                // 加载封面图片
                const savedCover = getMomentsImage('coverImage');
                if (savedCover) {
                    const coverImage = document.getElementById('cover-image');
                    const coverPlaceholder = document.getElementById('cover-placeholder');
                    
                    if (coverImage && coverPlaceholder) {
                        coverImage.src = savedCover;
                        coverImage.classList.remove('hide');
                        coverPlaceholder.classList.add('hide');
                    }
                }
                
                // 加载头像图片
                const savedAvatar = getMomentsImage('avatarImage');
                if (savedAvatar) {
                    const avatar = document.getElementById('moments-avatar');
                    const avatarIcon = avatar?.querySelector('.moments-avatar-icon');
                    
                    if (avatar) {
                        avatar.style.backgroundImage = `url(${savedAvatar})`;
                        if (avatarIcon) {
                            avatarIcon.style.display = 'none';
                        }
                    }
                }
                
                // 加载用户名
                const savedUsername = getMomentsImage('username');
                if (savedUsername) {
                    const usernameElement = document.getElementById('moments-username');
                    if (usernameElement) {
                        usernameElement.textContent = savedUsername;
                    }
                }
                
                console.log('动态图片加载完成');
            } catch (error) {
                console.error('加载动态图片失败:', error);
            }
        }
        
        // 更改用户名
        function changeUsername(event) {
            event.stopPropagation();
            
            const currentUsername = document.getElementById('moments-username').textContent;
            const newUsername = prompt('请输入您的昵称:', currentUsername);
            
            if (newUsername !== null && newUsername.trim() !== '') {
                const usernameElement = document.getElementById('moments-username');
                usernameElement.textContent = newUsername.trim();
                
                // 保存用户名
                saveMomentsImage('username', newUsername.trim());
                
                showToast('昵称已更新！', 'success');
            }
        }
        
        // 压缩图片
        function compressImage(fileOrDataUrl, maxWidth = 800, quality = 0.8) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = function() {
                    // 计算压缩后的尺寸
                    let { width, height } = img;
                    if (width > maxWidth) {
                        height = (height * maxWidth) / width;
                        width = maxWidth;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    // 绘制压缩后的图片
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // 转换为base64，降低质量以减少大小
                    const compressedData = canvas.toDataURL('image/jpeg', quality);
                    resolve(compressedData);
                };
                
                // 判断输入类型：File对象还是base64字符串
                if (typeof fileOrDataUrl === 'string') {
                    // 如果是base64字符串，直接使用
                    img.src = fileOrDataUrl;
                } else {
                    // 如果是File对象，创建URL
                    img.src = URL.createObjectURL(fileOrDataUrl);
                }
            });
        }
        
        // 保存动态图片（使用会话存储，避免空间问题）
        function saveMomentsImage(imageType, imageData) {
            try {
                // 使用sessionStorage暂存，页面会话期间有效
                sessionStorage.setItem(`moments_${imageType}`, imageData);
                console.log(`动态图片已保存: ${imageType}`);
            } catch (error) {
                console.error('保存动态图片失败:', error);
                // 如果sessionStorage也满了，只在内存中保存
                window.momentsImages = window.momentsImages || {};
                window.momentsImages[imageType] = imageData;
                console.log(`动态图片已保存到内存: ${imageType}`);
            }
        }
        
        // 获取动态图片
        function getMomentsImage(imageType) {
            try {
                // 先从sessionStorage获取
                const sessionData = sessionStorage.getItem(`moments_${imageType}`);
                if (sessionData) {
                    return sessionData;
                }
                
                // 然后从内存获取
                if (window.momentsImages && window.momentsImages[imageType]) {
                    return window.momentsImages[imageType];
                }
                
                return null;
            } catch (error) {
                console.error('获取动态图片失败:', error);
                return null;
            }
        }
        
        // 重置数据库（如果出现schema错误）
        async function resetDatabase() {
            try {
                await db.delete();
                console.log('数据库已重置');
                location.reload(); // 重新加载页面
            } catch (error) {
                console.error('重置数据库失败:', error);
            }
        }
        
        // 开始游戏
        function startGame(gameName) {
            if (gameName === 'witchPotion') {
                // TODO: 实现女巫的解药游戏
                alert('女巫的解药游戏正在开发中...\n\n这将是一个与AI角色互动的解谜游戏！');
            } else {
                alert('游戏功能正在开发中...');
            }
        }
        
                // 切换手机边框显示
        function togglePhoneBorder() {
            const phoneFrame = document.getElementById('phone-frame');
            const phoneScreen = document.getElementById('phone-screen');
            const toggle = document.getElementById('phone-border-toggle');
            const body = document.body;
            
            if (toggle.checked) {
                // 显示真实手机边框
                phoneFrame.style.display = 'block';
                phoneFrame.style.padding = '12px';
                phoneFrame.style.backgroundColor = '#fff';
                phoneFrame.style.borderRadius = '50px';
                phoneFrame.style.boxShadow = '0 20px 50px rgba(0,0,0,0.25), inset 0 2px 4px rgba(0,0,0,0.1)';
                phoneScreen.style.borderRadius = '40px';
                phoneScreen.style.border = '2px solid #333';
                body.style.background = 'var(--body-bg, #dcdcdc)';
                body.style.padding = '20px';
            } else {
                // 隐藏边框，但保持phone-screen的圆角和阴影
                phoneFrame.style.display = 'block';
                phoneFrame.style.padding = '0';
                phoneFrame.style.backgroundColor = 'transparent';
                phoneFrame.style.borderRadius = '0';
                phoneFrame.style.boxShadow = 'none';
                phoneScreen.style.borderRadius = '25px';
                phoneScreen.style.border = 'none';
                phoneScreen.style.boxShadow = 'var(--shadow-phone)';
                body.style.background = 'var(--body-bg, #1a1a1a)';
                body.style.padding = '0';
            }
            
            // 保存设置到localStorage
            localStorage.setItem('phoneBorderEnabled', toggle.checked);
            
            // 显示提示
            const message = toggle.checked ? '手机边框已开启！' : '手机边框已关闭！';
            showToast(message, 'success');
        }
        
        // 显示屏幕尺寸选择
        function showScreenSizeOptions() {
            showApp('screen-size-screen');
        }
        
        // 改变屏幕尺寸
        function changeScreenSize(width, height, name) {
            const phoneScreen = document.getElementById('phone-screen');
            
            // 应用新尺寸
            phoneScreen.style.width = width + 'px';
            phoneScreen.style.height = height + 'px';
            
            // 更新外观设置中的显示文本
            const currentSizeDesc = document.getElementById('current-screen-size');
            if (currentSizeDesc) {
                currentSizeDesc.textContent = `当前：${width}×${height} (${name})`;
            }
            
            // 更新选中状态
            document.querySelectorAll('.size-option .check-icon').forEach(icon => {
                icon.style.display = 'none';
            });
            document.querySelectorAll('.size-option').forEach(option => {
                option.style.backgroundColor = '';
            });
            
            // 显示当前选中项的勾选图标
            const currentOption = event.target.closest('.size-option');
            if (currentOption) {
                const checkIcon = currentOption.querySelector('.check-icon');
                if (checkIcon) {
                    checkIcon.style.display = 'block';
                } else {
                    // 如果没有勾选图标，创建一个
                    const newCheckIcon = document.createElement('i');
                    newCheckIcon.className = 'fas fa-check check-icon';
                    newCheckIcon.style.display = 'block';
                    currentOption.appendChild(newCheckIcon);
                }
                currentOption.style.backgroundColor = 'rgba(0, 123, 255, 0.1)';
            }
            
            // 保存到localStorage
            localStorage.setItem('screenSize', JSON.stringify({width, height, name}));
            
            // 显示提示
            showToast(`屏幕尺寸已切换为${name}！`, 'success');
            
            // 延迟一点再返回，让用户看到选择效果
            setTimeout(() => {
                showApp('appearance-screen');
            }, 300);
        }
        
        // 加载屏幕尺寸设置
        function loadScreenSize() {
            const saved = localStorage.getItem('screenSize');
            if (saved) {
                const {width, height, name} = JSON.parse(saved);
                const phoneScreen = document.getElementById('phone-screen');
                phoneScreen.style.width = width + 'px';
                phoneScreen.style.height = height + 'px';
                
                const currentSizeDesc = document.getElementById('current-screen-size');
                if (currentSizeDesc) {
                    currentSizeDesc.textContent = `当前：${width}×${height} (${name})`;
                }
            }
        }
        
        // 加载边框设置
        function loadPhoneBorderSetting() {
            const saved = localStorage.getItem('phoneBorderEnabled');
            const toggle = document.getElementById('phone-border-toggle');
            
            // 默认关闭边框
            const enabled = saved !== null ? saved === 'true' : false;
            
            if (toggle) {
                toggle.checked = enabled;
            }
            
            // 应用设置
            const phoneFrame = document.getElementById('phone-frame');
            const phoneScreen = document.getElementById('phone-screen');
            const body = document.body;
            
            if (enabled) {
                // 显示真实手机边框
                phoneFrame.style.display = 'block';
                phoneFrame.style.padding = '12px';
                phoneFrame.style.backgroundColor = '#fff';
                phoneFrame.style.borderRadius = '50px';
                phoneFrame.style.boxShadow = '0 20px 50px rgba(0,0,0,0.25), inset 0 2px 4px rgba(0,0,0,0.1)';
                phoneScreen.style.borderRadius = '40px';
                phoneScreen.style.border = '2px solid #333';
                body.style.background = 'var(--body-bg, #dcdcdc)';
                body.style.padding = '20px';
            } else {
                // 隐藏边框，但保持phone-screen的圆角和阴影
                phoneFrame.style.display = 'block';
                phoneFrame.style.padding = '0';
                phoneFrame.style.backgroundColor = 'transparent';
                phoneFrame.style.borderRadius = '0';
                phoneFrame.style.boxShadow = 'none';
                phoneScreen.style.borderRadius = '25px';
                phoneScreen.style.border = 'none';
                phoneScreen.style.boxShadow = 'var(--shadow-phone)';
                body.style.background = 'var(--body-bg, #1a1a1a)';
                body.style.padding = '0';
            }
        }
        
        // 添加Toast提示函数
        function showToast(message, type = 'info') {
            // 创建toast元素
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background-color: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 500;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                opacity: 0;
                transition: opacity 0.3s ease;
                backdrop-filter: blur(10px);
                -webkit-backdrop-filter: blur(10px);
            `;
            toast.textContent = message;
            
            document.body.appendChild(toast);
            
            // 显示toast
            setTimeout(() => {
                toast.style.opacity = '1';
            }, 10);
            
            // 3秒后自动隐藏
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, 3000);
        }
        
        // 文本截断函数
        function truncateText(text, maxLength = 50) {
    // --- 新增的安全检查 ---
    let textStr = '';
    if (typeof text === 'string') {
        textStr = text;
    } else if (text && typeof text === 'object') {
        // 如果收到了一个对象，可能是[object Object]问题的根源，
        // 我们不再让它崩溃，而是显示一个通用占位符。
        console.warn("truncateText 函数收到了一个对象，已自动处理:", text);
        return '[多媒体消息]';
    } else {
        // 对于其他意外情况 (如 null 或 undefined)，返回空字符串。
        return '';
    }
    // --- 安全检查结束 ---

    // 现在 textStr 保证是一个字符串，后续代码可以安全执行
            const plainText = textStr.replace(/<[^>]*>/g, '');
            const cleanText = plainText.replace(/\s+/g, ' ').trim();
            
            if (cleanText.length <= maxLength) {
                return cleanText;
            }
            
            return cleanText.substring(0, maxLength) + '...';
        }

        // 添加单个消息并应用动画效果
        function addMessageWithAnimation(message, characterId) {
            const messagesContainer = document.getElementById('api-chat-messages');
            if (!messagesContainer || !currentChatCharacter || characterId !== currentChatCharacter.id) return;
            
            const chatSettings = getCurrentChatSettings();
            const typingIndicator = document.getElementById('typing-indicator');
            
            // 处理系统消息
            if (message.sender === 'system') {
                let systemElement;
                
                if (message.isPoke) {
                    const systemContainer = document.createElement('div');
                    systemContainer.className = 'poke-system-container';
                    const systemMessage = document.createElement('div');
                    systemMessage.className = 'poke-system-message';
                    systemMessage.textContent = message.content;
                    systemContainer.appendChild(systemMessage);
                    systemElement = systemContainer;
                } else if (message.type === 'recalled_message') {
                    const centerContainer = document.createElement('div');
                    centerContainer.style.display = 'flex';
                    centerContainer.style.justifyContent = 'center';
                    centerContainer.style.margin = '4px 0';
                    centerContainer.dataset.messageId = message.id;
                    
                    const recallElement = document.createElement('div');
                    recallElement.className = 'recalled-message';
                    
                    const lines = message.content.split('\n');
                    const mainText = lines[0];
                    const originalText = lines[1];
                    
                    recallElement.textContent = mainText;
                    
                    if (originalText && originalText.startsWith('原文：')) {
                        const originalDiv = document.createElement('div');
                        originalDiv.className = 'original-text';
                        originalDiv.textContent = originalText;
                        recallElement.appendChild(originalDiv);
                    }
                    
                    centerContainer.appendChild(recallElement);
                    systemElement = centerContainer;
                    addMessageLongPressListener(centerContainer, message.id);
                } else {
                    const centerContainer = document.createElement('div');
                    centerContainer.style.display = 'flex';
                    centerContainer.style.justifyContent = 'center';
                    centerContainer.style.margin = '4px 0';
                    
                    const systemContainer = document.createElement('div');
                    systemContainer.className = 'system-message';
                    systemContainer.textContent = message.content;
                    
                    centerContainer.appendChild(systemContainer);
                    systemElement = centerContainer;
                }
                
                // 为系统消息添加滑入动画
                systemElement.style.opacity = '0';
                systemElement.style.transform = 'translateY(20px)';
                
                messagesContainer.insertBefore(systemElement, typingIndicator);
                
                // 触发动画
                requestAnimationFrame(() => {
                    systemElement.classList.add('message-slide-in');
                });
                
                return;
            }
            
            // 创建普通消息容器
            let messageContainer = document.createElement('div');
            const isEmojiOnly = message.isEmoji && !message.content;
            messageContainer.className = `message-container ${message.sender}${chatSettings.hideAvatars ? ' no-avatar' : ''}${isEmojiOnly ? ' emoji-only' : ''}`;
            messageContainer.dataset.messageId = message.id;
            
            if (message.sender === 'received') {
                // ==== 群聊支持 ====
                let character = characters.find(c => c.id === characterId);
                let isGroup = false;
                let group = null;
                if (!character) {
                    group = groupChats.find(g => g.id === characterId);
                    if (group) {
                        isGroup = true;
                    }
                }
                
                let displayAvatar = '';
                let displayName = '';
                let color = '#4CAF50';
                
                if (isGroup && group) {
                    // 群聊：根据消息的senderId或name查找成员
                    let member = null;
                    if (message.senderId) {
                        member = group.members.find(m => m.id === message.senderId);
                    } else if (message.name) {
                        member = group.members.find(m => m.name === message.name);
                    }
                    displayAvatar = member?.avatarUrl || '';
                    displayName = member?.name || '群成员';
                    color = member?.color || '#4CAF50';
                } else if (character) {
                    // 单聊
                    displayAvatar = chatSettings.aiDynamicAvatar || chatSettings.aiChatAvatar || character.avatarUrl;
                    displayName = chatSettings.aiChatNickname || character.name;
                    color = character.color || '#4CAF50';
                } else {
                    // 兜底，防止报错
                    displayAvatar = '';
                    displayName = '未知';
                    color = '#4CAF50';
                }
                const bubbleColor = chatSettings.aiBubbleColor || '#f0f0f0';
                const bubbleOpacity = chatSettings.aiBubbleOpacity || '1';
                const textColor = isLightColor(bubbleColor) ? '#333' : '#fff';
                const bubblePadding = chatSettings.bubblePadding || '12';
                
                // 处理特殊消息类型
                let messageContent = '';
                
                if (message.type === 'voice_message') {
                    // AI语音消息直接创建voice-message-container结构，不需要在这里创建messageContent
                    messageContent = '';
                } else if (message.type === 'ai_image') {
                    messageContent = `
                        <div class="ai-image-container">
                            <img src="${message.image}" class="message-image" onclick="showImage('${message.image}')" alt="AI生成的图片">
                            <div class="image-description">${message.imageDescription || ''}</div>
                        </div>
                    `;
                } else if (message.type === 'transfer') {
                    // 转账消息
                    const isUser = message.role === 'user';
                    const heartIcon = isUser ? '💕' : '💖';
                    const titleText = isUser ? '你发起的转账' : '收到转账';
                    let cardClass = '';
                    let statusHtml = '';
                    let clickHandler = '';
                    
                    if (message.status === 'accepted') {
                        statusHtml = `<div class="transfer-status">${isUser ? '对方已收款' : '已收款'}</div>`;
                        cardClass = 'accepted';
                    } else if (message.status === 'rejected') {
                        statusHtml = `<div class="transfer-status">${isUser ? '对方已退回' : '已退回'}</div>`;
                        cardClass = 'rejected';
                    } else if (!isUser) {
                        // AI发来的转账且未处理，添加点击处理
                        clickHandler = `onclick="showTransferConfirmDialog(${JSON.stringify(message).replace(/"/g, '&quot;')})"`;
                    }
                    
                    messageContent = `
                        <div class="transfer-message-container received">
                            <div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}" ${clickHandler}>
                                <div class="transfer-title">${heartIcon} ${titleText}</div>
                                <div class="transfer-amount">¥ ${Number(message.amount).toFixed(2)}</div>
                                <div class="transfer-note">${message.note || '转账'}</div>
                                ${statusHtml}
                            </div>
                        </div>
                    `;
                } else {
                    const chatMode = chatSettings.chatMode || 'online';
                    let processedContent = message.content;
                    
                    if (chatMode === 'offline') {
                        processedContent = processOfflineContent(message.content);
                    }
                    
                    messageContent = processedContent;
                }
                
                let avatarHtml = '';
                if (!chatSettings.hideAvatars) {
                    avatarHtml = `
                        <div class="message-avatar" style="background-color: ${color}; ${displayAvatar ? `background-image: url(${displayAvatar}); background-size: cover; background-position: center;` : ''}" ${character ? `onclick="pokeCharacter('${character.id}')" title="戳一戳"` : `title="${displayName}"`}>
                            ${displayAvatar ? '' : displayName.charAt(0)}
                        </div>
                    `;
                }
                
                const transparentBubbleColor = convertColorWithOpacity(bubbleColor, bubbleOpacity);
                
                let bubbleHtml = '';
                if (message.type === 'transfer') {
                    // 转账消息不需要气泡包裹
                    bubbleHtml = messageContent;
                } else {
                    // 普通消息用气泡包裹
                    bubbleHtml = `
                    <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                        ${messageContent}
                        ${message.image && !message.type ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}
                    </div>
                `;
                }
                
          // 🔥【修复】群聊昵称显示 （第三个渲染函数版本）- 特别处理语音消息和转账消息
          if (isGroup && group && displayName !== '群成员') {
    messageContainer.classList.add('group-message-item');
    const senderNameHtml = `<div class="sender-name">${displayName}</div>`;
    
    if (message.type === 'voice_message' || message.type === 'transfer') {
        // 🔥【修复】对于语音消息和转账消息，昵称需要在容器外部
    messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    } else {
        // 普通消息的处理
        messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    }
} else {
                messageContainer.innerHTML = avatarHtml + bubbleHtml;
}
                
                // 🔥【修复】如果是语音消息，按照renderChatMessages的结构创建，但要保留群聊昵称
                if (message.type === 'voice_message') {
                    // 过滤掉括号中的描述性内容，保留实际说话内容
                    const cleanVoiceContent = message.content.replace(/\([^)]*\)\s*/g, '').trim();
                    const duration = message.duration || Math.max(1, Math.ceil(cleanVoiceContent.length / 8));
                    const durationFormatted = duration < 60 ? `0:${String(duration).padStart(2, '0')}''` : `${Math.floor(duration/60)}:${String(duration%60).padStart(2, '0')}''`;
                    
                    const voiceMessageHTML = `
                        <div class="voice-message-container received">
                            <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                                <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${cleanVoiceContent}">
                                    <div class="voice-wave">
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                    </div>
                                    <div class="voice-duration">${durationFormatted}</div>
                                </div>
                            </div>
                            <div class="voice-text-content">${cleanVoiceContent}</div>
                        </div>
                    `;
                    
                    // 🔥【修复】保留群聊昵称显示
                    if (isGroup && group && displayName !== '群成员') {
                        const senderNameHtml = `<div class="sender-name">${displayName}</div>`;
                        messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${voiceMessageHTML}</div>`;
                    } else {
                    messageContainer.innerHTML = avatarHtml + voiceMessageHTML;
                    }
                }
            } else {
                // 用户消息
                let myDisplayAvatar = chatSettings.myChatAvatar;
                
                if (!myDisplayAvatar && chatSettings.selectedIdentityId) {
                    const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                    if (selectedPersona && selectedPersona.avatarUrl) {
                        myDisplayAvatar = selectedPersona.avatarUrl;
                    }
                }
                
                const myBubbleColor = chatSettings.myBubbleColor || '#007AFF';
                const myBubbleOpacity = chatSettings.myBubbleOpacity || '1';
                const myTextColor = isLightColor(myBubbleColor) ? '#333' : '#fff';
                const myBubblePadding = chatSettings.bubblePadding || '12';
                
                const transparentMyBubbleColor = convertColorWithOpacity(myBubbleColor, myBubbleOpacity);
                
                let myBubbleHtml = '';
                if (message.type === 'voice') {
                    const duration = message.duration || Math.max(1, Math.ceil(message.content.length / 8));
                    
                    myBubbleHtml = `
                        <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                            <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${message.content}">
                                <div class="voice-wave">
                                    <div class="wave-bar"></div>
                                    <div class="wave-bar"></div>
                                    <div class="wave-bar"></div>
                                    <div class="wave-bar"></div>
                                    <div class="wave-bar"></div>
                                </div>
                                <div class="voice-duration">${duration}"</div>
                            </div>
                        </div>
                    `;
                } else if (message.type === 'location') {
                    // 位置消息
                    myBubbleHtml = `
                        <div class="location-card" onclick="showLocationDetail('${message.locationName}')">
                            <div class="location-title">${message.locationName}</div>
                            <div class="location-card-map">
                                ${generateRealisticMapHTML()}
                            </div>
                        </div>
                    `;
                } else if (message.type === 'transfer') {
                    // 用户转账消息
                    let cardClass = '';
                    let statusHtml = '';
                    
                    if (message.status === 'accepted') {
                        statusHtml = `<div class="transfer-status">对方已收款</div>`;
                        cardClass = 'accepted';
                    } else if (message.status === 'rejected') {
                        statusHtml = `<div class="transfer-status">对方已退回</div>`;
                        cardClass = 'rejected';
                    }
                    
                    myBubbleHtml = `
                        <div class="transfer-message-container sent">
                            <div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}">
                                <div class="transfer-title">💕 你发起的转账</div>
                                <div class="transfer-amount">¥ ${Number(message.amount).toFixed(2)}</div>
                                <div class="transfer-note">${message.note || '转账'}</div>
                                ${statusHtml}
                            </div>
                        </div>
                    `;
                } else {
                    // 🔥【修复】处理多模态消息或普通文本消息 (第三个渲染函数版本)
                    let messageContentStr = '';
                    if (Array.isArray(message.content)) {
                        // 新的多模态格式
                        const textPart = message.content.find(p => p.type === 'text');
                        const imagePart = message.content.find(p => p.type === 'image_url');
                        
                        messageContentStr = textPart?.text || '';
                        
                        // 如果有图片，添加图片显示
                        if (imagePart?.image_url?.url) {
                            if (messageContentStr) {
                                messageContentStr += '<br>';
                            }
                            messageContentStr += `<img src="${imagePart.image_url.url}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${imagePart.image_url.url}')">`;
                        }
                    } else {
                        // 普通文本消息或旧格式
                        messageContentStr = message.content;
                    }
                    
                    myBubbleHtml = `
                    <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                        ${messageContentStr}
                        ${message.image && !Array.isArray(message.content) ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}
                    </div>
                `;
                }
                
                let myAvatarHtml = '';
                if (!chatSettings.hideAvatars) {
                    myAvatarHtml = `
                        <div class="message-avatar" style="background-color: #007AFF; ${myDisplayAvatar ? `background-image: url(${myDisplayAvatar}); background-size: cover; background-position: center;` : ''}">
                            ${myDisplayAvatar ? '' : '<i class="fas fa-user"></i>'}
                        </div>
                    `;
                }
                
                messageContainer.innerHTML = myBubbleHtml + myAvatarHtml;
                
                // 如果是语音消息，按照renderChatMessages的结构创建
                if (message.type === 'voice') {
                    // 创建完整的语音消息HTML，和renderChatMessages保持一致
                    const voiceMessageHTML = `
                        <div class="voice-message-container sent">
                            <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                                <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${message.content}">
                                    <div class="voice-wave">
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                    </div>
                                    <div class="voice-duration">${message.duration || Math.max(1, Math.ceil(message.content.length / 8))}"</div>
                                </div>
                            </div>
                            <div class="voice-text-content">${message.content}</div>
                        </div>
                    `;
                    
                    messageContainer.innerHTML = voiceMessageHTML + myAvatarHtml;
                }
                
                // 如果是位置消息，按照renderChatMessages的结构创建
                if (message.type === 'location') {
                    // 创建完整的位置消息HTML，确保不被包装在气泡中
                    const locationMessageHTML = `
                        <div class="location-card" onclick="showLocationDetail('${message.locationName}')">
                            <div class="location-title">${message.locationName}</div>
                            <div class="location-card-map">
                                ${generateRealisticMapHTML()}
                            </div>
                        </div>
                    `;
                    
                    messageContainer.innerHTML = locationMessageHTML + myAvatarHtml;
                }
            }
            
            // 添加滑入动画效果 - 简单自然的滑入
            messageContainer.style.opacity = '0';
            messageContainer.style.transform = 'translateY(20px)';
            
            messagesContainer.insertBefore(messageContainer, typingIndicator);
            
            // 触发滑入动画
            requestAnimationFrame(() => {
                messageContainer.classList.add('message-slide-in');
            });
            
            // 添加长按监听器
            addMessageLongPressListener(messageContainer, message.id);
            
            // 添加右键菜单功能
            const bubble = messageContainer.querySelector('.message-bubble');
            if (bubble) {
                bubble.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showMessageMenu(message.id, e);
                });
                
                bubble.onclick = (e) => {
                    if (e.target.tagName === 'IMG' && e.target.classList.contains('message-image')) {
                        showImage(e.target.src);
                    }
                };
            }
            
            // 滚动到底部
            setTimeout(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }, 100);
        }
        
        // 将颜色和透明度转换为rgba格式
        function convertColorWithOpacity(color, opacity) {
            // 如果颜色已经是rgba格式，直接返回
            if (color.startsWith('rgba')) {
                return color;
            }
            
            // 如果是十六进制颜色，转换为rgba
            if (color.startsWith('#')) {
                const hex = color.slice(1);
                const r = parseInt(hex.substring(0, 2), 16);
                const g = parseInt(hex.substring(2, 4), 16);
                const b = parseInt(hex.substring(4, 6), 16);
                return `rgba(${r}, ${g}, ${b}, ${opacity})`;
            }
            
            // 如果是rgb格式，转换为rgba
            if (color.startsWith('rgb(')) {
                const rgbValues = color.match(/\d+/g);
                return `rgba(${rgbValues[0]}, ${rgbValues[1]}, ${rgbValues[2]}, ${opacity})`;
            }
            
            // 如果是颜色名称，尝试转换（简单实现）
            const colorMap = {
                'red': '255, 0, 0',
                'green': '0, 128, 0',
                'blue': '0, 0, 255',
                'white': '255, 255, 255',
                'black': '0, 0, 0',
                'gray': '128, 128, 128',
                'yellow': '255, 255, 0',
                'cyan': '0, 255, 255',
                'magenta': '255, 0, 255'
            };
            
            if (colorMap[color.toLowerCase()]) {
                return `rgba(${colorMap[color.toLowerCase()]}, ${opacity})`;
            }
            
            // 如果无法识别，返回原色加透明度（作为备用）
            return color;
        }

        // 字体大小设置功能
        function changeFontSize(size) {
            const fontSize = parseInt(size);
            
            // 更新预览文字
            const preview = document.getElementById('font-size-preview');
            const valueDisplay = document.getElementById('font-size-value');
            
            if (preview) {
                preview.style.fontSize = fontSize + 'px';
            }
            
            if (valueDisplay) {
                valueDisplay.textContent = fontSize + 'px';
            }
            
            // 创建或更新全局字体大小CSS变量
            document.documentElement.style.setProperty('--global-font-size', fontSize + 'px');
            
            // 应用到聊天消息
            applyFontSizeToMessages(fontSize);
            
            // 应用到社交动态
            applyFontSizeToMoments(fontSize);
            
            // 如果当前有聊天角色，重新渲染消息以确保新字体大小生效
            if (currentChatCharacter && typeof renderChatMessages === 'function') {
                setTimeout(() => {
                    renderChatMessages(currentChatCharacter.id);
                }, 100);
            }
            
            // 保存设置
            localStorage.setItem('globalFontSize', fontSize);
            
            // 显示成功提示
            showToast('字号设置已保存并应用！', 'success');
        }
        
        // 字距设置功能
        function changeLetterSpacing(spacing) {
            const letterSpacing = parseFloat(spacing);
            
            // 更新预览文字
            const preview = document.getElementById('font-size-preview');
            const valueDisplay = document.getElementById('letter-spacing-value');
            
            if (preview) {
                preview.style.letterSpacing = letterSpacing + 'px';
            }
            
            if (valueDisplay) {
                // 根据数值显示对应的文字描述
                let description;
                if (letterSpacing < -0.2) {
                    description = '很紧凑';
                } else if (letterSpacing < 0.2) {
                    description = '标准';
                } else if (letterSpacing < 0.8) {
                    description = '舒适';
                } else if (letterSpacing < 1.5) {
                    description = '宽松';
                } else {
                    description = '很宽松';
                }
                valueDisplay.textContent = `${description} (${letterSpacing}px)`;
            }
            
            // 创建或更新全局字距CSS变量
            document.documentElement.style.setProperty('--global-letter-spacing', letterSpacing + 'px');
            
            // 应用到聊天消息
            applyLetterSpacingToMessages(letterSpacing);
            
            // 应用到社交动态
            applyLetterSpacingToMoments(letterSpacing);
            
            // 如果当前有聊天角色，重新渲染消息以确保新字距生效
            if (currentChatCharacter && typeof renderChatMessages === 'function') {
                setTimeout(() => {
                    renderChatMessages(currentChatCharacter.id);
                }, 100);
            }
            
            // 保存设置
            localStorage.setItem('globalLetterSpacing', letterSpacing);
            
            // 显示成功提示
            showToast('字距设置已保存并应用！', 'success');
        }
        
        function applyFontSizeToMessages(fontSize) {
            // 应用到所有聊天消息，使用!important强制覆盖内联样式
            const messageBubbles = document.querySelectorAll('.message-bubble');
            messageBubbles.forEach(bubble => {
                bubble.style.setProperty('font-size', fontSize + 'px', 'important');
            });
            
            // 应用到聊天输入框
            const chatInput = document.getElementById('api-chat-input');
            if (chatInput) {
                chatInput.style.fontSize = fontSize + 'px';
            }
        }
        
        function applyFontSizeToMoments(fontSize) {
            // 应用到微博动态内容
            const postContents = document.querySelectorAll('.post-content');
            postContents.forEach(content => {
                content.style.fontSize = fontSize + 'px';
            });
            
            // 应用到微博输入框
            const weiboTextarea = document.getElementById('weibo-text');
            if (weiboTextarea) {
                weiboTextarea.style.fontSize = fontSize + 'px';
            }
        }
        
        function applyLetterSpacingToMessages(letterSpacing) {
            // 应用到所有聊天消息
            const messageBubbles = document.querySelectorAll('.message-bubble');
            messageBubbles.forEach(bubble => {
                bubble.style.setProperty('letter-spacing', letterSpacing + 'px', 'important');
            });
            
            // 应用到聊天输入框
            const chatInput = document.getElementById('api-chat-input');
            if (chatInput) {
                chatInput.style.letterSpacing = letterSpacing + 'px';
            }
        }
        
        function applyLetterSpacingToMoments(letterSpacing) {
            // 应用到微博动态内容
            const postContents = document.querySelectorAll('.post-content');
            postContents.forEach(content => {
                content.style.letterSpacing = letterSpacing + 'px';
            });
            
            // 应用到微博输入框
            const weiboTextarea = document.getElementById('weibo-text');
            if (weiboTextarea) {
                weiboTextarea.style.letterSpacing = letterSpacing + 'px';
            }
        }
        
        function toggleAutoScale() {
            const toggle = document.getElementById('auto-scale-toggle');
            const isEnabled = toggle.checked;
            
            // 保存自动缩放设置
            localStorage.setItem('autoScaleFont', isEnabled);
            
            if (isEnabled) {
                // 根据屏幕尺寸自动调整字体
                autoAdjustFontSize();
                showToast('字体自动缩放已开启！', 'success');
            } else {
                showToast('字体自动缩放已关闭！', 'success');
            }
        }
        
        function autoAdjustFontSize() {
            const phoneScreen = document.getElementById('phone-screen');
            if (!phoneScreen) return;
            
            const screenWidth = parseInt(phoneScreen.style.width) || 350;
            
            // 根据屏幕宽度计算推荐字体大小
            let recommendedSize = 15; // 默认大小
            
            if (screenWidth <= 320) {
                recommendedSize = 13; // 小屏幕用小字体
            } else if (screenWidth <= 350) {
                recommendedSize = 14;
            } else if (screenWidth <= 375) {
                recommendedSize = 15;
            } else if (screenWidth <= 390) {
                recommendedSize = 16;
            } else {
                recommendedSize = 17; // 大屏幕用大字体
            }
            
            // 更新滑块和应用字体大小
            const slider = document.getElementById('font-size-slider');
            if (slider) {
                slider.value = recommendedSize;
                changeFontSize(recommendedSize);
            }
        }
        
        function loadFontSizeSettings() {
            // 加载字体大小设置
            const savedSize = localStorage.getItem('globalFontSize');
            const fontSize = savedSize ? parseInt(savedSize) : 15;
            
            const slider = document.getElementById('font-size-slider');
            const preview = document.getElementById('font-size-preview');
            const valueDisplay = document.getElementById('font-size-value');
            
            if (slider) {
                slider.value = fontSize;
            }
            
            if (preview) {
                preview.style.fontSize = fontSize + 'px';
            }
            
            if (valueDisplay) {
                valueDisplay.textContent = fontSize + 'px';
            }
            
            // 应用字体大小
            document.documentElement.style.setProperty('--global-font-size', fontSize + 'px');
            
            // 加载字距设置
            const savedSpacing = localStorage.getItem('globalLetterSpacing');
            const letterSpacing = savedSpacing ? parseFloat(savedSpacing) : 0;
            
            const spacingSlider = document.getElementById('letter-spacing-slider');
            const spacingValueDisplay = document.getElementById('letter-spacing-value');
            
            if (spacingSlider) {
                spacingSlider.value = letterSpacing;
            }
            
            if (preview) {
                preview.style.letterSpacing = letterSpacing + 'px';
            }
            
            if (spacingValueDisplay) {
                // 根据数值显示对应的文字描述
                let description;
                if (letterSpacing < -0.2) {
                    description = '很紧凑';
                } else if (letterSpacing < 0.2) {
                    description = '标准';
                } else if (letterSpacing < 0.8) {
                    description = '舒适';
                } else if (letterSpacing < 1.5) {
                    description = '宽松';
                } else {
                    description = '很宽松';
                }
                spacingValueDisplay.textContent = `${description} (${letterSpacing}px)`;
            }
            
            // 应用字距
            document.documentElement.style.setProperty('--global-letter-spacing', letterSpacing + 'px');
            
            // 延迟应用，确保DOM元素已经加载
            setTimeout(() => {
                applyFontSizeToMessages(fontSize);
                applyFontSizeToMoments(fontSize);
                applyLetterSpacingToMessages(letterSpacing);
                applyLetterSpacingToMoments(letterSpacing);
            }, 500);
            
            // 加载自动缩放设置
            const autoScale = localStorage.getItem('autoScaleFont');
            const autoScaleToggle = document.getElementById('auto-scale-toggle');
            if (autoScaleToggle) {
                autoScaleToggle.checked = autoScale === 'true';
            }
        }



        // 工具栏功能
        function triggerVoiceMessage() {
            showToast('语音功能开发中...', 'info');
            // 这里可以添加语音录制功能
        }

        // 聊天界面拍照功能 - 文字描述图片发送给AI
        async function openCamera() {
            if (!currentChatCharacter) {
                showToast('请先选择一个聊天对象', 'error');
                return;
            }
            
            const description = await showCustomPrompt("发送照片", "请用文字描述您要发送的照片：");
            if (description && description.trim()) {
                const msg = {
                    id: Date.now().toString(),
                    sender: 'sent',
                    type: 'user_photo',
                    content: description.trim(),
                    timestamp: Date.now(),
                    photoDescription: description.trim() // 保存原始描述用于点击查看
                };
                
                // 添加到聊天记录
                if (!chatMessages[currentChatCharacter.id]) {
                    chatMessages[currentChatCharacter.id] = [];
                }
                chatMessages[currentChatCharacter.id].push(msg);
                await saveChatMessages();
                
                // 刷新界面
                renderChatMessages(currentChatCharacter.id);
                renderMessageList();
                
                showToast('照片已发送', 'success');
            }
        }

        function openTransfer() {
            // 检查是否有当前聊天角色
            if (!currentChatCharacter) {
                showToast('请先选择聊天对象', 'warning');
                return;
            }
            
            // 显示转账对话框
            document.getElementById('transfer-modal').classList.add('visible');
        }

        function makeCall() {
            showToast('电话功能开发中...', 'info');
            // 这里可以添加电话功能
        }

        function openVideoCall() {
            showToast('视频通话功能开发中...', 'info');
            // 这里可以添加视频通话功能
        }

        function shareLocation() {
            if (!currentChatCharacter) {
                alert('请先选择一个角色');
                return;
            }
            
            // 重置输入框
            document.getElementById('location-address').value = '';
            document.getElementById('map-location-display').textContent = '请输入位置名称';
            
            // 随机化地图显示
            randomizeMapPosition();
            
            // 加载历史记录
            renderLocationHistory();
            
            // 显示模态框
            document.getElementById('location-modal').style.display = 'flex';
        }

        function hideLocationModal() {
            document.getElementById('location-modal').style.display = 'none';
        }

        function setLocationAddress(address) {
            document.getElementById('location-address').value = address;
            document.getElementById('map-location-display').textContent = address;
            
            // 生成随机坐标
            const lat = (39.8 + Math.random() * 0.4).toFixed(4);
            const lng = (116.2 + Math.random() * 0.4).toFixed(4);
            document.querySelector('.map-coordinates').textContent = `${lng}°E, ${lat}°N`;
        }

        function randomizeMapPosition() {
            const marker = document.getElementById('location-marker');
            const buildings = document.querySelectorAll('.building');
            
            // 随机移动标记位置
            const newTop = 20 + Math.random() * 60; // 20% - 80%
            const newLeft = 20 + Math.random() * 60; // 20% - 80%
            marker.style.top = newTop + '%';
            marker.style.left = newLeft + '%';
            
            // 随机移动建筑物
            buildings.forEach(building => {
                const top = Math.random() * 85; // 0% - 85%
                const left = Math.random() * 85; // 0% - 85%
                building.style.top = top + '%';
                building.style.left = left + '%';
            });
            
            // 更新坐标
            const lat = (39.8 + Math.random() * 0.4).toFixed(4);
            const lng = (116.2 + Math.random() * 0.4).toFixed(4);
            document.querySelector('.map-coordinates').textContent = `${lng}°E, ${lat}°N`;
        }

        // 生成逼真的地图HTML内容
        function generateRealisticMapHTML() {
            return `
                <div class="map-background"></div>
                <!-- 弯曲河流 -->
                <div class="river" style="top: 5%; left: 60%; width: 20px; height: 3px; transform: rotate(35deg);"></div>
                <div class="river-curve" style="top: 12%; left: 72%; width: 18px; height: 3px; transform: rotate(15deg);"></div>
                <div class="river" style="top: 18%; left: 80%; width: 16px; height: 3px; transform: rotate(-5deg);"></div>
                <div class="river-curve" style="top: 22%; left: 85%; width: 15px; height: 3px; transform: rotate(-25deg);"></div>
                <div class="river" style="top: 55%; left: 2%; width: 22px; height: 3px; transform: rotate(-10deg);"></div>
                <div class="river-curve" style="top: 62%; left: 18%; width: 20px; height: 3px; transform: rotate(8deg);"></div>
                <div class="river" style="top: 68%; left: 32%; width: 18px; height: 3px; transform: rotate(25deg);"></div>
                <!-- 公园绿地 -->
                <div class="park" style="top: 20%; left: 65%; width: 18px; height: 15px;"></div>
                <div class="park" style="top: 45%; left: 10%; width: 22px; height: 18px;"></div>
                <!-- 道路 -->
                <div class="map-roads">
                    <div class="road road-horizontal" style="top: 35%; width: 100%;"></div>
                    <div class="road road-vertical" style="left: 40%; height: 100%;"></div>
                    <div class="road road-horizontal" style="top: 65%; width: 70%; left: 30%;"></div>
                </div>
                <!-- 建筑物 -->
                <div class="map-buildings">
                    <div class="building house" style="top: 15%; left: 20%; width: 12px; height: 10px;"></div>
                    <div class="building office" style="top: 25%; left: 45%; width: 8px; height: 16px;"></div>
                    <div class="building shop" style="top: 50%; left: 50%; width: 14px; height: 8px;"></div>
                    <div class="building house" style="top: 70%; left: 75%; width: 10px; height: 8px;"></div>
                    <div class="building office" style="top: 8%; left: 85%; width: 6px; height: 12px;"></div>
                </div>
                <!-- 树木 -->
                <div class="tree big" style="top: 25%; left: 15%; width: 6px; height: 6px;"></div>
                <div class="tree small" style="top: 55%; left: 25%; width: 4px; height: 4px;"></div>
                <div class="tree big" style="top: 10%; left: 70%; width: 5px; height: 5px;"></div>
                <div class="tree small" style="top: 75%; left: 85%; width: 3px; height: 3px;"></div>
                <div class="tree small" style="top: 40%; left: 80%; width: 4px; height: 4px;"></div>
                <!-- 位置标记 -->
                <div class="map-marker">
                    <div class="marker-pin" style="color: #1890ff;">📍</div>
                </div>
            `;
        }

        // 历史地点管理
        let locationHistory = JSON.parse(localStorage.getItem('locationHistory') || '[]');

        function saveLocationHistory() {
            localStorage.setItem('locationHistory', JSON.stringify(locationHistory));
        }

        function addToLocationHistory(locationName) {
            if (!locationName.trim()) return;
            
            // 移除重复项
            locationHistory = locationHistory.filter(name => name !== locationName);
            // 添加到开头
            locationHistory.unshift(locationName);
            // 限制最多保存10个
            if (locationHistory.length > 10) {
                locationHistory = locationHistory.slice(0, 10);
            }
            
            saveLocationHistory();
            renderLocationHistory();
        }

        function removeFromLocationHistory(locationName) {
            locationHistory = locationHistory.filter(name => name !== locationName);
            saveLocationHistory();
            renderLocationHistory();
        }

        function renderLocationHistory() {
            const container = document.getElementById('location-history-items');
            if (!container) return;

            if (locationHistory.length === 0) {
                container.innerHTML = '<div class="location-history-empty">暂无历史记录</div>';
                return;
            }

            container.innerHTML = locationHistory.map(location => 
                `<div class="location-history-item" data-location="${location}" onclick="setLocationAddress('${location}')">
                    <span class="location-text">${location}</span>
                    <span class="delete-btn" onclick="event.stopPropagation(); confirmDeleteLocation('${location}')" title="删除">×</span>
                </div>`
            ).join('');
        }

        // 长按删除处理
        let touchTimer = null;
        let touchedElement = null;

        function handleLocationTouchStart(event, location) {
            touchedElement = event.target;
            touchTimer = setTimeout(() => {
                confirmDeleteLocation(location);
            }, 800); // 800ms长按
        }

        function handleLocationTouchEnd(event) {
            if (touchTimer) {
                clearTimeout(touchTimer);
                touchTimer = null;
            }
            if (touchedElement) {
                touchedElement.classList.remove('deleting');
                touchedElement = null;
            }
        }

        function confirmDeleteLocation(location) {
            if (touchedElement) {
                touchedElement.classList.add('deleting');
            }
            
            if (confirm(`确定要删除位置"${location}"吗？`)) {
                removeFromLocationHistory(location);
                showToast('位置已删除', 'success');
            } else if (touchedElement) {
                touchedElement.classList.remove('deleting');
            }
        }

        function sendLocationMessage() {
            const address = document.getElementById('location-address').value.trim();
            if (!address) {
                alert('请输入位置名称');
                return;
            }

            // 添加到历史记录
            addToLocationHistory(address);

            // 创建位置消息
            const locationMessage = {
                id: Date.now().toString(),
                sender: 'sent',
                type: 'location',
                locationName: address,
                coordinates: document.querySelector('.map-coordinates').textContent,
                content: `[用户分享了位置信息：${address}，坐标：${document.querySelector('.map-coordinates').textContent}]`,
                timestamp: Date.now()
            };

            console.log('🗺️ 创建位置消息:', locationMessage);
            
            // 🔥【调试】检查消息数据
            if (!locationMessage.locationName || !locationMessage.coordinates) {
                console.error('❌ 位置消息数据不完整:', {
                    locationName: locationMessage.locationName,
                    coordinates: locationMessage.coordinates
                });
                alert('位置信息不完整，请重试');
                return;
            }

            // 添加到聊天记录
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            chatMessages[currentChatCharacter.id].push(locationMessage);

            // 保存到数据库
            saveChatMessages();

            // 使用动画添加消息而不是重新渲染整个列表
            addMessageWithAnimation(locationMessage, currentChatCharacter.id);

            // 设置为待回复消息
            pendingUserMessage = locationMessage;

            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = '点击获取AI回复';
            }

            // 更新联系人列表
            renderMessageList();

            // 关闭模态框
            hideLocationModal();

            showToast('位置已分享', 'success');
        }

        // 更新已存在的位置卡片地图
        function updateExistingLocationMaps() {
            const locationMaps = document.querySelectorAll('.location-card-map');
            locationMaps.forEach(mapElement => {
                // 检查是否需要更新（没有新的地图元素）
                if (!mapElement.querySelector('.river')) {
                    mapElement.innerHTML = generateRealisticMapHTML();
                }
            });
        }

        // 监听位置输入框的变化
        document.addEventListener('DOMContentLoaded', function() {
            const locationInput = document.getElementById('location-address');
            if (locationInput) {
                locationInput.addEventListener('input', function() {
                    const value = this.value.trim();
                    if (value) {
                        document.getElementById('map-location-display').textContent = value;
                        
                        // 生成随机坐标
                        const lat = (39.8 + Math.random() * 0.4).toFixed(4);
                        const lng = (116.2 + Math.random() * 0.4).toFixed(4);
                        document.querySelector('.map-coordinates').textContent = `${lng}°E, ${lat}°N`;
                    } else {
                        document.getElementById('map-location-display').textContent = '请输入位置名称';
                    }
                });
            }
            
            // 点击模态框背景关闭
            document.getElementById('location-modal')?.addEventListener('click', (e) => {
                if (e.target === document.getElementById('location-modal')) {
                    hideLocationModal();
                }
            });

            // 定期更新现有的位置卡片地图
            setInterval(updateExistingLocationMaps, 1000);
        });

        // 显示位置详情
        function showLocationDetail(locationName) {
            alert(`📍 ${locationName}`);
        }
 
        // 📊 数据管理相关函数
        
        // 计算存储空间使用情况
        async function calculateStorageUsage() {
            try {
                let chatSize = 0, characterSize = 0, settingsSize = 0, emojiSize = 0;

                const [chatData, charData, settingsData, emojiData] = await Promise.all([
                    db.chatMessages.toArray(),
                    db.characters.toArray(), 
                    db.chatSettings.toArray(),
                    db.customEmojis.toArray()
                ]);

                chatSize = JSON.stringify(chatData).length;
                characterSize = JSON.stringify(charData).length;
                settingsSize = JSON.stringify(settingsData).length;
                emojiSize = JSON.stringify(emojiData).length;
                const total = chatSize + characterSize + settingsSize + emojiSize;

                // 更新显示
                const formatBytes = (bytes) => {
                    if (bytes === 0) return '0 B';
                    const k = 1024;
                    const sizes = ['B', 'KB', 'MB', 'GB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                };

                if (document.getElementById('chat-storage-size')) {
                    document.getElementById('chat-storage-size').textContent = formatBytes(chatSize);
                    document.getElementById('character-storage-size').textContent = formatBytes(characterSize);
                    document.getElementById('settings-storage-size').textContent = formatBytes(settingsSize);
                    document.getElementById('emoji-storage-size').textContent = formatBytes(emojiSize);
                    document.getElementById('total-storage-size').textContent = formatBytes(total);
                }
            } catch (error) {
                console.error('计算存储失败:', error);
            }
        }

        // 导出所有数据
        async function exportAllData() {
            try {
                showToast('正在导出数据...', 'info');
                const exportData = {
                    version: '1.0',
                    exportTime: new Date().toISOString(),
                    characters: await db.characters.toArray(),
                    chatMessages: await db.chatMessages.toArray(),
                    chatSettings: await db.chatSettings.toArray(),
                    customEmojis: await db.customEmojis.toArray()
                };

                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `chat_backup_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                showToast('导出成功！', 'success');
            } catch (error) {
                console.error('导出失败:', error);
                showToast('导出失败', 'error');
            }
        }

        // 导入数据
        function importDataFromFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async function(e) {
                const file = e.target.files[0];
                if (!file) return;
                try {
                    showToast('正在导入...', 'info');
                    const text = await file.text();
                    const data = JSON.parse(text);
                    if (!confirm('导入将覆盖现有数据，确定继续？')) return;
                    
                    if (data.characters?.length) {
                        await db.characters.clear();
                        await db.characters.bulkAdd(data.characters);
                    }
                    if (data.chatMessages?.length) {
                        await db.chatMessages.clear();
                        await db.chatMessages.bulkAdd(data.chatMessages);
                    }
                    if (data.chatSettings?.length) {
                        await db.chatSettings.clear();
                        await db.chatSettings.bulkAdd(data.chatSettings);
                    }
                    
                    await loadCharacters();
                    await loadChatMessages();
                    await loadChatSettings();
                    renderCharacterList();
                    renderMessageList();
                    calculateStorageUsage();
                    showToast('导入成功！', 'success');
                } catch (error) {
                    showToast('导入失败：' + error.message, 'error');
                }
            };
            input.click();
        }

        // 显示清理选项
        function showCleanupOptions() {
            const choice = prompt('选择清理项目：\n1. 清除动态头像\n2. 删除空聊天记录\n3. 清理localStorage\n4. 压缩图片\n\n输入数字（逗号分隔）：');
            if (choice) executeCleanupOptions(choice);
        }

        // 执行清理
        async function executeCleanupOptions(choice) {
            const selections = choice.split(',').map(s => parseInt(s.trim())).filter(n => n >= 1 && n <= 4);
            if (!selections.length) return;
            
            showToast('清理中...', 'info');
            let count = 0;
            
            for (const option of selections) {
                switch (option) {
                    case 1:
                        Object.keys(chatSettings).forEach(id => {
                            if (chatSettings[id]?.aiDynamicAvatar) {
                                delete chatSettings[id].aiDynamicAvatar;
                                count++;
                            }
                        });
                        break;
                    case 2:
                        Object.keys(chatMessages).forEach(id => {
                            if (!chatMessages[id]?.length) {
                                delete chatMessages[id];
                                count++;
                            }
                        });
                        break;
                    case 3:
                        for (let i = localStorage.length - 1; i >= 0; i--) {
                            const key = localStorage.key(i);
                            if (key?.startsWith('chatSettings_')) {
                                localStorage.removeItem(key);
                                count++;
                            }
                        }
                        break;
                    case 4:
                        await compressAllImages();
                        break;
                }
            }
            
            await saveChatSettings();
            await saveChatMessages();
            calculateStorageUsage();
            showToast(`清理完成！处理 ${count} 项`, 'success');
        }

        // 压缩图片
        async function compressAllImages() {
            showToast('压缩中...', 'info');
            let count = 0;
            
            // 压缩角色头像
            for (const char of characters) {
                if (char.avatarUrl?.length > 50000) {
                    char.avatarUrl = await compressImage(char.avatarUrl, 150, 0.6);
                    count++;
                }
            }
            await saveCharacters();
            
            // 压缩设置中的头像
            for (const id of Object.keys(chatSettings)) {
                const settings = chatSettings[id];
                if (settings?.aiChatAvatar?.length > 50000) {
                    settings.aiChatAvatar = await compressImage(settings.aiChatAvatar, 150, 0.6);
                    count++;
                }
                if (settings?.myChatAvatar?.length > 50000) {
                    settings.myChatAvatar = await compressImage(settings.myChatAvatar, 150, 0.6);
                    count++;
                }
            }
            await saveChatSettings();
            calculateStorageUsage();
            showToast(`压缩完成！处理 ${count} 张图片`, 'success');
        }

        // 调试用：列出所有角色ID和名称，帮助识别幽灵角色
        async function debugListAllCharacters() {
            try {
                console.log('=== 所有角色数据 ===');
                
                // 1. 数据库中的角色
                const dbChars = await db.characters.toArray();
                console.log('数据库角色表:', dbChars.map(c => `${c.name} (ID: ${c.id})`));
                
                // 2. 内存中的角色
                if (window.characters) {
                    console.log('内存角色列表:', window.characters.map(c => `${c.name} (ID: ${c.id})`));
                }
                
                // 3. 联系人列表
                if (window.contacts) {
                    console.log('联系人ID列表:', window.contacts);
                }
                
                // 4. 动态评论中的角色
                const comments = await db.momentComments.toArray();
                const commentAuthors = [...new Set(comments.map(c => `${c.nickname} (ID: ${c.authorId})`))];
                console.log('动态评论中的角色:', commentAuthors);
                
                // 5. 动态点赞中的角色
                const likes = await db.momentLikes.toArray();
                const likeAuthors = [...new Set(likes.map(l => `${l.name} (ID: ${l.authorId})`))];
                console.log('动态点赞中的角色:', likeAuthors);
                
                return {dbChars, comments, likes};
            } catch (error) {
                console.error('调试失败:', error);
            }
        }
        
        // 调试用：精确删除指定ID的角色数据
        async function debugDeleteCharacterById(characterId) {
            if (!characterId) {
                console.log('用法: debugDeleteCharacterById("角色ID")');
                return;
            }
            
            try {
                console.log(`开始删除角色ID: ${characterId}`);
                let deleteCount = 0;
                
                // 1. 从动态评论中删除
                const comments = await db.momentComments.where('authorId').equals(characterId).toArray();
                for (const comment of comments) {
                    await db.momentComments.delete(comment.id);
                    deleteCount++;
                    console.log(`删除评论: ${comment.nickname} - ${comment.text}`);
                }
                
                // 2. 从动态点赞中删除
                const likes = await db.momentLikes.where('authorId').equals(characterId).toArray();
                for (const like of likes) {
                    await db.momentLikes.delete([like.momentId, like.authorId]);
                    deleteCount++;
                    console.log(`删除点赞: ${like.name}`);
                }
                
                // 3. 从其他表中删除
                const chatMsgs = await db.chatMessages.where('characterId').equals(characterId).toArray();
                for (const msg of chatMsgs) {
                    await db.chatMessages.delete(msg.id);
                    deleteCount++;
                }
                
                const chatSets = await db.chatSettings.toArray();
                for (const setting of chatSets) {
                    if (setting.characterId === characterId) {
                        await db.chatSettings.delete(setting.id);
                        deleteCount++;
                    }
                }
                
                await db.characters.delete(characterId);
                deleteCount++;
                
                // 4. 从内存数组中删除
                if (window.contacts) {
                    window.contacts = window.contacts.filter(id => id !== characterId);
                    await saveContacts();
                }
                if (window.characters) {
                    window.characters = window.characters.filter(char => char.id !== characterId);
                }
                
                console.log(`删除完成！共删除 ${deleteCount} 条相关数据`);
                
                // 刷新界面
                if (window.renderContactList) window.renderContactList();
                if (window.renderMessageList) window.renderMessageList();
                
            } catch (error) {
                console.error('删除失败:', error);
            }
        }
        
        // 强制删除指定角色（用于清理幽灵角色）
        async function forceDeleteCharacter() {
            const characterName = prompt('输入要强制删除的角色名称（如：方回）：');
            if (!characterName || !characterName.trim()) return;
            
            try {
                showToast(`正在强制删除角色 "${characterName}"...`, 'info');
                let deleteCount = 0;
                
                // 1. 从动态评论中删除
                const comments = await db.momentComments.toArray();
                for (const comment of comments) {
                    if (comment.nickname === characterName || (comment.authorId && comment.authorId.includes(characterName))) {
                        await db.momentComments.delete(comment.id);
                        deleteCount++;
                        console.log(`删除评论：${comment.nickname} - ${comment.text}`);
                    }
                }
                
                // 2. 从动态点赞中删除
                const likes = await db.momentLikes.toArray();
                for (const like of likes) {
                    if (like.name === characterName || (like.authorId && like.authorId.includes(characterName))) {
                        await db.momentLikes.delete([like.momentId, like.authorId]);
                        deleteCount++;
                        console.log(`删除点赞：${like.name}`);
                    }
                }
                
                // 3. 从聊天消息中删除
                const chatMsgs = await db.chatMessages.toArray();
                for (const msg of chatMsgs) {
                    if (msg.characterId && msg.characterId.includes(characterName)) {
                        await db.chatMessages.delete(msg.id);
                        deleteCount++;
                    }
                }
                
                // 4. 从聊天设置中删除
                const chatSets = await db.chatSettings.toArray();
                for (const setting of chatSets) {
                    if (setting.characterId && setting.characterId.includes(characterName)) {
                        await db.chatSettings.delete(setting.id);
                        deleteCount++;
                    }
                }
                
                // 5. 从characters表中删除
                const chars = await db.characters.toArray();
                for (const char of chars) {
                    if (char.name === characterName || char.id.includes(characterName)) {
                        await db.characters.delete(char.id);
                        deleteCount++;
                        console.log(`删除角色：${char.name} (${char.id})`);
                    }
                }
                
                // 6. 从联系人列表中删除
                if (window.contacts) {
                    window.contacts = window.contacts.filter(id => !id.includes(characterName));
                    await saveContacts();
                }
                
                // 7. 清理内存中的数据
                if (window.characters) {
                    window.characters = window.characters.filter(char => char.name !== characterName);
                }
                if (window.chatMessages) {
                    Object.keys(window.chatMessages).forEach(key => {
                        if (key.includes(characterName)) {
                            delete window.chatMessages[key];
                        }
                    });
                }
                if (window.chatSettings) {
                    Object.keys(window.chatSettings).forEach(key => {
                        if (key.includes(characterName)) {
                            delete window.chatSettings[key];
                        }
                    });
                }
                
                // 刷新界面
                if (window.renderContactList) window.renderContactList();
                if (window.renderMessageList) window.renderMessageList();
                
                showToast(`强制删除完成！共删除 ${deleteCount} 条相关数据`, 'success');
                console.log(`强制删除角色 "${characterName}" 完成，删除了 ${deleteCount} 条记录`);
                
            } catch (error) {
                console.error('强制删除失败:', error);
                showToast('强制删除失败: ' + error.message, 'error');
            }
        }

        // 清理孤立联系人和重复数据
        async function cleanupOrphanedContacts() {
            try {
                showToast('正在清理孤立数据...', 'info');
                
                let cleanupCount = 0;
                
                // 1. 清理联系人列表中不存在的角色ID
                const validCharacterIds = characters.map(char => char.id);
                const originalContactsLength = contacts.length;
                contacts = contacts.filter(contactId => {
                    const isValid = validCharacterIds.includes(contactId);
                    if (!isValid) cleanupCount++;
                    return isValid;
                });
                
                // 2. 从数据库中清理孤立的联系人记录
                const dbContacts = await db.contacts.toArray();
                for (const contact of dbContacts) {
                    if (!validCharacterIds.includes(contact.characterId)) {
                        await db.contacts.delete(contact.id);
                        cleanupCount++;
                    }
                }
                
                // 3. 清理聊天消息中不存在角色的记录
                const chatMessageKeys = Object.keys(chatMessages);
                for (const characterId of chatMessageKeys) {
                    if (!validCharacterIds.includes(characterId)) {
                        delete chatMessages[characterId];
                        cleanupCount++;
                    }
                }
                
                // 4. 清理数据库中孤立的聊天消息
                const dbChatMessages = await db.chatMessages.toArray();
                for (const msgRecord of dbChatMessages) {
                    if (!validCharacterIds.includes(msgRecord.characterId)) {
                        await db.chatMessages.delete(msgRecord.id);
                        cleanupCount++;
                    }
                }
                
                // 5. 清理聊天设置中不存在角色的记录
                const chatSettingsKeys = Object.keys(chatSettings);
                for (const characterId of chatSettingsKeys) {
                    if (!validCharacterIds.includes(characterId)) {
                        delete chatSettings[characterId];
                        cleanupCount++;
                    }
                }
                
                // 6. 清理数据库中孤立的聊天设置
                const dbChatSettings = await db.chatSettings.toArray();
                for (const setting of dbChatSettings) {
                    if (!validCharacterIds.includes(setting.characterId)) {
                        await db.chatSettings.delete(setting.id);
                        cleanupCount++;
                    }
                }
                
                // 7. 清理动态评论中不存在角色的记录
                const dbMomentComments = await db.momentComments.toArray();
                for (const comment of dbMomentComments) {
                    // 清理authorId不在角色列表中且不是用户的评论
                    if (comment.authorId !== 'user' && !validCharacterIds.includes(comment.authorId)) {
                        await db.momentComments.delete(comment.id);
                        cleanupCount++;
                        console.log(`删除了孤立评论：${comment.nickname}(${comment.authorId})`);
                    }
                }
                
                // 8. 清理动态点赞中不存在角色的记录
                const dbMomentLikes = await db.momentLikes.toArray();
                for (const like of dbMomentLikes) {
                    // 清理authorId不在角色列表中且不是用户的点赞
                    if (like.authorId !== 'user' && !validCharacterIds.includes(like.authorId)) {
                        await db.momentLikes.delete([like.momentId, like.authorId]);
                        cleanupCount++;
                        console.log(`删除了孤立点赞：${like.name}(${like.authorId})`);
                    }
                }
                
                // 9. 保存清理后的数据
                await Promise.all([
                    saveContacts(),
                    saveChatMessages(),
                    saveChatSettings()
                ]);
                
                // 10. 重新渲染界面
                renderContactList();
                renderMessageList();
                
                showToast(`清理完成！共清理了 ${cleanupCount} 条孤立数据`, 'success');
                
                console.log('清理结果:', {
                    有效角色数: validCharacterIds.length,
                    清理前联系人数: originalContactsLength,
                    清理后联系人数: contacts.length,
                    总清理项目: cleanupCount
                });
                
            } catch (error) {
                console.error('清理孤立数据失败:', error);
                showToast('清理失败: ' + error.message, 'error');
            }
        }
        
        // 清空所有数据
        async function clearAllData() {
            const confirm = prompt('警告：将删除所有数据且无法恢复！\n输入"清空所有数据"确认：');
            if (confirm !== '清空所有数据') return;
            
            try {
                showToast('清空中...', 'info');
                await Promise.all([
                    db.characters.clear(),
                    db.chatMessages.clear(), 
                    db.chatSettings.clear(),
                    db.customEmojis.clear()
                ]);
                
                characters = [];
                chatMessages = {};
                chatSettings = {};
                customEmojis = [];
                
                for (let i = localStorage.length - 1; i >= 0; i--) {
                    const key = localStorage.key(i);
                    if (key?.startsWith('chatSettings_')) localStorage.removeItem(key);
                }
                
                renderCharacterList();
                renderMessageList();
                calculateStorageUsage();
                showToast('已清空所有数据', 'success');
                
                setTimeout(() => {
                    hideApp('data-management-screen');
                    hideApp('settings-screen');
                }, 2000);
            } catch (error) {
                showToast('清空失败', 'error');
            }
        }

        // 重复函数已删除

        // 转账相关变量
        let currentTransferMsg = null;
        
        // 处理用户发送给AI的转账
        async function processUserTransfer(userTransferMsg, aiMessages) {
            console.log('🚀 processUserTransfer 被调用:', {
                userTransferMsg,
                aiMessages,
                currentCharacter: currentChatCharacter?.name
            });
            
            if (!userTransferMsg || !currentChatCharacter) {
                console.log('❌ processUserTransfer 退出：缺少必要参数');
                return;
            }
            
            const messages = chatMessages[currentChatCharacter.id] || [];
            
            // 分析AI的回复内容，判断是否有转账相关操作
            let transferAction = null;
            let transferActionReason = '';
            
            for (const msgData of aiMessages) {
                // 检查AI是否在回复中明确处理了转账
                if (typeof msgData === 'object' && msgData.type === 'transfer_action') {
                    transferAction = msgData.action; // 'accept', 'reject', 'ignore'
                    transferActionReason = msgData.reason || '';
                    break;
                }
                
                // 检查AI的普通回复中是否包含转账处理的关键词
                if (typeof msgData === 'string') {
                    const content = msgData.toLowerCase();
                    if (content.includes('收下') || content.includes('谢谢') || content.includes('收款') || content.includes('接受') || 
                        content.includes('确认收款') || content.includes('已收款') || content.includes('收到了') || 
                        content.includes('感谢') || content.includes('好的') || content.includes('ok') || 
                        content.includes('没问题') || content.includes('可以')) {
                        transferAction = 'accept';
                        transferActionReason = '角色同意收款';

                        break;
                    } else if (content.includes('退回') || content.includes('不要') || content.includes('拒绝') || 
                              content.includes('不需要') || content.includes('不收') || content.includes('算了')) {
                        transferAction = 'reject';
                        transferActionReason = '角色拒绝收款';

                        break;
                    }
                }
            }
            
            // 如果AI明确表示了转账处理意图，则执行相应操作
            if (transferAction === 'accept' || transferAction === 'reject') {
                const transferIndex = messages.findIndex(msg => 
                    msg.timestamp === userTransferMsg.timestamp && msg.type === 'transfer' && msg.sender === 'sent');
                    
                if (transferIndex !== -1) {
                    // 更新转账状态
                    const newStatus = transferAction === 'accept' ? 'accepted' : 'rejected';
                    messages[transferIndex].status = newStatus;
                    
                    console.log('✅ 转账状态已更新:', {
                        oldStatus: userTransferMsg.status,
                        newStatus: newStatus,
                        message: messages[transferIndex]
                    });
                    
                    // 保存到数据库
                    await saveChatMessages();
                    
                    // 添加系统消息
                    const actionText = transferAction === 'accept' ? '已收款' : '已退回';
                    const systemMsg = {
                        id: Date.now().toString(),
                        sender: 'system',
                        content: `${currentChatCharacter.name}${actionText} ¥${Number(userTransferMsg.amount).toFixed(2)}`,
                        timestamp: Date.now()
                    };
                    
                    messages.push(systemMsg);
                    await saveChatMessages();
                    
                    console.log('📱 系统消息已添加:', systemMsg);
                    
                    // 立即重新渲染聊天界面以显示更新
                    renderChatMessages(currentChatCharacter.id);
                    
                    // 显示确认提示
                    const toastText = transferAction === 'accept' ? '转账已被接受' : '转账已被退回';
                    showToast(toastText, 'success');
                    
                    console.log('🎉 转账处理完成');
                } else {
                    console.error('❌ 未找到对应的转账消息');
                }
            } else {
                console.log('ℹ️ AI没有明确表态，转账保持pending状态');
            }
            // 如果AI没有明确表态，转账保持pending状态，等待用户手动处理或下次AI回复
        }
        
        // 转账相关函数
        function sendTransfer() {
            const amount = parseFloat(document.getElementById('transfer-amount').value);
            const note = document.getElementById('transfer-note').value.trim();
            
            if (!amount || amount <= 0) {
                showToast('请输入有效的转账金额', 'warning');
                return;
            }
            
            if (amount > 1000000000) {
                showToast('转账金额不能超过10亿元', 'warning');
                return;
            }
            
            // 创建转账消息 - 修复数据结构和设置pendingUserMessage
            const transferMessage = {
                id: Date.now().toString(),
                sender: 'sent',  // 修复：使用 sender 而不是 role
                type: 'transfer',
                amount: amount,
                note: note || '转账',
                timestamp: Date.now()
            };
            
            // 添加到聊天记录
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            chatMessages[currentChatCharacter.id].push(transferMessage);
            
            // 保存到数据库
            saveChatMessages();
            
            // 使用动画添加消息而不是重新渲染整个列表
            addMessageWithAnimation(transferMessage, currentChatCharacter.id);
            
            // 🔥 【关键修复】设置为待回复消息，让AI能看到转账
            pendingUserMessage = transferMessage;
            
            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = '点击获取AI回复';
            }
            
            // 更新联系人列表
            renderMessageList();
            
            // 关闭转账对话框
            document.getElementById('transfer-modal').classList.remove('visible');
            
            // 清空输入框
            document.getElementById('transfer-amount').value = '';
            document.getElementById('transfer-note').value = '';
            
            showToast('转账已发送', 'success');
        }
        
        function showTransferConfirmDialog(transferMsg) {
            if (!transferMsg || transferMsg.status) return;
            
            const modal = document.getElementById('transfer-confirm-modal');
            const amountEl = modal.querySelector('.transfer-confirm-amount');
            const noteEl = modal.querySelector('.transfer-confirm-note');
            
            // 设置转账信息
            amountEl.textContent = `¥ ${Number(transferMsg.amount).toFixed(2)}`;
            noteEl.textContent = `备注：${transferMsg.note || '无'}`;
            
            // 存储当前处理的转账信息
            currentTransferMsg = transferMsg;
            
            // 显示对话框
            modal.classList.add('visible');
        }
        
        async function acceptTransfer() {
            if (!currentTransferMsg || !currentChatCharacter) return;
            
            // 在聊天记录中找到对应的转账消息并更新状态
            const messages = chatMessages[currentChatCharacter.id] || [];
            const transferIndex = messages.findIndex(msg => 
                msg.timestamp === currentTransferMsg.timestamp && msg.type === 'transfer');
                
            if (transferIndex !== -1) {
                // 更新转账状态
                messages[transferIndex].status = 'accepted';
                
                // 保存到数据库
                await saveChatMessages();
                
                // 重新渲染聊天界面
                renderChatMessages(currentChatCharacter.id);
                
                // 添加一条系统消息，表示已收款
                const systemMsg = {
                    id: Date.now().toString(),
                    sender: 'system',
                    content: `你已确认收款 ¥${Number(currentTransferMsg.amount).toFixed(2)}`,
                    timestamp: Date.now()
                };
                
                messages.push(systemMsg);
                await saveChatMessages();
                renderChatMessages(currentChatCharacter.id);
            }
            
            // 关闭对话框
            document.getElementById('transfer-confirm-modal').classList.remove('visible');
            currentTransferMsg = null;
            
            showToast('已确认收款', 'success');
        }
        
        async function rejectTransfer() {
            if (!currentTransferMsg || !currentChatCharacter) return;
            
            // 在聊天记录中找到对应的转账消息并更新状态
            const messages = chatMessages[currentChatCharacter.id] || [];
            const transferIndex = messages.findIndex(msg => 
                msg.timestamp === currentTransferMsg.timestamp && msg.type === 'transfer');
                
            if (transferIndex !== -1) {
                // 更新转账状态
                messages[transferIndex].status = 'rejected';
                
                // 保存到数据库
                await saveChatMessages();
                
                // 重新渲染聊天界面
                renderChatMessages(currentChatCharacter.id);
                
                // 添加一条系统消息，表示已退回
                const systemMsg = {
                    id: Date.now().toString(),
                    sender: 'system',
                    content: `你已退回 ¥${Number(currentTransferMsg.amount).toFixed(2)}`,
                    timestamp: Date.now()
                };
                
                messages.push(systemMsg);
                await saveChatMessages();
                renderChatMessages(currentChatCharacter.id);
            }
            
            // 关闭对话框
            document.getElementById('transfer-confirm-modal').classList.remove('visible');
            currentTransferMsg = null;
            
            showToast('已退回转账', 'success');
        }

        // 监听app显示事件
        const originalShowApp = window.showApp;
        if (originalShowApp) {
            window.showApp = function(appId) {
                originalShowApp(appId);
                if (appId === 'data-management-screen') calculateStorageUsage();
            };
        }

        // 显示定时发布时间设置模态框
        function showScheduleTimesModal() {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            const scheduleTimes = chatSettings.scheduledMomentsTimes || [];
            
            const container = document.getElementById('schedule-times-container');
            container.innerHTML = '';
            
            // 渲染已有时间点
            scheduleTimes.forEach((time, index) => {
                const timeItem = document.createElement('div');
                timeItem.className = 'schedule-time-item';
                timeItem.style.cssText = `
                    display: flex;
                    align-items: center;
                    margin-bottom: 10px;
                    gap: 10px;
                `;
                timeItem.innerHTML = `
                    <input type="time" value="${time}" onchange="updateScheduleTime(${index}, this.value)" 
                           style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 6px;">
                    <button onclick="removeScheduleTime(${index})" 
                            style="padding: 8px 12px; background: #ff3b30; color: white; border: none; border-radius: 6px; cursor: pointer;">×</button>
                `;
                container.appendChild(timeItem);
            });
            
            showModal('schedule-times-modal');
        }
        
        // 添加定时发布时间点
        function addScheduleTime() {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            if (!chatSettings.scheduledMomentsTimes) {
                chatSettings.scheduledMomentsTimes = [];
            }
            
            if (chatSettings.scheduledMomentsTimes.length >= 10) {
                alert('最多只能设置10个时间点');
                return;
            }
            
            chatSettings.scheduledMomentsTimes.push('09:00');
            saveCurrentChatSettings(chatSettings);
            showScheduleTimesModal(); // 重新渲染
        }
        
        // 更新定时发布时间点
        function updateScheduleTime(index, newTime) {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.scheduledMomentsTimes && chatSettings.scheduledMomentsTimes[index] !== undefined) {
                chatSettings.scheduledMomentsTimes[index] = newTime;
                saveCurrentChatSettings(chatSettings);
            }
        }
        
        // 移除定时发布时间点
        function removeScheduleTime(index) {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.scheduledMomentsTimes && chatSettings.scheduledMomentsTimes[index] !== undefined) {
                chatSettings.scheduledMomentsTimes.splice(index, 1);
                saveCurrentChatSettings(chatSettings);
                showScheduleTimesModal(); // 重新渲染
            }
        }
        
        // 保存定时发布设置
        function saveScheduleTimes() {
            updateScheduleTimesDisplay();
            hideModal('schedule-times-modal');
            showToast('定时发布设置已保存', 'success');
        }
        
        // 更新定时发布时间显示
        function updateScheduleTimesDisplay() {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            const scheduleTimes = chatSettings.scheduledMomentsTimes || [];
            const displayElement = document.getElementById('schedule-times-display');
            
            if (scheduleTimes.length === 0) {
                displayElement.textContent = '未设置';
            } else if (scheduleTimes.length === 1) {
                displayElement.textContent = `1个时间点 (${scheduleTimes[0]})`;
            } else {
                displayElement.textContent = `${scheduleTimes.length}个时间点`;
            }
        }
        
        // 测试发布动态
        async function testPublishMoment() {
            if (!currentChatCharacter) {
                alert('请先选择一个角色');
                return;
            }
            
            const button = document.querySelector('button[onclick="testPublishMoment()"]');
            const originalText = button.textContent;
            button.textContent = '发布中...';
            button.disabled = true;
            
            try {
                await triggerBackgroundMomentsTest(currentChatCharacter.id);
                showToast('测试动态发布成功！', 'success');
            } catch (error) {
                console.error('测试发布失败:', error);
                showToast('测试发布失败', 'error');
            } finally {
                button.textContent = originalText;
                button.disabled = false;
            }
        }
        
        // 初始化定时发布系统
        function initScheduledMomentsSystem() {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            if (!chatSettings.scheduledMomentsEnabled || !chatSettings.scheduledMomentsTimes?.length) {
                return;
            }
            
            // 为每个设定时间创建定时器
            chatSettings.scheduledMomentsTimes.forEach(time => {
                if (!time) return;
                
                const [hours, minutes] = time.split(':').map(Number);
                const now = new Date();
                const scheduledTime = new Date();
                
                scheduledTime.setHours(hours, minutes, 0, 0);
                
                // 如果时间已过，设置为明天
                if (scheduledTime <= now) {
                    scheduledTime.setDate(scheduledTime.getDate() + 1);
                }
                
                const delay = scheduledTime.getTime() - now.getTime();
                
                setTimeout(() => {
                    // 执行定时发布
                    triggerBackgroundMoments(currentChatCharacter.id);
                    
                    // 设置每24小时重复执行
                    setInterval(() => {
                        triggerBackgroundMoments(currentChatCharacter.id);
                    }, 24 * 60 * 60 * 1000);
                }, delay);
            });
        }

        // 初始化转账功能事件监听器
        document.addEventListener('DOMContentLoaded', function() {
            // 添加转账相关事件监听器
            document.getElementById('transfer-cancel-btn')?.addEventListener('click', () => {
                document.getElementById('transfer-modal').classList.remove('visible');
            });
            
            document.getElementById('transfer-confirm-btn')?.addEventListener('click', sendTransfer);
            document.getElementById('transfer-accept-btn')?.addEventListener('click', acceptTransfer);
            document.getElementById('transfer-reject-btn')?.addEventListener('click', rejectTransfer);
            
            // 点击模态框背景关闭
            document.getElementById('transfer-modal')?.addEventListener('click', (e) => {
                if (e.target === document.getElementById('transfer-modal')) {
                    document.getElementById('transfer-modal').classList.remove('visible');
                }
            });
            
            document.getElementById('transfer-confirm-modal')?.addEventListener('click', (e) => {
                if (e.target === document.getElementById('transfer-confirm-modal')) {
                    document.getElementById('transfer-confirm-modal').classList.remove('visible');
                    currentTransferMsg = null;
                }
            });
        });

        // 群聊相关函数
        function updateGroupChatInfo() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            
            // 更新群聊头像预览
            const groupAvatarPreview = document.getElementById('group-avatar-preview');
            if (groupAvatarPreview) {
                if (currentChatCharacter.avatarUrl) {
                    groupAvatarPreview.src = currentChatCharacter.avatarUrl;
                } else {
                    // 使用默认的群聊头像 - 创建一个简单的Canvas头像
                    const canvas = document.createElement('canvas');
                    canvas.width = 40;
                    canvas.height = 40;
                    const ctx = canvas.getContext('2d');
                    
                    // 绘制蓝色圆形背景
                    ctx.beginPath();
                    ctx.arc(20, 20, 20, 0, 2 * Math.PI);
                    ctx.fillStyle = '#4a84c1';
                    ctx.fill();
                    
                    // 绘制白色"群"字
                    ctx.fillStyle = 'white';
                    ctx.font = '18px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('群', 20, 20);
                    
                    groupAvatarPreview.src = canvas.toDataURL();
                }
            }
            
            // 更新群聊名称显示
            const groupNameDisplay = document.getElementById('group-name-display');
            if (groupNameDisplay) {
                groupNameDisplay.textContent = currentChatCharacter.name || '群聊名称';
            }
            
            // 更新群成员数量显示
            const groupMemberCountDisplay = document.getElementById('group-member-count-display');
            if (groupMemberCountDisplay) {
                const memberCount = currentChatCharacter.members ? currentChatCharacter.members.length : 0;
                // 群成员数量 = 角色数量 + 1个用户
                const totalMemberCount = memberCount + 1;
                groupMemberCountDisplay.textContent = `${totalMemberCount}名成员`;
            }
            
            // 更新群公告显示
            const groupDescriptionDisplay = document.getElementById('group-description-display');
            if (groupDescriptionDisplay) {
                groupDescriptionDisplay.textContent = currentChatCharacter.description || '群公告：点击设置群公告';
            }
            
            // 更新我在群里的昵称 - 使用当前选择的面具名称作为默认值
            const currentMyGroupNickname = document.getElementById('current-my-group-nickname');
            if (currentMyGroupNickname) {
                let defaultNickname = '未选择';
        
        // --- 新增代码开始 ---
        const chatSettings = getCurrentChatSettings();
        const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
        // --- 新增代码结束 ---

                // 如果用户选择了面具，使用面具名称
        if (selectedPersona && selectedPersona.name) { // <--- 修改这里
            defaultNickname = selectedPersona.name;
                }
        
        // 优先显示用户在群聊中自己设置的昵称，如果没有，则显示创建群聊时选择的身份昵称
        currentMyGroupNickname.textContent = chatSettings.myChatNickname || defaultNickname;
            }
            
            // 渲染群成员网格
            renderGroupMembersGrid();
        }
        
        function changeGroupAvatar() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            
            const tempInput = document.createElement('input');
            tempInput.type = 'file';
            tempInput.accept = 'image/*';
            tempInput.style.display = 'none';
            document.body.appendChild(tempInput);
            
            tempInput.onchange = function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = async function(event) {
                        // 更新当前群聊角色的头像
                        currentChatCharacter.avatarUrl = event.target.result;
                        
                        // 如果是群聊，需要更新群聊数据
                        if (groupChats) {
                            const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                            if (groupIndex !== -1) {
                                groupChats[groupIndex].avatarUrl = event.target.result;
                                await saveGroupChats(groupChats);
                            }
                        }
                        
                        // 更新UI显示
                        updateGroupChatInfo();
                        document.getElementById('api-chat-title').textContent = currentChatCharacter.name;
                        
                        // 更新头像显示
                        const chatAvatarElement = document.querySelector('#api-chat-screen .message-avatar img');
                        if (chatAvatarElement) {
                            chatAvatarElement.src = event.target.result;
                        }
                        
                        // 更新消息列表和联系人列表中的群聊头像
                        renderContactList();
                        renderMessageList();
                        
                        document.body.removeChild(tempInput);
                    };
                    reader.readAsDataURL(e.target.files[0]);
                } else {
                    document.body.removeChild(tempInput);
                }
            };
            
            tempInput.click();
        }
        
        function changeGroupName() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            
            const newName = prompt('请输入新的群聊名称:', currentChatCharacter.name);
            if (newName && newName.trim() !== '') {
                const trimmedName = newName.trim();
                
                // 更新当前群聊角色的名称
                currentChatCharacter.name = trimmedName;
                
                // 如果是群聊，需要更新群聊数据
                if (groupChats) {
                    const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                    if (groupIndex !== -1) {
                        groupChats[groupIndex].name = trimmedName;
                        saveGroupChats(groupChats);
                    }
                }
                
                // 更新UI显示
                updateGroupChatInfo();
                document.getElementById('api-chat-title').textContent = trimmedName;
                renderContactList();
                renderMessageList();
            }
        }
        
// --- 请从这里开始复制，替换掉旧的 showGroupChatMemberSelection 和 renderGroupMembersGrid 函数 ---

// 5. 显示群成员选择 (已修正版本)
function showGroupChatMemberSelection(personaId) {
    console.log('✅ 第二个showGroupChatMemberSelection被调用，接收到的personaId:', personaId);
    
    // 立即将personaId存储到全局变量中，确保不会丢失
    window.currentGroupPersonaId = personaId;
    
    // 重置表单
    document.getElementById('group-chat-name').value = '';
    selectedGroupMembers = [];
    
    const membersContainer = document.getElementById('group-chat-members');
    membersContainer.innerHTML = '';
    
    if (characters.length < 2) {
        membersContainer.innerHTML = '<p class="empty-mount-chats">至少需要2个角色才能创建群聊</p>';
    } else {
        characters.forEach(character => {
            const memberItem = document.createElement('div');
            memberItem.className = 'group-member-item';
            memberItem.onclick = () => toggleGroupMemberSelection(character.id);
            // 关键修复：重新添加了显示角色简介的HTML代码
            memberItem.innerHTML = `
                <div class="group-member-checkbox" id="checkbox-${character.id}"></div>
                <div class="message-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url('${character.avatarUrl}'); background-size: cover; background-position: center;` : ''}">
                    ${character.avatarUrl ? '' : character.name.charAt(0)}
                </div>
                <div class="chat-option-text">
                    <div class="chat-option-title">${character.name}</div>
                    <div class="chat-option-desc">${truncateText(character.bio || '暂无简介', 80)}</div>
                </div>`;
            membersContainer.appendChild(memberItem);
        });
    }

    // 将 personaId 附加到创建按钮上
    console.log('✅ 在第二个位置绑定创建按钮，personaId:', personaId);
    const createBtn = document.getElementById('group-chat-modal').querySelector('.modal-primary');
    createBtn.onclick = () => {
        console.log('✅ 第二个位置的创建群聊按钮被点击，直接使用参数personaId:', personaId);
        createGroupChat(personaId);
    }; // 绑定带参数的创建函数

    showModal('group-chat-modal');
}


// 渲染群成员网格 (已修正版本)
        function renderGroupMembersGrid() {
            const groupMembersGrid = document.getElementById('group-members-grid');
            if (!groupMembersGrid || !currentChatCharacter || !currentChatCharacter.isGroup) return;
            
            // 清空现有内容
            groupMembersGrid.innerHTML = '';
            
    // --- 关键修复：正确获取并显示用户在当前群聊中的身份 ---
    const chatSettings = getCurrentChatSettings(); // 获取当前群聊的专属设置
    const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
    
            let userName = '用户';
            let userAvatar = '';
            
    if (selectedPersona) {
        // 优先使用群聊设置里为“我”单独设置的昵称和头像
        userName = chatSettings.myChatNickname || selectedPersona.name;
        userAvatar = chatSettings.myChatAvatar || selectedPersona.avatarUrl;
    }
    
    // 添加用户自己（排在第一位）
    const userItem = document.createElement('div');
    userItem.className = 'member-item user-member';
    userItem.onclick = () => changeMyGroupAvatar();
            userItem.innerHTML = `
                <img class="member-avatar" src="${userAvatar || createDefaultAvatar(userName)}" alt="${userName}">
                <div class="member-name">${userName}</div>
            `;
            groupMembersGrid.appendChild(userItem);
    // --- 修复结束 ---
            
            // 然后添加群内现有角色
            if (currentChatCharacter.members && currentChatCharacter.members.length > 0) {
                currentChatCharacter.members.forEach(member => {
                    const memberItem = document.createElement('div');
                    memberItem.className = 'member-item';
                    
                    memberItem.innerHTML = `
                        <div class="member-avatar-wrapper">
                            <img class="member-avatar clickable-avatar" 
                                 src="${member.avatarUrl || createDefaultAvatar(member.name)}" 
                                 alt="${member.name}"
                                 onclick="changeMemberAvatar('${member.id}', event)"
                                 title="点击更换${member.name}的头像">
                            <div class="avatar-hover-hint">
                                <i class="fas fa-camera"></i>
                            </div>
                        </div>
                        <div class="member-name">${member.name}</div>
                    `;
                    groupMembersGrid.appendChild(memberItem);
                });
            }
            
            // 添加邀请按钮
            const addMemberBtn = document.createElement('div');
            addMemberBtn.className = 'member-item add-member';
            addMemberBtn.onclick = () => addGroupMember();
            addMemberBtn.innerHTML = `
                <div class="member-avatar add-avatar">
                    <i class="fas fa-plus"></i>
                </div>
                <div class="member-name">邀请</div>
            `;
            groupMembersGrid.appendChild(addMemberBtn);
            
            // 只要群内有角色成员就显示移除按钮
            if (currentChatCharacter.members && currentChatCharacter.members.length > 0) {
                const removeMemberBtn = document.createElement('div');
                removeMemberBtn.className = 'member-item remove-member';
                removeMemberBtn.onclick = () => removeGroupMember();
                removeMemberBtn.innerHTML = `
                    <div class="member-avatar remove-avatar">
                        <i class="fas fa-minus"></i>
                    </div>
                    <div class="member-name">移除</div>
                `;
                groupMembersGrid.appendChild(removeMemberBtn);
            }
        }

// --- 请复制到这里结束 ---
        
        // 显示成员详情
        function showMemberProfile(member) {
            alert(`👤 群成员信息\n\n昵称：${member.name}\n角色ID：${member.id}\n\n点击头像可以查看角色详细信息`);
        }
        
        // 显示用户自己的资料
        function showUserProfile() {
            let userName = '用户';
            let userInfo = '群聊成员';
            
            if (currentPersona) {
                userName = currentPersona.name;
                userInfo = `当前面具：${currentPersona.name}`;
                if (currentPersona.description) {
                    userInfo += `\n面具描述：${currentPersona.description}`;
                }
            } else if (currentChatCharacter.myNickname) {
                userName = currentChatCharacter.myNickname;
                userInfo = `群昵称：${currentChatCharacter.myNickname}`;
            }
            
            alert(`👤 我的信息\n\n昵称：${userName}\n身份：${userInfo}\n\n这是你自己在群聊中的信息`);
        }
        
        // 创建默认头像
        function createDefaultAvatar(name) {
            const canvas = document.createElement('canvas');
            canvas.width = 50;
            canvas.height = 50;
            const ctx = canvas.getContext('2d');
            
            // 随机背景颜色
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF'];
            const bgColor = colors[name.charCodeAt(0) % colors.length];
            
            // 绘制圆形背景
            ctx.beginPath();
            ctx.arc(25, 25, 25, 0, 2 * Math.PI);
            ctx.fillStyle = bgColor;
            ctx.fill();
            
            // 绘制文字
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(name.charAt(0), 25, 25);
            
            return canvas.toDataURL();
        }
        
        function showGroupMembers() {
            alert('👥 群成员管理功能开发中...\n\n将支持以下功能：\n• 查看群成员列表\n• 设置群管理员\n• 管理群成员权限\n• 禁言/踢出群聊');
        }
        
        async function changeMyGroupNickname() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            
    const chatSettings = getCurrentChatSettings();
    const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
    
    const currentNickname = chatSettings.myChatNickname || (selectedPersona ? selectedPersona.name : '用户');
    const newNickname = prompt('请输入我在本群的昵称:', currentNickname);

    if (newNickname && newNickname.trim() !== '' && newNickname.trim() !== currentNickname) {
                const trimmedNickname = newNickname.trim();
                
        // 1. 更新当前群聊设置中的昵称
        chatSettings.myChatNickname = trimmedNickname;
        await saveCurrentChatSettings(chatSettings);
        
        // 2. 创建并添加系统消息
        const systemMessage = {
            id: 'system_' + Date.now(),
            sender: 'system',
            content: `你已将群昵称修改为 "${trimmedNickname}"`,
            timestamp: Date.now()
        };
        
        if (!chatMessages[currentChatCharacter.id]) {
            chatMessages[currentChatCharacter.id] = [];
        }
        chatMessages[currentChatCharacter.id].push(systemMessage);
        await saveChatMessages();
        
        // 3. 更新UI
        updateGroupChatInfo(); // 这会刷新设置页面的显示
        renderChatMessages(currentChatCharacter.id); // 刷新聊天界面显示系统消息

        showToast('群昵称修改成功！', 'success');
    }
}
// --- 新增函数 ---
async function changeMyGroupAvatar() {
    if (!currentChatCharacter) return;

    // 创建一个临时的文件输入框
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.style.display = 'none';

    // 当用户选择了文件后
    input.onchange = async (e) => {
        if (!e.target.files || !e.target.files[0]) return;
        
        const file = e.target.files[0];
        const reader = new FileReader();

        reader.onload = async (event) => {
            const newAvatarUrl = event.target.result;

            // 1. 更新当前群聊设置中的头像
            const chatSettings = getCurrentChatSettings();
            chatSettings.myChatAvatar = newAvatarUrl;
            await saveCurrentChatSettings(chatSettings);
            
            // 2. 创建并添加系统消息
            const systemMessage = {
                id: 'system_' + Date.now(),
                sender: 'system',
                content: `你更换了新头像`,
                timestamp: Date.now()
            };

            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            chatMessages[currentChatCharacter.id].push(systemMessage);
            await saveChatMessages();

            // 3. 更新UI
            updateGroupChatInfo(); // 刷新设置页面的成员列表
            renderChatMessages(currentChatCharacter.id); // 刷新聊天界面显示新头像和系统消息

            showToast('群头像更换成功！', 'success');
        };
        
        reader.readAsDataURL(file);
        document.body.removeChild(input); // 清理临时的input元素
    };

    document.body.appendChild(input);
    input.click(); // 弹出文件选择窗口
        }
        
        // 编辑群公告
        function editGroupDescription() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            showGroupNoticeModal();
        }
        
        // 显示群公告编辑模态框
        function showGroupNoticeModal() {
            const modal = document.getElementById('group-notice-modal');
            const textarea = document.getElementById('group-notice-content');
            const charCount = document.getElementById('notice-char-current');
            
            // 设置当前群公告内容
            const currentDescription = currentChatCharacter?.description || '';
            textarea.value = currentDescription;
            charCount.textContent = currentDescription.length;
            
            // 监听字符数变化
            textarea.addEventListener('input', updateNoticeCharCount);
            
            modal.style.display = 'flex';
            setTimeout(() => textarea.focus(), 100);
        }
        
        // 隐藏群公告编辑模态框
        function hideGroupNoticeModal() {
            const modal = document.getElementById('group-notice-modal');
            const textarea = document.getElementById('group-notice-content');
            
            // 移除事件监听器
            textarea.removeEventListener('input', updateNoticeCharCount);
            
            modal.style.display = 'none';
        }
        
        // 更新字符计数
        function updateNoticeCharCount() {
            const textarea = document.getElementById('group-notice-content');
            const charCount = document.getElementById('notice-char-current');
            charCount.textContent = textarea.value.length;
            
            // 如果超过限制，变色提示
            if (textarea.value.length > 500) {
                charCount.style.color = '#ff3b30';
            } else if (textarea.value.length > 450) {
                charCount.style.color = '#ff9500';
            } else {
                charCount.style.color = '#007AFF';
            }
        }
        
        // 保存群公告
        function saveGroupNotice() {
            const textarea = document.getElementById('group-notice-content');
            const newDescription = textarea.value.trim();
            
            if (newDescription.length > 500) {
                alert('群公告内容不能超过500字');
                return;
            }
            
                // 更新当前群聊角色的描述
            currentChatCharacter.description = newDescription;
                
                // 如果是群聊，需要更新群聊数据
                if (groupChats) {
                    const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                    if (groupIndex !== -1) {
                    groupChats[groupIndex].description = newDescription;
                        saveGroupChats(groupChats);
                    }
                }
                
                // 更新UI显示
                updateGroupChatInfo();
            hideGroupNoticeModal();
            
            // 显示成功提示
            showToast('✅ 群公告保存成功', 'success');
        }
        
        // 添加群成员 - 从现有角色中选择
        function addGroupMember() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            
            // 获取所有角色列表
            if (!characters || characters.length === 0) {
                alert('暂无可邀请的角色，请先创建角色');
                return;
            }
            
            // 过滤掉已经在群里的角色
            const currentMemberIds = currentChatCharacter.members ? currentChatCharacter.members.map(m => m.id) : [];
            const availableCharacters = characters.filter(char => !currentMemberIds.includes(char.id));
            
            if (availableCharacters.length === 0) {
                alert('所有角色都已经在群里了');
                return;
            }
            
            // 创建美观的选择界面
            showCharacterSelectionModal(availableCharacters, '邀请群成员', '请选择要邀请进群的角色：', (selectedCharacter) => {
                // 添加到群成员列表
                if (!currentChatCharacter.members) {
                    currentChatCharacter.members = [];
                }
                currentChatCharacter.members.push({
                    id: selectedCharacter.id,
                    name: selectedCharacter.name,
                    avatarUrl: selectedCharacter.avatarUrl
                });
                
                // 保存群聊数据
                if (groupChats) {
                    const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                    if (groupIndex !== -1) {
                        groupChats[groupIndex].members = currentChatCharacter.members;
                        saveGroupChats(groupChats);
                    }
                }
                
                // 更新UI
                updateGroupChatInfo();
                renderMessageList(); // 更新消息列表
                showToast(`✅ ${selectedCharacter.name} 已加入群聊`, 'success');
            });
        }
        
        // 移除群成员
        function removeGroupMember() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup || !currentChatCharacter.members) return;
            
            if (currentChatCharacter.members.length <= 1) {
                alert('群聊至少需要保留一个角色成员（不包括用户自己）');
                return;
            }
            
            // 创建美观的选择界面
            showCharacterSelectionModal(currentChatCharacter.members, '移除群成员', '请选择要移出群聊的成员：', (selectedMember) => {
                if (confirm(`确定要将 ${selectedMember.name} 移出群聊吗？`)) {
                    // 从群成员列表中移除
                    const memberIndex = currentChatCharacter.members.findIndex(m => m.id === selectedMember.id);
                    if (memberIndex !== -1) {
                        currentChatCharacter.members.splice(memberIndex, 1);
                        
                        // 保存群聊数据
                        if (groupChats) {
                            const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                            if (groupIndex !== -1) {
                                groupChats[groupIndex].members = currentChatCharacter.members;
                                saveGroupChats(groupChats);
                            }
                        }
                        
                        // 更新UI
                        updateGroupChatInfo();
                        renderMessageList(); // 更新消息列表
                        showToast(`✅ ${selectedMember.name} 已被移出群聊`, 'success');
                    }
                }
            });
        }
        
        // 群公告功能
        function showGroupNotice() {
            const notice = currentChatCharacter?.description || '暂无群公告';
            alert(`📢 群公告\n\n${notice}\n\n点击群信息卡片的公告区域可以编辑群公告`);
        }
        

        
        // 群应用功能
        function showGroupVote() {
            alert('🗳️ 群投票功能开发中...\n\n将支持以下功能：\n• 创建投票话题\n• 设置投票选项\n• 实时投票结果\n• 投票截止时间');
        }
        
        function showGroupActivity() {
            alert('📅 群活动功能开发中...\n\n将支持以下功能：\n• 创建群活动\n• 活动报名统计\n• 活动提醒\n• 活动签到');
        }
        
        function showGroupTask() {
            alert('✅ 群任务功能开发中...\n\n将支持以下功能：\n• 发布群任务\n• 任务认领\n• 完成状态跟踪\n• 积分奖励系统');
        }
        
        function showMoreApps() {
            alert('🔧 更多群应用\n\n即将推出：\n• 群直播\n• 群游戏\n• 群红包\n• 群机器人\n• 群日程\n• 群笔记');
        }
        
        // 显示角色选择模态框
        function showCharacterSelectionModal(characterList, title, description, onSelect) {
            const modalHTML = `
                <div class="modal character-selection-modal" id="character-selection-modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 class="modal-title">${title}</h3>
                            <button class="modal-close" onclick="hideCharacterSelectionModal()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p class="selection-description">${description}</p>
                            <div class="character-selection-grid" id="character-selection-grid">
                                ${characterList.map(char => `
                                    <div class="character-selection-item" data-character-id="${char.id}">
                                        <div class="character-selection-avatar">
                                            <img src="${char.avatarUrl || createDefaultAvatar(char.name)}" alt="${char.name}">
                                        </div>
                                        <div class="character-selection-info">
                                            <div class="character-selection-name">${char.name}</div>
                                            <div class="character-selection-bio">${(char.description || char.bio || '暂无简介').substring(0, 30)}${(char.description || char.bio || '').length > 30 ? '...' : ''}</div>
                                        </div>
                                        <div class="character-selection-check">
                                            <i class="fas fa-check"></i>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-secondary" onclick="hideCharacterSelectionModal()">取消</button>
                            <button class="modal-primary" id="confirm-selection-btn" onclick="confirmCharacterSelection()" disabled>确定</button>
                        </div>
                    </div>
                </div>
            `;
            
            const existingModal = document.getElementById('character-selection-modal');
            if (existingModal) {
                existingModal.remove();
            }
            
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            
            window.characterSelectionCallback = onSelect;
            window.selectedCharacterId = null;
            
            document.querySelectorAll('.character-selection-item').forEach(item => {
                item.addEventListener('click', function() {
                    document.querySelectorAll('.character-selection-item').forEach(i => i.classList.remove('selected'));
                    this.classList.add('selected');
                    window.selectedCharacterId = this.dataset.characterId;
                    document.getElementById('confirm-selection-btn').disabled = false;
                });
            });
        }
        
        // 隐藏角色选择模态框
        function hideCharacterSelectionModal() {
            const modal = document.getElementById('character-selection-modal');
            if (modal) {
                modal.remove();
            }
            window.characterSelectionCallback = null;
            window.selectedCharacterId = null;
        }
        
        // 确认角色选择
        function confirmCharacterSelection() {
            if (!window.selectedCharacterId || !window.characterSelectionCallback) return;
            
            const allCharacters = [...characters, ...(currentChatCharacter.members || [])];
            const selectedCharacter = allCharacters.find(char => char.id === window.selectedCharacterId);
            
            if (selectedCharacter) {
                window.characterSelectionCallback(selectedCharacter);
                hideCharacterSelectionModal();
            }
        }
        
        // 🔥【新增】群成员头像更换功能
        function changeMemberAvatar(memberId, event) {
            event.stopPropagation(); // 阻止事件冒泡
            
            const member = currentChatCharacter.members.find(m => m.id === memberId);
            if (!member) return;
            
            // 显示头像更换模态框
            showMemberAvatarModal(member);
        }

        // 🔥【新增】显示群成员头像更换模态框
        function showMemberAvatarModal(member) {
            const modal = document.getElementById('member-avatar-modal');
            const preview = document.getElementById('member-avatar-preview');
            const memberName = document.getElementById('member-avatar-name');
            const uploadInput = document.getElementById('member-avatar-upload');
            
            // 设置当前成员信息
            window.currentEditingMember = member;
            memberName.textContent = member.name;
            preview.src = member.avatarUrl || createDefaultAvatar(member.name);
            
            // 重置文件输入
            uploadInput.value = '';
            
            modal.style.display = 'flex';
        }

        // 🔥【新增】隐藏群成员头像更换模态框
        function hideMemberAvatarModal() {
            const modal = document.getElementById('member-avatar-modal');
            modal.style.display = 'none';
            window.currentEditingMember = null;
        }

        // 🔥【新增】处理群成员头像上传
        function handleMemberAvatarUpload() {
            const uploadInput = document.getElementById('member-avatar-upload');
            uploadInput.click();
        }

        // 🔥【新增】保存群成员头像
        function saveMemberAvatar() {
            if (!window.currentEditingMember) return;
            
            const preview = document.getElementById('member-avatar-preview');
            const newAvatarUrl = preview.src;
            
            // 更新群成员头像
            const memberIndex = currentChatCharacter.members.findIndex(m => m.id === window.currentEditingMember.id);
            if (memberIndex !== -1) {
                currentChatCharacter.members[memberIndex].avatarUrl = newAvatarUrl;
                
                // 同时更新全局角色列表中的头像
                const characterIndex = characters.findIndex(c => c.id === window.currentEditingMember.id);
                if (characterIndex !== -1) {
                    characters[characterIndex].avatarUrl = newAvatarUrl;
                    saveCharacters(characters);
                }
                
                // 保存群聊数据
                if (groupChats) {
                    const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                    if (groupIndex !== -1) {
                        groupChats[groupIndex].members = currentChatCharacter.members;
                        saveGroupChats(groupChats);
                    }
                }
                
                // 🔥【新增】在群聊消息中添加头像更换提示
                addAvatarChangeMessage(window.currentEditingMember.name);
                
                // 更新UI
                updateGroupChatInfo();
                renderGroupMembersGrid();
                refreshChatMessages(); // 刷新聊天消息显示新头像
                
                showToast(`✅ ${window.currentEditingMember.name} 的头像已更新`, 'success');
            }
            
            hideMemberAvatarModal();
        }

        // 🔥【新增】添加头像更换系统消息
        function addAvatarChangeMessage(memberName) {
            if (!currentChatCharacter || !chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            
            const systemMessage = {
                id: 'system_' + Date.now(),
                type: 'system',
                content: `${memberName} 更换了头像`,
                timestamp: new Date().toISOString(),
                isSystem: true
            };
            
            chatMessages[currentChatCharacter.id].push(systemMessage);
            saveChatMessages();
            
            // 刷新聊天界面
            if (currentChatCharacter) {
                displayChatMessages(currentChatCharacter.id);
            }
        }

        // 🔥【新增】刷新聊天消息以显示新头像
        function refreshChatMessages() {
            if (currentChatCharacter) {
                displayChatMessages(currentChatCharacter.id);
            }
        }

        // 🔥【新增】重置群成员头像为默认
        function resetMemberAvatar() {
            if (!window.currentEditingMember) return;
            
            const preview = document.getElementById('member-avatar-preview');
            const defaultAvatar = createDefaultAvatar(window.currentEditingMember.name);
            preview.src = defaultAvatar;
        }

        // 显示提示消息
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.textContent = message;
            
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
                color: white;
                padding: 12px 24px;
                border-radius: 25px;
                font-size: 14px;
                z-index: 10000;
                opacity: 0;
                transition: all 0.3s ease;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            `;
            
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '1';
                toast.style.transform = 'translateX(-50%) translateY(10px)';
            }, 100);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(-50%) translateY(-10px)';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, 3000);
        }

        // 文本截断函数
        function truncateText(text, maxLength = 80) {
            // 🔥【修复】确保text是字符串类型
            if (text === null || text === undefined) {
                return '';
            }
            
            // 如果不是字符串，转换为字符串
            if (typeof text !== 'string') {
                text = String(text);
            }
            
            if (!text || text.length <= maxLength) return text;
            
            // 按行分割文本
            const lines = text.split('\n');
            let result = '';
            let lineCount = 0;
            
            for (const line of lines) {
                // 限制最多显示3行
                if (lineCount >= 3) break;
                
                if (result.length + line.length + 1 <= maxLength) {
                    result += (result ? '\n' : '') + line;
                    lineCount++;
                } else {
                    // 如果这一行会超出长度限制，截断并添加省略号
                    const remaining = maxLength - result.length - 1;
                    if (remaining > 10) { // 确保有足够空间显示有意义的内容
                        result += (result ? '\n' : '') + line.substring(0, remaining - 3) + '...';
                    } else if (!result) {
                        // 如果是第一行就超长，直接截断
                        result = line.substring(0, maxLength - 3) + '...';
                    } else {
                        // 否则在当前结果后加省略号
                        result += '...';
                    }
                    break;
                }
            }
            
            return result;
        }
        
        // 🔥【新增】消息列表多选删除功能
        
        // 进入消息列表多选模式
        function enterMessageListMultiSelectMode(conversationId) {
            console.log('触发长按多选模式，对话ID:', conversationId); // 调试信息
            isMessageListMultiSelectMode = true;
            selectedConversations = [conversationId]; // 将触发长按的对话添加到选中列表
            renderMessageList(); // 重新渲染列表以显示多选界面
            showToast('已进入多选模式，可以选择多个对话进行删除', 'info');
        }
        
        // 退出消息列表多选模式
        function exitMessageListMultiSelectMode() {
            isMessageListMultiSelectMode = false;
            selectedConversations = [];
            renderMessageList(); // 重新渲染列表恢复正常状态
        }
        
        // 切换对话选择状态
        function toggleConversationSelection(conversationId) {
            const index = selectedConversations.indexOf(conversationId);
            if (index > -1) {
                selectedConversations.splice(index, 1);
            } else {
                selectedConversations.push(conversationId);
            }
            renderMessageList(); // 重新渲染以更新选择状态
        }
        
        // 删除选中的对话
        function deleteSelectedConversations() {
            if (selectedConversations.length === 0) {
                showToast('请先选择要删除的对话', 'error');
                return;
            }
            
            const count = selectedConversations.length;
            const confirmText = `确定要删除选中的 ${count} 个对话吗？\n\n删除后将清空对话的所有聊天记录，但不会删除角色，此操作不可恢复。`;
            
            if (confirm(confirmText)) {
                // 删除选中的对话
                selectedConversations.forEach(conversationId => {
                    // 删除聊天消息
                    if (chatMessages[conversationId]) {
                        delete chatMessages[conversationId];
                    }
                    
                    // 🔥【修复】正确处理单人对话和群聊的删除
                    // 检查是否是群聊
                    const groupIndex = groupChats.findIndex(g => g.id === conversationId);
                    if (groupIndex > -1) {
                        // 删除群聊记录
                        groupChats.splice(groupIndex, 1);
                    } else {
                        // 单人对话：从联系人列表中移除，这样对话框就会消失
                        const contactIndex = contacts.indexOf(conversationId);
                        if (contactIndex > -1) {
                            contacts.splice(contactIndex, 1);
                        }
                    }
                });
                
                // 保存数据
                saveChatMessages();
                saveGroupChats(groupChats);
                saveContacts(); // 🔥【修复】保存联系人列表，因为我们修改了它
                
                // 退出多选模式并刷新界面
                exitMessageListMultiSelectMode();
                
                showToast(`✅ 已删除 ${count} 个对话`, 'success');
            }
        }

    </script>
    
    <!-- 🔥【新增】群成员头像更换模态框 -->
    <div class="modal" id="member-avatar-modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">更换成员头像</h3>
                <button class="modal-close" onclick="hideMemberAvatarModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="member-avatar-form">
                    <div class="current-member-info">
                        <h4 id="member-avatar-name" class="member-name-title">角色名称</h4>
                        <p class="member-info-desc">为该角色设置新的头像，将在群聊中立即生效</p>
                    </div>
                    
                    <div class="avatar-upload-section">
                        <div class="avatar-preview-large">
                            <img id="member-avatar-preview" src="" alt="头像预览" class="preview-image">
                        </div>
                        
                        <div class="upload-buttons">
                            <button class="upload-btn primary" onclick="handleMemberAvatarUpload()">
                                <i class="fas fa-upload"></i>
                                选择新头像
                            </button>
                            <button class="upload-btn secondary" onclick="resetMemberAvatar()">
                                <i class="fas fa-undo"></i>
                                重置默认
                            </button>
                        </div>
                        
                        <input type="file" id="member-avatar-upload" accept="image/*" style="display: none;">
                    </div>
                    
                    <div class="avatar-tips">
                        <div class="tips-header">
                            <i class="fas fa-info-circle"></i>
                            <span>头像更换说明</span>
                        </div>
                        <div class="tips-content">
                            • 支持JPG、PNG等常见图片格式<br>
                            • 建议使用正方形图片，效果更佳<br>
                            • 头像更换后将在群聊中立即显示<br>
                            • 角色也可以在聊天时自主更换头像
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-button modal-secondary" onclick="hideMemberAvatarModal()">取消</button>
                <button class="modal-button modal-primary" onclick="saveMemberAvatar()">保存更改</button>
            </div>
        </div>
    </div>

    <!-- 群公告编辑模态框 -->
    <div class="modal" id="group-notice-modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">编辑群公告</h3>
                <button class="modal-close" onclick="hideGroupNoticeModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="group-notice-form">
                    <div class="form-group">
                        <label class="form-label">群公告内容</label>
                        <textarea 
                            id="group-notice-content" 
                            class="form-textarea group-notice-textarea" 
                            placeholder="输入群公告内容...&#10;&#10;可以包括：&#10;• 群规则说明&#10;• 重要通知&#10;• 活动安排&#10;• 其他事项"
                            maxlength="500"></textarea>
                        <div class="notice-char-count">
                            <span id="notice-char-current">0</span>/500字
                        </div>
                    </div>
                    <div class="notice-tips">
                        <div class="tips-header">
                            <i class="fas fa-lightbulb"></i>
                            <span>公告小贴士</span>
                        </div>
                        <div class="tips-content">
                            • 简洁明了，突出重点<br>
                            • 使用友好的语调<br>
                            • 定期更新重要信息<br>
                            • 可以使用emoji增加趣味性
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary" onclick="hideGroupNoticeModal()">取消</button>
                <button class="modal-primary" onclick="saveGroupNotice()">保存公告</button>
            </div>
        </div>
    </div>
    
    <!-- 定时发布时间设置模态框 -->
    <div class="modal" id="schedule-times-modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">定时发布时间设置</h3>
                <button class="modal-close" onclick="hideModal('schedule-times-modal')">&times;</button>
            </div>
            <div class="modal-body">
                <p style="color: #666; font-size: 14px; margin-bottom: 15px;">
                    设置角色每天自动发布动态的时间点（最多10个）
                </p>
                <div id="schedule-times-container">
                    <!-- 时间输入项将动态生成 -->
                </div>
                <button onclick="addScheduleTime()" style="margin-top: 10px; padding: 8px 16px; background: #007AFF; color: white; border: none; border-radius: 6px; cursor: pointer;">
                    + 添加时间点
                </button>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary" onclick="hideModal('schedule-times-modal')">取消</button>
                <button class="modal-primary" onclick="saveScheduleTimes()">保存</button>
            </div>
        </div>
    </div>

    <!-- 位置分享模态框 -->
    <div id="location-modal" class="modal" style="display: none;">
        <div class="modal-content location-modal-content">
            <div class="modal-header">
                <h3 class="modal-title">分享位置</h3>
                <button class="modal-close" onclick="hideLocationModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="location-input-section">
                    <label for="location-address">位置名称</label>
                    <input type="text" id="location-address" placeholder="请输入位置名称，如：咖啡厅、学校、家..." maxlength="50">
                    
                    <!-- 最近使用历史记录 -->
                    <div class="location-history" id="location-history">
                        <div class="location-history-title">📍 最近使用</div>
                        <div class="location-history-items" id="location-history-items">
                            <div class="location-history-empty">暂无历史记录</div>
                        </div>
                    </div>
                </div>
                <div class="virtual-map-container">
                    <div class="map-header" style="background: linear-gradient(135deg, #f6ffed 0%, #d9f7be 100%);">
                        <div class="map-location-name" id="map-location-display" style="color: #52c41a;">请输入位置名称</div>
                        <div class="map-coordinates" style="color: #73d13d;">116.4074°E, 39.9042°N</div>
                    </div>
                    <div class="virtual-map">
                        <div class="map-background"></div>
                        <!-- 弯曲河流 -->
                        <div class="river" style="top: 8%; left: 55%; width: 25px; height: 4px; transform: rotate(30deg);"></div>
                        <div class="river-curve" style="top: 18%; left: 68%; width: 22px; height: 4px; transform: rotate(10deg);"></div>
                        <div class="river" style="top: 26%; left: 78%; width: 20px; height: 4px; transform: rotate(-10deg);"></div>
                        <div class="river-curve" style="top: 32%; left: 85%; width: 18px; height: 4px; transform: rotate(-30deg);"></div>
                        <div class="river" style="top: 60%; left: 5%; width: 28px; height: 4px; transform: rotate(-15deg);"></div>
                        <div class="river-curve" style="top: 68%; left: 25%; width: 25px; height: 4px; transform: rotate(5deg);"></div>
                        <div class="river" style="top: 75%; left: 42%; width: 22px; height: 4px; transform: rotate(20deg);"></div>
                        <!-- 公园绿地 -->
                        <div style="position: absolute; top: 25%; left: 65%; width: 25px; height: 20px; background: linear-gradient(135deg, #f6ffed 0%, #d9f7be 50%, #b7eb8f 100%); border-radius: 3px; opacity: 0.6; z-index: 1;"></div>
                        <div style="position: absolute; top: 50%; left: 15%; width: 30px; height: 25px; background: linear-gradient(135deg, #f6ffed 0%, #d9f7be 50%, #b7eb8f 100%); border-radius: 3px; opacity: 0.6; z-index: 1;"></div>
                        <!-- 道路 -->
                        <div class="map-roads">
                            <div class="road road-horizontal" style="top: 30%; left: 0; width: 100%;"></div>
                            <div class="road road-vertical" style="left: 25%; top: 0; height: 100%;"></div>
                            <div class="road road-horizontal" style="top: 70%; left: 0; width: 100%;"></div>
                            <div class="road road-vertical" style="left: 75%; top: 0; height: 100%;"></div>
                        </div>
                        <!-- 建筑物 -->
                        <div class="map-buildings">
                            <div class="building" style="top: 10%; left: 35%; width: 20px; height: 15px; background: linear-gradient(135deg, #f0f0f0 0%, #d9d9d9 100%); border: 1px solid #bfbfbf; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                            <div class="building" style="top: 15%; left: 55%; width: 25px; height: 20px; background: linear-gradient(135deg, #e6f7ff 0%, #bae7ff 100%); border: 1px solid #91d5ff; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                            <div class="building" style="top: 40%; left: 10%; width: 18px; height: 12px; background: linear-gradient(135deg, #fff1f0 0%, #ffd8d6 100%); border: 1px solid #ffaaa5; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                            <div class="building" style="top: 45%; left: 85%; width: 22px; height: 18px; background: linear-gradient(135deg, #f0f0f0 0%, #d9d9d9 100%); border: 1px solid #bfbfbf; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                            <div class="building" style="top: 75%; left: 40%; width: 30px; height: 20px; background: linear-gradient(135deg, #e6f7ff 0%, #bae7ff 100%); border: 1px solid #91d5ff; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                            <div class="building" style="top: 80%; left: 15%; width: 20px; height: 15px; background: linear-gradient(135deg, #fff1f0 0%, #ffd8d6 100%); border: 1px solid #ffaaa5; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                        </div>
                        <!-- 树木 -->
                        <div style="position: absolute; top: 35%; left: 20%; width: 8px; height: 8px; background: radial-gradient(circle, #52c41a 0%, #389e0d 70%, #237804 100%); border-radius: 50%; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15); z-index: 3;"></div>
                        <div style="position: absolute; top: 60%; left: 30%; width: 6px; height: 6px; background: radial-gradient(circle, #73d13d 0%, #52c41a 70%, #389e0d 100%); border-radius: 50%; box-shadow: 0 0.5px 1px rgba(0, 0, 0, 0.1); z-index: 3;"></div>
                        <div style="position: absolute; top: 12%; left: 70%; width: 7px; height: 7px; background: radial-gradient(circle, #52c41a 0%, #389e0d 70%, #237804 100%); border-radius: 50%; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15); z-index: 3;"></div>
                        <div style="position: absolute; top: 85%; left: 90%; width: 5px; height: 5px; background: radial-gradient(circle, #73d13d 0%, #52c41a 70%, #389e0d 100%); border-radius: 50%; box-shadow: 0 0.5px 1px rgba(0, 0, 0, 0.1); z-index: 3;"></div>
                        <div style="position: absolute; top: 50%; left: 90%; width: 6px; height: 6px; background: radial-gradient(circle, #73d13d 0%, #52c41a 70%, #389e0d 100%); border-radius: 50%; box-shadow: 0 0.5px 1px rgba(0, 0, 0, 0.1); z-index: 3;"></div>
                        <!-- 位置标记 -->
                        <div class="map-marker" id="location-marker">
                            <div class="marker-pin" style="color: #1890ff;">📍</div>
                        </div>
                        <div class="map-current-location">
                            <div class="current-location-dot"></div>
                        </div>
                    </div>
                    <div class="map-footer">
                        <div class="map-scale">500m</div>
                        <div class="map-controls">
                            <button class="map-control-btn" onclick="randomizeMapPosition()">🎯 重新定位</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary" onclick="hideLocationModal()">取消</button>
                <button class="modal-primary" onclick="sendLocationMessage()">发送位置</button>
            </div>
        </div>
    </div>
    </div>

    <script>
        // 🔥【新增】群成员头像上传事件监听
        document.addEventListener('DOMContentLoaded', function() {
            const memberAvatarUpload = document.getElementById('member-avatar-upload');
            if (memberAvatarUpload) {
                memberAvatarUpload.addEventListener('change', function(e) {
                    if (e.target.files && e.target.files[0]) {
                        const file = e.target.files[0];
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            const preview = document.getElementById('member-avatar-preview');
                            if (preview) {
                                preview.src = event.target.result;
                            }
                        };
                        reader.readAsDataURL(file);
                    }
                });
            }
        });
    </script>

    <!-- 🔥【永久修复】身份选择功能自动修复脚本 -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🔧 开始应用身份选择功能永久修复...');
            
            // 修复1: 重写showPersonaSelectionForSingleChat函数
            if (typeof showPersonaSelectionForSingleChat === 'function') {
                const originalShowPersonaSelectionForSingleChat = showPersonaSelectionForSingleChat;
                showPersonaSelectionForSingleChat = function() {
                    originalShowPersonaSelectionForSingleChat();
                    
                    // 延迟修复事件绑定，确保DOM已生成
                    setTimeout(() => {
                        const items = document.querySelectorAll('#persona-selection-modal .persona-selection-item');
                        console.log('🔧 修复身份选择事件绑定，找到元素:', items.length);
                        
                        items.forEach(item => {
                            // 移除旧的事件监听器
                            item.onclick = null;
                            
                            // 添加新的点击事件
                            item.addEventListener('click', function() {
                                console.log('身份选择点击:', this.dataset.personaId);
                                
                                // 移除所有选中状态
                                document.querySelectorAll('#persona-selection-modal .persona-selection-item').forEach(i => {
                                    i.classList.remove('selected');
                                });
                                
                                // 设置当前元素为选中
                                this.classList.add('selected');
                                
                                // 保存身份ID
                                window.selectedPersonaForChat = this.dataset.personaId;
                                console.log('设置selectedPersonaForChat:', window.selectedPersonaForChat);
                                
                                // 启用确认按钮
                                const confirmBtn = document.getElementById('confirm-persona-btn');
                                if (confirmBtn) {
                                    confirmBtn.disabled = false;
                                }
                            });
                        });
                    }, 100);
                };
            }
            
            // 修复2: 重写confirmPersonaAndShowCharacters函数
            if (typeof confirmPersonaAndShowCharacters === 'function') {
                confirmPersonaAndShowCharacters = function() {
                    console.log('confirmPersonaAndShowCharacters调用，身份ID:', window.selectedPersonaForChat);
                    
                    if (!window.selectedPersonaForChat) {
                        console.error('身份ID为空！');
                        return;
                    }
                    
                    // 保存身份ID
                    const savedPersonaId = window.selectedPersonaForChat;
                    
                    // 隐藏模态框
                    const modal = document.getElementById('persona-selection-modal');
                    if (modal) {
                        modal.remove();
                    }
                    
                    // 恢复身份ID
                    window.selectedPersonaForChat = savedPersonaId;
                    console.log('保护后的身份ID:', window.selectedPersonaForChat);
                    
                    showCharacterSelectionForSingleChat();
                };
            }
            
            // 修复3: 重写buildCharacterPrompt函数
            if (typeof buildCharacterPrompt === 'function') {
                const originalBuildCharacterPrompt = buildCharacterPrompt;
                buildCharacterPrompt = function(character, hasImage = false) {
                    // 调用原函数获取基础prompt
                    let characterPrompt = originalBuildCharacterPrompt(character, hasImage);
                    
                    // 移除原有的currentPersona逻辑，替换为从聊天设置读取
                    const chatSettings = getCurrentChatSettings();
                    if (chatSettings.selectedIdentityId) {
                        const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                        if (selectedPersona) {
                            console.log('🔧 为角色', character.name, '使用身份:', selectedPersona.name);
                            
                            // 移除旧的身份信息（如果有）
                            const personaRegex = /\n\n# 对话者的角色设定：[\s\S]*?请根据用户的这个面具身份来进行对话。/;
                            characterPrompt = characterPrompt.replace(personaRegex, '');
                            
                            // 添加新的身份信息
                            const personaInfo = `\n\n# 对话者的角色设定：\n用户当前使用的面具是"${selectedPersona.name}"${selectedPersona.description ? `：${selectedPersona.description}` : ''}\n请根据用户的这个面具身份来进行对话。`;
                            
                            // 在角色设定后插入身份信息
                            const insertPoint = characterPrompt.indexOf('\n# 🔥【修复】表情包库信息');
                            if (insertPoint !== -1) {
                                characterPrompt = characterPrompt.slice(0, insertPoint) + personaInfo + characterPrompt.slice(insertPoint);
                            } else {
                                characterPrompt += personaInfo;
                            }
                        }
                    }
                    
                    return characterPrompt;
                };
            }
            
            console.log('✅ 身份选择功能永久修复已应用');
        });
    </script>

    <!-- 🔧【简单修复】群聊身份设置直接修复 -->
    <script>
        // 简单直接的群聊身份修复
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🔧 [简单修复] 群聊身份设置修复启动...');
            
            // 重写createGroupChat函数，确保身份设置立即生效
            if (typeof window.createGroupChat === 'function') {
                const originalCreateGroupChat = window.createGroupChat;
                window.createGroupChat = async function(personaId) {
                    console.log('🔧 [修复] createGroupChat被调用，身份ID:', personaId);
                    
                    // 调用原函数，传递personaId参数
                    await originalCreateGroupChat.call(this, personaId);
                    
                    // 如果有选择身份，立即加载到内存
                    if (personaId && groupChats && groupChats.length > 0) {
                        const latestGroup = groupChats[groupChats.length - 1];
                        const savedSettings = localStorage.getItem(`chatSettings_${latestGroup.id}`);
                        
                        if (savedSettings) {
                            try {
                                const settings = JSON.parse(savedSettings);
                                window.chatSettings[latestGroup.id] = settings;
                                console.log('🔧 [修复] 群聊身份设置已加载到内存:', settings);
                            } catch (error) {
                                console.error('🔧 [修复] 解析群聊设置失败:', error);
                            }
                        }
                    }
                };
            }
            
            console.log('🔧 [简单修复] 群聊身份设置修复完成');
        });
    </script>

    <!-- 📱【移动端优化】输入框viewport行为修复 -->
    <script>
        // 移动端输入框优化
        (function() {
            'use strict';
            
            console.log('📱 [移动端优化] 输入框viewport行为修复启动...');
            
            let isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            let isAndroid = /Android/.test(navigator.userAgent);
            let isMobile = isIOS || isAndroid;
            
            if (!isMobile) {
                console.log('📱 非移动端设备，跳过移动端优化');
                return;
            }
            
            // 获取所有可能的输入框
            function getAllInputs() {
                return document.querySelectorAll('textarea, input[type="text"], input[type="password"], input[type="email"], input[type="number"]');
            }
            
            // 防止iOS Safari自动缩放
            function preventZoom() {
                const viewportMeta = document.querySelector('meta[name="viewport"]');
                if (viewportMeta) {
                    viewportMeta.setAttribute('content', 
                        'width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no'
                    );
                }
            }
            
            // 恢复缩放功能
            function restoreZoom() {
                const viewportMeta = document.querySelector('meta[name="viewport"]');
                if (viewportMeta) {
                    viewportMeta.setAttribute('content', 
                        'width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=3.0, user-scalable=yes'
                    );
                }
            }
            
            // 输入框焦点处理
            function handleInputFocus(e) {
                console.log('📱 输入框获得焦点，防止自动缩放');
                
                // 防止iOS自动缩放
                if (isIOS) {
                    preventZoom();
                }
                
                // 确保输入框可见
                setTimeout(() => {
                    e.target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center'
                    });
                }, 300);
            }
            
            // 输入框失焦处理
            function handleInputBlur(e) {
                console.log('📱 输入框失去焦点，恢复缩放功能');
                
                // 恢复缩放功能
                if (isIOS) {
                    setTimeout(() => {
                        restoreZoom();
                    }, 100);
                }
                
                // 滚动回顶部
                setTimeout(() => {
                    window.scrollTo(0, 0);
                }, 100);
            }
            
            // 绑定事件到所有输入框
            function bindInputEvents() {
                const inputs = getAllInputs();
                console.log(`📱 找到 ${inputs.length} 个输入框，正在绑定事件...`);
                
                inputs.forEach(input => {
                    // 移除旧的事件监听器（如果存在）
                    input.removeEventListener('focus', handleInputFocus);
                    input.removeEventListener('blur', handleInputBlur);
                    
                    // 添加新的事件监听器
                    input.addEventListener('focus', handleInputFocus, { passive: true });
                    input.addEventListener('blur', handleInputBlur, { passive: true });
                    
                    // 确保输入框字体大小至少16px（防止iOS缩放）
                    const computedStyle = window.getComputedStyle(input);
                    const fontSize = parseInt(computedStyle.fontSize);
                    if (fontSize < 16) {
                        input.style.fontSize = '16px';
                        console.log('📱 调整输入框字体大小为16px，防止iOS缩放');
                    }
                });
            }
            
            // 监听DOM变化，处理动态添加的输入框
            const observer = new MutationObserver(function(mutations) {
                let shouldRebind = false;
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList') {
                        mutation.addedNodes.forEach(function(node) {
                            if (node.nodeType === 1) { // Element node
                                if (node.matches && (node.matches('textarea') || node.matches('input'))) {
                                    shouldRebind = true;
                                } else if (node.querySelector) {
                                    const inputs = node.querySelectorAll('textarea, input');
                                    if (inputs.length > 0) {
                                        shouldRebind = true;
                                    }
                                }
                            }
                        });
                    }
                });
                
                if (shouldRebind) {
                    console.log('📱 检测到新的输入框，重新绑定事件...');
                    setTimeout(bindInputEvents, 100);
                }
            });
            
            // 开始监听DOM变化
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
            
            // 页面加载完成后绑定事件
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', bindInputEvents);
            } else {
                bindInputEvents();
            }
            
            // 页面显示时重新绑定（处理从后台返回的情况）
            document.addEventListener('visibilitychange', function() {
                if (!document.hidden) {
                    setTimeout(bindInputEvents, 100);
                }
            });
            
            console.log('📱 [移动端优化] 输入框viewport行为修复已启动');
        })();
    </script>

    <!-- 💰【转账功能优化】让AI根据人设自然回应 -->
    <script>
        // 转账功能优化 - 移除自动收款，让AI根据人设自然回应
        (function() {
            'use strict';
            
            console.log('💰 [转账优化] 移除自动收款逻辑，让AI根据人设自然回应...');
            
            // 🔥【重要修改】移除自动收款逻辑，让AI根据角色人设自然决定
            // 转账状态变化应该由AI的自然回复触发，而不是自动处理
            // AI会根据自己的人设（比如高冷、温柔、傲娇等）来决定是否收款
            
            console.log('💰 [转账优化] AI将根据角色人设自然回应转账，不再自动收款');
        })();
    </script>
</body>
</html>