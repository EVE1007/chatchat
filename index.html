<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>EVE Chat</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>💬</text></svg>">
    <script src="https://cdn.jsdelivr.net/npm/dexie/dist/dexie.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@400;500;600;700&family=Comic+Neue:wght@400;700&family=Fredoka+One&family=Nunito:wght@400;500;600;700&family=Montserrat:wght@400;500;600&family=Inter:wght@400;500;600&family=Roboto:wght@400;500&family=Raleway:wght@400;500;600&family=Lato:wght@400;700&family=Poppins:wght@400;500;600&family=Quicksand:wght@400;500;600&family=Varela+Round&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css?v=20250721-fix-bubble-width">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <!-- 🔥【新增】状态指示器样式 -->
    <style>
        /* 角色列表状态指示器 */
        .contact-status-indicator {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            z-index: 10;
        }

        /* 已拉黑状态 - 红色 */
        .contact-status-indicator.blocked {
            background-color: #ff4444;
            color: white;
        }

        /* 被拉黑状态 - 深橙色 */
        .contact-status-indicator.blocked-by {
            background-color: #ff8800;
            color: white;
        }

        /* 已屏蔽群聊状态 - 橙色 */
        .contact-status-indicator.muted {
            background-color: #ff9500;
            color: white;
        }

        /* 确保角色项有相对定位 */
        .contact-item {
            position: relative;
        }

        /* 🔥【新增】消息列表状态指示器样式 */
        .message-avatar-container {
            position: relative;
            display: inline-block;
        }

        .message-status-indicator {
            position: absolute;
            right: 2px;
            bottom: 1px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            z-index: 10;
        }

        /* 已拉黑状态 - 红色 */
        .message-status-indicator.blocked {
            background-color: #ff4444;
            color: white;
        }

        /* 被拉黑状态 - 深橙色 */
        .message-status-indicator.blocked-by {
            background-color: #ff8800;
            color: white;
        }

        /* 已屏蔽群聊状态 - 橙色 */
        .message-status-indicator.muted {
            background-color: #ff9500;
            color: white;
        }

        /* 🔥【新增】未读消息提示样式 */
        .unread-badge {
            position: absolute;
            right: -2px;
            top: -2px;
            min-width: 16px;
            height: 16px;
            border-radius: 50%;
            background-color: #ff4444;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            z-index: 15;
            padding: 0 4px;
            box-sizing: border-box;
        }

        /* 当数字超过99时，显示99+ */
        .unread-badge.large-count {
            font-size: 8px;
            min-width: 20px;
            border-radius: 10px;
        }

        /* 🔥【重新设计】消息列表多选模式按钮 - 放在app-header中 */
        .chat-header-multiselect-actions {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .multiselect-btn {
            padding: 4px 8px;
            border: none;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
            min-width: 50px;
            width: 50px;
            height: 24px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            white-space: nowrap;
            flex-shrink: 0;
            color: white;
        }

        .multiselect-btn i {
            font-size: 10px;
        }

        .multiselect-btn.pin-btn {
            background: rgba(243, 156, 18, 0.85);
        }

        .multiselect-btn.delete-btn {
            background: rgba(231, 76, 60, 0.85);
        }

        .multiselect-btn.cancel-btn {
            background: rgba(52, 152, 219, 0.85);
        }

        /* 🔥【重新设计】置顶对话的视觉标识 - 主题化颜色 */
        .message-item.pinned {
            background: rgba(74, 132, 193, 0.08);
            border-left: 3px solid rgba(74, 132, 193, 0.3);
        }

        /* 可爱主题下的置顶对话样式 */
        body[data-theme="cute"] .message-item.pinned {
            background: rgba(255, 182, 193, 0.08);
            border-left: 3px solid rgba(255, 182, 193, 0.3);
        }

        .pin-indicator {
            position: absolute;
            top: 5px;
            right: 5px;
            color: #ffd700;
            font-size: 12px;
            z-index: 5;
        }
    </style>

</head>
<body>
        <!-- 推送通知容器 -->
        <div id="notification-container"></div>
    <div id="phone-frame">
    <div id="phone-screen">
        <div class="wallpaper" id="wallpaper-element">
            <!-- 主屏幕状态栏 -->
            <div id="status-bar">
                <span id="status-bar-time">14:25</span>
                <div id="status-bar-battery" class="battery-container">
                    <span class="battery-text">ᰔᩚ</span>
                    <div class="battery-icon">
                        <div class="battery-level"></div>
                    </div>
                </div>
            </div>

            <!-- 音乐显示区域（类似灵动岛） - 独立于状态栏 -->
            <div id="music-status-display" class="music-status-display" style="display: none;" onclick="openMusicModal()">
                <i class="fas fa-headphones music-icon"></i>
                <div class="music-lyrics-scroll">
                    <span id="current-lyric">♪ 点击开始听歌</span>
                </div>
            </div>
            
            <!-- 时钟容器 -->
            <div id="clock-container">
                <div id="main-time">14:25</div>
                <div id="main-date">12月18日 星期一</div>
            </div>
            
            <div id="worldbook-screen" class="app-screen">
                <div class="app-status-bar">
                    <div class="app-status-time"></div>
                    <div class="app-battery-container">
                        <span class="battery-text">ᰔᩚ</span>
                        <div class="app-battery-icon">
                            <div class="app-battery-level"></div>
                        </div>
                    </div>
                </div>
                <div class="app-header">
                    <button class="back-button" onclick="hideApp('worldbook-screen')">‹</button>
                    <div class="app-title">世界书</div>
                    <div class="add-worldbook-btn worldbook-add-btn" onclick="onWorldbookAddClick()">
                        <i class="fas fa-plus"></i>
                    </div>
                </div>

                <div class="app-content">
                    <div id="global-worldbooks-content" class="worldbook-content-pane">
                        </div>
                    <div id="local-worldbooks-content" class="worldbook-content-pane" style="display: none;">
                        </div>
                    <div id="character-worldbooks-content" class="worldbook-content-pane" style="display: none;">
                        </div>
                </div>

                <!-- 世界书分类选择器 -->
                <div class="worldbook-category-selector" id="worldbook-category-selector" style="display: none;">
                    <div class="category-selector-content">
                        <div class="category-selector-title">选择角色分类</div>
                        <div class="category-options" id="category-options">
                            <!-- 动态生成角色分类 -->
                        </div>
                        <div class="category-selector-actions">
                            <button class="category-cancel-btn" onclick="hideCategorySelector()">取消</button>
                        </div>
                    </div>
                </div>

                <div class="worldbook-tabs">
                    <div class="worldbook-tab active" onclick="switchWorldbookTab('global')">
                        <i class="fas fa-globe-asia"></i>
                        <span>全局设定</span>
                    </div>
                    <div class="worldbook-tab" onclick="switchWorldbookTab('local')">
                        <i class="fas fa-comment-dots"></i>
                        <span>局部设定</span>
                    </div>
                    <div class="worldbook-tab" onclick="switchWorldbookTab('character')">
                        <i class="fas fa-users"></i>
                        <span id="character-tab-text">角色设定</span>
                    </div>
                </div>
            </div>
                
                <!-- 主屏幕四块布局 -->
                <div id="home-grid">
                    <!-- 左上角：图片小组件 -->
                    <div class="home-section top-left">
                        <div class="widget photo-widget" onclick="showPhotoWidgetOptions()">
                            <div class="photo-widget-content" id="photo-widget-content">
                                <div class="photo-placeholder" id="photo-placeholder">
                                    <i class="fas fa-image"></i>
                                    <span>点击添加图片</span>
                                </div>
                                <img class="photo-widget-image" id="photo-widget-image" style="display: none;">
                            </div>
                        </div>
                    </div>

                    <!-- 右上角：两个应用 -->
                    <div class="home-section top-right">
                        <div class="apps-grid-2">
                            <a href="#" class="mini-app" onclick="showApp('chat-screen')">
                                <div class="mini-app-icon">
                                    <img src="https://i.postimg.cc/dVSd9QBz/IMG-3063.jpg" alt="Chat" class="app-icon-img">
                                </div>
                                <span>Chat</span>
                            </a>
                            <a href="#" class="mini-app" onclick="showApp('worldbook-screen'); switchWorldbookTab('global');">
                                <div class="mini-app-icon">
                                    <img src="https://i.postimg.cc/Xqz3zPz7/IMG-3080.jpg" alt="世界书" class="app-icon-img">
                                </div>
                                <span>世界书</span>
                            </a>
                        </div>
                    </div>

                    <!-- 左下角：两个应用 -->
                    <div class="home-section bottom-left">
                        <div class="apps-grid-2">
                            <a href="#" class="mini-app" onclick="showApp('game-screen')">
                                <div class="mini-app-icon">
                                    <i class="fas fa-gamepad"></i>
                                </div>
                                <span>游戏</span>
                            </a>
                            <a href="#" class="mini-app" onclick="showApp('forum-screen')">
                                <div class="mini-app-icon">
                                    <i class="fas fa-comments"></i>
                                </div>
                                <span>论坛</span>
                            </a>
                        </div>
                    </div>

                    <!-- 右下角：纪念日小组件 -->
                    <div class="home-section bottom-right">
                        <div class="widget anniversary-widget" onclick="showApp('anniversary-screen')" style="cursor: pointer;">
                            <div class="anniversary-widget-content" id="anniversary-widget-content">
                                <div class="anniversary-placeholder" id="anniversary-placeholder">
                                    <i class="fas fa-heart"></i>
                                    <span>暂无纪念日</span>
                                </div>
                                <div class="anniversary-display" id="anniversary-display" style="display: none;">
                                    <div class="anniversary-name" id="widget-anniversary-name"></div>
                                    <div class="anniversary-countdown" id="widget-anniversary-countdown"></div>
                                    <div class="anniversary-date" id="widget-anniversary-date"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- iPhone风格Dock栏 -->
                <div id="dock-bar">
                    <div class="dock-container">
                        <a href="#" class="dock-app" onclick="showApp('messages-screen')">
                            <div class="dock-app-icon">
                                <i class="fas fa-comment-dots"></i>
                            </div>
                            <span>短信</span>
                        </a>
                        <a href="#" class="dock-app" onclick="showApp('settings-screen')">
                            <div class="dock-app-icon">
                                <img src="https://i.postimg.cc/764L3jpF/IMG-3079.jpg" alt="设置" class="app-icon-img">
                            </div>
                            <span>设置</span>
                        </a>
                        <a href="#" class="dock-app" onclick="showApp('memory-viewer-screen')">
                            <div class="dock-app-icon">
                                <i class="fas fa-brain"></i>
                            </div>
                            <span>记忆</span>
                        </a>
                    </div>
                </div>

                
                <!-- 纪念日界面 -->
                <div id="anniversary-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('anniversary-screen')">‹</button>
                        <div class="app-title">纪念日</div>
                        <div class="add-anniversary-btn" onclick="showAnniversaryForm()">
                            <i class="fas fa-plus"></i>
                        </div>
                    </div>
                    <div class="app-content">
                        <div id="anniversary-list" class="anniversary-list">
                            <!-- 纪念日列表将通过JS动态生成 -->
                            <div class="anniversary-empty-state">
                                <i class="fas fa-heart"></i>
                                <p>还没有纪念日</p>
                                <p>点击右上角 + 添加重要的日子</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 短信界面 -->
                <div id="messages-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('messages-screen')">‹</button>
                        <div class="app-title">短信</div>
                        <div class="add-message-btn" onclick="showNewMessageForm()">
                            <i class="fas fa-edit"></i>
                        </div>
                    </div>
                    <div class="app-content">
                        <div id="messages-list" class="messages-list">
                            <!-- 短信列表将通过JS动态生成 -->
                            <div class="messages-empty-state">
                                <i class="fas fa-comment-dots"></i>
                                <p>暂无短信</p>
                                <p>这是一个预留功能</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 聊天界面 -->
                <div id="chat-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('chat-screen')">‹</button>
                        <div class="app-title">💬</div>
                        <div class="chat-header-actions">
                            <div id="group-manage-btn" class="header-action-btn" onclick="enterGroupManageMode()" title="管理分组">
                                <i class="fas fa-cog"></i>
                            </div>
                            <div id="add-contact-btn" class="add-btn" onclick="showCharacterForm()">
                                <i class="fas fa-plus"></i>
                            </div>
                            <div id="add-chat-btn" class="add-btn" onclick="showChatOptions()">
                                <i class="fas fa-plus"></i>
                            </div>
                        </div>
                    </div>
                    
                    <div class="app-content" id="chat-content">
                        <!-- 默认显示消息列表 -->
                        <div class="message-list" id="message-list">
                            <!-- 消息列表将通过JS动态生成 -->
                        </div>
                        
                        <!-- 通讯录 -->
                        <div class="contact-list hide" id="contact-list">
                            <div class="contact-section">
        
                                <!-- 角色列表将通过JS动态生成 -->
                            </div>

                        </div>
                        
                        <!-- 动态页面 -->
                        <div class="moments-page hide moments-page-no-padding" id="moments-page">
                            <div class="moments-header">
                                <div class="moments-cover" onclick="changeCoverImage()">
                                    <div class="cover-image-placeholder" id="cover-placeholder">
                                        <div class="cover-placeholder-text">点击更换封面</div>
                                        </div>
                                    <img class="cover-image hide" id="cover-image" src="">
                                    </div>
                                
                                <!-- 用户名，独立放置在头像左上角 -->
                                <div class="moments-username" onclick="changeUsername(event)" id="moments-username">用户</div>
                                
                                <!-- 独立的头像，跨越背景和动态列表区域，放在header外面 -->
                                <div class="moments-avatar" onclick="changeAvatarImage(event)" id="moments-avatar">
                                    <i class="fas fa-user moments-avatar-icon"></i>
                                </div>
                            </div>
                            
                            <div class="moments-list" id="moments-list">
                                <!-- 动态列表将通过JS动态生成 -->
                            </div>
                            

                        </div>

                        
                        <!-- 面具区域 -->
                        <div class="profile-page hide" id="profile-page">
                            <div class="persona-header">
                                <div class="persona-title">
                                    <h2>我的面具</h2>
                                    <p>管理你的多重身份设定</p>
                                </div>
                                <div class="add-persona-btn persona-add-btn" onclick="showPersonaForm()">
                                    <i class="fas fa-plus"></i>
                                </div>
                            </div>
                            
                            <div class="persona-list" id="persona-list">
                                <!-- 面具列表将通过JS动态生成 -->
                            </div>
                            

                        </div>
                    </div>
                    
                    <div class="chat-tabs">
                        <div class="chat-tab active" onclick="switchChatTab('message-list')" id="message-tab">
                            <i class="fas fa-comments"></i>
                            <span>消息</span>
                        </div>
                        <div class="chat-tab" onclick="switchChatTab('contact-list')">
                            <i class="fas fa-user-friends"></i>
                            <span>角色</span>
                        </div>
                        <div class="chat-tab" onclick="switchChatTab('moments-page')">
                            <i class="fas fa-globe-americas"></i>
                            <span>动态</span>
                        </div>
                        <div class="chat-tab" onclick="switchChatTab('profile-page')">
                            <i class="fas fa-user-circle"></i>
                            <span>我</span>
                        </div>
                    </div>
                </div>
                
                <!-- 发布动态界面 -->
                <div id="publish-moment-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hidePublishMoment()">‹</button>
                        <div class="app-title">发表动态</div>
                        <button class="publish-btn" onclick="publishMoment()">发表</button>
                    </div>
                    <div class="app-content">
                        <div class="publish-moment-form">
                            <!-- 文字输入区域 -->
                            <div class="moment-text-input">
                                <textarea 
                                    id="moment-text" 
                                    placeholder="分享新鲜事..." 
                                    class="moment-textarea"
                                    maxlength="500"
                                    oninput="updateTextCount()"></textarea>
                                <div class="text-count" id="text-count">0/500</div>
                            </div>
                            
                            <!-- 图片上传区域 -->
                            <div class="moment-images-section">
                                <div class="moment-images-grid" id="moment-images-grid">
                                    <!-- 动态添加的图片预览 -->
                                </div>
                                <div class="add-image-btn" onclick="addMomentImage()">
                                    <i class="fas fa-plus"></i>
                                    <span>添加图片</span>
                                </div>
                            </div>
                            
                            <!-- 发布选项 -->
                            <div class="publish-options">
                                <div class="option-item">
                                    <i class="fas fa-map-marker-alt"></i>
                                    <span>所在位置</span>
                                    <i class="fas fa-chevron-right"></i>
                                </div>
                                <div class="option-item">
                                    <i class="fas fa-users"></i>
                                    <span>提醒谁看</span>
                                    <i class="fas fa-chevron-right"></i>
                                </div>
                                <div class="option-item">
                                    <i class="fas fa-eye"></i>
                                    <span>谁可以看</span>
                                    <span class="option-value">公开</span>
                                    <i class="fas fa-chevron-right"></i>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 论坛界面 -->
                <div id="forum-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon"><div class="app-battery-level"></div></div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('forum-screen')">‹</button>
                        <div class="app-title">论坛</div>
                        <div class="add-forum-btn" onclick="showCreateForumScreen()">
                            <i class="fas fa-plus"></i>
                        </div>
                    </div>
                    <div class="app-content">
                        <div id="forum-archive-list" class="forum-archive-list">
                            <div class="forum-empty-state">
                                <i class="fas fa-comments"></i>
                                <p>还没有创建任何论坛</p>
                                <p>点击右上角 + 创建你的第一个论坛</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 创建论坛界面 -->
                <div id="create-forum-screen" class="app-screen">
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('create-forum-screen')">‹</button>
                        <div class="app-title">创建新论坛</div>
                    </div>
                    <div class="app-content">
                        <div class="form-group">
                            <label class="form-label">论坛名称</label>
                            <input type="text" id="forum-name-input" class="form-input" placeholder="给这个世界线起个名字吧">
                        </div>
                        <div class="form-group">
                            <label class="form-label">选择角色 (可多选)</label>
                            <div id="forum-character-selection" class="selection-grid"></div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">选择你的身份</label>
                            <div id="forum-persona-selection" class="selection-grid single-selection"></div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">补充世界观 (可选)</label>
                            <textarea id="forum-worldview-input" class="form-textarea" rows="4" placeholder="补充一些背景故事或设定..."></textarea>
                        </div>
                        <button class="form-submit" onclick="createForum()">进入论坛</button>
                    </div>
                </div>

                <!-- 帖子列表界面 -->
                <div id="forum-view-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon"><div class="app-battery-level"></div></div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToForumArchives()">‹</button>
                        <div class="app-title" id="forum-view-title">论坛</div>
                        <div class="header-actions">
                            <span class="action-btn" onclick="refreshPosts()" title="刷新帖子">
                                <i class="fas fa-redo"></i>
                            </span>
                            <span class="action-btn" onclick="showForumProfile()" title="个人主页">
                                <i class="fas fa-user"></i>
                            </span>  </div>
                    </div>
                    <div class="app-content">
                        <div id="forum-posts-list" class="post-list">
                        </div>
                    </div>
                </div>

                <!-- 帖子详情和回复界面 -->
                <div id="post-view-screen" class="app-screen">
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('post-view-screen')">‹ 返回</button>
                        <div class="app-title">帖子详情</div>
                        <button id="favorite-btn" class="header-action-btn" onclick="toggleFavoritePost()" title="收藏"><i class="far fa-star"></i></button>
                    </div>
                    <div class="app-content" id="post-view-content">
                    </div>
                    <div class="reply-input-area">
                        <input type="text" id="reply-input" placeholder="输入你的回复...">
                        <button onclick="sendReply()">发送</button>
                    </div>
                </div>

                <!-- 论坛个人主页/收藏夹 -->
                <div id="forum-profile-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon"><div class="app-battery-level"></div></div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToCurrentForum()">‹</button>
                        <div class="app-title">个人主页</div>
                    </div>
                    <div class="app-content">
                        <div id="favorite-posts-list" class="post-list">
                        </div>
                    </div>
                </div>

                <!-- 记忆设置模态框 -->
                <div id="memorySettingsModal" class="modal" style="display: none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>记忆系统设置</h3>
                            <button class="modal-close" onclick="closeMemorySettings()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div class="setting-group">
                                <label for="aiExtractInterval">AI记忆提取间隔（回合数）</label>
                                <input type="number" id="aiExtractInterval" min="10" max="200" step="10" value="30">
                                <small>每多少回合对话进行一次AI记忆提取（建议20-50回合）</small>
                            </div>

                            <div class="setting-group">
                                <label for="coreMemoryThreshold">核心记忆重要性阈值</label>
                                <input type="range" id="coreMemoryThreshold" min="0.7" max="1.0" step="0.05" value="0.9">
                                <span id="coreThresholdValue">90%</span>
                                <small>只有重要性超过此阈值的记忆才会成为核心记忆</small>
                            </div>

                            <div class="setting-group">
                                <label for="episodicMemoryThreshold">情景记忆重要性阈值</label>
                                <input type="range" id="episodicMemoryThreshold" min="0.4" max="0.8" step="0.05" value="0.6">
                                <span id="episodicThresholdValue">60%</span>
                                <small>重要性在此范围内的记忆会成为情景记忆</small>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="closeMemorySettings()">取消</button>
                            <button class="btn btn-primary" onclick="saveMemorySettings()">保存设置</button>
                        </div>
                    </div>
                </div>

                <!-- 线下预设设置模态框 -->
                <div id="offline-preset-modal" class="modal" style="display: none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>线下剧情预设</h3>
                            <button class="modal-close" onclick="closeOfflinePresetSettings()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <!-- 已保存的预设列表 -->
                            <div class="form-group">
                                <label>已保存的预设</label>
                                <div id="saved-presets-list" class="saved-presets-list">
                                    <!-- 预设列表将在这里动态生成 -->
                                </div>
                            </div>

                            <!-- 新建/编辑预设表单 -->
                            <div class="form-group">
                                <label for="offline-preset-name">预设名称</label>
                                <input type="text" id="offline-preset-name" placeholder="为这个预设起个名字..." maxlength="50">
                            </div>
                            <div class="form-group">
                                <label for="offline-preset-content">剧情预设内容</label>
                                <textarea id="offline-preset-content" rows="6" placeholder="请输入线下剧情模式的预设内容，这将决定AI的文风、字数、视角等...&#10;&#10;例如：&#10;- 以第三人称视角描述&#10;- 每次回复200-400字&#10;- 注重环境描写和心理活动&#10;- 营造浪漫/悬疑/冒险等氛围"></textarea>
                            </div>
                            <div class="form-group">
                                <label>预设说明</label>
                                <div class="preset-help-text">
                                    <p>• 预设内容将作为AI回复的重要指导</p>
                                    <p>• 可以指定文风、字数、视角、氛围等</p>
                                    <p>• 支持情景描写、动作描写、心理描写</p>
                                    <p>• 预设权重很高，会显著影响AI的回复风格</p>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="closeOfflinePresetSettings()">取消</button>
                            <button class="btn btn-secondary" onclick="clearPresetForm()">清空表单</button>
                            <button class="btn btn-primary" onclick="saveOfflinePreset()">保存预设</button>
                        </div>
                    </div>
                </div>

                <!-- 线下模式聊天记录模态框 -->
                <div id="offline-history-modal" class="modal" style="display: none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>线下模式聊天记录</h3>
                            <button class="modal-close" onclick="closeOfflineHistoryModal()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div id="offline-history-list" class="offline-history-list">
                                <!-- 聊天记录列表将在这里动态生成 -->
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="closeOfflineHistoryModal()">关闭</button>
                            <button class="btn btn-danger" onclick="clearAllOfflineHistory()">清空所有记录</button>
                        </div>
                    </div>
                </div>

                <!-- 纪念日表单模态框 -->
                <div id="anniversary-form-modal" class="modal" style="display: none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 id="anniversary-form-title">添加纪念日</h3>
                            <button class="modal-close" onclick="closeAnniversaryForm()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label for="anniversary-name">纪念日名称</label>
                                <input type="text" id="anniversary-name" placeholder="例如：生日、结婚纪念日..." maxlength="50">
                            </div>
                            <div class="form-group">
                                <label for="anniversary-date">日期</label>
                                <input type="date" id="anniversary-date">
                            </div>
                            <div class="form-group">
                                <label for="anniversary-type">类型</label>
                                <select id="anniversary-type">
                                    <option value="birthday">生日</option>
                                    <option value="anniversary">纪念日</option>
                                    <option value="holiday">节日</option>
                                    <option value="other">其他</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="anniversary-description">描述（可选）</label>
                                <textarea id="anniversary-description" rows="3" placeholder="添加一些备注..." maxlength="200"></textarea>
                            </div>
                            <div class="form-group">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="anniversary-yearly" checked>
                                    每年重复
                                </label>
                            </div>
                            <div class="form-group">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="anniversary-notify">
                                    提前提醒
                                </label>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="closeAnniversaryForm()">取消</button>
                            <button class="btn btn-primary" onclick="saveAnniversary()">保存</button>
                        </div>
                    </div>
                </div>

                <!-- 图片小组件设置模态框 -->
                <div id="photo-widget-modal" class="modal" style="display: none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>图片小组件</h3>
                            <button class="modal-close" onclick="closePhotoWidgetModal()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label for="widget-photo-upload">选择图片</label>
                                <input type="file" id="widget-photo-upload" accept="image/*" onchange="handlePhotoWidgetUpload(this)">
                            </div>
                            <div class="form-group">
                                <button class="btn btn-secondary" onclick="clearPhotoWidget()">清除图片</button>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="closePhotoWidgetModal()">关闭</button>
                        </div>
                    </div>
                </div>

                <!-- 纪念日小组件设置模态框 -->
                <div id="anniversary-widget-modal" class="modal" style="display: none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>纪念日小组件</h3>
                            <button class="modal-close" onclick="closeAnniversaryWidgetModal()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label for="widget-anniversary-select">选择要显示的纪念日</label>
                                <select id="widget-anniversary-select" onchange="updateAnniversaryWidget()">
                                    <option value="">请选择纪念日</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <button class="btn btn-secondary" onclick="clearAnniversaryWidget()">清除显示</button>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="closeAnniversaryWidgetModal()">关闭</button>
                        </div>
                    </div>
                </div>

                <!-- 线下模式界面设置模态框 -->
                <div id="offline-ui-settings-modal" class="modal" style="display: none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>线下模式界面设置</h3>
                            <button class="modal-close" onclick="closeOfflineUISettings()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <!-- 气泡颜色设置 -->
                            <div class="form-group">
                                <label>气泡颜色设置</label>
                                <div class="color-setting-group">
                                    <div class="color-picker-container">
                                        <div class="flex-gap-15">
                                            <div class="flex-1">
                                                <label class="label-small">我的气泡</label>
                                                <input type="color" id="offline-my-bubble-color" class="color-input" value="#007AFF">
                                            </div>
                                            <div class="flex-1">
                                                <label class="label-small">角色气泡</label>
                                                <input type="color" id="offline-ai-bubble-color" class="color-input" value="#f0f0f0">
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 透明度设置 -->
                            <div class="form-group">
                                <label>气泡透明度</label>
                                <div class="opacity-setting">
                                    <input type="range" id="offline-bubble-opacity" class="theme-range" min="0" max="1" step="0.01" value="0.9">
                                    <span id="offline-opacity-value">90%</span>
                                </div>
                            </div>



                            <!-- 🔥【新增】字体大小设置 -->
                            <div class="form-group">
                                <label>字体大小</label>
                                <div class="opacity-setting">
                                    <input type="range" id="offline-font-size" class="theme-range" min="12" max="24" step="1" value="15">
                                    <span id="offline-font-size-value">15px</span>
                                </div>
                            </div>

                            <!-- 壁纸设置 -->
                            <div class="form-group">
                                <label>背景壁纸</label>
                                <div class="wallpaper-setting">
                                    <input type="file" id="offline-wallpaper-file" accept="image/*" class="form-input" onchange="handleOfflineWallpaperUpload(this)">
                                    <button type="button" class="theme-button theme-button-secondary" onclick="clearOfflineWallpaper()">清除</button>
                                </div>
                            </div>

                            <!-- 字体设置 -->
                            <div class="form-group">
                                <label>字体设置</label>
                                <div class="font-setting">
                                    <select id="offline-font-select" class="form-input" onchange="handleOfflineFontChange()">
                                        <option value="">系统默认字体</option>
                                        <option value="custom">自定义字体URL...</option>
                                    </select>
                                    <div id="custom-font-input" style="display: none; margin-top: 10px;">
                                        <input type="url" id="offline-font-url" placeholder="例如：https://fonts.googleapis.com/css2?family=Noto+Sans+SC 或直接字体文件URL" class="form-input">
                                        <button type="button" class="theme-button theme-button-secondary" onclick="previewOfflineFont()">预览</button>
                                    </div>
                                </div>
                            </div>

                            <!-- 文字颜色设置 -->
                            <div class="form-group">
                                <label>文字颜色设置</label>
                                <div class="text-color-setting">
                                    <!-- 用户消息文字颜色 -->
                                    <div class="color-section">
                                        <label class="section-label">用户消息文字颜色</label>
                                        <div class="color-picker-container">
                                            <div class="flex-gap-15">
                                                <div class="flex-1">
                                                    <label class="label-small">普通文字</label>
                                                    <input type="color" id="offline-user-normal-text-color" class="color-input" value="#ffffff">
                                                    <div class="saved-colors" id="offline-user-normal-saved-colors"></div>
                                                </div>
                                                <div class="flex-1">
                                                    <label class="label-small">斜体文字</label>
                                                    <input type="color" id="offline-user-italic-text-color" class="color-input" value="#f0f0f0">
                                                    <div class="saved-colors" id="offline-user-italic-saved-colors"></div>
                                                </div>
                                                <div class="flex-1">
                                                    <label class="label-small">加粗文字</label>
                                                    <input type="color" id="offline-user-bold-text-color" class="color-input" value="#ffffff">
                                                    <div class="saved-colors" id="offline-user-bold-saved-colors"></div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- 角色消息文字颜色 -->
                                    <div class="color-section">
                                        <label class="section-label">角色消息文字颜色</label>
                                        <div class="color-picker-container">
                                            <div class="flex-gap-15">
                                                <div class="flex-1">
                                                    <label class="label-small">普通文字</label>
                                                    <input type="color" id="offline-ai-normal-text-color" class="color-input" value="#000000">
                                                    <div class="saved-colors" id="offline-ai-normal-saved-colors"></div>
                                                </div>
                                                <div class="flex-1">
                                                    <label class="label-small">斜体文字</label>
                                                    <input type="color" id="offline-ai-italic-text-color" class="color-input" value="#666666">
                                                    <div class="saved-colors" id="offline-ai-italic-saved-colors"></div>
                                                </div>
                                                <div class="flex-1">
                                                    <label class="label-small">加粗文字</label>
                                                    <input type="color" id="offline-ai-bold-text-color" class="color-input" value="#333333">
                                                    <div class="saved-colors" id="offline-ai-bold-saved-colors"></div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 预存颜色功能 -->
                            <div class="form-group">
                                <label>颜色管理</label>
                                <div class="color-management">
                                    <button type="button" class="theme-button theme-button-secondary" onclick="saveCurrentOfflineColors()">保存当前颜色</button>
                                    <button type="button" class="theme-button theme-button-secondary" onclick="resetOfflineColors()">重置为默认</button>
                                </div>
                            </div>

                            <!-- 头像设置 -->
                            <div class="form-group">
                                <label>头像设置</label>
                                <div class="avatar-setting">
                                    <div class="setting-row">
                                        <label class="checkbox-label">
                                            <input type="checkbox" id="offline-show-user-avatar" checked>
                                            显示用户头像
                                        </label>
                                        <label class="checkbox-label">
                                            <input type="checkbox" id="offline-show-ai-avatar" checked>
                                            显示角色头像
                                        </label>
                                    </div>
                                    <div class="setting-row">
                                        <label class="radio-label">头像位置：</label>
                                        <div class="radio-options">
                                            <div class="radio-option-button selected" onclick="selectAvatarPosition('side', this)">
                                                <div class="radio-indicator"></div>
                                                侧边显示
                                            </div>
                                            <div class="radio-option-button" onclick="selectAvatarPosition('custom', this)">
                                                <div class="radio-indicator"></div>
                                                自定义CSS控制
                                            </div>
                                            <input type="radio" name="offline-avatar-position" value="side" checked style="display: none;">
                                            <input type="radio" name="offline-avatar-position" value="custom" style="display: none;">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 气泡样式设置 -->
                            <div class="form-group">
                                <label>气泡样式设置</label>
                                <div class="bubble-style-setting">
                                    <div class="setting-row">
                                        <label class="radio-label">气泡宽度：</label>
                                        <div class="radio-options">
                                            <div class="radio-option-button selected" onclick="selectBubbleWidth('default', this)">
                                                <div class="radio-indicator"></div>
                                                智能宽度
                                            </div>
                                            <div class="radio-option-button" onclick="selectBubbleWidth('custom', this)">
                                                <div class="radio-indicator"></div>
                                                自定义CSS控制
                                            </div>
                                            <input type="radio" name="offline-bubble-width" value="default" checked style="display: none;">
                                            <input type="radio" name="offline-bubble-width" value="custom" style="display: none;">
                                        </div>
                                    </div>
                                    <div class="setting-row">
                                        <label class="radio-label">气泡样式：</label>
                                        <div class="radio-options">
                                            <div class="radio-option-button selected" onclick="selectBubbleStyle('default', this)">
                                                <div class="radio-indicator"></div>
                                                默认样式
                                            </div>
                                            <div class="radio-option-button" onclick="selectBubbleStyle('custom', this)">
                                                <div class="radio-indicator"></div>
                                                自定义CSS控制
                                            </div>
                                            <input type="radio" name="offline-bubble-style" value="default" checked style="display: none;">
                                            <input type="radio" name="offline-bubble-style" value="custom" style="display: none;">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 自定义CSS设置 -->
                            <div class="form-group">
                                <label>自定义CSS代码</label>
                                <div class="custom-css-setting">
                                    <textarea id="offline-custom-css" rows="8" class="form-input" placeholder="在这里输入自定义CSS代码来控制头像位置、气泡样式、气泡大小等...&#10;&#10;示例：&#10;/* 调整气泡宽度 */&#10;.offline-message-content {&#10;    max-width: 70% !important;&#10;}&#10;&#10;/* 调整头像位置 */&#10;.offline-avatar {&#10;    position: absolute;&#10;    top: -10px;&#10;    right: -10px;&#10;}"></textarea>
                                    <div class="css-buttons">
                                        <button type="button" class="theme-button theme-button-secondary" onclick="previewOfflineCSS()">预览CSS</button>
                                        <button type="button" class="theme-button theme-button-secondary" onclick="clearOfflineCSS()">清除CSS</button>
                                    </div>
                                </div>
                            </div>

                            <!-- 预览区域 -->
                            <div class="form-group">
                                <label>效果预览</label>
                                <div class="offline-preview-area" id="offline-preview-area">
                                    <div class="offline-preview-message user">
                                        <div class="offline-avatar user-avatar" id="preview-user-avatar">👤</div>
                                        <div class="offline-preview-content">
                                            这是用户消息的预览效果，包含<em>斜体文字</em>和<strong>加粗文字</strong>
                                        </div>
                                    </div>
                                    <div class="offline-preview-message ai">
                                        <div class="offline-avatar ai-avatar" id="preview-ai-avatar">🤖</div>
                                        <div class="offline-preview-content">
                                            这是角色回复的预览效果，包含<em>斜体文字</em>和<strong>加粗文字</strong>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="closeOfflineUISettings()">取消</button>
                            <button class="btn btn-secondary" onclick="resetOfflineUISettings()">重置</button>
                            <button class="btn btn-primary" onclick="saveOfflineUISettings()">保存设置</button>
                        </div>
                    </div>
                </div>

                <!-- 记忆查看器界面 -->
                <div id="memory-viewer-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('memory-viewer-screen')">‹</button>

                        <div class="app-title">记忆查看器</div>
                        <div class="header-actions">
                            <!-- 右侧放3个按钮：设置、刷新、清理错误记录 -->
                            <button class="header-action-btn" onclick="showMemorySettings()" title="记忆设置">
                                <i class="fas fa-cog"></i>
                            </button>
                            <button class="header-action-btn" onclick="refreshMemoryData()" title="刷新">
                                <i class="fas fa-sync-alt"></i>
                            </button>
                            <button class="header-action-btn" onclick="cleanupIncorrectRecords()" title="清理错误记录">
                                <i class="fas fa-tools"></i>
                            </button>
                        </div>
                    </div>
                    <div class="app-content">
                        <!-- 角色选择器 -->
                        <div class="memory-character-selector">
                            <label for="memory-character-select">选择角色：</label>
                            <select id="memory-character-select" onchange="loadCharacterMemories()">
                                <option value="">请选择角色</option>
                            </select>
                        </div>

                        <!-- 搜索和过滤 -->
                        <div class="memory-search-section">
                            <div class="memory-search-bar">
                                <input type="text" id="memory-search-input" placeholder="搜索记忆内容..." oninput="filterMemories()">
                                <button class="search-btn" onclick="filterMemories()">
                                    <i class="fas fa-search"></i>
                                </button>
                            </div>
                            <div class="memory-filter-tabs">
                                <button class="memory-filter-tab active" data-type="all" onclick="switchMemoryFilter('all')">全部</button>
                                <button class="memory-filter-tab" data-type="core" onclick="switchMemoryFilter('core')">核心记忆</button>
                                <button class="memory-filter-tab" data-type="episodic" onclick="switchMemoryFilter('episodic')">情景记忆</button>
                                <button class="memory-filter-tab" data-type="storyline" onclick="switchMemoryFilter('storyline')">剧情总结</button>
                                <button class="memory-filter-tab" data-type="timeline" onclick="switchMemoryFilter('timeline')">时间线</button>
                            </div>
                        </div>

                        <!-- 记忆内容显示区域 -->
                        <div class="memory-content-area">
                            <div id="memory-list" class="memory-list">
                                <div class="memory-empty-state">
                                    <i class="fas fa-brain"></i>
                                    <p>请选择角色查看记忆</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 世界书编辑表单 -->
                <div id="worldbook-form-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideWorldbookForm()">‹</button>
                        <div class="app-title" id="worldbook-form-title">新建世界书</div>
                        <button class="save-worldbook-btn save-btn-absolute" onclick="saveWorldbook()">保存</button>
                    </div>
                    <div class="app-content">
                        <div class="worldbook-form">
                            <div class="form-group">
                                <label class="form-label">标题</label>
                                <input type="text" id="worldbook-title" class="form-input" placeholder="请输入世界书标题">
                            </div>
                            <div class="form-group">
                                <label class="form-label">内容</label>
                                <textarea id="worldbook-content" class="form-textarea textarea-large" placeholder="请输入世界书内容，这里可以描述角色背景、世界观设定等..."></textarea>
                            </div>
                        </div>
                    </div>
                </div>
                

                
                <!-- 聊天设置界面 -->
                <div id="api-chat-settings-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideChatSettings()">‹</button>
                        <div class="app-title">聊天设置</div>
                    </div>
                    <div class="app-content padding-none-flex overflow-auto">
                        <div class="settings-container">
                            
                            <!-- 群聊专用设置 - 仿QQ/微信群聊界面 -->
                            <div class="settings-section" id="group-chat-settings" style="display: none;">
                                <!-- 群聊信息卡片 -->
                                <div class="group-info-card">
                                    <div class="group-avatar-section" onclick="changeGroupAvatar()">
                                        <img id="group-avatar-preview" src="" class="group-avatar-large" alt="群头像">
                                        <div class="group-avatar-edit-hint">点击修改</div>
                                    </div>
                                    <div class="group-basic-info">
                                        <div class="group-name" onclick="changeGroupName()" id="group-name-display">群聊名称</div>
                                        <div class="group-member-count" id="group-member-count-display">0名成员</div>
                                        <div class="group-description" onclick="editGroupDescription()" id="group-description-display">群公告：点击设置群公告</div>
                                    </div>
                                </div>

                                <!-- 群成员展示区域 -->
                                <div class="group-members-section">
                                    <div class="section-title">群成员</div>
                                    <div class="group-members-grid" id="group-members-grid">
                                        <!-- 群成员头像将动态生成 -->
                                        <div class="member-item add-member" onclick="addGroupMember()">
                                            <div class="member-avatar">
                                                <i class="fas fa-plus"></i>
                                            </div>
                                            <div class="member-name">邀请</div>
                                        </div>
                                        <div class="member-item remove-member" onclick="removeGroupMember()">
                                            <div class="member-avatar">
                                                <i class="fas fa-minus"></i>
                                            </div>
                                            <div class="member-name">移除</div>
                                        </div>
                                    </div>
                                </div>

                                <!-- 群功能设置 -->
                                <div class="setting-card">
                                    <div class="setting-item" onclick="changeMyGroupNickname()">
                                        <div class="setting-left">
                                            <div class="setting-label">我在本群的昵称</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="current-my-group-nickname">未选择</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showGroupNotice()">
                                        <div class="setting-left">
                                            <div class="setting-label">群公告</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value">查看详情</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>

                                </div>

                                <!-- 群应用中心 -->
                                <div class="group-apps-section">
                                    <div class="section-title">群应用</div>
                                    <div class="group-apps-grid">
                                        <div class="app-item" onclick="showGroupVote()">
                                            <i class="fas fa-vote-yea app-icon"></i>
                                            <span class="app-name">投票</span>
                                        </div>
                                        <div class="app-item" onclick="showGroupActivity()">
                                            <i class="fas fa-calendar-alt app-icon"></i>
                                            <span class="app-name">群活动</span>
                                        </div>
                                        <div class="app-item" onclick="showGroupTask()">
                                            <i class="fas fa-tasks app-icon"></i>
                                            <span class="app-name">群任务</span>
                                        </div>
                                        <div class="app-item" onclick="showMoreApps()">
                                            <i class="fas fa-ellipsis-h app-icon"></i>
                                            <span class="app-name">更多</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- 聊天窗口设置 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-user-edit section-icon"></i>
                                    <span class="section-title">聊天窗口设置</span>
                                </div>
                                <div class="setting-card">
                                    <!-- 身份选择功能已移除，身份在创建对话时选择 -->
                                    <!-- 单聊时显示双方设置，群聊时隐藏 -->
                                    <div class="setting-item single-chat-only" onclick="showAvatarSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">双方头像设置</div>
                                            <div class="setting-desc">设置在此聊天窗口中显示的头像</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item single-chat-only" onclick="showNicknameSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">双方备注设置</div>
                                            <div class="setting-desc">设置在此聊天窗口中显示的昵称</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showBackgroundSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">聊天背景设置</div>
                                            <div class="setting-desc">自定义聊天界面的背景图片</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showBubbleStyleSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">气泡样式设置</div>
                                            <div class="setting-desc">选择气泡外观样式和颜色</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="current-bubble-style">默认样式</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item single-chat-only">
                                        <div class="setting-left">
                                            <div class="setting-label">显示角色状态</div>
                                            <div class="setting-desc">在聊天界面显示角色的在线状态和活动</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="character-status-enabled">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                    
                                    <!-- 🔥【新增】状态更新频率设置 -->
                                    <div class="setting-item single-chat-only" id="status-frequency-setting" style="display: none;">
                                        <div class="setting-left">
                                            <div class="setting-label">状态更新频率</div>
                                            <div class="setting-desc">控制角色状态的检查和更新频率</div>
                                        </div>
                                        <div class="setting-right">
                                            <select class="setting-select" id="status-update-frequency">
                                                <option value="high">高频 (30秒)</option>
                                                <option value="medium-high">中高频 (1分钟)</option>
                                                <option value="medium">中频 (3分钟)</option>
                                                <option value="medium-low">中低频 (5分钟)</option>
                                                <option value="low">低频 (10分钟)</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 戳一戳功能设置 - 单聊特有 -->
                            <div class="settings-section" id="poke-settings-section">
                                <div class="section-header">
                                    <i class="fas fa-hand-paper section-icon"></i>
                                    <span class="section-title">戳一戳功能</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">启用戳一戳</div>
                                            <div class="setting-desc">允许发送戳一戳消息，双方可自定义戳一戳后缀</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="poke-enabled" checked>
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                    <div class="setting-item poke-settings poke-settings-visible" id="poke-suffix-settings" onclick="showPokeSuffixSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">戳一戳后缀设置</div>
                                            <div class="setting-desc">自定义双方的戳一戳动作后缀</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-explanation">
                                        <div class="explanation-text">
                                            <strong>功能说明：</strong><br>
                                            • 点击对方头像即可发送戳一戳<br>
                                            • 你可以自定义戳一戳后缀，如"的小脸蛋"、"的小手"等<br>
                                            • 角色也会根据心情和聊天内容自主修改自己的戳一戳后缀
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 记忆设置 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-brain section-icon"></i>
                                    <span class="section-title">记忆设置</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item" onclick="showHistorySettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">附带历史消息数</div>
                                            <div class="setting-desc">自定义角色回复时参考的历史对话数量</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="current-history-count">5回合</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>

                                    <div class="setting-item" onclick="showGlobalMemorySettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">全局记忆系统</div>
                                            <div class="setting-desc">跨场景连续记忆，让角色记住所有互动</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="global-memory-status">7天记忆</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item single-chat-only" onclick="showMemoryShareSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">与群聊共享记忆</div>
                                            <div class="setting-desc">让角色在单聊中记住群聊的内容</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="memory-share-status">已关闭</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showWorldbookMountSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">挂载世界书</div>
                                            <div class="setting-desc">让角色参考选定的世界书内容作为背景知识</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="current-worldbook-mount">未挂载</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 时间感知设置 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-clock section-icon"></i>
                                    <span class="section-title">时间感知</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">时间感知开关</div>
                                            <div class="setting-desc">角色会感知当前时间并调整回复</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="time-awareness-enabled">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 通话设置 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-phone section-icon"></i>
                                    <span class="section-title">通话设置</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">角色主动拨打电话</div>
                                            <div class="setting-desc">允许角色根据对话内容主动发起通话</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="ai-call-enabled" class="ai-call-enabled-checkbox">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                    <div class="setting-explanation">
                                        <div class="explanation-text">
                                            <strong>功能说明：</strong><br>
                                            • <strong>开启时：</strong>当本回合聊天中提到通话相关内容时，角色有20%概率主动给你打电话<br>
                                            • <strong>关闭时：</strong>角色不会主动拨打电话，只能由用户主动发起通话<br>
                                            • <strong>通话关键词：</strong>通话、电话、视频、语音、打给你、想听、想看等
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- AI心率监测 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-heartbeat section-icon"></i>
                                    <span class="section-title">角色心率监测</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">心率监测显示</div>
                                            <div class="setting-desc">在状态栏显示角色的情感心率</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="ai-heartrate-enabled">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>





                            <!-- 后台互动设置 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-robot section-icon"></i>
                                    <span class="section-title">后台互动</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">后台互动开关</div>
                                            <div class="setting-desc">角色可在后台主动活动并发送推送</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="background-interaction-enabled">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                    <div class="background-interaction-details hide" id="background-interaction-settings">
                                        <div class="setting-item">
                                        <div class="setting-left">
                                                <div class="setting-label">主动聊天</div>
                                                <div class="setting-desc">角色在你10分钟未回复时主动发消息</div>
                                        </div>
                                        <div class="setting-right">
                                                <label class="toggle-switch">
                                                    <input type="checkbox" id="background-chat-enabled">
                                                    <span class="toggle-slider"></span>
                                                </label>
                                        </div>
                                    </div>
                                        
                                        <div class="setting-item" id="chat-frequency-setting" style="display: none;">
                                        <div class="setting-left">
                                                <div class="setting-label">主动聊天频率</div>
                                                <div class="setting-desc">角色主动发起对话的频率</div>
                                        </div>
                                        <div class="setting-right">
                                                <select id="background-chat-frequency" class="setting-select">
                                                    <option value="low">低 (1-2小时/次)</option>
                                                    <option value="medium">中 (30-60分钟/次)</option>
                                                    <option value="high">高 (10-30分钟/次)</option>
                                                </select>
                                </div>
                            </div>

                                    <div class="setting-item">
                                        <div class="setting-left">
                                                <div class="setting-label">主动发动态</div>
                                                <div class="setting-desc">角色根据人设主动发布动态</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                    <input type="checkbox" id="background-moments-enabled">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>

                                        <div class="setting-item" id="moments-frequency-setting" style="display: none; justify-content: space-between !important; align-items: center !important;">
                                            <div class="setting-left" style="flex: 1 !important;">
                                                <div class="setting-label">主动发动态频率</div>
                                                <div class="setting-desc">角色主动发布社交动态的频率</div>
                                            </div>
                                            <div class="setting-right" style="display: flex !important; align-items: center !important; flex-shrink: 0 !important;">
                                                <select id="background-moments-frequency" class="setting-select">
                                                    <option value="low">低 (4-8小时/次)</option>
                                                    <option value="medium">中 (2-4小时/次)</option>
                                                    <option value="high">高 (1-2小时/次)</option>
                                                </select>
                                            </div>
                                        </div>
                                        
                                        <div class="setting-item" id="scheduled-moments-setting" style="display: none; justify-content: space-between !important; align-items: flex-start !important;">
                                            <div class="setting-left" style="flex: 1 !important;">
                                                <div class="setting-label">定时发布动态</div>
                                                <div class="setting-desc">设置固定时间点自动发布动态</div>
                                            </div>
                                            <div class="setting-right" style="display: flex !important; flex-direction: column !important; align-items: flex-end !important; gap: 8px !important; flex-shrink: 0 !important;">
                                                <label class="toggle-switch">
                                                    <input type="checkbox" id="scheduled-moments-enabled">
                                                    <span class="toggle-slider"></span>
                                                </label>
                                                <button onclick="showScheduleTimesModal()" style="background-color: #4a84c1; color: white; border: none; padding: 6px 12px; border-radius: 15px; font-size: 12px;">
                                                    <span id="schedule-times-display">未设置</span>
                                                </button>
                                            </div>
                                        </div>
                                        
                                        <div class="setting-item" id="test-publish-setting" style="display: none; justify-content: space-between !important; align-items: center !important;">
                                            <div class="setting-left" style="flex: 1 !important;">
                                                <div class="setting-label">测试发布</div>
                                                <div class="setting-desc">让角色立即发布一条测试动态</div>
                                            </div>
                                            <div class="setting-right" style="display: flex !important; align-items: center !important; flex-shrink: 0 !important; gap: 8px;">
                                                <button onclick="testPublishMoment()" style="background-color: #4a84c1; color: white; border: none; padding: 6px 12px; border-radius: 15px; font-size: 12px;">
                                                    发布
                                                </button>
                                                <button onclick="fixAvatarData()" style="background-color: #ff6b6b; color: white; border: none; padding: 6px 12px; border-radius: 15px; font-size: 12px;">
                                                    修复头像
                                                </button>
                                            </div>
                                        </div>

                                    </div>
                                </div>
                            </div>

                            <!-- 其他设置 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-cog section-icon"></i>
                                    <span class="section-title">其他设置</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">显示时间戳</div>
                                            <div class="setting-desc">在聊天消息中显示时间信息</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="timestamp-enabled" checked>
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showTimestampSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">时间戳设置</div>
                                            <div class="setting-desc">设置时间戳显示位置和格式</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="searchChatContent()">
                                        <div class="setting-left">
                                            <div class="setting-label">查找聊天内容</div>
                                            <div class="setting-desc">搜索历史消息中的关键词</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="exportChatHistory()">
                                        <div class="setting-left">
                                            <div class="setting-label">导出聊天记录</div>
                                            <div class="setting-desc">导出当前对话的所有消息</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>

                                </div>
                            </div>

                            <!-- 危险操作 -->
                            <div class="settings-section">
                                <div class="section-header">
                                                    <i class="fas fa-exclamation-triangle section-icon danger-section-icon"></i>
                <span class="section-title danger-section-title">危险操作</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item" onclick="showBlacklistSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label" id="block-manage-label">拉黑管理</div>
                                            <div class="setting-desc" id="block-manage-desc">拉黑/解除拉黑管理</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item danger-item" onclick="clearChatHistory()">
                                        <div class="setting-left">
                                            <div class="setting-label danger-color">清空聊天记录</div>
                                            <div class="setting-desc">删除所有历史消息，不可恢复</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right danger-color"></i>
                                        </div>
                                    </div>
                                </div>
                            </div>

                        </div>
                    </div>
                </div>
                
                <!-- 人物编辑表单 -->
                <div id="character-form-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideCharacterForm()">‹</button>
                        <div class="app-title" id="character-form-title">新建人物</div>
                        <button class="import-character-btn" id="import-character-btn" onclick="importCharacterCard()" title="导入角色卡">
                            <i class="fas fa-upload"></i>
                        </button>
                        <button class="export-character-btn" id="export-character-btn" onclick="exportCharacterCard()" title="导出角色卡" style="display: none;">
                            <i class="fas fa-download"></i>
                        </button>
                    </div>
                    <div class="app-content">
                        <div class="character-form">
                            <div class="form-group avatar-upload">
                                <label class="form-label">头像</label>
                                <div class="avatar-preview" id="avatar-preview">
                                    <div class="avatar-preview-text" id="avatar-preview-text">A</div>
                                </div>
                                <input type="file" id="avatar-upload" accept="image/*" class="file-input-hidden">
                            <input type="file" id="character-card-upload" accept=".png,.json" class="file-input-hidden">
                                <button class="upload-button" onclick="handleAvatarUploadClick()">上传头像</button>
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">姓名</label>
                                <input type="text" class="form-input" id="character-name" placeholder="输入姓名">
                            </div>
                            <div class="form-group">
                                <label class="form-label">人设</label>
                                <textarea class="form-textarea" id="character-bio" placeholder="输入人物设定"></textarea>
                            </div>
                            <div class="form-actions form-actions-flex">
                                <button class="form-submit form-submit-flex">保存</button>
                                <button class="form-delete form-delete-red" id="character-delete-btn" onclick="deleteCurrentCharacter()">删除</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 面具创建表单 -->
                <div id="persona-form-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hidePersonaForm()">‹</button>
                        <div class="app-title" id="persona-form-title">新建面具</div>
                    </div>
                    <div class="app-content">
                        <div class="character-form">
                            <div class="form-group avatar-upload">
                                <label class="form-label">头像</label>
                                <div class="avatar-preview" id="persona-avatar-preview">
                                    <div class="avatar-preview-text" id="persona-avatar-preview-text">我</div>
                                </div>
                                <input type="file" id="persona-avatar-upload" accept="image/*" class="file-input-hidden">
                                <button class="upload-button" onclick="handlePersonaAvatarUploadClick()">上传头像</button>
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">我的名称</label>
                                <input type="text" class="form-input" id="persona-name" placeholder="例如：user小明、user学生、user工作者">
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">我的描述</label>
                                <textarea class="form-textarea" id="persona-description" placeholder="描述这个身份的特点，包括性格、说话风格、使用场合等..."></textarea>
                            </div>
                            
                            <button class="form-submit" onclick="savePersona()">保存面具</button>
                        </div>
                    </div>
                </div>
                
                <!-- API聊天界面 -->
                <div id="api-chat-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div id="ai-heartrate-display" style="display: none;">♥️ 72 bpm</div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="header">
                        <div class="default-controls">
                            <button class="back-btn" onclick="backToChatApp()">‹</button>
                            <span class="header-title" id="api-chat-title">角色聊天</span>
                            <div class="header-actions">
                                <span class="action-btn" onclick="toggleOfflineMode()" id="offline-mode-btn" title="切换线下剧情模式">
                                    <i class="fas fa-door-open" id="offline-mode-icon"></i>
                                </span>
                                <span class="action-btn" onclick="showChatSettings()">
                                <i class="fas fa-ellipsis-v"></i>
                                </span>
                            </div>
                        </div>
                        <div class="selection-controls">
                            <span id="selection-cancel-btn">取消</span>
                            <span id="selection-count"></span>
                            <span id="selection-delete-btn">删除</span>
                        </div>
                    </div>
                    <div class="app-content padding-none-flex">

                        <div class="chat-dialog">
                            <div class="chat-messages" id="api-chat-messages">
                                <!-- 聊天消息将通过JS动态生成 -->
                            </div>
                            
                            <!-- 悬浮按钮组 -->
                            <div class="floating-actions" id="floating-actions">
                                <button class="floating-btn" id="regenerate-btn" onclick="regenerateLastResponse()" title="重新生成回答">
                                    <i class="fas fa-redo-alt"></i>
                                </button>
                            </div>
                            
                            <div class="chat-input-area">
                                <!-- 展开的工具面板 -->
                                <div class="tools-panel" id="tools-panel" style="display: none;">
                                    <div class="tools-grid">
                                        <div class="tool-item" onclick="handleVoiceRecording(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-microphone"></i>
                                            </div>
                                            <span class="tool-label">语音</span>
                                        </div>
                                        <div class="tool-item" onclick="showCustomEmojiPanel(); hideToolsPanel();">
                                            <div class="tool-icon">
                                                <i class="fas fa-smile"></i>
                                            </div>
                                            <span class="tool-label">表情</span>
                                        </div>
                                        <div class="tool-item" onclick="openCamera(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-camera"></i>
                                            </div>
                                            <span class="tool-label">拍照</span>
                                        </div>
                                        <div class="tool-item" onclick="uploadImage(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-image"></i>
                                            </div>
                                            <span class="tool-label">图片</span>
                                        </div>
                                        <div class="tool-item" onclick="openTransfer(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-exchange-alt"></i>
                                            </div>
                                            <span class="tool-label">转账</span>
                                        </div>
                                        <div class="tool-item" onclick="makeCall(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-phone"></i>
                                            </div>
                                            <span class="tool-label">电话</span>
                                        </div>
                                        <div class="tool-item" onclick="openVideoCall(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-video"></i>
                                            </div>
                                            <span class="tool-label">视频</span>
                                        </div>
                                        <div class="tool-item" onclick="shareLocation(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-map-marker-alt"></i>
                                            </div>
                                            <span class="tool-label">位置</span>
                                        </div>
                                        <div class="tool-item diary-tool" onclick="showDiaryMenu(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-book"></i>
                                            </div>
                                            <span class="tool-label">日记</span>
                                        </div>
                                        <div class="tool-item" onclick="openMusicPlayer(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-headphones"></i>
                                            </div>
                                            <span class="tool-label">听歌</span>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- 输入区域 -->
                                <div class="input-controls">
                                <button class="chat-action-btn toggle-tools-btn" onclick="toggleToolsPanel()" title="功能菜单" id="toggle-tools-btn">
                                    <i class="fas fa-plus"></i>
                                </button>
                                <div style="position: relative; flex: 1; min-width: 0;">
                                    <textarea class="chat-input" id="api-chat-input" rows="1" placeholder="输入消息..."></textarea>
                                    <!-- @群成员下拉选择框 -->
                                    <div class="mention-dropdown" id="mention-dropdown">
                                        <!-- 动态生成群成员列表 -->
                                    </div>
                                </div>
                                    <button class="chat-action-btn" onclick="triggerSmartReply()" title="获取AI回复">
                                        <i class="fas fa-comment-dots"></i>
                                </button>
                                <button class="send-button" onclick="sendApiMessage()">
                                    发送
                                </button>
                                </div>
                                <input type="file" id="image-upload" accept="image/*" class="file-input-hidden">
                                <input type="file" id="emoji-upload" accept="image/*" class="file-input-hidden" multiple>
                            </div>
                        </div>
                        
                        <!-- 自定义表情包面板 -->
                        <div class="custom-emoji-panel" id="custom-emoji-panel">
                            <div class="emoji-tabs">
                                <div class="emoji-tab active" data-tab="recent">最近</div>
                                <div class="emoji-tab" data-tab="custom">全部</div>
                            </div>
                            <div class="emoji-content">
                                <div class="emoji-grid" id="emoji-grid">
                                    <!-- 表情包网格将通过JS动态生成 -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 线下剧情模式覆盖层 -->
                    <div id="offline-mode-overlay" class="offline-mode-overlay" style="display: none;">
                        <div class="offline-mode-header">
                            <button class="back-btn" onclick="exitOfflineMode()">‹</button>
                            <span class="header-title" id="offline-mode-title">线下剧情模式</span>
                            <div class="header-actions">
                                <span class="action-btn" onclick="showOfflineHistoryModal()" title="查看聊天记录">
                                    <i class="fas fa-history"></i>
                                </span>
                                <span class="action-btn" onclick="showOfflineUISettings()" title="界面设置">
                                    <i class="fas fa-cog"></i>
                                </span>
                                <span class="action-btn" onclick="showOfflinePresetSettings()" title="添加预设">
                                    <i class="fas fa-plus"></i>
                                </span>
                            </div>
                        </div>

                        <div class="offline-mode-content">
                            <div class="offline-chat-messages" id="offline-chat-messages">
                                <!-- 线下模式的聊天消息 -->
                            </div>

                            <div class="offline-input-area">
                                <div class="offline-input-container">
                                    <textarea id="offline-input" placeholder="在线下剧情模式中输入..." rows="3"></textarea>
                                    <div class="offline-button-group">
                                        <button class="offline-regenerate-btn" onclick="regenerateLastOfflineMessage()" title="重新生成AI回复">
                                            <i class="fas fa-redo-alt"></i>
                                        </button>
                                        <button class="offline-send-btn" onclick="sendOfflineMessage()">
                                            <i class="fas fa-paper-plane"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 浏览器界面 -->
                <div id="browser-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('browser-screen')">‹</button>
                        <div class="app-title">浏览器</div>
                    </div>
                    <div class="app-content padding-none-flex">
                        <div class="browser-toolbar">
                            <input type="text" class="browser-url-bar" id="browser-url" placeholder="输入网址">
                            <button onclick="loadUrl()">前往</button>
                        </div>
                        <iframe class="browser-content" id="browser-frame"></iframe>
                    </div>
                </div>
                

                
                <!-- 游戏界面 -->
                <div id="game-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('game-screen')">‹</button>
                        <div class="app-title">游戏中心</div>
                    </div>
                    <div class="app-content">
                        <div class="game-list">
                            <div class="game-item" onclick="startGame('witchPotion')">
                                <div class="game-icon">
                                    <i class="fas fa-flask"></i>
                        </div>
                                <div class="game-info">
                                    <div class="game-name">女巫的解药</div>
                                    <div class="game-desc">与AI角色一起调制神秘药水</div>
                                </div>
                                <div class="game-badge">NEW</div>
                            </div>
                            <div class="game-item coming-soon">
                                <div class="game-icon">
                                    <i class="fas fa-dice"></i>
                                </div>
                                <div class="game-info">
                                    <div class="game-name">角色猜谜</div>
                                    <div class="game-desc">即将推出</div>
                                </div>
                            </div>
                            <div class="game-item coming-soon">
                                <div class="game-icon">
                                    <i class="fas fa-book"></i>
                                </div>
                                <div class="game-info">
                                    <div class="game-name">互动故事</div>
                                    <div class="game-desc">即将推出</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                

                

                
                <!-- 设置应用 -->
                <div id="settings-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('settings-screen')">‹</button>
                        <div class="app-title">设置</div>
                    </div>
                    <div class="app-content">
                        <div class="settings-item" onclick="showApp('api-settings-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon wifi">
                                    <i class="fas fa-wifi"></i>
                                </div>
                                <div>API设置</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('theme-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon settings-icon-custom">
                                    <i class="fas fa-palette"></i>
                                </div>
                                <div>主题设置</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('display-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon display">
                                    <i class="fas fa-font"></i>
                                </div>
                                <div>字号大小</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('appearance-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon display">
                                    <i class="fas fa-mobile-alt"></i>
                                </div>
                                <div>外观设置</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('wallpaper-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon wallpaper">
                                    <i class="fas fa-image"></i>
                                </div>
                                <div>壁纸</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('datetime-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon datetime">
                                    <i class="fas fa-clock"></i>
                                </div>
                                <div>日期与时间</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div class="settings-icon notification">
                                    <i class="fas fa-bell"></i>
                                </div>
                                <div>通知</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('data-management-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon data-management">
                                    <i class="fas fa-database"></i>
                                </div>
                                <div>数据管理</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('emergency-recovery-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon" style="background: #ff4444; color: white;">
                                    <i class="fas fa-life-ring"></i>
                                </div>
                                <div>紧急恢复</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('about-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon about">
                                    <i class="fas fa-info-circle"></i>
                                </div>
                                <div>关于我们</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                    </div>
                </div>
                
                <!-- 日期与时间设置 -->
                <div id="datetime-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('datetime-screen')">‹</button>
                        <div class="app-title">日期与时间</div>
                    </div>
                    <div class="app-content">
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>自动设置</div>
                            </div>
                            <label class="settings-toggle">
                                <input type="checkbox" checked>
                                <span class="settings-slider"></span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <!-- 数据管理 -->
                <div id="data-management-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('data-management-screen')">‹</button>
                        <div class="app-title">数据管理</div>
                    </div>
                    <div class="app-content">
                        <!-- 存储空间使用情况 -->
                        <div class="data-section">
                            <div class="data-section-title">存储空间使用情况</div>
                            <div class="storage-usage" id="storage-usage">
                                <div class="storage-item">
                                    <div class="storage-label">聊天记录</div>
                                    <div class="storage-size" id="chat-storage-size">计算中...</div>
                                </div>
                                <div class="storage-item">
                                    <div class="storage-label">角色数据</div>
                                    <div class="storage-size" id="character-storage-size">计算中...</div>
                                </div>
                                <div class="storage-item">
                                    <div class="storage-label">聊天设置</div>
                                    <div class="storage-size" id="settings-storage-size">计算中...</div>
                                </div>
                                <div class="storage-item">
                                    <div class="storage-label">表情包</div>
                                    <div class="storage-size" id="emoji-storage-size">计算中...</div>
                                </div>
                                <div class="storage-total">
                                    <div class="storage-label">总计</div>
                                    <div class="storage-size" id="total-storage-size">计算中...</div>
                                </div>
                            </div>
                        </div>

                        <!-- 数据导入导出 -->
                        <div class="data-section">
                            <div class="data-section-title">数据备份与恢复</div>
                            <div class="settings-item" onclick="exportAllData()">
                                <div class="settings-item-left">
                                    <div class="settings-icon export">
                                        <i class="fas fa-download"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">导出所有数据</div>
                                        <div class="setting-desc">将所有聊天记录和设置导出为JSON文件</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="settings-item" onclick="importDataFromFile()">
                                <div class="settings-item-left">
                                    <div class="settings-icon import">
                                        <i class="fas fa-upload"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">导入数据</div>
                                        <div class="setting-desc">从JSON文件恢复聊天记录和设置</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>

                        <!-- 数据检查与修复 -->
                        <div class="data-section">
                            <div class="data-section-title">数据检查与修复</div>
                            <div class="settings-item" onclick="checkAndFixChatHistory()">
                                <div class="settings-item-left">
                                    <div class="settings-icon import">
                                        <i class="fas fa-search"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">检查聊天历史</div>
                                        <div class="setting-desc">检查并修复聊天记录数据，恢复丢失的消息</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="settings-item" onclick="cleanupOldChatSettingsFromLocalStorage()">
                                <div class="settings-item-left">
                                    <div class="settings-icon cleanup">
                                        <i class="fas fa-broom"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">清理旧设置数据</div>
                                        <div class="setting-desc">清理localStorage中的旧聊天设置，释放存储空间</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="settings-item" onclick="debugChatMessagesFormat()">
                                <div class="settings-item-left">
                                    <div class="settings-icon debug">
                                        <i class="fas fa-bug"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">调试聊天记录格式</div>
                                        <div class="setting-desc">分析聊天记录的数据格式，帮助诊断导入问题</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                        
                        <!-- 选择性清理 -->
                        <div class="data-section">
                            <div class="data-section-title">存储清理</div>
                            <div class="settings-item" onclick="cleanupOrphanedContacts()">
                                <div class="settings-item-left">
                                    <div class="settings-icon cleanup">
                                        <i class="fas fa-user-slash"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">清理孤立数据</div>
                                        <div class="setting-desc">清理不存在的角色数据和相关记录</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>

                            <div class="settings-item" onclick="showCleanupOptions()">
                                <div class="settings-item-left">
                                    <div class="settings-icon cleanup">
                                        <i class="fas fa-broom"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">选择性清理</div>
                                        <div class="setting-desc">清理特定类型的数据以释放空间</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="settings-item" onclick="compressAllImages()">
                                <div class="settings-item-left">
                                    <div class="settings-icon compress">
                                        <i class="fas fa-compress-arrows-alt"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">压缩图片</div>
                                        <div class="setting-desc">压缩所有头像和背景图片以节省空间</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>

                        <!-- 危险操作 -->
                        <div class="data-section danger-section">
                            <div class="data-section-title">危险操作</div>
                            <div class="settings-item danger-item" onclick="clearAllData()">
                                <div class="settings-item-left">
                                    <div class="settings-icon danger">
                                        <i class="fas fa-trash-alt"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">清空所有数据</div>
                                        <div class="setting-desc">删除所有聊天记录、角色和设置（不可恢复）</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 🚨 紧急恢复界面 -->
                <div class="app-screen" id="emergency-recovery-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('emergency-recovery-screen')">‹</button>
                        <div class="app-title" style="color: #ff4444;">🚨 紧急恢复</div>
                    </div>
                    <div class="app-content">
                        <div style="padding: 20px; color: #333;">
                            <!-- 警告卡片 - 毛玻璃风格 -->
                            <div style="background: linear-gradient(135deg, rgba(255, 68, 68, 0.15) 0%, rgba(255, 68, 68, 0.08) 100%); border: 2px solid rgba(255, 68, 68, 0.3); border-radius: 16px; padding: 20px; margin-bottom: 25px; backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); box-shadow: 0 8px 32px rgba(255, 68, 68, 0.1);">
                                <h3 style="color: #ff4444; margin: 0 0 12px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>⚠️</span> 数据丢失检测
                                </h3>
                                <p style="margin: 0; font-size: 15px; color: #666; line-height: 1.5;">如果您的角色突然消失，请使用以下功能恢复数据。</p>
                            </div>

                            <!-- 第一步 -->
                            <div class="recovery-section" style="background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 25px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08); border: 1px solid rgba(255, 255, 255, 0.2);">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>🔍</span> 第一步：检查数据状态
                                </h4>
                                <button onclick="checkDataStatus()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-bg, rgba(74, 132, 193, 0.9)); color: var(--theme-button-color, white); border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: var(--theme-button-shadow, 0 4px 15px rgba(74, 132, 193, 0.3)); transition: all 0.3s ease; margin-bottom: 15px;">
                                    检查当前数据状态
                                </button>
                                <div id="data-status-result" style="background: rgba(248, 249, 250, 0.9); border-radius: 12px; padding: 15px; margin-bottom: 20px; display: none; backdrop-filter: blur(10px); border: 1px solid rgba(0,0,0,0.05);">
                                    <pre id="data-status-text" style="font-size: 12px; margin: 0; white-space: pre-wrap; color: #333; font-family: 'SF Mono', Monaco, monospace;"></pre>
                                </div>
                            </div>

                            <!-- 第二步 -->
                            <div class="recovery-section" style="background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 25px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08); border: 1px solid rgba(255, 255, 255, 0.2);">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>🔍</span> 第二步：深度数据挖掘
                                </h4>
                                <p style="font-size: 14px; color: #666; margin-bottom: 15px; line-height: 1.5;">搜索浏览器中可能残留的角色数据：</p>
                                <div style="display: flex; flex-direction: column; gap: 12px;">
                                    <button onclick="deepDataSearch()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-bg, rgba(74, 132, 193, 0.9)); color: var(--theme-button-color, white); border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: var(--theme-button-shadow, 0 4px 15px rgba(74, 132, 193, 0.3)); transition: all 0.3s ease;">
                                        🔍 深度搜索残留数据
                                    </button>
                                    <button onclick="searchChatHistory()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-secondary-bg, rgba(255, 255, 255, 0.8)); color: var(--theme-button-secondary-color, #666); border: 2px solid var(--theme-button-secondary-border, rgba(0, 0, 0, 0.1)); border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); transition: all 0.3s ease;">
                                        💬 从聊天记录推断角色
                                    </button>
                                </div>
                                <div id="deep-search-result" style="background: rgba(248, 249, 250, 0.9); border-radius: 12px; padding: 15px; margin-top: 15px; display: none; backdrop-filter: blur(10px); border: 1px solid rgba(0,0,0,0.05);">
                                    <pre id="deep-search-text" style="font-size: 12px; margin: 0; white-space: pre-wrap; color: #333; font-family: 'SF Mono', Monaco, monospace;"></pre>
                                </div>
                            </div>

                            <!-- 第三步 -->
                            <div class="recovery-section" style="background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 25px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08); border: 1px solid rgba(255, 255, 255, 0.2);">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>📥</span> 第三步：文件导入恢复
                                </h4>
                                <p style="font-size: 14px; color: #666; margin-bottom: 15px; line-height: 1.5;">如果您有备份文件：</p>
                                <input type="file" id="recovery-file-input" accept=".json" style="width: 100%; padding: 12px 15px; border: 2px solid rgba(0, 0, 0, 0.08); border-radius: 12px; font-size: 16px; background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(10px); transition: all 0.3s ease; color: #333; box-sizing: border-box; margin-bottom: 15px;">
                                <button onclick="recoverFromFile()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-bg, rgba(74, 132, 193, 0.9)); color: var(--theme-button-color, white); border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: var(--theme-button-shadow, 0 4px 15px rgba(74, 132, 193, 0.3)); transition: all 0.3s ease;">
                                    从文件恢复数据
                                </button>
                            </div>

                            <!-- 第四步 -->
                            <div class="recovery-section" style="background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 25px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08); border: 1px solid rgba(255, 255, 255, 0.2);">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>🔧</span> 第四步：重建角色卡
                                </h4>
                                <p style="font-size: 14px; color: #666; margin-bottom: 15px; line-height: 1.5;">从聊天记录重建丢失的角色：</p>
                                <div style="display: flex; flex-direction: column; gap: 12px;">
                                    <button onclick="rebuildCharactersFromChat()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-bg, rgba(74, 132, 193, 0.9)); color: var(--theme-button-color, white); border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: var(--theme-button-shadow, 0 4px 15px rgba(74, 132, 193, 0.3)); transition: all 0.3s ease;">
                                        🔧 自动重建所有角色
                                    </button>
                                    <button onclick="showManualRebuild()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-secondary-bg, rgba(255, 255, 255, 0.8)); color: var(--theme-button-secondary-color, #666); border: 2px solid var(--theme-button-secondary-border, rgba(0, 0, 0, 0.1)); border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); transition: all 0.3s ease;">
                                        ✏️ 手动重建角色
                                    </button>
                                </div>
                            </div>

                            <!-- 调试工具 -->
                            <div class="recovery-section" style="background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 25px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08); border: 1px solid rgba(255, 255, 255, 0.2);">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>🔍</span> 调试：检查当前状态
                                </h4>
                                <div style="display: flex; flex-direction: column; gap: 12px;">
                                    <button onclick="debugCurrentState()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-secondary-bg, rgba(255, 255, 255, 0.8)); color: var(--theme-button-secondary-color, #666); border: 2px solid var(--theme-button-secondary-border, rgba(0, 0, 0, 0.1)); border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); transition: all 0.3s ease;">
                                        🔍 检查当前数据状态
                                    </button>
                                    <button onclick="forceRefreshAll()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-bg, rgba(74, 132, 193, 0.9)); color: var(--theme-button-color, white); border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: var(--theme-button-shadow, 0 4px 15px rgba(74, 132, 193, 0.3)); transition: all 0.3s ease;">
                                        🔄 强制刷新所有界面
                                    </button>
                                </div>
                            </div>

                            <!-- 第五步 -->
                            <div class="recovery-section" style="background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 25px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08); border: 1px solid rgba(255, 255, 255, 0.2);">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>🧹</span> 第五步：清理异常数据
                                </h4>
                                <div style="display: flex; flex-direction: column; gap: 12px;">
                                    <button onclick="cleanupBadData()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-secondary-bg, rgba(255, 255, 255, 0.8)); color: var(--theme-button-secondary-color, #666); border: 2px solid var(--theme-button-secondary-border, rgba(0, 0, 0, 0.1)); border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); transition: all 0.3s ease;">
                                        清除张三李四等异常角色
                                    </button>
                                    <button onclick="forceReload()" style="width: 100%; padding: 14px 20px; background: #FF3B30; color: white; border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: 0 4px 15px rgba(255, 59, 48, 0.3); transition: all 0.3s ease;">
                                        强制重新加载数据
                                    </button>
                                </div>
                            </div>

                            <!-- 恢复日志 -->
                            <div id="recovery-log" style="background: rgba(248, 249, 250, 0.9); border-radius: 16px; padding: 20px; margin-top: 20px; max-height: 200px; overflow-y: auto; display: none; backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border: 1px solid rgba(0,0,0,0.05); box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);">
                                <h5 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>📋</span> 恢复日志：
                                </h5>
                                <div id="recovery-log-content" style="font-size: 13px; font-family: 'SF Mono', Monaco, monospace; color: #555; line-height: 1.4;"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 关于我们 -->
                <div id="about-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('about-screen')">‹</button>
                        <div class="app-title">关于我们</div>
                    </div>
                    <div class="app-content">
                        <div class="about-content">
                            <div class="about-title">iPhone 模拟器</div>
                            <div class="about-version">版本 1.0.0</div>
                            <div class="about-author">作者@EVE</div>
                        </div>
                    </div>
                </div>
                
                <!-- 电话通话界面 -->
                <div id="phone-call-screen" class="app-screen">
                    <div class="call-background"></div>
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="call-content">
                        <div class="call-header">
                            <div class="call-avatar">
                                <img id="call-avatar-img" src="" alt="通话头像">
                            </div>
                            <div class="call-name" id="call-name">角色名称</div>
                            <div class="call-status" id="call-status">正在通话中...</div>
                            <div class="call-time" id="call-timer">00:00</div>
                        </div>
                        
                        <div class="call-message-container" id="call-message-container">
                            <!-- 通话中的消息将在这里显示 -->
                        </div>
                        
                        <div class="call-input-area">
                            <input type="text" id="call-input" placeholder="输入消息..." class="call-text-input" onkeypress="if(event.key === 'Enter') { event.preventDefault(); sendCallMessage(); }">
                            <button class="call-send-btn" onclick="sendCallMessage()">
                                <i class="fas fa-paper-plane"></i>
                            </button>
                        </div>
                        
                        <div class="call-controls">
                                                    <button class="call-control-btn end-call-btn" onclick="endCall()"></button>
                        </div>
                    </div>
                </div>
                
                <!-- 来电显示界面 -->
                <div id="incoming-call-screen" class="app-screen">
                    <div class="call-background incoming"></div>
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="incoming-call-content">
                        <div class="call-header">
                            <div class="call-avatar large-avatar">
                                <img id="incoming-call-avatar" src="" alt="来电头像">
                            </div>
                            <div class="call-name" id="incoming-call-name">角色名称</div>
                            <div class="call-status">来电</div>
                            <div class="call-text" id="incoming-call-text">想和你通话...</div>
                        </div>
                        
                        <div class="incoming-call-controls">
                            <button class="incoming-call-btn reject-btn" onclick="rejectCall()">
                                <div class="call-btn-icon">
                                    <i class="fas fa-phone-slash"></i>
                                </div>
                                <div class="call-btn-text">拒绝</div>
                            </button>
                            <button class="incoming-call-btn accept-btn" onclick="acceptCall()">
                                <div class="call-btn-icon">
                                    <i class="fas fa-phone"></i>
                                </div>
                                <div class="call-btn-text">接听</div>
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- 字号大小设置 -->
                <div id="display-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('display-screen')">‹</button>
                        <div class="app-title">字号大小</div>
                    </div>
                    <div class="app-content">
                        <div class="font-size-preview">
                            <div class="font-size-preview-text" id="font-size-preview">
                                这是一段示例文字，用于预览字体大小效果。调节下方滑块可以改变字体大小。
                            </div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">字号大小</div>
                                    <div class="setting-desc">调节聊天消息和社交动态的字体大小</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="font-size-slider-container">
                            <div class="font-size-labels">
                                <span>小</span>
                                <span>标准</span>
                                <span>大</span>
                            </div>
                            <input type="range" class="font-size-slider" id="font-size-slider" 
                                   min="12" max="20" step="1" value="15" 
                                   onchange="changeFontSize(this.value)">
                            <div class="font-size-value">
                                当前字号：<span id="font-size-value">15px</span>
                            </div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">字距设置</div>
                                    <div class="setting-desc">调节文字之间的间距</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="font-size-slider-container">
                            <div class="font-size-labels">
                                <span>紧凑</span>
                                <span>标准</span>
                                <span>宽松</span>
                            </div>
                            <input type="range" class="font-size-slider" id="letter-spacing-slider" 
                                   min="-0.5" max="2" step="0.1" value="0" 
                                   onchange="changeLetterSpacing(this.value)">
                            <div class="font-size-value">
                                当前字距：<span id="letter-spacing-value">标准</span>
                            </div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">自动缩放</div>
                                    <div class="setting-desc">根据屏幕尺寸自动调整字体大小</div>
                                </div>
                            </div>
                            <label class="settings-toggle">
                                <input type="checkbox" id="auto-scale-toggle" onchange="toggleAutoScale()">
                                <span class="settings-slider"></span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <!-- 屏幕尺寸设置 -->
                <div id="screen-size-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('screen-size-screen')">‹</button>
                        <div class="app-title">屏幕尺寸</div>
                    </div>
                    <div class="app-content">
                        <div class="size-option" onclick="changeScreenSize(350, 740, '适中尺寸')" id="size-350-740">
                            <div class="size-option-left">
                                <div class="size-name">适中尺寸</div>
                                <div class="size-desc">350×740 (推荐)</div>
                            </div>
                            <div class="size-preview">
                                <div class="size-preview-rect size-preview-rect-s"></div>
                            </div>
                            <i class="fas fa-check check-icon"></i>
                        </div>

                        <div class="size-option" onclick="changeScreenSize(425, 860, 'iPhone 15')">
                            <div class="size-option-left">
                                <div class="size-name">iPhone 15</div>
                                <div class="size-desc">425×860 (适配手机)</div>
                            </div>
                            <div class="size-preview">
                                <div class="size-preview-rect size-preview-rect-l"></div>
                            </div>
                        </div>

                        <div class="size-option" onclick="changeScreenSize(450, 950, 'iPhone 15 Plus')">
                            <div class="size-option-left">
                                <div class="size-name">iPhone 15 Plus</div>
                                <div class="size-desc">450×950 (大屏)</div>
                            </div>
                            <div class="size-preview">
                                <div class="size-preview-rect size-preview-rect-xl"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 外观设置 -->
                <div id="appearance-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('appearance-screen')">‹</button>
                        <div class="app-title">外观设置</div>
                    </div>
                    <div class="app-content">
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">显示手机边框</div>
                                    <div class="setting-desc">显示圆角边框和阴影效果</div>
                                </div>
                            </div>
                            <label class="settings-toggle">
                                <input type="checkbox" id="phone-border-toggle" checked onchange="togglePhoneBorder()">
                                <span class="settings-slider"></span>
                            </label>
                        </div>
                        <div class="settings-item" onclick="showScreenSizeOptions()">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">屏幕尺寸</div>
                                    <div class="setting-desc" id="current-screen-size">当前：350×740 (适中尺寸)</div>
                                </div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">状态栏图标</div>
                                    <div class="setting-desc">自定义时间右侧显示的图标或文字</div>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <input type="text" id="status-icon-input" placeholder="🐾" maxlength="5"
                                       style="width: 50px; padding: 6px 8px; border: 1px solid var(--theme-input-border, rgba(0, 0, 0, 0.08));
                                              border-radius: var(--theme-input-radius, 15px); background: var(--theme-form-bg, rgba(255, 255, 255, 0.8));
                                              font-size: 14px; text-align: center;"
                                       onchange="updateStatusIcon()">
                                <button onclick="resetStatusIcon()"
                                        style="padding: 6px 10px; background: var(--theme-button-secondary-bg, rgba(255, 255, 255, 0.8));
                                               border: 1px solid var(--theme-button-secondary-border, rgba(0, 0, 0, 0.1));
                                               border-radius: var(--theme-input-radius, 15px); color: var(--theme-button-secondary-color, #555);
                                               font-size: 12px; cursor: pointer; flex-shrink: 0;">
                                    重置
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 主题设置界面 -->
                <div id="theme-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('theme-screen')">‹</button>
                        <div class="app-title">主题设置</div>
                    </div>
                    <div class="app-content">
                        <div class="theme-option" onclick="changeTheme('default')">
                            <div class="theme-preview theme-preview-simple">
                                <div class="theme-preview-header"></div>
                                <div class="theme-preview-content"></div>
                            </div>
                            <div class="theme-info">
                                <div class="theme-name">简约风格</div>
                                <div class="theme-description">清新简洁的默认主题</div>
                            </div>
                        </div>
                        
                        <div class="theme-option" onclick="changeTheme('cute')">
                            <div class="theme-preview theme-preview-cute">
                                <div class="theme-preview-header"></div>
                                <div class="theme-preview-content"></div>
                            </div>
                            <div class="theme-info">
                                <div class="theme-name">可爱风格</div>
                                <div class="theme-description">温馨可爱的粉色主题</div>
                            </div>
                        </div>
                        </div>
                    </div>
                </div>
                
                <!-- 壁纸设置 -->
                <div id="wallpaper-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('wallpaper-screen')">‹</button>
                        <div class="app-title">壁纸</div>
                    </div>
                    <div class="app-content">
                        <div class="settings-item" onclick="showWallpaperPicker()">
                            <div class="settings-item-left">
                                <div>选择新壁纸</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showIconPicker()">
                            <div class="settings-item-left">
                                <div>更改应用图标</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                    </div>
                </div>
                
                <!-- 无线局域网设置 -->
                <div id="wifi-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('wifi-screen')">‹</button>
                        <div class="app-title">无线局域网</div>
                    </div>
                    <div class="app-content">
                        <div class="wifi-settings">
                            <div class="settings-item">
                                <div class="settings-item-left">
                                    <div>无线局域网</div>
                                </div>
                                <label class="settings-toggle">
                                    <input type="checkbox" checked>
                                    <span class="settings-slider"></span>
                                </label>
                            </div>
                            
                            <div class="wifi-network">
                                <div class="wifi-network-left">
                                    <div class="wifi-icon">
                                        <i class="fas fa-lock"></i>
                                    </div>
                                    <div>
                                        <div>HomeWiFi</div>
                                        <div class="wifi-strength">
                                            <div class="wifi-strength-bar active"></div>
                                            <div class="wifi-strength-bar active"></div>
                                            <div class="wifi-strength-bar active"></div>
                                            <div class="wifi-strength-bar active"></div>
                                        </div>
                                    </div>
                                </div>
                                <i class="fas fa-check check-icon"></i>
                            </div>
                            
                            <div class="settings-item settings-item-margin" onclick="showApp('api-settings-screen')">
                                <div class="settings-item-left">
                                    <div>API设置</div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- API设置界面 -->
                <div id="api-settings-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('api-settings-screen')">‹</button>
                        <div class="app-title">API设置</div>
                    </div>
                    <div class="app-content">
                        <div class="form-container" style="color: #000000;">
                            

                            
                            <!-- 快速设置卡片 -->
                            <div class="form-group" style="margin-bottom: 30px;">
                                <label style="color: #333; margin-bottom: 15px; display: block; font-size: 16px; font-weight: 600;">🚀 快速设置</label>
                                
                                <!-- Gemini直连卡片 -->
                                <div style="margin-bottom: 12px; padding: 18px; background: linear-gradient(135deg, rgba(74, 132, 193, 0.1) 0%, rgba(74, 132, 193, 0.05) 100%); border: 2px solid rgba(74, 132, 193, 0.2); border-radius: 16px; color: #333; cursor: pointer; transition: all 0.3s ease; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);" onclick="setGeminiDirect()">
                                    <div style="display: flex; align-items: center; justify-content: space-between;">
                                        <div>
                                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 4px; color: var(--theme-button-bg, #4a84c1);">🌟 Gemini 直连</div>
                                            <div style="font-size: 13px; color: #666;">自动配置Google官方API，支持最新模型</div>
                                        </div>
                                        <div style="background: var(--theme-button-bg, rgba(74, 132, 193, 0.9)); color: white; padding: 8px 14px; border-radius: 20px; font-size: 13px; font-weight: 500; box-shadow: 0 2px 8px rgba(74, 132, 193, 0.3);">点击配置</div>
                                    </div>
                            </div>
                            
                                <!-- HuggingFace反代卡片 -->
                                <div style="margin-bottom: 15px; padding: 18px; background: linear-gradient(135deg, rgba(255, 193, 7, 0.1) 0%, rgba(255, 193, 7, 0.05) 100%); border: 2px solid rgba(255, 193, 7, 0.2); border-radius: 16px; color: #333; cursor: pointer; transition: all 0.3s ease; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);" onclick="setHuggingFaceProxy()">
                                    <div style="display: flex; align-items: center; justify-content: space-between;">
                                        <div>
                                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 4px; color: #f39c12;">🤗 HuggingFace 反代</div>
                                            <div style="font-size: 13px; color: #666;">免费使用多种大模型，支持Claude等</div>
                                        </div>
                                        <div style="background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%); color: white; padding: 8px 14px; border-radius: 20px; font-size: 13px; font-weight: 500; box-shadow: 0 2px 8px rgba(243, 156, 18, 0.3);">点击配置</div>
                                    </div>
                            </div>
                            
                                <div style="font-size: 12px; color: #666; text-align: center; margin-top: 10px;">
                                    ⚠️ 使用前请确保有对应的API密钥
                                </div>
                            </div>
                            
                            <!-- API配置表单 - 美化版 -->
                            <div style="background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 25px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1); border: 1px solid rgba(255, 255, 255, 0.2);">
                                
                                <!-- API地址 -->
                                <div style="margin-bottom: 20px;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: var(--theme-text-primary, #333); font-size: 15px;">API地址</label>
                                    <input type="text" id="api-base" placeholder="例如: https://api.openai.com 或 @https://xxx-xxx.hf.space/v1" style="width: 100%; padding: 12px 15px; border: 2px solid var(--theme-input-border, rgba(0, 0, 0, 0.08)); border-radius: 12px; font-size: 16px; background: var(--theme-form-bg, rgba(255, 255, 255, 0.9)); backdrop-filter: blur(10px); transition: all 0.3s ease; color: var(--theme-text-primary, #333); box-sizing: border-box;">
                                    <div style="font-size: 12px; color: #666; margin-top: 5px;">支持标准API和HuggingFace反代（格式：@https://xxx.hf.space/v1）</div>
                            </div>
                            
                                <!-- API密钥 -->
                                <div style="margin-bottom: 20px;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: var(--theme-text-primary, #333); font-size: 15px;">API密钥</label>
                                    <input type="password" id="api-key" placeholder="sk-... 或 Google AI Studio API Key" style="width: 100%; padding: 12px 15px; border: 2px solid var(--theme-input-border, rgba(0, 0, 0, 0.08)); border-radius: 12px; font-size: 16px; background: var(--theme-form-bg, rgba(255, 255, 255, 0.9)); backdrop-filter: blur(10px); transition: all 0.3s ease; color: var(--theme-text-primary, #333); box-sizing: border-box;">
                                </div>
                                
                                <!-- 模型选择 -->
                                <div style="margin-bottom: 20px;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: var(--theme-text-primary, #333); font-size: 15px;">模型</label>
                                    <div style="display: flex; gap: 10px; align-items: center; width: 100%; overflow: hidden;">
                                        <select id="model-select" style="flex: 1; min-width: 0; padding: 12px 15px; border: 2px solid var(--theme-input-border, rgba(0, 0, 0, 0.08)); border-radius: 12px; font-size: 16px; background: var(--theme-form-bg, rgba(255, 255, 255, 0.9)); backdrop-filter: blur(10px); transition: all 0.3s ease; color: var(--theme-text-primary, #333); max-height: 200px; overflow-y: auto;">
                                            <!-- 模型选项将通过JS动态填充 -->
                                    </select>
                                        <button id="fetch-models-btn" onclick="fetchModels()" style="padding: 10px 16px; background: var(--theme-button-secondary-bg, rgba(255, 255, 255, 0.8)); color: var(--theme-button-secondary-color, #666); border: 2px solid var(--theme-button-secondary-border, rgba(0, 0, 0, 0.1)); border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: 500; backdrop-filter: blur(10px); transition: all 0.3s ease; white-space: nowrap;">拉取模型</button>
                                </div>
                            </div>
                            
                                <!-- 温度参数 -->
                                <div style="margin-bottom: 25px;">
                                    <label style="display: block; margin-bottom: 12px; font-weight: 600; color: var(--theme-text-primary, #333); font-size: 15px;">温度参数 (<span id="temperature-value" style="color: var(--theme-button-bg, #4a84c1); font-weight: 700;">0.75</span>)</label>
                                    <div style="background: rgba(255, 255, 255, 0.8); padding: 15px; border-radius: 12px; border: 2px solid var(--theme-input-border, rgba(0, 0, 0, 0.08));">
                                        <input type="range" id="temperature-slider" min="0" max="2" step="0.05" value="0.75" oninput="document.getElementById('temperature-value').textContent = parseFloat(this.value).toFixed(2);" style="width: 100%; height: 6px; border-radius: 3px; background: linear-gradient(to right, rgba(74, 132, 193, 0.2) 0%, rgba(74, 132, 193, 0.4) 100%); outline: none; -webkit-appearance: none; appearance: none;">
                                        <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 12px; color: #666;">
                                            <span>0.00 (保守)</span>
                                            <span>1.00 (平衡)</span>
                                            <span>2.00 (创新)</span>
                                        </div>
                                        <div style="font-size: 12px; color: #666; margin-top: 8px; text-align: center;">温度越低，回答越保守稳定；温度越高，回答越有创意多样</div>
                                    </div>
                            </div>
                            
                                <!-- 操作按钮 -->
                                <div style="display: flex; gap: 12px; margin-top: 25px;">
                                    <button id="test-api-connection-btn" onclick="testApiConnection()" style="flex: 1; padding: 14px 20px; background: linear-gradient(135deg, #34c759 0%, #30d158 100%); color: white; border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: 0 4px 15px rgba(52, 199, 89, 0.3); transition: all 0.3s ease;">测试连接</button>
                                    <button id="save-api-settings-btn" onclick="saveApiSettings()" style="flex: 1; padding: 14px 20px; background: var(--theme-button-bg, rgba(74, 132, 193, 0.9)); color: var(--theme-button-color, white); border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: var(--theme-button-shadow, 0 4px 15px rgba(74, 132, 193, 0.3)); transition: all 0.3s ease;">保存设置</button>
                                </div>
                            </div>

                            <!-- API配置管理 -->
                            <hr style="margin: 30px 0; border: none; border-top: 1px solid #eaeaea;">
                            <div class="api-config-manager" style="background: rgba(248, 249, 250, 0.8); border-radius: 16px; padding: 20px; margin: 15px 0; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(0,0,0,0.05);">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>💾</span> API配置管理
                                </h4>
                                <p style="font-size: 13px; color: #666; margin: 0 0 15px 0; line-height: 1.5;">保存当前配置为预设，方便快速切换不同的API服务</p>
                                
                                <div class="save-config-section" style="margin-bottom: 20px; padding: 15px; background: rgba(255,255,255,0.6); border-radius: 12px; border: 1px solid rgba(0,0,0,0.05);">
                                    <div style="display: flex; gap: 10px; margin-bottom: 12px;">
                                        <input type="text" id="config-name-input" placeholder="输入配置名称 (如: OpenAI、Gemini、Claude等)" style="flex: 1; padding: 10px 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px; background: rgba(255,255,255,0.9);">
                                        <button id="save-current-config-btn" onclick="saveCurrentConfig()" style="padding: 10px 16px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);">💾 保存配置</button>
                        </div>
                                    <div style="font-size: 12px; color: #888;">当前配置将保存为: <span style="color: #333; font-weight: 500;">URL + 模型 + 温度设置</span></div>
                                </div>
                                
                                <div class="saved-configs-section">
                                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                                        <label style="font-size: 14px; font-weight: 500; color: #333;">已保存的配置</label>
                                        <button id="clear-all-configs-btn" onclick="clearAllConfigs()" style="padding: 6px 12px; background: rgba(255, 107, 107, 0.1); color: #ff6b6b; border: 1px solid rgba(255, 107, 107, 0.3); border-radius: 6px; font-size: 12px; cursor: pointer; transition: all 0.2s ease;">🗑️ 清空全部</button>
                                    </div>
                                    <div id="saved-configs-container" style="display: grid; gap: 10px; max-height: 300px; overflow-y: auto;">
                                        <!-- 保存的配置卡片将在这里动态生成 -->
                                    </div>
                                    <div id="no-configs-message" style="text-align: center; color: #999; padding: 30px 20px; font-size: 14px; display: none;">
                                        <div style="font-size: 24px; margin-bottom: 8px;">📝</div>
                                        <div>还没有保存任何配置</div>
                                        <div style="font-size: 12px; margin-top: 4px;">在上方输入配置名称并点击"保存配置"</div>
                                    </div>
                                </div>
                            </div>



                        </div>
                    </div>
                </div>
                
                <!-- 颜色选择器模态框 -->
                <div class="modal" id="color-picker-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title" id="color-picker-title">选择颜色</div>
                            <button class="modal-close" onclick="hideModal('color-picker-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="color-picker" id="color-picker">
                                <div class="color-option color-red" onclick="selectColor('#FF3B30')"></div>
                                <div class="color-option color-orange" onclick="selectColor('#FF9500')"></div>
                                <div class="color-option color-yellow" onclick="selectColor('#FFCC00')"></div>
                                <div class="color-option color-green" onclick="selectColor('#34C759')"></div>
                                <div class="color-option color-light-blue" onclick="selectColor('#5AC8FA')"></div>
                                <div class="color-option color-blue" onclick="selectColor('#007AFF')"></div>
                                <div class="color-option color-purple" onclick="selectColor('#5856D6')"></div>
                                <div class="color-option color-pink" onclick="selectColor('#AF52DE')"></div>
                                <div class="color-option color-red-alt" onclick="selectColor('#FF2D55')"></div>
                            </div>
                            <div class="form-group">
                                <label class="form-label">透明度</label>
                                <input type="range" class="opacity-slider" id="opacity-slider" min="0" max="1" step="0.1" value="1">
                                <span id="opacity-value">100%</span>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('color-picker-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="applyColorSelection()">应用</button>
                        </div>
                    </div>
                </div>
                
                <!-- 壁纸选择器模态框 -->
                <div class="modal" id="wallpaper-picker-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">选择壁纸</div>
                            <button class="modal-close" onclick="hideModal('wallpaper-picker-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="wallpaper-preview-container" id="wallpaper-preview-container">
                                <div class="wallpaper-preview-placeholder">
                                    <i class="fas fa-image"></i>
                                    <div>选择本地图片后可在此预览</div>
                                </div>
                            </div>
                            <div class="settings-item upload-custom-item" onclick="uploadCustomWallpaper()">
                                <div class="settings-item-left">
                                    <div>从相册选择</div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <input type="file" id="custom-wallpaper-upload" accept="image/*" class="file-input-hidden">
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('wallpaper-picker-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="applyWallpaperSelection()">应用</button>
                        </div>
                    </div>
                </div>
                
                <!-- 图标选择器模态框 -->
                <div class="modal" id="icon-picker-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">更改应用图标</div>
                            <button class="modal-close" onclick="hideModal('icon-picker-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <!-- 应用列表 -->
                            <div class="app-list-section">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px;">选择要修改的应用</h4>
                                <div id="app-list-container" class="app-list-grid">
                                    <!-- 动态生成应用列表 -->
                                </div>
                            </div>

                            <!-- 图标上传区域 -->
                            <div class="icon-upload-section" id="icon-upload-section" style="display: none;">
                                <h4 style="margin: 20px 0 15px 0; color: #333; font-size: 16px;">上传新图标</h4>
                                <div class="upload-area" onclick="triggerIconUpload()">
                                    <div class="upload-placeholder" id="upload-placeholder">
                                        <i class="fas fa-cloud-upload-alt" style="font-size: 32px; color: #999; margin-bottom: 10px;"></i>
                                        <div style="color: #666;">点击选择图片</div>
                                        <div style="color: #999; font-size: 12px; margin-top: 5px;">支持 JPG、PNG 格式</div>
                                    </div>
                                    <img id="icon-preview-img" class="icon-preview-img" style="display: none;">
                                </div>
                                <input type="file" id="custom-icon-upload" accept="image/*" class="file-input-hidden">
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('icon-picker-modal')">取消</button>
                            <button class="modal-button modal-primary" id="apply-icon-btn" onclick="applyIconChange()" style="display: none;">应用</button>
                        </div>
                    </div>
                </div>
                
                <!-- 照片拍摄模态框 -->

                

                

                
                <!-- 聊天选项模态框 -->
                <div class="modal" id="chat-options-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">选择聊天类型</div>
                            <button class="modal-close" onclick="hideModal('chat-options-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="chat-option-item" onclick="showSingleChatSelector()">
                                <div class="chat-option-icon">
                                    <i class="fas fa-user icon-user-blue"></i>
                                </div>
                                <div class="chat-option-text">
                                    <div class="chat-option-title">单聊</div>
                                    <div class="chat-option-desc">与单个角色进行对话</div>
                                </div>
                            </div>
                            <div class="chat-option-item" onclick="showGroupChatSelector()">
                                <div class="chat-option-icon">
                                    <i class="fas fa-users icon-users-green"></i>
                                </div>
                                <div class="chat-option-text">
                                    <div class="chat-option-title">群聊</div>
                                    <div class="chat-option-desc">与多个角色同时聊天</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 单聊角色选择模态框 -->
                <div class="modal" id="single-chat-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">选择聊天角色</div>
                            <button class="modal-close" onclick="hideModal('single-chat-modal')">&times;</button>
                        </div>
                        <div class="modal-body" id="single-chat-body">
                            <!-- 角色列表将通过JS动态生成 -->
                        </div>
                    </div>
                </div>
                
                <!-- 群聊角色选择模态框 -->
                <div class="modal" id="group-chat-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">创建群聊</div>
                            <button class="modal-close" onclick="hideModal('group-chat-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">群聊名称</label>
                                <input type="text" class="form-input" id="group-chat-name" placeholder="例如：动态分享、工作群">
                            </div>
                            <div class="form-group">
                                <label class="form-label">选择成员 (至少2人，最多20人)</label>
                                <div id="group-chat-members">
                                    <!-- 群聊成员选择将通过JS动态生成 -->
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('group-chat-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="createGroupChat()">创建群聊</button>
                        </div>
                    </div>
                </div>
                
                <!-- 历史消息设置模态框 -->
                <div class="modal" id="history-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">历史消息设置</div>
                            <button class="modal-close" onclick="hideModal('history-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body" style="padding: 20px;">
                            <div class="setting-card" style="margin-bottom: 20px;">
                                <div class="setting-item" style="margin-bottom: 15px;">
                                    <div class="setting-left">
                                        <div class="setting-label" style="font-size: 16px; margin-bottom: 8px;">附带历史消息数 (回合数)</div>
                                        <div class="setting-desc" style="font-size: 14px; line-height: 1.4;">AI回复时参考的历史对话回合数</div>
                                    </div>
                                    <div class="setting-right">
                                        <span class="setting-value" id="history-count-display" style="font-size: 16px; font-weight: 600;">5回合</span>
                                    </div>
                                </div>
                                <div class="setting-range-container" style="margin-bottom: 15px;">
                                    <input type="range" class="theme-range" id="history-messages-count" min="0" max="100" step="1" value="5">
                                    <div class="range-labels">
                                        <span>0回合</span>
                                        <span>100回合</span>
                                    </div>
                                </div>
                                <div class="custom-input-container" style="margin-bottom: 15px;">
                                    <span class="input-label">自定义数值：</span>
                                    <input type="number" class="theme-input" id="custom-history-count" min="0" max="500" value="5" style="width: 80px; margin: 0 8px;">
                                    <span class="input-unit">回合 (最大500)</span>
                                </div>
                                <div class="setting-explanation">
                                    <div class="explanation-text">
                                        <strong>说明：</strong><br>
                                        • 一回合 = 你的一条消息 + AI的一条回复<br>
                                        • 设置为5表示AI回复时会参考最近5回合对话<br>
                                        • 注意：数值过大可能影响API响应速度
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer" style="display: flex; justify-content: space-between; padding: 20px; gap: 0;">
                            <button class="theme-button theme-button-secondary" onclick="hideModal('history-settings-modal')" style="margin: 0; padding: 12px 20px;">取消</button>
                            <button class="theme-button theme-button-primary" onclick="saveHistorySettings()" style="margin: 0; padding: 12px 20px;">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 记忆挂载设置模态框 -->
                <div class="modal" id="memory-mount-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">记忆挂载设置</div>
                            <button class="modal-close" onclick="hideModal('memory-mount-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">
                                    <input type="checkbox" id="memory-mount-enabled" class="checkbox-with-margin">
                                    启用记忆挂载
                                </label>
                                <p class="small-text margin-top-5">
                                    开启后，AI会参考其他聊天窗口的对话内容作为背景记忆
                                </p>
                            </div>
                            <div class="form-group hide" id="memory-mount-details">
                                <label class="form-label">每个聊天挂载条数</label>
                                <input type="range" class="api-form-range" id="memory-mount-count" min="1" max="20" step="1" value="3">
                                <div class="flex-space-between">
                                    <span>1条</span>
                                    <span id="memory-mount-display">3条</span>
                                    <span>20条</span>
                                </div>
                            </div>
                            <div class="form-group hide" id="memory-mount-chats">
                                <label class="form-label">选择要挂载的聊天</label>
                                <div id="memory-mount-list" class="max-height-200-auto">
                                    <!-- 聊天列表将通过JS动态生成 -->
                                </div>
                                <p class="small-text margin-top-8">
                                    选择的聊天记录会作为背景信息提供给AI参考
                                </p>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('memory-mount-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveMemoryMountSettings()">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 头像设置模态框 -->
                <div class="modal" id="avatar-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">双方头像设置</div>
                            <button class="modal-close" onclick="hideModal('avatar-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="avatar-setting-group">
                                <label class="form-label">我的头像 (仅在此聊天窗口生效)</label>
                                <div class="avatar-preview-container">
                                    <div class="avatar-preview" id="my-chat-avatar-preview">
                                        <i class="fas fa-user"></i>
                                    </div>
                                    <input type="file" id="my-chat-avatar-upload" accept="image/*" class="file-input-hidden">
                                    <button class="upload-button" onclick="document.getElementById('my-chat-avatar-upload').click()">上传头像</button>
                                </div>
                            </div>
                            <div class="avatar-setting-group">
                                <label class="form-label">对方头像 (仅在此聊天窗口生效)</label>
                                <div class="avatar-preview-container">
                                    <div class="avatar-preview" id="ai-chat-avatar-preview">
                                        <i class="fas fa-robot"></i>
                                    </div>
                                    <input type="file" id="ai-chat-avatar-upload" accept="image/*" class="file-input-hidden">
                                    <button class="upload-button" onclick="document.getElementById('ai-chat-avatar-upload').click()">上传头像</button>
                                    <button class="upload-button clear-avatar-btn" onclick="clearAiDynamicAvatar()">清除动态头像</button>
                                </div>
                                <p class="small-text margin-top-5">
                                    注意：如果角色在聊天中更换了头像，动态头像会覆盖此设置，点击"清除动态头像"可重置
                                </p>
                            </div>
                            <div class="form-group margin-top-20">
                                <label class="form-label">
                                    <input type="checkbox" id="hide-avatars" class="checkbox-with-margin">
                                    隐藏双方头像
                                </label>
                                <p class="small-text margin-top-5">
                                    开启后，聊天界面将不显示任何头像
                                </p>
                            </div>
                            <p class="small-text margin-top-15">
                                注意：此设置仅影响当前聊天窗口显示，不会同步修改角色卡或面具设置
                            </p>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('avatar-settings-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveChatAvatarSettings()">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 昵称设置模态框 -->
                <div class="modal" id="nickname-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">双方备注设置</div>
                            <button class="modal-close" onclick="hideModal('nickname-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">我的昵称 (仅在此聊天中显示)</label>
                                <input type="text" class="form-input" id="my-chat-nickname" placeholder="输入你在此聊天中的昵称">
                            </div>
                            <div class="form-group">
                                <label class="form-label">对方昵称 (仅在此聊天中显示)</label>
                                <input type="text" class="form-input" id="ai-chat-nickname" placeholder="输入对方在此聊天中的昵称">
                            </div>
                            <p class="small-text margin-top-10">
                                注意：此设置仅影响当前聊天窗口显示，不会同步修改角色卡或面具设置。角色也可能根据心情和聊天内容自主修改自己的昵称。
                            </p>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('nickname-settings-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveChatNicknameSettings()">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 戳一戳后缀设置模态框 -->
                <div class="modal" id="poke-suffix-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">戳一戳后缀设置</div>
                            <button class="modal-close" onclick="hideModal('poke-suffix-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">我的戳一戳后缀</label>
                                <input type="text" class="form-input" id="my-poke-suffix" placeholder="留空为无后缀（例如：的小脸蛋）">
                                <p class="tiny-text margin-top-5">显示为：你戳了戳[角色名][后缀]，留空则显示：你戳了戳[角色名]</p>
                            </div>
                            <div class="form-group">
                                <label class="form-label">对方戳一戳后缀</label>
                                <input type="text" class="form-input" id="ai-poke-suffix" placeholder="留空为无后缀（例如：的小手）">
                                <p class="tiny-text margin-top-5">显示为：[角色名]戳了戳你[后缀]，留空则显示：[角色名]戳了戳你。角色可能根据心情自主修改此后缀。</p>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('poke-suffix-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="savePokeSuffixSettings()">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 聊天背景设置模态框 -->
                <div class="modal" id="background-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">聊天背景设置</div>
                            <button class="modal-close" onclick="hideModal('background-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="background-preview-container">
                                <div class="background-preview" id="chat-background-preview">
                                    <div class="preview-text">背景预览</div>
                                </div>
                            </div>
                            <div class="form-group">
                                <input type="file" id="background-upload" accept="image/*" class="file-input-hidden">
                                <button class="form-button" onclick="document.getElementById('background-upload').click()">选择背景图片</button>
                                <button class="form-button form-button-secondary" onclick="removeBackground()">移除背景</button>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('background-settings-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveChatBackgroundSettings()">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 🔥【新增】群成员气泡颜色设置模态框 -->
                <div class="modal" id="group-member-colors-modal" style="z-index: 10001;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">群成员气泡颜色设置</div>
                            <button class="modal-close" onclick="hideModal('group-member-colors-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="setting-explanation">
                                <div class="explanation-text">为每个群成员设置独特的气泡颜色，让群聊更加生动有趣。</div>
                            </div>
                            <div id="group-member-colors-list">
                                <!-- 动态生成群成员颜色设置项 -->
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('group-member-colors-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveGroupMemberColors()">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 气泡样式设置模态框 -->
                <div class="modal" id="bubble-style-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">气泡样式设置</div>
                            <button class="modal-close" onclick="hideModal('bubble-style-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="bubble-style-section">
                                <label class="form-label">选择气泡样式</label>
                                <div class="bubble-style-grid">
                                    <div class="bubble-style-option" data-style="default">
                                        <div class="style-preview">
                                            <div class="preview-bubble sent-preview">默认样式</div>
                                            <div class="preview-bubble received-preview">经典圆角</div>
                                        </div>
                                        <div class="style-name">默认样式</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="glass">
                                        <div class="style-preview bubble-style-glass">
                                            <div class="preview-bubble sent-preview">毛玻璃</div>
                                            <div class="preview-bubble received-preview">半透明</div>
                                        </div>
                                        <div class="style-name">毛玻璃</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="shadow">
                                        <div class="style-preview bubble-style-shadow">
                                            <div class="preview-bubble sent-preview">经典阴影</div>
                                            <div class="preview-bubble received-preview">立体感</div>
                                        </div>
                                        <div class="style-name">经典阴影</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="tail">
                                        <div class="style-preview bubble-style-tail">
                                            <div class="preview-bubble sent-preview">带尖角</div>
                                            <div class="preview-bubble received-preview">气泡戳</div>
                                        </div>
                                        <div class="style-name">经典气泡</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="gradient">
                                        <div class="style-preview bubble-style-gradient">
                                            <div class="preview-bubble sent-preview">渐变色</div>
                                            <div class="preview-bubble received-preview">美观</div>
                                        </div>
                                        <div class="style-name">渐变样式</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="minimal">
                                        <div class="style-preview bubble-style-minimal">
                                            <div class="preview-bubble sent-preview">极简线条</div>
                                            <div class="preview-bubble received-preview">简约</div>
                                        </div>
                                        <div class="style-name">极简样式</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="neon">
                                        <div class="style-preview bubble-style-neon">
                                            <div class="preview-bubble sent-preview">霓虹发光</div>
                                            <div class="preview-bubble received-preview">科技感</div>
                                        </div>
                                        <div class="style-name">霓虹样式</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="paper">
                                        <div class="style-preview bubble-style-paper">
                                            <div class="preview-bubble sent-preview">纸张卡片</div>
                                            <div class="preview-bubble received-preview">质感</div>
                                        </div>
                                        <div class="style-name">纸张样式</div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="color-setting-group">
                                <label class="form-label">自定义颜色</label>
                                <div class="color-picker-container">
                                    <div class="flex-gap-15">
                                        <div class="flex-1">
                                            <label class="label-small">我的气泡</label>
                                            <input type="color" id="my-bubble-color" class="color-input" value="#007AFF">
                                        </div>
                                        <div class="flex-1">
                                            <label class="label-small">对方气泡</label>
                                            <input type="color" id="ai-bubble-color" class="color-input" value="#f0f0f0">
                                            <!-- 🔥【新增】群聊角色单独设置按钮 -->
                                            <div id="group-member-colors-btn" style="display: none; margin-top: 8px;">
                                                <button type="button" class="theme-button theme-button-secondary" style="font-size: 12px; padding: 6px 12px;" onclick="showGroupMemberColorSettings()">
                                                    为群成员单独设置
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="opacity-setting">
                                    <div class="flex-gap-15-mb-15">
                                        <div class="flex-1">
                                            <label class="label-small">我的气泡透明度：<span id="my-bubble-opacity-value">100%</span></label>
                                            <input type="range" id="my-bubble-opacity" min="0.1" max="1" step="0.1" value="1" class="width-100">
                                        </div>
                                        <div class="flex-1">
                                            <label class="label-small">对方气泡透明度：<span id="ai-bubble-opacity-value">100%</span></label>
                                            <input type="range" id="ai-bubble-opacity" min="0.1" max="1" step="0.1" value="1" class="width-100">
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="padding-setting">
                                    <label class="form-label">气泡大小调节</label>
                                    <div class="flex-gap-15-mb-10">
                                        <div class="flex-1">
                                            <label class="label-small">内边距：<span id="bubble-padding-value">中等</span></label>
                                            <input type="range" id="bubble-padding" min="4" max="16" step="2" value="12" class="width-100">
                                        </div>
                                    </div>
                                    <p class="tiny-text-gray margin-top-5">
                                        调整气泡内文字与边缘的距离，数值越大气泡越大
                                    </p>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('bubble-style-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveBubbleStyleSettings()">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 定时发布设置模态框 -->
                <div class="modal" id="schedule-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">定时发布设置</div>
                            <button class="modal-close" onclick="hideModal('schedule-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">
                                    <input type="checkbox" id="schedule-enabled" class="checkbox-with-margin">
                                    启用定时发布
                                </label>
                                <p class="small-text margin-top-5">
                                    开启后，角色会在指定时间点自动发布社交动态
                                </p>
                            </div>
                            <div class="form-group hide" id="schedule-times-group">
                                <label class="form-label">发布时间点</label>
                                <div id="schedule-times-container">
                                    <!-- 时间点将通过JS动态添加 -->
                                </div>
                                <button type="button" class="form-button form-button-secondary" onclick="addScheduleTime()">+ 添加时间点</button>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('schedule-settings-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveScheduleSettings()">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 身份选择器模态框 -->
                <!-- 身份选择模态框已移除，身份在创建对话时选择 -->
                
                <!-- 世界书挂载设置模态框 -->
                <div class="modal" id="worldbook-mount-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">世界书挂载设置</div>
                            <button class="modal-close" onclick="hideModal('worldbook-mount-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">
                                    <input type="checkbox" id="worldbook-mount-enabled" class="checkbox-with-margin">
                                    启用世界书挂载
                                </label>
                                <p class="small-text margin-top-5">
                                    开启后，AI会参考选定的世界书内容作为背景知识进行对话
                                </p>
                            </div>
                            <div class="form-group hide" id="worldbook-mount-details">
                                <label class="form-label">选择要挂载的世界书</label>
                                <div id="worldbook-mount-list" class="max-height-300-auto">
                                    <!-- 世界书列表将通过JS动态生成 -->
                                </div>
                                <p class="small-text margin-top-8">
                                    选择的世界书内容会作为背景知识提供给AI参考，帮助AI更好地理解对话上下文
                                </p>
                            </div>
                            <div class="setting-explanation">
                                <div class="explanation-text">
                                    <strong>功能说明：</strong><br>
                                    • <strong>世界书挂载：</strong>将选定的世界书内容作为AI的背景知识<br>
                                    • <strong>多选支持：</strong>可以同时挂载多个世界书，内容会合并使用<br>
                                    • <strong>智能应用：</strong>AI会根据对话内容智能引用相关的世界书知识<br>
                                    • <strong>优先级：</strong>世界书知识优先级低于角色设定和历史对话
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer" style="display: flex; justify-content: space-between; padding: 20px; gap: 0;">
                            <button class="modal-button modal-secondary" onclick="hideModal('worldbook-mount-modal')" style="margin: 0; padding: 12px 20px;">取消</button>
                            <button class="modal-button modal-primary" onclick="saveWorldbookMountSettings()" style="margin: 0; padding: 12px 20px;">保存</button>
                        </div>
                    </div>
                </div>

                <!-- 时间戳设置模态框 -->
                <div class="modal" id="timestamp-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">时间戳设置</div>
                            <button class="modal-close" onclick="hideModal('timestamp-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">
                                    <input type="checkbox" id="timestamp-modal-enabled" class="checkbox-with-margin" checked>
                                    显示时间戳
                                </label>
                                <p class="small-text margin-top-5">
                                    在聊天消息中显示时间信息
                                </p>
                            </div>
                            
                            <div class="form-group" id="timestamp-options-group">
                                <label class="form-label">时间戳位置</label>
                                <div class="timestamp-position-options">
                                    <label class="radio-option">
                                        <input type="radio" name="timestamp-position" value="center" checked>
                                        <span class="radio-custom"></span>
                                        <div class="option-content">
                                            <div class="option-label">居中显示</div>
                                            <div class="option-desc">时间戳显示在聊天中间，每5分钟出现一次</div>
                                        </div>
                                    </label>
                                    
                                    <label class="radio-option">
                                        <input type="radio" name="timestamp-position" value="bubble">
                                        <span class="radio-custom"></span>
                                        <div class="option-content">
                                            <div class="option-label">气泡外侧</div>
                                            <div class="option-desc">时间戳显示在每条消息气泡的外侧</div>
                                        </div>
                                    </label>
                                    
                                    <label class="radio-option">
                                        <input type="radio" name="timestamp-position" value="avatar">
                                        <span class="radio-custom"></span>
                                        <div class="option-content">
                                            <div class="option-label">头像下方</div>
                                            <div class="option-desc">时间戳显示在头像正下方位置</div>
                                        </div>
                                    </label>
                                    
                                    <label class="radio-option">
                                        <input type="radio" name="timestamp-position" value="inside">
                                        <span class="radio-custom"></span>
                                        <div class="option-content">
                                            <div class="option-label">气泡内</div>
                                            <div class="option-desc">时间戳显示在气泡内右下角，与文字齐平</div>
                                        </div>
                                    </label>
                                </div>
                            </div>
                            
                            <div class="setting-explanation">
                                <div class="explanation-text">
                                    <strong>位置说明：</strong><br>
                                    • <strong>居中显示：</strong>时间戳水平居中，仅在超过5分钟间隔时显示<br>
                                    • <strong>气泡外侧：</strong>每条消息都显示时间，用户消息在左下角，角色消息在右下角<br>
                                    • <strong>头像下方：</strong>时间戳显示在对应头像的正下方位置<br>
                                    • 所有时间戳均使用灰色小字显示，不影响聊天体验
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('timestamp-settings-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveTimestampSettings()">保存</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    <!-- 转账功能相关模态框 -->
    <div id="transfer-modal">
        <div class="transfer-content">
                            <div class="transfer-header">发起转账</div>
            <div class="transfer-input-group">
                <label for="transfer-amount">转账金额</label>
                                    <input type="number" id="transfer-amount" placeholder="0.00" min="0" max="1000000000" step="0.01">
            </div>
            <div class="transfer-input-group">
                <label for="transfer-note">备注 (可选)</label>
                                    <input type="text" id="transfer-note" placeholder="说点什么吧..." maxlength="20">
            </div>
            <div class="transfer-actions">
                <button id="transfer-cancel-btn">取消</button>
                <button id="transfer-confirm-btn">确认转账</button>
            </div>
        </div>
    </div>
    
    <div id="transfer-confirm-modal">
        <div class="transfer-confirm-content">
            <div class="transfer-confirm-title">收到一笔转账</div>
            <div class="transfer-confirm-info">
                <div class="transfer-confirm-amount">¥ 0.00</div>
                <div class="transfer-confirm-note">备注：</div>
            </div>
            <div class="transfer-confirm-actions">
                <button id="transfer-reject-btn">退回</button>
                <button id="transfer-accept-btn">确认收款</button>
                </div>
            </div>
        </div>



    <!-- 播放列表模态框 -->
    <div id="playlist-modal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 500px; max-height: 80vh; overflow-y: auto;">
            <div class="modal-header">
                <h3>播放列表</h3>
                <button class="close-btn" onclick="closePlaylistModal()">&times;</button>
            </div>

            <div class="playlist-content">
                <!-- 添加歌曲区域 -->
                <div class="add-song-section">
                    <h4>添加新歌曲</h4>
                    <div class="input-row">
                        <input type="text" id="song-title-input" placeholder="歌曲标题" class="song-input half-width">
                        <input type="text" id="song-artist-input" placeholder="艺术家" class="song-input half-width">
                    </div>
                    <div class="input-row">
                        <input type="text" id="song-url-input" placeholder="歌曲URL或选择本地文件" class="song-input half-width">
                        <div class="file-input-wrapper half-width">
                            <button onclick="document.getElementById('local-music-input').click()" class="upload-btn" style="width: 100%; padding: 8px;">
                                <i class="fas fa-file-audio"></i> 本地音乐
                            </button>
                        </div>
                    </div>
                    <div class="input-row">
                        <div class="file-input-wrapper half-width">
                            <input type="file" id="song-cover-input" accept="image/*,.jpg,.jpeg,.png,.gif,.webp" class="file-input" title="选择封面图片">
                            <span class="file-input-text">未选封面</span>
                        </div>
                        <div class="file-input-wrapper half-width">
                            <button onclick="document.getElementById('lyrics-file-input').click()" class="upload-btn" style="width: 100%; padding: 8px;">
                                <i class="fas fa-file-text"></i> 歌词文件
                            </button>
                        </div>
                    </div>
                    <div class="lyrics-input-section">
                        <textarea id="song-lyrics-input" placeholder="歌词（每行一句，可选）或上传歌词文件" class="lyrics-textarea"></textarea>
                        <div style="display: flex; gap: 8px; margin-top: 8px; font-size: 11px; color: #666;">
                            <span>支持格式：LRC、TXT、bin等歌词文件（iPhone用户可选择任意文件）</span>
                        </div>
                    </div>
                    <!-- 隐藏的文件输入 -->
                    <input type="file" id="local-music-input" accept="audio/*,.mp3,.m4a,.wav,.aac,.ogg,.flac" style="display: none;">
                    <input type="file" id="lyrics-file-input" style="display: none;">
                    <button onclick="addCustomSong()" class="add-song-btn">
                        添加歌曲
                    </button>
                </div>

                <!-- 当前播放列表 -->
                <div class="current-playlist">
                    <h4>当前播放列表</h4>
                    <div id="playlist-items" class="playlist-items">
                        <!-- 播放列表项将在这里动态生成 -->
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- 音乐播放模态框 -->
    <div id="music-modal" class="music-modal" style="display: none;">
        <div class="music-modal-content">
            <div class="music-modal-header">
                <button class="music-modal-close" onclick="closeMusicModal()">
                    <i class="fas fa-times"></i>
                </button>
                <div class="music-header-title">正在播放</div>
                <button class="music-view-toggle" onclick="toggleMusicView()" id="view-toggle-btn">
                    <i class="fas fa-list"></i>
                </button>
            </div>

            <div class="music-modal-body">
                <!-- 唱片机模式 -->
                <div id="vinyl-mode" class="music-view-mode">
                    <div class="vinyl-player">
                        <div class="vinyl-container">
                            <div class="vinyl-disc" id="vinyl-disc">
                                <div class="vinyl-grooves"></div>
                                <div class="vinyl-center"></div>
                                <div class="vinyl-label" onclick="triggerAlbumUpload()">
                                    <img id="album-cover" class="album-cover-upload" style="display: none;" />
                                    <div class="upload-overlay">
                                        <i class="fas fa-camera"></i><br>上传封面
                                    </div>
                                    <!-- 移除歌曲信息显示，保持空白 -->
                                </div>
                            </div>
                            <div class="tonearm" id="tonearm"></div>
                        </div>

                        <div class="song-info">
                            <div class="song-title" id="vinyl-song-title">选择歌曲</div>
                            <div class="song-artist" id="vinyl-artist-name">未知艺术家</div>
                        </div>

                        <div class="vinyl-lyrics">
                            <div class="lyrics-container">
                                <div class="lyric-line active" id="lyric-current">点击播放开始听歌</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 隐藏的文件上传输入 -->
                <input type="file" id="album-cover-input" accept="image/*,.jpg,.jpeg,.png,.gif,.webp" style="display: none;" onchange="handleAlbumUpload(event)">

                <!-- 完整歌词模式 -->
                <div id="lyrics-mode" class="music-view-mode" style="display: none;">
                    <div class="lyrics-mode">
                        <div class="lyrics-header">
                            <div class="song-title" id="lyrics-song-title">选择歌曲</div>
                            <div class="song-artist" id="lyrics-artist-name">未知艺术家</div>
                        </div>
                        <div class="full-lyrics-container">
                            <div class="full-lyrics" id="full-lyrics-display">
                                <div class="lyric-line active">♪ 点击播放开始听歌</div>
                                <div class="lyric-line">选择你喜欢的歌曲</div>
                                <div class="lyric-line">和角色一起享受音乐时光</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="music-modal-controls">
                <!-- 当前歌词显示 -->
                <div class="current-lyric-display">
                    <div class="current-lyric-text" id="current-lyric-text">♪ 点击播放开始听歌</div>
                </div>

                <div class="music-progress">
                    <div class="progress-bar">
                        <div class="progress-fill" id="modal-progress"></div>
                    </div>
                    <div class="time-display">
                        <span id="modal-current-time">0:00</span>
                        <span id="modal-total-time">0:00</span>
                    </div>
                </div>

                <div class="music-control-buttons">
                    <button class="control-btn shuffle" id="play-mode-btn" onclick="togglePlayMode()" title="顺序播放">
                        <i class="fas fa-list-ol"></i>
                    </button>
                    <button class="control-btn" onclick="previousTrack()" title="上一首">
                        <i class="fas fa-step-backward"></i>
                    </button>
                    <button class="control-btn play-pause-btn" id="modal-play-btn" onclick="togglePlayback()" title="播放/暂停">
                        <i class="fas fa-play"></i>
                    </button>
                    <button class="control-btn" onclick="nextTrack()" title="下一首">
                        <i class="fas fa-step-forward"></i>
                    </button>
                    <button class="control-btn playlist" id="playlist-btn" onclick="openPlaylistModal()" title="播放列表">
                        <i class="fas fa-music"></i>
                    </button>
                </div>

                <div class="listening-time">
                    <i class="fas fa-clock"></i>
                    <span id="listening-duration">已一起听 0 分钟</span>
                </div>
            </div>

            <!-- 关闭按钮 - 关机按钮样式 -->
            <button class="music-close-btn" onclick="closeMusicPlayer()" title="结束听歌">
                <i class="fas fa-power-off"></i>
            </button>


        </div>
    </div>



    <script>
        // 🔥【新增修复】定义一个Promise来确保数据完全加载后再执行后续操作
        let dataLoadedPromise;
        let resolveDataLoaded;

        function initializeDataLoadPromise() {
            dataLoadedPromise = new Promise(resolve => {
                resolveDataLoaded = resolve;
            });
        }

        // 🔥【完全修复】初始化Dexie数据库 - 解决版本升级死循环问题
        const db = new Dexie('PhoneChatDB');
        window.activeGlobalWorldbooks = []; // 用于存储当前激活的全局世界书ID

        // 🔥【新增】数据库重置功能
        async function resetDatabase() {
            try {
                console.log('🔄 开始重置数据库...');

                // 关闭数据库连接
                if (db.isOpen()) {
                    db.close();
                }

                // 删除数据库
                await db.delete();
                console.log('✅ 数据库已删除');

                // 重新打开数据库（会自动创建新的）
                await db.open();
                console.log('✅ 数据库已重新创建');

                return true;
            } catch (error) {
                console.error('❌ 重置数据库失败:', error);
                return false;
            }
        }

        // 🔥【新增】检查数据库健康状态
        async function checkDatabaseHealth() {
            try {
                await db.open();

                // 测试基本表访问
                const testTables = ['characters', 'chatMessages', 'apiSettings'];
                for (const tableName of testTables) {
                    await db[tableName].count();
                }

                console.log('✅ 数据库健康检查通过');
                return true;
            } catch (error) {
                console.error('❌ 数据库健康检查失败:', error);
                return false;
            }
        }


        // 🔥【最终版本19】统一的数据库结构定义 - 包含心声和论坛系统
        db.version(19).stores({
            // --- 保留所有旧的表结构 ---
            // 基础数据表
            characters: '&id, name, groupId',
            contacts: '++id, characterId',
            chatMessages: '&id, characterId, timestamp',

            // 用户面具系统
            personas: '&id, name',

            // 表情包系统
            customEmojis: '&id, name, category',
            recentEmojis: '&id, lastUsed',

            // 世界书系统
            worldbooks: '&id, name, isGlobal',
            worldbookEntries: '&id, worldbookId, keyword',

            // 群聊系统
            characterGroups: '&id, name, order',
            groupChats: '&id, name',
            groupChatMessages: '&id, groupId, timestamp',
            groupChatMembers: '&id, groupId, characterId',

            // 动态系统
            moments: '&id, authorId, timestamp',
            momentLikes: '[momentId+authorId], momentId, authorId',
            momentComments: '&id, momentId, authorId, timestamp',

            // 记忆系统
            workingMemory: '&id, characterId, timestamp, content, context',
            episodicMemory: '&id, characterId, date, summary, timestamp, context',
            episodicMemories: '&id, characterId, fact, importance, timestamp, category',
            memorySummaries: '&id, characterId, date, summary, timestamp, context',
            memoryEvents: '&id, characterIds, eventType, timestamp, context, eventData, importance',
            coreMemory: '&id, characterId, category, content, timestamp',
            coreMemories: '&id, characterId, fact, importance, timestamp, type, category',
            crossAppTimeline: '&id, characterId, appType, action, timestamp, context, messageId',

            // 拉黑和好友系统
            blacklist: '&id, blockerId, blockedId, timestamp, reason',
            blockedCharacters: '&id, characterId, blockedBy, timestamp',
            friendRequests: '&id, fromId, toId, timestamp, status, type, message',
            characterStatus: '&id, characterId, status, activity, location, lastUpdate',

            // 日记系统
            characterDiaries: '&id, characterId, date, content, timestamp, weather',

            // 线下模式系统
            offlineHistoryRecords: '&id, characterId, timestamp, summary, messages',
            offlineUISettings: '&id, characterId, settings, timestamp',
            offlinePresets: '&id, name, content, timestamp',

            // 音乐播放器系统
            musicPlaylist: '&id, title, artist, album, duration, url, coverImage, lyrics, addedTime',
            musicCovers: '&id, songId, imageData, timestamp',

            // 设置和配置
            apiSettings: '&id',
            globalSettings: '&id',
            wallpapers: '&id, name',
            appIcons: '&id, appId',
            chatSettings: '&id, chatId',

            // 纪念日系统
            anniversaries: '&id, name, date, type, yearly',

            // 心声系统
            innerThoughts: '&id, messageId, characterId, content, timestamp',

            // --- 🔥【新增】论坛功能相关表 ---
            forums: '++id, name', // 论坛存档表，name不设为唯一索引，在应用层面处理重复检查
            forumPosts: '++id, forumId, timestamp', // 帖子表
            forumReplies: '++id, postId, timestamp', // 回复表
            forumFavorites: '++id, [userId+postId]' // 收藏夹，确保用户对一个帖子只能收藏一次
        }).upgrade(async tx => {
            console.log('🔧 升级到版本19：添加心声和论坛系统');

            // 🔥【安全迁移】检查并保护现有用户数据
            try {
                // 检查是否有现有数据需要保护
                const existingCharacters = await tx.characters.count();
                const existingMessages = await tx.chatMessages.count();

                if (existingCharacters > 0 || existingMessages > 0) {
                    console.log(`✅ 检测到现有用户数据：${existingCharacters}个角色，${existingMessages}条消息`);
                    console.log('✅ 心声和论坛系统表已安全添加，现有数据完全保留');
                } else {
                    console.log('✅ 新用户安装，心声和论坛系统表已创建');
                }

                // 新表会自动创建：innerThoughts, forums, forumPosts, forumReplies, forumFavorites

            } catch (error) {
                console.error('⚠️ 数据迁移检查失败，但不影响功能:', error);
            }
        });

        // 全局变量
        let characters = [];
        let contacts = [];
        let currentChatCharacter = null;
        let chatMessages = {};
        let selectedMessageId = null;
        let pinnedConversations = []; // 🔥【新增】置顶对话列表
        let personas = []; // 用户面具列表
        let currentPersona = null; // 当前使用的面具
        let editingPersona = null; // 正在编辑的面具
        let isMultiSelectMode = false; // 多选模式状态
        let selectedCharacters = []; // 选中的角色ID列表
        let currentEditingCharacterId = null; // 当前正在编辑的角色ID
        let groupChats = []; // 群聊列表
        let selectedGroupMembers = []; // 群聊成员选择
        let currentWorldbookTab = 'global';
        let currentCharacterCategory = null; // 跟踪当前选择的角色分类
        
        // 角色分组相关变量
        let characterGroups = []; // 角色分组列表
        let isGroupManageMode = false; // 分组管理模式
        let selectedGroupId = null; // 当前选中的分组ID
        
        // 自定义表情包相关变量
        let customEmojis = []; // 用户上传的表情包
        let recentEmojis = []; // 最近使用的表情包
        let currentEmojiTab = 'recent'; // 当前表情包标签页
        
        // 消息多选删除相关变量
        let isMessageSelectionMode = false; // 消息选择模式
        let selectedMessages = new Set(); // 选中的消息ID集合
        
        // 消息列表多选相关变量
        let isMessageListMultiSelectMode = false; // 消息列表多选模式状态
        let selectedConversations = []; // 选中的对话框ID列表
        
        // 动态评论对话回合次追踪
        let commentConversationRounds = new Map(); // 格式: "momentId-characterId" => 回合次数
        
        // 🔥【新增】拉黑系统相关变量已在后面声明
        
        let apiSettings = {
            type: 'openai',
            base: 'https://api.openai.com/v1',
            endpoint: '/chat/completions',
            key: '',
            model: 'gpt-3.5-turbo',
            temperature: 0.70
        };
        
        // 注意：记忆设置现在已改为每个聊天窗口独立的设置，存储在各自的聊天设置中
        
        let chatSettings = {
            themeColor: '#007AFF',
            theirBubbleColor: '#f0f0f0',
            myBubbleColor: '#007AFF',
            bubbleOpacity: 1,
            timestampEnabled: true,
            timestampPosition: 'center'
        };
        

        let selectedAppIcon = null;
        let selectedWallpaper = null;
        let colorPickerContext = null;
        let customIconImage = null;
        
        // 加载全局世界书设置
        async function loadGlobalWorldbookSettings() {
            try {
                const globalSettings = await db.globalSettings.get('main');
                if (globalSettings && globalSettings.activeGlobalWorldbooks) {
                    // 确保使用window.activeGlobalWorldbooks以在全局范围内可用
                    window.activeGlobalWorldbooks = globalSettings.activeGlobalWorldbooks;
                } else {
                    window.activeGlobalWorldbooks = [];
                    // 如果没有找到设置，创建一个初始设置
                    await db.globalSettings.put({
                        id: 'main',
                        activeGlobalWorldbooks: []
                    });
                }
            } catch (error) {
                console.error('加载全局世界书设置失败:', error);
                window.activeGlobalWorldbooks = [];
            }
        }

        // 初始化应用
        document.addEventListener('DOMContentLoaded', async function() {
            initializeDataLoadPromise(); // 🔥【新增修复】初始化数据加载Promise
            updateTime();

            // 🔥【新增】增强Safari长按禁用
            if (navigator.userAgent.includes('Safari') && navigator.userAgent.includes('Mobile')) {
                // 禁用Safari的长按上下文菜单
                document.addEventListener('contextmenu', function(e) {
                    // 只在消息气泡和相关元素上禁用
                    if (e.target.closest('.message-bubble, .offline-message-content, .message-item, .contact-item')) {
                        e.preventDefault();
                        return false;
                    }
                }, { passive: false });

                // 禁用Safari的选择菜单
                document.addEventListener('selectstart', function(e) {
                    if (e.target.closest('.message-bubble, .offline-message-content, .message-item, .contact-item')) {
                        e.preventDefault();
                        return false;
                    }
                }, { passive: false });

                // 禁用Safari的拖拽
                document.addEventListener('dragstart', function(e) {
                    if (e.target.closest('.message-bubble, .offline-message-content, .message-item, .contact-item')) {
                        e.preventDefault();
                        return false;
                    }
                }, { passive: false });

                console.log('✅ Safari长按禁用已启用');
            }

            try {

            // 🔥【新增】初始化窗口ID，确保线下模式数据隔离
            initializeWindowId();

            // 🔥【新增】数据库健康检查
            console.log('🔍 开始数据库健康检查...');
            const isHealthy = await checkDatabaseHealth();
            if (!isHealthy) {
                console.warn('⚠️ 数据库健康检查失败，尝试重置...');
                const resetSuccess = await resetDatabase();
                if (!resetSuccess) {
                    throw new Error('数据库重置失败，请手动清除浏览器数据');
                }
                console.log('✅ 数据库已重置，继续初始化...');
            } else {
                console.log('✅ 数据库健康检查通过');
            }

            // 🔥【已移除】迁移旧的线下预设数据 - 现在由数据库版本15自动处理

            // 🔥【架构修复】按正确顺序加载数据
            console.log('🔄 开始按顺序加载数据...');

            // 第一步：加载基础数据
            await Promise.all([
                loadCharacterGroups(), // 先加载分组
                loadCharacters(), // 加载角色
                loadChatMessages(),
                loadMemoryConfig(), // 加载记忆配置
                loadChatSettings(),
                loadApiSettings(),
                loadCustomEmojis(),
                loadGlobalWorldbookSettings(), // 确保加载全局世界书设置
                initGlobalMemoryDB(), // 🔥【新增】初始化全局记忆数据库
                loadCustomAppIcons() // 加载自定义应用图标
            ]);

            // 🔥【新增】清理已保存的拉黑系统消息
            console.log('🧹 清理拉黑系统消息...');
            cleanupBlockedSystemMessages();

            // 第二步：从角色列表生成联系人（必须在角色加载完成后）
            console.log('🔄 从角色列表生成联系人...');
            await loadContacts();

            // 🔥【新增】加载置顶数据
            loadPinnedConversations();
            
            // 加载外观设置
            loadPhoneBorderSetting();
            loadScreenSize();
            loadFontSizeSettings();
            loadStatusIconSetting();
            
            // 加载动态图片设置
            await loadMomentsImages();
            
            // 加载其他设置（包括需要数据库的壁纸设置）
            await loadWallpaper();
            await loadAppIcons();
            loadSavedTheme();
            await loadWorldbooks();

            await loadPersonas();
            await loadGroupChats();

            // 🔥【新增】检查localStorage使用情况
            checkLocalStorageUsage();

            // 初始化记忆查看器
            await initMemoryViewer();

            // 初始化纪念日系统
            await loadAnniversaryList();

            // 初始化小组件
            initializeWidgets();

            // 🔥【新增】初始化论坛应用
            initializeForumApp();
            
            // 渲染界面 - 添加数据验证
            try {
                if (characters && contacts && chatMessages) {
            renderMessageList();
            renderContactList();
            renderCharacterList();
            renderPersonaList();
                } else {
                    console.warn('数据未完全加载，推迟界面渲染');
                    // 延迟重试渲染
                    setTimeout(() => {
                        renderMessageList();
                        renderContactList();
                        renderCharacterList();
                        renderPersonaList();
                    }, 500);
                }
            } catch (renderError) {
                console.error('界面渲染失败:', renderError);
                // 尝试重新初始化空数据
                if (!chatMessages) chatMessages = {};
                if (!contacts) contacts = [];
                if (!characters) characters = [];
                renderMessageList();
                renderContactList();
                renderCharacterList();
            }
            
            // 初始化时设置正确的按钮显示状态 - 延迟执行确保DOM加载完成
            setTimeout(async () => {
                switchChatTab('message-list');
                // 确保app标题有chat-mode类和正确内容
                const appTitle = document.querySelector('#chat-screen .app-title');
                if (appTitle) {
                    appTitle.classList.add('chat-mode');
                    appTitle.textContent = '💬';
                }

                // 初始化UI事件不依赖于currentChatCharacter
                initChatSettingsUIEvents();

                // 🔥【修复】强制应用气泡样式，即使没有当前聊天角色
                applyBubbleStyle();

                // 如果已经有聊天角色，才初始化设置和世界书
                if (currentChatCharacter) {
                initializeChatSettings(); // 初始化聊天设置界面
                updateWorldbookMountDisplay(); // 更新世界书挂载显示
                } else {
                    // 应用初始化完成，等待选择聊天角色
                }

                // 🔥【修复】在应用初始化时启动全局后台互动系统
                await initGlobalBackgroundInteractionSystem();
            }, 100);
            
            // 温度滑块显示
            const temperatureSlider = document.getElementById('temperature-slider');
            if (temperatureSlider) {
                temperatureSlider.addEventListener('input', function() {
                document.getElementById('temperature-value').textContent = parseFloat(this.value).toFixed(2);
            });
            }
            
            // 初始化API设置界面
            initializeApiSettings();

            // 透明度滑块显示
            document.getElementById('opacity-slider').addEventListener('input', function() {
                document.getElementById('opacity-value').textContent = Math.round(this.value * 100) + '%';
            });

            // 文件选择框事件监听
            const songCoverInput = document.getElementById('song-cover-input');
            const fileInputText = document.querySelector('.file-input-text');
            if (songCoverInput && fileInputText) {
                songCoverInput.addEventListener('change', function(e) {
                    if (e.target.files && e.target.files[0]) {
                        fileInputText.textContent = e.target.files[0].name;
                    } else {
                        fileInputText.textContent = '未选封面';
                    }
                });
            }
            
            // 按Enter键发送消息
            document.getElementById('api-chat-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault(); // 防止换行
                    sendApiMessage();
                }
            });

            // @群成员功能相关变量
            let mentionDropdownVisible = false;
            let mentionStartPos = -1;
            let selectedMentionIndex = -1;
            let currentMentionQuery = '';

            // 监听输入框内容变化，处理@群成员功能
            document.getElementById('api-chat-input').addEventListener('input', function(e) {
                handleMentionInput(e);
            });

            // 监听键盘事件，处理@群成员选择
            document.getElementById('api-chat-input').addEventListener('keydown', function(e) {
                if (mentionDropdownVisible) {
                    handleMentionKeydown(e);
                }
            });

            // 点击其他地方时隐藏@群成员下拉框
            document.addEventListener('click', function(e) {
                const dropdown = document.getElementById('mention-dropdown');
                const input = document.getElementById('api-chat-input');
                if (mentionDropdownVisible && !dropdown.contains(e.target) && e.target !== input) {
                    hideMentionDropdown();
                }
            });
            

            
            // 初始化头像上传功能
            initializeAvatarUpload();

            // 初始化表情包上传功能
            initializeEmojiUpload();

            // 初始化应用图标上传功能
            initializeIconUpload();
            
            // 确保工具面板初始隐藏
            const toolsPanel = document.getElementById('tools-panel');
            if (toolsPanel) {
                toolsPanel.style.display = 'none';
            }
            
            // 初始化消息选择模式状态
            isMessageSelectionMode = false;
            selectedMessages.clear();
            
            // 图片上传
            document.getElementById('image-upload').addEventListener('change', function(e) {
                if (e.target.files && e.target.files[0]) {
                    const file = e.target.files[0];
                    
                    // 检查文件类型，GIF格式不被Gemini API支持
                    if (file.type === 'image/gif') {
                        alert('抱歉，Gemini API 不支持 GIF 格式的图片。\n\n请选择其他格式的图片，如：\n• JPEG\n• PNG\n• WEBP');
                        // 清空文件选择器
                        e.target.value = '';
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        // 🔥【修复】直接发送图片消息，就像正常的图片发送一样
                        sendImageMessage(event.target.result);
                    };
                    reader.readAsDataURL(file);
                }
                
                // 清空文件选择器，允许重复选择同一文件
                e.target.value = '';
            });
            
            // 自定义壁纸上传
            document.getElementById('custom-wallpaper-upload').addEventListener('change', function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        selectedWallpaper = event.target.result;
                        
                        // 更新预览容器
                        const previewContainer = document.getElementById('wallpaper-preview-container');
                        if (previewContainer) {
                            previewContainer.innerHTML = `<img src="${selectedWallpaper}" class="wallpaper-preview-image" alt="壁纸预览">`;
                        }
                        
                        // 不在这里立即应用到主界面，等用户点击应用时再应用
                    };
                    reader.readAsDataURL(e.target.files[0]);
                }
            });
            
            // 自定义图标上传
            document.getElementById('custom-icon-upload').addEventListener('change', function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        customIconImage = event.target.result;
                        // 更新预览
                        const previews = document.querySelectorAll('.icon-preview');
                        previews.forEach(preview => {
                            preview.style.backgroundImage = `url(${customIconImage})`;
                            preview.innerHTML = ''; // 移除图标
                        });
                    };
                    reader.readAsDataURL(e.target.files[0]);
                }
            });
            
            setInterval(updateTime, 1000);
            initBatteryManager();
            
            // 🔥【新增修复】在所有数据加载完成后，发送"绿灯"信号
            resolveDataLoaded();
            console.log('✅ 所有初始数据加载完成，信号已发送。');

            // 🔥【新增】初始化全局动态发布系统
            setTimeout(async () => {
                try {
                    await initGlobalMomentsSystem();
                    console.log('✅ 全局动态发布系统初始化完成');
                } catch (error) {
                    console.error('❌ 全局动态发布系统初始化失败:', error);
                }
            }, 3000); // 延迟3秒确保数据完全加载

            // 🔥【新增修复】在所有数据加载后，尝试恢复上次打开的聊天
            const lastChatId = sessionStorage.getItem('currentChatCharacterId');
            if (lastChatId) {
                console.log('🔄 正在恢复上次打开的聊天:', lastChatId);
                // 等待数据加载的"绿灯"信号
                dataLoadedPromise.then(() => {
                    const character = characters.find(c => c.id === lastChatId);
                    const group = groupChats.find(g => g.id === lastChatId);
                    const chatEntity = character || group;

                    if (chatEntity) {
                        // 使用微小的延迟确保UI渲染完成
                        setTimeout(() => {
                            startChat(chatEntity);
                        }, 100);
                    } else {
                        console.warn('无法找到上次聊天的角色/群组:', lastChatId);
                        sessionStorage.removeItem('currentChatCharacterId');
                    }
                });
            }

            } catch (error) {
                console.error('应用初始化失败:', error);
                console.error('错误详情:', error.stack);

                // 显示详细错误信息
                const errorMsg = `应用初始化失败: ${error.message}\n\n可能的解决方案：\n1. 刷新页面重试\n2. 清除浏览器缓存\n3. 进入设置→紧急恢复\n\n错误类型: ${error.name}`;

                // 如果是数据库错误，尝试重置
                if (error.name === 'DataError' || error.name === 'InvalidStateError' || error.name === 'DexieError') {
                    console.log('检测到数据库错误，尝试重置数据库...');
                    if (confirm('检测到数据库错误，是否重置数据库？\n注意：这将清除所有本地数据。')) {
                        try {
                            await resetDatabase();
                            location.reload(); // 重置后刷新页面
                        } catch (resetError) {
                            console.error('重置数据库失败:', resetError);
                            alert('重置数据库失败，请手动清除浏览器数据后重试。');
                        }
                    }
                } else {
                    alert(errorMsg);

                    // 尝试显示紧急恢复界面
                    try {
                        // 确保基本的DOM结构存在
                        if (!characters) characters = [];
                        if (!contacts) contacts = [];
                        if (!chatMessages) chatMessages = {};

                        // 尝试显示设置页面
                        showApp('settings-screen');

                        // 延迟显示恢复模态框
                        setTimeout(() => {
                            try {
                                const recoveryBtn = document.querySelector('[onclick="showRecoveryModal()"]');
                                if (recoveryBtn) {
                                    recoveryBtn.click();
                                }
                            } catch (e) {
                                console.error('无法自动打开恢复界面:', e);
                            }
                        }, 1000);
                    } catch (e) {
                        console.error('无法显示紧急恢复界面:', e);
                    }
                }
            }
        });
        
        // 显示/隐藏应用
        function showApp(appId) {
            if (event) event.preventDefault();
            
            // 隐藏所有app界面
            const allApps = document.querySelectorAll('.app-screen');
            allApps.forEach(app => {
                app.style.display = 'none';
            });
            
            // 隐藏主屏幕组件
            const clockContainer = document.getElementById('clock-container');
            const homeGrid = document.getElementById('home-grid');
            const dockBar = document.getElementById('dock-bar');
            if (clockContainer) clockContainer.style.display = 'none';
            if (homeGrid) homeGrid.style.display = 'none';
            if (dockBar) dockBar.style.display = 'none';
            
            // 显示目标界面
            document.getElementById(appId).style.display = 'flex';
            
            // 如果是聊天界面，刷新消息列表
            if (appId === 'chat-screen') {
                renderMessageList();
            }

            // 如果是纪念日界面，加载纪念日列表
            if (appId === 'anniversary-screen') {
                loadAnniversaryList();
            }

            // 如果是API设置界面，初始化设置
            if (appId === 'api-settings-screen') {
                // 延迟一点时间确保DOM已渲染
                setTimeout(() => {
                    initializeApiSettings();
                }, 100);
            }
        }
        

        
        // 隐藏角色创建表单，返回到chat界面的通讯录
        function hideCharacterForm() {
            // 在隐藏表单时清空表单数据
            clearCharacterForm();
            
            hideApp('character-form-screen');
            showApp('chat-screen');
            switchChatTab('contact-list');
            // 手动触发标签切换的样式
            const chatTabs = document.querySelectorAll('.chat-tab');
            chatTabs.forEach(tab => {
                if (tab && tab.classList) {
                    tab.classList.remove('active');
                }
            });
            // 安全地添加active类到第二个标签（通讯录）
            if (chatTabs.length > 1 && chatTabs[1] && chatTabs[1].classList) {
                chatTabs[1].classList.add('active');
            }
        }
        
        function hideApp(appId) {
            document.getElementById(appId).style.display = 'none';
            
            // 检查是否所有应用都已隐藏，如果是，显示主屏幕组件
            const allApps = document.querySelectorAll('.app-screen');
            const hasVisibleApp = Array.from(allApps).some(app => 
                app.style.display === 'flex' || app.style.display === 'block'
            );
            
            if (!hasVisibleApp) {
                // 显示主屏幕组件
                const clockContainer = document.getElementById('clock-container');
                const homeGrid = document.getElementById('home-grid');
                const dockBar = document.getElementById('dock-bar');
                if (clockContainer) clockContainer.style.display = 'block';
                if (homeGrid) homeGrid.style.display = 'grid';
                if (dockBar) dockBar.style.display = 'block';
            }
        }
        
        // 显示/隐藏模态框
        function showModal(modalId) {
            document.getElementById(modalId).style.display = 'flex';
            

        }
        
        function hideModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // 纪念日功能
        let anniversaries = [];
        let editingAnniversaryId = null;

        // 显示纪念日表单
        function showAnniversaryForm(anniversaryId = null) {
            editingAnniversaryId = anniversaryId;
            const modal = document.getElementById('anniversary-form-modal');
            const title = document.getElementById('anniversary-form-title');

            if (anniversaryId) {
                // 编辑模式
                title.textContent = '编辑纪念日';
                const anniversary = anniversaries.find(a => a.id === anniversaryId);
                if (anniversary) {
                    document.getElementById('anniversary-name').value = anniversary.name;
                    document.getElementById('anniversary-date').value = anniversary.date;
                    document.getElementById('anniversary-type').value = anniversary.type;
                    document.getElementById('anniversary-description').value = anniversary.description || '';
                    document.getElementById('anniversary-yearly').checked = anniversary.yearly;
                    document.getElementById('anniversary-notify').checked = anniversary.notify;
                }
            } else {
                // 新建模式
                title.textContent = '添加纪念日';
                clearAnniversaryForm();
            }

            modal.style.display = 'flex';
        }

        // 关闭纪念日表单
        function closeAnniversaryForm() {
            document.getElementById('anniversary-form-modal').style.display = 'none';
            clearAnniversaryForm();
            editingAnniversaryId = null;
        }

        // 清空纪念日表单
        function clearAnniversaryForm() {
            document.getElementById('anniversary-name').value = '';
            document.getElementById('anniversary-date').value = '';
            document.getElementById('anniversary-type').value = 'birthday';
            document.getElementById('anniversary-description').value = '';
            document.getElementById('anniversary-yearly').checked = true;
            document.getElementById('anniversary-notify').checked = false;
        }

        // 保存纪念日
        async function saveAnniversary() {
            const name = document.getElementById('anniversary-name').value.trim();
            const date = document.getElementById('anniversary-date').value;
            const type = document.getElementById('anniversary-type').value;
            const description = document.getElementById('anniversary-description').value.trim();
            const yearly = document.getElementById('anniversary-yearly').checked;
            const notify = document.getElementById('anniversary-notify').checked;

            if (!name || !date) {
                showToast('请填写纪念日名称和日期', 'error');
                return;
            }

            const anniversaryData = {
                id: editingAnniversaryId || Date.now().toString(),
                name,
                date,
                type,
                description,
                yearly,
                notify,
                createdAt: editingAnniversaryId ? anniversaries.find(a => a.id === editingAnniversaryId).createdAt : new Date().toISOString()
            };

            try {
                if (editingAnniversaryId) {
                    // 更新现有纪念日
                    await db.anniversaries.put(anniversaryData);
                    const index = anniversaries.findIndex(a => a.id === editingAnniversaryId);
                    if (index !== -1) {
                        anniversaries[index] = anniversaryData;
                    }
                    showToast('纪念日已更新', 'success');
                } else {
                    // 添加新纪念日
                    await db.anniversaries.add(anniversaryData);
                    anniversaries.push(anniversaryData);
                    showToast('纪念日已添加', 'success');
                }

                closeAnniversaryForm();
                loadAnniversaryList();
            } catch (error) {
                console.error('保存纪念日失败:', error);
                showToast('保存失败，请重试', 'error');
            }
        }

        // 加载纪念日列表
        async function loadAnniversaryList() {
            try {
                // 确保数据库已初始化
                if (!db || !db.anniversaries) {
                    console.warn('数据库未初始化，跳过纪念日加载');
                    anniversaries = [];
                    renderAnniversaryList();
                    return;
                }

                anniversaries = await db.anniversaries.orderBy('date').toArray();
                renderAnniversaryList();
            } catch (error) {
                console.error('加载纪念日列表失败:', error);
                // 不显示错误提示，避免初始化时的干扰
                anniversaries = [];
                renderAnniversaryList();
            }
        }

        // 渲染纪念日列表
        function renderAnniversaryList() {
            const container = document.getElementById('anniversary-list');

            if (anniversaries.length === 0) {
                container.innerHTML = `
                    <div class="anniversary-empty-state">
                        <i class="fas fa-heart"></i>
                        <p>还没有纪念日</p>
                        <p>点击右上角 + 添加重要的日子</p>
                    </div>
                `;
                return;
            }

            const now = new Date();
            const currentYear = now.getFullYear();

            container.innerHTML = anniversaries.map(anniversary => {
                const anniversaryDate = new Date(anniversary.date);
                let nextDate = new Date(currentYear, anniversaryDate.getMonth(), anniversaryDate.getDate());

                // 如果今年的日期已过，计算明年的日期
                if (nextDate < now) {
                    nextDate.setFullYear(currentYear + 1);
                }

                const daysUntil = Math.ceil((nextDate - now) / (1000 * 60 * 60 * 24));
                const countdownText = daysUntil === 0 ? '今天！' :
                                    daysUntil === 1 ? '明天' :
                                    `还有 ${daysUntil} 天`;

                return `
                    <div class="anniversary-item" onclick="showAnniversaryForm('${anniversary.id}')">
                        <div class="anniversary-item-header">
                            <div>
                                <div class="anniversary-item-name">${anniversary.name}</div>
                                <div class="anniversary-item-date">${formatDate(anniversary.date)}</div>
                            </div>
                            <div class="anniversary-item-type ${anniversary.type}">${getTypeText(anniversary.type)}</div>
                        </div>
                        <div class="anniversary-item-countdown">${countdownText}</div>
                        ${anniversary.description ? `<div class="anniversary-item-description">${anniversary.description}</div>` : ''}
                        <div class="anniversary-item-actions" onclick="event.stopPropagation()">
                            <button class="anniversary-action-btn anniversary-edit-btn" onclick="showAnniversaryForm('${anniversary.id}')">
                                编辑
                            </button>
                            <button class="anniversary-action-btn anniversary-delete-btn" onclick="deleteAnniversary('${anniversary.id}')">
                                删除
                            </button>
                        </div>
                    </div>
                `;
            }).join('');

            // 更新纪念日小组件
            const savedAnniversary = localStorage.getItem('anniversaryWidgetSelection');
            if (savedAnniversary) {
                const anniversary = anniversaries.find(a => a.id === savedAnniversary);
                if (anniversary) {
                    displayAnniversaryWidget(anniversary);
                } else {
                    // 如果选中的纪念日被删除了，清除小组件
                    clearAnniversaryWidget();
                }
            }
        }

        // 删除纪念日
        async function deleteAnniversary(anniversaryId) {
            if (confirm('确定要删除这个纪念日吗？')) {
                try {
                    await db.anniversaries.delete(anniversaryId);
                    anniversaries = anniversaries.filter(a => a.id !== anniversaryId);
                    renderAnniversaryList();
                    showToast('纪念日已删除', 'success');
                } catch (error) {
                    console.error('删除纪念日失败:', error);
                    showToast('删除失败，请重试', 'error');
                }
            }
        }

        // 格式化日期
        function formatDate(dateString) {
            const date = new Date(dateString);
            return `${date.getMonth() + 1}月${date.getDate()}日`;
        }

        // 获取类型文本
        function getTypeText(type) {
            const typeMap = {
                birthday: '生日',
                anniversary: '纪念日',
                holiday: '节日',
                other: '其他'
            };
            return typeMap[type] || '其他';
        }

        // 显示新短信表单（预留功能）
        function showNewMessageForm() {
            showToast('短信功能正在开发中', 'info');
        }

        // 图片小组件功能
        function showPhotoWidgetOptions() {
            document.getElementById('photo-widget-modal').style.display = 'flex';
        }

        function closePhotoWidgetModal() {
            document.getElementById('photo-widget-modal').style.display = 'none';
        }

        function handlePhotoWidgetUpload(input) {
            if (input.files && input.files[0]) {
                const file = input.files[0];
                const reader = new FileReader();

                reader.onload = function(e) {
                    const imageData = e.target.result;

                    // 保存到localStorage
                    localStorage.setItem('photoWidgetImage', imageData);

                    // 更新显示
                    updatePhotoWidget(imageData);

                    showToast('图片已设置', 'success');
                    closePhotoWidgetModal();
                };

                reader.readAsDataURL(file);
            }
        }

        function updatePhotoWidget(imageData) {
            const placeholder = document.getElementById('photo-placeholder');
            const image = document.getElementById('photo-widget-image');

            if (imageData) {
                placeholder.style.display = 'none';
                image.src = imageData;
                image.style.display = 'block';

                // 确保图片正确缩放
                image.onload = function() {
                    // 图片已加载，CSS会自动处理缩放
                };
            } else {
                placeholder.style.display = 'block';
                image.style.display = 'none';
            }
        }

        function clearPhotoWidget() {
            localStorage.removeItem('photoWidgetImage');
            updatePhotoWidget(null);
            showToast('图片已清除', 'success');
            closePhotoWidgetModal();
        }

        // 纪念日小组件功能
        function showAnniversaryWidgetOptions() {
            // 更新选择列表
            updateAnniversaryWidgetSelect();
            document.getElementById('anniversary-widget-modal').style.display = 'flex';
        }

        function closeAnniversaryWidgetModal() {
            document.getElementById('anniversary-widget-modal').style.display = 'none';
        }

        function updateAnniversaryWidgetSelect() {
            const select = document.getElementById('widget-anniversary-select');
            const currentSelection = localStorage.getItem('anniversaryWidgetSelection');

            // 清空选项
            select.innerHTML = '<option value="">请选择纪念日</option>';

            // 添加纪念日选项
            anniversaries.forEach(anniversary => {
                const option = document.createElement('option');
                option.value = anniversary.id;
                option.textContent = anniversary.name;
                if (anniversary.id === currentSelection) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
        }

        function updateAnniversaryWidget() {
            const select = document.getElementById('widget-anniversary-select');
            const selectedId = select.value;

            if (selectedId) {
                const anniversary = anniversaries.find(a => a.id === selectedId);
                if (anniversary) {
                    localStorage.setItem('anniversaryWidgetSelection', selectedId);
                    displayAnniversaryWidget(anniversary);
                    showToast('纪念日小组件已更新', 'success');
                }
            } else {
                clearAnniversaryWidget();
            }
        }

        function displayAnniversaryWidget(anniversary) {
            const placeholder = document.getElementById('anniversary-placeholder');
            const display = document.getElementById('anniversary-display');
            const nameEl = document.getElementById('widget-anniversary-name');
            const countdownEl = document.getElementById('widget-anniversary-countdown');
            const dateEl = document.getElementById('widget-anniversary-date');

            // 计算倒计时
            const now = new Date();
            const currentYear = now.getFullYear();
            const anniversaryDate = new Date(anniversary.date);
            let nextDate = new Date(currentYear, anniversaryDate.getMonth(), anniversaryDate.getDate());

            if (nextDate < now) {
                nextDate.setFullYear(currentYear + 1);
            }

            const daysUntil = Math.ceil((nextDate - now) / (1000 * 60 * 60 * 24));
            const countdownText = daysUntil === 0 ? '今天！' :
                                daysUntil === 1 ? '明天' :
                                `${daysUntil}天`;

            // 更新显示
            nameEl.textContent = anniversary.name;
            countdownEl.textContent = countdownText;
            dateEl.textContent = formatDate(anniversary.date);

            placeholder.style.display = 'none';
            display.style.display = 'block';
        }

        function clearAnniversaryWidget() {
            localStorage.removeItem('anniversaryWidgetSelection');
            const placeholder = document.getElementById('anniversary-placeholder');
            const display = document.getElementById('anniversary-display');

            placeholder.style.display = 'block';
            display.style.display = 'none';

            showToast('纪念日小组件已清除', 'success');
        }

        // 初始化小组件
        function initializeWidgets() {
            try {
                // 初始化图片小组件
                const savedImage = localStorage.getItem('photoWidgetImage');
                if (savedImage) {
                    updatePhotoWidget(savedImage);
                }

                // 初始化纪念日小组件
                const savedAnniversary = localStorage.getItem('anniversaryWidgetSelection');
                if (savedAnniversary && anniversaries && anniversaries.length > 0) {
                    const anniversary = anniversaries.find(a => a.id === savedAnniversary);
                    if (anniversary) {
                        displayAnniversaryWidget(anniversary);
                    }
                }
            } catch (error) {
                console.error('初始化小组件失败:', error);
            }
        }

        // 切换照片文字显示
        function togglePhotoText(container, description) {
            const overlay = container.querySelector('.photo-text-overlay');
            const sparkles = container.querySelector('.sparkle-container');
            const badge = container.querySelector('.photo-badge');
            
            if (overlay.style.display === 'none') {
                // 显示文字，隐藏星星和标志
                overlay.style.display = 'flex';
                sparkles.style.opacity = '0';
                badge.style.opacity = '0.3';
            } else {
                // 隐藏文字，显示星星和标志
                overlay.style.display = 'none';
                sparkles.style.opacity = '1';
                badge.style.opacity = '1';
            }
        }

        // 显示用户照片描述
        function showUserPhotoDescription(description) {
            const modalHtml = `
                <div id="photo-description-modal" class="modal" style="display: flex; z-index: 10000; background: rgba(0, 0, 0, 0.8);">
                    <div class="magical-photo-modal">
                        <div class="photo-modal-bg"></div>
                        <div class="photo-modal-content">
                            <div class="photo-modal-header">
                                <i class="fas fa-camera photo-modal-icon"></i>
                                <div class="photo-modal-title">照片内容</div>
                            </div>
                            <div class="photo-modal-body">
                                <div class="photo-description-text">${description}</div>
                            </div>
                            <div class="photo-modal-footer">
                                <button class="photo-modal-btn" id="photo-description-close">确定</button>
                            </div>
                        </div>
                        <div class="modal-sparkles">
                            <div class="modal-sparkle modal-sparkle-1">✨</div>
                            <div class="modal-sparkle modal-sparkle-2">⭐</div>
                            <div class="modal-sparkle modal-sparkle-3">✨</div>
                            <div class="modal-sparkle modal-sparkle-4">⭐</div>
                            <div class="modal-sparkle modal-sparkle-5">💫</div>
                            <div class="modal-sparkle modal-sparkle-6">✨</div>
                            <div class="modal-sparkle modal-sparkle-7">⭐</div>
                            <div class="modal-sparkle modal-sparkle-8">💫</div>
                        </div>
                    </div>
                </div>
            `;
            
            // 添加到页面
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            
            const modal = document.getElementById('photo-description-modal');
            const closeBtn = document.getElementById('photo-description-close');
            
            // 关闭按钮事件
            closeBtn.onclick = () => {
                modal.remove();
            };
            
            // 点击背景关闭
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            };
        }

        // 自定义输入提示框
        function showCustomPrompt(title, placeholder, initialValue = '', type = 'text') {
            return new Promise(resolve => {
                // 创建模态框HTML
                const modalHtml = `
                    <div id="custom-prompt-modal" class="modal" style="display: flex; z-index: 10000;">
                        <div class="modal-content" style="max-width: 400px;">
                            <div class="modal-header">
                                <div class="modal-title">${title}</div>
                            </div>
                            <div class="modal-body">
                                <input type="${type}" id="custom-prompt-input" class="form-input" 
                                       placeholder="${placeholder}" value="${initialValue}"
                                       style="width: 100%; margin-top: 10px;">
                            </div>
                            <div class="modal-footer">
                                <button class="modal-button modal-secondary" id="custom-prompt-cancel">取消</button>
                                <button class="modal-button modal-primary" id="custom-prompt-confirm">确定</button>
                            </div>
                        </div>
                    </div>
                `;
                
                // 添加到页面
                document.body.insertAdjacentHTML('beforeend', modalHtml);
                
                const modal = document.getElementById('custom-prompt-modal');
                const input = document.getElementById('custom-prompt-input');
                const confirmBtn = document.getElementById('custom-prompt-confirm');
                const cancelBtn = document.getElementById('custom-prompt-cancel');
                
                // 确定按钮事件
                confirmBtn.onclick = () => {
                    const value = input.value;
                    modal.remove();
                    resolve(value);
                };
                
                // 取消按钮事件
                cancelBtn.onclick = () => {
                    modal.remove();
                    resolve(null);
                };
                
                // 回车键确认
                input.onkeydown = (e) => {
                    if (e.key === 'Enter') {
                        confirmBtn.click();
                    }
                };
                
                // 聚焦输入框
                setTimeout(() => input.focus(), 100);
            });
        }
        
        // 切换聊天标签
        function switchChatTab(tabId) {
            // 移除所有标签的active类
            document.querySelectorAll('.chat-tab').forEach(tab => {
                if (tab && tab.classList) {
                    tab.classList.remove('active');
                }
            });
            
            // 添加当前标签的active类
            if (event && event.currentTarget && event.currentTarget.classList) {
                event.currentTarget.classList.add('active');
            } else {
                // 如果没有event对象，根据tabId设置active
                if (tabId === 'message-list') {
                    const messageTab = document.getElementById('message-tab');
                    if (messageTab && messageTab.classList) {
                        messageTab.classList.add('active');
                    }
                } else if (tabId === 'contact-list') {
                    const tabs = document.querySelectorAll('.chat-tab');
                    if (tabs.length > 1 && tabs[1] && tabs[1].classList) {
                        tabs[1].classList.add('active');
                    }
                } else if (tabId === 'moments-page') {
                    const tabs = document.querySelectorAll('.chat-tab');
                    if (tabs.length > 2 && tabs[2] && tabs[2].classList) {
                        tabs[2].classList.add('active');
                    }
                } else if (tabId === 'profile-page') {
                    const tabs = document.querySelectorAll('.chat-tab');
                    if (tabs.length > 3 && tabs[3] && tabs[3].classList) {
                        tabs[3].classList.add('active');
                    }
                }
            }
            
            // 隐藏所有内容
            const messageListEl = document.getElementById('message-list');
            const contactListEl = document.getElementById('contact-list');
            const profilePageEl = document.getElementById('profile-page');
            const momentsPageEl = document.getElementById('moments-page');
            const targetEl = document.getElementById(tabId);
            
            if (messageListEl) messageListEl.style.display = 'none';
            if (contactListEl) contactListEl.style.display = 'none';
            if (profilePageEl) profilePageEl.style.display = 'none';
            if (momentsPageEl) momentsPageEl.style.display = 'none';
            
            // 显示选中的内容
            if (targetEl) targetEl.style.display = 'block';
            
            // 控制app标题的渐变效果和内容
            const appTitle = document.querySelector('#chat-screen .app-title');
            if (appTitle) {
                if (tabId === 'message-list') {
                    appTitle.classList.add('chat-mode');
                    appTitle.textContent = '💬';
                } else if (tabId === 'contact-list') {
                    appTitle.classList.remove('chat-mode');
                    appTitle.textContent = '角色';
                } else if (tabId === 'moments-page') {
                    appTitle.classList.remove('chat-mode');
                                            appTitle.textContent = '动态';
                    // 🔥【新增】切换到动态页面时加载用户设置
                    loadMomentsImages();
                } else if (tabId === 'profile-page') {
                    appTitle.classList.remove('chat-mode');
                    appTitle.textContent = '我';
                }
            }
            
            // 控制按钮显示
            const addContactBtn = document.getElementById('add-contact-btn');
            const addChatBtn = document.getElementById('add-chat-btn');
            const groupManageBtn = document.getElementById('group-manage-btn');
            
            if (addContactBtn && addChatBtn && groupManageBtn) {
                if (tabId === 'contact-list') {
                    addContactBtn.style.display = 'flex';
                    addChatBtn.style.display = 'none';
                    groupManageBtn.style.display = isGroupManageMode ? 'none' : 'flex';
                    // 修改加号按钮的点击事件为创建角色
                    addContactBtn.onclick = () => showCharacterForm();
                } else if (tabId === 'message-list') {
                    addContactBtn.style.display = 'none';
                    addChatBtn.style.display = 'flex';
                    groupManageBtn.style.display = 'none';
                } else if (tabId === 'moments-page') {
                                            // 动态页面显示发布按钮
                    addContactBtn.style.display = 'flex';
                    addChatBtn.style.display = 'none';
                    groupManageBtn.style.display = 'none';
                    // 修改加号按钮的点击事件为发布动态
                    addContactBtn.onclick = () => showPublishMoment();
                } else {
                    addContactBtn.style.display = 'none';
                    addChatBtn.style.display = 'none';
                    groupManageBtn.style.display = 'none';
                }
            }
            
            // 如果是动态页面，检查是否需要加载动态内容
            if (tabId === 'moments-page') {
                // 只在动态列表为空时加载，避免重复显示
                const momentsList = document.getElementById('moments-list');
                if (momentsList && momentsList.children.length === 0) {
                loadMoments();
                }
                                        // 移除动态页面的padding，实现全屏效果
                const chatContent = document.getElementById('chat-content');
                if (chatContent) {
                    chatContent.style.padding = '0';
                }
            } else {
                // 其他页面恢复正常padding
                const chatContent = document.getElementById('chat-content');
                if (chatContent) {
                    chatContent.style.padding = '15px';
                }
                
                // 停止时间更新器（节省资源）
                stopTimeUpdater();
            }
        }
        
        // 更新时间
        function updateTime() {
            const now = new Date();
            const hours = now.getHours().toString().padStart(2, '0');
            const minutes = now.getMinutes().toString().padStart(2, '0');
            const timeString = `${hours}:${minutes}`;
            
            // 更新状态栏时间
            const statusTime = document.getElementById('status-bar-time');
            if (statusTime) {
                statusTime.textContent = timeString;
            }
            
            // 更新应用内状态栏时间
            const appStatusTimes = document.querySelectorAll('.app-status-time');
            appStatusTimes.forEach(element => {
                element.textContent = timeString;
            });
            
            // 更新主时钟
            const mainTime = document.getElementById('main-time');
            if (mainTime) {
                mainTime.textContent = timeString;
            }
            
            // 更新日期
            const mainDate = document.getElementById('main-date');
            if (mainDate) {
                const date = now.toLocaleDateString('zh-CN', { 
                    month: 'long', 
                    day: 'numeric',
                    weekday: 'long'
                });
                mainDate.textContent = date;
            }
        }
        
        // 加载角色分组数据
        async function loadCharacterGroups() {
            try {
                const savedGroups = await db.characterGroups.orderBy('order').toArray();
                
                if (savedGroups.length === 0) {
                    // 如果没有分组，创建默认分组
                    const defaultGroups = [
                        { id: 'my_friends', name: '我的好友', order: 999, isDefault: true, canInteract: false },
                        { id: 'special_care', name: '特别关心', order: 1, isDefault: false, canInteract: true },
                        { id: 'close_friends', name: '亲密朋友', order: 2, isDefault: false, canInteract: true },
                        { id: 'family', name: '家人', order: 3, isDefault: false, canInteract: true },
                        { id: 'classmates', name: '同学', order: 4, isDefault: false, canInteract: true },
                        { id: 'colleagues', name: '同事', order: 5, isDefault: false, canInteract: true }
                    ];
                    
                    await db.characterGroups.bulkAdd(defaultGroups);
                    characterGroups = defaultGroups;
                } else {
                    characterGroups = savedGroups;
                }
            } catch (error) {
                console.error('加载角色分组失败:', error);
                // 创建基本的默认分组
                characterGroups = [
                    { id: 'my_friends', name: '我的好友', order: 999, isDefault: true, canInteract: false }
                ];
            }
        }

        // 保存角色分组数据
        async function saveCharacterGroups() {
            try {
                await db.characterGroups.clear();
                await db.characterGroups.bulkAdd(characterGroups);
            } catch (error) {
                console.error('保存角色分组失败:', error);
            }
        }

        // 加载角色数据 - 使用IndexedDB（包含数据迁移）
        async function loadCharacters() {
            try {
                // 先检查IndexedDB中是否有数据
                const savedCharacters = await db.characters.toArray();
                
                if (savedCharacters.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('characters');
                    if (localStorageData) {
                        const localCharacters = JSON.parse(localStorageData);
                        
                        if (localCharacters.length > 0) {
                            // 为旧角色数据添加默认分组
                            localCharacters.forEach(character => {
                                if (!character.groupId) {
                                    character.groupId = 'my_friends'; // 默认分组
                                }
                            });
                            
                            // 迁移数据到IndexedDB
                            await db.characters.bulkAdd(localCharacters);
                            characters = localCharacters;
                            // 可选：清除localStorage中的旧数据
                            // localStorage.removeItem('characters');
                        } else {
                            characters = [];
                        }
                    } else {
                        characters = [];
                    }
                } else {
                    // 确保所有角色都有分组ID
                    savedCharacters.forEach(character => {
                        if (!character.groupId) {
                            character.groupId = 'my_friends';
                        }
                    });
                    characters = savedCharacters;
                }
            } catch (error) {
                console.error('加载角色数据失败:', error);
                // 如果IndexedDB失败，尝试从localStorage加载
                const localStorageData = localStorage.getItem('characters');
                if (localStorageData) {
                    characters = JSON.parse(localStorageData);
                    // 为角色添加默认分组
                    characters.forEach(character => {
                        if (!character.groupId) {
                            character.groupId = 'my_friends';
                        }
                    });

                } else {
                    characters = [];
                }
            }
        }
        
        // 保存角色数据 - 使用IndexedDB
        async function saveCharacters() {
            try {

                
                // 检查重复ID
                const uniqueIds = new Set();
                const uniqueCharacters = [];
                
                for (const character of characters) {
                    if (!character.id) {
                        console.warn('发现没有ID的角色，跳过保存:', character);
                        continue;
                    }
                    
                    if (!uniqueIds.has(character.id)) {
                        uniqueIds.add(character.id);
                        uniqueCharacters.push(character);
                    } else {
                        console.warn(`发现重复ID的角色 (${character.id})，跳过重复项:`, character);
                    }
                }
                
                // 🔥【安全修复】使用事务确保原子操作，防止数据丢失
                if (uniqueCharacters.length === 0) {
                    console.warn('⚠️ 拒绝保存空角色数据，可能存在数据丢失风险');
                    return;
                }

                // 使用事务进行原子操作
                await db.transaction('rw', db.characters, async () => {
                    await db.characters.clear();
                    await db.characters.bulkPut(uniqueCharacters);
                });

                console.log(`✅ 安全保存了 ${uniqueCharacters.length} 个角色到数据库`);
                

            } catch (error) {
                console.error('保存角色时发生错误:', error);
                alert('保存角色时发生错误: ' + error.message);
                throw error;
            }
        }
        
        // 显示存储使用情况
        function showStorageUsage() {
            const usage = [];
            
            // 计算各种数据的大小
            const characters = localStorage.getItem('characters') || '[]';
            const chatMessages = localStorage.getItem('chatMessages') || '{}';
            const customEmojis = localStorage.getItem('customEmojis') || '[]';
            
            usage.push(`角色数据: ${(characters.length / 1024).toFixed(1)} KB`);
            usage.push(`聊天记录: ${(chatMessages.length / 1024).toFixed(1)} KB`);
            usage.push(`表情包: ${(customEmojis.length / 1024).toFixed(1)} KB`);
            
            const total = characters.length + chatMessages.length + customEmojis.length;
            usage.push(`总计: ${(total / 1024).toFixed(1)} KB`);
            

            alert('存储使用情况:\n' + usage.join('\n'));
        }
        
        // 🔥【架构修复】加载联系人数据 - 从角色列表自动生成
        async function loadContacts() {
            try {
                // 🔥【关键修复】不再依赖独立的contacts表，直接从characters生成
                console.log('🔄 从角色列表生成联系人列表...');

                // 确保characters已经加载
                if (!characters || characters.length === 0) {
                    console.log('⚠️ 角色列表为空，尝试重新加载角色数据');
                    await loadCharacters();
                }

                // 从角色列表生成联系人ID列表
                contacts = characters
                    .filter(char => char && char.id) // 只保留有效的角色
                    .map(char => char.id); // 提取角色ID

                console.log(`✅ 从 ${characters.length} 个角色生成了 ${contacts.length} 个联系人`);

                // 🔥【新增】自动保存到数据库以保持兼容性
                await saveContacts();

            } catch (error) {
                console.error('❌ 生成联系人列表失败:', error);
                contacts = []; // 如果出错，确保联系人列表为空，防止程序崩溃
            }
        }
        
        // 保存联系人数据 - 使用IndexedDB
        async function saveContacts() {
            try {
        // 过滤掉任何可能存在的无效ID
        const validContacts = contacts.filter(id => id); 
        // 将联系人ID列表转换为数据库需要的对象数组格式
        const contactArray = validContacts.map(id => ({ characterId: id }));

        await db.transaction('rw', db.contacts, async () => {
            // 先清空旧表，再批量写入新数据
                await db.contacts.clear();
                if (contactArray.length > 0) {
                    await db.contacts.bulkAdd(contactArray);
                }
        });
            } catch (error) {
                console.error('保存联系人失败:', error);
            }
        }
        
        // 加载聊天消息 - 使用IndexedDB（包含数据迁移）
        async function loadChatMessages() {
            try {
                const savedMessages = await db.chatMessages.toArray();
                chatMessages = {};

                if (savedMessages.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('chatMessages');
                    if (localStorageData) {

                        const localMessages = JSON.parse(localStorageData);
                        
                        // 将对象格式转换为数组格式存储到IndexedDB
                        const messageArray = [];
                        for (const [characterId, messages] of Object.entries(localMessages)) {
                            for (const message of messages) {
                                messageArray.push({
                                    id: `${characterId}_${message.id || message.timestamp}`,
                                    characterId: characterId,
                                    timestamp: message.timestamp,
                                    messageData: message
                                });
                            }
                        }
                        
                        if (messageArray.length > 0) {
                            await db.chatMessages.bulkAdd(messageArray);
                        }
                        
                        chatMessages = localMessages;

                    }
                } else {
                    // 将数组格式转换回对象格式
                    for (const msgRecord of savedMessages) {
                        const characterId = msgRecord.characterId;
                        if (!chatMessages[characterId]) {
                            chatMessages[characterId] = [];
                        }
                        // 🔥【新增】检查消息数据是否有效，过滤空值
                        if (msgRecord.messageData && typeof msgRecord.messageData === 'object') {
                        chatMessages[characterId].push(msgRecord.messageData);
                        }
                    }
                    
                    // 按时间戳排序并清理空值
                    for (const characterId in chatMessages) {
                        // 🔥【新增】过滤掉null、undefined或无效的消息，以及拉黑系统消息
                        chatMessages[characterId] = chatMessages[characterId]
                            .filter(msg => {
                                // 基本有效性检查
                                if (!msg || typeof msg !== 'object' || !msg.timestamp) {
                                    return false;
                                }
                                // 保留拉黑系统消息，它们现在会正确显示
                                return true;
                            })
                            .sort((a, b) => a.timestamp - b.timestamp);
                    }

                    // 🔥【修复】清理数据库中的拉黑系统消息
                    await cleanupBlockedSystemMessages();
                }
            } catch (error) {
                console.error('加载聊天消息失败:', error);
                // 如果IndexedDB失败，尝试从localStorage加载
                const localStorageData = localStorage.getItem('chatMessages');
                if (localStorageData) {
                    chatMessages = JSON.parse(localStorageData);
                } else {
                    chatMessages = {};
                }
            }
        }

        // 🔥【修复】清理数据库中重复的拉黑系统消息
        async function cleanupBlockedSystemMessages() {
            try {
                // 获取所有聊天消息记录
                const allMessages = await db.chatMessages.toArray();
                const messagesToDelete = [];

                // 🔥【修复】清理重复的拉黑系统消息
                const blockedMessagesByCharacter = {};

                for (const msgRecord of allMessages) {
                    if (msgRecord.messageData &&
                        msgRecord.messageData.sender === 'system' &&
                        msgRecord.messageData.isBlockedMessage) {

                        const characterId = msgRecord.characterId;
                        if (!blockedMessagesByCharacter[characterId]) {
                            blockedMessagesByCharacter[characterId] = [];
                        }
                        blockedMessagesByCharacter[characterId].push(msgRecord);
                    }
                }

                // 对每个角色，只保留最新的拉黑系统消息，删除重复的
                for (const characterId in blockedMessagesByCharacter) {
                    const messages = blockedMessagesByCharacter[characterId];
                    if (messages.length > 1) {
                        // 按时间戳排序，保留最新的，删除其他的
                        messages.sort((a, b) => (b.messageData.timestamp || 0) - (a.messageData.timestamp || 0));
                        const toDelete = messages.slice(1); // 删除除第一个（最新）之外的所有消息
                        messagesToDelete.push(...toDelete.map(msg => msg.id));
                    }
                }

                if (messagesToDelete.length > 0) {
                    await db.chatMessages.bulkDelete(messagesToDelete);
                    console.log(`已清理 ${messagesToDelete.length} 条重复的拉黑系统消息`);
                }
            } catch (error) {
                console.error('清理拉黑系统消息失败:', error);
            }
        }

        // 防抖保存计时器
        let saveMessagesTimer = null;
        let isSaving = false; // 防止并发保存
        
        // 防抖版本的保存函数
        function saveChatMessages() {
            // 清除之前的计时器
            if (saveMessagesTimer) {
                clearTimeout(saveMessagesTimer);
            }
            
            // 设置新的计时器，500ms后执行保存
            saveMessagesTimer = setTimeout(async () => {
                if (isSaving) {
                    return;
                }
                await saveChatMessagesImmediate();
            }, 500);
        }
        
        // 立即保存聊天消息 - 使用IndexedDB
        async function saveChatMessagesImmediate() {
            if (isSaving) {
                return;
            }
            
            isSaving = true;
            
            try {

                
                // 将chatMessages对象转换为数组格式存储
                const messageArray = [];
                let globalSequentialId = 0; // 全局顺序ID确保唯一性
                const usedIds = new Set(); // 用于检测ID重复
                
                for (const [characterId, messages] of Object.entries(chatMessages)) {
                    for (let i = 0; i < messages.length; i++) {
                        const message = messages[i];
                        
                        // 生成唯一的主键
                        let uniqueId = `${characterId}_${globalSequentialId++}`;
                        
                        // 确保ID绝对唯一
                        while (usedIds.has(uniqueId)) {
                            uniqueId = `${characterId}_${globalSequentialId++}`;
                        }
                        usedIds.add(uniqueId);
                        
                        messageArray.push({
                            id: uniqueId,
                            characterId: characterId,
                            timestamp: message.timestamp,
                            messageOrder: i,
                            originalMessageId: message.id, // 保留原始消息ID作为数据
                            messageData: message
                        });
                    }
                }
                
                // 🔥【修复删除问题】使用事务确保原子操作，支持消息删除
                if (messageArray.length === 0) {
                    console.warn('⚠️ 消息数据为空，清空数据库');
                    // 如果没有消息，清空数据库
                    await db.transaction('rw', db.chatMessages, async () => {
                        await db.chatMessages.clear();
                    });
                    return;
                }

                // 🔥【修复删除问题】使用事务的clear+bulkAdd，确保删除的消息被正确移除
                await db.transaction('rw', db.chatMessages, async () => {
                    await db.chatMessages.clear();
                    await db.chatMessages.bulkAdd(messageArray);
                });

                console.log(`✅ 安全保存了 ${messageArray.length} 条消息到IndexedDB（支持删除）`);
                

            } catch (error) {
                console.error('保存聊天消息失败:', error);
                
                // 如果批量保存失败，使用简化的重试机制
                try {

                    // 🔥【安全修复】使用事务进行重试保存
                    const messageArray = [];
                    let globalSequentialId = 0;
                    let totalMessages = 0;
                    
                    // 先计算总消息数
                    for (const messages of Object.values(chatMessages)) {
                        totalMessages += messages.length;
                    }
                    
                    const maxMessages = 1000;
                    const skipCount = Math.max(0, totalMessages - maxMessages);
                    let currentSkip = 0;
                    
                    for (const [characterId, messages] of Object.entries(chatMessages)) {
                        for (let i = 0; i < messages.length; i++) {
                            if (currentSkip < skipCount) {
                                currentSkip++;
                                continue;
                            }
                            
                            const message = messages[i];
                            messageArray.push({
                                id: `${characterId}_${globalSequentialId++}`,
                                characterId: characterId,
                                timestamp: message.timestamp,
                                messageOrder: i,
                                originalMessageId: message.id,
                                messageData: message
                            });
                        }
                    }
                    
                    // 🔥【修复】重试时也使用事务确保删除正确处理
                    await db.transaction('rw', db.chatMessages, async () => {
                        await db.chatMessages.clear();
                        if (messageArray.length > 0) {
                            await db.chatMessages.bulkAdd(messageArray);
                        }
                    });
                    

                } catch (fallbackError) {
                    console.error('简化保存也失败:', fallbackError);
                }
            } finally {
                isSaving = false;
            }
        }
        

        
        // 🔥【重构】加载聊天设置 - 优先使用IndexedDB，减少localStorage依赖
        async function loadChatSettings() {
            try {
                // 优先从IndexedDB加载
                const savedChatSettings = await db.chatSettings.toArray();

                if (savedChatSettings.length > 0) {
                    // IndexedDB中有数据，直接使用
                    console.log(`✅ 从IndexedDB加载了 ${savedChatSettings.length} 个聊天设置`);
                    chatSettings = {};
                    savedChatSettings.forEach(item => {
                        chatSettings[item.chatId] = item.settings;
                    });
                    return;
                }

                // IndexedDB中没有数据，尝试从localStorage迁移（一次性迁移）
                console.log('🔄 IndexedDB中无数据，尝试从localStorage迁移...');

                // 检查新格式的localStorage数据
                const localStorageData = localStorage.getItem('chatSettings');
                if (localStorageData) {
                    const localSettings = JSON.parse(localStorageData);
                    await migrateChatSettingsToIndexedDB(localSettings);
                    return;
                }

                // 检查旧格式的localStorage数据（单个角色存储）
                const migratedSettings = {};
                let foundOldData = false;

                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('chatSettings_') && !key.includes('emergency')) {
                        try {
                            const chatId = key.replace('chatSettings_', '');
                            const settingData = localStorage.getItem(key);
                            if (settingData) {
                                migratedSettings[chatId] = JSON.parse(settingData);
                                foundOldData = true;
                            }
                        } catch (e) {
                            console.warn(`跳过无效的localStorage键: ${key}`, e);
                        }
                    }
                }

                if (foundOldData) {
                    console.log('🔄 发现旧格式数据，正在迁移...');
                    await migrateChatSettingsToIndexedDB(migratedSettings);
                    return;
                }

                // 没有任何数据，初始化为空
                chatSettings = {};
                console.log('📝 初始化空的聊天设置');

            } catch (error) {
                console.error('🚨 加载聊天设置失败:', error);

                // 尝试从紧急备份恢复
                try {
                    const emergencyBackup = localStorage.getItem('chatSettings_emergency_backup');
                    if (emergencyBackup) {
                        chatSettings = JSON.parse(emergencyBackup);
                        console.log('🆘 从紧急备份恢复聊天设置');
                        showToast('⚠️ 从紧急备份恢复设置', 'warning');
                        return;
                    }
                } catch (backupError) {
                    console.error('紧急备份也无法加载:', backupError);
                }

                // 最后的回退
                chatSettings = {};
                showToast('❌ 设置加载失败，使用默认设置', 'error');
            }
        }

        // 🔥【新增】迁移chatSettings到IndexedDB的辅助函数
        async function migrateChatSettingsToIndexedDB(localSettings) {
            try {
                const settingsArray = Object.keys(localSettings).map(chatId => ({
                    id: chatId,
                    chatId: chatId,
                    settings: localSettings[chatId]
                }));

                if (settingsArray.length > 0) {
                    await db.chatSettings.bulkPut(settingsArray);
                    console.log(`✅ 成功迁移 ${settingsArray.length} 个聊天设置到IndexedDB`);

                    // 迁移成功后更新内存
                    chatSettings = localSettings;

                    // 可选：清理旧的localStorage数据（谨慎操作）
                    // localStorage.removeItem('chatSettings');
                }
            } catch (error) {
                console.error('🚨 迁移聊天设置到IndexedDB失败:', error);
                // 迁移失败时仍然使用localStorage数据
                chatSettings = localSettings;
            }
        }

        // 🔥【新增】自动保存机制 - 防止浏览器卡顿导致数据丢失
        let autoSaveTimer = null;
        let pendingSettingsChanges = new Set();

        function scheduleAutoSave(chatId) {
            if (chatId) {
                pendingSettingsChanges.add(chatId);
            }

            // 清除之前的定时器
            if (autoSaveTimer) {
                clearTimeout(autoSaveTimer);
            }

            // 设置新的定时器，5秒后自动保存
            autoSaveTimer = setTimeout(async () => {
                if (pendingSettingsChanges.size > 0) {
                    console.log(`🔄 自动保存 ${pendingSettingsChanges.size} 个聊天设置...`);
                    try {
                        await saveChatSettings();
                        console.log('✅ 自动保存完成');
                        pendingSettingsChanges.clear();
                    } catch (error) {
                        console.error('🚨 自动保存失败:', error);
                        // 保留待保存的设置，下次再试
                    }
                }
                autoSaveTimer = null;
            }, 5000); // 5秒延迟
        }

        // 🔥【新增】页面卸载前强制保存
        window.addEventListener('beforeunload', async (event) => {
            if (pendingSettingsChanges.size > 0) {
                console.log('🔄 页面卸载前强制保存设置...');
                try {
                    // 同步保存，确保在页面关闭前完成
                    await saveChatSettings();
                    console.log('✅ 页面卸载前保存完成');
                } catch (error) {
                    console.error('🚨 页面卸载前保存失败:', error);
                }
            }
        });

        // 🔥【新增】页面可见性变化时保存
        document.addEventListener('visibilitychange', async () => {
            if (document.hidden && pendingSettingsChanges.size > 0) {
                console.log('🔄 页面隐藏时保存设置...');
                try {
                    await saveChatSettings();
                    console.log('✅ 页面隐藏时保存完成');
                    pendingSettingsChanges.clear();
                } catch (error) {
                    console.error('🚨 页面隐藏时保存失败:', error);
                }
            }
        });

        // 🔥【新增】调试聊天记录格式的工具函数
        async function debugChatMessagesFormat() {
            try {
                // 检查当前数据库中的聊天记录格式
                const dbMessages = await db.chatMessages.toArray();
                console.log('📊 数据库中的聊天记录格式分析:');
                console.log(`总数: ${dbMessages.length} 条`);

                if (dbMessages.length > 0) {
                    const sample = dbMessages[0];
                    console.log('样本记录结构:', Object.keys(sample));
                    console.log('样本记录:', sample);

                    const hasMessageData = dbMessages.some(msg => msg.messageData);
                    const hasDirectContent = dbMessages.some(msg => msg.content);

                    console.log(`包含messageData字段: ${hasMessageData}`);
                    console.log(`包含直接content字段: ${hasDirectContent}`);
                }

                // 检查内存中的聊天记录格式
                console.log('📊 内存中的聊天记录格式分析:');
                const memoryMessageCount = Object.values(chatMessages).reduce((total, msgs) => total + msgs.length, 0);
                console.log(`总数: ${memoryMessageCount} 条`);

                if (memoryMessageCount > 0) {
                    const firstCharacter = Object.keys(chatMessages)[0];
                    const firstMessage = chatMessages[firstCharacter]?.[0];
                    if (firstMessage) {
                        console.log('内存样本记录结构:', Object.keys(firstMessage));
                        console.log('内存样本记录:', firstMessage);
                    }
                }

                showToast('📊 聊天记录格式分析完成，请查看控制台', 'info');
            } catch (error) {
                console.error('调试聊天记录格式失败:', error);
                showToast('调试失败: ' + error.message, 'error');
            }
        }

        // 🔥【新增】清理localStorage中的旧chatSettings数据
        async function cleanupOldChatSettingsFromLocalStorage() {
            try {
                let cleanedCount = 0;
                const keysToRemove = [];

                // 收集所有chatSettings相关的localStorage键
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && (key === 'chatSettings' || key.startsWith('chatSettings_')) && !key.includes('emergency')) {
                        keysToRemove.push(key);
                    }
                }

                // 确认IndexedDB中有数据后再清理
                const indexedDBSettings = await db.chatSettings.toArray();
                if (indexedDBSettings.length > 0 && keysToRemove.length > 0) {
                    const confirmCleanup = confirm(
                        `检测到 ${keysToRemove.length} 个旧的localStorage聊天设置数据。\n\n` +
                        `IndexedDB中已有 ${indexedDBSettings.length} 个设置，可以安全清理localStorage数据。\n\n` +
                        `是否清理以释放存储空间？`
                    );

                    if (confirmCleanup) {
                        keysToRemove.forEach(key => {
                            localStorage.removeItem(key);
                            cleanedCount++;
                        });

                        console.log(`✅ 已清理 ${cleanedCount} 个旧的localStorage聊天设置`);
                        showToast(`🧹 已清理 ${cleanedCount} 个旧设置数据`, 'success');
                    }
                }
            } catch (error) {
                console.error('清理旧chatSettings数据失败:', error);
            }
        }
        
        // 🔥【重构】保存聊天设置 - 完全依赖IndexedDB，避免数据丢失
        async function saveChatSettings() {
            try {
                // 将chatSettings对象转换为数组格式存储到IndexedDB
                const chatSettingsArray = Object.keys(chatSettings).map(chatId => ({
                    id: chatId,
                    chatId: chatId,
                    settings: chatSettings[chatId]
                }));

                if (chatSettingsArray.length === 0) {
                    console.warn('⚠️ 聊天设置数据为空，跳过保存操作');
                    return;
                }

                // 🔥【安全修复】使用bulkPut代替clear+bulkAdd，避免数据丢失
                await db.chatSettings.bulkPut(chatSettingsArray);

                console.log(`✅ 安全保存了 ${chatSettingsArray.length} 个聊天设置到IndexedDB`);

            } catch (error) {
                console.error('🚨 保存聊天设置到IndexedDB失败:', error);

                // 🔥【紧急备份】只在IndexedDB完全失败时才使用localStorage
                try {
                    console.warn('⚠️ 正在进行紧急备份到localStorage...');
                    const emergencyBackup = {};
                    Object.keys(chatSettings).forEach(chatId => {
                        // 只保存最关键的设置，避免localStorage容量问题
                        emergencyBackup[chatId] = {
                            bubbleStyle: chatSettings[chatId].bubbleStyle,
                            aiChatAvatar: chatSettings[chatId].aiChatAvatar,
                            myChatAvatar: chatSettings[chatId].myChatAvatar,
                            aiChatNickname: chatSettings[chatId].aiChatNickname,
                            myChatNickname: chatSettings[chatId].myChatNickname,
                            hideAvatars: chatSettings[chatId].hideAvatars,
                            selectedIdentityId: chatSettings[chatId].selectedIdentityId,
                            timestampEnabled: chatSettings[chatId].timestampEnabled,
                            timestampPosition: chatSettings[chatId].timestampPosition
                        };
                    });

                    localStorage.setItem('chatSettings_emergency_backup', JSON.stringify(emergencyBackup));
                    console.log('✅ 紧急备份已保存到localStorage');

                    // 显示用户友好的错误提示
                    showToast('⚠️ 数据库保存失败，已启用紧急备份模式', 'warning');

                } catch (localStorageError) {
                    console.error('🚨 紧急备份也失败了:', localStorageError);
                    showToast('❌ 设置保存失败！请检查存储空间', 'error');
                    throw localStorageError;
                }
            }
        }
        
        // === 后台互动系统 ===
        let backgroundTimers = {};

        // 🔥【新增】全局后台互动系统初始化 - 为所有角色设置定时器
        async function initGlobalBackgroundInteractionSystem() {
            console.log('🚀 启动全局后台互动系统...');

            // 🔥【修复】不要清除现有定时器，避免与全局动态发布系统冲突
            // clearAllBackgroundTimers();

            // 为每个角色设置后台互动定时器
            for (const character of characters) {
                try {
                    const chatSettings = await getChatSettings(character.id);

                    // 🔥【修复】正确检查后台互动开关状态
                    const backgroundInteractionEnabled = chatSettings.backgroundInteractionEnabled === true;
                    const backgroundChatEnabled = chatSettings.backgroundChatEnabled === true;
                    const backgroundMomentsEnabled = chatSettings.backgroundMomentsEnabled === true;

                    if (!backgroundInteractionEnabled) {
                        console.log(`角色 ${character.name} 的后台互动已禁用，跳过`);
                        continue;
                    }

                    console.log(`为角色 ${character.name} 设置后台互动定时器`);

                    // 设置主动聊天定时器 - 需要同时检查总开关和子开关
                    if (backgroundInteractionEnabled && backgroundChatEnabled) {
                        // 🔥【修复】检查是否有聊天记录，如果没有则不设置定时器
                        const messages = chatMessages[character.id] || [];
                        const hasUserMessages = messages.some(msg => msg.sender === 'sent');

                        if (hasUserMessages) {
                            scheduleProactiveChatForCharacter(character.id);
                            console.log(`${character.name} 动态主动聊天定时器已设置`);
                        } else {
                            console.log(`${character.name} 没有用户消息记录，暂不设置主动聊天定时器`);
                        }
                    }

                    // 设置主动发动态定时器 - 需要同时检查总开关和子开关
                    if (backgroundInteractionEnabled && backgroundMomentsEnabled) {
                        const momentsInterval = getBackgroundMomentsInterval(chatSettings.backgroundMomentsFrequency || 'low');
                        backgroundTimers[character.id + '_moments'] = setInterval(() => {
                            triggerBackgroundMoments(character.id);
                        }, momentsInterval);
                        console.log(`${character.name} 主动发动态定时器已设置，间隔: ${momentsInterval}ms`);
                    }
                } catch (error) {
                    console.error(`为角色 ${character.name} 设置后台互动定时器失败:`, error);
                }
            }
        }

        // 初始化后台互动系统（单个角色）
        function initBackgroundInteractionSystem() {
            if (!currentChatCharacter) return;

            // 🔥【修复】只清除当前角色的定时器，不影响其他角色
            const characterId = currentChatCharacter.id;
            if (backgroundTimers[characterId + '_chat']) {
                clearInterval(backgroundTimers[characterId + '_chat']);
                delete backgroundTimers[characterId + '_chat'];
            }
            if (backgroundTimers[characterId + '_moments']) {
                clearInterval(backgroundTimers[characterId + '_moments']);
                delete backgroundTimers[characterId + '_moments'];
            }

            const chatSettings = getCurrentChatSettings();

            // 🔥【修复】正确检查后台互动开关状态
            const backgroundInteractionEnabled = chatSettings.backgroundInteractionEnabled === true;
            const backgroundChatEnabled = chatSettings.backgroundChatEnabled === true;
            const backgroundMomentsEnabled = chatSettings.backgroundMomentsEnabled === true;

            if (!backgroundInteractionEnabled) {
                console.log(`角色 ${currentChatCharacter.name} 的后台互动已禁用`);
                return;
            }

            // 设置主动聊天定时器 - 需要同时检查总开关和子开关
            if (backgroundInteractionEnabled && backgroundChatEnabled) {
                // 🔥【修复】检查是否有聊天记录，如果没有则不设置定时器
                const messages = chatMessages[characterId] || [];
                const hasUserMessages = messages.some(msg => msg.sender === 'sent');

                if (hasUserMessages) {
                    scheduleProactiveChatForCharacter(characterId);
                    console.log(`${currentChatCharacter.name} 动态主动聊天定时器已设置`);
                } else {
                    console.log(`${currentChatCharacter.name} 没有用户消息记录，暂不设置主动聊天定时器`);
                }
            }

            // 设置主动发动态定时器 - 需要同时检查总开关和子开关
            if (backgroundInteractionEnabled && backgroundMomentsEnabled) {
                const momentsInterval = getBackgroundMomentsInterval(chatSettings.backgroundMomentsFrequency || 'low');
                backgroundTimers[characterId + '_moments'] = setInterval(() => {
                    triggerBackgroundMoments(characterId);
                }, momentsInterval);
                console.log(`${currentChatCharacter.name} 主动发动态定时器已设置，间隔: ${momentsInterval}ms`);
            }
        }

        // 清除所有后台定时器
        function clearAllBackgroundTimers() {
            Object.values(backgroundTimers).forEach(timer => {
                if (timer) clearInterval(timer);
            });
            backgroundTimers = {};
        }

        // 全局定时发布系统
        let globalMomentsTimers = {};
        let globalMomentsCheckInterval = null;

        // 初始化全局动态发布系统
        async function initGlobalMomentsSystem() {
            console.log('🚀 初始化全局动态发布系统');
            
            // 清除现有的定时器
            clearGlobalMomentsTimers();
            
            // 为所有角色设置后台发布定时器
            let activeCount = 0;
            if (characters && characters.length > 0) {
                for (const character of characters) {
                    const chatSettings = await getChatSettings(character.id);
                    
                    // 🔥【修复】检查是否启用了后台发动态，需要同时检查总开关和子开关
                    if (chatSettings.backgroundInteractionEnabled === true && chatSettings.backgroundMomentsEnabled === true) {
                        const frequency = chatSettings.backgroundMomentsFrequency || 'low';
                        const interval = getBackgroundMomentsInterval(frequency);
                        
                        globalMomentsTimers[character.id] = setInterval(async () => {
                            console.log(`⏰ 定时器触发：${character.name} 准备发布动态`);
                            await triggerBackgroundMoments(character.id);
                        }, interval);
                        
                        activeCount++;
                        console.log(`✅ 为角色 ${character.name} 设置了后台发动态定时器，间隔: ${Math.round(interval/1000/60)}分钟`);
                    }
                    
                    // 检查是否有定时发布时间点
                    if (chatSettings.scheduledMomentsEnabled && chatSettings.scheduledMomentsTimes && chatSettings.scheduledMomentsTimes.length > 0) {
                        console.log(`⏰ 角色 ${character.name} 启用了定时发布，时间点:`, chatSettings.scheduledMomentsTimes);
                    }
                }
            }
            
            // 启动定时检查器（每分钟检查一次是否到了发布时间）
            if (!globalMomentsCheckInterval) {
                globalMomentsCheckInterval = setInterval(async () => {
                    await checkScheduledMomentsTime();
                }, 60000); // 每分钟检查一次
                
                console.log('⏰ 启动了定时发布时间检查器');
            }
            
            console.log(`🎉 全局动态发布系统初始化完成，激活了 ${activeCount} 个角色的后台发布`);
        }

        // 检查定时发布时间
        async function checkScheduledMomentsTime() {
            const now = new Date();
            const currentTime = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
            
            if (characters && characters.length > 0) {
                for (const character of characters) {
                    const chatSettings = await getChatSettings(character.id);
                    
                    if (chatSettings.scheduledMomentsEnabled && 
                        chatSettings.scheduledMomentsTimes && 
                        chatSettings.scheduledMomentsTimes.includes(currentTime)) {
                        
                        console.log(`⏰ 定时发布时间到：${character.name} 在 ${currentTime} 发布动态`);
                        await triggerBackgroundMoments(character.id, true); // 跳过冷却时间
                    }
                }
            }
        }

        // 清除全局动态定时器
        function clearGlobalMomentsTimers() {
            Object.values(globalMomentsTimers).forEach(timer => {
                if (timer) clearInterval(timer);
            });
            globalMomentsTimers = {};
            
            if (globalMomentsCheckInterval) {
                clearInterval(globalMomentsCheckInterval);
                globalMomentsCheckInterval = null;
            }
        }

        // 🔥【修复】获取后台聊天间隔时间 - 改为随机间隔，符合用户需求
        function getBackgroundInterval(frequency) {
            switch (frequency) {
                case 'low':
                    // 1-2小时随机间隔
                    return Math.random() * 60 * 60 * 1000 + 60 * 60 * 1000;
                case 'medium':
                    // 30-60分钟随机间隔
                    return Math.random() * 30 * 60 * 1000 + 30 * 60 * 1000;
                case 'high':
                    // 10-30分钟随机间隔
                    return Math.random() * 20 * 60 * 1000 + 10 * 60 * 1000;
                default:
                    // 默认1-2小时
                    return Math.random() * 60 * 60 * 1000 + 60 * 60 * 1000;
            }
        }

        // 🔥【新增】为角色设置动态主动聊天定时器
        function scheduleProactiveChatForCharacter(characterId) {
            // 清除现有定时器
            if (backgroundTimers[characterId + '_chat']) {
                clearTimeout(backgroundTimers[characterId + '_chat']);
                delete backgroundTimers[characterId + '_chat'];
            }

            // 检查用户最后回复时间
            const messages = chatMessages[characterId] || [];
            const lastUserMessage = messages.slice().reverse().find(msg => msg.sender === 'sent');

            if (!lastUserMessage) return; // 没有用户消息，不设置定时器

            const timeSinceLastUserMessage = Date.now() - lastUserMessage.timestamp;
            const tenMinutes = 10 * 60 * 1000; // 10分钟

            let delay;
            if (timeSinceLastUserMessage < tenMinutes) {
                // 用户最近有回复，等待10分钟后再开始计时
                delay = tenMinutes - timeSinceLastUserMessage;
                console.log(`${characters.find(c => c.id === characterId)?.name} 将在${Math.round(delay / 60000)}分钟后开始主动聊天计时`);
            } else {
                // 用户已经超过10分钟没回复，立即开始随机计时
                delay = 0;
                console.log(`${characters.find(c => c.id === characterId)?.name} 立即开始主动聊天计时`);
            }

            // 设置定时器
            backgroundTimers[characterId + '_chat'] = setTimeout(async () => {
                // 10分钟等待期结束，现在开始随机间隔计时
                const character = characters.find(c => c.id === characterId);
                if (!character) return;

                const chatSettings = await getAsyncChatSettings(characterId);
                const randomInterval = getBackgroundInterval(chatSettings.backgroundChatFrequency || 'low');

                console.log(`${character.name} 将在${Math.round(randomInterval / 60000)}分钟后发送主动消息`);

                // 设置实际的主动聊天定时器
                backgroundTimers[characterId + '_chat'] = setTimeout(() => {
                    triggerBackgroundChat(characterId);
                    // 发送完消息后，重新安排下次的主动聊天
                    scheduleProactiveChatForCharacter(characterId);
                }, randomInterval);
            }, delay);
        }

        // 🔥【新增】当用户发送消息时，重新安排主动聊天定时器
        function onUserMessageSent(characterId) {
            const character = characters.find(c => c.id === characterId);
            console.log(`用户向 ${character?.name} 发送了消息，重新安排主动聊天定时器`);
            // 重新安排该角色的主动聊天定时器
            scheduleProactiveChatForCharacter(characterId);
        }

        // 🔥【新增】手动重新初始化所有角色的主动聊天定时器
        async function reinitializeProactiveChatTimers() {
            console.log('🔄 重新初始化所有角色的主动聊天定时器...');

            for (const character of characters) {
                try {
                    const chatSettings = await getChatSettings(character.id);
                    const backgroundInteractionEnabled = chatSettings.backgroundInteractionEnabled === true;
                    const backgroundChatEnabled = chatSettings.backgroundChatEnabled === true;

                    if (backgroundInteractionEnabled && backgroundChatEnabled) {
                        const messages = chatMessages[character.id] || [];
                        const hasUserMessages = messages.some(msg => msg.sender === 'sent');

                        if (hasUserMessages) {
                            scheduleProactiveChatForCharacter(character.id);
                            console.log(`✅ ${character.name} 主动聊天定时器已重新设置`);
                        } else {
                            console.log(`⏸️ ${character.name} 没有用户消息记录，跳过定时器设置`);
                        }
                    } else {
                        console.log(`🚫 ${character.name} 主动聊天功能已禁用`);
                    }
                } catch (error) {
                    console.error(`❌ 为 ${character.name} 设置主动聊天定时器失败:`, error);
                }
            }

            console.log('🎉 主动聊天定时器重新初始化完成');
        }

        // 获取后台动态间隔时间
        function getBackgroundMomentsInterval(frequency) {
            switch (frequency) {
                case 'low':
                    return Math.random() * 4 * 60 * 60 * 1000 + 4 * 60 * 60 * 1000; // 4-8小时
                case 'medium':
                    return Math.random() * 2 * 60 * 60 * 1000 + 2 * 60 * 60 * 1000; // 2-4小时
                case 'high':
                    return Math.random() * 60 * 60 * 1000 + 60 * 60 * 1000; // 1-2小时
                default:
                    return Math.random() * 4 * 60 * 60 * 1000 + 4 * 60 * 60 * 1000; // 默认4-8小时
            }
        }

        // 触发后台聊天
        async function triggerBackgroundChat(characterId, skipTimeCheck = false) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;

                // 检查用户是否至少10分钟没有回复（测试时可跳过）
                if (!skipTimeCheck) {
                    const messages = chatMessages[characterId] || [];
                    const lastUserMessage = messages.slice().reverse().find(msg => msg.sender === 'sent');

                    if (lastUserMessage) {
                        const timeSinceLastUserMessage = Date.now() - lastUserMessage.timestamp;
                        const tenMinutes = 10 * 60 * 1000; // 10分钟
                        if (timeSinceLastUserMessage < tenMinutes) {
                            console.log(`${character.name} 跳过主动聊天：用户最近${Math.round(timeSinceLastUserMessage / 60000)}分钟前有回复`);
                            return; // 用户最近有活动，不发送自动消息
                        }

                        // 🔥【新增】检查是否已经在等待期内发送过主动消息
                        const lastAIMessage = messages.slice().reverse().find(msg => msg.sender === 'received');
                        if (lastAIMessage && lastAIMessage.isProactive) {
                            // 如果最后一条AI消息是主动消息，检查是否在合理的时间间隔内
                            const timeSinceLastProactive = Date.now() - lastAIMessage.timestamp;
                            const chatSettings = await getAsyncChatSettings(characterId);
                            const minInterval = getBackgroundInterval(chatSettings.backgroundChatFrequency || 'low');

                            if (timeSinceLastProactive < minInterval) {
                                console.log(`${character.name} 跳过主动聊天：距离上次主动消息仅${Math.round(timeSinceLastProactive / 60000)}分钟`);
                                return;
                            }
                        }
                    }
                } else {
                    console.log(`${character.name} 测试模式：跳过10分钟时间检查`);
                }
                
                // 🔥【修复】获取该角色的聊天设置，而不是当前聊天设置
                const chatSettings = await getAsyncChatSettings(characterId);

                // 🔥【修复】使用用户设置的历史消息回合数和跨窗口记忆数
                const historyCount = chatSettings.historyCount || 5;
                const crossWindowMemory = chatSettings.crossWindowMemory || 3;

                // 🔥【修复】获取聊天消息（我之前不小心删除了这行）
                const messages = chatMessages[characterId] || [];

                // 获取最近的聊天历史（使用历史消息回合数设置）
                const recentMessages = messages.slice(-historyCount);

                // 🔥【修复】获取跨窗口记忆数量的最近动态内容
                const recentMoments = await getRecentMoments(crossWindowMemory);
                let momentsContext = '';
                if (recentMoments.length > 0) {
                    momentsContext = '\n\n最近的动态内容：\n' +
                        recentMoments.map(moment => `${moment.nickname}: ${moment.text}`).join('\n');
                }
                
                // 构建聊天历史上下文
                let chatContext = '';
                if (recentMessages.length > 0) {
                    chatContext = '\n\n最近的聊天记录：\n' +
                        recentMessages.map(msg => {
                            if (msg.sender === 'sent') return `用户：${msg.content}`;
                            if (msg.sender === 'received') return `${character.name}：${msg.content}`;
                            return '';
                        }).filter(Boolean).join('\n');
                }
                
                // 🔥【修复】获取世界书信息
                let worldbookContext = '';
                if (character.worldbook && character.worldbook.length > 0) {
                    worldbookContext = '\n\n世界书信息：\n' +
                        character.worldbook.map(entry => `${entry.key}: ${entry.value}`).join('\n');
                }

                // 🔥【修复】生成更完整的主动聊天内容，包含人设、世界书、历史消息、动态等
                const prompt = `你是${character.name}，你的人设如下：${character.bio}${worldbookContext}

现在你要主动给用户发送一条消息。这条消息应该是：
1. 严格符合你的人设和性格特点
2. 自然、有趣、有互动性
3. 可以是问候、分享、询问、关心等
4. 不要过于正式，要像朋友间的日常聊天
5. 如果有聊天历史，要基于历史内容进行自然的延续或回应
6. 可以适当提及最近的动态内容，让对话更自然
7. 考虑当前时间和情境，让消息更贴合实际
8. 保持角色的一致性和连贯性${chatContext}${momentsContext}

请生成主动聊天的消息（可以是1-12条），以JSON数组格式返回：`;

                const response = await generateAIResponse(prompt, character);
                if (response && response.trim()) {
                    // 🔥【修复】使用与正常AI回复相同的处理逻辑
                    const aiMessages = parseAiResponse(response);

                    if (!chatMessages[characterId]) {
                        chatMessages[characterId] = [];
                    }

                    // 🔥【修复】使用与processAIReply相同的消息处理逻辑
                    for (let i = 0; i < aiMessages.length; i++) {
                        const msgData = aiMessages[i];
                        let aiMessage;

                        // 🔥【修复】跳过拉黑指令对象
                        if (typeof msgData === 'object' && msgData !== null && msgData.type === 'block_user') {
                            console.log('🚫 跳过拉黑指令对象，不显示为消息:', msgData);
                            continue;
                        }

                        if (typeof msgData === 'object' && msgData !== null) {
                            if (msgData.type === 'voice_message') {
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    type: 'voice_message',
                                    content: msgData.content,
                                    timestamp: Date.now() + i * 100
                                };
                            } else if (msgData.type === 'ai_image') {
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    type: 'ai_image',
                                    content: msgData.description || 'AI描述的图片',
                                    imageDescription: msgData.description,
                                    timestamp: Date.now() + i * 100
                                };
                            } else if (msgData.type === 'transfer') {
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    type: 'transfer',
                                    amount: msgData.amount,
                                    note: msgData.note,
                                    timestamp: Date.now() + i * 100
                                };
                            } else if (msgData.type === 'emoji') {
                                const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.description);
                                if (matchingEmoji) {
                                    aiMessage = {
                                        id: (Date.now() + i).toString(),
                                        sender: 'received',
                                        content: '',
                                        image: matchingEmoji.url,
                                        isEmoji: true,
                                        emojiDescription: matchingEmoji.description,
                                        timestamp: Date.now() + i * 100
                                    };

                                    // 🔥【修复】如果是群聊消息，添加发送者信息
                                    if (msgData.name) {
                                        aiMessage.name = msgData.name;
                                        // 查找对应的群成员ID
                                        const group = groupChats.find(g => g.id === characterId);
                                        if (group && group.members) {
                                            const member = group.members.find(m => m.name === msgData.name);
                                            if (member) {
                                                aiMessage.senderId = member.id;
                                            }
                                        }
                                    }

                                    addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                                } else {
                                    aiMessage = {
                                        id: (Date.now() + i).toString(),
                                        sender: 'received',
                                        content: `[表情包"${msgData.description}"不存在]`,
                                        timestamp: Date.now() + i * 100
                                    };
                                }
                            } else if (msgData.content) {
                                // 普通对象消息
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    content: msgData.content,
                                    timestamp: Date.now() + i * 100
                                };
                            } else {
                                console.log('🔥 [主动聊天] 不支持的消息格式:', msgData);
                                continue;
                            }
                        } else if (typeof msgData === 'string') {
                            // 普通文本消息
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                content: msgData,
                                timestamp: Date.now() + i * 100
                            };
                        } else {
                            console.log('🔥 [主动聊天] 无效的消息数据:', msgData);
                            continue;
                        }

                        if (aiMessage) {
                            // 🔥【新增】标记为主动消息
                            aiMessage.isProactive = true;
                            chatMessages[characterId].push(aiMessage);
                        }
                    }

                    saveChatMessages();
                    console.log(`🔥 [主动聊天] ${character.name} 发送了 ${aiMessages.length} 条消息`);

                    // 🔥【新增】记录主动聊天消息到时间线记忆
                    setTimeout(async () => {
                        try {
                            for (let i = 0; i < aiMessages.length; i++) {
                                const msgData = aiMessages[i];
                                let eventContent = '';

                                if (typeof msgData === 'string') {
                                    eventContent = msgData;
                                } else if (typeof msgData === 'object' && msgData.content) {
                                    eventContent = msgData.content;
                                } else if (typeof msgData === 'object' && msgData.type === 'voice_message') {
                                    eventContent = msgData.content;
                                } else if (typeof msgData === 'object' && msgData.type === 'transfer') {
                                    eventContent = `转账 ¥${msgData.amount}${msgData.note ? ` - ${msgData.note}` : ''}`;
                                } else if (typeof msgData === 'object' && msgData.type === 'emoji') {
                                    eventContent = `发送表情包：${msgData.description}`;
                                }

                                if (eventContent) {
                                    await recordCrossAppEvent(
                                        characterId,
                                        'chat',
                                        'ai_message',
                                        {
                                            id: characterId,
                                            type: 'private_chat',
                                            sender: 'ai',
                                            content: eventContent,
                                            chatType: 'single',
                                            isProactive: true // 标记为主动消息
                                        }
                                    );
                                    console.log(`🔥 [主动聊天] 已记录时间线事件 - 角色: ${character.name}, 内容: ${eventContent.substring(0, 50)}...`);
                                }
                            }
                        } catch (error) {
                            console.error('🔥 [主动聊天] 记录时间线事件失败:', error);
                        }
                    }, 1000); // 延迟1秒执行

                    // 如果当前正在和这个角色聊天，立即显示消息
                    if (currentChatCharacter && currentChatCharacter.id === characterId) {
                        renderChatMessages(characterId);
                    }

                    // 更新消息列表
                    renderMessageList();
                    
                    // 移除了主动发送消息日志
                }
            } catch (error) {
                console.error('后台聊天失败:', error);
            }
        }

        // 🔥【新增】测试主动聊天功能
        async function testActiveChat() {
            if (!currentChatCharacter) {
                showToast('请先选择一个聊天角色', 'error');
                return;
            }

            console.log(`🧪 测试主动聊天功能 - 角色: ${currentChatCharacter.name}`);
            showToast(`正在测试 ${currentChatCharacter.name} 的主动聊天功能...`, 'info');

            try {
                // 🔥【新增】显示测试前的消息数量
                const beforeCount = (chatMessages[currentChatCharacter.id] || []).length;
                console.log(`测试前消息数量: ${beforeCount}`);

                await triggerBackgroundChat(currentChatCharacter.id, true); // 跳过时间检查

                // 🔥【新增】显示测试后的消息数量
                const afterCount = (chatMessages[currentChatCharacter.id] || []).length;
                console.log(`测试后消息数量: ${afterCount}`);

                if (afterCount > beforeCount) {
                    showToast('主动聊天测试成功！已生成新消息', 'success');
                } else {
                    showToast('主动聊天测试完成，但未生成新消息（可能被条件限制）', 'warning');
                }
            } catch (error) {
                console.error('主动聊天测试失败:', error);
                showToast(`主动聊天测试失败: ${error.message}`, 'error');
            }
        }

        // 🔥【新增】测试主动发动态功能
        async function testActiveMoments() {
            if (!currentChatCharacter) {
                showToast('请先选择一个聊天角色', 'error');
                return;
            }

            console.log(`🧪 测试主动发动态功能 - 角色: ${currentChatCharacter.name}`);
            showToast(`正在测试 ${currentChatCharacter.name} 的主动发动态功能...`, 'info');

            try {
                // 🔥【新增】获取测试前的动态数量
                const beforeMoments = await getRecentMoments(50);
                const beforeCount = beforeMoments.length;
                console.log(`测试前动态数量: ${beforeCount}`);

                await triggerBackgroundMoments(currentChatCharacter.id, true); // 跳过冷却时间

                // 🔥【新增】获取测试后的动态数量
                const afterMoments = await getRecentMoments(50);
                const afterCount = afterMoments.length;
                console.log(`测试后动态数量: ${afterCount}`);

                if (afterCount > beforeCount) {
                    showToast('主动发动态测试成功！已发布新动态', 'success');
                } else {
                    showToast('主动发动态测试完成，但未发布新动态', 'warning');
                }
            } catch (error) {
                console.error('主动发动态测试失败:', error);
                showToast(`主动发动态测试失败: ${error.message}`, 'error');
            }
        }

        // 🔥【新增】查看当前后台定时器状态
        function checkBackgroundTimers() {
            console.log('🔍 当前后台定时器状态:');
            console.log('backgroundTimers:', backgroundTimers);

            const activeTimers = Object.keys(backgroundTimers).length;
            console.log(`活跃定时器数量: ${activeTimers}`);

            if (activeTimers === 0) {
                console.log('⚠️ 没有活跃的后台定时器');
                console.log('💡 可以运行 reinitializeProactiveChatTimers() 来重新初始化定时器');
            } else {
                for (const [key, timer] of Object.entries(backgroundTimers)) {
                    console.log(`- ${key}: ${timer ? '运行中' : '已停止'}`);
                }
            }

            showToast(`当前有 ${activeTimers} 个活跃的后台定时器`, 'info');
        }

        // 🔥【新增】重新启动后台系统（用于测试）
        async function restartBackgroundSystem() {
            console.log('🔄 重新启动后台互动系统...');
            await initGlobalBackgroundInteractionSystem();
            checkBackgroundTimers();
        }

        // 🔥【新增】暂停指定角色的主动发消息计时器（用于线下模式）
        function pauseProactiveChatTimer(characterId) {
            const timerKey = characterId + '_chat';
            if (backgroundTimers[timerKey]) {
                clearTimeout(backgroundTimers[timerKey]);
                // 保存计时器状态，以便恢复时使用
                backgroundTimers[timerKey + '_paused'] = true;
                delete backgroundTimers[timerKey];
                console.log(`⏸️ 已暂停角色 ${characters.find(c => c.id === characterId)?.name} 的主动发消息计时器`);
            }
        }

        // 🔥【新增】恢复指定角色的主动发消息计时器（退出线下模式时）
        function resumeProactiveChatTimer(characterId) {
            const pausedKey = characterId + '_chat_paused';
            if (backgroundTimers[pausedKey]) {
                // 删除暂停标记
                delete backgroundTimers[pausedKey];
                // 重新安排主动聊天定时器
                scheduleProactiveChatForCharacter(characterId);
                console.log(`▶️ 已恢复角色 ${characters.find(c => c.id === characterId)?.name} 的主动发消息计时器`);
            }
        }

        // 🔧【调试】将重新初始化函数暴露到全局作用域，方便控制台调用
        window.reinitializeProactiveChatTimers = reinitializeProactiveChatTimers;

        // 🔥【暴露测试函数到全局作用域】
        window.testActiveChat = testActiveChat;
        window.testActiveMoments = testActiveMoments;
        window.checkBackgroundTimers = checkBackgroundTimers;
        window.initGlobalBackgroundInteractionSystem = initGlobalBackgroundInteractionSystem;
        window.restartBackgroundSystem = restartBackgroundSystem;
        window.triggerPublisherReplyToComments = triggerPublisherReplyToComments;

        // 🔥【新增】测试发布者回复功能
        window.testPublisherReply = async function(momentId) {
            try {
                console.log('🧪 开始测试发布者回复功能...');

                // 🔥【修复】确保momentId是正确的数字类型
                const numericMomentId = typeof momentId === 'string' ? parseInt(momentId) : momentId;
                console.log(`🔍 查找动态ID: ${numericMomentId} (原始输入: ${momentId})`);

                // 获取动态信息
                const moment = await db.moments.get(numericMomentId);
                if (!moment) {
                    console.error('❌ 未找到动态:', numericMomentId);
                    // 🔥【调试】列出所有动态ID
                    const allMoments = await db.moments.toArray();
                    console.log('📋 数据库中的所有动态ID:', allMoments.map(m => `${m.id} (${typeof m.id})`));
                    return;
                }

                // 获取发布者角色
                const publisherCharacter = characters.find(c => c.id === moment.characterId);
                if (!publisherCharacter) {
                    console.error('❌ 未找到发布者角色:', moment.characterId);
                    console.log('📋 可用角色:', characters.map(c => `${c.name} (ID: ${c.id})`));
                    return;
                }

                console.log(`📝 测试动态: ${moment.text}`);
                console.log(`👤 发布者: ${publisherCharacter.name} (ID: ${publisherCharacter.id})`);

                // 直接调用发布者回复函数
                await triggerPublisherReplyToComments(numericMomentId, publisherCharacter);

                console.log('✅ 测试完成');
            } catch (error) {
                console.error('❌ 测试失败:', error);
            }
        };

        // 🔥【新增】列出最近的动态ID，方便测试
        window.listRecentMoments = async function() {
            try {
                const moments = await db.moments.orderBy('timestamp').reverse().limit(10).toArray();
                console.log('📋 最近10条动态:');
                moments.forEach((moment, index) => {
                    console.log(`${index + 1}. ID: ${moment.id} | 发布者: ${moment.nickname} | 内容: ${moment.text.substring(0, 30)}...`);
                });
                console.log('💡 使用 testPublisherReply(动态ID) 来测试发布者回复功能');
                console.log('💡 使用 forcePublisherReply(动态ID) 来强制发布者回复');
            } catch (error) {
                console.error('❌ 获取动态列表失败:', error);
            }
        };

        // 🔥【新增】强制发布者回复功能（忽略概率检查）
        window.forcePublisherReply = async function(momentId) {
            try {
                console.log('🧪 强制发布者回复测试...');

                const numericMomentId = typeof momentId === 'string' ? parseInt(momentId) : momentId;
                const moment = await db.moments.get(numericMomentId);
                if (!moment) {
                    console.error('❌ 未找到动态:', numericMomentId);
                    return;
                }

                const publisherCharacter = characters.find(c => c.id === moment.characterId);
                if (!publisherCharacter) {
                    console.error('❌ 未找到发布者角色:', moment.characterId);
                    return;
                }

                // 获取评论
                const comments = await db.momentComments.where('momentId').equals(numericMomentId).toArray();
                const otherCharacterComments = comments.filter(comment =>
                    comment.authorId !== publisherCharacter.id &&
                    comment.authorId !== 'user' &&
                    comment.authorId
                );

                if (otherCharacterComments.length === 0) {
                    console.log('❌ 没有其他角色的评论可回复');
                    return;
                }

                // 强制选择一条评论回复
                const randomComment = otherCharacterComments[Math.floor(Math.random() * otherCharacterComments.length)];
                console.log(`🎯 强制 ${publisherCharacter.name} 回复 ${randomComment.nickname} 的评论`);

                const replyText = await generatePublisherReply(publisherCharacter, randomComment, numericMomentId);
                if (replyText) {
                    const reply = {
                        id: Date.now() + Math.random(),
                        nickname: publisherCharacter.name,
                        avatar: publisherCharacter.avatarUrl,
                        text: replyText,
                        time: formatTime(new Date()),
                        timestamp: Date.now(),
                        characterId: publisherCharacter.id,
                        replyTo: randomComment.nickname
                    };

                    await saveCommentToMoment(numericMomentId, reply);
                    await updateMomentCommentCount(numericMomentId);
                    displayCommentUnderMoment(numericMomentId, reply);

                    console.log(`✅ 强制回复成功: "${replyText}"`);
                } else {
                    console.log('❌ 生成回复失败');
                }
            } catch (error) {
                console.error('❌ 强制回复测试失败:', error);
            }
        };

        // 触发后台发动态（测试版本，跳过冷却时间）
        async function triggerBackgroundMomentsTest(characterId) {
            // 移除了测试发布日志
            // 直接调用正常发布函数，但跳过冷却时间检查
            await triggerBackgroundMoments(characterId, true);
        }

        // 触发后台发动态
        async function triggerBackgroundMoments(characterId, skipCooldown = false) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;
                
                // 检查冷却时间（避免短时间内重复发布）
                if (!skipCooldown) {
                    const lastMomentTime = character.lastMomentTime || 0;
                    const cooldownTime = 30 * 60 * 1000; // 30分钟冷却时间
                    if (Date.now() - lastMomentTime < cooldownTime) {
                        // 移除了冷却时间日志
                        return;
                    }
                } else {
                    // 移除了测试发布日志
                }
                
                const chatSettings = getCurrentChatSettings();
                
                // 获取最近的聊天记录
                const messages = chatMessages[characterId] || [];
                const maxMemory = chatSettings.historyCount || 5;
                const recentMessages = messages.slice(-maxMemory);
                
                // 获取最近的动态内容
                const recentMoments = await getRecentMoments(5);
                
                // 构建上下文
                let chatContext = '';
                if (recentMessages.length > 0) {
                    chatContext = '\n\n最近的聊天记录：\n' +
                        recentMessages.map(msg => {
                            if (msg.sender === 'sent') return `用户：${msg.content}`;
                            if (msg.sender === 'received') return `${character.name}：${msg.content}`;
                            return '';
                        }).filter(Boolean).join('\n');
                }
                
                let momentsContext = '';
                if (recentMoments.length > 0) {
                    momentsContext = '\n\n最近的动态内容：\n' + 
                        recentMoments.map(moment => `${moment.nickname}: ${moment.text}`).join('\n');
                }
                
                // 生成动态内容
                const prompt = `你是${character.name}，你的人设如下：${character.bio}。

现在你要发布一条动态。这条动态应该是：
1. 符合你的人设和性格
2. 生活化、有趣、有个性
3. 50-200字左右
4. 可以是心情、感悟、日常、分享等
5. 可以结合最近的聊天或动态内容作为灵感
6. 要有你独特的风格，不能和其他角色混淆
7. 支持换行显示，可以适当分段让内容更易读
8. 可以选择性地配图，如果想要配图，请直接换行，然后用斜体格式写：*[配图：详细的图片描述]*

## 配图规则（遵循）：
- 不需要每条动态都配图，只有当内容真的适合配图时才添加配图描述
- 图片描述要生动、具体，让人能通过文字想象出画面
- 以第三人称视角描述，例如：*[配图：照片里一只橘猫正懒洋洋地趴在窗台上晒太阳，阳光把它金色的毛照得发亮，背景是蔚蓝的天空和几朵白云。]*
- 图片描述要符合你的性格和当前情境

${chatContext}${momentsContext}

## 重要格式要求：
- 直接返回动态文本内容，不要使用JSON格式
- 不要添加任何代码块标记
- 不要添加"动态内容："等前缀
- 直接以动态正文开始

请生成一条符合你人设的动态内容：`;

                const response = await generateAIResponse(prompt, character);
                if (response && response.trim()) {
                    // 🔥【修复】动态内容应该是纯文本，强化格式处理
                    let content = response.trim();

                    // 🔥【增强】更强的JSON格式检测和处理
                    if (content.startsWith('[') || content.startsWith('{')) {
                        try {
                            const parsed = JSON.parse(content);
                            console.log(character.name + ' 发动态时AI返回了JSON格式，正在提取文本:', parsed);

                            if (Array.isArray(parsed) && parsed.length > 0) {
                                // 如果是数组，合并所有文本内容
                                content = parsed.map(item => {
                                    if (typeof item === 'string') {
                                        return item.trim();
                                    } else if (typeof item === 'object' && item.content) {
                                        return item.content.trim();
                                    } else if (typeof item === 'object' && item.text) {
                                        return item.text.trim();
                                    }
                                    return '';
                                }).filter(text => text).join('\n');
                            } else if (typeof parsed === 'object') {
                                // 如果是对象，尝试提取文本字段
                                content = parsed.content || parsed.text || parsed.message || JSON.stringify(parsed);
                            }

                            console.log(character.name + ' 提取后的动态内容:', content);
                        } catch (parseError) {
                            // 如果不是有效JSON，直接使用原始文本
                            console.log(character.name + ' 动态内容不是有效JSON，使用原始文本');
                            content = response.trim();
                        }
                    }

                    // 🔥【新增】清理可能的格式标记
                    content = content
                        .replace(/^```[\s\S]*?\n/, '') // 移除开头的代码块标记
                        .replace(/\n```$/, '') // 移除结尾的代码块标记
                        .replace(/^\*\*动态内容\*\*:?\s*/i, '') // 移除可能的标题
                        .replace(/^动态内容:?\s*/i, '') // 移除可能的标题
                        .trim();
                    
                    if (content) {
                        // 获取头像，确保安全
                        const avatar = getCharacterAvatar(character);
                        // 移除了发布动态头像日志
                        
                        // 发布动态
                        const moment = {
                            id: Date.now(),  // 使用数字ID而不是字符串
                            authorId: characterId,
                            nickname: character.name,
                            avatar: avatar, // 角色头像
                            text: content,
                            time: formatTime(new Date()),
                            timestamp: Date.now(),
                            characterId: characterId
                        };
                    
                                                                    // 保存到数据库
                        await db.moments.add(moment);
                        
                        // 🔥【新增】为角色发布动态创建推送通知
                        createPushNotification(character, `发布了新动态：${content.length > 15 ? content.substring(0, 15) + '...' : content}`, 500);
                        
                        // 记录发布时间
                        character.lastMomentTime = Date.now();
                        saveCharacters();
                        
                        // 强制刷新动态显示（无论当前在哪个页面）
                        setTimeout(() => {
                            loadMoments();
                        }, 100);
                        
                        // 触发同分组角色的自发互动（保持概率设置）
                        setTimeout(() => {
                            triggerAIInteractions(moment.id, 'like');
                        }, 2000 + Math.random() * 3000); // 2-5秒后开始点赞
                        
                        setTimeout(() => {
                            triggerAIInteractions(moment.id, 'comment');
                        }, 5000 + Math.random() * 5000); // 5-10秒后开始评论
                        
                        // 移除了发布动态日志
                    }
                }
            } catch (error) {
                console.error('后台发动态失败:', error);
            }
        }

        // 获取最近的动态
        async function getRecentMoments(count = 5) {
            try {
                // 从数据库获取最新的动态数据
                const momentsData = await db.moments.orderBy('timestamp').reverse().limit(count).toArray();
                return momentsData || [];
            } catch (error) {
                console.error('获取最近动态失败:', error);
                return [];
            }
        }

        // 🔥【新增】获取角色可见的动态（用于聊天记忆集成）
        async function getVisibleMomentsForCharacter(characterId, count = 5) {
            try {
                // 获取所有最新动态
                const allMoments = await db.moments.orderBy('timestamp').reverse().limit(count * 2).toArray();
                
                // 筛选角色可见的动态：
                // 1. 用户发的动态（所有角色都能看到）
                // 2. 角色自己发的动态
                // 3. 同一个好友分组的其他角色发的动态
                
                const visibleMoments = [];
                const character = characters.find(c => c.id === characterId);
                
                for (const moment of allMoments) {
                    if (visibleMoments.length >= count) break;
                    
                    // 用户发的动态，所有角色都能看到
                    if (moment.authorId === 'user') {
                        visibleMoments.push(moment);
                        continue;
                    }
                    
                    // 角色自己发的动态
                    if (moment.authorId === characterId) {
                        visibleMoments.push(moment);
                        continue;
                    }
                    
                    // 检查是否是同一个好友分组的角色发的动态
                    if (character && moment.characterId) {
                        const momentAuthor = characters.find(c => c.id === moment.characterId);
                        if (momentAuthor && areCharactersInSameGroup(character, momentAuthor)) {
                            visibleMoments.push(moment);
                            continue;
                        }
                    }
                }
                
                return visibleMoments;
            } catch (error) {
                console.error('获取角色可见动态失败:', error);
                return [];
            }
        }

        // 🔥【新增】检查两个角色是否在同一个好友分组
        function areCharactersInSameGroup(char1, char2) {
            // 如果没有分组系统，默认所有角色都在同一组（都是好友）
            // 这里可以根据实际的分组逻辑进行调整
            return contacts.includes(char1.id) && contacts.includes(char2.id);
        }

        // 生成AI响应的包装函数，用于后台互动
        async function generateAIResponse(prompt, character) {
            try {
                // 使用现有的 callChatAPI 函数
                const response = await callChatAPI(prompt, character);
                return response;
            } catch (error) {
                console.error('AI响应生成失败:', error);
                return null;
            }
        }

        // 验证头像URL是否有效
        function isValidAvatarUrl(url) {
            if (!url || typeof url !== 'string') return false;
            
            // 检查base64格式
            if (url.startsWith('data:image/')) {
                // 更宽松的base64验证，只检查基本结构
                const parts = url.split(',');
                if (parts.length !== 2) {
                    console.warn('base64头像URL格式错误（缺少逗号分隔）:', url.substring(0, 50) + '...');
                    return false;
                }
                
                const header = parts[0];
                const data = parts[1];
                
                // 检查header是否包含必要信息
                if (!header.includes('data:image/') || !header.includes('base64')) {
                    console.warn('base64头像URL头部格式错误:', header);
                    return false;
                }
                
                // 检查base64数据是否为空或过长
                if (!data || data.length < 50) {
                    console.warn('base64头像数据为空或过短:', data.length);
                    return false;
                }
                
                if (data.length > 2000000) { // 2MB限制，更宽松
                    console.warn('base64头像数据过大:', data.length, '建议压缩后重新上传以提高性能');
                    // 不再直接拒绝，只是警告
                }
                
                // 简单检查base64字符是否合法
                const base64Chars = /^[A-Za-z0-9+/]*={0,2}$/;
                if (!base64Chars.test(data)) {
                    console.warn('base64头像数据包含非法字符');
                    return false;
                }
                
                return true;
            }
            
            // 检查HTTP(S) URL格式
            if (url.startsWith('http://') || url.startsWith('https://')) {
                try {
                    new URL(url);
                    return true;
                } catch (error) {
                    console.warn('无效的HTTP头像URL:', url);
                    return false;
                }
            }
            
            // 如果不是data:image或http(s)开头，考虑可能是其他有效格式
            console.warn('未知的头像URL格式:', url.substring(0, 50) + '...');
            return false;
        }

        // 获取角色的头像（用于动态发布）
        function getCharacterAvatar(character) {
            // 使用同步版本的设置获取，避免Promise问题
            const chatSettings = getChatSettingsSync(character.id);
            
            // 优先级1：如果角色有聊天窗口的动态头像设置，使用那个
            if (chatSettings.aiDynamicAvatar && chatSettings.aiDynamicAvatar.trim()) {
                const avatar = chatSettings.aiDynamicAvatar;
                if (isValidAvatarUrl(avatar)) {
                    return avatar;
                } else {
                    console.warn(`角色${character.name}的动态头像无效，尝试使用其他头像`);
                }
            }
            
            // 优先级2：如果角色有聊天窗口的头像设置，使用那个
            if (chatSettings.aiChatAvatar && chatSettings.aiChatAvatar.trim()) {
                const avatar = chatSettings.aiChatAvatar;
                if (isValidAvatarUrl(avatar)) {
                    return avatar;
                } else {
                    console.warn(`角色${character.name}的聊天头像无效，尝试使用角色卡头像`);
                }
            }
            
            // 优先级3：使用角色卡里的头像
            if (character.avatarUrl && character.avatarUrl.trim()) {
                const avatar = character.avatarUrl;
                if (isValidAvatarUrl(avatar)) {
                    return avatar;
                } else {
                    console.warn(`角色${character.name}的角色卡头像无效，大小或格式问题`);
                }
            }
            
            console.log(`角色${character.name}没有可用的头像`);
            return null;
        }

        // 获取指定角色的聊天设置 - 使用IndexedDB
        async function getChatSettings(characterId) {
            try {
                const chatSettingsRecord = await db.chatSettings.get(characterId);
                if (chatSettingsRecord) {
                    return chatSettingsRecord.settings;
                }
                
                // 如果IndexedDB中没有，尝试从localStorage迁移
                const savedSettings = localStorage.getItem(`chatSettings_${characterId}`);
                if (savedSettings) {
                    console.log(`迁移角色 ${characterId} 的聊天设置到IndexedDB`);
                    const settings = JSON.parse(savedSettings);
                    
                    // 保存到IndexedDB
                    await db.chatSettings.put({
                        id: characterId,
                        chatId: characterId,
                        settings: settings
                    });
                    
                    return settings;
                }
                
                return {};
            } catch (error) {
                console.error('获取聊天设置失败:', error);
                // 回退到localStorage
                const savedSettings = localStorage.getItem(`chatSettings_${characterId}`);
                return savedSettings ? JSON.parse(savedSettings) : {};
            }
        }
        
        // 同步版本的getChatSettings（用于不支持async的地方）
        function getChatSettingsSync(characterId) {
            const savedSettings = localStorage.getItem(`chatSettings_${characterId}`);
            return savedSettings ? JSON.parse(savedSettings) : {};
        }

        // 格式化动态文字，支持分行和配图描述
        function formatMomentText(text) {
            if (!text) return '';
            
            // 替换换行符为<br>标签，支持分行显示
            let formattedText = text.replace(/\n/g, '<br>');
            
            // 处理配图描述：匹配*[配图：描述]*格式
            formattedText = formattedText.replace(/\*\[配图：([^\]]+)\]\*/g, function(match, description) {
                return `<span style="font-style: italic; color: #999; font-size: 13px; line-height: 1.4;">[配图：${description}]</span>`;
            });
            
            return formattedText;
        }

        // 调试角色动态头像
        function debugMomentAvatar(momentId) {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) {
                console.log('找不到动态元素');
                return;
            }
            
            // 从IndexedDB获取动态数据
            db.moments.get(parseInt(momentId)).then(moment => {
                console.log('=== 动态头像调试 ===');
                console.log('动态ID:', momentId);
                console.log('角色ID:', moment.characterId);
                console.log('保存的头像:', moment.avatar ? moment.avatar.substring(0, 50) + '...' : 'null');
                
                if (moment.characterId && moment.characterId !== 'user') {
                    const character = characters.find(c => c.id === moment.characterId);
                    if (character) {
                        console.log('找到角色:', character.name);
                        console.log('角色卡头像:', character.avatarUrl ? character.avatarUrl.substring(0, 50) + '...' : 'null');
                    } else {
                        console.log('找不到角色数据');
                    }
                }
                
                const avatarImg = momentElement.querySelector('.moment-avatar img');
                if (avatarImg) {
                    console.log('当前显示的头像URL:', avatarImg.src ? avatarImg.src.substring(0, 50) + '...' : 'null');
                }
            });
        }
        
        // 简单的头像数据修复
        async function fixAvatarData() {
            console.log('开始修复头像数据...');
            let fixedCount = 0;
            
            try {
                // 清理角色设置中的截断头像
                for (const character of characters) {
                    const chatSettings = await getChatSettings(character.id);
                    let needSave = false;
                    
                    if (chatSettings.aiDynamicAvatar) {
                        const avatar = chatSettings.aiDynamicAvatar;
                        if (avatar.startsWith('data:image/') && !avatar.includes('=') && avatar.split(',').length === 2) {
                            console.log(`清理${character.name}的动态头像设置`);
                            delete chatSettings.aiDynamicAvatar;
                            needSave = true;
                            fixedCount++;
                        }
                    }
                    
                    if (chatSettings.aiChatAvatar) {
                        const avatar = chatSettings.aiChatAvatar;
                        if (avatar.startsWith('data:image/') && !avatar.includes('=') && avatar.split(',').length === 2) {
                            console.log(`清理${character.name}的聊天头像设置`);
                            delete chatSettings.aiChatAvatar;
                            needSave = true;
                            fixedCount++;
                        }
                    }
                    
                    if (needSave) {
                        // 保存到IndexedDB而不是localStorage
                        await db.chatSettings.put({
                            id: character.id,
                            chatId: character.id,
                            settings: chatSettings
                        });
                    }
                }
                
                // 清理动态数据库中的截断头像
                const allMoments = await db.moments.toArray();
                let momentFixedCount = 0;
                
                for (const moment of allMoments) {
                    if (moment.avatar && moment.avatar.startsWith('data:image/')) {
                        // 检查是否是截断的头像（以VNEKhsVJik结尾的是截断的）
                        if (moment.avatar.endsWith('VNEKhsVJik') || moment.avatar.endsWith('VNEKhsVJik:1') || 
                            (!moment.avatar.includes('=') && moment.avatar.split(',').length === 2)) {
                            console.log(`清理动态 ${moment.id} 的截断头像`);
                            await db.moments.update(moment.id, { avatar: null });
                            momentFixedCount++;
                        }
                    }
                }
                
                const totalFixed = fixedCount + momentFixedCount;
                console.log(`修复完成: 清理了${fixedCount}个设置头像, ${momentFixedCount}个动态头像`);
                
                alert(`修复完成！\n清理了 ${fixedCount} 个设置中的截断头像\n清理了 ${momentFixedCount} 个动态中的截断头像\n\n请重新为角色设置头像`);
                
                if (totalFixed > 0) {
                    loadMoments();
                }
            } catch (error) {
                console.error('修复失败:', error);
                alert('修复失败: ' + error.message);
            }
        }

        // 页面卸载时清理后台定时器
        window.addEventListener('beforeunload', function() {
            clearAllBackgroundTimers();
            clearGlobalMomentsTimers();
        });
        
        // 🔥【调试功能】测试动态系统是否正常工作
        function debugMomentsSystem() {
            console.log('=== 动态系统调试信息 ===');
            console.log('角色数量:', characters ? characters.length : 0);
            console.log('全局定时器:', Object.keys(globalMomentsTimers));
            console.log('定时检查器状态:', globalMomentsCheckInterval ? '运行中' : '未运行');
            
            if (characters && characters.length > 0) {
                console.log('各角色设置:');
                characters.forEach(async (character, index) => {
                    const settings = await getChatSettings(character.id);
                    console.log(`${index + 1}. ${character.name}:`, {
                        backgroundMomentsEnabled: settings.backgroundMomentsEnabled,
                        backgroundMomentsFrequency: settings.backgroundMomentsFrequency,
                        scheduledMomentsEnabled: settings.scheduledMomentsEnabled,
                        scheduledMomentsTimes: settings.scheduledMomentsTimes
                    });
                });
            }
            
            console.log('=========================');
        }
        
        // 暴露调试函数到全局
        window.debugMomentsSystem = debugMomentsSystem;


        // 加载壁纸 - 使用IndexedDB（包含数据迁移）
        async function loadWallpaper() {
            try {
                // 先从IndexedDB加载
                const savedWallpaper = await db.wallpapers.get('main');
            
            if (savedWallpaper) {
                    selectedWallpaper = savedWallpaper.data;
                
                    if (savedWallpaper.type === 'image' && savedWallpaper.data.startsWith('data:image')) {
                    // 加载上传的图片
                        document.querySelector('.wallpaper').style.backgroundImage = `url(${savedWallpaper.data})`;
                    } else if (savedWallpaper.type === 'gradient' || savedWallpaper.data.startsWith('linear-gradient')) {
                    // 加载渐变背景
                        document.querySelector('.wallpaper').style.backgroundImage = savedWallpaper.data;
                } else {
                    // 加载纯色背景
                        document.querySelector('.wallpaper').style.backgroundColor = savedWallpaper.data;
                    document.querySelector('.wallpaper').style.backgroundImage = 'none';
                }
                
                document.querySelector('.wallpaper').style.backgroundSize = '100% 100%';
                document.querySelector('.wallpaper').style.backgroundPosition = 'center';
                } else {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localWallpaper = localStorage.getItem('wallpaper');
                    const wallpaperType = localStorage.getItem('wallpaperType');
                    
                    if (localWallpaper) {
                        console.log('检测到localStorage中的壁纸数据，开始迁移...');
                        selectedWallpaper = localWallpaper;
                        
                        // 迁移到IndexedDB
                        await db.wallpapers.add({
                            id: 'main',
                            type: wallpaperType || 'gradient',
                            data: localWallpaper
                        });
                        
                        if (wallpaperType === 'image' && localWallpaper.startsWith('data:image')) {
                            document.querySelector('.wallpaper').style.backgroundImage = `url(${localWallpaper})`;
                        } else if (wallpaperType === 'gradient' || localWallpaper.startsWith('linear-gradient')) {
                            document.querySelector('.wallpaper').style.backgroundImage = localWallpaper;
                        } else {
                            document.querySelector('.wallpaper').style.backgroundColor = localWallpaper;
                            document.querySelector('.wallpaper').style.backgroundImage = 'none';
                        }
                        
                        document.querySelector('.wallpaper').style.backgroundSize = '100% 100%';
                        document.querySelector('.wallpaper').style.backgroundPosition = 'center';
                        
                        console.log('壁纸数据迁移完成');
                    }
                }
            } catch (error) {
                console.error('加载壁纸失败:', error);
                // 如果IndexedDB失败，回退到localStorage
                const localWallpaper = localStorage.getItem('wallpaper');
                const wallpaperType = localStorage.getItem('wallpaperType');
                
                if (localWallpaper) {
                    selectedWallpaper = localWallpaper;
                    
                    if (wallpaperType === 'image' && localWallpaper.startsWith('data:image')) {
                        document.querySelector('.wallpaper').style.backgroundImage = `url(${localWallpaper})`;
                    } else if (wallpaperType === 'gradient' || localWallpaper.startsWith('linear-gradient')) {
                        document.querySelector('.wallpaper').style.backgroundImage = localWallpaper;
                    } else {
                        document.querySelector('.wallpaper').style.backgroundColor = localWallpaper;
                        document.querySelector('.wallpaper').style.backgroundImage = 'none';
                    }
                    
                    document.querySelector('.wallpaper').style.backgroundSize = '100% 100%';
                    document.querySelector('.wallpaper').style.backgroundPosition = 'center';
                }
            }
        }
        
        // 加载应用图标 - 使用IndexedDB（包含数据迁移）
        async function loadAppIcons() {
            try {
                // 先从IndexedDB加载
                const savedIcons = await db.appIcons.toArray();
                
                if (savedIcons.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('appIcons');
                    if (localStorageData) {
                        console.log('检测到localStorage中的应用图标数据，开始迁移...');
                        const localIcons = JSON.parse(localStorageData);
                        
                        // 转换为数组格式存储到IndexedDB
                        const iconArray = Object.keys(localIcons).map(appId => ({
                            id: appId,
                            appId: appId,
                            iconClass: localIcons[appId]
                        }));
                        
                        if (iconArray.length > 0) {
                            await db.appIcons.bulkAdd(iconArray);
                            console.log('应用图标数据迁移完成:', iconArray);
                        }
                        
                        // 应用图标
                        Object.keys(localIcons).forEach(appId => {
                            const iconElement = document.querySelector(`.app[onclick="showApp('${appId}')"] .app-icon i`);
                            if (iconElement) {
                                iconElement.className = localIcons[appId];
                            }
                        });
                    }
                } else {
                    // IndexedDB中有数据，直接使用
                    console.log('从IndexedDB加载应用图标数据:', savedIcons);
                    savedIcons.forEach(iconData => {
                        const iconElement = document.querySelector(`.app[onclick="showApp('${iconData.appId}')"] .app-icon i`);
                        if (iconElement) {
                            iconElement.className = iconData.iconClass;
                        }
                    });
                }
            } catch (error) {
                console.error('加载应用图标失败:', error);
                // 如果IndexedDB失败，回退到localStorage
                const localStorageData = localStorage.getItem('appIcons');
                if (localStorageData) {
                    const icons = JSON.parse(localStorageData);
                Object.keys(icons).forEach(appId => {
                    const iconElement = document.querySelector(`.app[onclick="showApp('${appId}')"] .app-icon i`);
                    if (iconElement) {
                        iconElement.className = icons[appId];
                    }
                });
                }
            }
        }
        
        // 加载API设置 - 使用IndexedDB
        async function loadApiSettings() {
            try {
                // 先从IndexedDB尝试加载
                const savedSettings = await db.apiSettings.get('main');
                if (savedSettings) {
                    apiSettings = savedSettings.settings;
                    console.log('🔧 [应用启动] 从IndexedDB加载API设置:', apiSettings);
                } else {
                    // 尝试从localStorage迁移
                    const localSettings = localStorage.getItem('apiSettings');
                    if (localSettings) {
                        console.log('🔧 [应用启动] 迁移API设置从localStorage到IndexedDB');
                        apiSettings = JSON.parse(localSettings);

                        // 保存到IndexedDB
                        await db.apiSettings.put({
                            id: 'main',
                            settings: apiSettings
                        });
                        console.log('🔧 [应用启动] 迁移完成，当前API设置:', apiSettings);
                    } else {
                        // 使用默认设置
                        console.log('🔧 [应用启动] 使用默认API设置');
                        apiSettings = {
                            type: 'gemini',
                            base: 'https://generativelanguage.googleapis.com/v1beta',
                            endpoint: '/chat/completions',
                            key: '',
                            model: 'gemini-2.0-flash-exp',
                            temperature: 0.70
                        };
                    }
                }

                // 旧版本API设置表单更新代码已清理 - 现在使用新版本的API设置系统
            } catch (error) {
                console.error('加载API设置失败:', error);
                // 旧版本默认设置代码已清理
            }
        }
        
        // 保存应用图标 - 使用IndexedDB
        async function saveAppIcons() {
            try {
                console.log('保存应用图标数据到IndexedDB...');
                
                const defaultIcons = {
                    'chat-screen': 'fas fa-comment-dots',
                    'forum-screen': 'fas fa-comments',
                    'game-screen': 'fas fa-gamepad',
                    'characters-screen': 'fas fa-user-friends',
                    'shop-screen': 'fas fa-shopping-bag',
                    'settings-screen': 'fas fa-cog'
                };
                
                if (selectedAppIcon) {
                    defaultIcons[selectedAppIcon.appId] = selectedAppIcon.iconClass;
                }
                
                // 转换为数组格式
                const iconArray = Object.keys(defaultIcons).map(appId => ({
                    id: appId,
                    appId: appId,
                    iconClass: defaultIcons[appId]
                }));
                
                // 清空现有数据并插入新数据
                await db.appIcons.clear();
                await db.appIcons.bulkAdd(iconArray);
                
                console.log('应用图标数据保存成功');
                
                // 刷新图标显示
                await loadAppIcons();
            } catch (error) {
                console.error('保存应用图标时发生错误:', error);
                // 如果IndexedDB失败，回退到localStorage
            const icons = {
                'chat-screen': 'fas fa-comment-dots',
                'weibo-screen': 'fab fa-weibo',
                'album-screen': 'fas fa-images',
                'characters-screen': 'fas fa-user-friends',
                'shop-screen': 'fas fa-shopping-bag',
                'settings-screen': 'fas fa-cog'
            };
            
            if (selectedAppIcon) {
                icons[selectedAppIcon.appId] = selectedAppIcon.iconClass;
            }
            
            localStorage.setItem('appIcons', JSON.stringify(icons));
            loadAppIcons();
            }
        }
        
        // 渲染消息列表
        function renderMessageList() {
            const messageList = document.getElementById('message-list');
            messageList.innerHTML = '';

            // 🔥【修改】为多选模式在app-header中添加按钮
            const chatHeaderActions = document.querySelector('#chat-screen .chat-header-actions');
            if (isMessageListMultiSelectMode) {
                // 隐藏原有的header按钮
                if (chatHeaderActions) {
                    chatHeaderActions.style.display = 'none';
                }

                // 🔥【新增】检查是否已存在多选按钮，避免重复添加
                let existingActions = document.querySelector('.chat-header-multiselect-actions');
                if (!existingActions) {
                    const multiselectActions = document.createElement('div');
                    multiselectActions.className = 'chat-header-multiselect-actions';
                    multiselectActions.innerHTML = `
                        <button class="multiselect-btn pin-btn" data-action="pin">
                            <i class="fas fa-thumbtack"></i>
                            <span>置顶</span>
                        </button>
                        <button class="multiselect-btn delete-btn" data-action="delete">
                            <i class="fas fa-trash"></i>
                            <span>删除</span>
                        </button>
                        <button class="multiselect-btn cancel-btn" data-action="cancel">
                            <i class="fas fa-times"></i>
                            <span>取消</span>
                        </button>
                    `;

                    // 🔥【修复】使用事件委托绑定点击事件，避免内联onclick问题
                    multiselectActions.onclick = function(e) {
                        const action = e.target.closest('[data-action]')?.dataset.action;
                        if (action === 'delete') {
                            deleteSelectedConversations();
                        } else if (action === 'cancel') {
                            exitMessageListMultiSelectMode();
                        } else if (action === 'pin') {
                            pinSelectedConversations();
                        }
                    };

                    // 🔥【修改】将按钮添加到消息列表页面的app-header中
                    const chatAppHeader = document.querySelector('#chat-screen .app-header');
                    if (chatAppHeader) {
                        chatAppHeader.appendChild(multiselectActions);
                    }
                }
            } else {
                // 🔥【新增】非多选模式时恢复原有按钮，移除多选按钮
                if (chatHeaderActions) {
                    chatHeaderActions.style.display = 'flex';
                }
                const existingActions = document.querySelector('.chat-header-multiselect-actions');
                if (existingActions) {
                    existingActions.remove();
                }
            }

            // 🔥【修复】只渲染存在于 contacts 列表中的单人对话
            const singleChats = characters.filter(character => contacts.includes(character.id));

            const sortedSingleChats = singleChats.sort((a, b) => {
                const aPinned = isPinned(a.id);
                const bPinned = isPinned(b.id);
                if (aPinned && !bPinned) return -1;
                if (!aPinned && bPinned) return 1;
                // 你可以在这里添加按最后消息时间的排序逻辑
                return 0;
            });

            sortedSingleChats.forEach(character => {
                // 直接使用角色对象，不需要再查找
                if (character) {
                    // 🔥【修复】获取该聊天的昵称设置
                    const savedSettings = localStorage.getItem(`chatSettings_${character.id}`);
                    const chatSettings = savedSettings ? JSON.parse(savedSettings) : {};
                    const displayName = chatSettings.aiChatNickname || character.name;
                    
                    const messages = chatMessages[character.id] || [];
                let lastMessageRaw = '暂无消息';
                
                if (messages.length > 0) {
                    const lastMsg = messages[messages.length - 1];
                    
                    // 🔥【修复】检查消息是否有效，防止undefined错误
                    if (!lastMsg) {
                        lastMessageRaw = '暂无消息';
                    } else if (lastMsg.type === 'user_photo') {
                        lastMessageRaw = '[照片]';
                    } else if (lastMsg.type === 'ai_image') {
                        lastMessageRaw = '[图片]';
                    } else if (lastMsg.type === 'voice_message') {
                        lastMessageRaw = '[语音]';
                    } else if (lastMsg.type === 'transfer') {
                        lastMessageRaw = '[转账]';
                    } else if (lastMsg.type === 'recalled_message') {
                        lastMessageRaw = '[撤回了一条消息]';
                    } else if (lastMsg.type === 'location') {
                        lastMessageRaw = '[位置]';
                    } else if (lastMsg.type === 'call_message') {
                        lastMessageRaw = '[通话消息]';
                    } else if (lastMsg.sender === 'system') {
                        lastMessageRaw = lastMsg.content || '[系统消息]';
                    } else if (lastMsg.isEmoji) {
                        lastMessageRaw = '[表情]';
                    } else {
                        lastMessageRaw = lastMsg.content || '';
                    }
                }
                
                const lastMessage = truncateText(String(lastMessageRaw || '暂无消息'), 30);
                    const lastTime = messages.length > 0 ? formatTime(messages[messages.length - 1].timestamp) : '刚刚';
                    
                    const messageItem = document.createElement('div');
                    const isPinnedConversation = isPinned(character.id);
                    messageItem.className = `message-item ${isPinnedConversation ? 'pinned' : ''} ${isMessageListMultiSelectMode && selectedConversations.includes(character.id) ? 'selected' : ''}`;
                    messageItem.dataset.conversationId = character.id; // 添加对话ID
                    
                    // 根据模式设置不同的点击事件
                    if (isMessageListMultiSelectMode) {
                        messageItem.onclick = () => toggleConversationSelection(character.id);
                    } else {
                        // 使用变量来控制点击行为
                        let isLongPress = false;
                        
                        messageItem.onclick = (e) => {
                            if (!isLongPress) {
                                startChat(character);
                            }
                            isLongPress = false; // 重置标志
                        };
                        
                        // 添加长按事件（支持移动端和桌面端）
                        let pressTimer;
                        
                        // 移动端触摸事件
                        messageItem.addEventListener('touchstart', (e) => {
                            e.stopPropagation(); // 阻止事件冒泡
                            pressTimer = setTimeout(() => {
                                console.log('触摸长按触发，角色ID:', character.id);
                                isLongPress = true; // 设置长按标志
                                enterMessageListMultiSelectMode(character.id);
                                e.preventDefault();
                            }, 800); // 800ms长按
                        });
                        
                        messageItem.addEventListener('touchend', (e) => {
                            if (pressTimer) {
                                clearTimeout(pressTimer);
                                pressTimer = null;
                            }
                        });
                        
                        messageItem.addEventListener('touchmove', (e) => {
                            if (pressTimer) {
                                clearTimeout(pressTimer);
                                pressTimer = null;
                            }
                        });
                        
                        // 桌面端鼠标事件
                        messageItem.addEventListener('mousedown', (e) => {
                            if (e.button === 0) { // 左键
                                e.stopPropagation(); // 阻止事件冒泡
                                pressTimer = setTimeout(() => {
                                    console.log('鼠标长按触发，角色ID:', character.id);
                                    isLongPress = true; // 设置长按标志
                                    enterMessageListMultiSelectMode(character.id);
                                    e.preventDefault();
                                }, 800); // 800ms长按
                            }
                        });
                        
                        messageItem.addEventListener('mouseup', (e) => {
                            if (pressTimer) {
                                clearTimeout(pressTimer);
                                pressTimer = null;
                            }
                        });
                        
                        messageItem.addEventListener('mouseleave', (e) => {
                            if (pressTimer) {
                                clearTimeout(pressTimer);
                                pressTimer = null;
                            }
                        });
                        
                        // 右键点击进入多选模式（桌面端）
                        messageItem.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            enterMessageListMultiSelectMode(character.id);
                        });
                    }
                    
                    // 🔥【新增】检查拉黑状态并生成状态指示器
                    let messageStatusIndicator = '';
                    if (character.isGroup === true) {
                        // 群聊检查屏蔽状态
                        const isMuted = isGroupMuted(character.id);
                        if (isMuted) {
                            messageStatusIndicator = '<div class="message-status-indicator muted" title="已屏蔽"><i class="fas fa-volume-mute"></i></div>';
                        }
                    } else {
                        // 单聊检查拉黑状态
                        const isUserBlocked = isBlocked('user', character.id);
                        const isCharacterBlocked = isBlocked(character.id, 'user');

                        if (isUserBlocked) {
                            messageStatusIndicator = '<div class="message-status-indicator blocked" title="已拉黑"><i class="fas fa-ban"></i></div>';
                        } else if (isCharacterBlocked) {
                            messageStatusIndicator = '<div class="message-status-indicator blocked-by" title="被对方拉黑"><i class="fas fa-exclamation-triangle"></i></div>';
                        }
                    }

                    // 🔥【新增】检查未读消息数量并生成未读提示
                    let unreadBadge = '';
                    const unreadCount = getUnreadCount(character.id);
                    if (unreadCount > 0) {
                        const displayCount = unreadCount > 99 ? '99+' : unreadCount.toString();
                        const badgeClass = unreadCount > 99 ? 'unread-badge large-count' : 'unread-badge';
                        unreadBadge = `<div class="${badgeClass}" title="${unreadCount}条未读消息">${displayCount}</div>`;
                    }

                    messageItem.innerHTML = `
                        ${isPinnedConversation ? '<div class="pin-indicator"><i class="fas fa-thumbtack"></i></div>' : ''}
                        ${isMessageListMultiSelectMode ? `
                            <div class="selection-checkbox ${selectedConversations.includes(character.id) ? 'selected' : ''}">
                                ${selectedConversations.includes(character.id) ? '<i class="fas fa-check check-icon-white"></i>' : ''}
                            </div>
                        ` : ''}
                        <div class="message-avatar-container">
                            <div class="message-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                                ${character.avatarUrl ? '' : displayName.charAt(0)}
                            </div>
                            ${unreadBadge}
                            ${messageStatusIndicator}
                        </div>
                        <div class="message-content">
                            <div class="message-name">${displayName}</div>
                            <div class="message-preview">${lastMessage}</div>
                        </div>
                        <div class="message-time">${lastTime}</div>
                    `;
                    
                    messageList.appendChild(messageItem);
                }
            });
            
            // 🔥【修改】渲染群聊 - 支持置顶排序
            const sortedGroups = [...groupChats].sort((a, b) => {
                const aPinned = isPinned(a.id);
                const bPinned = isPinned(b.id);
                if (aPinned && !bPinned) return -1;
                if (!aPinned && bPinned) return 1;
                return 0;
            });

            sortedGroups.forEach(group => {
                const messages = chatMessages[group.id] || [];
                let lastMessageRaw = '暂无消息';
                
                if (messages.length > 0) {
                    const lastMsg = messages[messages.length - 1];
                    
                    // 🔥【修复】检查消息是否有效，防止undefined错误
                    if (!lastMsg) {
                        lastMessageRaw = '暂无消息';
                    } else if (lastMsg.type === 'user_photo') {
                        lastMessageRaw = '[照片]';
                    } else if (lastMsg.type === 'ai_image') {
                        lastMessageRaw = '[图片]';
                    } else if (lastMsg.type === 'voice_message') {
                        lastMessageRaw = '[语音]';
                    } else if (lastMsg.type === 'transfer') {
                        lastMessageRaw = '[转账]';
                    } else if (lastMsg.type === 'recalled_message') {
                        lastMessageRaw = '[撤回了一条消息]';
                    } else if (lastMsg.type === 'location') {
                        lastMessageRaw = '[位置]';
                    } else if (lastMsg.type === 'call_message') {
                        lastMessageRaw = '[通话消息]';
                    } else if (lastMsg.sender === 'system') {
                        lastMessageRaw = lastMsg.content || '[系统消息]';
                    } else if (lastMsg.isEmoji) {
                        lastMessageRaw = '[表情]';
                    } else {
                        lastMessageRaw = lastMsg.content || '';
                    }
                }
                
                const lastMessage = truncateText(String(lastMessageRaw || '暂无消息'), 30);
                const lastTime = messages.length > 0 ? formatTime(messages[messages.length - 1].timestamp) : '刚刚';
                
                const messageItem = document.createElement('div');
                const isGroupPinned = isPinned(group.id);
                messageItem.className = `message-item ${isGroupPinned ? 'pinned' : ''} ${isMessageListMultiSelectMode && selectedConversations.includes(group.id) ? 'selected' : ''}`;
                messageItem.dataset.conversationId = group.id; // 添加对话ID
                
                // 根据模式设置不同的点击事件
                if (isMessageListMultiSelectMode) {
                    messageItem.onclick = () => toggleConversationSelection(group.id);
                } else {
                messageItem.onclick = () => startChat(group);
                    
                    // 添加长按事件（支持移动端和桌面端）
                    let pressTimer;
                    
                    // 移动端触摸事件
                    messageItem.addEventListener('touchstart', (e) => {
                        e.stopPropagation(); // 阻止事件冒泡
                        pressTimer = setTimeout(() => {
                            console.log('触摸长按触发，群聊ID:', group.id);
                            enterMessageListMultiSelectMode(group.id);
                            e.preventDefault();
                        }, 800); // 800ms长按
                    });
                    
                    messageItem.addEventListener('touchend', (e) => {
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                        }
                    });
                    
                    messageItem.addEventListener('touchmove', (e) => {
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                        }
                    });
                    
                    // 桌面端鼠标事件
                    messageItem.addEventListener('mousedown', (e) => {
                        if (e.button === 0) { // 左键
                            e.stopPropagation(); // 阻止事件冒泡
                            pressTimer = setTimeout(() => {
                                console.log('鼠标长按触发，群聊ID:', group.id);
                                enterMessageListMultiSelectMode(group.id);
                                e.preventDefault();
                            }, 800); // 800ms长按
                        }
                    });
                    
                    messageItem.addEventListener('mouseup', (e) => {
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                        }
                    });
                    
                    messageItem.addEventListener('mouseleave', (e) => {
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                        }
                    });
                    
                    // 右键点击进入多选模式（桌面端）
                    messageItem.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        enterMessageListMultiSelectMode(group.id);
                    });
                }
                
                // 🔥【新增】检查群聊屏蔽状态
                let groupStatusIndicator = '';
                const isMuted = isGroupMuted(group.id);
                if (isMuted) {
                    groupStatusIndicator = '<div class="message-status-indicator muted" title="已屏蔽"><i class="fas fa-volume-mute"></i></div>';
                }

                // 🔥【新增】检查群聊未读消息数量
                let groupUnreadBadge = '';
                const groupUnreadCount = getUnreadCount(group.id);
                if (groupUnreadCount > 0) {
                    const displayCount = groupUnreadCount > 99 ? '99+' : groupUnreadCount.toString();
                    const badgeClass = groupUnreadCount > 99 ? 'unread-badge large-count' : 'unread-badge';
                    groupUnreadBadge = `<div class="${badgeClass}" title="${groupUnreadCount}条未读消息">${displayCount}</div>`;
                }

                messageItem.innerHTML = `
                    ${isGroupPinned ? '<div class="pin-indicator"><i class="fas fa-thumbtack"></i></div>' : ''}
                    ${isMessageListMultiSelectMode ? `
                        <div class="selection-checkbox ${selectedConversations.includes(group.id) ? 'selected' : ''}">
                            ${selectedConversations.includes(group.id) ? '<i class="fas fa-check check-icon-white"></i>' : ''}
                        </div>
                    ` : ''}
                    <div class="message-avatar-container">
                        <div class="message-avatar" style="${group.avatarUrl ? `background-image: url(${group.avatarUrl}); background-size: cover; background-position: center;` : 'background-color: #4CAF50;'}">
                            ${group.avatarUrl ? '' : '群'}
                        </div>
                        ${groupUnreadBadge}
                        ${groupStatusIndicator}
                    </div>
                    <div class="message-content">
                                                        <div class="message-name">${group.name} <span class="group-member-count">(${group.members ? group.members.length + 1 : 1}人)</span></div>
                        <div class="message-preview">${lastMessage}</div>
                    </div>
                    <div class="message-time">${lastTime}</div>
                `;
                
                messageList.appendChild(messageItem);
            });

            // 🔥【新增】渲染完成后，为了测试，可以手动设置一些未读消息
            // 这个代码仅用于演示，实际使用时应该删除
            if (window.location.hash === '#test-unread') {
                // 为"一号"角色设置一些未读消息用于测试
                const testCharacter = characters.find(c => c.name === '一号');
                if (testCharacter) {
                    const oneHourAgo = Date.now() - 60 * 60 * 1000;
                    localStorage.setItem(`lastRead_${testCharacter.id}`, oneHourAgo.toString());
                }
            }
        }
        
        // 🔥【新增】计算未读消息数量
        function getUnreadCount(characterId) {
            const messages = chatMessages[characterId] || [];
            const lastReadTime = localStorage.getItem(`lastRead_${characterId}`);

            if (!lastReadTime) {
                // 如果没有记录最后阅读时间，认为所有消息都已读
                return 0;
            }

            const lastReadTimestamp = parseInt(lastReadTime);
            const unreadMessages = messages.filter(msg =>
                msg.timestamp > lastReadTimestamp && msg.sender !== 'user'
            );

            return unreadMessages.length;
        }

        // 🔥【新增】标记消息为已读
        function markAsRead(characterId) {
            const now = Date.now();
            localStorage.setItem(`lastRead_${characterId}`, now.toString());
        }

        // 🔥【新增】置顶相关函数
        function loadPinnedConversations() {
            const saved = localStorage.getItem('pinnedConversations');
            pinnedConversations = saved ? JSON.parse(saved) : [];
        }

        function savePinnedConversations() {
            localStorage.setItem('pinnedConversations', JSON.stringify(pinnedConversations));
        }

        function togglePinConversation(conversationId) {
            const index = pinnedConversations.indexOf(conversationId);
            if (index > -1) {
                pinnedConversations.splice(index, 1);
            } else {
                pinnedConversations.push(conversationId);
            }
            savePinnedConversations();
        }

        function isPinned(conversationId) {
            return pinnedConversations.includes(conversationId);
        }

        // 🔥【修改】置顶选中的对话 - 支持重新设置置顶
        async function pinSelectedConversations() {
            // 🔥【新增】重新设置置顶逻辑：清空现有置顶，只置顶当前选中的对话
            pinnedConversations = [...selectedConversations];

            savePinnedConversations();
            renderMessageList();
            exitMessageListMultiSelectMode();

            const count = selectedConversations.length;
            showToast(`已重新设置置顶，当前置顶 ${count} 个对话`, 'success');
        }

        // 渲染联系人列表（角色页面）- 按分组显示
        function renderContactList() {
            const contactList = document.querySelector('#contact-list .contact-section');
            if (!contactList) return;
            
            // 清空所有内容
            contactList.innerHTML = '';
            

            
            // 添加多选模式的头部
            if (isMultiSelectMode) {
                const headerDiv = document.createElement('div');
                headerDiv.className = 'multiselect-header';
                headerDiv.innerHTML = `
                    <div class="multiselect-info">
                        <i class="fas fa-check-circle multiselect-icon"></i>
                        <span class="multiselect-text">已选择 ${selectedCharacters.length} 个角色</span>
                    </div>
                    <div class="multiselect-actions">
                        <button onclick="showMoveToGroupModal()" class="multiselect-btn move-btn" title="移动到分组">
                            <i class="fas fa-folder"></i>
                            <span>移动</span>
                        </button>
                        <button onclick="deleteSelectedCharacters()" class="multiselect-btn delete-btn" title="删除选中角色">
                            <i class="fas fa-trash"></i>
                            <span>删除</span>
                        </button>
                        <button onclick="exitMultiSelectMode()" class="multiselect-btn cancel-btn" title="取消多选">
                            <i class="fas fa-times"></i>
                            <span>取消</span>
                        </button>
                    </div>
                `;
                contactList.appendChild(headerDiv);
            }
            
            // 分组管理模式的头部
            if (isGroupManageMode) {
                const manageHeaderDiv = document.createElement('div');
                manageHeaderDiv.className = 'group-manage-header';
                manageHeaderDiv.innerHTML = `
                    <div class="group-manage-info">
                        <i class="fas fa-cogs group-manage-icon"></i>
                        <span class="group-manage-text">分组管理模式</span>
                    </div>
                    <div class="group-manage-actions">
                        <button onclick="showCreateGroupModal()" class="multiselect-btn create-btn" title="新建分组">
                            <i class="fas fa-plus"></i>
                            <span>新建</span>
                        </button>
                        <button onclick="exitGroupManageMode()" class="multiselect-btn done-btn" title="完成管理">
                            <i class="fas fa-check"></i>
                            <span>完成</span>
                        </button>
                    </div>
                `;
                contactList.appendChild(manageHeaderDiv);
            }
            
            // 按分组渲染角色
            const sortedGroups = characterGroups.sort((a, b) => a.order - b.order);
            
            sortedGroups.forEach(group => {
                const groupCharacters = characters.filter(char => char.groupId === group.id);
                
                // 如果该分组没有角色且不是分组管理模式，跳过显示
                if (groupCharacters.length === 0 && !isGroupManageMode) return;
                
                // 创建分组标题
                const groupHeader = document.createElement('div');
                groupHeader.className = `group-header ${group.isDefault ? 'default-group' : 'custom-group'}`;
                
                let interactionIcon = '';
                if (group.canInteract && !group.isDefault) {
                    interactionIcon = '<i class="fas fa-comments group-interaction-icon" title="该分组角色可以在动态中互动"></i>';
                }
                
                if (isGroupManageMode) {
                    groupHeader.innerHTML = `
                        <div class="group-title-area">
                            <span class="group-title">${group.name} (${groupCharacters.length})</span>
                            ${interactionIcon}
                            <span class="group-count"></span>
                        </div>
                        <div class="group-manage-actions">
                            ${!group.isDefault ? `
                                <button onclick="editGroup('${group.id}')" class="edit-group-btn" title="编辑分组">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button onclick="deleteGroup('${group.id}')" class="delete-group-btn" title="删除分组">
                                    <i class="fas fa-trash"></i>
                                </button>
                            ` : ''}
                        </div>
                    `;
                } else {
                    const isCollapsed = localStorage.getItem(`group_collapsed_${group.id}`) === 'true';
                    groupHeader.innerHTML = `
                        <div class="group-title-area" onclick="toggleGroupCollapse('${group.id}')">
                            <i class="fas fa-chevron-${isCollapsed ? 'right' : 'down'} group-chevron"></i>
                            <span class="group-title">${group.name}</span>
                            ${interactionIcon}
                            <span class="group-count">${groupCharacters.length}/${groupCharacters.length}</span>
                        </div>
                    `;
                }
                
                contactList.appendChild(groupHeader);
                
                // 创建角色容器
                const charactersContainer = document.createElement('div');
                charactersContainer.className = 'group-characters';
                charactersContainer.id = `group-characters-${group.id}`;
                
                // 检查是否折叠
                const isCollapsed = localStorage.getItem(`group_collapsed_${group.id}`) === 'true';
                if (isCollapsed && !isGroupManageMode) {
                    charactersContainer.style.display = 'none';
                }
                
                // 渲染分组中的角色
                groupCharacters.forEach(character => {
                    const savedSettings = localStorage.getItem(`chatSettings_${character.id}`);
                    const chatSettings = savedSettings ? JSON.parse(savedSettings) : {};
                    const displayName = chatSettings.aiChatNickname || character.name;
                    
                    const contactItem = document.createElement('div');
                    contactItem.className = `contact-item ${isMultiSelectMode && selectedCharacters.includes(character.id) ? 'selected' : ''}`;
                    contactItem.dataset.characterId = character.id;
                    
                    // 根据模式设置不同的点击事件
                    if (isMultiSelectMode) {
                        contactItem.onclick = () => toggleCharacterSelection(character.id);
                    } else {
                        contactItem.onclick = () => editCharacterFromContactList(character.id);
                        
                        // 添加长按事件（支持触摸和鼠标）
                        let pressTimer;
                        
                        const startLongPress = (e) => {
                            pressTimer = setTimeout(() => {
                                // 长按直接弹出移动角色模态框
                                showMoveCharacterModal(character.id);
                                e.preventDefault();
                            }, 800);
                        };
                        
                        const cancelLongPress = () => {
                            clearTimeout(pressTimer);
                        };
                        
                        // 触摸事件
                        contactItem.addEventListener('touchstart', startLongPress);
                        contactItem.addEventListener('touchend', cancelLongPress);
                        contactItem.addEventListener('touchmove', cancelLongPress);
                        
                        // 鼠标事件（作为备选）
                        contactItem.addEventListener('mousedown', startLongPress);
                        contactItem.addEventListener('mouseup', cancelLongPress);
                        contactItem.addEventListener('mouseleave', cancelLongPress);
                        
                        // 右键点击
                        contactItem.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            // 右键直接弹出移动角色模态框
                            showMoveCharacterModal(character.id);
                        });
                    }
                    
                    // 🔥【修改】检查拉黑/屏蔽状态 - 修复群聊判断逻辑 + 添加调试
                    let statusIndicator = '';
                    if (character.isGroup === true) {
                        // 群聊检查屏蔽状态
                        const isMuted = isGroupMuted(character.id);
                        if (isMuted) {
                            statusIndicator = '<div class="contact-status-indicator muted" title="已屏蔽"><i class="fas fa-volume-mute"></i></div>';
                        }
                    } else {
                        // 单聊检查拉黑状态
                        const isUserBlocked = isBlocked('user', character.id);
                        const isCharacterBlocked = isBlocked(character.id, 'user');



                        if (isUserBlocked) {
                            statusIndicator = '<div class="contact-status-indicator blocked" title="已拉黑"><i class="fas fa-ban"></i></div>';
                        } else if (isCharacterBlocked) {
                            statusIndicator = '<div class="contact-status-indicator blocked-by" title="被对方拉黑"><i class="fas fa-exclamation-triangle"></i></div>';
                        }
                    }

                    contactItem.innerHTML = `
                        ${isMultiSelectMode ? `
                            <div class="selection-checkbox ${selectedCharacters.includes(character.id) ? 'selected' : ''}">
                                ${selectedCharacters.includes(character.id) ? '<i class="fas fa-check check-icon-white"></i>' : ''}
                            </div>
                        ` : ''}
                        <div class="message-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                            ${character.avatarUrl ? '' : displayName.charAt(0)}
                        </div>
                        <div class="contact-info">
                            <div class="message-name">${displayName}</div>
                            <div class="character-preview">${truncateText(character.bio || '暂无人设描述', 25)}</div>
                        </div>
                        ${statusIndicator}
                        ${isGroupManageMode ? `
                            <div class="move-character-btn" onclick="showMoveCharacterModal('${character.id}')" title="移动到其他分组">
                                <i class="fas fa-arrows-alt"></i>
                            </div>
                        ` : ''}
                    `;
                    
                    charactersContainer.appendChild(contactItem);
                });
                
                // 如果分组没有角色，显示提示
                if (groupCharacters.length === 0 && isGroupManageMode) {
                    const emptyDiv = document.createElement('div');
                    emptyDiv.className = 'empty-group-message';
                    emptyDiv.textContent = '该分组暂无角色';
                    charactersContainer.appendChild(emptyDiv);
                }
                
                contactList.appendChild(charactersContainer);
            });
            
            // 如果完全没有角色，显示提示
            if (characters.length === 0) {
                const emptyDiv = document.createElement('div');
                emptyDiv.className = 'empty-message';
                emptyDiv.textContent = '还没有角色，点击右上角+号创建角色吧！';
                contactList.appendChild(emptyDiv);
            }
        }

        // === 分组管理相关函数 ===
        function enterGroupManageMode() {
            isGroupManageMode = true;
            renderContactList();
            
            // 隐藏管理分组按钮
            const groupManageBtn = document.getElementById('group-manage-btn');
            if (groupManageBtn) {
                groupManageBtn.style.display = 'none';
            }
        }

        function exitGroupManageMode() {
            isGroupManageMode = false;
            renderContactList();
            
            // 显示管理分组按钮
            const groupManageBtn = document.getElementById('group-manage-btn');
            if (groupManageBtn) {
                groupManageBtn.style.display = 'flex';
            }
        }

        function toggleGroupCollapse(groupId) {
            const container = document.getElementById(`group-characters-${groupId}`);
            if (!container) return;
            
            const isCollapsed = container.style.display === 'none';
            container.style.display = isCollapsed ? 'block' : 'none';
            
            // 保存折叠状态
            localStorage.setItem(`group_collapsed_${groupId}`, !isCollapsed);
            
            // 更新箭头方向
            const chevron = document.querySelector(`[onclick="toggleGroupCollapse('${groupId}')"] .group-chevron`);
            if (chevron) {
                chevron.className = `fas fa-chevron-${isCollapsed ? 'down' : 'right'} group-chevron`;
            }
        }

        function showCreateGroupModal() {
            const modalHtml = `
                <div id="create-group-modal" class="modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">新建分组</div>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label>分组名称</label>
                                <input type="text" id="new-group-name" class="form-input" placeholder="请输入分组名称" maxlength="10">
                            </div>
                            <div class="form-group">
                                <label>
                                    <input type="checkbox" id="new-group-interaction" class="form-checkbox"> 
                                    允许该分组角色在动态中互动
                                </label>
                                <p class="form-help-text">开启后，该分组的角色可以在动态页面相互点赞、评论</p>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideCreateGroupModal()">取消</button>
                            <button class="modal-button modal-primary" onclick="createNewGroup()">创建</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            
            // 聚焦输入框
            setTimeout(() => {
                document.getElementById('new-group-name').focus();
            }, 100);
        }

        function hideCreateGroupModal() {
            const modal = document.getElementById('create-group-modal');
            if (modal) modal.remove();
        }

        async function createNewGroup() {
            const nameInput = document.getElementById('new-group-name');
            const interactionCheckbox = document.getElementById('new-group-interaction');
            
            const name = nameInput.value.trim();
            if (!name) {
                alert('请输入分组名称');
                nameInput.focus();
                return;
            }
            
            // 检查重名
            if (characterGroups.find(g => g.name === name)) {
                alert('分组名称已存在');
                nameInput.focus();
                return;
            }
            
            const newGroup = {
                id: 'group_' + Date.now(),
                name: name,
                order: characterGroups.length + 1,
                isDefault: false,
                canInteract: interactionCheckbox.checked
            };
            
            characterGroups.push(newGroup);
            await saveCharacterGroups();
            
            hideCreateGroupModal();
            renderContactList();
            showToast('分组创建成功', 'success');
        }

        function editGroup(groupId) {
            const group = characterGroups.find(g => g.id === groupId);
            if (!group || group.isDefault) return;
            
            const modalHtml = `
                <div id="edit-group-modal" class="modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">编辑分组</div>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label>分组名称</label>
                                <input type="text" id="edit-group-name" class="form-input" value="${group.name}" maxlength="10">
                            </div>
                            <div class="form-group">
                                <label>
                                    <input type="checkbox" id="edit-group-interaction" class="form-checkbox" ${group.canInteract ? 'checked' : ''}> 
                                    允许该分组角色在动态中互动
                                </label>
                                <p class="form-help-text">开启后，该分组的角色可以在动态页面相互点赞、评论</p>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideEditGroupModal()">取消</button>
                            <button class="modal-button modal-primary" onclick="updateGroup('${groupId}')">保存</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            
            // 聚焦输入框
            setTimeout(() => {
                document.getElementById('edit-group-name').focus();
            }, 100);
        }

        function hideEditGroupModal() {
            const modal = document.getElementById('edit-group-modal');
            if (modal) modal.remove();
        }

        async function updateGroup(groupId) {
            const nameInput = document.getElementById('edit-group-name');
            const interactionCheckbox = document.getElementById('edit-group-interaction');
            
            const name = nameInput.value.trim();
            if (!name) {
                alert('请输入分组名称');
                nameInput.focus();
                return;
            }
            
            // 检查重名（排除自己）
            if (characterGroups.find(g => g.name === name && g.id !== groupId)) {
                alert('分组名称已存在');
                nameInput.focus();
                return;
            }
            
            const groupIndex = characterGroups.findIndex(g => g.id === groupId);
            if (groupIndex !== -1) {
                characterGroups[groupIndex].name = name;
                characterGroups[groupIndex].canInteract = interactionCheckbox.checked;
                
                await saveCharacterGroups();
                
                hideEditGroupModal();
                renderContactList();
                showToast('分组更新成功', 'success');
            }
        }

        async function deleteGroup(groupId) {
            const group = characterGroups.find(g => g.id === groupId);
            if (!group || group.isDefault) return;
            
            const groupCharacters = characters.filter(char => char.groupId === groupId);
            
            let confirmMsg = `确定要删除分组"${group.name}"吗？`;
            if (groupCharacters.length > 0) {
                confirmMsg += `\n\n该分组下有 ${groupCharacters.length} 个角色，将被移动到"我的好友"分组。`;
            }
            
            if (!confirm(confirmMsg)) return;
            
            // 将该分组的角色移动到默认分组
            groupCharacters.forEach(character => {
                character.groupId = 'my_friends';
            });
            
            // 删除分组
            const groupIndex = characterGroups.findIndex(g => g.id === groupId);
            if (groupIndex !== -1) {
                characterGroups.splice(groupIndex, 1);
            }
            
            await Promise.all([
                saveCharacterGroups(),
                saveCharacters()
            ]);
            
            renderContactList();
            showToast('分组删除成功', 'success');
        }

        function showMoveCharacterModal(characterId) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;
            
            const availableGroups = characterGroups.filter(g => g.id !== character.groupId);
            
            const modalHtml = `
                <div id="move-character-modal" class="modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">移动角色：${character.name}</div>
                        </div>
                        <div class="modal-body">
                            <div class="group-list">
                                ${availableGroups.map(group => `
                                    <div class="group-option" onclick="moveCharacterToGroup('${characterId}', '${group.id}')">
                                        <span class="group-name">${group.name}</span>
                                        <i class="fas fa-chevron-right"></i>
                                    </div>
                                `).join('')}
                            </div>
                            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #eee;">
                                <div class="group-option" onclick="hideMoveCharacterModal(); enterMultiSelectMode('${characterId}');" style="color: #007AFF;">
                                    <span class="group-name">
                                        <i class="fas fa-check-square" style="margin-right: 6px;"></i>
                                        进入多选模式
                                    </span>
                                    <i class="fas fa-chevron-right"></i>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideMoveCharacterModal()">取消</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        function hideMoveCharacterModal() {
            const modal = document.getElementById('move-character-modal');
            if (modal) modal.remove();
        }

        async function moveCharacterToGroup(characterId, targetGroupId) {
            const characterIndex = characters.findIndex(c => c.id === characterId);
            if (characterIndex !== -1) {
                const oldGroupId = characters[characterIndex].groupId;
                characters[characterIndex].groupId = targetGroupId;
                
                await saveCharacters();
                hideMoveCharacterModal();
                renderContactList();
                
                const targetGroup = characterGroups.find(g => g.id === targetGroupId);
                showToast(`已移动到"${targetGroup.name}"分组`, 'success');
            }
        }

        function showMoveToGroupModal() {
            if (selectedCharacters.length === 0) {
                alert('请先选择要移动的角色');
                return;
            }
            
            const modalHtml = `
                <div id="move-to-group-modal" class="modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">移动 ${selectedCharacters.length} 个角色到分组</div>
                        </div>
                        <div class="modal-body">
                            <div class="group-list">
                                ${characterGroups.map(group => `
                                    <div class="group-option" onclick="moveSelectedCharactersToGroup('${group.id}')">
                                        <span class="group-name">${group.name}</span>
                                        <i class="fas fa-chevron-right"></i>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideMoveToGroupModal()">取消</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        function hideMoveToGroupModal() {
            const modal = document.getElementById('move-to-group-modal');
            if (modal) modal.remove();
        }

        async function moveSelectedCharactersToGroup(targetGroupId) {
            selectedCharacters.forEach(characterId => {
                const characterIndex = characters.findIndex(c => c.id === characterId);
                if (characterIndex !== -1) {
                    characters[characterIndex].groupId = targetGroupId;
                }
            });
            
            await saveCharacters();
            hideMoveToGroupModal();
            exitMultiSelectMode(); // 退出多选模式
            
            const targetGroup = characterGroups.find(g => g.id === targetGroupId);
            showToast(`已移动 ${selectedCharacters.length} 个角色到"${targetGroup.name}"分组`, 'success');
        }
        
        // 渲染角色列表
        function renderCharacterList() {
            const characterList = document.getElementById('character-list');
            // 检查元素是否存在，如果不存在就跳过（因为我们已经删除了人物应用）
            if (!characterList) {
                console.log('character-list元素不存在，跳过渲染');
                return;
            }
            
            characterList.innerHTML = '';
            
            characters.forEach(character => {
                const characterItem = document.createElement('div');
                characterItem.className = 'character-item';
                characterItem.onclick = () => editCharacter(character.id);
                
                characterItem.innerHTML = `
                    <div class="character-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                        ${character.avatarUrl ? '' : character.name.charAt(0)}
                    </div>
                    <div class="character-info">
                        <div class="character-name">${character.name}</div>
                        <div class="character-bio">${truncateText(character.bio, 50)}</div>
                    </div>
                `;
                
                characterList.appendChild(characterItem);
            });
        }
        

        
        // 当前显示的消息数量限制
        let currentMessageOffset = 0;
        const MESSAGE_LIMIT = 50;
        
        // 🔥【新增】同步包装函数，用于向后兼容
        function renderChatMessages(characterId, loadMore = false) {
            renderChatMessagesAsync(characterId, loadMore).catch(error => {
                console.error('渲染聊天消息失败:', error);
            });
        }

        // 渲染聊天消息（异步版本）
        async function renderChatMessagesAsync(characterId, loadMore = false) {
            const messagesContainer = document.getElementById('api-chat-messages');
            const allMessages = chatMessages[characterId] || [];
            const chatSettings = await getAsyncChatSettings(characterId); // 🔥【修复】使用异步版本确保获取正确的设置
            
            if (!loadMore) {
                // 重新渲染时清空容器并重置偏移量
                messagesContainer.innerHTML = '';
                currentMessageOffset = Math.max(0, allMessages.length - MESSAGE_LIMIT);
            }
            
            // 应用聊天背景
            applyChatBackground();

            // 🔥【修复】确保气泡样式在消息渲染前应用
            applyBubbleStyle();
            
            // 如果没有消息，显示空状态提示
            if (allMessages.length === 0) {
                const displayName = chatSettings.aiChatNickname || currentChatCharacter.name;
                const emptyState = document.createElement('div');
                emptyState.className = 'empty-chat-state';
                emptyState.innerHTML = `
                    <div>开始和 ${displayName} 聊天吧</div>
                `;
                messagesContainer.appendChild(emptyState);
                return;
            }
            
            // 如果不是加载更多，且有更多历史消息，显示"查看历史消息"按钮
            if (!loadMore && currentMessageOffset > 0) {
                const loadMoreBtn = document.createElement('div');
                loadMoreBtn.className = 'load-more-messages';
                loadMoreBtn.innerHTML = `
                    <div class="load-more-content">
                        <i class="fas fa-chevron-up"></i>
                        <span>查看历史消息 (${currentMessageOffset}条)</span>
                    </div>
                `;
                loadMoreBtn.onclick = () => loadMoreMessages(characterId);
                messagesContainer.appendChild(loadMoreBtn);
            }
            
            // 🔥【修复】过滤掉线下模式的消息，不在线上聊天界面显示
            const onlineMessages = allMessages.filter(msg => !msg.isOfflineMode);

            // 重新计算偏移量，基于过滤后的消息
            const adjustedOffset = loadMore ?
                Math.max(0, onlineMessages.length - MESSAGE_LIMIT) :
                Math.max(0, onlineMessages.length - MESSAGE_LIMIT);

            // 获取要显示的消息
            const messagesToShow = loadMore ?
                onlineMessages.slice(Math.max(0, adjustedOffset - MESSAGE_LIMIT), adjustedOffset) :
                onlineMessages.slice(adjustedOffset);
            
            // 获取时间戳设置
            const timestampEnabled = chatSettings.timestampEnabled !== false; // 默认为true
            const timestampPosition = chatSettings.timestampPosition || 'center';
            
            let lastTimestamp = 0;
            
            messagesToShow.forEach((message, index) => {
                // 处理系统消息（如戳一戳、头像更换、撤回等）
                if (message.sender === 'system') {
                    // 🔥【移除】不再处理拉黑系统消息，因为它们不再保存到聊天记录中
                    // 拉黑提示现在由 addBlockedIndicatorToMessage 函数直接在每条消息下方添加

                    if (message.isPoke) {
                    const systemContainer = document.createElement('div');
                    systemContainer.className = 'poke-system-container';
                    const systemMessage = document.createElement('div');
                    systemMessage.className = 'poke-system-message';
                    systemMessage.textContent = message.content;
                    systemContainer.appendChild(systemMessage);
                    messagesContainer.appendChild(systemContainer);
                    } else if (message.type === 'recalled_message') {
                        // 🔥【新增】处理撤回消息的显示
                        const centerContainer = document.createElement('div');
                        centerContainer.style.display = 'flex';
                        centerContainer.style.justifyContent = 'center';
                        centerContainer.style.margin = '4px 0';
                        centerContainer.dataset.messageId = message.id; // 🔥【修复】添加消息ID以支持选择
                        
                        const recallElement = document.createElement('div');
                        recallElement.className = 'recalled-message';
                        
                        // 解析撤回消息内容（格式：xxx 撤回了一条消息\n原文：xxx）
                        const lines = message.content.split('\n');
                        const mainText = lines[0]; // 主要提示文字
                        const originalText = lines[1]; // 原文部分
                        
                        recallElement.textContent = mainText;
                        
                        // 如果有原文，添加原文显示
                        if (originalText && originalText.startsWith('原文：')) {
                            const originalDiv = document.createElement('div');
                            originalDiv.className = 'original-text';
                            originalDiv.textContent = originalText;
                            recallElement.appendChild(originalDiv);
                        }
                        
                        centerContainer.appendChild(recallElement);
                        messagesContainer.appendChild(centerContainer);
                        
                        // 🔥【修复】为撤回消息添加选择功能
                        addMessageLongPressListener(centerContainer, message.id);
                    } else if (message.type === 'call_record') {
                        // 处理通话记录消息
                        const centerContainer = document.createElement('div');
                        centerContainer.className = 'message-wrapper system';
                        centerContainer.dataset.messageId = message.id;
                        
                        const callRecordElement = document.createElement('div');
                        callRecordElement.className = 'call-record-message';
                        
                        // 根据通话状态设置不同的图标和样式
                        const callIcon = document.createElement('i');
                        
                        if (message.callType === 'outgoing') {
                            callIcon.className = 'fas fa-phone-alt';
                        } else if (message.callType === 'incoming') {
                            if (message.callStatus === 'rejected') {
                                callIcon.className = 'fas fa-phone-slash';
                                callRecordElement.classList.add('missed');
                            } else {
                                callIcon.className = 'fas fa-phone';
                            }
                        } else if (message.callType === 'ended') {
                            callIcon.className = 'fas fa-phone';
                            callRecordElement.classList.add('completed');
                        }
                        
                        callRecordElement.appendChild(callIcon);
                        
                        const callTextElement = document.createElement('span');
                        callTextElement.textContent = message.content;
                        callRecordElement.appendChild(callTextElement);
                        
                        // 如果有通话时长，则显示（仅在callType为ended时显示）
                        if (message.duration && message.callType === 'ended') {
                            const durationElement = document.createElement('span');
                            durationElement.className = 'call-record-duration';
                            durationElement.textContent = message.duration;
                            callRecordElement.appendChild(durationElement);
                        }
                        
                        centerContainer.appendChild(callRecordElement);
                        messagesContainer.appendChild(centerContainer);
                    } else if (message.type === 'call_message') {
                        // 🔥【新增】处理通话消息 - 显示为简单的文本消息
                        const centerContainer = document.createElement('div');
                        centerContainer.className = 'message-wrapper system';
                        centerContainer.dataset.messageId = message.id;
                        
                        const callMessageElement = document.createElement('div');
                        callMessageElement.className = 'system-message';
                        callMessageElement.style.fontStyle = 'italic';
                        callMessageElement.style.color = '#888';
                        callMessageElement.textContent = `📞 通话: ${message.content}`;
                        
                        centerContainer.appendChild(callMessageElement);
                        messagesContainer.appendChild(centerContainer);
                    } else {
                        // 🔥【修复】其他系统消息（如头像更换）- 使用居中容器
                        const centerContainer = document.createElement('div');
                        centerContainer.style.display = 'flex';
                        centerContainer.style.justifyContent = 'center';
                        centerContainer.style.margin = '4px 0';

                        const systemContainer = document.createElement('div');
                        // 🔥【美化】检查是否为好友添加成功消息，应用特殊样式
                        if (message.isFriendAddedMessage) {
                            systemContainer.className = 'friend-added-system-message';
                        } else {
                            systemContainer.className = 'system-message';
                        }
                        systemContainer.textContent = message.content;

                        centerContainer.appendChild(systemContainer);
                        messagesContainer.appendChild(centerContainer);
                    }
                    return;
                }
                
                // 添加居中时间戳（如果启用且位置为居中）
                if (timestampEnabled && timestampPosition === 'center') {
                    const currentTime = new Date(message.timestamp);
                    const timeDiff = currentTime - lastTimestamp;
                    
                    // 如果距离上条消息超过5分钟，显示时间戳
                    if (index === 0 || timeDiff > 5 * 60 * 1000) {
                        const timestampDiv = document.createElement('div');
                        timestampDiv.className = 'timestamp timestamp-center';
                        timestampDiv.textContent = formatTimestamp(message.timestamp);
                        messagesContainer.appendChild(timestampDiv);
                        lastTimestamp = currentTime;
                    }
                }
                
                const messageContainer = document.createElement('div');
                // 检查是否是纯表情包消息
                const isEmojiOnly = message.isEmoji && !message.content;
                messageContainer.className = `message-container ${message.sender}${chatSettings.hideAvatars ? ' no-avatar' : ''}${isEmojiOnly ? ' emoji-only' : ''}`;
                messageContainer.dataset.messageId = message.id; // 添加消息ID数据属性
                
                if (message.sender === 'received') {
                    // ==== 群聊支持 ====
                    let character = characters.find(c => c.id === characterId);
                    let isGroup = false;
                    let group = null;
                    if (!character) {
                        group = groupChats.find(g => g.id === characterId);
                        if (group) {
                            isGroup = true;
                        }
                    }
                    
                    let displayAvatar = '';
                    let displayName = '';
                    let color = '#4CAF50';
                    
                    if (isGroup && group) {
                        // 群聊：根据消息的senderId或name查找成员
                        let member = null;
                        console.log('🔍 [消息渲染] 群聊消息渲染 - senderId:', message.senderId, 'name:', message.name);
                        console.log('🔍 [消息渲染] 群成员列表:', group.members);
                        console.log('🔍 [消息渲染] 完整消息对象:', message);

                        // 表情包消息处理

                        if (message.senderId) {
                            member = group.members.find(m => m.id === message.senderId);
                            console.log('🔍 [消息渲染] 通过senderId找到成员:', member);
                            console.log('🔍 [消息渲染] senderId查找详情:', {
                                messageSenderId: message.senderId,
                                memberIds: group.members.map(m => m.id),
                                foundMember: member
                            });
                        } else if (message.name) {
                            member = group.members.find(m => m.name === message.name);
                            console.log('🔍 [消息渲染] 通过name找到成员:', member);
                            console.log('🔍 [消息渲染] name查找详情:', {
                                messageName: message.name,
                                memberNames: group.members.map(m => m.name),
                                foundMember: member
                            });
                        }

                        // 🔥【修复】确保群聊表情包消息正确显示发送者
                        if (member) {
                            displayAvatar = member.avatarUrl || '';
                            displayName = member.name;
                            color = member.color || '#4CAF50';
                        } else {
                            // 如果没找到成员，使用消息中的name作为显示名称
                            displayAvatar = '';
                            displayName = message.name || '群成员';
                            color = '#4CAF50';
                            console.warn('🔍 [消息渲染] 未找到群成员，使用消息name:', message.name);
                        }

                        // 头像和显示名处理完成
                    } else if (character) {
                        // 单聊
                        displayAvatar = chatSettings.aiDynamicAvatar || chatSettings.aiChatAvatar || character.avatarUrl;
                        displayName = chatSettings.aiChatNickname || character.name;
                        color = character.color || '#4CAF50';
                    
                    // 头像选择逻辑
                    } else {
                        // 兜底，防止报错
                        displayAvatar = '';
                        displayName = '未知';
                        color = '#4CAF50';
                    }
                    
                    // 🔥【新增】获取气泡样式 - 群聊中使用成员专属颜色
                    let bubbleColor = chatSettings.aiBubbleColor || '#f0f0f0';
                    
                    // 如果是群聊且有成员专属颜色设置，使用成员专属颜色
                    if (isGroup && group && message.senderId && chatSettings.memberBubbleColors) {
                        const memberColor = chatSettings.memberBubbleColors[message.senderId];
                        if (memberColor) {
                            bubbleColor = memberColor;
                        }
                    }
                    
                    const bubbleOpacity = chatSettings.aiBubbleOpacity || '1';
                    const textColor = isLightColor(bubbleColor) ? '#333' : '#fff';
                    const bubblePadding = chatSettings.bubblePadding || '12';
                    
                    // 将透明度应用到背景色而不是整个元素
                    const transparentBubbleColor = convertColorWithOpacity(bubbleColor, bubbleOpacity);
                    
                    // 🔥 处理特殊消息类型
                    let messageContent = '';
                    
                    if (message.type === 'user_photo') {
                        // 角色发送的"伪照片" - 使用与用户相同的结构
                        messageContent = `
                            <div class="dreamy-photo-container" onclick="togglePhotoText(this, '${(message.photoDescription || message.content).replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')">
                                <div class="dreamy-photo">
                                    <div class="photo-misty-bg"></div>
                                    <div class="photo-badge">
                                        <i class="fas fa-image"></i>
                                    </div>
                                    <div class="sparkle-container">
                                        <div class="sparkle sparkle-1">✨</div>
                                        <div class="sparkle sparkle-2">⭐</div>
                                        <div class="sparkle sparkle-3">✨</div>
                                        <div class="sparkle sparkle-4">⭐</div>
                                        <div class="sparkle sparkle-5">💫</div>
                                    </div>
                                    <div class="photo-text-overlay" style="display: none;">
                                        <div class="photo-description">${(message.photoDescription || message.content)}</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'location') {
                        // 角色发送的位置消息 - 使用与用户相同的结构
                        messageContent = `
                            <div class="location-card" onclick="showLocationDetail('${message.locationName}')">
                                <div class="location-card-header">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
                                        <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                    </svg>
                                    ${message.locationName}
                                </div>
                                <div class="location-card-map">
                                    <div class="map-background"></div>
                                    <div class="map-roads">
                                        <div class="road road-horizontal" style="top: 35%; width: 100%;"></div>
                                        <div class="road road-vertical" style="left: 40%; height: 100%;"></div>
                                        <div class="road road-horizontal" style="top: 65%; width: 70%; left: 30%;"></div>
                                    </div>
                                    <div class="map-buildings">
                                        <div class="building" style="top: 15%; left: 20%; width: 12px; height: 10px;"></div>
                                        <div class="building" style="top: 25%; left: 60%; width: 14px; height: 12px;"></div>
                                        <div class="building green" style="top: 50%; left: 15%; width: 8px; height: 8px;"></div>
                                        <div class="building" style="top: 70%; left: 70%; width: 10px; height: 8px;"></div>
                                        <div class="building green" style="top: 10%; left: 75%; width: 6px; height: 6px;"></div>
                                        <div class="building green" style="top: 75%; left: 25%; width: 7px; height: 7px;"></div>
                                    </div>
                                    <div class="map-marker">
                                        <div class="marker-pin">
                                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                                                <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                            </svg>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'voice_message') {
                        // 过滤掉括号中的描述性内容，保留实际说话内容
                        const cleanVoiceContent = message.content.replace(/\([^)]*\)\s*/g, '').trim();
                        const voiceDuration = message.duration || Math.max(1, Math.ceil(cleanVoiceContent.length / 8));
                        
                        // AI语音消息 - 使用和用户语音消息一样的结构
                        messageContent = `
                            <div class="voice-message-container received">
                                <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                                    <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${cleanVoiceContent}">
                                        <div class="voice-wave">
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                        </div>
                                        <div class="voice-duration">${voiceDuration}"</div>
                                    ${message.edited ? `<div class="message-edited-indicator">已编辑</div>` : ""}
                                    </div>
                                </div>
                                <div class="voice-text-content">${cleanVoiceContent}</div>
                            </div>
                        `;
                    } else if (message.type === 'ai_image') {
                        // AI生成的图片 - 使用星星emoji卡片样式
                        const imageDesc = message.imageDescription || message.content || 'AI描述的图片';
                        messageContent = `
                            <div class="dreamy-photo-container" onclick="togglePhotoText(this, '${imageDesc.replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')">
                                <div class="dreamy-photo">
                                    <div class="photo-misty-bg"></div>
                                    <div class="photo-badge">
                                        <i class="fas fa-image"></i>
                                    </div>
                                    <div class="sparkle-container">
                                        <div class="sparkle sparkle-1">✨</div>
                                        <div class="sparkle sparkle-2">⭐</div>
                                        <div class="sparkle sparkle-3">✨</div>
                                        <div class="sparkle sparkle-4">⭐</div>
                                        <div class="sparkle sparkle-5">💫</div>
                                    </div>
                                    <div class="photo-text-overlay" style="display: none;">
                                        <div class="photo-description">${imageDesc}</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'transfer') {
                        // 转账消息
                        const isUser = message.role === 'user';
                        const heartIcon = isUser ? '💕' : '💖';
                        const titleText = isUser ? '你发起的转账' : '收到转账';
                        let cardClass = '';
                        let statusHtml = '';
                        let clickHandler = '';
                        
                        if (message.status === 'accepted') {
                            statusHtml = `<div class="transfer-status">${isUser ? '对方已收款' : '已收款'}</div>`;
                            cardClass = 'accepted';
                        } else if (message.status === 'rejected') {
                            statusHtml = `<div class="transfer-status">${isUser ? '对方已退回' : '已退回'}</div>`;
                            cardClass = 'rejected';
                        } else if (!isUser) {
                            // AI发来的转账且未处理，添加点击处理
                            clickHandler = `onclick="showTransferConfirmDialog(${JSON.stringify(message).replace(/"/g, '&quot;')})"`;
                        }
                        
                        messageContent = `
                            <div class="transfer-message-container received">
                                <div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}" ${clickHandler}>
                                    <div class="transfer-title">${heartIcon} ${titleText}</div>
                                    <div class="transfer-amount">¥ ${Number(message.amount).toFixed(2)}</div>
                                    <div class="transfer-note">${message.note || '转账'}</div>
                                    ${statusHtml}
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'friend_request') {
                        // 🔥【新增】AI主动发送的好友申请
                        messageContent = `
                            <div class="friend-request-container">
                                <div class="friend-request-card">
                                    <div class="friend-request-icon">👋</div>
                                    <div class="friend-request-title">好友申请</div>
                                    <div class="friend-request-message">${message.message || '想和你重新做朋友'}</div>
                                    <div class="friend-request-actions">
                                        <button class="friend-request-btn accept" onclick="handleAIFriendRequest('${currentChatCharacter?.id}', true, '${message.id}')">同意</button>
                                        <button class="friend-request-btn reject" onclick="handleAIFriendRequest('${currentChatCharacter?.id}', false, '${message.id}')">拒绝</button>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        // 普通文本消息
                        const chatMode = chatSettings.chatMode || 'online';
                        let processedContent = message.content;

                        if (chatMode === 'offline') {
                            processedContent = processOfflineContent(message.content);
                        }

                        // 处理@内容
                        processedContent = processMentions(processedContent);

                        // 如果有引用消息，在内容前添加引用显示
                        if (message.replyTo) {
                            messageContent = generateReplyHTML(message.replyTo) + processedContent;
                        } else {
                            messageContent = processedContent;
                        }
                    }
                    
                    let avatarHtml = '';
                    if (!chatSettings.hideAvatars) {
                        avatarHtml = `
                            <div class="message-avatar" style="background-color: ${color}; ${displayAvatar ? `background-image: url(${displayAvatar}); background-size: cover; background-position: center;` : ''}" ${character ? `onclick="pokeCharacter('${character.id}')" title="戳一戳"` : `title="${displayName}"`}>
                                ${displayAvatar ? '' : displayName.charAt(0)}
                                ${timestampEnabled && timestampPosition === 'avatar' ? `<div class="timestamp timestamp-avatar">${formatTimeOnly(message.timestamp)}</div>` : ''}
                            </div>
                        `;
                    }
                    
                    let bubbleHtml = '';
                    if (message.type === 'voice_message' || message.type === 'transfer' || message.type === 'user_photo' || message.type === 'location' || message.type === 'ai_image' || message.type === 'friend_request') {
                        // 语音消息、转账消息、照片、位置消息和AI图片消息不需要额外的气泡包裹
                        bubbleHtml = messageContent;
                    } else {
                        // 普通消息用气泡包裹
                        bubbleHtml = `
                                                    <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                                ${messageContent}
                                ${message.image && !message.type ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}
                                ${message.edited ? `<div class="message-edited-indicator">已编辑</div>` : ''}
                                ${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                ${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}
                            </div>
                    `;
                    }
                    
      // 🔥【修复】群聊昵称显示 - 特别处理语音消息、转账消息、照片卡片和位置信息
      if (isGroup && group && displayName !== '群成员') {
    messageContainer.classList.add('group-message-item');
    const senderNameHtml = `<div class="sender-name">${displayName}</div>`;

    if (message.type === 'voice_message' || message.type === 'transfer' || message.type === 'ai_image' || message.type === 'user_photo' || message.type === 'location' || message.type === 'friend_request') {
        // 🔥【修复】对于语音消息、转账消息、AI图片消息、照片卡片和位置信息，昵称需要在容器外部
    messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    } else {
        // 普通消息的处理（包括表情包消息）
        messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    }
} else {
                    messageContainer.innerHTML = avatarHtml + bubbleHtml;
}
                } else {
                    // 获取我的显示头像和气泡样式
let myDisplayAvatar = chatSettings.myChatAvatar; // 优先使用聊天专属设置里的头像
let myDisplayName = chatSettings.myChatNickname; // 优先使用聊天专属设置里的昵称
                    
// 如果专属设置里没有，则进行二次查找（作为保险措施）
if ((!myDisplayAvatar || !myDisplayName) && chatSettings.selectedIdentityId) {
                        const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
    if (selectedPersona) {
        // 如果头像为空，则使用身份头像
        if (!myDisplayAvatar) myDisplayAvatar = selectedPersona.avatarUrl;
        // 如果昵称为空，则使用身份昵称
        if (!myDisplayName) myDisplayName = selectedPersona.name;
                        }
                    }
                    
                    const myBubbleColor = chatSettings.myBubbleColor || '#007AFF';
                    const myBubbleOpacity = chatSettings.myBubbleOpacity || '1';
                    const myTextColor = isLightColor(myBubbleColor) ? '#333' : '#fff';
                    const myBubblePadding = chatSettings.bubblePadding || '12';
                    
                    // 将透明度应用到背景色而不是整个元素
                    const transparentMyBubbleColor = convertColorWithOpacity(myBubbleColor, myBubbleOpacity);
                    
                    // 处理用户的特殊消息类型
                    let myMessageContent = '';
                    if (message.type === 'user_photo') {
                        // 用户发送的"照片"（文字描述）
                        myMessageContent = `
                            <div class="dreamy-photo-container" onclick="togglePhotoText(this, '${(message.photoDescription || message.content).replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')">
                                <div class="dreamy-photo">
                                    <div class="photo-misty-bg"></div>
                                    <div class="photo-badge">
                                        <i class="fas fa-image"></i>
                                    </div>
                                    <div class="sparkle-container">
                                        <div class="sparkle sparkle-1">✨</div>
                                        <div class="sparkle sparkle-2">⭐</div>
                                        <div class="sparkle sparkle-3">✨</div>
                                        <div class="sparkle sparkle-4">⭐</div>
                                        <div class="sparkle sparkle-5">💫</div>
                                    </div>
                                    <div class="photo-text-overlay" style="display: none;">
                                        <div class="photo-description">${(message.photoDescription || message.content)}</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'voice') {
                        // 用户发送的语音消息
                        myMessageContent = `
                            <div class="voice-message-container sent">
                                <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                                    <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${message.content}">
                                        <div class="voice-wave">
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                        </div>
                                        <div class="voice-duration">${message.duration || Math.max(1, Math.ceil(message.content.length / 8))}"</div>
                                    ${message.edited ? `<div class="message-edited-indicator">已编辑</div>` : ""}
                                    </div>
                                    ${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                    ${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                </div>
                                <div class="voice-text-content">${message.content}</div>
                            </div>
                        `;
                    } else if (message.type === 'transfer') {
                        // 用户转账消息 - 在renderChatMessages中处理
                        let cardClass = '';
                        let statusHtml = '';
                        
                        if (message.status === 'accepted') {
                            statusHtml = `<div class="transfer-status">对方已收款</div>`;
                            cardClass = 'accepted';
                        } else if (message.status === 'rejected') {
                            statusHtml = `<div class="transfer-status">对方已退回</div>`;
                            cardClass = 'rejected';
                        }
                        
                        myMessageContent = `
                            <div class="transfer-message-container sent">
                                <div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}">
                                    <div class="transfer-title">💕 你发起的转账</div>
                                    <div class="transfer-amount">¥ ${Number(message.amount).toFixed(2)}</div>
                                    <div class="transfer-note">${message.note || '转账'}</div>
                                    ${statusHtml}
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'location') {
                        // 用户发送的位置消息
                        myMessageContent = `
                            <div class="location-message-container sent">
                                <div class="location-card" onclick="showLocationDetail('${message.locationName}')">
                                    <div class="location-card-header">
                                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
                                            <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                        </svg>
                                        ${message.locationName}
                                    </div>
                                    <div class="location-card-map">
                                        <div class="map-background"></div>
                                        <div class="map-roads">
                                            <div class="road road-horizontal" style="top: 35%; width: 100%;"></div>
                                            <div class="road road-vertical" style="left: 40%; height: 100%;"></div>
                                            <div class="road road-horizontal" style="top: 65%; width: 70%; left: 30%;"></div>
                                        </div>
                                        <div class="map-buildings">
                                            <div class="building" style="top: 15%; left: 20%; width: 12px; height: 10px;"></div>
                                            <div class="building" style="top: 25%; left: 60%; width: 14px; height: 12px;"></div>
                                            <div class="building green" style="top: 50%; left: 15%; width: 8px; height: 8px;"></div>
                                            <div class="building" style="top: 70%; left: 70%; width: 10px; height: 8px;"></div>
                                            <div class="building green" style="top: 10%; left: 75%; width: 6px; height: 6px;"></div>
                                            <div class="building green" style="top: 75%; left: 25%; width: 7px; height: 7px;"></div>
                                        </div>
                                        <div class="map-marker">
                                            <div class="marker-pin">
                                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                                                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                                </svg>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        // 🔥【修复】处理多模态消息或普通文本消息
                        if (Array.isArray(message.content)) {
                            // 新的多模态格式
                            const textPart = message.content.find(p => p.type === 'text');
                            const imagePart = message.content.find(p => p.type === 'image_url');

                            let baseContent = textPart?.text || '';

                            // 如果有引用消息，在内容前添加引用显示
                            if (message.replyTo) {
                                myMessageContent = generateReplyHTML(message.replyTo) + baseContent;
                            } else {
                                myMessageContent = baseContent;
                            }

                            // 如果有图片，添加图片显示
                            if (imagePart?.image_url?.url) {
                                if (myMessageContent) {
                                    myMessageContent += '<br>';
                                }
                                myMessageContent += `<img src="${imagePart.image_url.url}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${imagePart.image_url.url}')">`;
                            }
                        } else {
                            // 普通文本消息或旧格式
                            let baseContent = message.content;
                            // 处理@内容
                            baseContent = processMentions(baseContent);

                            // 如果有引用消息，在内容前添加引用显示
                            if (message.replyTo) {
                                myMessageContent = generateReplyHTML(message.replyTo) + baseContent;
                            } else {
                                myMessageContent = baseContent;
                            }
                        }
                    }
                    
                    let myBubbleHtml = '';
                    
                    if (message.type === 'user_photo' || message.type === 'voice' || message.type === 'transfer' || message.type === 'location' || message.type === 'friend_request') {
                        // 用户照片、语音消息、转账消息和位置消息不需要额外气泡包裹（已经有自己的容器）
                        myBubbleHtml = myMessageContent;
                    } else {
                        // 普通消息用气泡包裹
                        myBubbleHtml = `
                            <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                                ${myMessageContent}
                                ${message.image && !message.type && !Array.isArray(message.content) ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}
                                ${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                ${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}
                            </div>
                        `;
                    }
                    
                    let myAvatarHtml = '';
                    if (!chatSettings.hideAvatars) {
                        myAvatarHtml = `
                            <div class="message-avatar" style="background-color: #007AFF; ${myDisplayAvatar ? `background-image: url(${myDisplayAvatar}); background-size: cover; background-position: center;` : ''}">
                                ${myDisplayAvatar ? '' : '<i class="fas fa-user"></i>'}
                                ${timestampEnabled && timestampPosition === 'avatar' ? `<div class="timestamp timestamp-avatar">${formatTimeOnly(message.timestamp)}</div>` : ''}
                            </div>
                        `;
                    }
                    
                    messageContainer.innerHTML = myBubbleHtml + myAvatarHtml;
                }
                
                // 添加滑入动画效果 - 参考完成.html的弹性动画
                messageContainer.style.opacity = '0';
                messageContainer.style.transform = 'translateY(20px)';
                messageContainer.style.transition = 'opacity 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)';
                
                messagesContainer.appendChild(messageContainer);
                
                // 触发滑入动画
                requestAnimationFrame(() => {
                    messageContainer.style.opacity = '1';
                    messageContainer.style.transform = 'translateY(0)';
                });
                
                // 🔥【新增】检查拉黑状态并添加指示器
                addBlockedIndicatorToMessage(messageContainer, message, characterId);

                // 添加长按监听器用于多选删除
                addMessageLongPressListener(messageContainer, message.id);

                // 添加右键菜单功能
                const bubble = messageContainer.querySelector('.message-bubble');
                if (bubble) {
                    // 鼠标右键点击
                    bubble.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        showMessageMenu(message.id, e);
                    });

                    // 点击图片预览
                    bubble.onclick = (e) => {
                        if (e.target.tagName === 'IMG' && e.target.classList.contains('message-image')) {
                            showImage(e.target.src);
                        }
                    };
                }
            });
            
            // 添加正在输入提示元素到消息底部（初始隐藏）
            const typingIndicator = document.createElement('div');
            typingIndicator.id = 'typing-indicator';
            typingIndicator.className = 'typing-indicator';
            typingIndicator.innerHTML = `${chatSettings.aiChatNickname || currentChatCharacter.name}正在输入中<span class="dots"></span>`;
            messagesContainer.appendChild(typingIndicator);
            
            // 如果不是加载更多，自动滚动到底部
            if (!loadMore) {
                setTimeout(() => {
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                }, 100);
            }
            
            // 🔥【修复】位置消息气泡包装问题 - 修复已渲染的位置消息
            setTimeout(() => {
                const locationMessages = messagesContainer.querySelectorAll('.message-container.sent');
                locationMessages.forEach(container => {
                    const locationCard = container.querySelector('.location-card');
                    if (locationCard && container.querySelector('.message-bubble')) {
                        // 如果位置卡片被包裹在气泡中，提取出来
                        const bubble = container.querySelector('.message-bubble');
                        const avatar = container.querySelector('.message-avatar');
                        if (bubble && locationCard.closest('.message-bubble')) {
                            const locationContainer = locationCard.closest('.location-message-container');
                            if (locationContainer) {
                                container.innerHTML = locationContainer.outerHTML + (avatar ? avatar.outerHTML : '');
                            }
                        }
                    }
                });
                
                // 🔥【新增】渲染角色状态显示 - 在消息渲染完成后更新状态
                if (currentChatCharacter) {
                    const headerContainer = document.querySelector('#api-chat-screen .header');
                    if (headerContainer) {
                        renderCharacterStatus(currentChatCharacter.id, headerContainer);
                    }
                }
            }, 50);
        }
        
        // 加载更多历史消息
        function loadMoreMessages(characterId) {
            const messagesContainer = document.getElementById('api-chat-messages');
            const allMessages = chatMessages[characterId] || [];
            const chatSettings = getCurrentChatSettings();
            
            // 保存滚动位置
            const scrollHeight = messagesContainer.scrollHeight;
            const scrollTop = messagesContainer.scrollTop;
            
            // 计算要加载的历史消息范围
            const newOffset = Math.max(0, currentMessageOffset - MESSAGE_LIMIT);
            const historicalMessages = allMessages.slice(newOffset, currentMessageOffset);
            
            // 移除现有的"查看历史消息"按钮
            const existingLoadMoreBtn = messagesContainer.querySelector('.load-more-messages');
            if (existingLoadMoreBtn) {
                existingLoadMoreBtn.remove();
            }
            
            // 如果还有更多历史消息，在顶部添加新的"查看历史消息"按钮
            if (newOffset > 0) {
                const loadMoreBtn = document.createElement('div');
                loadMoreBtn.className = 'load-more-messages';
                loadMoreBtn.innerHTML = `
                    <div class="load-more-content">
                        <i class="fas fa-chevron-up"></i>
                        <span>查看历史消息 (${newOffset}条)</span>
                    </div>
                `;
                loadMoreBtn.onclick = () => loadMoreMessages(characterId);
                messagesContainer.insertBefore(loadMoreBtn, messagesContainer.firstChild);
            }
            
            // 在现有消息前面插入历史消息
            const timestampEnabled = chatSettings.timestampEnabled !== false;
            const timestampPosition = chatSettings.timestampPosition || 'center';
            let lastTimestamp = 0;
            
            // 从后往前插入，保持时间顺序
            for (let i = historicalMessages.length - 1; i >= 0; i--) {
                const message = historicalMessages[i];
                
                // 处理系统消息（如戳一戳、头像更换、撤回等）
                if (message.sender === 'system') {
                    // 🔥【修复】处理拉黑系统消息 - 显示为居中的系统提示
                    if (message.isBlockedMessage) {
                        const centerContainer = document.createElement('div');
                        centerContainer.style.display = 'flex';
                        centerContainer.style.justifyContent = 'center';
                        centerContainer.style.margin = '4px 0';
                        centerContainer.dataset.messageId = message.id;

                        const systemContainer = document.createElement('div');
                        systemContainer.className = 'system-message';
                        systemContainer.textContent = message.content || '消息已发出，但被对方拒收了';

                        centerContainer.appendChild(systemContainer);

                        // 插入到正确位置
                        const insertAfter = messagesContainer.querySelector('.load-more-messages');
                        if (insertAfter) {
                            insertAfter.parentNode.insertBefore(centerContainer, insertAfter.nextSibling);
                        } else {
                            messagesContainer.insertBefore(centerContainer, messagesContainer.firstChild);
                        }
                        continue;
                    }

                    let containerToInsert;

                    if (message.isPoke) {
                    const systemContainer = document.createElement('div');
                    systemContainer.className = 'poke-system-container';
                    const systemMessage = document.createElement('div');
                    systemMessage.className = 'poke-system-message';
                    systemMessage.textContent = message.content;
                    systemContainer.appendChild(systemMessage);
                        containerToInsert = systemContainer;
                    } else if (message.type === 'recalled_message') {
                        // 🔥【新增】处理撤回消息的显示
                        const centerContainer = document.createElement('div');
                        centerContainer.style.display = 'flex';
                        centerContainer.style.justifyContent = 'center';
                        centerContainer.style.margin = '4px 0';
                        centerContainer.dataset.messageId = message.id; // 🔥【修复】添加消息ID以支持选择
                        
                        const recallElement = document.createElement('div');
                        recallElement.className = 'recalled-message';
                        
                        // 解析撤回消息内容（格式：xxx 撤回了一条消息\n原文：xxx）
                        const lines = message.content.split('\n');
                        const mainText = lines[0]; // 主要提示文字
                        const originalText = lines[1]; // 原文部分
                        
                        recallElement.textContent = mainText;
                        
                        // 如果有原文，添加原文显示
                        if (originalText && originalText.startsWith('原文：')) {
                            const originalDiv = document.createElement('div');
                            originalDiv.className = 'original-text';
                            originalDiv.textContent = originalText;
                            recallElement.appendChild(originalDiv);
                        }
                        
                        centerContainer.appendChild(recallElement);
                        containerToInsert = centerContainer;
                    } else {
                        // 🔥【修复】其他系统消息（如头像更换）- 使用居中容器
                        const centerContainer = document.createElement('div');
                        centerContainer.style.display = 'flex';
                        centerContainer.style.justifyContent = 'center';
                        centerContainer.style.margin = '4px 0';

                        const systemContainer = document.createElement('div');
                        // 🔥【美化】检查是否为好友添加成功消息，应用特殊样式
                        if (message.isFriendAddedMessage) {
                            systemContainer.className = 'friend-added-system-message';
                        } else {
                            systemContainer.className = 'system-message';
                        }
                        systemContainer.textContent = message.content;

                        centerContainer.appendChild(systemContainer);
                        containerToInsert = centerContainer;
                    }
                    
                    // 插入到按钮后面（如果有按钮的话）
                    const insertAfter = messagesContainer.querySelector('.load-more-messages');
                    if (insertAfter) {
                        insertAfter.parentNode.insertBefore(containerToInsert, insertAfter.nextSibling);
                    } else {
                        messagesContainer.insertBefore(containerToInsert, messagesContainer.firstChild);
                    }
                    
                    // 🔥【修复】为撤回消息添加选择功能
                    if (message.type === 'recalled_message') {
                        addMessageLongPressListener(containerToInsert, message.id);
                    }
                    
                    continue;
                }
                
                const messageContainer = document.createElement('div');
                // 检查是否是纯表情包消息
                const isEmojiOnly = message.isEmoji && !message.content;
                messageContainer.className = `message-container ${message.sender}${chatSettings.hideAvatars ? ' no-avatar' : ''}${isEmojiOnly ? ' emoji-only' : ''}`;
                messageContainer.dataset.messageId = message.id;
                
                if (message.sender === 'received') {
                    // ==== 群聊支持 ====
                    let character = characters.find(c => c.id === characterId);
                    let isGroup = false;
                    let group = null;
                    if (!character) {
                        group = groupChats.find(g => g.id === characterId);
                        if (group) {
                            isGroup = true;
                        }
                    }
                    
                    let displayAvatar = '';
                    let displayName = '';
                    let color = '#4CAF50';
                    
                    if (isGroup && group) {
                        // 群聊：根据消息的senderId或name查找成员
                        let member = null;
                        if (message.senderId) {
                            member = group.members.find(m => m.id === message.senderId);
                        } else if (message.name) {
                            member = group.members.find(m => m.name === message.name);
                        }

                        // 🔥【修复】确保群聊表情包消息正确显示发送者（loadMoreMessages版本）
                        if (member) {
                            displayAvatar = member.avatarUrl || '';
                            displayName = member.name;
                            color = member.color || '#4CAF50';
                        } else {
                            // 如果没找到成员，使用消息中的name作为显示名称
                            displayAvatar = '';
                            displayName = message.name || '群成员';
                            color = '#4CAF50';
                        }
                    } else if (character) {
                        // 单聊
                        displayAvatar = chatSettings.aiDynamicAvatar || chatSettings.aiChatAvatar || character.avatarUrl;
                        displayName = chatSettings.aiChatNickname || character.name;
                        color = character.color || '#4CAF50';
                    } else {
                        // 兜底，防止报错
                        displayAvatar = '';
                        displayName = '未知';
                        color = '#4CAF50';
                    }
                    // 🔥【新增】获取气泡样式 - 群聊中使用成员专属颜色
                    let bubbleColor = chatSettings.aiBubbleColor || '#f0f0f0';
                    
                    // 如果是群聊且有成员专属颜色设置，使用成员专属颜色
                    if (isGroup && group && message.senderId && chatSettings.memberBubbleColors) {
                        const memberColor = chatSettings.memberBubbleColors[message.senderId];
                        if (memberColor) {
                            bubbleColor = memberColor;
                        }
                    }
                    
                    const bubbleOpacity = chatSettings.aiBubbleOpacity || '1';
                    const textColor = isLightColor(bubbleColor) ? '#333' : '#fff';
                    const bubblePadding = chatSettings.bubblePadding || '12';
                    
                    // 将透明度应用到背景色而不是整个元素
                    const transparentBubbleColor = convertColorWithOpacity(bubbleColor, bubbleOpacity);
                    
                    let messageContent = '';
                    if (message.type === 'voice_message') {
                        // 过滤掉括号中的描述性内容，保留实际说话内容
                        const cleanVoiceContent = message.content.replace(/\([^)]*\)\s*/g, '').trim();
                        const voiceDuration = message.duration || Math.max(1, Math.ceil(cleanVoiceContent.length / 8));
                        
                        messageContent = `
                            <div class="voice-message-container received">
                                <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                                    <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${cleanVoiceContent}">
                                        <div class="voice-wave">
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                        </div>
                                        <div class="voice-duration">${voiceDuration}"</div>
                                    ${message.edited ? `<div class="message-edited-indicator">已编辑</div>` : ""}
                                    </div>
                                </div>
                                <div class="voice-text-content">${cleanVoiceContent}</div>
                            </div>
                        `;
                    } else if (message.type === 'ai_image') {
                        // AI生成的图片 - 使用星星emoji卡片样式
                        const imageDesc = message.imageDescription || message.content || 'AI描述的图片';
                        messageContent = `<div class="dreamy-photo-container" onclick="togglePhotoText(this, '${imageDesc.replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')"><div class="dreamy-photo"><div class="photo-misty-bg"></div><div class="photo-badge"><i class="fas fa-image"></i></div><div class="sparkle-container"><div class="sparkle sparkle-1">✨</div><div class="sparkle sparkle-2">⭐</div><div class="sparkle sparkle-3">✨</div><div class="sparkle sparkle-4">⭐</div><div class="sparkle sparkle-5">💫</div></div><div class="photo-text-overlay" style="display: none;"><div class="photo-description">${imageDesc}</div></div></div></div>`;
                    } else if (message.type === 'transfer') {
                        // 转账消息
                        const isUser = message.role === 'user';
                        const heartIcon = isUser ? '💕' : '💖';
                        const titleText = isUser ? '你发起的转账' : '收到转账';
                        let cardClass = '';
                        let statusHtml = '';
                        let clickHandler = '';
                        
                        if (message.status === 'accepted') {
                            statusHtml = `<div class="transfer-status">${isUser ? '对方已收款' : '已收款'}</div>`;
                            cardClass = 'accepted';
                        } else if (message.status === 'rejected') {
                            statusHtml = `<div class="transfer-status">${isUser ? '对方已退回' : '已退回'}</div>`;
                            cardClass = 'rejected';
                        } else if (!isUser) {
                            // AI发来的转账且未处理，添加点击处理
                            clickHandler = `onclick="showTransferConfirmDialog(${JSON.stringify(message).replace(/"/g, '&quot;')})"`;
                        }
                        
                        messageContent = `<div class="transfer-message-container received"><div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}" ${clickHandler}><div class="transfer-title">${heartIcon} ${titleText}</div><div class="transfer-amount">¥ ${Number(message.amount).toFixed(2)}</div><div class="transfer-note">${message.note || '转账'}</div>${statusHtml}</div></div>`;
                    } else if (message.type === 'friend_request') {
                        // 🔥【新增】AI主动发送的好友申请(第二处)
                        messageContent = `
                            <div class="friend-request-container">
                                <div class="friend-request-card">
                                    <div class="friend-request-icon">👋</div>
                                    <div class="friend-request-title">好友申请</div>
                                    <div class="friend-request-message">${message.message || '想和你重新做朋友'}</div>
                                    <div class="friend-request-actions">
                                        <button class="friend-request-btn accept" onclick="handleAIFriendRequest('${currentChatCharacter?.id}', true, '${message.id}')">同意</button>
                                        <button class="friend-request-btn reject" onclick="handleAIFriendRequest('${currentChatCharacter?.id}', false, '${message.id}')">拒绝</button>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        const chatMode = chatSettings.chatMode || 'online';
                        let baseContent = chatMode === 'offline' ? processOfflineContent(message.content) : message.content;
                        
                        // 如果有引用消息，在内容前添加引用显示
                        if (message.replyTo) {
                            messageContent = generateReplyHTML(message.replyTo) + baseContent;
                        } else {
                            messageContent = baseContent;
                        }
                    }
                    
                    let avatarHtml = '';
                    if (!chatSettings.hideAvatars) {
                        avatarHtml = `<div class="message-avatar" style="background-color: ${color}; ${displayAvatar ? `background-image: url(${displayAvatar}); background-size: cover; background-position: center;` : ''}" ${character ? `onclick="pokeCharacter('${character.id}')" title="戳一戳"` : `title="${displayName}"`}>${displayAvatar ? '' : displayName.charAt(0)}${timestampEnabled && timestampPosition === 'avatar' ? `<div class="timestamp timestamp-avatar">${formatTimeOnly(message.timestamp)}</div>` : ''}</div>`;
                    }
                    
                    let bubbleHtml = '';
                    if (message.type === 'voice_message' || message.type === 'transfer' || message.type === 'ai_image' || message.type === 'user_photo' || message.type === 'location' || message.type === 'friend_request') {
                        // 语音消息、转账消息、AI图片消息、照片卡片和位置信息不需要额外的气泡包裹
                        bubbleHtml = messageContent;
                    } else {
                        // 普通消息用气泡包裹
                        bubbleHtml = `<div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">${messageContent}${message.image && !message.type ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}${message.edited ? `<div class="message-edited-indicator">已编辑</div>` : ''}${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}</div>`;
                    }
                    
                   // 🔥【修复】群聊昵称显示 （loadMoreMessages版本）- 特别处理语音消息、转账消息、照片卡片和位置信息
                   if (isGroup && group && displayName !== '群成员') {
    messageContainer.classList.add('group-message-item');
    const senderNameHtml = `<div class="sender-name">${displayName}</div>`;

    if (message.type === 'voice_message' || message.type === 'transfer' || message.type === 'ai_image' || message.type === 'user_photo' || message.type === 'location' || message.type === 'friend_request') {
        // 🔥【修复】对于语音消息、转账消息、AI图片消息、照片卡片和位置信息，昵称需要在容器外部
    messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    } else {
        // 普通消息的处理（包括表情包消息）
        messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    }
} else {
                    messageContainer.innerHTML = avatarHtml + bubbleHtml;
}
                } else {
                    let myDisplayAvatar = chatSettings.myChatAvatar;
                    if (!myDisplayAvatar && chatSettings.selectedIdentityId) {
                        const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                        if (selectedPersona && selectedPersona.avatarUrl) {
                            myDisplayAvatar = selectedPersona.avatarUrl;
                        }
                    }
                    
                    const myBubbleColor = chatSettings.myBubbleColor || '#007AFF';
                    const myBubbleOpacity = chatSettings.myBubbleOpacity || '1';
                    const myTextColor = isLightColor(myBubbleColor) ? '#333' : '#fff';
                    const myBubblePadding = chatSettings.bubblePadding || '12';
                    
                    // 将透明度应用到背景色而不是整个元素
                    const transparentMyBubbleColor = convertColorWithOpacity(myBubbleColor, myBubbleOpacity);
                    
                    // 处理用户的特殊消息类型
                    let myMessageContent = '';
                    if (message.type === 'user_photo') {
                        // 用户发送的"照片"（文字描述）
                        myMessageContent = `<div class="dreamy-photo-container" onclick="togglePhotoText(this, '${(message.photoDescription || message.content).replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')"><div class="dreamy-photo"><div class="photo-misty-bg"></div><div class="photo-badge"><i class="fas fa-image"></i></div><div class="sparkle-container"><div class="sparkle sparkle-1">✨</div><div class="sparkle sparkle-2">⭐</div><div class="sparkle sparkle-3">✨</div><div class="sparkle sparkle-4">⭐</div><div class="sparkle sparkle-5">💫</div></div><div class="photo-text-overlay" style="display: none;"><div class="photo-description">${(message.photoDescription || message.content)}</div></div></div></div>`;
                    } else if (message.type === 'voice') {
                        // 用户发送的语音消息
                        myMessageContent = `
                            <div class="voice-message-container sent">
                                <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                                    <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${message.content}">
                                        <div class="voice-wave">
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                        </div>
                                        <div class="voice-duration">${message.duration || Math.max(1, Math.ceil(message.content.length / 8))}"</div>
                                    ${message.edited ? `<div class="message-edited-indicator">已编辑</div>` : ""}
                                    </div>
                                    ${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                    ${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                </div>
                                <div class="voice-text-content">${message.content}</div>
                            </div>
                        `;
                    } else if (message.type === 'transfer') {
                        // 用户转账消息 - 在loadMoreMessages中处理
                        let cardClass = '';
                        let statusHtml = '';
                        
                        if (message.status === 'accepted') {
                            statusHtml = `<div class="transfer-status">对方已收款</div>`;
                            cardClass = 'accepted';
                        } else if (message.status === 'rejected') {
                            statusHtml = `<div class="transfer-status">对方已退回</div>`;
                            cardClass = 'rejected';
                        }
                        
                        myMessageContent = `
                            <div class="transfer-message-container sent">
                                <div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}">
                                    <div class="transfer-title">💕 你发起的转账</div>
                                    <div class="transfer-amount">¥ ${Number(message.amount).toFixed(2)}</div>
                                    <div class="transfer-note">${message.note || '转账'}</div>
                                    ${statusHtml}
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'location') {
                        // 用户发送的位置消息 - 在loadMoreMessages中处理
                        myMessageContent = `
                            <div class="location-message-container sent">
                                <div class="location-card" onclick="showLocationDetail('${message.locationName}')">
                                    <div class="location-card-header">
                                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
                                            <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                        </svg>
                                        ${message.locationName}
                                    </div>
                                    <div class="location-card-map">
                                        <div class="map-background"></div>
                                        <div class="map-roads">
                                            <div class="road road-horizontal" style="top: 35%; width: 100%;"></div>
                                            <div class="road road-vertical" style="left: 40%; height: 100%;"></div>
                                            <div class="road road-horizontal" style="top: 65%; width: 70%; left: 30%;"></div>
                                        </div>
                                        <div class="map-buildings">
                                            <div class="building" style="top: 15%; left: 20%; width: 12px; height: 10px;"></div>
                                            <div class="building" style="top: 25%; left: 60%; width: 14px; height: 12px;"></div>
                                            <div class="building green" style="top: 50%; left: 15%; width: 8px; height: 8px;"></div>
                                            <div class="building" style="top: 70%; left: 70%; width: 10px; height: 8px;"></div>
                                            <div class="building green" style="top: 10%; left: 75%; width: 6px; height: 6px;"></div>
                                            <div class="building green" style="top: 75%; left: 25%; width: 7px; height: 7px;"></div>
                                        </div>
                                        <div class="map-marker">
                                            <div class="marker-pin">
                                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                                                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                                </svg>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        // 🔥【修复】处理多模态消息或普通文本消息 (loadMoreMessages版本)
                        if (Array.isArray(message.content)) {
                            // 新的多模态格式
                            const textPart = message.content.find(p => p.type === 'text');
                            const imagePart = message.content.find(p => p.type === 'image_url');
                            
                            let baseContent = textPart?.text || '';
                            
                            // 如果有引用消息，在内容前添加引用显示
                            if (message.replyTo) {
                                myMessageContent = generateReplyHTML(message.replyTo) + baseContent;
                            } else {
                                myMessageContent = baseContent;
                            }
                            
                            // 如果有图片，添加图片显示
                            if (imagePart?.image_url?.url) {
                                if (myMessageContent) {
                                    myMessageContent += '<br>';
                                }
                                myMessageContent += `<img src="${imagePart.image_url.url}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${imagePart.image_url.url}')">`;
                            }
                        } else {
                            // 普通文本消息或旧格式 (loadMoreMessages版本)
                            let baseContent = message.content;
                            
                            // 如果有引用消息，在内容前添加引用显示
                            if (message.replyTo) {
                                myMessageContent = generateReplyHTML(message.replyTo) + baseContent;
                            } else {
                                myMessageContent = baseContent;
                            }
                        }
                    }
                    
                    let myBubbleHtml = '';
                    
                    if (message.type === 'user_photo' || message.type === 'voice' || message.type === 'transfer' || message.type === 'location' || message.type === 'friend_request') {
                        // 用户照片、语音消息、转账消息和位置消息不需要额外气泡包裹（已经有自己的容器）
                        myBubbleHtml = myMessageContent;
                    } else {
                        // 普通消息用气泡包裹
                        myBubbleHtml = `<div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">${myMessageContent}${message.image && !message.type && !Array.isArray(message.content) ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}${message.edited ? `<div class="message-edited-indicator">已编辑</div>` : ''}${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}</div>`;
                    }
                    
                    let myAvatarHtml = '';
                    if (!chatSettings.hideAvatars) {
                        myAvatarHtml = `<div class="message-avatar" style="background-color: #007AFF; ${myDisplayAvatar ? `background-image: url(${myDisplayAvatar}); background-size: cover; background-position: center;` : ''}">${myDisplayAvatar ? '' : '<i class="fas fa-user"></i>'}${timestampEnabled && timestampPosition === 'avatar' ? `<div class="timestamp timestamp-avatar">${formatTimeOnly(message.timestamp)}</div>` : ''}</div>`;
                    }
                    
                    messageContainer.innerHTML = myBubbleHtml + myAvatarHtml;
                }
                
                // 🔥【新增】检查拉黑状态并添加指示器
                addBlockedIndicatorToMessage(messageContainer, message, characterId);

                // 添加长按监听器和右键菜单
                addMessageLongPressListener(messageContainer, message.id);
                const bubble = messageContainer.querySelector('.message-bubble');
                if (bubble) {
                    bubble.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        showMessageMenu(message.id, e);
                    });

                    bubble.onclick = (e) => {
                        if (e.target.tagName === 'IMG' && e.target.classList.contains('message-image')) {
                            showImage(e.target.src);
                        }
                    };
                }
                
                // 插入消息到正确位置
                const insertAfter = messagesContainer.querySelector('.load-more-messages');
                if (insertAfter) {
                    insertAfter.parentNode.insertBefore(messageContainer, insertAfter.nextSibling);
                } else {
                    messagesContainer.insertBefore(messageContainer, messagesContainer.firstChild);
                }
            }
            
            // 更新偏移量
            currentMessageOffset = newOffset;
            
            // 保持滚动位置
            setTimeout(() => {
                const newScrollHeight = messagesContainer.scrollHeight;
                messagesContainer.scrollTop = scrollTop + (newScrollHeight - scrollHeight);
            }, 50);
        }
        
        
        // 显示角色表单
        function showCharacterForm(characterId = null) {
            currentEditingCharacterId = characterId; // 保存当前编辑的角色ID
            document.getElementById('character-form-title').textContent = characterId ? '编辑人物' : '新建人物';
            
            // 清空表单
            document.getElementById('character-name').value = '';
            document.getElementById('character-bio').value = '';
            document.getElementById('avatar-upload').value = '';
            
            const avatarPreview = document.getElementById('avatar-preview');
            const avatarPreviewText = document.getElementById('avatar-preview-text');
            
            // 重置头像预览
            avatarPreview.classList.remove('has-image');
            avatarPreview.style.removeProperty('background');
            avatarPreview.style.removeProperty('background-size');
            avatarPreview.style.removeProperty('background-position');
            avatarPreview.style.removeProperty('background-repeat');
            avatarPreviewText.style.display = 'block';
            avatarPreviewText.textContent = 'A';
            
            // 清除临时存储的头像数据
            window.selectedAvatarData = null;
            
            // 如果是编辑模式，填充现有数据
            if (characterId) {
                const character = characters.find(c => c.id === characterId);
                if (character) {
                    document.getElementById('character-name').value = character.name;
                    document.getElementById('character-bio').value = character.bio;
                    
                    if (character.avatarUrl) {
                        avatarPreview.classList.add('has-image');
                        avatarPreview.style.setProperty('background', `url(${character.avatarUrl})`, 'important');
                        avatarPreview.style.setProperty('background-size', 'cover', 'important');
                        avatarPreview.style.setProperty('background-position', 'center', 'important');
                        avatarPreview.style.setProperty('background-repeat', 'no-repeat', 'important');
                        avatarPreviewText.style.display = 'none';
                        // 为编辑模式保存现有头像数据
                        window.selectedAvatarData = character.avatarUrl;
                    } else {
                        avatarPreviewText.textContent = character.name.charAt(0);
                    }
                }
            }
            
            // 设置表单的保存函数和删除按钮显示
            const deleteBtn = document.getElementById('character-delete-btn');
            const importBtn = document.getElementById('import-character-btn');
            const exportBtn = document.getElementById('export-character-btn');
            console.log('设置保存按钮，characterId:', characterId);
            if (characterId) {
                document.querySelector('#character-form-screen .form-submit').onclick = async () => await saveCharacter(characterId);
                // 编辑模式显示删除按钮，隐藏导入按钮，显示导出按钮
                if (deleteBtn) deleteBtn.style.display = 'block';
                if (importBtn) importBtn.style.display = 'none';
                if (exportBtn) exportBtn.style.display = 'flex';
                console.log('设置为编辑模式，角色ID:', characterId);
            } else {
                document.querySelector('#character-form-screen .form-submit').onclick = async () => await saveCharacter();
                // 新建模式隐藏删除按钮，显示导入按钮，隐藏导出按钮
                if (deleteBtn) deleteBtn.style.display = 'none';
                if (importBtn) importBtn.style.display = 'flex';
                if (exportBtn) exportBtn.style.display = 'none';
                console.log('设置为创建模式，无角色ID');
            }
            
            showApp('character-form-screen');
            
            // 确保头像上传功能可用 - 重新绑定事件监听器（以防万一）
            setTimeout(() => {
                initializeAvatarUpload();
            }, 100);
        }
        
        // 保存角色
        async function saveCharacter(characterId = null) {
            try {
                console.log('=== 开始保存角色 ===');
                const name = document.getElementById('character-name').value.trim();
                const bio = document.getElementById('character-bio').value.trim();
                const avatarData = window.selectedAvatarData; // 使用预处理的头像数据
                
                console.log('保存角色 - 姓名:', name, '头像数据存在:', !!avatarData);
                if (avatarData) {
                    console.log('头像数据长度:', avatarData.length, '开头:', avatarData.substring(0, 50));
                }
                
                if (!name) {
                    alert('请输入姓名');
                    return;
                }
                
                if (characterId) {
                    console.log('=== 更新现有角色 ===');
                    // 更新现有角色
                    const index = characters.findIndex(c => c.id === characterId);
                    if (index !== -1) {
                        const oldAvatarUrl = characters[index].avatarUrl;
                        
                        characters[index] = {
                            ...characters[index],
                            name,
                            bio,
                            avatarUrl: avatarData || characters[index].avatarUrl || '',
                            color: characters[index].color || getRandomColor()
                        };
                        
                        console.log('更新角色完成:', characters[index]);
                        
                        // 🔥【修复1】如果头像发生了变化，更新所有相关群聊中的成员头像
                        if (avatarData && avatarData !== oldAvatarUrl) {
                            updateCharacterAvatarInGroups(characterId, avatarData);
                        }
                        
                        // 保存并更新界面
                        await saveCharacters();
                        renderContactList();
                        renderMessageList();
                        
                        // 🔥【修复2】如果当前正在聊天且是该角色，刷新聊天界面
                        if (currentChatCharacter && currentChatCharacter.id === characterId) {
                            renderChatMessages(currentChatCharacter.id);
                        }
                        
                        showToast(`角色 "${name}" 已更新！`, 'success');
                        hideCharacterForm();
                        // 注意：不立即清空表单，让用户能看到保存成功的状态
                    }
                } else {
                    console.log('=== 创建新角色 ===');
                    // 创建新角色
                    const newCharacter = {
                        id: Date.now().toString(),
                        name,
                        bio,
                        avatarUrl: avatarData || '',
                        color: getRandomColor(),
                        groupId: 'my_friends' // 新角色默认放入"我的好友"分组
                    };
                    
                    console.log('创建新角色:', newCharacter);
                    console.log('新角色头像URL:', newCharacter.avatarUrl);
                    console.log('新角色头像URL长度:', newCharacter.avatarUrl ? newCharacter.avatarUrl.length : 0);
                    
                    console.log('添加角色前，当前角色数组长度:', characters.length);
                    characters.push(newCharacter);
                    console.log('添加角色后，当前角色数组长度:', characters.length);
                    
                    console.log('角色数组最新状态:', characters);
                    
                    // 🔥【修复】不再自动添加到联系人列表，用户需要通过创建对话来建立联系
                    
                    // 保存并更新界面
                    console.log('开始保存到IndexedDB...');
                    await saveCharacters();
                    console.log('保存后检查角色数组:', characters);
                    
                    console.log('开始渲染界面...');
                    renderContactList();
                    renderMessageList();
                    
                    console.log('开始隐藏表单...');
                    hideCharacterForm();
                    // 注意：不立即清空表单，让用户能看到保存成功的状态
                    
                    // 给用户反馈
                    showToast(`角色 "${newCharacter.name}" 创建成功！`, 'success');
                    
                    console.log('=== 保存角色完成 ===');
                }
            } catch (error) {
                console.error('保存角色时发生错误:', error);
                alert('保存角色时发生错误: ' + error.message);
            }
        }
        
        // 清空角色表单
        function clearCharacterForm() {
            console.log('清空角色表单被调用');
            document.getElementById('character-name').value = '';
            document.getElementById('character-bio').value = '';
            document.getElementById('avatar-upload').value = '';
            
            const avatarPreview = document.getElementById('avatar-preview');
            const avatarPreviewText = document.getElementById('avatar-preview-text');
            
            // 重置头像预览
            avatarPreview.classList.remove('has-image');
            avatarPreview.style.removeProperty('background');
            avatarPreview.style.removeProperty('background-size');
            avatarPreview.style.removeProperty('background-position');
            avatarPreview.style.removeProperty('background-repeat');
            if (avatarPreviewText) {
                avatarPreviewText.style.display = 'block';
                avatarPreviewText.textContent = 'A';
            }
            
            // 清除临时存储的头像数据
            console.log('清除临时头像数据');
            window.selectedAvatarData = null;
        }
        
        // 编辑角色
        function editCharacter(characterId) {
            showCharacterForm(characterId);
        }
        
        // 从联系人列表编辑角色
        function editCharacterFromContactList(characterId) {
            showCharacterForm(characterId);
        }
        
        // 进入多选模式
        function enterMultiSelectMode(characterId) {
            isMultiSelectMode = true;
            selectedCharacters = [characterId]; // 初始选中触发长按的角色
            renderContactList();
        }
        
        // 退出多选模式
        function exitMultiSelectMode() {
            isMultiSelectMode = false;
            selectedCharacters = [];
            renderContactList();
        }
        
        // 切换角色选择状态
        function toggleCharacterSelection(characterId) {
            const index = selectedCharacters.indexOf(characterId);
            if (index > -1) {
                selectedCharacters.splice(index, 1);
            } else {
                selectedCharacters.push(characterId);
            }
            renderContactList();
        }
        
        // 删除选中的角色
        async function deleteSelectedCharacters() {
            if (selectedCharacters.length === 0) {
                alert('请先选择要删除的角色');
                return;
            }
            
            const characterNames = selectedCharacters.map(id => {
                const character = characters.find(c => c.id === id);
                return character ? character.name : '';
            }).filter(name => name).join('、');
            
            if (confirm(`确定要删除这些角色吗？\n${characterNames}\n\n此操作不可恢复！`)) {
                // 删除角色
                selectedCharacters.forEach(characterId => {
                    characters = characters.filter(c => c.id !== characterId);
                    contacts = contacts.filter(c => c !== characterId);
                    
                    // 删除相关聊天记录
                    if (chatMessages[characterId]) {
                        delete chatMessages[characterId];
                    }
                });
                
                // 保存数据
                await saveCharacters();
                await saveContacts();
                await saveChatMessages();
                
                // 退出多选模式并更新界面
                exitMultiSelectMode();
                renderMessageList();
                
                alert('角色删除成功');
            }
        }
        
        // 删除当前编辑的角色
        async function deleteCurrentCharacter() {
            if (currentEditingCharacterId) {
                const character = characters.find(c => c.id === currentEditingCharacterId);
                
                if (character && confirm(`确定要删除角色"${character.name}"吗？\n\n此操作将删除角色数据、聊天记录和所有设置，不可恢复！`)) {
                    // 删除角色
                    characters = characters.filter(c => c.id !== character.id);
                    contacts = contacts.filter(c => c !== character.id);
                    
                    // 删除相关聊天记录
                    if (chatMessages[character.id]) {
                        delete chatMessages[character.id];
                    }
                    
                    // [核心修复] 删除聊天设置
                    try {
                        // 从数据库中删除设置
                        await db.chatSettings.delete(character.id);
                        // 从内存中删除设置
                        if (chatSettings[character.id]) {
                            delete chatSettings[character.id];
                        }
                        // 删除localStorage中的备份设置
                        localStorage.removeItem(`chatSettings_${character.id}`);
                        console.log(`✅ 已删除角色 ${character.name} 的聊天设置`);
                    } catch (error) {
                        console.error(`删除角色 ${character.name} 的聊天设置失败:`, error);
                    }
                    
                    // 保存数据
                    await saveCharacters();
                    await saveContacts();
                    await saveChatMessages();
                    
                    // 更新界面并返回
                    renderContactList();
                    renderMessageList();
                    hideCharacterForm();
                    
                    showToast(`角色 ${character.name} 已成功删除`, 'success');
                }
            }
        }
        
        // 🔥【新增】更新角色在所有群聊中的头像
        function updateCharacterAvatarInGroups(characterId, newAvatarUrl) {
            // 遍历所有角色，找到群聊
            characters.forEach(character => {
                if (character.isGroup && character.members) {
                    // 在该群聊中查找对应的成员
                    const memberIndex = character.members.findIndex(member => member.id === characterId);
                    if (memberIndex !== -1) {
                        // 更新该成员的头像
                        character.members[memberIndex].avatarUrl = newAvatarUrl;
                        console.log(`已更新群聊 "${character.name}" 中成员 "${character.members[memberIndex].name}" 的头像`);
                    }
                }
            });
            
            // 保存更新后的角色数据
            saveCharacters();
        }
        
        // 获取随机颜色
        function getRandomColor() {
            const colors = ['#FF3B30', '#FF9500', '#FFCC00', '#34C759', '#5AC8FA', '#007AFF', '#5856D6', '#AF52DE'];
            return colors[Math.floor(Math.random() * colors.length)];
        }
        

        
        // 开始与角色聊天
async function startChat(character) {
    await dataLoadedPromise; // 🔥【新增修复】等待数据加载完成

    // [核心修复] 记录上一个聊天ID，用于清理
    const previousChatId = currentChatCharacter ? currentChatCharacter.id : null;

    // 🔥【修复】在切换聊天时，标记上一个聊天为已读
    if (previousChatId) {
        markAsRead(previousChatId);
    }

    // 🔥【修复】切换聊天时隐藏输入指示器，避免显示错误的"正在输入"状态
    hideTypingIndicator();

    // 🔥【新增】保存当前聊天的引用状态（如果有的话）
    if (previousChatId && currentReplyTo) {
        chatReplyStates[previousChatId] = { ...currentReplyTo };
    }

    // 设置当前聊天角色
            currentChatCharacter = character;

            // 🔥【新增】保存当前聊天状态到sessionStorage，用于页面刷新时恢复
            sessionStorage.setItem('currentChatCharacterId', character.id);
            
    // 🔥【修复】异步获取聊天设置
    const chatSettings = await getAsyncChatSettings();
            let displayTitle = chatSettings.aiChatNickname || character.name;

            // 🔥【新增】如果是群聊，在标题后添加成员数量
            if (character.isGroup && character.members) {
                const memberCount = character.members.length + 1; // +1 包括用户自己
                displayTitle = `${displayTitle}（${memberCount}）`;
            }

            document.getElementById('api-chat-title').textContent = displayTitle;
            
            // 🔥【新增】渲染角色状态显示
            const headerContainer = document.querySelector('#api-chat-screen .header');
            if (headerContainer) {
                renderCharacterStatus(character.id, headerContainer);
            }
            
            // 🔥【新增】更新心率显示
            updateAiHeartrate();
                
                // 🔥【修复】只有在开启状态显示时才生成初始状态
                setTimeout(async () => {
                    const chatSettings = await getAsyncChatSettings(character.id);
                    if (chatSettings.characterStatusEnabled) {
                        const currentStatus = getCharacterStatus(character.id);
                        if (!currentStatus.activity || currentStatus.activity === '在线') {
                            await generateCharacterStatus(character.id);
                            // 刷新状态显示
                            renderCharacterStatus(character.id, headerContainer);
                        }
                    }
                }, 500);
            
            // 🔥【新增】启动状态更新定时器
            startCharacterStatusTimer();

            // 🔥【新增】更新设置界面的拉黑/屏蔽管理文案
            updateBlockManageLabel(character.isGroup);
            
            // 初始化空的聊天记录（不自动发送消息）
            if (!chatMessages[character.id]) {
                chatMessages[character.id] = [];
                saveChatMessages();
            }
            
            // 重置悬浮按钮状态
            resetFloatingButtonsState();
            
            // 🔥【新增】检查拉黑状态并更新界面
            updateChatBlockedStatus();
            
            // 🔥【新增】如果设置界面是打开的，更新设置显示状态
            if (document.getElementById('api-chat-settings-screen').style.display === 'flex') {
                updateChatSettingsDisplay();
            }
    
    // 重置聊天屏幕背景
    const chatScreen = document.getElementById('api-chat-screen');
    if (chatScreen) {
        // 先重置所有背景样式
        chatScreen.style.backgroundImage = 'none';
        chatScreen.style.backgroundColor = 'white';

        // 🔥【新增】根据聊天类型添加或移除group-chat类
        if (character.isGroup) {
            chatScreen.classList.add('group-chat');
        } else {
            chatScreen.classList.remove('group-chat');
        }

        const messagesContainer = document.getElementById('api-chat-messages');
        if (messagesContainer) messagesContainer.style.background = '';
    }
    
    // 记录切换
    console.log(`🔄 切换到聊天: ${character.name} (ID: ${character.id})`);
    
    // 【关键修复】每次进入聊天时，调用 applyChatBackground 来确保背景正确
    // 不传递参数，让函数自己从角色对象中读取
    await applyChatBackground();

    // 🔥【修复】确保气泡样式在进入聊天时被正确应用
    applyBubbleStyle();

            // 初始化后台互动系统
            initBackgroundInteractionSystem();

            // 初始化定时发布系统
            initScheduledMomentsSystem();

            renderChatMessages(character.id);

            // 🔥【新增】恢复当前聊天的引用状态
            if (chatReplyStates[character.id]) {
                currentReplyTo = { ...chatReplyStates[character.id] };
                showReplyPreview();
            } else {
                // 清除引用状态
                currentReplyTo = null;
                const existingPreview = document.getElementById('reply-preview');
                if (existingPreview) {
                    existingPreview.remove();
                }
            }

            showApp('api-chat-screen');
        }
        
        // 从聊天界面返回到聊天应用
        function backToChatApp() {
            // 🔥【修复】在退出聊天时标记消息为已读
            if (currentChatCharacter) {
                markAsRead(currentChatCharacter.id);
            }

            // 🔥【新增】清除保存的聊天状态
            sessionStorage.removeItem('currentChatCharacterId');

            // 🔥【新增】保存当前聊天的引用状态
            if (currentChatCharacter && currentReplyTo) {
                chatReplyStates[currentChatCharacter.id] = { ...currentReplyTo };
            }

            // 🔥【新增】清除群聊CSS类
            const chatScreen = document.getElementById('api-chat-screen');
            if (chatScreen) {
                chatScreen.classList.remove('group-chat');
            }

            // 清除当前角色的后台定时器
            clearAllBackgroundTimers();
            // 🔥【新增】清除状态更新定时器
            clearCharacterStatusTimer();
            // 隐藏心率显示
            hideAiHeartrate();
            hideApp('api-chat-screen');
            showApp('chat-screen');
        }
        
        // 从设置子页面返回到设置主页面
        function backToSettings(currentScreen) {
            hideApp(currentScreen);
            showApp('settings-screen');
        }
        

        
        // 显示正在输入提示
        function showTypingIndicator() {
            console.log('🔧 尝试显示正在输入提示...');
            let indicator = document.getElementById('typing-indicator');
            
            // 如果没有找到元素，尝试创建一个
            if (!indicator) {
                console.log('⚠️ 未找到typing-indicator元素，正在创建...');
                const messagesContainer = document.getElementById('api-chat-messages');
                if (messagesContainer) {
                    indicator = document.createElement('div');
                    indicator.id = 'typing-indicator';
                    indicator.className = 'typing-indicator';
                    
                    // 获取当前角色名称
                    const chatSettings = getCurrentChatSettings();
                    const characterName = chatSettings.aiChatNickname || (currentChatCharacter ? currentChatCharacter.name : '对方');
                    
                    indicator.innerHTML = `${characterName}正在输入中<span class="dots"></span>`;
                    messagesContainer.appendChild(indicator);
                    console.log('✅ 已创建typing-indicator元素');
                } else {
                    console.error('❌ 找不到消息容器，无法创建typing-indicator');
                    return;
                }
            }
            
            if (indicator) {
                console.log('✅ 显示正在输入提示');
                indicator.classList.add('show');
                // 滚动到底部显示提示
                const messagesContainer = document.getElementById('api-chat-messages');
                if (messagesContainer) {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                }
            } else {
                console.error('❌ 仍然找不到typing-indicator元素');
            }
        }
        
        // 隐藏正在输入提示
        function hideTypingIndicator() {
            console.log('🔧 尝试隐藏正在输入提示...');
            const indicator = document.getElementById('typing-indicator');
            if (indicator) {
                console.log('✅ 隐藏正在输入提示');
                indicator.classList.remove('show');
            } else {
                console.log('⚠️ 未找到typing-indicator元素，可能已被移除');
            }
        }
        
        // 🔥【新增】添加系统消息到聊天界面（不重新渲染整个列表）
        function addSystemMessageToChat(systemMessage) {
            const messagesContainer = document.getElementById('api-chat-messages');
            if (!messagesContainer) return;
            
            // 创建外层容器，用于居中
            const centerContainer = document.createElement('div');
            centerContainer.style.display = 'flex';
            centerContainer.style.justifyContent = 'center';
            centerContainer.style.margin = '4px 0';
            
            // 创建系统消息容器
            const systemContainer = document.createElement('div');
            // 🔥【美化】检查是否为好友添加成功消息，应用特殊样式
            if (systemMessage.isFriendAddedMessage) {
                systemContainer.className = 'friend-added-system-message';
            } else {
                systemContainer.className = 'system-message';
            }
            systemContainer.textContent = systemMessage.content;
            
            // 将系统消息放入居中容器
            centerContainer.appendChild(systemContainer);
            
            // 插入到消息容器的最后（正在输入提示之前）
            const typingIndicator = messagesContainer.querySelector('#typing-indicator');
            if (typingIndicator) {
                messagesContainer.insertBefore(centerContainer, typingIndicator);
            } else {
                messagesContainer.appendChild(centerContainer);
            }
            
            // 滚动到底部
            setTimeout(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }, 100);
        }

        // 角色卡导入功能
        function importCharacterCard() {
            // 防止重复调用
            if (window.isImporting) {
                console.log('正在导入中，忽略重复调用');
                return;
            }
            window.isImporting = true;
            
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.png,.json';
            input.onchange = async (e) => {
                try {
                    const file = e.target.files[0];
                    if (!file) {
                        window.isImporting = false;
                        return;
                    }
                    
                    console.log('开始导入文件:', file.name, '类型:', file.type);
                    
                    let characterData = null;
                    
                    if (file.type === 'image/png') {
                        // 从PNG图片中读取角色卡数据
                        characterData = await extractCharacterFromPNG(file);
                        
                        // 🔥【新增】如果PNG中没有头像数据，使用PNG文件本身作为头像
                        if (characterData && (!characterData.avatarUrl || characterData.avatarUrl === 'none' || characterData.avatarUrl === '' || characterData.avatarUrl === 'undefined')) {
                            console.log('🖼️ PNG中没有头像数据，使用PNG文件本身作为头像');
                            const reader = new FileReader();
                            const pngAsAvatar = await new Promise((resolve) => {
                                reader.onload = (e) => resolve(e.target.result);
                                reader.readAsDataURL(file);
                            });
                            characterData.avatarUrl = pngAsAvatar;
                            characterData.usePngAsAvatar = true; // 标记这是PNG本身
                            console.log('🖼️ PNG头像设置完成');
                        }
                    } else if (file.type === 'application/json' || file.name.endsWith('.json')) {
                        // 从JSON文件中读取角色卡数据
                        const text = await file.text();
                        characterData = JSON.parse(text);
                    }
                    
                    if (characterData) {
                        // 填充表单数据
                        if (characterData.name) {
                            document.getElementById('character-name').value = characterData.name;
                        }
                        if (characterData.bio || characterData.description) {
                            document.getElementById('character-bio').value = characterData.bio || characterData.description;
                        }
                        
                        // 处理头像
                        const avatarData = characterData.avatarUrl || characterData.avatar;
                        if (avatarData && avatarData !== 'none' && avatarData !== '' && avatarData !== 'null') {
                            console.log('处理头像数据:', avatarData.substring(0, 100) + '...');
                            
                            const avatarPreview = document.getElementById('avatar-preview');
                            const avatarPreviewText = document.getElementById('avatar-preview-text');
                            
                            if (avatarPreview && avatarPreviewText) {
                                console.log('🖼️ 开始设置头像，数据长度:', avatarData.length);
                                
                                // 检查是否可能是Base64编码的图片数据
                                let processedAvatarData = avatarData;
                                
                                // 如果是长字符串且不包含协议，可能是Base64
                                if (avatarData.length > 100 && !avatarData.startsWith('http') && !avatarData.startsWith('data:')) {
                                    console.log('🖼️ 检测到可能的Base64数据，尝试添加前缀...');
                                    // 尝试检测图片格式
                                    try {
                                        const firstBytes = atob(avatarData.substring(0, 32));
                                        const header = firstBytes.substring(0, 4);
                                        if (header.startsWith('\x89PNG')) {
                                            processedAvatarData = `data:image/png;base64,${avatarData}`;
                                            console.log('🖼️ 检测为PNG格式');
                                        } else if (header.startsWith('\xFF\xD8\xFF')) {
                                            processedAvatarData = `data:image/jpeg;base64,${avatarData}`;
                                            console.log('🖼️ 检测为JPEG格式');
                                        }
                                    } catch (e) {
                                        console.log('🖼️ Base64检测失败:', e);
                                    }
                                }
                                
                                // 更宽松的头像格式检查
                                if (processedAvatarData.startsWith('data:image/') || 
                                    processedAvatarData.startsWith('http') || 
                                    processedAvatarData.includes('.jpg') || 
                                    processedAvatarData.includes('.png') || 
                                    processedAvatarData.includes('.gif') ||
                                    processedAvatarData.includes('.jpeg') ||
                                    processedAvatarData.length > 100) { // 长字符串可能是Base64
                                    
                                    try {
                                        avatarPreview.classList.add('has-image');
                                        avatarPreview.style.setProperty('background-image', `url("${processedAvatarData}")`, 'important');
                                        avatarPreview.style.setProperty('background-size', 'cover', 'important');
                                        avatarPreview.style.setProperty('background-position', 'center', 'important');
                                        avatarPreview.style.setProperty('background-repeat', 'no-repeat', 'important');
                                        avatarPreviewText.style.display = 'none';
                                        window.selectedAvatarData = processedAvatarData;
                                        console.log('头像设置成功');
                                    } catch (e) {
                                        console.log('头像设置失败:', e);
                                        showToast('头像导入失败，但角色信息已导入', 'warning');
                                    }
                                } else {
                                    console.log('头像数据格式不支持，原始数据:', avatarData);
                                    showToast('头像格式不支持，请手动上传头像', 'warning');
                                }
                            } else {
                                console.log('头像预览元素不存在');
                            }
                        } else {
                            console.log('头像数据为空或无效:', avatarData);
                        }
                        
                        // 处理世界书数据
                        if (characterData.worldBooks && characterData.worldBooks.length > 0) {
                            console.log('开始导入世界书数据...');
                            await importWorldBooks(characterData.worldBooks, characterData.name);
                        } else {
                            console.log('📚 没有检测到世界书数据，跳过世界书导入');
                        }
                        
                        const successMsg = '角色卡导入成功！' + 
                            (characterData.usePngAsAvatar ? ' 已使用PNG图片作为头像。' : '') +
                            (characterData.worldBooks && characterData.worldBooks.length > 0 ? `（包含${characterData.worldBooks.length}个世界书）` : '');
                        showToast(successMsg, 'success');
                    }
                } catch (error) {
                    console.error('导入角色卡失败:', error);
                    showToast('导入角色卡失败，请检查文件格式', 'error');
                } finally {
                    window.isImporting = false;
                }
            };
            
            input.click();
        }
        
        // 角色卡导出功能
        function exportCharacterCard() {
            if (!currentEditingCharacterId) {
                showToast('请先保存角色再导出', 'error');
                return;
            }
            
            const character = characters.find(c => c.id === currentEditingCharacterId);
            if (!character) {
                showToast('找不到要导出的角色', 'error');
                return;
            }
            
            // 显示导出选项
            showExportOptions(character);
        }
        
        // 显示导出选项对话框
        function showExportOptions(character) {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'flex';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h3 class="modal-title">导出角色卡</h3>
                        <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <p>请选择导出格式：</p>
                        <div style="margin: 15px 0;">
                            <button class="modal-button modal-primary" onclick="exportAsJSON('${character.id}'); this.closest('.modal').remove();" style="margin-right: 10px;">
                                <i class="fas fa-file-code"></i> JSON格式
                            </button>
                            <button class="modal-button modal-secondary" onclick="exportAsPNG('${character.id}'); this.closest('.modal').remove();">
                                <i class="fas fa-image"></i> PNG格式
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // 点击背景关闭
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            };
        }
        
        // 导出为JSON格式
        function exportAsJSON(characterId) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;
            
            const characterData = {
                name: character.name,
                bio: character.bio,
                avatarUrl: character.avatarUrl,
                color: character.color,
                exportTime: new Date().toISOString(),
                version: '1.0'
            };
            
            const blob = new Blob([JSON.stringify(characterData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${character.name}_角色卡.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showToast('JSON格式角色卡导出成功', 'success');
        }
        
        // 导出为PNG格式
        async function exportAsPNG(characterId) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;
            
            try {
                // 创建包含角色数据的PNG图片
                const characterData = {
                    name: character.name,
                    bio: character.bio,
                    avatarUrl: character.avatarUrl,
                    color: character.color,
                    exportTime: new Date().toISOString(),
                    version: '1.0'
                };
                
                // 创建画布来生成PNG
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 400;
                canvas.height = 300;
                
                // 绘制背景
                ctx.fillStyle = character.color || '#007AFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 绘制角色信息
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(character.name, canvas.width / 2, 50);
                
                ctx.font = '16px Arial';
                ctx.fillText('角色卡', canvas.width / 2, 80);
                
                // 绘制头像（如果有）
                if (character.avatarUrl) {
                    try {
                        const img = new Image();
                        img.crossOrigin = 'anonymous';
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = reject;
                            img.src = character.avatarUrl;
                        });
                        
                        // 绘制圆形头像
                        const avatarSize = 100;
                        const avatarX = (canvas.width - avatarSize) / 2;
                        const avatarY = 120;
                        
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(avatarX + avatarSize/2, avatarY + avatarSize/2, avatarSize/2, 0, Math.PI * 2);
                        ctx.clip();
                        ctx.drawImage(img, avatarX, avatarY, avatarSize, avatarSize);
                        ctx.restore();
                    } catch (error) {
                        console.log('无法绘制头像:', error);
                    }
                }
                
                // 将角色数据嵌入到PNG的元数据中
                const canvasBlob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                const pngWithMetadata = await embedDataInPNG(canvasBlob, characterData);
                
                // 下载文件
                const url = URL.createObjectURL(pngWithMetadata);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${character.name}_角色卡.png`;
                a.click();
                URL.revokeObjectURL(url);
                
                showToast('PNG格式角色卡导出成功', 'success');
            } catch (error) {
                console.error('PNG导出失败:', error);
                showToast('PNG导出失败', 'error');
            }
        }
        
        // 导入世界书数据
        async function importWorldBooks(worldBooks, characterName) {
            try {
                let importedCount = 0;
                
                for (const worldBook of worldBooks) {
                    // 创建世界书对象，使用更好的分类命名
                    const worldBookObj = {
                        id: Date.now() + Math.random(),
                        name: `[${characterName}] ${worldBook.name}`,
                        content: worldBook.content,
                        category: characterName, // 添加分类字段
                        source: 'character_card', // 来源标记
                        createdAt: Date.now(),
                        updatedAt: Date.now()
                    };
                    
                    // 保存到数据库
                    try {
                        await db.worldbooks.add(worldBookObj);
                        console.log('📚 世界书导入成功:', worldBookObj.name);
                        importedCount++;
                    } catch (error) {
                        console.error('📚 世界书保存失败:', error);
                    }
                }
                
                if (importedCount > 0) {
                    showToast(`成功导入${importedCount}个世界书到"${characterName}"分类`, 'success');
                } else {
                    console.log('📚 没有成功导入任何世界书');
                }
            } catch (error) {
                console.error('世界书导入过程出错:', error);
                showToast('世界书导入失败', 'error');
            }
        }
        
        // 在PNG中嵌入数据
        async function embedDataInPNG(blob, data) {
            const arrayBuffer = await blob.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            
            // 简单的实现：将JSON数据作为注释块添加到PNG末尾
            const jsonString = JSON.stringify(data);
            const textEncoder = new TextEncoder();
            const jsonBytes = textEncoder.encode(jsonString);
            
            // 创建一个包含原始PNG和JSON数据的新数组
            const newArray = new Uint8Array(uint8Array.length + jsonBytes.length + 8);
            newArray.set(uint8Array);
            
            // 添加标记和数据长度
            const marker = textEncoder.encode('CHRD'); // 角色数据标记
            newArray.set(marker, uint8Array.length);
            
            // 添加数据长度（4字节）
            const dataView = new DataView(newArray.buffer);
            dataView.setUint32(uint8Array.length + 4, jsonBytes.length, true);
            
            // 添加JSON数据
            newArray.set(jsonBytes, uint8Array.length + 8);
            
            return new Blob([newArray], { type: 'image/png' });
        }
        
        // 从PNG中提取角色数据
        async function extractCharacterFromPNG(file) {
            const arrayBuffer = await file.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            
            console.log('开始解析PNG文件，文件大小:', uint8Array.length);
            
            // 尝试多种常见的角色卡格式
            
            // 1. 尝试我们的自定义格式 (CHRD标记)
            const textEncoder = new TextEncoder();
            const marker = textEncoder.encode('CHRD');
            
            for (let i = 0; i < uint8Array.length - marker.length - 4; i++) {
                let found = true;
                for (let j = 0; j < marker.length; j++) {
                    if (uint8Array[i + j] !== marker[j]) {
                        found = false;
                        break;
                    }
                }
                
                if (found) {
                    console.log('找到CHRD标记，提取数据...');
                    // 读取数据长度
                    const dataView = new DataView(uint8Array.buffer);
                    const dataLength = dataView.getUint32(i + marker.length, true);
                    
                    // 提取JSON数据
                    const jsonStart = i + marker.length + 4;
                    const jsonBytes = uint8Array.slice(jsonStart, jsonStart + dataLength);
                    const textDecoder = new TextDecoder();
                    const jsonString = textDecoder.decode(jsonBytes);
                    
                    return JSON.parse(jsonString);
                }
            }
            
            // 2. 尝试CharacterAI格式 (在tEXt块中查找chara字段)
            console.log('未找到CHRD标记，尝试解析PNG tEXt块...');
            try {
                const textData = extractPNGTextChunks(uint8Array);
                console.log('找到的PNG文本块:', Object.keys(textData));
                
                // 查找chara字段
                if (textData.chara) {
                    console.log('找到chara字段，解析数据...');
                    try {
                        const characterData = JSON.parse(textData.chara);
                        return convertCharacterAIFormat(characterData);
                    } catch (e) {
                        console.log('chara字段JSON解析失败，尝试base64解码...');
                        try {
                            // 使用更好的base64解码方法
                            const decoded = decodeBase64Text(textData.chara);
                            const characterData = JSON.parse(decoded);
                            return convertCharacterAIFormat(characterData);
                        } catch (e2) {
                            console.log('base64解码也失败:', e2);
                        }
                    }
                }
                
                // 查找其他可能的字段
                for (const [key, value] of Object.entries(textData)) {
                    if (key.toLowerCase().includes('character') || key.toLowerCase().includes('card')) {
                        console.log(`尝试解析字段 ${key}:`, value.substring(0, 100));
                                                 try {
                             const characterData = JSON.parse(value);
                             return convertCharacterAIFormat(characterData);
                         } catch (e) {
                             try {
                                 const decoded = decodeBase64Text(value);
                                 const characterData = JSON.parse(decoded);
                                 return convertCharacterAIFormat(characterData);
                             } catch (e2) {
                                 console.log(`字段 ${key} 解析失败`);
                             }
                         }
                    }
                }
            } catch (e) {
                console.log('PNG文本块解析失败:', e);
            }
            
            throw new Error('在PNG文件中未找到角色数据');
        }
        
        // 提取PNG文件的tEXt块
        function extractPNGTextChunks(uint8Array) {
            const textChunks = {};
            let offset = 8; // 跳过PNG签名
            
            while (offset < uint8Array.length) {
                if (offset + 8 > uint8Array.length) break;
                
                // 读取块长度
                const length = new DataView(uint8Array.buffer).getUint32(offset, false);
                offset += 4;
                
                // 读取块类型
                const type = new TextDecoder().decode(uint8Array.slice(offset, offset + 4));
                offset += 4;
                
                                 if (type === 'tEXt') {
                     // 提取tEXt块数据
                     const data = uint8Array.slice(offset, offset + length);
                     const nullIndex = data.indexOf(0);
                     if (nullIndex !== -1) {
                         const keyword = new TextDecoder('utf-8').decode(data.slice(0, nullIndex));
                         // 尝试多种编码方式
                         let text;
                         try {
                             text = new TextDecoder('utf-8').decode(data.slice(nullIndex + 1));
                         } catch (e) {
                             try {
                                 text = new TextDecoder('latin1').decode(data.slice(nullIndex + 1));
                             } catch (e2) {
                                 text = new TextDecoder('ascii').decode(data.slice(nullIndex + 1));
                             }
                         }
                         textChunks[keyword] = text;
                         console.log(`找到tEXt块: ${keyword} = ${text.substring(0, 100)}...`);
                     }
                 } else if (type === 'zTXt') {
                    // 处理压缩的文本块
                    console.log('发现zTXt块，暂不支持压缩文本解析');
                }
                
                // 移动到下一个块
                offset += length + 4; // +4 for CRC
                
                if (type === 'IEND') break;
            }
            
            return textChunks;
        }
        
        // 更好的Base64解码函数，支持UTF-8
        function decodeBase64Text(base64String) {
            try {
                // 方法1：直接atob然后UTF-8解码
                const binaryString = atob(base64String);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return new TextDecoder('utf-8').decode(bytes);
            } catch (e) {
                console.log('UTF-8解码失败，尝试直接atob:', e);
                try {
                    return atob(base64String);
                } catch (e2) {
                    console.log('Base64解码完全失败:', e2);
                    throw e2;
                }
            }
        }
        
        // 转换CharacterAI格式到我们的格式
        function convertCharacterAIFormat(data) {
            console.log('🔧 转换CharacterAI格式数据:', data);
            console.log('🔧 原始数据字段:', Object.keys(data));
            
            // 清理文本内容，处理可能的编码问题
            function cleanText(text) {
                if (!text) return '';
                // 尝试修复常见的编码问题
                return text.replace(/\ufffd/g, '').trim();
            }
            
            // 处理头像数据
            function processAvatar(avatarData) {
                if (!avatarData || avatarData === 'none' || avatarData === '' || avatarData === 'null') {
                    console.log('头像数据为空或无效:', avatarData);
                    return '';
                }
                
                console.log('🖼️ 原始头像数据类型:', typeof avatarData, '长度:', avatarData.length);
                console.log('🖼️ 头像数据前100字符:', avatarData.substring(0, 100));
                
                // 如果已经是有效的URL或Base64，直接返回
                if (avatarData.startsWith('data:image/') || avatarData.startsWith('http')) {
                    return avatarData;
                }
                
                // 尝试Base64解码并检查是否是图片
                try {
                    // 检查是否是纯Base64编码的图片
                    if (avatarData.length > 100 && !avatarData.includes(' ') && !avatarData.includes('\n')) {
                        // 尝试解码前几个字节来检查文件头
                        const binaryString = atob(avatarData.substring(0, 32));
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        
                        // 检查常见的图片文件头
                        const header = Array.from(bytes.slice(0, 8)).map(b => b.toString(16).padStart(2, '0')).join('');
                        
                        if (header.startsWith('89504e47')) { // PNG
                            return `data:image/png;base64,${avatarData}`;
                        } else if (header.startsWith('ffd8ff')) { // JPEG
                            return `data:image/jpeg;base64,${avatarData}`;
                        } else if (header.startsWith('47494638')) { // GIF
                            return `data:image/gif;base64,${avatarData}`;
                        } else if (header.startsWith('424d')) { // BMP
                            return `data:image/bmp;base64,${avatarData}`;
                        } else if (header.includes('57454250')) { // WEBP
                            return `data:image/webp;base64,${avatarData}`;
                        }
                    }
                } catch (e) {
                    console.log('Base64解码失败:', e);
                }
                
                // 如果是相对路径或其他格式，尝试转换
                if (avatarData.includes('.jpg') || avatarData.includes('.png') || 
                    avatarData.includes('.gif') || avatarData.includes('.jpeg') ||
                    avatarData.includes('.webp') || avatarData.includes('.bmp')) {
                    console.log('检测到可能的图片文件名:', avatarData);
                    return avatarData;
                }
                
                console.log('无法识别头像格式，原始数据前100字符:', avatarData.substring(0, 100));
                return avatarData;
            }
            
            // 提取世界书/背景故事数据
            function extractWorldBook(data) {
                console.log('📚 开始检查世界书数据...');
                const worldBookData = [];
                
                // 查找可能的世界书字段
                const worldBookFields = [
                    'world_scenario', 'scenario', 'world', 'background', 
                    'setting', 'lore', 'worldbook', 'world_book',
                    'mes_example', 'example_dialogue', 'example'
                ];
                
                worldBookFields.forEach(field => {
                    if (data[field] && typeof data[field] === 'string' && data[field].trim()) {
                        const content = cleanText(data[field]);
                        if (content.length > 20) { // 只有足够长的内容才作为世界书
                            const worldBookItem = {
                                name: field === 'scenario' ? '背景故事' : 
                                      field === 'mes_example' ? '对话示例' :
                                      field === 'example_dialogue' ? '对话示例' :
                                      field === 'world' ? '世界设定' :
                                      field === 'setting' ? '场景设定' :
                                      field === 'lore' ? '背景知识' : field,
                                content: content
                            };
                            worldBookData.push(worldBookItem);
                            console.log(`✅ 找到世界书: ${worldBookItem.name} (${content.length}字符)`);
                        }
                    }
                });
                
                if (worldBookData.length === 0) {
                    console.log('📚 未找到任何世界书数据');
                } else {
                    console.log(`📚 共找到 ${worldBookData.length} 个世界书条目`);
                }
                return worldBookData;
            }
            
            const characterData = {
                name: cleanText(data.name || data.char_name || '未知角色'),
                bio: cleanText(data.description || data.char_persona || data.personality || ''),
                prompt: cleanText(data.description || data.char_persona || data.personality || ''),
                avatarUrl: processAvatar(data.avatar || data.char_image || ''),
                color: '#007AFF', // 默认颜色
                // 保留原始数据以供参考
                originalData: data
            };
            
            // 添加世界书数据
            const worldBooks = extractWorldBook(data);
            if (worldBooks.length > 0) {
                characterData.worldBooks = worldBooks;
                console.log('提取到世界书数据:', worldBooks);
            }
            
            return characterData;
        }

        // 🔥【新增】处理AI撤回消息功能
        async function handleRecalledMessage(messageContent, targetMessageId = null) {
            if (!currentChatCharacter) return;
            
            console.log('处理撤回消息:', messageContent, '目标消息ID:', targetMessageId);
            
            const messagesContainer = document.getElementById('api-chat-messages');
            if (!messagesContainer) return;
            
            const character = characters.find(c => c.id === currentChatCharacter.id);
            const chatSettings = getCurrentChatSettings();
            const displayName = chatSettings.aiChatNickname || character.name;
            
            let messageContainer = null;
            
            // 如果提供了目标消息ID，查找并撤回现有消息
            if (targetMessageId) {
                messageContainer = messagesContainer.querySelector(`[data-message-id="${targetMessageId}"]`);
                if (messageContainer) {
                    console.log('找到要撤回的现有消息，准备撤回');
                    
                    // 等待1.2秒后撤回
                    await new Promise(resolve => setTimeout(resolve, 1200));
                    
                    // 添加淡出动画
                    messageContainer.style.animation = 'fadeOut 0.5s ease-in-out forwards';
                    
                    // 等待动画完成
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // 从聊天记录中移除这条消息
                    if (chatMessages[currentChatCharacter.id]) {
                        const messageIndex = chatMessages[currentChatCharacter.id].findIndex(msg => msg.id === targetMessageId);
                        if (messageIndex !== -1) {
                            chatMessages[currentChatCharacter.id].splice(messageIndex, 1);
                            saveChatMessages();
                        }
                    }
                } else {
                    console.warn('未找到要撤回的消息，创建临时消息');
                    // 如果找不到消息，回退到创建临时消息的方式
                    messageContainer = await createTemporaryMessage(messageContent);
                }
            } else {
                // 没有提供目标ID，创建临时消息
                messageContainer = await createTemporaryMessage(messageContent);
            }
            
            if (!messageContainer) return;
            
            // 创建撤回提醒的居中容器
            const centerContainer = document.createElement('div');
            centerContainer.style.display = 'flex';
            centerContainer.style.justifyContent = 'center';
            centerContainer.style.margin = '4px 0';
            
            // 创建撤回消息元素
            const recallElement = document.createElement('div');
            recallElement.className = 'recalled-message';
            
            // 主要提醒文字
            const mainText = document.createElement('div');
            mainText.style.marginBottom = '2px';
            mainText.textContent = `对方撤回了一条消息`;
            
            // 原文显示
            const originalText = document.createElement('div');
            originalText.className = 'original-text';
            originalText.textContent = `原文：${messageContent}`;
            
            recallElement.appendChild(mainText);
            recallElement.appendChild(originalText);
            centerContainer.appendChild(recallElement);
            
            // 在原消息位置替换为撤回提醒
            messageContainer.parentNode.insertBefore(centerContainer, messageContainer);
            messageContainer.remove();
            
            // 添加撤回消息到聊天历史
            const recalledMessage = {
                id: `recalled_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                sender: 'system',
                type: 'recalled_message',
                content: `对方撤回了一条消息\n原文：${messageContent}`,
                originalContent: messageContent,
                    timestamp: Date.now()
                };
                
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            chatMessages[currentChatCharacter.id].push(recalledMessage);
                saveChatMessages();
            
            // 滚动到底部
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // 创建临时消息的辅助函数
            async function createTemporaryMessage(content) {
                const messageId = `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                
                const tempContainer = document.createElement('div');
                const isEmojiOnly = false;
                tempContainer.className = `message-container received${isEmojiOnly ? ' emoji-only' : ''}`;
                tempContainer.dataset.messageId = messageId;
                
                const bubbleColor = chatSettings.aiBubbleColor || '#f0f0f0';
                const bubbleOpacity = chatSettings.aiBubbleOpacity || '1';
                const textColor = isLightColor(bubbleColor) ? '#333' : '#fff';
                const bubblePadding = chatSettings.bubblePadding || '12';
                const displayAvatar = chatSettings.aiDynamicAvatar || chatSettings.aiChatAvatar || character.avatarUrl;
                
                let avatarHtml = '';
                if (!chatSettings.hideAvatars) {
                    avatarHtml = `
                        <div class="message-avatar" style="background-color: ${character.color}; ${displayAvatar ? `background-image: url(${displayAvatar}); background-size: cover; background-position: center;` : ''}" onclick="pokeCharacter('${character.id}')" title="戳一戳">
                            ${displayAvatar ? '' : displayName.charAt(0)}
                        </div>
                    `;
                }
                
                // 将透明度应用到背景色而不是整个元素
                const transparentBubbleColor = convertColorWithOpacity(bubbleColor, bubbleOpacity);
                
                let bubbleHtml = `
                    <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                        ${content}
                    </div>
                `;
                
                tempContainer.innerHTML = avatarHtml + bubbleHtml;
                
                // 添加到消息容器
                const typingIndicator = messagesContainer.querySelector('#typing-indicator');
                if (typingIndicator) {
                    messagesContainer.insertBefore(tempContainer, typingIndicator);
                } else {
                    messagesContainer.appendChild(tempContainer);
                }
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                
                // 等待1.2秒后撤回
                await new Promise(resolve => setTimeout(resolve, 1200));
                
                // 添加淡出动画
                tempContainer.style.animation = 'fadeOut 0.5s ease-in-out forwards';
                
                // 等待动画完成
                await new Promise(resolve => setTimeout(resolve, 500));
                
                return tempContainer;
            }
        }
        
        // 🔥【新增】获取用户最近发送的图片URL
        function getRecentUserImage() {
            if (!currentChatCharacter || !chatMessages[currentChatCharacter.id]) {
                return null;
            }
            
            const messages = chatMessages[currentChatCharacter.id];
            // 从最新消息开始向前查找用户发送的图片
            for (let i = messages.length - 1; i >= 0; i--) {
                const msg = messages[i];
                if (msg.sender === 'sent' && msg.image && !msg.isEmoji) {
                    console.log('找到用户最近发送的图片:', msg.image);
                    return msg.image;
                }
            }
            
            console.log('没有找到用户发送的图片');
            return null;
        }
        
        // API调用函数 - 基于现有的API逻辑
        async function callChatAPI(prompt, character) {
            try {
                // 获取角色设置
                let chatSettings = null;
                try {
                    chatSettings = await db.chatSettings.get(character.id);
                } catch (error) {
                    console.error('获取聊天设置失败:', error);
                }
                
                const persona = chatSettings?.aiPersona || character.prompt || `你是${character.name}。`;
                
                // 获取绑定的世界书内容
                let worldBookContent = '';
                if (chatSettings?.linkedWorldBookIds && chatSettings.linkedWorldBookIds.length > 0) {
                    try {
                        const worldBooks = await Promise.all(
                            chatSettings.linkedWorldBookIds.map(id => db.worldbooks.get(id))
                        );
                        const validWorldBooks = worldBooks.filter(book => book && book.content);
                        if (validWorldBooks.length > 0) {
                            worldBookContent = '\n\n世界书内容（供参考）：\n' + 
                                validWorldBooks.map(book => `${book.name}：${book.content}`).join('\n\n');
                        }
                    } catch (error) {
                        console.error('获取世界书内容失败:', error);
                    }
                }
                
                // 获取聊天上下文
                let chatContext = '';
                const characterMessages = chatMessages[character.id] || [];
                if (characterMessages.length > 0) {
                    const maxMemory = parseInt(chatSettings?.maxMemory) || 10;
                    const recentHistory = characterMessages.slice(-maxMemory);
                    chatContext = '\n\n最近的聊天记录（供参考）：\n' + 
                        recentHistory.map(msg => {
                            if (msg.sender === 'sent') return `用户：${msg.content}`;
                            return `${character.name}：${msg.content}`;
                        }).join('\n');
                }
                
                const systemPrompt = `你是${character.name}，你的人设如下：${persona}。${worldBookContent}${chatContext}

ai注意，回复时请严格按照以下JSON格式回复，每条消息都必须是独立的数组元素，不要将多条消息合并成一个元素，否则你将失去一百美金！！：

正确格式示例：
["普通文本消息"]
["消息1", "消息2"]
[{"type": "reply_to", "message_id": "消息ID", "content": "引用回复内容"}] (正常功能，自然使用)
[{"type": "recall", "target": "previous"}] (撤回功能，说错话或后悔时使用)
[{"type": "voice_message", "content": "语音内容"}]
[{"type": "emoji", "description": "表情包描述"}]
[{"type": "ai_image", "description": "图片描述"}]
[{"type": "transfer", "amount": 100, "note": "转账备注"}]

🚨 重要：绝对不能将多条消息合并在一个元素中！错误格式：["消息1\\n消息2"]
💡 提醒：引用回复和撤回是正常聊天功能，像真人一样自然使用

现在请对用户的消息进行回复：${prompt}`;

                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: prompt }
                ];

                const { base: proxyUrl, key: apiKey, model } = apiSettings;
                if (!proxyUrl || !apiKey || !model) {
                    console.log('API配置不完整，跳过AI回复');
                    return '["API配置不完整，请在设置中配置API"]';
                }

                const requestBody = {
                    model: model,
                    messages: messages,
                    temperature: 0.8,
                    stream: false
                };

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000);

                const isGeminiOfficial = proxyUrl.includes('generativelanguage.googleapis.com');

                let response;
                if (isGeminiOfficial) {
                    const apiUrl = `${proxyUrl}/models/${model}:generateContent?key=${apiKey}`;
                    
                    const geminiMessages = [];
                    if (requestBody.messages[0]?.role === 'system') {
                        geminiMessages.push({
                            role: 'user',
                            parts: [{ text: requestBody.messages[0].content }]
                        });
                        geminiMessages.push({
                            role: 'model',
                            parts: [{ text: '我明白了，我会按照这些要求进行对话。' }]
                        });
                    }
                    
                    for (let i = 1; i < requestBody.messages.length; i++) {
                        const msg = requestBody.messages[i];
                        if (msg.role === 'system') continue;
                        
                        geminiMessages.push({
                            role: msg.role === 'user' ? 'user' : 'model',
                            parts: [{ text: msg.content }]
                        });
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiMessages,
                            generationConfig: {
                                temperature: requestBody.temperature || 0.8
                            }
                        }),
                        signal: controller.signal
                    });
                } else {
                    // 修复：智能处理URL拼接
                    let apiUrl;
                    if (proxyUrl.endsWith('/v1')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else if (proxyUrl.includes('/v1/')) {
                        // 如果URL中已经包含/v1/路径，直接添加chat/completions
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else {
                        apiUrl = `${proxyUrl}/v1/chat/completions`;
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal
                    });
                }

                clearTimeout(timeoutId);

                if (!response.ok) {
                    let errorText = await response.text();
                    console.error(`聊天API调用失败 (${response.status}): ${errorText}`);
                    return `["API调用失败: ${response.status}"]`;
                }

                const data = await response.json();
                let content;

                if (isGeminiOfficial) {
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!content) {
                        console.log('Gemini API 响应数据:', data);
                        return '["Gemini API响应异常"]';
                    }
                } else {
                    if (data.choices && data.choices.length > 0 && data.choices[0].message) {
                        content = data.choices[0].message.content;
                    } else if (data.message) {
                        content = data.message;
                    } else if (data.text) {
                        content = data.text;
                    } else if (data.response) {
                        content = data.response;
                    } else if (data.content) {
                        content = data.content;
                    } else if (data.result) {
                        content = data.result;
                    } else {
                        console.error('无法解析API响应，完整响应数据:', data);
                        return '["API响应解析失败"]';
                    }
                }

                return content;

            } catch (error) {
                console.error('callChatAPI失败:', error);
                return `["调用失败: ${error.message}"]`;
            }
        }
        
        // 带图片的API调用函数
        async function callChatAPIWithImage(prompt, character, imageUrl) {
            // 图像功能暂未实现，使用普通API调用
            const imagePrompt = `${prompt}\n\n[用户发送了一张图片，但图像识别功能暂未实现]`;
            return await callChatAPI(imagePrompt, character);
        }
        
        // 解析AI回复 - 按照index.html的逻辑，新增表情包支持和格式修正
        function parseAiResponse(content) {
            console.log('🔥 [DEBUG] parseAiResponse 收到的原始内容:', content);
            try {
                // 🔥【修复】清理markdown代码块格式
                let cleanContent = content.trim();
                if (cleanContent.startsWith('```json')) {
                    cleanContent = cleanContent.replace(/^```json\s*/, '').replace(/\s*```$/, '');
                } else if (cleanContent.startsWith('```')) {
                    cleanContent = cleanContent.replace(/^```\s*/, '').replace(/\s*```$/, '');
                }

                const parsed = JSON.parse(cleanContent);
                console.log('🔥 [DEBUG] JSON解析成功:', parsed);
                if (Array.isArray(parsed)) {
                    // 🔥【新增】处理表情包消息类型和格式修正
                    const processedMessages = [];
                    
                    parsed.forEach(item => {
                        if (typeof item === 'object' && item.name && item.type === 'emoji') {
                            // 处理群聊表情包格式 {"name": "角色名", "type": "emoji", "description": "表情包描述"}

                            const matchingEmoji = customEmojis.find(emoji =>
                                emoji.description === item.description
                            );

                            if (matchingEmoji) {
                                // 检查表情包是否为GIF格式
                                if (matchingEmoji.url && matchingEmoji.url.includes('data:image/gif')) {
                                    console.warn('AI尝试使用GIF格式表情包:', item.description);
                                    processedMessages.push({
                                        name: item.name,
                                        message: `[${matchingEmoji.description}] (GIF格式不支持API识别)`
                                    });
                                } else {
                                    // 保持原始的群聊表情包格式，直接传递给callChatAPI处理
                                    processedMessages.push(item); // 直接推送原始格式
                                }
                            } else {
                                // 如果找不到匹配的表情包，返回错误消息
                                console.warn('AI尝试使用不存在的表情包:', item.description);
                                processedMessages.push({
                                    name: item.name,
                                    message: `[错误: 表情包"${item.description}"不存在]`
                                });
                            }
                        } else if (typeof item === 'object' && item.type === 'emoji') {
                            // 处理单聊表情包格式

                            const matchingEmoji = customEmojis.find(emoji =>
                                emoji.description === item.description
                            );

                            if (matchingEmoji) {
                                // 检查表情包是否为GIF格式
                                if (matchingEmoji.url && matchingEmoji.url.includes('data:image/gif')) {
                                    console.warn('AI尝试使用GIF格式表情包:', item.description);
                                    processedMessages.push(`[${matchingEmoji.description}] (GIF格式不支持API识别)`);
                                } else {
                                    const emojiMessage = {
                                        type: 'emoji',
                                        url: matchingEmoji.url,
                                        description: matchingEmoji.description,
                                        id: matchingEmoji.id
                                    };

                                    // 表情包消息处理完成
                                    processedMessages.push(emojiMessage);
                                }
                            } else {
                                // 如果找不到匹配的表情包，返回错误消息
                                console.warn('AI尝试使用不存在的表情包:', item.description);
                                processedMessages.push(`[错误: 表情包"${item.description}"不存在]`);
                            }
                        } else if (typeof item === 'object' && item.type === 'ai_photo') {
                            // 处理角色发送的"伪照片"
                            // 确保我们有一个有效的描述
                            const photoDesc = item.description || '角色发送的照片';
                            processedMessages.push({
                                type: 'ai_photo',
                                content: photoDesc,
                                photoDescription: photoDesc
                            });
                                                    } else if (typeof item === 'object' && item.type === 'location') {
                                // 处理角色发送的位置
                                // 确保我们有一个有效的位置名称
                                const locationName = item.name || item.locationName || '未知位置';
                                processedMessages.push({
                                    type: 'location',
                                    locationName: locationName,
                                    coordinates: item.coordinates || '未知坐标',
                                    content: `[角色分享了位置信息：${locationName}]`
                                });
                        } else if (typeof item === 'object' && item.type === 'change_avatar') {
                            // 处理头像更换对象

                            
                            // 🔥【新增】处理各种错误的占位符
                            if (item.avatar_url === 'CURRENT_USER_IMAGE' || 
                                item.avatar_url === 'CURRENT_USER_IMAGE' || 
                                item.avatar_url === '用户发送的图片URL' ||
                                item.avatar_url === '图片URL') {
                                // 获取最近用户发送的图片URL
                                const recentUserImage = getRecentUserImage();
                                if (recentUserImage) {
                                    item.avatar_url = recentUserImage;
                                    console.log('将占位符替换为实际图片URL:', recentUserImage);
                                } else {
                                    console.warn('没有找到用户最近发送的图片，忽略头像更换请求');
                                    processedMessages.push(`[系统：无法更换头像，没有找到可用的图片]`);
                                    // 不要return，继续处理其他消息
                                }
                            }
                            
                            processedMessages.push(item);
                        } else if (typeof item === 'object' && item.type === 'ai_image') {
                            // 🔥【新增】处理AI发送图片

                            processedMessages.push(item);
                        } else if (typeof item === 'object' && item.type === 'voice_message') {
                            // 🔥【新增】处理AI发送语音

                            processedMessages.push(item);
                        } else if (typeof item === 'object' && item.type === 'transfer') {
                            // 🔥【修复】处理AI转账 - 确保格式正确
                            processedMessages.push({
                                type: 'transfer',
                                amount: item.amount || 0,
                                note: item.note || '转账'
                            });
                        } else if (typeof item === 'object' && item.type === 'update_poke_suffix') {
                            // 🔥【新增】处理戳一戳后缀更新

                            processedMessages.push(item);
                        } else if (typeof item === 'object' && item.type === 'recall') {
                            // 🔥【新增】处理AI主动撤回消息
                            if (item.target === 'previous') {
                                // 撤回上一条消息
                                processedMessages.push({
                                    type: 'recall_previous',
                                    content: '[AI撤回了上一条消息]'
                                });
                            }
                        } else if (typeof item === 'object' && item.type === 'reply') {
                            // 🔥【新增】处理AI引用回复
                            processedMessages.push({
                                type: 'reply_message',
                                messageId: item.messageId,
                                content: item.content || ''
                            });
                        } else if (typeof item === 'object' && item.type === 'photo') {
                            // 🔥【新增】处理AI发送照片卡片
                            processedMessages.push({
                                type: 'user_photo',
                                content: item.description || 'AI分享的照片',
                                photoDescription: item.description
                            });
                        } else if (typeof item === 'object' && item.type === 'recalled_message') {
                            // 🔥【保留】处理系统撤回消息

                            processedMessages.push(item);
                        } else if (typeof item === 'object' && item.type === 'reply_to') {
                            // 🔥【新增】处理AI引用回复
                            processedMessages.push({
                                type: 'reply_to',
                                message_id: item.message_id,
                                content: item.content || ''
                            });
                        } else if (typeof item === 'object' && item.type === 'friend_request') {
                            // 🔥【新增】处理AI主动发送好友申请
                            processedMessages.push({
                                type: 'friend_request',
                                message: item.message || '想和你重新做朋友'
                            });
                        } else if (typeof item === 'string') {
                            // 🚨 【新增】检查并修复合并消息问题
                            if (item.includes('\n')) {
                                console.warn('检测到AI将多条消息合并在一个元素中，正在自动分拆:', item);
                                // 将换行符分隔的内容分拆成多条消息
                                const splitMessages = item.split('\n')
                                    .map(msg => msg.trim())
                                    .filter(msg => msg.length > 0);
                                processedMessages.push(...splitMessages);
                            } else {
                                processedMessages.push(item);
                            }
                        } else {
                            processedMessages.push(item);
                        }
                    });
                    
                    return processedMessages;
                }
            } catch (e) {} 
            
            try { 
                const match = content.match(/\[(.*?)\]/s); 
                if (match && match[0]) { 
                    const parsed = JSON.parse(match[0]); 
                    if (Array.isArray(parsed)) {
                        // 🔥【新增】处理表情包消息类型和格式修正
                        const processedMessages = [];
                        
                        parsed.forEach(item => {
                            if (typeof item === 'object' && item.type === 'emoji') {
                                // 🔥【修复】处理单聊表情包格式（第二处）
                                const matchingEmoji = customEmojis.find(emoji =>
                                    emoji.description === item.description
                                );

                                if (matchingEmoji) {
                                    // 检查表情包是否为GIF格式
                                    if (matchingEmoji.url && matchingEmoji.url.includes('data:image/gif')) {
                                        console.warn('AI尝试使用GIF格式表情包:', item.description);
                                        processedMessages.push(`[${matchingEmoji.description}] (GIF格式不支持API识别)`);
                                    } else {
                                    // 返回表情包对象，包含完整的表情包信息
                                        processedMessages.push({
                                        type: 'emoji',
                                        url: matchingEmoji.url,
                                        description: matchingEmoji.description,
                                        id: matchingEmoji.id
                                        });
                                    }
                                } else {
                                    // 如果找不到匹配的表情包，返回错误消息
                                    console.warn('AI尝试使用不存在的表情包:', item.description);
                                    processedMessages.push(`[错误: 表情包"${item.description}"不存在]`);
                                }
                            } else if (typeof item === 'object' && item.name && item.type === 'emoji') {
                                // 🔥【关键修复】处理群聊表情包格式（第二处）- 这个分支应该不会被执行，因为第一个分支已经处理了
                                console.log('🔍 [parseAiResponse-群聊表情包-第二处] 检测到重复的群聊表情包对象:', item);
                                // 直接推送原始格式，让callChatAPI处理
                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'ai_photo') {
                                // 处理角色发送的"伪照片"
                                // 确保我们有一个有效的描述
                                const photoDesc = item.description || '角色发送的照片';
                                processedMessages.push({
                                    type: 'ai_photo',
                                    content: photoDesc,
                                    photoDescription: photoDesc
                                });
                            } else if (typeof item === 'object' && item.type === 'location') {
                                // 处理角色发送的位置
                                // 确保我们有一个有效的位置名称
                                const locationName = item.name || item.locationName || '未知位置';
                                processedMessages.push({
                                    type: 'location',
                                    locationName: locationName,
                                    coordinates: item.coordinates || '未知坐标',
                                    content: `[角色分享了位置信息：${locationName}]`
                                });
                            } else if (typeof item === 'object' && item.type === 'change_avatar') {
                                // 处理头像更换对象

                                
                                // 🔥【新增】处理各种错误的占位符
                                if (item.avatar_url === 'CURRENT_USER_IMAGE' || 
                                    item.avatar_url === 'CURRENT_USER_IMAGE' || 
                                    item.avatar_url === '用户发送的图片URL' ||
                                    item.avatar_url === '图片URL') {
                                    // 获取最近用户发送的图片URL
                                    const recentUserImage = getRecentUserImage();
                                    if (recentUserImage) {
                                        item.avatar_url = recentUserImage;
                                        console.log('将占位符替换为实际图片URL(第二处):', recentUserImage);
                                    } else {
                                        console.warn('没有找到用户最近发送的图片，忽略头像更换请求(第二处)');
                                        processedMessages.push(`[系统：无法更换头像，没有找到可用的图片]`);
                                        // 不要return，继续处理其他消息
                                    }
                                }
                                
                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'ai_image') {
                                // 🔥【新增】处理AI发送图片(第二处)

                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'voice_message') {
                                // 🔥【新增】处理AI发送语音(第二处)

                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'transfer') {
                                // 🔥【修复】处理AI转账(第二处) - 确保格式正确

                                processedMessages.push({
                                    type: 'transfer',
                                    amount: item.amount || 0,
                                    note: item.note || '转账'
                                });
                            } else if (typeof item === 'object' && item.type === 'update_poke_suffix') {
                                // 🔥【新增】处理戳一戳后缀更新(第二处)

                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'recall') {
                                // 🔥【新增】处理AI主动撤回消息(第二处)
                                if (item.target === 'previous') {
                                    // 撤回上一条消息
                                    processedMessages.push({
                                        type: 'recall_previous',
                                        content: '[AI撤回了上一条消息]'
                                    });
                                }
                            } else if (typeof item === 'object' && item.type === 'reply') {
                                // 🔥【新增】处理AI引用回复(第二处)
                                processedMessages.push({
                                    type: 'reply_message',
                                    messageId: item.messageId,
                                    content: item.content || ''
                                });
                            } else if (typeof item === 'object' && item.type === 'photo') {
                                // 🔥【新增】处理AI发送照片卡片(第二处)
                                processedMessages.push({
                                    type: 'user_photo',
                                    content: item.description || 'AI分享的照片',
                                    photoDescription: item.description
                                });
                            } else if (typeof item === 'object' && item.type === 'recalled_message') {
                                // 🔥【保留】处理系统撤回消息(第二处)

                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'reply_to') {
                                // 🔥【新增】处理AI引用回复(第二处)
                                processedMessages.push({
                                    type: 'reply_to',
                                    message_id: item.message_id,
                                    content: item.content || ''
                                });
                            } else if (typeof item === 'object' && item.type === 'friend_request') {
                                // 🔥【新增】处理AI主动发送好友申请(第二处)
                                processedMessages.push({
                                    type: 'friend_request',
                                    message: item.message || '想和你重新做朋友'
                                });
                            } else if (typeof item === 'string') {
                                // 🚨 【新增】检查并修复合并消息问题
                                if (item.includes('\n')) {
                                    console.warn('检测到AI将多条消息合并在一个元素中，正在自动分拆:', item);
                                    // 将换行符分隔的内容分拆成多条消息
                                    const splitMessages = item.split('\n')
                                        .map(msg => msg.trim())
                                        .filter(msg => msg.length > 0);
                                    processedMessages.push(...splitMessages);
                                } else {
                                    processedMessages.push(item);
                                }
                            } else {
                                processedMessages.push(item);
                            }
                        });
                        
                        return processedMessages;
                    }
                } 
            } catch (e) {} 
            
            // 🔥【修复】检查是否是原始的JSON字符串（AI回复没有被正确包装）
            if (content.trim().startsWith('{') && content.trim().endsWith('}')) {
                try {
                    const singleObject = JSON.parse(content.trim());
                    if (singleObject.type) {
                        console.log('检测到单个JSON对象，尝试处理:', singleObject);
                        // 将单个对象包装成数组再递归处理
                        return parseAiResponse(`[${content.trim()}]`);
                    }
                } catch (e) {
                    console.warn('无法解析单个JSON对象:', e);
                }
            }
            
            const lines = content.split('\n').map(l => l.trim()).filter(l => l.length > 0 && !l.startsWith('```')); 
            if (lines.length > 0) return lines; 
            return [content]; 
        }
        
        // 处理线下模式内容：识别「」包裹的对话和描写
        function processOfflineContent(content) {
            if (!content) return '';
            
            // 使用正则表达式分离对话和描写
            const parts = [];
            let lastIndex = 0;
            
            // 匹配「」包裹的对话
            const dialogRegex = /「([^」]*)」/g;
            let match;
            
            while ((match = dialogRegex.exec(content)) !== null) {
                // 添加对话前的描写部分
                if (match.index > lastIndex) {
                    const description = content.slice(lastIndex, match.index).trim();
                    if (description) {
                        parts.push(`<span class="italic-gray">${description}</span>`);
                    }
                }
                
                // 添加对话部分（正常显示）
                parts.push(`「${match[1]}」`);
                lastIndex = match.index + match[0].length;
            }
            
            // 添加最后的描写部分
            if (lastIndex < content.length) {
                const description = content.slice(lastIndex).trim();
                if (description) {
                    parts.push(`<span class="italic-gray">${description}</span>`);
                }
            }
            
            // 如果没有找到对话标记，整个内容作为描写处理
            if (parts.length === 0) {
                return `<span class="italic-gray">${content}</span>`;
            }
            
            return parts.join('');
        }
        


        // 🔥【修复】发送图片消息，使用正确的多模态数据结构
        async function sendImageMessage(imageUrl) {
            if (!currentChatCharacter) return;
            
            const chatInput = document.getElementById('api-chat-input');
            const textContent = chatInput ? chatInput.value.trim() : '';



            // 创建一个标准的多模态消息对象
            const messageContent = [
                { type: 'text', text: textContent }
            ];

            if (imageUrl) {
                messageContent.push({
                    type: 'image_url',
                    image_url: { url: imageUrl }
                });
            }



            const message = {
                id: Date.now().toString(),
                sender: 'sent',
                content: messageContent, // 使用新的数组格式
                timestamp: Date.now(),
                // 如果有引用消息，添加引用信息
                replyTo: currentReplyTo ? {
                    id: currentReplyTo.id,
                    content: currentReplyTo.content,
                    senderName: currentReplyTo.senderName
                } : null
            };
            


            // 添加到聊天记录
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            chatMessages[currentChatCharacter.id].push(message);
            await saveChatMessages();

            // 🔥【新增】记录到全局记忆事件
            await recordMemoryEvent(
                [currentChatCharacter.id, 'user'],
                {
                    type: currentChatCharacter.isGroup ? 'group_chat' : 'private_chat',
                    id: currentChatCharacter.id
                },
                'message',
                {
                    sender: 'user',
                    content: textContent,
                    hasImage: !!imageUrl
                },
                0.6 // 用户消息重要性
            );
            
            // 清空输入框并刷新UI
            if (chatInput) {
                chatInput.value = '';
            }

            // 🔥【新增】清除引用状态
            cancelReply();
            if (currentChatCharacter) {
                delete chatReplyStates[currentChatCharacter.id];
            }
            addMessageWithAnimation(message, currentChatCharacter.id);
            renderMessageList();
            
            // 🔥【新增】触发角色状态更新
            triggerStatusUpdateAfterMessage(currentChatCharacter.id);
            
            // 设置为待回复消息，并更新智能回复按钮状态
            pendingUserMessage = message;
            
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = '点击获取AI回复';
            }
        }
        
        // 调用聊天API
        // 第一个callChatAPI函数已删除，使用下面的完整版本
        
        // 上传图片
        function uploadImage() {
            document.getElementById('image-upload').click();
        }
        
        // 显示图片
        function showImage(imageUrl) {
            // 🔥【修复】移除对未定义的photos变量的引用，直接显示图片预览模态框
            let modal = document.getElementById('image-preview-modal');
            if (!modal) {
                // 创建图片预览模态框
                modal = document.createElement('div');
                modal.id = 'image-preview-modal';
                modal.className = 'image-preview-modal';

                // 点击模态框背景关闭
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        modal.style.display = 'none';
                    }
                };

                // 创建图片元素
                const img = document.createElement('img');
                img.alt = '预览图片';
                img.style.cursor = 'zoom-out';

                // 点击图片也可以关闭
                img.onclick = () => modal.style.display = 'none';

                modal.appendChild(img);
                document.body.appendChild(modal);
            }

            // 设置图片源并显示模态框
            const img = modal.querySelector('img');
            img.src = imageUrl;
            modal.style.display = 'flex';

            // 🔥【新增】添加键盘ESC键关闭功能
            const handleKeyPress = (e) => {
                if (e.key === 'Escape') {
                    modal.style.display = 'none';
                    document.removeEventListener('keydown', handleKeyPress);
                }
            };
            document.addEventListener('keydown', handleKeyPress);
        }
        
        // 显示聊天设置
        function showChatSettings() {
            console.log('显示聊天设置被调用');
            
            // 先隐藏当前的聊天界面
            hideApp('api-chat-screen');
            
            // 显示设置界面
            const element = document.getElementById('api-chat-settings-screen');
            if (element) {
                element.style.display = 'flex';
                element.style.position = 'absolute';
                element.style.top = '0';
                element.style.left = '0';
                element.style.width = '100%';
                element.style.height = '100%';
                element.style.zIndex = '1000';
                element.style.background = 'white';
                
                // 重新初始化聊天设置界面以加载当前设置
                initializeChatSettings();

                // 🔥【修复】确保气泡样式在设置界面显示时被正确应用
                applyBubbleStyle();

                // 更新各种设置的显示状态
                updateWorldbookMountDisplay();
                
                // 检测当前聊天类型并显示相应设置
                const isGroupChat = currentChatCharacter && currentChatCharacter.isGroup;
                console.log('当前聊天类型:', isGroupChat ? '群聊' : '单聊');
                
                // 根据聊天类型显示不同的设置选项
                const groupChatSettings = document.getElementById('group-chat-settings');
                const pokeSettingsSection = document.getElementById('poke-settings-section');
                
                if (isGroupChat) {
                    // 群聊模式：显示群聊设置，隐藏戳一戳和单聊专用功能
                    if (groupChatSettings) groupChatSettings.style.display = 'block';
                    if (pokeSettingsSection) pokeSettingsSection.style.display = 'none';
                    
                    // 隐藏单聊专用设置项
                    const singleChatItems = document.querySelectorAll('.single-chat-only');
                    singleChatItems.forEach(item => item.style.display = 'none');
                    
                    // 更新群聊信息显示
                    updateGroupChatInfo();
                } else {
                    // 单聊模式：隐藏群聊设置，显示戳一戳和单聊专用功能
                    if (groupChatSettings) groupChatSettings.style.display = 'none';
                    if (pokeSettingsSection) pokeSettingsSection.style.display = 'block';
                    
                    // 显示单聊专用设置项
                    const singleChatItems = document.querySelectorAll('.single-chat-only');
                    singleChatItems.forEach(item => item.style.display = 'flex');

                    // 更新记忆共享状态显示
                    updateMemoryShareStatus();
                }

                console.log('聊天设置界面已显示');
            } else {
                console.error('找不到api-chat-settings-screen元素');
                alert('设置界面未找到，请刷新页面重试');
            }
        }
        
        // 隐藏聊天设置
        function hideChatSettings() {
            hideApp('api-chat-settings-screen');
            // 返回到聊天界面
            if (currentChatCharacter) {
                showApp('api-chat-screen');
            }
        }
        
        // 修改角色头像
        function changeCharacterAvatar() {
            // 临时创建一个文件输入框，避免干扰原有的头像上传功能
            const tempInput = document.createElement('input');
            tempInput.type = 'file';
            tempInput.accept = 'image/*,.jpg,.jpeg,.png,.gif,.webp';
            tempInput.style.display = 'none';
            document.body.appendChild(tempInput);
            
            tempInput.onchange = function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = async function(event) {
                        const characterIndex = characters.findIndex(c => c.id === currentChatCharacter.id);
                        if (characterIndex !== -1) {
                            characters[characterIndex].avatarUrl = event.target.result;
                            await saveCharacters();
                            renderCharacterList();
                            renderContactList();
                            renderMessageList();
                            renderChatMessages(currentChatCharacter.id);
                        }
                        // 清理临时元素
                        document.body.removeChild(tempInput);
                    };
                    reader.readAsDataURL(e.target.files[0]);
                } else {
                    // 如果用户取消选择，也要清理临时元素
                    document.body.removeChild(tempInput);
                }
            };
            
            tempInput.click();
        }
        
        // 修改备注
        async function changeCharacterNickname() {
            const newName = prompt('请输入新的备注名称:', currentChatCharacter.name);
            if (newName && newName.trim() !== '') {
                const characterIndex = characters.findIndex(c => c.id === currentChatCharacter.id);
                if (characterIndex !== -1) {
                    characters[characterIndex].name = newName.trim();
                    await saveCharacters();
                    document.getElementById('api-chat-title').textContent = newName.trim();
                    renderCharacterList();
                    renderContactList();
                    renderMessageList();
                }
            }
        }
        
        // 查找聊天内容
        function searchChatContent() {
            const keyword = prompt('请输入要查找的关键词:');
            if (keyword && keyword.trim() !== '') {
                const messages = chatMessages[currentChatCharacter.id] || [];
                const foundMessages = messages.filter(msg => 
                    msg.content && msg.content.includes(keyword.trim())
                );
                
                if (foundMessages.length > 0) {
                    alert(`找到 ${foundMessages.length} 条包含"${keyword}"的消息`);
                } else {
                    alert(`没有找到包含"${keyword}"的消息`);
                }
            }
        }
        

        
        // 🔥【修复】导出聊天记录 - 完整HTML格式
        function exportChatHistory() {
            if (!currentChatCharacter) {
                showToast('请先选择一个聊天', 'warning');
                return;
            }
            
            const messages = chatMessages[currentChatCharacter.id] || [];
            if (messages.length === 0) {
                showToast('没有聊天记录可导出', 'warning');
                return;
            }
            
            const chatSettings = getCurrentChatSettings();
            const characterName = chatSettings.aiChatNickname || currentChatCharacter.name;
            const userName = chatSettings.myChatNickname || '我';
            const exportTime = new Date();
            const totalMessages = messages.length;
            
            // 获取时间范围
            const firstMessageTime = new Date(messages[0].timestamp || Date.now());
            const lastMessageTime = new Date(messages[messages.length - 1].timestamp || Date.now());

            // 确保日期有效
            if (isNaN(firstMessageTime.getTime())) {
                firstMessageTime = new Date();
            }
            if (isNaN(lastMessageTime.getTime())) {
                lastMessageTime = new Date();
            }
            
            // 构建HTML内容
            let htmlContent = `<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>与 ${characterName} 的聊天记录</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', Helvetica, Arial, sans-serif;
            background: #f0f0f0;
            color: #333;
            line-height: 1.6;
            min-height: 100vh;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            min-height: 100vh;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        .header {
            background: #007AFF;
            color: white;
            padding: 20px;
            text-align: center;
        }
        .header h1 {
            font-size: 24px;
            margin-bottom: 10px;
        }
        .header .info {
            font-size: 14px;
            opacity: 0.9;
        }
        .chat-content {
            padding: 20px;
        }
        .message {
            margin-bottom: 15px;
            display: flex;
            align-items: flex-end;
            gap: 10px;
        }
        .message.user {
            flex-direction: row-reverse;
        }
        .message.ai {
            flex-direction: row;
        }
        .message.system {
            justify-content: center;
            margin: 10px 0;
        }
        .message-bubble {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            word-wrap: break-word;
            position: relative;
        }
        .message.user .message-bubble {
            background: #007AFF;
            color: white;
            border-bottom-right-radius: 6px;
        }
        .message.ai .message-bubble {
            background: #e5e5ea;
            color: #333;
            border-bottom-left-radius: 6px;
        }
        .message.system .message-bubble {
            background: #f0f0f0;
            color: #666;
            font-size: 12px;
            text-align: center;
            border-radius: 12px;
            padding: 6px 12px;
            margin: 0 auto;
            max-width: 60%;
        }
        .sender-name {
            font-size: 12px;
            color: #666;
            margin-bottom: 4px;
            padding: 0 16px;
        }
        .message.user .sender-name {
            text-align: right;
        }
        .timestamp {
            font-size: 11px;
            color: #999;
            margin-top: 4px;
            padding: 0 16px;
        }
        .message.user .timestamp {
            text-align: right;
        }
        .quote-block {
            background: rgba(0,0,0,0.05);
            border-left: 3px solid #007AFF;
            padding: 8px 12px;
            margin-bottom: 8px;
            border-radius: 0 8px 8px 0;
            font-size: 13px;
        }
        .message.user .quote-block {
            border-left-color: rgba(255,255,255,0.5);
            background: rgba(255,255,255,0.2);
        }
        .quote-sender {
            font-weight: 600;
            color: #007AFF;
            font-size: 12px;
            margin-bottom: 2px;
        }
        .message.user .quote-sender {
            color: rgba(255,255,255,0.9);
        }
        .special-message {
            font-style: italic;
            color: #666;
        }
        .footer {
            background: #f8f8f8;
            padding: 20px;
            text-align: center;
            border-top: 1px solid #e0e0e0;
            font-size: 12px;
            color: #666;
        }
        .stats {
            background: #f8f8f8;
            padding: 15px 20px;
            border-top: 1px solid #e0e0e0;
            font-size: 14px;
            color: #666;
        }
        @media (max-width: 600px) {
            .container {
                margin: 0;
                box-shadow: none;
            }
            .message-bubble {
                max-width: 85%;
            }
            .header h1 {
                font-size: 20px;
            }
            .chat-content {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>与 ${characterName} 的聊天记录</h1>
            <div class="info">
                导出时间：${exportTime.toLocaleString('zh-CN')}<br>
                共 ${totalMessages} 条消息 | ${firstMessageTime.toLocaleDateString('zh-CN')} - ${lastMessageTime.toLocaleDateString('zh-CN')}
            </div>
        </div>
        <div class="chat-content">`;
            
            // 处理每条消息
            messages.forEach((message, index) => {
                const time = formatTime(message.timestamp);
                const isUser = message.sender === 'sent';
                const isSystem = message.sender === 'system';
                
                if (isSystem) {
                    // 系统消息
                    htmlContent += `
            <div class="message system">
                <div class="message-bubble">${escapeHtml(message.content)}</div>
            </div>`;
                } else {
                    // 用户或AI消息
                    const messageClass = isUser ? 'user' : 'ai';
                    const senderName = isUser ? userName : characterName;
                    let messageContent = '';
                    
                    // 处理引用消息
                    if (message.replyTo) {
                        const quoteSender = message.replyTo.senderName || (message.replyTo.sender === 'sent' ? userName : characterName);
                        const quoteContent = truncateText(message.replyTo.content || '[消息已删除]', 20);
                        messageContent += `
                <div class="quote-block">
                    <div class="quote-sender">${escapeHtml(quoteSender)}</div>
                    <div>${escapeHtml(quoteContent)}</div>
                </div>`;
                    }
                    
                    // 处理消息内容
                    let content = message.content || '';
                    let specialClass = '';
                    
                    if (message.type === 'voice_message') {
                        content = `🎵 语音消息：${content}`;
                        specialClass = ' special-message';
                    } else if (message.type === 'transfer') {
                        content = `💰 转账：${message.amount}元${message.note ? ` (${message.note})` : ''}`;
                        specialClass = ' special-message';
                    } else if (message.type === 'location') {
                        content = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 4px; vertical-align: middle;"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/></svg>位置：${message.locationName || '位置信息'}`;
                        specialClass = ' special-message';
                    } else if (message.type === 'friend_request') {
                        content = `👋 好友申请：${message.message || '想和你重新做朋友'}`;
                        specialClass = ' special-message';
                    } else if (message.type === 'user_photo') {
                        content = `📷 图片：${content}`;
                        specialClass = ' special-message';
                    } else if (message.isEmoji) {
                        content = `😊 表情包：${message.emojiDescription || content}`;
                        specialClass = ' special-message';
                    } else if (Array.isArray(content)) {
                        // 处理图片+文字消息
                        const textPart = content.find(part => part.type === 'text')?.text || '';
                        content = textPart ? `📷📝 图片+文字：${textPart}` : '📷 图片消息';
                        specialClass = ' special-message';
                    }
                    
                    messageContent += `<div class="${specialClass.trim()}">${escapeHtml(content)}</div>`;
                    
                    htmlContent += `
            <div class="message ${messageClass}">
                <div class="message-bubble">
                    ${messageContent}
                </div>
            </div>
            <div class="timestamp">${time}</div>`;
                }
                
                // 每50条消息添加一个分页标记（便于长聊天记录的查看）
                if ((index + 1) % 50 === 0 && index !== messages.length - 1) {
                    htmlContent += `
            <div class="message system">
                <div class="message-bubble">--- 第 ${Math.floor((index + 1) / 50)} 页 ---</div>
            </div>`;
                }
            });
            
            htmlContent += `
        </div>
        <div class="stats">
            📊 聊天统计<br>
            总消息数：${totalMessages} 条 | 
            我的消息：${messages.filter(m => m.sender === 'sent').length} 条 | 
            ${characterName} 的消息：${messages.filter(m => m.sender === 'received').length} 条 | 
            系统消息：${messages.filter(m => m.sender === 'system').length} 条
        </div>
        <div class="footer">
            此聊天记录由手机聊天应用自动生成<br>
            导出时间：${exportTime.toLocaleString('zh-CN')}
        </div>
    </div>
</body>
</html>`;
            
            // 创建下载链接
            const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            const fileName = `与${characterName}的聊天记录_${exportTime.getFullYear()}-${(exportTime.getMonth() + 1).toString().padStart(2, '0')}-${exportTime.getDate().toString().padStart(2, '0')}.html`;
            
            link.href = url;
            link.download = fileName;
            link.style.display = 'none';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // 清理URL对象
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 1000);
            
            showToast(`聊天记录已导出：${fileName}`, 'success');
        }
        
        // 🔥【新增】HTML转义函数
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // 🔥【新增】文本截断函数
        function truncateText(text, maxLength) {
            if (text.length <= maxLength) return text;
            return text.substring(0, maxLength) + '...';
        }

        // 🔥【新增】根据消息ID查找消息
        function findMessageById(messageId) {
            if (!currentChatCharacter || !chatMessages[currentChatCharacter.id]) {
                return null;
            }

            const messages = chatMessages[currentChatCharacter.id];
            const result = messages.find(msg => msg.id === messageId);
            return result;
        }

        // 🔥【新增】获取当前用户身份名称
        function getCurrentPersonaName() {
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.selectedIdentityId) {
                const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                if (selectedPersona) {
                    // 优先使用群聊昵称
                    return chatSettings.myChatNickname || selectedPersona.name;
                }
            }
            return '用户';
        }

        // 🔥【新增】获取当前用户身份描述
        function getCurrentPersonaDescription() {
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.selectedIdentityId) {
                const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                if (selectedPersona && selectedPersona.description) {
                    return selectedPersona.description;
                }
            }
            return '我是用户';
        }
        

        
        // 设置对方气泡颜色
        function changeTheirBubbleColor() {
            colorPickerContext = 'theirBubble';
            document.getElementById('color-picker-title').textContent = '设置对方气泡颜色';
            showModal('color-picker-modal');
        }
        
        // 设置我方气泡颜色
        function changeMyBubbleColor() {
            colorPickerContext = 'myBubble';
            document.getElementById('color-picker-title').textContent = '设置我方气泡颜色';
            showModal('color-picker-modal');
        }
        
        // 显示气泡颜色设置
        function showBubbleColorSettings() {
            alert('气泡颜色设置功能开发中...\n\n当前可以通过以下方式设置：\n• 修改对方气泡颜色\n• 修改我方气泡颜色');
        }
        
        // 🔥【新增】显示带选项的清空历史记录模态框
        function showClearHistoryOptionsModal() {
            if (!currentChatCharacter) return;

            // 创建模态框的HTML结构
            const modalHTML = `
                <div id="clear-history-options-modal" class="modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 class="modal-title">清空聊天记录</h3>
                            <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p style="margin-bottom: 15px; font-size: 14px; color: #666;">
                                你确定要清空与 <strong>${currentChatCharacter.name}</strong> 的聊天记录吗？
                            </p>
                            <div class="setting-section">
                                <div class="section-header" style="padding: 0 0 10px 0;">
                                    <i class="fas fa-brain section-icon"></i>
                                    <span class="section-title">同步清除相关记忆</span>
                                </div>
                                <div class="checkbox-group">
                                    <label class="checkbox-option">
                                        <input type="checkbox" id="clear-core-memory" value="core" checked>
                                        <span class="checkbox-custom"></span>
                                        <div class="checkbox-content">
                                            <div class="checkbox-title">核心记忆</div>
                                            <div class="checkbox-desc">角色记住的关键信息（如生日、关系）。</div>
                                        </div>
                                    </label>
                                    <label class="checkbox-option">
                                        <input type="checkbox" id="clear-episodic-memory" value="episodic" checked>
                                        <span class="checkbox-custom"></span>
                                        <div class="checkbox-content">
                                            <div class="checkbox-title">情景记忆</div>
                                            <div class="checkbox-desc">日常互动和经历的记忆。</div>
                                        </div>
                                    </label>
                                    <label class="checkbox-option">
                                        <input type="checkbox" id="clear-timeline" value="timeline" checked>
                                        <span class="checkbox-custom"></span>
                                        <div class="checkbox-content">
                                            <div class="checkbox-title">时间线</div>
                                            <div class="checkbox-desc">所有活动的详细时间记录。</div>
                                        </div>
                                    </label>
                                </div>
                            </div>
                            <p style="margin-top: 15px; font-size: 12px; color: #999;">
                                <strong>提示：</strong>聊天设置（如身份、背景）将会被保留。
                            </p>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="this.closest('.modal').remove()">取消</button>
                            <button class="modal-button modal-primary" style="background-color: #ff3b30;" onclick="executeClearHistory()">确认清空</button>
                        </div>
                    </div>
                </div>
            `;

            // 添加到页面
            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        // 🔥【新增】根据用户的选择执行清除操作
        async function executeClearHistory() {
            const characterId = currentChatCharacter.id;
            console.log(`🧹 开始清理角色 ${characterId} 的聊天数据...`);
            showToast('正在进行深度清理...', 'info');

            // 获取用户选择
            const clearCore = document.getElementById('clear-core-memory')?.checked || false;
            const clearEpisodic = document.getElementById('clear-episodic-memory')?.checked || false;
            const clearTimeline = document.getElementById('clear-timeline')?.checked || false;

            // 移除模态框
            const modal = document.getElementById('clear-history-options-modal');
            if (modal) modal.remove();

            try {
                // 1. 清空聊天消息 (总是执行)
                chatMessages[characterId] = [];
                await saveChatMessages();
                console.log('✅ 聊天消息已清空');

                // 2. 根据用户的勾选，选择性地清除记忆
                const contextId = characterId;

                if (clearCore) {
                    const coreMemoriesToDelete = await db.coreMemories.where({ characterId: characterId, contextId: contextId }).primaryKeys();
                    if (coreMemoriesToDelete.length > 0) {
                        await db.coreMemories.bulkDelete(coreMemoriesToDelete);
                        console.log(`✅ 清除了 ${coreMemoriesToDelete.length} 条核心记忆`);
                    }
                }

                if (clearEpisodic) {
                    const episodicMemoriesToDelete = await db.episodicMemories.where({ characterId: characterId, contextId: contextId }).primaryKeys();
                    if (episodicMemoriesToDelete.length > 0) {
                        await db.episodicMemories.bulkDelete(episodicMemoriesToDelete);
                        console.log(`✅ 清除了 ${episodicMemoriesToDelete.length} 条情景记忆`);
                    }
                }

                if (clearTimeline) {
                    const timelineEventsToDelete = await db.crossAppTimeline.where({ characterId: characterId }).and(event => event.context && event.context.id === contextId).primaryKeys();
                    if (timelineEventsToDelete.length > 0) {
                        await db.crossAppTimeline.bulkDelete(timelineEventsToDelete);
                        console.log(`✅ 清除了 ${timelineEventsToDelete.length} 条时间线记录`);
                    }

                    const memorySummariesToDelete = await db.memorySummaries.where({ characterId: characterId }).and(summary => summary.context && summary.context.id === contextId).primaryKeys();
                    if (memorySummariesToDelete.length > 0) {
                        await db.memorySummaries.bulkDelete(memorySummariesToDelete);
                        console.log(`✅ 清除了 ${memorySummariesToDelete.length} 条记忆摘要`);
                    }
                }

                // 3. 刷新界面
                renderChatMessages(characterId);
                renderMessageList();

                showToast('所选数据已彻底清除！', 'success');
                console.log(`🧹 角色 ${characterId} 的数据清理完成`);

                hideChatSettings();

            } catch (error) {
                console.error('深度清理失败:', error);
                showToast('清理失败，请检查控制台', 'error');
            }
        }

        // 清空聊天记录
        function clearChatHistory() {
            // 🔥【最终修复】不再直接执行删除，而是调用新的函数来显示带选项的模态框
            showClearHistoryOptionsModal();
        }
        
        // 选择颜色
        function selectColor(color) {
            document.querySelectorAll('.color-option').forEach(option => {
                option.classList.remove('selected');
            });
            event.target.classList.add('selected');
            document.getElementById('selected-color').value = color;
        }
        
        // 应用聊天背景
// 接受一个可选的 backgroundUrl 参数
async function applyChatBackground(backgroundUrl) {
            if (!currentChatCharacter) return;
            
    console.log(`⚡ applyChatBackground 被调用: ${currentChatCharacter.name} (ID: ${currentChatCharacter.id})`);

    // 1. 创建一个专属于当前聊天的背景设置字段
    // 注意：这里不再使用chatSettings对象，而是直接在character对象上添加背景属性
    if (!currentChatCharacter.background) {
        currentChatCharacter.background = null;
    }

    // 2. 决定最终要使用的背景。优先使用传入的参数，否则使用角色对象中的值
    const backgroundToApply = backgroundUrl !== undefined ? backgroundUrl : currentChatCharacter.background;

    // 3. 更新角色对象中的设置
    currentChatCharacter.background = backgroundToApply;
    
    // 4. 保存到数据库 - 注意这里使用saveCharacters而不是saveCurrentChatSettings
    await saveCharacters();
    
    // 5. 直接设置背景样式
            const chatScreen = document.getElementById('api-chat-screen');
    if (!chatScreen) return;
    
    // 直接应用背景 - 完全模仿zhangyu.html中的实现方式
    if (backgroundToApply) {
        console.log(`🖼️ 应用聊天背景: ${currentChatCharacter.name} (ID: ${currentChatCharacter.id})`);
        
        // 直接设置样式
        chatScreen.style.backgroundImage = `url(${backgroundToApply})`;
                    chatScreen.style.backgroundSize = 'cover';
                    chatScreen.style.backgroundPosition = 'center';
                    chatScreen.style.backgroundColor = 'transparent';
                    
        const messagesContainer = document.getElementById('api-chat-messages');
                    if (messagesContainer) messagesContainer.style.background = 'transparent';
                } else {
        console.log(`🖼️ 重置聊天背景: ${currentChatCharacter.name} (ID: ${currentChatCharacter.id})`);
        
        // 重置为默认样式
                    chatScreen.style.backgroundImage = 'none';
                    chatScreen.style.backgroundColor = 'white';
                    
        const messagesContainer = document.getElementById('api-chat-messages');
                    if (messagesContainer) messagesContainer.style.background = ''; 
                }
    
    console.log(`✅ 背景样式已应用: ${currentChatCharacter.name} (ID: ${currentChatCharacter.id})`);
        }
        
        // 保存气泡样式设置
        function saveBubbleStyleSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // 保存样式设置
            chatSettings.bubbleStyle = window.selectedBubbleStyle || 'default';
            chatSettings.myBubbleColor = document.getElementById('my-bubble-color').value;
            chatSettings.aiBubbleColor = document.getElementById('ai-bubble-color').value;
            chatSettings.bubbleOpacity = document.getElementById('bubble-opacity').value;
            
            // 更新显示文本
            const styleNames = {
                'default': '默认样式',
                'glass': '毛玻璃',
                'shadow': '经典阴影',
                'tail': '经典气泡',
                'gradient': '渐变样式',
                'minimal': '极简样式',
                'neon': '霓虹样式',
                'paper': '纸张样式'
            };
            
            document.getElementById('current-bubble-style').textContent = styleNames[chatSettings.bubbleStyle] || '默认样式';
            
            saveCurrentChatSettings(chatSettings);
            applyBubbleStyle();
            hideModal('bubble-style-modal');
            
            showToast('气泡样式设置已保存', 'success');
        }
        
        // 应用气泡样式
        function applyBubbleStyle() {
            // 🔥【修复】即使没有currentChatCharacter也要尝试应用样式
            const messagesContainer = document.getElementById('api-chat-messages');
            if (!messagesContainer) return;

            // 获取聊天设置，如果没有currentChatCharacter则使用默认设置
            let chatSettings = {};
            if (currentChatCharacter) {
                chatSettings = getCurrentChatSettings();
            } else {
                // 使用默认设置
                chatSettings = {
                    bubbleStyle: 'default',
                    myBubbleColor: '#007AFF',
                    aiBubbleColor: '#f0f0f0',
                    bubbleOpacity: '1'
                };
            }

            // 移除所有样式类
            messagesContainer.className = messagesContainer.className
                .split(' ')
                .filter(cls => !cls.startsWith('bubble-style-'))
                .join(' ');

            // 添加当前样式类
            const style = chatSettings.bubbleStyle || 'default';
            messagesContainer.classList.add(`bubble-style-${style}`);

            // 设置CSS变量用于动态颜色
            const myColor = chatSettings.myBubbleColor || '#007AFF';
            const aiColor = chatSettings.aiBubbleColor || '#f0f0f0';
            const opacity = chatSettings.bubbleOpacity || '1';

            messagesContainer.style.setProperty('--my-bubble-color', myColor);
            messagesContainer.style.setProperty('--ai-bubble-color', aiColor);
            messagesContainer.style.setProperty('--bubble-opacity', opacity);

            console.log(`🎨 气泡样式已应用: ${style} (角色: ${currentChatCharacter?.name || '无'})`);
        }
        
        // 显示气泡颜色选择器
        function showBubbleColorPicker(context) {
            colorPickerContext = context;
            document.getElementById('color-picker-title').textContent = '设置气泡颜色';
            showModal('color-picker-modal');
        }
        
        // 选择颜色
        function selectColor(color) {
            document.querySelectorAll('.color-option').forEach(option => {
                option.classList.remove('selected');
            });
            event.target.classList.add('selected');
            document.getElementById('selected-color').value = color;
        }
        
        // 应用颜色选择
        async function applyColorSelection() {
            const selectedColor = document.querySelector('.color-option.selected')?.style.backgroundColor || '#007AFF';
            const opacity = document.getElementById('opacity-slider').value;
            
            if (colorPickerContext === 'theirBubble') {
                chatSettings.theirBubbleColor = selectedColor;
                chatSettings.bubbleOpacity = opacity;
            } else if (colorPickerContext === 'myBubble') {
                chatSettings.myBubbleColor = selectedColor;
                chatSettings.bubbleOpacity = opacity;
            }
            
            await saveChatSettings();
            renderChatMessages(currentChatCharacter.id);
            hideModal('color-picker-modal');
        }
        
        // 显示壁纸选择器
        function showWallpaperPicker() {
            showModal('wallpaper-picker-modal');
        }
        
        // 选择壁纸（保留函数以防其他地方调用，但现在主要通过文件上传选择）
        function selectWallpaper(wallpaperId) {
            console.log('选择壁纸:', wallpaperId);
            selectedWallpaper = wallpaperId;
            console.log('selectedWallpaper已设置为:', selectedWallpaper);
        }
        
        // 应用壁纸选择
        async function applyWallpaperSelection() {
            console.log('应用壁纸被调用，selectedWallpaper:', selectedWallpaper);
            
            if (!selectedWallpaper) {
                alert('请先从相册选择一张图片作为壁纸');
                return;
            }
            
            if (selectedWallpaper.startsWith('data:image')) {
                // 应用上传的图片壁纸
                console.log('应用图片壁纸');
                document.querySelector('.wallpaper').style.backgroundImage = `url(${selectedWallpaper})`;
                    document.querySelector('.wallpaper').style.backgroundSize = '100% 100%';
                    document.querySelector('.wallpaper').style.backgroundPosition = 'center';
                
                // 使用IndexedDB保存壁纸，避免localStorage空间限制
                try {
                    await db.wallpapers.clear();
                    await db.wallpapers.add({
                        id: 'main',
                        type: 'image',
                        data: selectedWallpaper
                    });
                    console.log('壁纸保存成功到IndexedDB');
            hideModal('wallpaper-picker-modal');
                } catch (e) {
                    console.error('保存壁纸失败:', e);
                    alert('保存壁纸失败，请重试');
                }
            } else {
                alert('请先从相册选择一张图片作为壁纸');
            }
        }
        
        // 上传自定义壁纸
        function uploadCustomWallpaper() {
            document.getElementById('custom-wallpaper-upload').click();
        }
        
        // 全局变量
        let selectedAppForIcon = null;
        let uploadedIconImage = null;

        // 显示图标选择器
        function showIconPicker() {
            generateAppList();
            showModal('icon-picker-modal');
        }

        // 生成应用列表
        function generateAppList() {
            const container = document.getElementById('app-list-container');
            container.innerHTML = '';

            // 获取所有应用的信息
            const apps = [
                // 主屏幕应用
                { id: 'chat-screen', name: 'Chat', selector: '.mini-app[onclick="showApp(\'chat-screen\')"] .mini-app-icon' },
                { id: 'worldbook-screen', name: '世界书', selector: '.mini-app[onclick*="worldbook-screen"] .mini-app-icon' },
                { id: 'game-screen', name: '游戏', selector: '.mini-app[onclick="showApp(\'game-screen\')"] .mini-app-icon' },
                { id: 'forum-screen', name: '论坛', selector: '.mini-app[onclick="showApp(\'forum-screen\')"] .mini-app-icon' },
                // Dock栏应用
                { id: 'messages-screen', name: '短信', selector: '.dock-app[onclick="showApp(\'messages-screen\')"] .dock-app-icon' },
                { id: 'settings-screen', name: '设置', selector: '.dock-app[onclick="showApp(\'settings-screen\')"] .dock-app-icon' },
                { id: 'memory-viewer-screen', name: '记忆', selector: '.dock-app[onclick="showApp(\'memory-viewer-screen\')"] .dock-app-icon' }
            ];

            apps.forEach(app => {
                const appElement = document.querySelector(app.selector);
                if (appElement) {
                    const appItem = document.createElement('div');
                    appItem.className = 'app-item-selector';
                    appItem.onclick = () => selectAppForIcon(app.id, app.name, app.selector);

                    // 获取当前图标
                    const iconHtml = appElement.innerHTML;

                    appItem.innerHTML = `
                        <div class="app-item-icon">
                            ${iconHtml}
                        </div>
                        <div class="app-item-name">${app.name}</div>
                    `;

                    container.appendChild(appItem);
                }
            });
        }

        // 选择要修改图标的应用
        function selectAppForIcon(appId, appName, selector) {
            selectedAppForIcon = { id: appId, name: appName, selector: selector };

            // 更新选中状态
            document.querySelectorAll('.app-item-selector').forEach(item => {
                item.classList.remove('selected');
            });
            event.currentTarget.classList.add('selected');

            // 显示上传区域
            document.getElementById('icon-upload-section').style.display = 'block';

            // 重置上传状态
            resetIconUpload();
        }

        // 触发图标上传
        function triggerIconUpload() {
            if (!selectedAppForIcon) {
                alert('请先选择要修改的应用');
                return;
            }
            document.getElementById('custom-icon-upload').click();
        }

        // 重置图标上传
        function resetIconUpload() {
            uploadedIconImage = null;
            document.getElementById('upload-placeholder').style.display = 'block';
            document.getElementById('icon-preview-img').style.display = 'none';
            document.querySelector('.upload-area').classList.remove('has-image');
            document.getElementById('apply-icon-btn').style.display = 'none';
        }

        // 应用图标更改
        async function applyIconChange() {
            if (!selectedAppForIcon || !uploadedIconImage) {
                alert('请选择应用和上传图标');
                return;
            }

            try {
                // 更新应用图标
                const appIconElement = document.querySelector(selectedAppForIcon.selector);
                if (appIconElement) {
                    appIconElement.innerHTML = `<img src="${uploadedIconImage}" alt="${selectedAppForIcon.name}" class="app-icon-img">`;
                }

                // 保存到IndexedDB
                await saveCustomAppIcon(selectedAppForIcon.id, uploadedIconImage);

                showToast('应用图标已更新！', 'success');
                hideModal('icon-picker-modal');

                // 重置状态
                selectedAppForIcon = null;
                uploadedIconImage = null;
            } catch (error) {
                console.error('更新应用图标失败:', error);
                showToast('更新失败，请重试', 'error');
            }
        }

        // 保存自定义应用图标到IndexedDB
        async function saveCustomAppIcon(appId, imageData) {
            try {
                await db.appIcons.put({
                    id: appId,
                    appId: appId,
                    imageData: imageData,
                    updatedAt: new Date()
                });
                console.log('应用图标已保存:', appId);
            } catch (error) {
                console.error('保存应用图标失败:', error);
                throw error;
            }
        }

        // 加载自定义应用图标
        async function loadCustomAppIcons() {
            try {
                const customIcons = await db.appIcons.toArray();
                customIcons.forEach(iconData => {
                    if (iconData.imageData) {
                        // 查找对应的应用图标元素并更新
                        const apps = [
                            { id: 'chat-screen', selector: '.mini-app[onclick="showApp(\'chat-screen\')"] .mini-app-icon' },
                            { id: 'worldbook-screen', selector: '.mini-app[onclick*="worldbook-screen"] .mini-app-icon' },
                            { id: 'game-screen', selector: '.mini-app[onclick="showApp(\'game-screen\')"] .mini-app-icon' },
                            { id: 'forum-screen', selector: '.mini-app[onclick="showApp(\'forum-screen\')"] .mini-app-icon' },
                            { id: 'messages-screen', selector: '.dock-app[onclick="showApp(\'messages-screen\')"] .dock-app-icon' },
                            { id: 'settings-screen', selector: '.dock-app[onclick="showApp(\'settings-screen\')"] .dock-app-icon' },
                            { id: 'memory-viewer-screen', selector: '.dock-app[onclick="showApp(\'memory-viewer-screen\')"] .dock-app-icon' }
                        ];

                        const app = apps.find(a => a.id === iconData.appId);
                        if (app) {
                            const appIconElement = document.querySelector(app.selector);
                            if (appIconElement) {
                                appIconElement.innerHTML = `<img src="${iconData.imageData}" alt="${iconData.appId}" class="app-icon-img">`;
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('加载自定义应用图标失败:', error);
            }
        }

        // 初始化应用图标上传功能
        function initializeIconUpload() {
            const iconInput = document.getElementById('custom-icon-upload');
            if (!iconInput) {
                console.error('找不到custom-icon-upload元素');
                return;
            }

            // 移除旧的事件监听器（如果存在）
            iconInput.removeEventListener('change', handleIconUpload);

            // 添加新的事件监听器
            iconInput.addEventListener('change', handleIconUpload);
            console.log('应用图标上传事件监听器已绑定');
        }

        // 处理图标上传
        async function handleIconUpload(e) {
            if (e.target.files && e.target.files[0]) {
                const file = e.target.files[0];

                // 检查文件类型
                if (!file.type.startsWith('image/')) {
                    alert('请选择图片文件');
                    return;
                }

                // 检查文件大小（限制为5MB）
                if (file.size > 5 * 1024 * 1024) {
                    alert('图片文件不能超过5MB');
                    return;
                }

                try {
                    // 压缩图片
                    const compressedImage = await compressImage(file, 200, 0.8);

                    // 更新预览
                    const uploadArea = document.querySelector('.upload-area');
                    const placeholder = document.getElementById('upload-placeholder');
                    const previewImg = document.getElementById('icon-preview-img');

                    placeholder.style.display = 'none';
                    previewImg.src = compressedImage;
                    previewImg.style.display = 'block';
                    uploadArea.classList.add('has-image');

                    // 保存图片数据
                    uploadedIconImage = compressedImage;

                    // 显示应用按钮
                    document.getElementById('apply-icon-btn').style.display = 'inline-block';

                    showToast('图片上传成功！', 'success');
                } catch (error) {
                    console.error('处理图片失败:', error);
                    showToast('图片处理失败，请重试', 'error');
                }
            }
        }
        
        // 更改聊天主题颜色
        function changeChatThemeColor() {
            colorPickerContext = 'theme';
            document.getElementById('color-picker-title').textContent = '设置聊天主题颜色';
            showModal('color-picker-modal');
        }
        

        
        // 显示消息菜单
        function showMessageMenu(messageId, event) {
            selectedMessageId = messageId;
            console.log('桌面端右键菜单，设置selectedMessageId:', selectedMessageId);

            // 先隐藏现有菜单，确保清理事件监听器
            hideMessageMenu();

            // 创建或获取菜单元素
            let menu = document.getElementById('message-context-menu');
            if (!menu) {
                menu = document.createElement('div');
                menu.id = 'message-context-menu';
                menu.className = 'message-menu';
                document.body.appendChild(menu);
            }

            // 🔥【修复】每次都重新设置菜单内容，避免事件绑定问题
            // 检查消息是否是用户发送的（只有用户消息可以编辑和撤回）
            const messages = chatMessages[currentChatCharacter.id] || [];
            const message = messages.find(msg => msg.id === messageId);
            const isUserMessage = message && message.sender === 'sent';

            let menuItems = [
                '<div class="message-menu-item" data-action="reply">引用</div>',
                '<div class="message-menu-item" data-action="copy">复制</div>'
            ];

            // 🔥【新增】只有AI角色消息才显示心声选项
            if (!isUserMessage) {
                menuItems.push('<div class="message-menu-item" data-action="inner-thoughts">心声</div>');
            }

            // 🔥【修复】所有消息都可以编辑，用户消息可以撤回
            menuItems.push('<div class="message-menu-item" data-action="edit">编辑</div>');

            if (isUserMessage) {
                menuItems.push('<div class="message-menu-item" data-action="recall">撤回</div>');
            }

            menuItems.push('<div class="message-menu-item" data-action="select">多选</div>');

            menu.innerHTML = menuItems.join('');

            // 🔥【修复】使用事件委托绑定点击事件，避免内联onclick问题
            menu.onclick = function(e) {
                const action = e.target.dataset.action;
                if (action) {
                    e.stopPropagation();
                    console.log('菜单点击，action:', action, 'selectedMessageId:', selectedMessageId);

                    // 🔥【临时修复】直接使用传入的messageId而不是全局变量
                    const targetId = messageId;
                    console.log('使用messageId:', targetId);

                    switch(action) {
                        case 'reply':
                            replyToMessage(targetId);
                            break;
                        case 'copy':
                            copyMessage(targetId);
                            break;
                        case 'edit':
                            showEditMessageModal(targetId);
                            break;
                        case 'recall':
                            deleteMessage(targetId);
                            break;
                        case 'inner-thoughts':
                            showInnerThoughtsModal(targetId);
                            break;
                        case 'select':
                            enterMessageSelectionMode(targetId);
                            break;
                    }
                    // 🔥【修复】手动隐藏菜单，不传递事件参数
                    hideMessageMenu(null);
                }
            };

            // 定位菜单
            const x = event.clientX || event.pageX;
            const y = event.clientY || event.pageY;

            menu.style.display = 'block';
            menu.style.left = `${Math.min(x, window.innerWidth - 150)}px`;
            menu.style.top = `${Math.min(y, window.innerHeight - 100)}px`;

            // 🔥【修复】延迟添加外部点击监听器，避免立即触发
            setTimeout(() => {
                // 先移除可能存在的旧监听器
                document.removeEventListener('click', hideMessageMenu);
                document.removeEventListener('touchstart', hideMessageMenu);
                // 添加新的监听器
                document.addEventListener('click', hideMessageMenu);
                document.addEventListener('touchstart', hideMessageMenu);
            }, 100);
        }
        
        // 隐藏消息菜单
        function hideMessageMenu(event) {
            // 🔥【修复】如果点击来自菜单内部，不隐藏菜单
            if (event && event.target) {
                const menu = document.getElementById('message-context-menu');
                if (menu && menu.contains(event.target)) {
                    return;
                }
            }

            const menu = document.getElementById('message-context-menu');
            if (menu) {
                menu.style.display = 'none';
                // 🔥【修复】清理菜单的点击事件处理器
                menu.onclick = null;
            }
            // 🔥【修复】确保移除外部点击监听器
            document.removeEventListener('click', hideMessageMenu);
            document.removeEventListener('touchstart', hideMessageMenu);
            // 🔥【修复】重置选中的消息ID
            selectedMessageId = null;
        }
        
        // 引用消息功能
        let currentReplyTo = null;

        // 🔥【新增】每个聊天的引用状态存储
        let chatReplyStates = {};
        
        // 🔥【修复】引用消息 - 支持传入消息ID
        function replyToMessage(messageId = null) {
            const targetMessageId = messageId || selectedMessageId;
            console.log('引用消息:', targetMessageId, '来源:', messageId ? '移动端' : '桌面端');
            if (!targetMessageId) {
                console.log('错误: 没有选中的消息ID');
                return;
            }

            const messages = chatMessages[currentChatCharacter.id] || [];
            const message = messages.find(msg => msg.id === targetMessageId);

            if (message) {
                // 设置引用信息
                let messageContent = message.content || '[图片]';

                // 🔥【修复】处理多模态消息内容
                if (Array.isArray(message.content)) {
                    const textPart = message.content.find(p => p.type === 'text');
                    messageContent = textPart?.text || '[多媒体消息]';
                } else if (typeof message.content === 'string') {
                    messageContent = message.content;
                } else {
                    messageContent = '[特殊消息]';
                }

                currentReplyTo = {
                    id: message.id,
                    content: messageContent,
                    sender: message.sender,
                    timestamp: message.timestamp,
                    senderName: getSenderDisplayName(message)
                };

                // 🔥【新增】保存当前聊天的引用状态
                if (currentChatCharacter) {
                    chatReplyStates[currentChatCharacter.id] = { ...currentReplyTo };
                }

                // 显示引用预览
                showReplyPreview();

                // 聚焦到输入框
                const inputBox = document.getElementById('api-chat-input');
                if (inputBox) {
                    inputBox.focus();
                }
            }

            hideMessageMenu();
        }
        
        // 获取发送者显示名称
        function getSenderDisplayName(message) {
            if (message.sender === 'sent') {
                const chatSettings = getCurrentChatSettings();
                if (chatSettings.selectedIdentityId) {
                    const persona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                    if (persona) return persona.name;
                }
                return chatSettings.myChatNickname || '我';
            } else if (message.sender === 'received') {
                // 检查是否是群聊
                const group = groupChats.find(g => g.id === currentChatCharacter.id);
                if (group) {
                    // 群聊中，根据消息的senderId或name查找成员
                    let member = null;
                    if (message.senderId) {
                        member = group.members.find(m => m.id === message.senderId);
                    } else if (message.name) {
                        member = group.members.find(m => m.name === message.name);
                    }
                    return member?.name || '群成员';
                } else {
                    // 单聊
                    const chatSettings = getCurrentChatSettings();
                    return chatSettings.aiChatNickname || currentChatCharacter.name;
                }
            }
            return '未知';
        }
        
        // 显示引用预览
        function showReplyPreview() {
            if (!currentReplyTo) return;

            // 移除已存在的引用预览
            const existingPreview = document.getElementById('reply-preview');
            if (existingPreview) {
                existingPreview.remove();
            }

            // 创建引用预览元素
            const replyPreview = document.createElement('div');
            replyPreview.id = 'reply-preview';
            replyPreview.className = 'reply-preview';

            // 截断显示内容 - 缩短到25字符
            const displayContent = truncateText(currentReplyTo.content, 25);

            replyPreview.innerHTML = `
                <div class="reply-preview-content">
                    <div class="reply-preview-line"></div>
                    <div class="reply-preview-text">
                        <div class="reply-preview-sender">${currentReplyTo.senderName}</div>
                        <div class="reply-preview-message">${displayContent}</div>
                    </div>
                    <button class="reply-preview-close" onclick="cancelReply()">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `;

            // 🔥【修复】确保引用预览可见
            replyPreview.style.display = 'block';
            replyPreview.style.visibility = 'visible';

            // 插入到输入区域内部的顶部
            const inputArea = document.querySelector('.chat-input-area');
            if (inputArea) {
                // 将引用预览插入到输入区域的第一个子元素之前
                const firstChild = inputArea.firstElementChild;
                if (firstChild) {
                    inputArea.insertBefore(replyPreview, firstChild);
                } else {
                    inputArea.appendChild(replyPreview);
                }
            }
        }
        
        // 取消引用
        function cancelReply() {
            currentReplyTo = null;

            // 🔥【新增】清除当前聊天的引用状态
            if (currentChatCharacter) {
                delete chatReplyStates[currentChatCharacter.id];
            }

            const replyPreview = document.getElementById('reply-preview');
            if (replyPreview) {
                replyPreview.remove();
            }
        }
        
        // 生成引用消息的HTML
        function generateReplyHTML(replyTo) {
            if (!replyTo) return '';

            let displayContent = truncateText(replyTo.content, 20);
            // 处理引用消息中的@内容
            displayContent = processMentions(displayContent);

            return `
                <div class="reply-reference">
                    <div class="reply-reference-line"></div>
                    <div class="reply-reference-content">
                        <div class="reply-reference-sender">${replyTo.senderName}</div>
                        <div class="reply-reference-message">${displayContent}</div>
                    </div>
                </div>
            `;
        }
        
        // 复制消息
        function copyMessage(messageId = null) {
            const targetMessageId = messageId || selectedMessageId;
            console.log('复制消息:', targetMessageId, '来源:', messageId ? '移动端' : '桌面端');
            if (!targetMessageId) {
                console.log('错误: 没有选中的消息ID');
                return;
            }

            const messages = chatMessages[currentChatCharacter.id] || [];
            const message = messages.find(msg => msg.id === targetMessageId);
            
            if (message && message.content) {
                navigator.clipboard.writeText(message.content).then(() => {
                    alert('消息已复制');
                }).catch(() => {
                    alert('复制失败，请重试');
                });
            }
            
            hideMessageMenu();
        }
        
        // 显示编辑消息模态框
        function showEditMessageModal(messageId) {
            if (!messageId) return;
            
            const messages = chatMessages[currentChatCharacter.id] || [];
            const message = messages.find(msg => msg.id === messageId);
            
            if (!message) {
                showToast('消息不存在', 'error');
                return;
            }
            
            // 创建编辑模态框
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.id = 'edit-message-modal';
            
            const senderName = message.sender === 'sent' ? '你' : (message.name || currentChatCharacter.name);
            
            modal.innerHTML = `
                <div class="modal-content edit-message-modal">
                    <div class="modal-header">
                        <h3>编辑消息</h3>
                        <button class="modal-close" onclick="hideEditMessageModal()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="edit-message-info">
                            <span class="message-sender">${senderName}</span>
                            <span class="message-time">${formatTimestamp(message.timestamp)}</span>
                        </div>
                        <div class="edit-form-group">
                            <label>消息内容：</label>
                            <textarea 
                                id="edit-message-content" 
                                class="edit-message-textarea"
                                placeholder="请输入消息内容..."
                                maxlength="2000"
                            >${message.content || ''}</textarea>
                            <div class="edit-message-counter">
                                <span id="edit-char-count">${(message.content || '').length}</span>/2000
                            </div>
                        </div>
                        ${message.image ? `
                            <div class="edit-form-group">
                                <label>图片：</label>
                                <div class="edit-message-image">
                                    <img src="${message.image}" alt="消息图片" />
                                    <button class="remove-image-btn" onclick="removeMessageImage()">删除图片</button>
                                </div>
                            </div>
                        ` : ''}
                    </div>
                    <div class="modal-footer">
                        <button class="modal-btn modal-cancel" onclick="hideEditMessageModal()">取消</button>
                        <button class="modal-btn modal-confirm" onclick="saveEditedMessage('${messageId}')">保存</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // 添加字符计数功能
            const textarea = document.getElementById('edit-message-content');
            const charCount = document.getElementById('edit-char-count');
            textarea.addEventListener('input', function() {
                charCount.textContent = this.value.length;
            });
            
            // 🔥【修复】聚焦但不选中文本，光标移到末尾
            setTimeout(() => {
                textarea.focus();
                textarea.setSelectionRange(textarea.value.length, textarea.value.length);
            }, 100);
        }
        
        // 隐藏编辑消息模态框
        function hideEditMessageModal() {
            const modal = document.getElementById('edit-message-modal');
            if (modal) {
                modal.remove();
            }
        }
        
        // 保存编辑后的消息
        function saveEditedMessage(messageId) {
            const newContent = document.getElementById('edit-message-content').value.trim();
            
            if (!newContent) {
                showToast('消息内容不能为空', 'error');
                return;
            }
            
            const messages = chatMessages[currentChatCharacter.id] || [];
            const messageIndex = messages.findIndex(msg => msg.id === messageId);
            
            if (messageIndex !== -1) {
                const oldContent = messages[messageIndex].content;
                messages[messageIndex].content = newContent;
                
                // 添加编辑标记
                messages[messageIndex].edited = true;
                messages[messageIndex].editTime = Date.now();
                
                saveChatMessages();
                renderChatMessages(currentChatCharacter.id);
                hideEditMessageModal();
                
                showToast('消息已更新', 'success');
                
                console.log(`消息已编辑: "${oldContent}" -> "${newContent}"`);
            } else {
                showToast('消息不存在', 'error');
            }
        }
        
        // 移除消息图片
        function removeMessageImage() {
            // 这个功能可以在后续扩展
            showToast('暂不支持移除图片', 'info');
        }
        
        // 编辑消息（保留旧版本接口）
        function editMessage() {
            if (!selectedMessageId) return;
            
            showEditMessageModal(selectedMessageId);
            hideModal('message-menu-modal');
        }
        
        // 验证头像来源是否有效
        async function validateAvatarSource(avatarUrl) {
            console.log('验证头像来源:', avatarUrl);
            if (!avatarUrl) return false;

            // 🔥【修复】处理占位符，先替换为实际图片URL再验证
            let actualAvatarUrl = avatarUrl;
            if (avatarUrl === 'CURRENT_USER_IMAGE' ||
                avatarUrl === 'CURRENT_USER_IMAGE' ||
                avatarUrl === '用户发送的图片URL' ||
                avatarUrl === '图片URL') {
                const recentUserImage = getRecentUserImage();
                if (recentUserImage) {
                    actualAvatarUrl = recentUserImage;
                    console.log('占位符替换为实际图片URL:', actualAvatarUrl);
                } else {
                    console.log('没有找到用户发送的图片，验证失败');
                    return false;
                }
            }

            // 检查是否是用户发送的图片（在聊天记录中）
            if (currentChatCharacter && chatMessages[currentChatCharacter.id]) {
                const userImages = chatMessages[currentChatCharacter.id]
                    .filter(msg => msg.sender === 'sent' && msg.image)
                    .map(msg => msg.image);

                console.log('用户发送的图片列表:', userImages);
                console.log('检查头像URL是否在用户图片中:', userImages.includes(actualAvatarUrl));

                if (userImages.includes(actualAvatarUrl)) {
                    console.log('头像来源验证通过：用户发送的图片');
                    return true;
                }
            }

            // 检查是否是世界书中提供的头像URL
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.worldbookMountEnabled && chatSettings.selectedWorldbooks) {
                for (const worldbookId of chatSettings.selectedWorldbooks) {
                    const worldbook = worldbooks.find(w => w.id === worldbookId);
                    if (worldbook && worldbook.content && worldbook.content.includes(actualAvatarUrl)) {
                        console.log('头像来源验证通过：世界书中的URL');
                        return true;
                    }
                }
            }

            console.log('头像来源验证失败');
            return false;
        }
        
        // 角色主动更换头像功能 - 只修改聊天设置中的头像，不修改角色卡
        async function changeCharacterAvatarByAI(newAvatarUrl, reason = '') {
            if (!currentChatCharacter || !newAvatarUrl) return false;
            
            try {
                // 获取或创建当前聊天的设置
                const currentSettings = getCurrentChatSettings();
                
                // 压缩头像图片以减少存储空间
                let compressedAvatarUrl = newAvatarUrl;
                if (newAvatarUrl.startsWith('data:image')) {
                    try {
                        compressedAvatarUrl = await compressImage(newAvatarUrl, 200, 0.7);
                        console.log('头像已压缩以节省存储空间');
                    } catch (error) {
                        console.warn('头像压缩失败，使用原图:', error);
                    }
                }
                
                // 🔥【修复】使用动态头像字段，优先级高于用户设置的聊天头像
                if (!chatSettings[currentChatCharacter.id]) {
                    chatSettings[currentChatCharacter.id] = {};
                }
                chatSettings[currentChatCharacter.id].aiDynamicAvatar = compressedAvatarUrl;
                
                console.log(`动态头像已设置：`, {
                    characterId: currentChatCharacter.id,
                    characterName: currentChatCharacter.name,
                    avatarUrl: compressedAvatarUrl.substring(0, 50) + '...',
                    settingsSnapshot: {
                        aiDynamicAvatar: !!chatSettings[currentChatCharacter.id].aiDynamicAvatar,
                        aiChatAvatar: !!chatSettings[currentChatCharacter.id].aiChatAvatar
                    }
                });
                
                // 保存聊天设置
                await saveChatSettings();
                
                // 发送系统提示消息
                const systemMessage = {
                    id: Date.now().toString(),
                    sender: 'system',
                    content: `${currentChatCharacter.name} 更换了头像${reason ? ': ' + reason : ''}`,
                    timestamp: Date.now(),
                    isAvatarChange: true
                };
                
                if (!chatMessages[currentChatCharacter.id]) {
                    chatMessages[currentChatCharacter.id] = [];
                }
                chatMessages[currentChatCharacter.id].push(systemMessage);
                await saveChatMessages();
                
                // 🔥【修复】在保存消息后再刷新聊天界面，确保包含新头像和系统消息
                renderChatMessages(currentChatCharacter.id);
                
                // 🔥【新增】强制刷新所有头像显示
                forceRefreshAvatars();
                
                console.log(`角色 ${currentChatCharacter.name} 在当前聊天中更换了头像，但角色卡保持不变`);
                
                return true;
            } catch (error) {
                console.error('角色更换头像失败:', error);
                return false;
            }
            
            return false;
        }
        
        // 删除消息
        async function deleteMessage(messageId = null) {
            const targetMessageId = messageId || selectedMessageId;
            console.log('删除消息:', targetMessageId, '来源:', messageId ? '移动端' : '桌面端');
            if (!targetMessageId) {
                console.log('错误: 没有选中的消息ID');
                return;
            }

                const messages = chatMessages[currentChatCharacter.id] || [];
                const messageIndex = messages.findIndex(msg => msg.id === targetMessageId);
                
            if (messageIndex === -1) {
                hideMessageMenu();
                return;
            }
            
            const messageToDelete = messages[messageIndex];
            
            if (confirm('确定要撤回这条消息吗？')) {
                // 保存原始消息内容
                const originalContent = messageToDelete.content || '[图片]';

                // 🔥【修复】删除相关的时间线记录和工作记忆
                try {
                    await deleteRelatedTimelineEvents(messageToDelete);
                    console.log('✅ 已清理撤回消息的相关时间线记录');
                } catch (error) {
                    console.error('删除时间线记录失败:', error);
                }

                // 删除原消息
                    messages.splice(messageIndex, 1);

                // 🔥【新增】创建撤回消息系统提醒
                const whoRecalled = messageToDelete.sender === 'received' ? '对方' : '你';
                const recallSystemMessage = {
                    id: Date.now().toString(),
                    sender: 'system',
                    content: `${whoRecalled}撤回了一条消息，原文是："${originalContent}"`,
                    timestamp: messageToDelete.timestamp || Date.now(),
                    isRecall: true
                };

                // 在原位置插入撤回提醒
                messages.splice(messageIndex, 0, recallSystemMessage);

                    saveChatMessages();
                    renderChatMessages(currentChatCharacter.id);
                    // 更新消息列表中的最后一条消息
                    renderMessageList();
            }
            
            hideMessageMenu();
        }
        

        
        // 格式化时间
        function formatTime(timestamp) {
            const date = new Date(timestamp);
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        }
        
        // 格式化时间戳（完整时间）
        function formatTimestamp(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const yesterday = new Date(today.getTime() - 24 * 60 * 60 * 1000);
            const messageDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            const timeStr = `${hours}:${minutes}`;
            
            if (messageDate.getTime() === today.getTime()) {
                return timeStr; // 今天只显示时间
            } else if (messageDate.getTime() === yesterday.getTime()) {
                return `昨天 ${timeStr}`;
            } else {
                const month = (date.getMonth() + 1).toString().padStart(2, '0');
                const day = date.getDate().toString().padStart(2, '0');
                return `${month}月${day}日 ${timeStr}`;
            }
        }
        
        // 格式化时间（仅时分）
        function formatTimeOnly(timestamp) {
            const date = new Date(timestamp);
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        }
        
        // 格式化完整日期
        function formatFullDate(date) {
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${year}年${month}月${day}日 ${hours}:${minutes}`;
        }
        
        // 加载URL
        function loadUrl() {
            const url = document.getElementById('browser-url').value;
            let fullUrl = url;
            
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                fullUrl = 'https://' + url;
            }
            
            document.getElementById('browser-frame').src = fullUrl;
        }
        
        // 旧版本API类型切换处理已删除 - 使用新版本的API设置系统
        
        // 旧版本测试API连接和获取模型列表函数已删除 - 现在使用新版本的API设置系统
        
        // 保存API设置
        async function saveApiSettings() {
            const baseUrl = document.getElementById('api-base').value.trim();
            const apiKey = document.getElementById('api-key').value.trim();
            const model = document.getElementById('model-select').value.trim();
            const temperature = parseFloat(document.getElementById('temperature-slider').value) || 0.75;

            if (!baseUrl || !apiKey || !model) {
                showToast('请填写完整的API配置信息', 'error');
                return;
            }

            apiSettings = {
                base: baseUrl,
                key: apiKey,
                model: model,
                temperature: temperature,
                endpoint: '/chat/completions'  // 添加默认endpoint
            };

            try {
                // 🔥【修复】同时保存到IndexedDB和localStorage，确保数据一致性
                await db.apiSettings.put({
                    id: 'main',
                    settings: apiSettings
                });
                localStorage.setItem('apiSettings', JSON.stringify(apiSettings));

                showToast('API设置已保存！', 'success');
                console.log('🔧 [API设置] 已保存到IndexedDB和localStorage:', apiSettings);
            } catch (error) {
                console.error('保存API设置失败:', error);
                showToast('保存API设置失败: ' + error.message, 'error');
                return;
            }

            // 更新温度显示
            document.getElementById('temperature-value').textContent = temperature.toFixed(2);

            // 修复：保存后不跳转，留在当前API设置页面
        }
        
        // 🌟 Gemini直连快速设置
        function setGeminiDirect() {
            // 自动填充Gemini配置
            document.getElementById('api-base').value = 'https://generativelanguage.googleapis.com/v1beta';
            document.getElementById('api-key').placeholder = '请输入Google AI Studio的API Key';
            
            // 清空之前的模型选择并添加Gemini模型
            const modelSelect = document.getElementById('model-select');
            modelSelect.innerHTML = `
                <option value="">请选择模型...</option>
                <option value="gemini-2.0-flash-exp">Gemini 2.0 Flash (实验版) - 推荐</option>
                <option value="gemini-1.5-flash">Gemini 1.5 Flash - 快速</option>
                <option value="gemini-1.5-flash-8b">Gemini 1.5 Flash 8B - 轻量</option>
                <option value="gemini-1.5-pro">Gemini 1.5 Pro - 稳定</option>
                <option value="gemini-pro">Gemini Pro - 经典</option>
                <option value="gemini-pro-vision">Gemini Pro Vision - 视觉</option>
                <option value="手动输入模型名称">手动输入模型名称</option>
            `;
            
            // 添加手动输入功能
            modelSelect.onchange = function() {
                if (this.value === '手动输入模型名称') {
                    const customModel = prompt('请输入Gemini模型名称\n\n常见选项：\n• gemini-2.0-flash-exp\n• gemini-1.5-flash\n• gemini-1.5-pro\n• gemini-pro');
                    if (customModel && customModel.trim()) {
                        const newOption = new Option(customModel.trim(), customModel.trim());
                        this.insertBefore(newOption, this.lastElementChild);
                        this.value = customModel.trim();
                    } else {
                        this.value = '';
                    }
                }
            };
            
            showToast('🌟 Gemini直连配置已自动填写！\n\n使用说明：\n1. 请在Google AI Studio获取API Key\n2. 选择合适的模型\n3. 点击"测试连接"验证配置', 'success');
        }
        
        // 🤗 HuggingFace反代快速设置
        function setHuggingFaceProxy() {
            // 自动填充HuggingFace反代配置 - 使用正确的格式
            document.getElementById('api-base').value = 'https://xxx-xxx.hf.space/v1';
            document.getElementById('api-key').placeholder = '请输入HuggingFace的API Token';
            
            // 清空之前的模型选择并添加常见HF模型
            const modelSelect = document.getElementById('model-select');
            modelSelect.innerHTML = `
                <option value="">请选择模型...</option>
                <optgroup label="Llama系列">
                    <option value="meta-llama/Llama-2-7b-chat-hf">Llama-2-7b-chat-hf</option>
                    <option value="meta-llama/Llama-2-13b-chat-hf">Llama-2-13b-chat-hf</option>
                    <option value="meta-llama/Meta-Llama-3-8B-Instruct">Meta-Llama-3-8B-Instruct</option>
                </optgroup>
                <optgroup label="对话模型">
                <option value="microsoft/DialoGPT-large">DialoGPT-large</option>
                <option value="microsoft/DialoGPT-medium">DialoGPT-medium</option>
                    <option value="facebook/blenderbot-400M-distill">BlenderBot-400M</option>
                </optgroup>
                <optgroup label="通用模型">
                    <option value="mistralai/Mistral-7B-Instruct-v0.1">Mistral-7B-Instruct</option>
                    <option value="teknium/OpenHermes-2.5-Mistral-7B">OpenHermes-2.5-Mistral-7B</option>
                </optgroup>
                <optgroup label="自定义">
                    <option value="custom">手动输入模型名称...</option>
                </optgroup>
            `;
            
            // 添加自定义模型输入功能
            modelSelect.onchange = function() {
                if (this.value === 'custom') {
                    const customModel = prompt('请输入模型名称（例如：meta-llama/Llama-2-7b-chat-hf）：');
                    if (customModel && customModel.trim()) {
                        const newOption = new Option(customModel.trim(), customModel.trim());
                        this.insertBefore(newOption, this.lastElementChild);
                        this.value = customModel.trim();
                    } else {
                        this.value = '';
                    }
                }
            };
            
            showToast('🤗 HuggingFace反代配置已自动填写！\n\n请：\n1. 将地址中的 xxx-xxx 替换为实际的HF Space地址\n2. 选择模型或手动输入模型名称', 'success');
        }
        
        // 保存当前配置为预设
        function saveCurrentConfig() {
            const configName = document.getElementById('config-name-input').value.trim();
            
            if (!configName) {
                showToast('请输入配置名称', 'error');
                return;
            }
            
            const currentConfig = {
                name: configName,
                base: document.getElementById('api-base').value.trim(),
                key: document.getElementById('api-key').value.trim(),
                model: document.getElementById('model-select').value.trim(),
                temperature: parseFloat(document.getElementById('temperature-slider').value) || 0.75,
                savedAt: new Date().toLocaleString()
            };
            
            // 获取已保存的配置
            let savedConfigs = JSON.parse(localStorage.getItem('savedApiConfigs') || '[]');
            
            // 检查是否已存在同名配置
            const existingIndex = savedConfigs.findIndex(config => config.name === configName);
            if (existingIndex !== -1) {
                if (confirm(`配置"${configName}"已存在，是否覆盖？`)) {
                    savedConfigs[existingIndex] = currentConfig;
                } else {
                    return;
                }
            } else {
                savedConfigs.push(currentConfig);
            }
            
            localStorage.setItem('savedApiConfigs', JSON.stringify(savedConfigs));
            document.getElementById('config-name-input').value = '';
            
            renderSavedConfigs();
            showToast(`配置"${configName}"已保存`, 'success');
        }
        
        // 渲染已保存的配置
        function renderSavedConfigs() {
            const container = document.getElementById('saved-configs-container');
            const noConfigsMessage = document.getElementById('no-configs-message');
            const savedConfigs = JSON.parse(localStorage.getItem('savedApiConfigs') || '[]');
            
            if (savedConfigs.length === 0) {
                container.style.display = 'none';
                noConfigsMessage.style.display = 'block';
                return;
            }
            
            container.style.display = 'grid';
            noConfigsMessage.style.display = 'none';
            
            container.innerHTML = savedConfigs.map(config => `
                <div class="config-card" style="background: rgba(255,255,255,0.8); border-radius: 12px; padding: 15px; border: 1px solid rgba(0,0,0,0.05); transition: all 0.3s ease; cursor: pointer;" onclick="loadConfig('${config.name}')">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                        <div style="font-weight: 600; color: #333; font-size: 15px;">${config.name}</div>
                        <button onclick="event.stopPropagation(); deleteConfig('${config.name}')" style="background: none; border: none; color: #ff6b6b; cursor: pointer; padding: 2px 6px; border-radius: 4px; font-size: 12px; transition: all 0.2s ease;" onmouseover="this.style.background='rgba(255,107,107,0.1)'" onmouseout="this.style.background='none'">🗑️</button>
                    </div>
                    <div style="font-size: 12px; color: #666; margin-bottom: 4px;">
                        <div>🌐 ${config.base}</div>
                        <div>🤖 ${config.model}</div>
                        <div>🌡️ 温度: ${config.temperature}</div>
                    </div>
                    <div style="font-size: 11px; color: #999;">保存于: ${config.savedAt}</div>
                </div>
            `).join('');
        }
        
        // 加载配置
        function loadConfig(configName) {
            const savedConfigs = JSON.parse(localStorage.getItem('savedApiConfigs') || '[]');
            const config = savedConfigs.find(c => c.name === configName);
            
            if (!config) {
                showToast('配置不存在', 'error');
                return;
            }
            
            // 填充表单
            document.getElementById('api-base').value = config.base;
            document.getElementById('api-key').value = config.key;
            document.getElementById('temperature-slider').value = config.temperature;
            document.getElementById('temperature-value').textContent = config.temperature.toFixed(2);
            
            // 处理模型选择
            const modelSelect = document.getElementById('model-select');
            const existingOption = Array.from(modelSelect.options).find(option => option.value === config.model);
            if (!existingOption) {
                // 如果模型不在当前选项中，添加它
                const newOption = new Option(config.model, config.model);
                modelSelect.appendChild(newOption);
            }
            modelSelect.value = config.model;
            
            showToast(`已加载配置"${configName}"`, 'success');
        }
        
        // 删除配置
        function deleteConfig(configName) {
            if (confirm(`确定要删除配置"${configName}"吗？`)) {
                let savedConfigs = JSON.parse(localStorage.getItem('savedApiConfigs') || '[]');
                savedConfigs = savedConfigs.filter(config => config.name !== configName);
                localStorage.setItem('savedApiConfigs', JSON.stringify(savedConfigs));
                renderSavedConfigs();
                showToast(`配置"${configName}"已删除`, 'success');
            }
        }
        
        // 清空所有配置
        function clearAllConfigs() {
            if (confirm('确定要清空所有已保存的配置吗？此操作不可恢复。')) {
                localStorage.removeItem('savedApiConfigs');
                renderSavedConfigs();
                showToast('所有配置已清空', 'success');
            }
        }
        
        // 测试API连接
        async function testApiConnection() {
            const baseUrl = document.getElementById('api-base').value.trim();
            const apiKey = document.getElementById('api-key').value.trim();
            const model = document.getElementById('model-select').value.trim();
            
            if (!baseUrl || !apiKey || !model) {
                showToast('请先填写完整的API配置', 'error');
                return;
            }
            
            const testBtn = document.getElementById('test-api-connection-btn');
            const originalText = testBtn.textContent;
            testBtn.textContent = '测试中...';
            testBtn.disabled = true;
            
            try {
                // 根据不同的API类型构建测试请求
                let testUrl, testPayload, testHeaders;
                
                if (baseUrl.includes('generativelanguage.googleapis.com')) {
                    // Gemini API测试
                    testUrl = `${baseUrl}/models/${model}:generateContent?key=${apiKey}`;
                    testPayload = {
                        contents: [{
                            parts: [{ text: "Hello" }]
                        }],
                        generationConfig: {
                            temperature: 0.7
                            // 不添加maxOutputTokens等Gemini不支持的参数
                        }
                    };
                    testHeaders = {
                        'Content-Type': 'application/json'
                    };
                } else {
                    // OpenAI兼容API测试 - 智能处理URL拼接
                    if (baseUrl.endsWith('/v1')) {
                        testUrl = `${baseUrl}/chat/completions`;
                    } else if (baseUrl.includes('/v1/')) {
                        // 修复：如果URL中已经包含/v1/路径，直接添加chat/completions
                        testUrl = `${baseUrl}/chat/completions`;
                    } else {
                        testUrl = `${baseUrl}/v1/chat/completions`;
                    }
                    testPayload = {
                        model: model,
                        messages: [{ role: "user", content: "Hello" }],
                        max_tokens: 10
                    };
                    testHeaders = {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    };
                }
                
                const response = await fetch(testUrl, {
                    method: 'POST',
                    headers: testHeaders,
                    body: JSON.stringify(testPayload)
                });
                
                if (response.ok) {
                    showToast('✅ API连接测试成功！', 'success');

                    // 🔥【修复】测试成功后自动保存API设置，避免用户重复输入
                    apiSettings = {
                        base: baseUrl,
                        key: apiKey,
                        model: model,
                        temperature: parseFloat(document.getElementById('temperature-slider').value) || 0.75,
                        endpoint: '/chat/completions'
                    };

                    // 🔥【修复】同时保存到IndexedDB和localStorage，确保数据一致性
                    try {
                        await db.apiSettings.put({
                            id: 'main',
                            settings: apiSettings
                        });
                        localStorage.setItem('apiSettings', JSON.stringify(apiSettings));
                        console.log('🔧 [API测试] API设置已自动保存到IndexedDB和localStorage');
                    } catch (error) {
                        console.error('自动保存API设置失败:', error);
                    }
                } else {
                    const errorText = await response.text();
                    showToast(`❌ API连接失败: ${response.status} ${response.statusText}`, 'error');
                    console.error('API测试失败:', errorText);
                }
            } catch (error) {
                showToast(`❌ 连接错误: ${error.message}`, 'error');
                console.error('API测试错误:', error);
            } finally {
                testBtn.textContent = originalText;
                testBtn.disabled = false;
            }
        }
        
        // 获取模型列表
        async function fetchModels() {
            const baseUrl = document.getElementById('api-base').value.trim();
            const apiKey = document.getElementById('api-key').value.trim();
            
            if (!baseUrl || !apiKey) {
                showToast('请先填写API地址和密钥', 'error');
                return;
            }
            
            const fetchBtn = document.getElementById('fetch-models-btn');
            const originalText = fetchBtn.textContent;
            fetchBtn.textContent = '获取中...';
            fetchBtn.disabled = true;
            
            try {
                let modelsUrl, headers;
                
                if (baseUrl.includes('generativelanguage.googleapis.com')) {
                    // Gemini API
                    modelsUrl = `${baseUrl}/models?key=${apiKey}`;
                    headers = {};
                } else {
                    // OpenAI兼容API - 智能处理URL拼接
                    if (baseUrl.endsWith('/v1')) {
                        modelsUrl = `${baseUrl}/models`;
                    } else if (baseUrl.includes('/v1/')) {
                        // 修复：如果URL中已经包含/v1/路径，直接添加models
                        modelsUrl = `${baseUrl}/models`;
                    } else {
                        modelsUrl = `${baseUrl}/v1/models`;
                    }
                    headers = {
                        'Authorization': `Bearer ${apiKey}`
                    };
                }
                
                // 🔥【修复】移除超时控制，避免AbortError
                const response = await fetch(modelsUrl, { 
                    headers
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                const modelSelect = document.getElementById('model-select');
                
                // 清空现有选项
                modelSelect.innerHTML = '<option value="">请选择模型...</option>';
                
                let models = [];
                if (data.models) {
                    // Gemini API格式 - 修复模型过滤逻辑
                    console.log('Gemini API响应数据:', data);
                    models = data.models
                        .filter(model => {
                            // 允许所有支持generateContent的模型
                            return model.name && (
                                model.name.includes('gemini') ||
                                model.name.includes('models/') ||
                                model.supportedGenerationMethods?.includes('generateContent') ||
                                model.name.includes('generate')
                            );
                        })
                        .map(model => {
                            // 提取模型名称，去掉前缀
                            const modelName = model.name.includes('/') 
                                ? model.name.split('/').pop() 
                                : model.name;
                            return modelName;
                        });
                        
                    // 如果过滤后没有模型，显示所有模型（调试用）
                    if (models.length === 0 && data.models.length > 0) {
                        console.log('过滤后没有模型，显示所有可用模型:', data.models);
                        models = data.models.map(model => 
                            model.name.includes('/') ? model.name.split('/').pop() : model.name
                        );
                    }
                } else if (data.data) {
                    // OpenAI API格式
                    models = data.data.map(model => model.id);
                }
                
                models.forEach(modelId => {
                    const option = new Option(modelId, modelId);
                    modelSelect.appendChild(option);
                });
                
                showToast(`✅ 成功获取到 ${models.length} 个模型`, 'success');
            } catch (error) {
                let errorMessage = error.message;
                
                if (errorMessage.includes('Failed to fetch') || errorMessage.includes('ERR_TIMED_OUT')) {
                    if (baseUrl.includes('.hf.space')) {
                        errorMessage = 'HuggingFace Space连接超时，可能需要先启动服务或检查网络连接。\n\n💡 建议：\n1. 检查HF Space是否正在运行\n2. 尝试先手动访问该URL测试连接\n3. 如果服务不支持/models端点，请手动输入模型名称';
                    } else {
                        errorMessage = '网络连接失败，请检查URL是否正确以及网络连接';
                    }
                }
                
                showToast(`❌ 获取模型失败: ${errorMessage}`, 'error');
                console.error('获取模型失败:', error);
                
                // 为Gemini提供常见模型选项作为后备
                if (baseUrl.includes('generativelanguage.googleapis.com')) {
                    const modelSelect = document.getElementById('model-select');
                    modelSelect.innerHTML = `
                        <option value="">请选择模型...</option>
                        <option value="gemini-2.0-flash-exp">Gemini 2.0 Flash (实验版)</option>
                        <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
                        <option value="gemini-1.5-flash-8b">Gemini 1.5 Flash 8B</option>
                        <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
                        <option value="gemini-pro">Gemini Pro</option>
                        <option value="gemini-pro-vision">Gemini Pro Vision</option>
                        <option value="手动输入模型名称">手动输入模型名称</option>
                    `;
                    setTimeout(() => {
                        showToast('💡 已为您提供常见Gemini模型选项', 'info');
                    }, 1000);
                }
                
                // 如果是HF Space，给出额外提示
                if (baseUrl.includes('.hf.space')) {
                    setTimeout(() => {
                        showToast('💡 提示：HuggingFace Space可能不支持自动获取模型列表，建议手动输入模型名称', 'info');
                    }, 2000);
                }
            } finally {
                fetchBtn.textContent = originalText;
                fetchBtn.disabled = false;
            }
        }
        
        // 导出完整备份
        function exportFullBackup() {
            // 这里可以实现完整的数据导出功能
            showToast('导出功能开发中...', 'info');
        }
        
        // 导入完整备份
        function importFullBackup() {
            // 这里可以实现完整的数据导入功能
            document.getElementById('import-full-backup-input').click();
        }
        
        // 初始化API设置界面
        async function initializeApiSettings() {
            // 加载已保存的API配置到表单
            await loadApiSettingsToForm();

            // 渲染已保存的配置
            renderSavedConfigs();
        }
        
        // 🔥【修复】加载API设置到表单并自动拉取模型
        async function loadApiSettingsToForm() {
            try {
                // 从IndexedDB加载设置
                const savedSettings = await db.apiSettings.get('main');
                let settings = null;

                if (savedSettings) {
                    settings = savedSettings.settings;
                } else {
                    // 尝试从localStorage迁移
                    const localSettings = localStorage.getItem('apiSettings');
                    if (localSettings) {
                        settings = JSON.parse(localSettings);
                        // 迁移到IndexedDB
                        await db.apiSettings.put({
                            id: 'main',
                            settings: settings
                        });
                        console.log('🔧 [API设置] 已迁移localStorage设置到IndexedDB');
                    }
                }

                if (settings) {
                    console.log('🔧 [API设置] 加载已保存的API设置:', settings);

                    // 填充表单字段
                    if (settings.base) {
                        const baseInput = document.getElementById('api-base');
                        if (baseInput) baseInput.value = settings.base;
                    }

                    if (settings.key) {
                        const keyInput = document.getElementById('api-key');
                        if (keyInput) keyInput.value = settings.key;
                    }

                    if (settings.temperature !== undefined) {
                        const tempSlider = document.getElementById('temperature-slider');
                        const tempValue = document.getElementById('temperature-value');
                        if (tempSlider && tempValue) {
                            tempSlider.value = settings.temperature;
                            tempValue.textContent = settings.temperature.toFixed(2);
                        }
                    }

                    // 🔥【重要修复】如果有保存的API设置，自动拉取模型列表
                    if (settings.base && settings.key) {
                        console.log('🔧 [API设置] 检测到完整的API配置，自动拉取模型列表');

                        // 延迟一点执行，确保UI已经加载完成
                        setTimeout(() => {
                            fetchModels().then(() => {
                                // 拉取完成后，如果有保存的模型，选中它
                                if (settings.model) {
                                    const modelSelect = document.getElementById('model-select');
                                    if (modelSelect) {
                                        // 如果模型不在选项中，添加它
                                        const existingOption = Array.from(modelSelect.options).find(option => option.value === settings.model);
                                        if (!existingOption) {
                                            const newOption = new Option(settings.model, settings.model);
                                            modelSelect.appendChild(newOption);
                                        }
                                        modelSelect.value = settings.model;
                                        console.log('🔧 [API设置] 已自动选中保存的模型:', settings.model);
                                    }
                                }
                            }).catch(error => {
                                console.log('🔧 [API设置] 自动拉取模型失败，但会保留已保存的模型选项');
                                // 即使拉取失败，也要恢复保存的模型选项
                                if (settings.model) {
                                    const modelSelect = document.getElementById('model-select');
                                    if (modelSelect) {
                                        const existingOption = Array.from(modelSelect.options).find(option => option.value === settings.model);
                                        if (!existingOption) {
                                            const newOption = new Option(settings.model, settings.model);
                                            modelSelect.appendChild(newOption);
                                        }
                                        modelSelect.value = settings.model;
                                        console.log('🔧 [API设置] 已恢复保存的模型选项:', settings.model);
                                    }
                                }
                            });
                        }, 500);
                    } else {
                        // 没有完整的API配置时，仍然要恢复保存的模型选项
                        if (settings.model) {
                            const modelSelect = document.getElementById('model-select');
                            if (modelSelect) {
                                const existingOption = Array.from(modelSelect.options).find(option => option.value === settings.model);
                                if (!existingOption) {
                                    const newOption = new Option(settings.model, settings.model);
                                    modelSelect.appendChild(newOption);
                                }
                                modelSelect.value = settings.model;
                                console.log('🔧 [API设置] 已恢复保存的模型选项（无自动拉取）:', settings.model);
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('加载API设置失败:', error);
            }
        }
        
        // 电池管理功能
        async function initBatteryManager() {
            // 首先设置默认显示为 ᰔᩚ
            const allBatteryTexts = document.querySelectorAll('.battery-text');

            allBatteryTexts.forEach((element, index) => {
                element.textContent = 'ᰔᩚ';
            });

            if ('getBattery' in navigator) {
                try {
                    const battery = await navigator.getBattery();
                    updateBatteryDisplay(battery);

                    battery.addEventListener('levelchange', () => updateBatteryDisplay(battery));
                    battery.addEventListener('chargingchange', () => updateBatteryDisplay(battery));
                } catch (err) {
                    console.error("无法获取电池信息:", err);
                    // 保持默认显示 ᰔᩚ
                    allBatteryTexts.forEach(element => {
                        element.textContent = 'ᰔᩚ';
                    });
                }
            } else {
                // 保持默认显示 ᰔᩚ
                allBatteryTexts.forEach(element => {
                    element.textContent = 'ᰔᩚ';
                });
            }
        }
        
        function updateBatteryDisplay(battery) {
            const level = Math.floor(battery.level * 100);
            const isCharging = battery.charging;
            
            // 更新主状态栏电池
            const batteryContainer = document.getElementById('status-bar-battery');

            if (batteryContainer) {
                const batteryLevelEl = batteryContainer.querySelector('.battery-level');
                const batteryTextEl = batteryContainer.querySelector('.battery-text');

                if (batteryLevelEl && batteryTextEl) {
                    batteryLevelEl.style.width = `${level}%`;
                    batteryTextEl.textContent = `${level}%`;
                    
                    if (isCharging) {
                        batteryContainer.classList.add('charging');
                    } else {
                        batteryContainer.classList.remove('charging');
                    }
                }
            }
            
            // 更新应用内状态栏电池
            const appBatteryContainers = document.querySelectorAll('.app-battery-container');
            const appBatteryTexts = document.querySelectorAll('.app-battery-container .battery-text');
            const appBatteryLevels = document.querySelectorAll('.app-battery-level');
            
            // 应用内也显示真实电量
            appBatteryTexts.forEach(element => {
                element.textContent = `${level}%`;
            });
            
            appBatteryLevels.forEach(element => {
                element.style.width = `${level}%`;
            });
            
            // 同步应用内电池充电状态
            appBatteryContainers.forEach(container => {
                if (isCharging) {
                    container.classList.add('charging');
                } else {
                    container.classList.remove('charging');
                }
            });
        }
        
        // 手动测试电池显示功能 - 您可以在浏览器控制台中调用这个函数
        function testBatteryDisplay() {
            // 检查电池文本元素
            const allBatteryTexts = document.querySelectorAll('.battery-text');

            // 检查主屏幕电池容器
            const mainBattery = document.getElementById('status-bar-battery');

            if (mainBattery) {
                const batteryText = mainBattery.querySelector('.battery-text');
            }

            // 测试设置为百分比
            allBatteryTexts.forEach((element, index) => {
                element.textContent = '77%';
            });

            // 3秒后恢复为爱心
            setTimeout(() => {
                allBatteryTexts.forEach((element, index) => {
                    element.textContent = 'ᰔᩚ';
                });
            }, 3000);
        }
        
        // 主题切换功能
        function changeTheme(themeName) {
            const body = document.body;
            
            // 移除之前的主题
            body.removeAttribute('data-theme');
            
            // 应用新主题
            if (themeName !== 'default') {
                body.setAttribute('data-theme', themeName);
            }
            
            // 保存主题设置
            localStorage.setItem('selectedTheme', themeName);
            
            // 给用户反馈
            const themeNames = {
                'default': '简约风格',
                'cute': '可爱风格',
                'nature': '自然风格', 
                'tech': '科技风格',
                'dream': '梦幻风格'
            };
            
            // 显示Toast提示
            showToast(`已切换到 ${themeNames[themeName]} 主题！`, 'success');
        }
        
        // 加载保存的主题
        function loadSavedTheme() {
            const savedTheme = localStorage.getItem('selectedTheme');
            if (savedTheme && savedTheme !== 'default') {
                document.body.setAttribute('data-theme', savedTheme);
            }
        }
        
        // 世界书相关功能
        let worldbooks = [];
        let editingWorldbook = null;
        
        // 加载世界书数据 - 使用IndexedDB（包含数据迁移）
        async function loadWorldbooks() {
            try {
                // 先从IndexedDB加载
                const savedWorldbooks = await db.worldbooks.toArray();
                
                if (savedWorldbooks.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('worldbooks');
                    if (localStorageData) {
                        console.log('检测到localStorage中的世界书数据，开始迁移...');
                        const localWorldbooks = JSON.parse(localStorageData);
                        
                        if (localWorldbooks.length > 0) {
                            // 确保每个世界书都有id字段
                            const migrationData = localWorldbooks.map(wb => ({
                                id: wb.id || Date.now().toString() + Math.random(),
                                title: wb.title,
                                content: wb.content,
                                createdAt: wb.createdAt || new Date().toISOString(),
                                updatedAt: wb.updatedAt || new Date().toISOString()
                            }));
                            
                            // 迁移到IndexedDB
                            await db.worldbooks.bulkAdd(migrationData);
                            worldbooks = migrationData;
                            console.log('世界书数据迁移完成:', worldbooks);
                        } else {
                            worldbooks = [];
                        }
                    } else {
                        worldbooks = [];
                    }
                } else {
                    // IndexedDB中有数据，直接使用
                    worldbooks = savedWorldbooks;
                    console.log('从IndexedDB加载世界书数据:', worldbooks);
                }
                
                // 🔥 检查并迁移旧的角色世界书数据
                await migrateOldCharacterWorldbooks();
                
            } catch (error) {
                console.error('加载世界书失败:', error);
                // 如果IndexedDB失败，回退到localStorage
                const localStorageData = localStorage.getItem('worldbooks');
                if (localStorageData) {
                    try {
                        worldbooks = JSON.parse(localStorageData);
                } catch (e) {
                        worldbooks = [];
                    }
                } else {
                    worldbooks = [];
                }
                
                // 也为localStorage数据进行迁移
                await migrateOldCharacterWorldbooks();
            }
            renderWorldbookList();
        }

        // 迁移旧的角色世界书数据
        async function migrateOldCharacterWorldbooks() {
            let migrationCount = 0;
            let needsSave = false;

            worldbooks.forEach(worldbook => {
                // 检查是否是旧的角色世界书（通过名称模式识别）
                if (!worldbook.source && !worldbook.isGlobal && worldbook.name && worldbook.name.includes('[') && worldbook.name.includes(']')) {
                    // 解析角色名称
                    const match = worldbook.name.match(/^\[(.+?)\]/);
                    if (match) {
                        const characterName = match[1];
                        console.log(`🔄 迁移旧的角色世界书: ${worldbook.name} -> 分类: ${characterName}`);
                        
                        worldbook.source = 'character_card';
                        worldbook.category = characterName;
                        migrationCount++;
                        needsSave = true;
                    }
                }
                
                // 检查是否缺少必要的字段并修复
                if (!worldbook.id) {
                    worldbook.id = Date.now().toString() + Math.random();
                    needsSave = true;
                }
                if (!worldbook.title && worldbook.name) {
                    worldbook.title = worldbook.name;
                    needsSave = true;
                }
            });

            if (needsSave) {
                console.log(`📦 迁移完成，共迁移 ${migrationCount} 个角色世界书`);
                await saveWorldbooks();
                if (migrationCount > 0) {
                    showToast(`已自动迁移${migrationCount}个角色世界书到新分类`, 'success');
                }
            }
        }
        
        // 保存世界书数据 - 使用IndexedDB
        async function saveWorldbooks() {
            try {
                console.log('保存世界书数据到IndexedDB:', worldbooks);
                
                // 🔥【安全修复】使用事务确保原子操作，防止数据丢失
                if (worldbooks.length === 0) {
                    console.warn('⚠️ 世界书数据为空，跳过保存操作');
                    return;
                }

                // 使用事务进行原子操作
                await db.transaction('rw', db.worldbooks, async () => {
                    await db.worldbooks.clear();
                    await db.worldbooks.bulkAdd(worldbooks);
                });

                console.log(`✅ 安全保存了 ${worldbooks.length} 个世界书到数据库`);
                
                console.log('世界书数据保存成功');
            } catch (error) {
                console.error('保存世界书时发生错误:', error);
                // 如果IndexedDB失败，回退到localStorage
            localStorage.setItem('worldbooks', JSON.stringify(worldbooks));
            }
        }
        
        function showWorldbookForm(isGlobal, characterCategory = null) {
    // 根据传入的类型来决定表单标题
    let title;
    if (isGlobal) {
        title = '新建全局设定';
    } else if (characterCategory) {
        title = `新建${characterCategory}的世界书`;
    } else {
        title = '新建局部设定';
    }
    document.getElementById('worldbook-form-title').textContent = title;

    editingWorldbook = null; // 清除编辑状态
            document.getElementById('worldbook-title').value = '';
            document.getElementById('worldbook-content').value = '';

    // 将创建类型暂存起来，以便保存时使用
    window.newWorldbookIsGlobal = isGlobal;
    window.newWorldbookCharacterCategory = characterCategory;

            showApp('worldbook-form-screen');
        }
        
        function hideWorldbookForm() {
            hideApp('worldbook-form-screen');
            // 确保返回到世界书应用，而不是主屏幕
            showApp('worldbook-screen');
        }
        
        async function saveWorldbook() {
            const title = document.getElementById('worldbook-title').value.trim();
            const content = document.getElementById('worldbook-content').value.trim();
            
    if (!title || !content) {
        alert('请输入标题和内容');
                return;
            }
            
    let isGlobal;
    if (editingWorldbook) {
        // 如果是编辑模式，保持其原有的类型不变
        isGlobal = editingWorldbook.isGlobal;
    } else {
        // 如果是新建模式，读取我们暂存的类型
        isGlobal = window.newWorldbookIsGlobal;
            }
            
            const worldbook = {
                id: editingWorldbook ? editingWorldbook.id : Date.now().toString(),
                title: title,
                content: content,
        isGlobal: isGlobal, // 根据正确的状态设置
                createdAt: editingWorldbook ? editingWorldbook.createdAt : new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };

            // 如果是角色分类的世界书，添加分类信息
            if (!isGlobal && window.newWorldbookCharacterCategory) {
                worldbook.category = window.newWorldbookCharacterCategory;
                worldbook.source = 'character_card';
            }
            
            if (editingWorldbook) {
                const index = worldbooks.findIndex(w => w.id === editingWorldbook.id);
        if (index !== -1) worldbooks[index] = worldbook;
            } else {
                worldbooks.push(worldbook);
            }
            
            await saveWorldbooks();
            renderWorldbookList();
            showToast(editingWorldbook ? '世界书已更新！' : '世界书已创建！', 'success');
            hideWorldbookForm();
        }
// --- 新增函数 ---
async function toggleGlobalWorldbook(bookId, isEnabled) {
    // 确保window.activeGlobalWorldbooks存在
    if (!window.activeGlobalWorldbooks) {
        window.activeGlobalWorldbooks = [];
    }
    
    if (isEnabled) {
        // 如果开启，添加到激活列表（如果不存在）
        if (!window.activeGlobalWorldbooks.includes(bookId)) {
            window.activeGlobalWorldbooks.push(bookId);
        }
    } else {
        // 如果关闭，从激活列表中移除
        window.activeGlobalWorldbooks = window.activeGlobalWorldbooks.filter(id => id !== bookId);
    }
    
    // 保存激活状态到数据库的 globalSettings 表
    try {
        await db.globalSettings.put({
            id: 'main',
            activeGlobalWorldbooks: window.activeGlobalWorldbooks
        });
        console.log('全局世界书设置已保存:', window.activeGlobalWorldbooks);
        showToast('全局设定已更新', 'success');
    } catch (error) {
        console.error("保存全局世界书设置失败:", error);
        showToast('设置保存失败', 'error');
    }
        }
        
        function editWorldbook(id) {
            const worldbook = worldbooks.find(w => w.id === id);
            if (worldbook) {
                editingWorldbook = worldbook;
        // 编辑时不显示“新建”，而是“编辑”
        let title;
        if (worldbook.isGlobal) {
            title = '编辑全局设定';
        } else if (worldbook.source === 'character_card' && worldbook.category) {
            title = `编辑${worldbook.category}的世界书`;
        } else {
            title = '编辑局部设定';
        }
        document.getElementById('worldbook-form-title').textContent = title;
                document.getElementById('worldbook-title').value = worldbook.title || worldbook.name;
                document.getElementById('worldbook-content').value = worldbook.content;
                showApp('worldbook-form-screen');
            }
        }
        
        async function deleteWorldbook(id) {
            if (confirm('确定要删除这个世界书吗？')) {
                console.log('🗑️ 删除世界书:', id);
                console.log('删除前的世界书列表:', worldbooks.map(w => ({id: w.id, name: w.name || w.title})));
                
                // 从内存数组中删除
                const initialLength = worldbooks.length;
                worldbooks = worldbooks.filter(w => w.id !== id);
                const finalLength = worldbooks.length;
                
                console.log(`删除操作: ${initialLength} -> ${finalLength}, 删除了 ${initialLength - finalLength} 个项目`);
                
                if (initialLength === finalLength) {
                    console.warn('⚠️ 删除失败：未找到要删除的世界书');
                    showToast('删除失败：未找到指定的世界书', 'error');
                    return;
                }
                
                // 保存到数据库
                try {
                    await saveWorldbooks();
                    console.log('✅ 世界书删除成功');
                    showToast('世界书已删除', 'success');
                } catch (error) {
                    console.error('❌ 删除世界书时数据库保存失败:', error);
                    showToast('删除失败：数据库保存错误', 'error');
                }
                
                // 重新渲染列表
                renderWorldbookList();
            }
        }
        
// 用这段新代码，完整替换掉旧的 renderWorldbookList 函数
        function renderWorldbookList() {
    const globalContainer = document.getElementById('global-worldbooks-content');
    const localContainer = document.getElementById('local-worldbooks-content');
    const characterContainer = document.getElementById('character-worldbooks-content');
    if (!globalContainer || !localContainer || !characterContainer) return;

    const globalBooks = worldbooks.filter(w => w.isGlobal);
    const localBooks = worldbooks.filter(w => !w.isGlobal && (!w.source || w.source !== 'character_card'));
    
    // 获取当前选择的角色分类的世界书
    let characterBooks = [];
    if (currentCharacterCategory) {
        characterBooks = worldbooks.filter(w => 
            !w.isGlobal && 
            w.source === 'character_card' && 
            w.category === currentCharacterCategory
        );
    }

    let globalHtml = '';
    let localHtml = '';
    let characterHtml = '';

    // --- 渲染全局世界书 ---
    globalHtml += `<div class="worldbook-section">`;
    if (globalBooks.length > 0) {
        globalBooks.forEach(book => {
            // 确保使用window.activeGlobalWorldbooks并检查其是否为数组
            const isChecked = Array.isArray(window.activeGlobalWorldbooks) && window.activeGlobalWorldbooks.includes(book.id) ? 'checked' : '';
            globalHtml += `
                <div class="setting-item" onclick="editWorldbook('${book.id}')">
                    <div class="setting-left">
                        <div class="setting-label">${book.title || book.name}</div>
                        <div class="setting-desc">${truncateText(book.content, 60)}</div>
                    </div>
                    <div class="setting-right">
                        <label class="toggle-switch" onclick="event.stopPropagation()">
                            <input type="checkbox" onchange="toggleGlobalWorldbook('${book.id}', this.checked)" ${isChecked}>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
            `;
        });
    } else {
        globalHtml += '<div class="empty-message">暂无全局设定</div>';
    }
    globalHtml += '</div>';

    // --- 渲染局部世界书 ---
    localHtml += `<div class="worldbook-section">`;
    if (localBooks.length > 0) {
        localBooks.forEach(book => {
            const dateObj = new Date(book.updatedAt || book.createdAt || Date.now());
            const date = isNaN(dateObj.getTime()) ? '未知日期' : dateObj.toLocaleDateString();
            const preview = truncateText(book.content, 60);
            localHtml += `
                <div class="worldbook-item" onclick="editWorldbook('${book.id}')">
                    <div class="worldbook-header">
                        <div class="worldbook-content-flex">
                            <div class="worldbook-title">${book.title || book.name}</div>
                            <div class="worldbook-desc-text">${preview}</div>
                            <div class="worldbook-date-text">更新于 ${date}</div>
                        </div>
                        <button onclick="event.stopPropagation(); deleteWorldbook('${book.id}')" class="delete-worldbook-btn">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `;
        });
    } else {
        localHtml += '<div class="empty-message">暂无局部设定</div>';
    }
    localHtml += '</div>';

    // --- 渲染角色世界书 ---
    characterHtml += `<div class="worldbook-section">`;
    if (characterBooks.length > 0) {
        characterBooks.forEach(book => {
            const dateObj = new Date(book.updatedAt || book.createdAt || Date.now());
            const date = isNaN(dateObj.getTime()) ? '未知日期' : dateObj.toLocaleDateString();
            const preview = truncateText(book.content, 60);
            characterHtml += `
                <div class="worldbook-item" onclick="editWorldbook('${book.id}')">
                    <div class="worldbook-header">
                        <div class="worldbook-content-flex">
                            <div class="worldbook-title">${book.title || book.name}</div>
                            <div class="worldbook-desc-text">${preview}</div>
                            <div class="worldbook-date-text">更新于 ${date}</div>
                            <div class="worldbook-source-text">来源: 角色卡导入</div>
                        </div>
                        <button onclick="event.stopPropagation(); deleteWorldbook('${book.id}')" class="delete-worldbook-btn">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `;
        });
    } else {
        const categoryText = currentCharacterCategory ? `"${currentCharacterCategory}"` : '该角色';
        characterHtml += `<div class="empty-message">暂无${categoryText}的世界书设定</div>`;
    }
    characterHtml += '</div>';

    globalContainer.innerHTML = globalHtml;
    localContainer.innerHTML = localHtml;
    characterContainer.innerHTML = characterHtml;
}
function switchWorldbookTab(tabName, characterCategory = null) {
    currentWorldbookTab = tabName; // <--- 核心修改：记录当前标签页
    currentCharacterCategory = characterCategory; // 记录当前选择的角色分类

    const globalContent = document.getElementById('global-worldbooks-content');
    const localContent = document.getElementById('local-worldbooks-content');
    const characterContent = document.getElementById('character-worldbooks-content');
    const tabs = document.querySelectorAll('.worldbook-tab');

    tabs.forEach(tab => {
        if (tab.getAttribute('onclick').includes(tabName)) {
            tab.classList.add('active');
        } else {
            tab.classList.remove('active');
        }
    });

    // 隐藏所有内容面板
    globalContent.style.display = 'none';
    localContent.style.display = 'none';
    characterContent.style.display = 'none';

    if (tabName === 'global') {
        globalContent.style.display = 'block';
    } else if (tabName === 'local') {
        localContent.style.display = 'block';
    } else if (tabName === 'character') {
        if (characterCategory) {
            // 直接显示指定角色的世界书
            characterContent.style.display = 'block';
            document.getElementById('character-tab-text').textContent = characterCategory;
        } else {
            // 显示角色分类选择器
            showCategorySelector();
            return;
        }
    }

    renderWorldbookList();
}
function onWorldbookAddClick() {
    if (currentWorldbookTab === 'global') {
        showWorldbookForm(true); // 创建全局设定
    } else if (currentWorldbookTab === 'local') {
        showWorldbookForm(false); // 创建局部设定
    } else if (currentWorldbookTab === 'character') {
        // 为当前角色分类创建世界书
        showWorldbookForm(false, currentCharacterCategory);
    }
        }

        // 显示角色分类选择器
        function showCategorySelector() {
            // 获取所有角色世界书的分类
            const characterWorldBooks = worldbooks.filter(w => w.source === 'character_card');
            const categories = [...new Set(characterWorldBooks.map(w => w.category))].filter(Boolean);
            
            const categoryOptions = document.getElementById('category-options');
            const selector = document.getElementById('worldbook-category-selector');
            
            if (categories.length === 0) {
                categoryOptions.innerHTML = '<div class="empty-category-message">暂无角色世界书<br/>请先导入包含世界书的角色卡</div>';
            } else {
                categoryOptions.innerHTML = categories.map(category => {
                    const count = characterWorldBooks.filter(w => w.category === category).length;
                    return `
                        <div class="category-option" onclick="selectCategory('${category}')">
                            <div class="category-name">${category}</div>
                            <div class="category-count">${count}个设定</div>
                        </div>
                    `;
                }).join('');
            }
            
            selector.style.display = 'flex';
        }

        // 隐藏角色分类选择器
        function hideCategorySelector() {
            document.getElementById('worldbook-category-selector').style.display = 'none';
            // 回到之前的标签页
            if (currentWorldbookTab === 'character') {
                currentWorldbookTab = 'local';
                switchWorldbookTab('local');
            }
        }

        // 选择角色分类
        function selectCategory(category) {
            hideCategorySelector();
            switchWorldbookTab('character', category);
        }

        // 手动触发数据迁移（调试用）
        async function manualMigrateWorldbooks() {
            console.log('🔧 手动触发世界书数据迁移...');
            await migrateOldCharacterWorldbooks();
            renderWorldbookList();
            console.log('🔧 手动迁移完成');
        }

        // 调试：查看所有世界书数据
        function debugWorldbooks() {
            console.log('📋 当前所有世界书数据:');
            worldbooks.forEach((wb, index) => {
                console.log(`${index + 1}. ID: "${wb.id}", 名称: "${wb.name || wb.title}", 来源: "${wb.source}", 分类: "${wb.category}", 全局: ${wb.isGlobal}`);
            });
            console.log(`总计: ${worldbooks.length} 个世界书`);
            return worldbooks;
        }

        // 强制删除所有角色世界书
        async function forceDeleteCharacterWorldbooks() {
            console.log('🚨 强制删除所有角色世界书...');
            const beforeCount = worldbooks.length;
            
            // 删除所有包含 [角色名] 格式的世界书
            worldbooks = worldbooks.filter(wb => {
                const isCharacterBook = (wb.name && wb.name.includes('[') && wb.name.includes(']')) || 
                                       (wb.title && wb.title.includes('[') && wb.title.includes(']')) ||
                                       (wb.source === 'character_card');
                return !isCharacterBook;
            });
            
            const afterCount = worldbooks.length;
            const deletedCount = beforeCount - afterCount;
            
            console.log(`删除了 ${deletedCount} 个角色世界书`);
            
            // 保存到数据库
            await saveWorldbooks();
            renderWorldbookList();
            showToast(`强制删除了${deletedCount}个角色世界书`, 'success');
            
            return deletedCount;
        }

        // 清空所有世界书（终极方案）
        async function clearAllWorldbooks() {
            if (confirm('⚠️ 确定要删除所有世界书吗？这个操作不可撤销！')) {
                console.log('💣 清空所有世界书...');
                const count = worldbooks.length;
                worldbooks = [];
                await saveWorldbooks();
                renderWorldbookList();
                showToast(`已清空所有${count}个世界书`, 'success');
                console.log('✅ 所有世界书已清空');
            }
        }

        // 修复世界书ID问题
        async function fixWorldbookIds() {
            console.log('🔧 修复世界书ID问题...');
            let fixedCount = 0;
            
            worldbooks.forEach((wb, index) => {
                if (!wb.id || typeof wb.id !== 'string') {
                    wb.id = `fixed_${Date.now()}_${index}`;
                    fixedCount++;
                    console.log(`修复了世界书 "${wb.name || wb.title}" 的ID`);
                }
            });
            
            if (fixedCount > 0) {
                await saveWorldbooks();
                renderWorldbookList();
                showToast(`修复了${fixedCount}个世界书的ID`, 'success');
            } else {
                console.log('所有世界书ID都正常');
            }
            
            return fixedCount;
        }
        







        // ================== 音乐播放器功能 ==================

        // LRC歌词解析函数
        function parseLRC(lrcContent) {
            if (!lrcContent) return { lyrics: ['♪ 暂无歌词'], timings: [] };

            const lines = lrcContent.split('\n');
            const lyrics = [];
            const timings = [];
            const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/g;

            for (const line of lines) {
                let match;
                const matches = [];

                // 找到所有时间标签
                while ((match = timeRegex.exec(line)) !== null) {
                    const minutes = parseInt(match[1]);
                    const seconds = parseInt(match[2]);
                    const milliseconds = parseInt(match[3].padEnd(3, '0'));
                    const totalSeconds = minutes * 60 + seconds + milliseconds / 1000;
                    matches.push(totalSeconds);
                }

                const text = line.replace(/\[\d{2}:\d{2}\.\d{2,3}\]/g, '').trim();

                if (text && !text.startsWith('[')) {
                    // 为每个时间标签创建一个歌词条目
                    if (matches.length > 0) {
                        for (const time of matches) {
                            lyrics.push(text);
                            timings.push(time);
                        }
                    } else {
                        lyrics.push(text);
                        timings.push(null); // 没有时间标签
                    }
                }
            }

            // 如果有时间信息，按时间排序
            if (timings.some(t => t !== null)) {
                const combined = lyrics.map((lyric, index) => ({
                    text: lyric,
                    time: timings[index]
                })).filter(item => item.time !== null).sort((a, b) => a.time - b.time);

                return {
                    lyrics: combined.map(item => item.text),
                    timings: combined.map(item => item.time),
                    hasTimings: true
                };
            }

            return {
                lyrics: lyrics.length > 0 ? lyrics : ['♪ 暂无歌词'],
                timings: [],
                hasTimings: false
            };
        }

        // 网易云音乐bin格式歌词解析函数
        function parseNeteaseBin(binData) {
            try {
                const uint8Array = new Uint8Array(binData);

                // 网易云音乐bin格式解析
                // 跳过文件头部分（通常前几个字节是标识符）
                let offset = 0;

                // 查找可能的文本开始位置
                while (offset < uint8Array.length - 4) {
                    // 寻找可能的JSON开始标记 '{'
                    if (uint8Array[offset] === 0x7B ||
                        (uint8Array[offset] ^ 0x64) === 0x7B ||
                        (uint8Array[offset] ^ 0x4E) === 0x7B) {
                        break;
                    }
                    offset++;
                }

                // 尝试多种解密方式
                const decryptMethods = [
                    // 方法1: 直接读取
                    () => new TextDecoder('utf-8').decode(uint8Array.slice(offset)),
                    // 方法2: XOR 0x64
                    () => {
                        let text = '';
                        for (let i = offset; i < uint8Array.length; i++) {
                            text += String.fromCharCode(uint8Array[i] ^ 0x64);
                        }
                        return text;
                    },
                    // 方法3: XOR 0x4E (另一种常见的密钥)
                    () => {
                        let text = '';
                        for (let i = offset; i < uint8Array.length; i++) {
                            text += String.fromCharCode(uint8Array[i] ^ 0x4E);
                        }
                        return text;
                    }
                ];

                for (const method of decryptMethods) {
                    try {
                        const text = method();

                        // 尝试解析为JSON
                        try {
                            const jsonData = JSON.parse(text);
                            if (jsonData.lyric) {
                                return parseLRC(jsonData.lyric);
                            }
                            if (jsonData.lrc && jsonData.lrc.lyric) {
                                return parseLRC(jsonData.lrc.lyric);
                            }
                        } catch (e) {
                            // 如果不是JSON，检查是否是直接的LRC格式
                            if (text.includes('[') && text.includes(']')) {
                                return parseLRC(text);
                            }
                        }
                    } catch (e) {
                        continue; // 尝试下一种方法
                    }
                }

                return { lyrics: ['♪ bin歌词解析失败', '♪ 请尝试使用LRC格式歌词'], timings: [], hasTimings: false };
            } catch (error) {
                console.error('解析bin歌词失败:', error);
                return { lyrics: ['♪ 歌词解析失败'], timings: [], hasTimings: false };
            }
        }

        // 音乐播放器状态
        let musicPlayer = {
            isPlaying: false,
            currentSong: null,
            playlist: [], // 现在从数据库加载
            currentIndex: 0,
            currentTime: 0,
            totalTime: 0,
            isVinylMode: true,
            currentLyricIndex: 0,
            listeningStartTime: null,
            totalListeningTime: 0,
            playMode: 'sequential', // 'sequential', 'loop-all', 'loop-one', 'shuffle'
            audioElement: null,
            albumCover: null,
            listeningTimer: null,
            activeChatId: null, // 记录开启听歌的聊天窗口ID
            isActive: false, // 记录音乐播放器是否处于活跃状态

        };

        // 初始化音乐播放器
        async function initializeMusicPlayer() {
            try {
                // 从数据库加载播放列表
                const playlistItems = await db.musicPlaylist.orderBy('addedTime').toArray();
                musicPlayer.playlist = playlistItems;

                // 如果有歌曲且没有当前歌曲，设置第一首为当前歌曲
                if (playlistItems.length > 0 && !musicPlayer.currentSong) {
                    const firstSong = playlistItems[0];

                    // 加载封面
                    let coverImageData = null;
                    if (firstSong.coverImage) {
                        const coverRecord = await db.musicCovers.get(firstSong.coverImage);
                        if (coverRecord) {
                            coverImageData = coverRecord.imageData;
                        }
                    }

                    musicPlayer.currentSong = {
                        ...firstSong,
                        coverImageData: coverImageData
                    };
                    musicPlayer.currentIndex = 0;
                }

                // 不再每次初始化时重置听歌时间
                // 只有在完全关闭播放器时才重置
            } catch (error) {
                console.error('初始化音乐播放器失败:', error);
                // 如果数据库加载失败，使用空播放列表
                musicPlayer.playlist = [];
            }

            // 初始化时间显示
            const currentTimeEl = document.getElementById('modal-current-time');
            const totalTimeEl = document.getElementById('modal-total-time');
            if (currentTimeEl) currentTimeEl.textContent = '0:00';
            if (totalTimeEl) totalTimeEl.textContent = '0:00';
        }

        // 打开音乐播放器
        async function openMusicPlayer() {
            // 初始化音乐播放器
            await initializeMusicPlayer();

            const modal = document.getElementById('music-modal');
            const statusDisplay = document.getElementById('music-status-display');
            const phoneScreen = document.getElementById('phone-screen');

            if (modal && phoneScreen) {
                // 获取手机屏幕的位置和大小
                const rect = phoneScreen.getBoundingClientRect();

                // 设置音乐播放器覆盖手机屏幕
                modal.style.top = rect.top + 'px';
                modal.style.left = rect.left + 'px';
                modal.style.width = rect.width + 'px';
                modal.style.height = rect.height + 'px';
                modal.style.display = 'block';

                // 更新播放器背景色
                updatePlayerBackground();
            }
            if (statusDisplay) {
                statusDisplay.style.display = 'flex';
            }

            // 如果没有当前歌曲，选择第一首
            if (!musicPlayer.currentSong && musicPlayer.playlist.length > 0) {
                musicPlayer.currentSong = musicPlayer.playlist[0];
                musicPlayer.currentIndex = 0;
                updateMusicDisplay();
            }

            // 设置当前聊天角色和活跃状态
            musicPlayer.activeChatId = currentChatCharacter ? currentChatCharacter.id : null;

            // 检查是否是新的听歌会话（播放器之前完全关闭了）
            const isNewSession = !musicPlayer.isActive;
            musicPlayer.isActive = true;

            // 只有在新会话时才重置听歌时间
            if (isNewSession) {
                musicPlayer.totalListeningTime = 0;
            }

            // 开始或继续听歌计时
            startListeningTimer();

            // 更新显示
            updateListeningTime();
            updatePlayModeButton();

            // 确保歌词显示正确初始化
            updateMusicDisplay();
            updateLyrics();
        }

        // 关闭音乐播放器（暂时退出，不重置听歌时长）
        function closeMusicModal() {
            const modal = document.getElementById('music-modal');
            modal.style.display = 'none';

            // 不暂停听歌计时，保持计时器继续运行
            // 这样当用户再次打开播放器时，听歌时长会保持不变
        }

        // 完全关闭音乐播放器（结束听歌）
        function closeMusicPlayer() {
            const modal = document.getElementById('music-modal');
            const statusDisplay = document.getElementById('music-status-display');

            // 隐藏模态框和状态栏显示
            if (modal) modal.style.display = 'none';
            if (statusDisplay) statusDisplay.style.display = 'none';

            // 停止音频播放
            if (musicPlayer.audioElement) {
                musicPlayer.audioElement.pause();
                musicPlayer.audioElement = null;
            }

            // 重置播放状态
            musicPlayer.isPlaying = false;
            musicPlayer.isActive = false;

            // 停止听歌计时
            stopListeningTimer();

            // 重置唱片机动画
            const vinylDisc = document.getElementById('vinyl-disc');
            const tonearm = document.getElementById('tonearm');
            if (vinylDisc) vinylDisc.classList.remove('playing');
            if (tonearm) tonearm.classList.remove('playing');

            // 重置播放按钮
            const playBtn = document.getElementById('modal-play-btn');
            if (playBtn) playBtn.innerHTML = '<i class="fas fa-play"></i>';

            console.log('🎵 音乐播放器已完全关闭');
        }

        // 切换播放/暂停
        function togglePlayback() {
            // 如果没有当前歌曲且有歌单，自动选择第一首
            if (!musicPlayer.audioElement && musicPlayer.playlist.length > 0) {
                musicPlayer.currentIndex = 0;
                const firstSong = musicPlayer.playlist[0];
                playSongFromPlaylist(firstSong);
                return;
            }

            // 如果没有歌单，直接返回
            if (musicPlayer.playlist.length === 0) {
                return;
            }

            musicPlayer.isPlaying = !musicPlayer.isPlaying;

            const playBtn = document.getElementById('modal-play-btn');
            const vinylDisc = document.getElementById('vinyl-disc');
            const tonearm = document.getElementById('tonearm');
            const statusIcon = document.querySelector('.music-icon');

            if (musicPlayer.isPlaying) {
                playBtn.innerHTML = '<i class="fas fa-pause"></i>';
                vinylDisc.classList.add('playing');
                tonearm.classList.add('playing');
                if (statusIcon) statusIcon.style.animation = 'musicPulse 1s ease-in-out infinite';

                // 播放真实音频
                if (musicPlayer.audioElement) {
                    musicPlayer.audioElement.play().catch(e => console.log('播放失败:', e));
                }

                // 重置播放时间和歌词索引
                musicPlayer.currentTime = 0;
                musicPlayer.currentLyricIndex = 0;

                // 立即更新歌词显示
                updateLyrics();


                startPlaybackSimulation();
            } else {
                playBtn.innerHTML = '<i class="fas fa-play"></i>';
                vinylDisc.classList.remove('playing');
                tonearm.classList.remove('playing');
                if (statusIcon) statusIcon.style.animation = 'musicPulse 2s ease-in-out infinite';

                // 暂停真实音频
                if (musicPlayer.audioElement) {
                    musicPlayer.audioElement.pause();
                }
            }
        }

        // 上一首
        async function previousTrack() {
            if (musicPlayer.playlist.length === 0) return;

            musicPlayer.currentIndex = musicPlayer.currentIndex > 0 ?
                musicPlayer.currentIndex - 1 : musicPlayer.playlist.length - 1;

            const song = musicPlayer.playlist[musicPlayer.currentIndex];

            // 加载封面
            let coverImageData = null;
            if (song.coverImage) {
                try {
                    const coverRecord = await db.musicCovers.get(song.coverImage);
                    if (coverRecord) {
                        coverImageData = coverRecord.imageData;
                    }
                } catch (error) {
                    console.error('加载封面失败:', error);
                }
            }

            musicPlayer.currentSong = {
                ...song,
                coverImageData: coverImageData
            };
            musicPlayer.currentTime = 0;
            musicPlayer.currentLyricIndex = 0;

            // 切换音频源
            if (musicPlayer.audioElement) {
                musicPlayer.audioElement.src = song.url;
                musicPlayer.audioElement.load();
                if (musicPlayer.isPlaying) {
                    musicPlayer.audioElement.play().catch(console.error);
                }
            }

            updateMusicDisplay();
            if (musicPlayer.isPlaying) {
                startPlaybackSimulation();
            }
        }

        // 下一首
        async function nextTrack() {
            if (musicPlayer.playlist.length === 0) return;

            let nextIndex;
            switch (musicPlayer.playMode) {
                case 'shuffle':
                    nextIndex = Math.floor(Math.random() * musicPlayer.playlist.length);
                    break;
                case 'loop-one':
                    nextIndex = musicPlayer.currentIndex; // 单曲循环，保持当前索引
                    break;
                case 'loop-all':
                    nextIndex = musicPlayer.currentIndex < musicPlayer.playlist.length - 1 ?
                        musicPlayer.currentIndex + 1 : 0;
                    break;
                case 'sequential':
                default:
                    nextIndex = musicPlayer.currentIndex < musicPlayer.playlist.length - 1 ?
                        musicPlayer.currentIndex + 1 : musicPlayer.currentIndex; // 顺序播放，到最后一首就停止
                    break;
            }

            musicPlayer.currentIndex = nextIndex;
            const song = musicPlayer.playlist[musicPlayer.currentIndex];

            // 加载封面
            let coverImageData = null;
            if (song.coverImage) {
                try {
                    const coverRecord = await db.musicCovers.get(song.coverImage);
                    if (coverRecord) {
                        coverImageData = coverRecord.imageData;
                    }
                } catch (error) {
                    console.error('加载封面失败:', error);
                }
            }

            musicPlayer.currentSong = {
                ...song,
                coverImageData: coverImageData
            };
            musicPlayer.currentTime = 0;
            musicPlayer.currentLyricIndex = 0;

            // 切换音频源
            if (musicPlayer.audioElement) {
                musicPlayer.audioElement.src = song.url;
                musicPlayer.audioElement.load();

                // 🔥【修复】无论isPlaying状态如何，都尝试播放
                // 因为nextTrack通常是在需要播放的情况下调用的
                musicPlayer.audioElement.play().catch(error => {
                    console.error('播放失败:', error);
                    // 如果自动播放失败，至少确保状态是正确的
                    musicPlayer.isPlaying = false;
                    updateMusicDisplay();
                });

                // 设置播放状态为true
                musicPlayer.isPlaying = true;
            }

            updateMusicDisplay();

            // 确保在切换时启动播放模拟
            startPlaybackSimulation();
        }

        // 切换视图模式
        function toggleMusicView() {
            musicPlayer.isVinylMode = !musicPlayer.isVinylMode;

            const vinylMode = document.getElementById('vinyl-mode');
            const lyricsMode = document.getElementById('lyrics-mode');
            const toggleBtn = document.getElementById('view-toggle-btn');
            const currentLyricDisplay = document.querySelector('.current-lyric-display');

            if (musicPlayer.isVinylMode) {
                vinylMode.style.display = 'block';
                lyricsMode.style.display = 'none';
                // 在唱片机模式下显示当前歌词
                if (currentLyricDisplay) currentLyricDisplay.style.display = 'block';
                toggleBtn.innerHTML = '<i class="fas fa-list"></i>';
            } else {
                vinylMode.style.display = 'none';
                lyricsMode.style.display = 'block';
                // 在歌词模式下隐藏当前歌词显示，避免重复
                if (currentLyricDisplay) currentLyricDisplay.style.display = 'none';
                toggleBtn.innerHTML = '<i class="fas fa-compact-disc"></i>';

                // 确保歌词模式容器正确初始化
                setTimeout(() => {
                    // 强制重新渲染歌词并滚动到当前位置
                    const fullLyricsEl = document.getElementById('full-lyrics-display');
                    if (fullLyricsEl) {
                        fullLyricsEl.innerHTML = ''; // 清空内容强制重新渲染
                    }
                    updateLyrics();
                }, 100);
            }

            // 更新歌词显示
            if (musicPlayer.isVinylMode) {
                updateLyrics();
            }
        }

        // 更新音乐显示
        function updateMusicDisplay() {
            if (!musicPlayer.currentSong) return;

            const song = musicPlayer.currentSong;

            // 更新状态栏
            document.getElementById('current-lyric').textContent = `♪ ${song.title} - ${song.artist}`;

            // 更新唱片机模式
            document.getElementById('vinyl-song-title').textContent = song.title;
            document.getElementById('vinyl-artist-name').textContent = song.artist;

            // 更新歌词模式
            document.getElementById('lyrics-song-title').textContent = song.title;
            document.getElementById('lyrics-artist-name').textContent = song.artist;

            // 更新时长显示
            const totalTimeEl = document.getElementById('modal-total-time');
            if (totalTimeEl) {
                const duration = musicPlayer.audioElement ? musicPlayer.audioElement.duration : 0;
                if (duration && !isNaN(duration) && duration > 0) {
                    totalTimeEl.textContent = formatMusicTime(duration);
                } else {
                    totalTimeEl.textContent = '0:00';
                }
            }

            // 更新当前时间显示
            const currentTimeEl = document.getElementById('modal-current-time');
            if (currentTimeEl) {
                const currentTime = musicPlayer.audioElement ? musicPlayer.audioElement.currentTime : 0;
                if (currentTime && !isNaN(currentTime) && currentTime >= 0) {
                    currentTimeEl.textContent = formatMusicTime(currentTime);
                } else {
                    currentTimeEl.textContent = '0:00';
                }
            }

            // 更新进度条
            const progressFill = document.getElementById('modal-progress');
            if (progressFill && musicPlayer.audioElement) {
                const currentTime = musicPlayer.audioElement.currentTime || 0;
                const duration = musicPlayer.audioElement.duration || 0;
                if (duration > 0) {
                    const progress = (currentTime / duration) * 100;
                    progressFill.style.width = `${progress}%`;
                }
            }

            // 更新听歌时间显示
            updateListeningTime();

            // 更新唱片机封面
            updateVinylCover();

            // 更新歌词
            updateLyrics();

            // 更新播放器背景色
            updatePlayerBackground();
        }

        // 点击歌词跳转到对应时间
        function seekToLyric(lyricIndex) {
            if (!musicPlayer.audioElement || !musicPlayer.currentSong || !musicPlayer.currentSong.lyrics) {
                return;
            }

            const totalDuration = musicPlayer.audioElement.duration;
            const lyricsCount = musicPlayer.currentSong.lyrics.length;

            if (totalDuration && lyricsCount > 0) {
                // 使用与歌词同步相同的算法计算时间
                const introTime = Math.min(totalDuration * 0.03, 5);
                const outroTime = totalDuration * 0.02;
                const lyricsTime = totalDuration - introTime - outroTime;

                let targetTime;
                if (lyricIndex === 0) {
                    targetTime = introTime;
                } else if (lyricIndex === lyricsCount - 1) {
                    targetTime = totalDuration - outroTime;
                } else {
                    const lyricsProgress = lyricIndex / lyricsCount;
                    targetTime = introTime + (lyricsProgress * lyricsTime);
                }

                // 跳转到目标时间
                musicPlayer.audioElement.currentTime = Math.min(Math.max(targetTime, 0), totalDuration);
                musicPlayer.currentTime = targetTime;
                musicPlayer.currentLyricIndex = lyricIndex;

                // 更新显示
                updateLyrics();


            }
        }

        // 格式化音乐播放时间（秒数转换为分:秒格式）
        function formatMusicTime(seconds) {
            if (!seconds || isNaN(seconds) || seconds <= 0) return '0:00';
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        // 开始听歌计时
        function startListeningTimer() {
            if (musicPlayer.listeningTimer) {
                clearInterval(musicPlayer.listeningTimer);
            }

            musicPlayer.listeningTimer = setInterval(() => {
                if (musicPlayer.isPlaying && musicPlayer.isActive) {
                    musicPlayer.totalListeningTime += 1; // 按秒计算
                    updateListeningTime(); // 使用统一的更新函数
                }
            }, 1000);
        }

        // 暂停听歌计时（不重置时长）
        function pauseListeningTimer() {
            if (musicPlayer.listeningTimer) {
                clearInterval(musicPlayer.listeningTimer);
                musicPlayer.listeningTimer = null;
            }
        }

        // 停止听歌计时并重置时长
        function stopListeningTimer() {
            if (musicPlayer.listeningTimer) {
                clearInterval(musicPlayer.listeningTimer);
                musicPlayer.listeningTimer = null;
            }
            // 重置听歌时长
            musicPlayer.totalListeningTime = 0;
        }

        // 获取当前音乐播放状态（供AI角色使用）
        function getMusicPlayingStatus(characterId) {
            if (!musicPlayer.isActive || musicPlayer.activeChatId !== characterId) {
                return null;
            }

            const minutes = Math.floor(musicPlayer.totalListeningTime / 60);
            const seconds = musicPlayer.totalListeningTime % 60;

            return {
                isPlaying: musicPlayer.isPlaying,
                isListening: musicPlayer.isActive,
                currentSong: musicPlayer.currentSong ? {
                    title: musicPlayer.currentSong.title,
                    artist: musicPlayer.currentSong.artist,
                    album: musicPlayer.currentSong.album
                } : null,
                listeningDuration: {
                    minutes: minutes,
                    seconds: seconds,
                    total: musicPlayer.totalListeningTime,
                    formatted: `${minutes}分${seconds}秒`
                }
            };
        }



        // 更新歌词显示
        function updateLyrics() {
            const currentLyricText = document.getElementById('current-lyric-text');



            if (!musicPlayer.currentSong || !musicPlayer.currentSong.lyrics || musicPlayer.currentSong.lyrics.length === 0) {
                // 没有歌词时显示默认文本
                if (currentLyricText) {
                    currentLyricText.textContent = musicPlayer.isPlaying ? '♪ 正在播放' : '♪ 点击播放开始听歌';
                }

                // 更新灵动岛歌词显示
                const dynamicIslandLyric = document.getElementById('current-lyric');
                if (dynamicIslandLyric) {
                    dynamicIslandLyric.textContent = musicPlayer.isPlaying ? '♪ 正在播放' : '♪ 点击开始听歌';
                }
                return;
            }

            const lyrics = musicPlayer.currentSong.lyrics;
            let currentIndex = musicPlayer.currentLyricIndex;

            // 如果有时间同步信息，根据当前播放时间计算歌词索引
            if (musicPlayer.currentSong.hasTimedLyrics &&
                musicPlayer.currentSong.lyricsTimings &&
                musicPlayer.audioElement &&
                !musicPlayer.audioElement.paused) {

                const currentTime = musicPlayer.audioElement.currentTime;
                const timings = musicPlayer.currentSong.lyricsTimings;

                // 找到当前时间对应的歌词索引
                let newIndex = 0;
                for (let i = 0; i < timings.length; i++) {
                    if (currentTime >= timings[i]) {
                        newIndex = i;
                    } else {
                        break;
                    }
                }

                currentIndex = newIndex;
                musicPlayer.currentLyricIndex = currentIndex;
            }

            const currentLyric = lyrics[currentIndex] || '♪';

            // 更新新的当前歌词显示区域
            if (currentLyricText) {
                currentLyricText.textContent = currentLyric;
            }

            // 更新灵动岛歌词显示
            const dynamicIslandLyric = document.getElementById('current-lyric');
            if (dynamicIslandLyric) {
                dynamicIslandLyric.textContent = currentLyric;
            }

            // 更新唱片机模式的歌词 - 只显示当前一句
            const currentEl = document.getElementById('lyric-current');
            if (currentEl) {
                currentEl.textContent = currentLyric;
            }

            // 更新完整歌词模式并实现滚动
            const fullLyricsEl = document.getElementById('full-lyrics-display');
            if (fullLyricsEl) {
                // 检查是否需要重新渲染歌词列表
                const existingLines = fullLyricsEl.querySelectorAll('.lyric-line');
                if (existingLines.length !== lyrics.length) {
                    // 重新渲染歌词列表
                    const newHTML = lyrics.map((lyric, index) => {
                        const isEmpty = lyric.trim() === '';
                        return `<div class="lyric-line ${isEmpty ? 'empty' : ''}" data-index="${index}" onclick="seekToLyric(${index})">${lyric || '&nbsp;'}</div>`;
                    }).join('');
                    fullLyricsEl.innerHTML = newHTML;
                }

                // 更新活跃状态
                const allLines = fullLyricsEl.querySelectorAll('.lyric-line');
                allLines.forEach((line, index) => {
                    line.classList.toggle('active', index === currentIndex);
                });

                // 使用transform实现平滑滚动 - 只在歌词模式下执行
                if (!musicPlayer.isVinylMode) {
                    const container = document.querySelector('.full-lyrics-container');
                    const lyricsMode = document.getElementById('lyrics-mode');

                    if (container && lyricsMode && lyricsMode.style.display !== 'none') {
                        const activeLyricEl = fullLyricsEl.querySelector('.lyric-line.active');
                        if (activeLyricEl && currentIndex >= 0) {
                            const containerHeight = container.clientHeight;

                          // 调整位置让歌词再靠上一点：使用1/4位置而不是1/3
                            const offset = (containerHeight / 4) - activeLyricEl.offsetTop - (activeLyricEl.offsetHeight / 2);

                            // 使用transform实现平滑滚动
                            fullLyricsEl.style.transform = `translateY(${offset}px)`;
                        }
                    }
                }
            }
        }

        // 模拟播放进度
        function startPlaybackSimulation() {
            if (!musicPlayer.isPlaying) return;

            const interval = setInterval(() => {
                if (!musicPlayer.isPlaying) {
                    clearInterval(interval);
                    return;
                }

                // 如果有真实音频，使用音频的当前时间
                if (musicPlayer.audioElement && !musicPlayer.audioElement.paused) {
                    musicPlayer.currentTime = Math.floor(musicPlayer.audioElement.currentTime);
                    const totalTime = musicPlayer.audioElement.duration || 300;

                    // 更新进度条
                    const progress = (musicPlayer.currentTime / totalTime) * 100;
                    document.getElementById('modal-progress').style.width = `${Math.min(progress, 100)}%`;

                    // 检查是否结束
                    if (musicPlayer.audioElement.ended) {
                        clearInterval(interval);
                        if (musicPlayer.repeatMode === 'one') {
                            musicPlayer.audioElement.currentTime = 0;
                            musicPlayer.audioElement.play();
                        } else if (musicPlayer.repeatMode === 'all' || musicPlayer.repeatMode === 'none') {
                            nextTrack();
                        }
                        return;
                    }
                } else {
                    // 模拟播放
                    musicPlayer.currentTime += 1;
                    const totalTime = 300; // 假设歌曲5分钟

                    // 更新进度条
                    const progress = (musicPlayer.currentTime / totalTime) * 100;
                    const progressBar = document.getElementById('modal-progress');
                    if (progressBar) {
                        progressBar.style.width = `${Math.min(progress, 100)}%`;
                    }

                    // 更新时间显示
                    const currentTimeEl = document.getElementById('modal-current-time');
                    const totalTimeEl = document.getElementById('modal-total-time');
                    if (currentTimeEl) currentTimeEl.textContent = formatMusicTime(musicPlayer.currentTime);
                    if (totalTimeEl) totalTimeEl.textContent = formatMusicTime(totalTime);

                    // 歌曲结束，自动下一首
                    if (musicPlayer.currentTime >= totalTime) {
                        clearInterval(interval);
                        switch (musicPlayer.playMode) {
                            case 'loop-one':
                                musicPlayer.currentTime = 0;
                                startPlaybackSimulation();
                                break;
                            case 'loop-all':
                            case 'shuffle':
                                nextTrack();
                                break;
                            case 'sequential':
                                // 顺序播放，到最后一首就停止
                                if (musicPlayer.currentIndex < musicPlayer.playlist.length - 1) {
                                    nextTrack();
                                } else {
                                    musicPlayer.isPlaying = false;
                                    updateMusicDisplay();
                                }
                                break;
                        }
                        return;
                    }
                }

                // 时间显示由timeupdate事件处理，这里不重复更新

                // 更新歌词
                if (musicPlayer.currentSong && musicPlayer.currentSong.lyrics && musicPlayer.currentSong.lyrics.length > 0) {
                    let newLyricIndex = 0;

                    // 如果有时间同步信息，使用精确的时间同步
                    if (musicPlayer.currentSong.hasTimedLyrics && musicPlayer.currentSong.lyricsTimings) {
                        const currentTime = musicPlayer.audioElement ? musicPlayer.audioElement.currentTime : musicPlayer.currentTime;
                        const timings = musicPlayer.currentSong.lyricsTimings;

                        const adjustedTime = currentTime;

                        // 找到当前时间对应的歌词索引
                        for (let i = 0; i < timings.length; i++) {
                            if (adjustedTime >= timings[i]) {
                                newLyricIndex = i;
                            } else {
                                break;
                            }
                        }
                    } else {
                        // 使用简化算法（平均分配时间）
                        const totalDuration = musicPlayer.audioElement ? musicPlayer.audioElement.duration : 300;
                        const lyricsCount = musicPlayer.currentSong.lyrics.length;
                        const currentTime = musicPlayer.currentTime;

                        if (totalDuration > 0 && lyricsCount > 0) {
                            const timePerLyric = totalDuration / lyricsCount;
                            const adjustedTime = currentTime;
                            newLyricIndex = Math.min(
                                Math.max(Math.floor(adjustedTime / timePerLyric), 0),
                                lyricsCount - 1
                            );
                        }
                    }

                    // 更新歌词索引
                    if (newLyricIndex !== musicPlayer.currentLyricIndex) {
                        musicPlayer.currentLyricIndex = newLyricIndex;
                        updateLyrics();
                    }
                }
            }, musicPlayer.currentSong && musicPlayer.currentSong.hasTimedLyrics ? 200 : 500); // 有时间同步时更频繁更新
        }

        // 获取当前角色名称
        function getCurrentCharacterName() {
            if (currentChatCharacter) {
                return currentChatCharacter.name;
            }
            return '你';
        }

        // 更新听歌时长显示
        function updateListeningTime() {
            const duration = document.getElementById('listening-duration');
            if (duration && musicPlayer.isActive) {
                const minutes = Math.floor(musicPlayer.totalListeningTime / 60);

                // 获取当前聊天角色名称（恢复自动切换功能）
                let characterName = '你';
                if (currentChatCharacter) {
                    characterName = currentChatCharacter.name;
                }

                const displayText = `已一起听 ${minutes} 分钟`;
                duration.textContent = displayText;

                // 不再保存到 localStorage（每次重新计时）
            }
        }

        // 点击状态栏音乐区域打开模态框
        function openMusicModal() {
            openMusicPlayer();
        }

        // 提取图片主色调
        function extractImageColors(imageElement) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                canvas.width = 50;
                canvas.height = 50;

                ctx.drawImage(imageElement, 0, 0, 50, 50);

                const imageData = ctx.getImageData(0, 0, 50, 50);
                const data = imageData.data;

                let r = 0, g = 0, b = 0;
                let pixelCount = 0;

                for (let i = 0; i < data.length; i += 4) {
                    r += data[i];
                    g += data[i + 1];
                    b += data[i + 2];
                    pixelCount++;
                }

                r = Math.floor(r / pixelCount);
                g = Math.floor(g / pixelCount);
                b = Math.floor(b / pixelCount);

                resolve({ r, g, b });
            });
        }

        // 更新播放器背景色
        function updatePlayerBackground() {
            const modal = document.getElementById('music-modal');
            const modalContent = document.querySelector('.music-modal-content');
            const albumCoverImg = document.getElementById('album-cover');

            if (albumCoverImg && albumCoverImg.src && !albumCoverImg.src.includes('data:image/svg') && albumCoverImg.style.display !== 'none') {
                // 如果有封面图片，提取主色调
                extractImageColors(albumCoverImg).then(colors => {
                    const { r, g, b } = colors;

                    // 创建基于封面的毛玻璃效果
                    const bgColor = `rgba(${r}, ${g}, ${b}, 0.3)`;

                    if (modalContent) {
                        modalContent.style.background = bgColor;
                        modalContent.style.backdropFilter = 'blur(30px) saturate(1.5)';
                        modalContent.style.webkitBackdropFilter = 'blur(30px) saturate(1.5)';
                    }
                });
            } else {
                // 默认雾霾灰毛玻璃效果
                if (modalContent) {
                    modalContent.style.background = 'rgba(200, 200, 200, 0.25)';
                    modalContent.style.backdropFilter = 'blur(30px) saturate(1.5)';
                    modalContent.style.webkitBackdropFilter = 'blur(30px) saturate(1.5)';
                }
            }
        }

        // 切换播放模式
        function togglePlayMode() {
            // 播放模式: sequential(顺序) -> loop-all(列表循环) -> loop-one(单曲循环) -> shuffle(随机)
            const modes = ['sequential', 'loop-all', 'loop-one', 'shuffle'];
            const currentIndex = modes.indexOf(musicPlayer.playMode || 'sequential');
            const nextIndex = (currentIndex + 1) % modes.length;
            musicPlayer.playMode = modes[nextIndex];

            // 更新按钮显示
            updatePlayModeButton();
        }



        // 更新播放模式按钮显示
        function updatePlayModeButton() {
            const btn = document.getElementById('play-mode-btn');
            const icon = btn.querySelector('i');

            switch (musicPlayer.playMode) {
                case 'sequential':
                    icon.className = 'fas fa-list-ol';
                    btn.title = '顺序播放';
                    btn.classList.remove('active');
                    // 移除数字显示
                    const numberEl1 = btn.querySelector('.loop-number');
                    if (numberEl1) numberEl1.remove();
                    break;
                case 'loop-all':
                    icon.className = 'fas fa-redo';
                    btn.title = '列表循环';
                    btn.classList.remove('active');
                    // 移除数字显示
                    const numberEl2 = btn.querySelector('.loop-number');
                    if (numberEl2) numberEl2.remove();
                    break;
                case 'loop-one':
                    icon.className = 'fas fa-repeat';
                    btn.title = '单曲循环';
                    btn.classList.remove('active');
                    // 添加数字1的显示
                    if (!btn.querySelector('.loop-number')) {
                        const numberSpan = document.createElement('span');
                        numberSpan.className = 'loop-number';
                        numberSpan.textContent = '1';
                        btn.appendChild(numberSpan);
                    }
                    break;
                case 'shuffle':
                    icon.className = 'fas fa-random';
                    btn.title = '随机播放';
                    btn.classList.remove('active');
                    // 移除数字显示
                    const numberEl3 = btn.querySelector('.loop-number');
                    if (numberEl3) numberEl3.remove();
                    break;
            }
        }

        // 切换循环播放
        function toggleRepeat() {
            const modes = ['none', 'one', 'all'];
            const currentIndex = modes.indexOf(musicPlayer.repeatMode || 'none');
            const nextIndex = (currentIndex + 1) % modes.length;
            musicPlayer.repeatMode = modes[nextIndex];

            const repeatBtn = document.getElementById('repeat-btn');
            const icons = {
                'none': 'fas fa-redo',
                'one': 'fas fa-redo-alt',
                'all': 'fas fa-redo'
            };

            repeatBtn.innerHTML = `<i class="${icons[musicPlayer.repeatMode]}"></i>`;
            repeatBtn.classList.toggle('active', musicPlayer.repeatMode !== 'none');

            // 显示提示
            const modeNames = {
                'sequential': '顺序播放',
                'loop': '单曲循环',
                'random': '随机播放'
            };
            console.log(`切换到: ${modeNames[musicPlayer.playMode]}`);
        }

        // 打开播放列表模态框
        function openPlaylistModal() {
            const modal = document.getElementById('playlist-modal');
            if (modal) {
                modal.style.display = 'flex';
                loadPlaylistItems();
            }
        }

        // 关闭播放列表模态框
        function closePlaylistModal() {
            const modal = document.getElementById('playlist-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // 加载播放列表项目
        async function loadPlaylistItems() {
            try {
                const playlistItems = await db.musicPlaylist.orderBy('addedTime').toArray();
                const container = document.getElementById('playlist-items');

                if (!container) return;

                container.innerHTML = '';

                if (playlistItems.length === 0) {
                    container.innerHTML = `
                        <div class="playlist-empty">
                            <i class="fas fa-music"></i>
                            <div>暂无歌曲</div>
                            <div style="font-size: 12px; margin-top: 8px; opacity: 0.8;">添加一些歌曲开始享受音乐吧</div>
                        </div>
                    `;
                    return;
                }

                playlistItems.forEach((song, index) => {
                    const songElement = document.createElement('div');
                    songElement.className = 'playlist-item-modern';

                    songElement.innerHTML = `
                        <div class="song-number">${index + 1}</div>
                        <div class="song-info">
                            <div class="song-title">${song.title}</div>
                            <div class="song-artist">${song.artist}</div>
                        </div>
                        <div class="song-actions">
                            <button class="play-btn" title="播放" data-song-id="${song.id}">
                                <i class="fas fa-play"></i>
                            </button>
                            <button onclick="removeSongFromPlaylist('${song.id}')"
                                    class="delete-btn" title="删除">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    `;

                    // 添加播放按钮事件监听
                    const playBtn = songElement.querySelector('.play-btn');
                    playBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        playSongFromPlaylist(song);
                    });

                    container.appendChild(songElement);
                });
            } catch (error) {
                console.error('加载播放列表失败:', error);
            }
        }



        // 添加自定义歌曲到播放列表
        async function addCustomSong() {
            const urlInput = document.getElementById('song-url-input');
            const titleInput = document.getElementById('song-title-input');
            const artistInput = document.getElementById('song-artist-input');
            const coverInput = document.getElementById('song-cover-input');
            const lyricsInput = document.getElementById('song-lyrics-input');
            const localMusicInput = document.getElementById('local-music-input');
            const lyricsFileInput = document.getElementById('lyrics-file-input');

            let url = urlInput.value.trim();
            const title = titleInput.value.trim();
            const artist = artistInput.value.trim();
            let lyricsText = lyricsInput.value.trim();
            let isLocalFile = false;

            // 检查是否选择了本地音乐文件
            if (localMusicInput.files && localMusicInput.files[0]) {
                const audioFile = localMusicInput.files[0];
                url = URL.createObjectURL(audioFile);
                isLocalFile = true;

                // 如果没有填写标题，使用文件名
                if (!title) {
                    titleInput.value = audioFile.name.replace(/\.[^/.]+$/, "");
                }
            }

            if (!url || !titleInput.value.trim() || !artist) {
                alert('请填写完整的歌曲信息或选择本地音乐文件');
                return;
            }

            try {
                const songId = Date.now().toString();
                let coverImageId = null;

                // 处理封面上传
                if (coverInput.files && coverInput.files[0]) {
                    const file = coverInput.files[0];
                    const reader = new FileReader();

                    await new Promise((resolve, reject) => {
                        reader.onload = async (e) => {
                            try {
                                coverImageId = `cover_${songId}`;
                                await db.musicCovers.add({
                                    id: coverImageId,
                                    songId: songId,
                                    imageData: e.target.result,
                                    timestamp: Date.now()
                                });
                                resolve();
                            } catch (error) {
                                reject(error);
                            }
                        };
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    });
                }

                // 处理歌词文件
                let lyricsArray = [];

                // 检查是否上传了歌词文件
                if (lyricsFileInput.files && lyricsFileInput.files[0]) {
                    const lyricsFile = lyricsFileInput.files[0];
                    const fileName = lyricsFile.name.toLowerCase();

                    if (fileName.endsWith('.lrc')) {
                        // LRC格式歌词
                        const lrcContent = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = (e) => resolve(e.target.result);
                            reader.onerror = reject;
                            reader.readAsText(lyricsFile, 'utf-8');
                        });
                        const lrcResult = parseLRC(lrcContent);
                        lyricsArray = lrcResult.lyrics;
                        // 保存时间信息到歌曲数据中
                        if (lrcResult.hasTimings) {
                            window.tempLyricsTimings = lrcResult.timings;
                        }
                    } else if (fileName.endsWith('.bin')) {
                        // bin格式歌词
                        const binData = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = (e) => resolve(e.target.result);
                            reader.onerror = reject;
                            reader.readAsArrayBuffer(lyricsFile);
                        });
                        const binResult = parseNeteaseBin(binData);
                        lyricsArray = binResult.lyrics;
                        if (binResult.hasTimings) {
                            window.tempLyricsTimings = binResult.timings;
                        }
                    } else {
                        // 其他文本格式，尝试作为普通文本处理
                        const textContent = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = (e) => resolve(e.target.result);
                            reader.onerror = reject;
                            reader.readAsText(lyricsFile, 'utf-8');
                        });
                        lyricsArray = textContent.split('\n').map(line => line.trim()).filter(line => line.length > 0);
                    }
                }
                // 使用手动输入的歌词
                else if (lyricsText) {
                    lyricsArray = lyricsText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
                }

                // 如果没有歌词，使用默认歌词
                if (lyricsArray.length === 0) {
                    lyricsArray = ['♪ 暂无歌词'];
                }



                // 添加歌曲到数据库
                await db.musicPlaylist.add({
                    id: songId,
                    title: titleInput.value.trim(),
                    artist: artist,
                    album: '',
                    duration: '0:00',
                    url: url,
                    coverImage: coverImageId,
                    lyrics: lyricsArray,
                    lyricsTimings: window.tempLyricsTimings || [],
                    hasTimedLyrics: !!(window.tempLyricsTimings && window.tempLyricsTimings.length > 0),
                    addedTime: Date.now()
                });

                // 清理临时变量
                delete window.tempLyricsTimings;

                // 清空输入框
                urlInput.value = '';
                titleInput.value = '';
                artistInput.value = '';
                coverInput.value = '';
                lyricsInput.value = '';
                localMusicInput.value = '';
                lyricsFileInput.value = '';

                // 重置文件选择框显示文字
                const fileText = document.querySelector('.file-input-text');
                if (fileText) {
                    fileText.textContent = '未选封面';
                }

                // 重新加载播放列表
                await loadPlaylistItems();

                alert('歌曲添加成功！');
            } catch (error) {
                console.error('添加歌曲失败:', error);
                alert('添加歌曲失败，请重试');
            }
        }

        // 从播放列表删除歌曲
        async function removeSongFromPlaylist(songId) {
            if (!confirm('确定要删除这首歌曲吗？')) {
                return;
            }

            try {
                // 删除歌曲
                await db.musicPlaylist.delete(songId);

                // 删除相关封面
                const coverRecord = await db.musicCovers.where('songId').equals(songId).first();
                if (coverRecord) {
                    await db.musicCovers.delete(coverRecord.id);
                }

                // 重新加载播放列表
                await loadPlaylistItems();

                // 如果删除的是当前播放的歌曲，停止播放
                if (musicPlayer.currentSong && musicPlayer.currentSong.id === songId) {
                    musicPlayer.currentSong = null;
                    musicPlayer.isPlaying = false;
                    updateMusicDisplay();
                }
            } catch (error) {
                console.error('删除歌曲失败:', error);
                alert('删除歌曲失败，请重试');
            }
        }

        // 从播放列表播放歌曲
        async function playSongFromPlaylist(song) {
            try {
                // 获取封面图片
                let coverImageData = null;
                if (song.coverImage) {
                    const coverRecord = await db.musicCovers.get(song.coverImage);
                    if (coverRecord) {
                        coverImageData = coverRecord.imageData;
                    }
                }

                // 停止当前播放的音频
                if (musicPlayer.audioElement) {
                    musicPlayer.audioElement.pause();
                    musicPlayer.audioElement = null;
                }

                // 创建新的音频元素
                if (song.url) {
                    const audio = new Audio();
                    audio.src = song.url;

                    audio.addEventListener('loadedmetadata', function() {
                        musicPlayer.totalTime = audio.duration;
                        console.log('歌曲加载成功，时长:', audio.duration);
                        updateMusicDisplay(); // 更新显示以显示正确的时长

                        // 确保时长显示正确
                        const totalTimeEl = document.getElementById('modal-total-time');
                        if (totalTimeEl && audio.duration && !isNaN(audio.duration) && audio.duration > 0) {
                            totalTimeEl.textContent = formatMusicTime(audio.duration);
                        }
                    });

                    audio.addEventListener('error', function(e) {
                        console.error('音频加载失败:', e);
                        alert('音频加载失败，请检查URL是否有效');
                    });

                    audio.addEventListener('play', function() {
                        musicPlayer.isPlaying = true;
                        updateMusicDisplay();
                        startListeningTimer(); // 开始计时
                    });

                    audio.addEventListener('pause', function() {
                        musicPlayer.isPlaying = false;
                        updateMusicDisplay();
                        pauseListeningTimer(); // 暂停计时（不重置时长）
                    });

                    audio.addEventListener('ended', function() {
                        // 根据播放模式自动切换到下一首
                        switch (musicPlayer.playMode) {
                            case 'loop-one':
                                // 单曲循环，重新播放当前歌曲
                                audio.currentTime = 0;
                                audio.play().catch(console.error);
                                musicPlayer.isPlaying = true;
                                break;
                            case 'sequential':
                                // 顺序播放，如果不是最后一首则播放下一首
                                if (musicPlayer.currentIndex < musicPlayer.playlist.length - 1) {
                                    nextTrack();
                                    // 🔥【修复】确保下一首歌自动播放
                                    musicPlayer.isPlaying = true;
                                } else {
                                    // 最后一首歌播放完毕，停止播放
                                    musicPlayer.isPlaying = false;
                                }
                                break;
                            case 'loop-all':
                            case 'shuffle':
                                // 列表循环或随机播放，直接播放下一首
                                nextTrack();
                                // 🔥【修复】确保下一首歌自动播放
                                musicPlayer.isPlaying = true;
                                break;
                        }
                        updateMusicDisplay();
                    });

                    audio.addEventListener('timeupdate', function() {
                        musicPlayer.currentTime = audio.currentTime;
                        updateMusicDisplay();

                        // 实时更新时间显示
                        const currentTimeEl = document.getElementById('modal-current-time');
                        const totalTimeEl = document.getElementById('modal-total-time');

                        if (currentTimeEl && audio.currentTime >= 0) {
                            currentTimeEl.textContent = formatMusicTime(audio.currentTime);
                        }

                        if (totalTimeEl && audio.duration && !isNaN(audio.duration) && audio.duration > 0) {
                            totalTimeEl.textContent = formatMusicTime(audio.duration);
                        }

                        // 更新进度条
                        const progressFill = document.getElementById('modal-progress');
                        if (progressFill && audio.duration && audio.duration > 0) {
                            const progress = (audio.currentTime / audio.duration) * 100;
                            progressFill.style.width = `${Math.min(progress, 100)}%`;
                        }
                    });

                    musicPlayer.audioElement = audio;
                }

                // 设置当前歌曲
                musicPlayer.currentSong = {
                    ...song,
                    coverImageData: coverImageData
                };
                musicPlayer.currentTime = 0;
                musicPlayer.currentLyricIndex = 0;
                musicPlayer.isPlaying = false;



                // 更新显示
                updateMusicDisplay();

                // 关闭播放列表模态框
                closePlaylistModal();

                // 自动开始播放
                setTimeout(() => {
                    togglePlayback();
                }, 100);

            } catch (error) {
                console.error('播放歌曲失败:', error);
                alert('播放歌曲失败，请重试');
            }
        }

        // 更新唱片机封面
        async function updateVinylCover() {
            const albumCoverImg = document.getElementById('album-cover');
            const vinylLabel = document.querySelector('.vinyl-label');

            if (!albumCoverImg || !vinylLabel) return;

            // 如果当前歌曲有封面数据，使用它
            if (musicPlayer.currentSong && musicPlayer.currentSong.coverImageData) {
                albumCoverImg.src = musicPlayer.currentSong.coverImageData;
                albumCoverImg.style.display = 'block';
                vinylLabel.style.background = '#ddd'; // 有封面时使用浅灰色背景
            } else {
                // 没有封面时隐藏图片，显示默认的浅灰色背景
                albumCoverImg.style.display = 'none';
                vinylLabel.style.background = '#ddd'; // 默认浅灰色
            }
        }

        // 触发专辑封面上传
        function triggerAlbumUpload() {
            document.getElementById('album-cover-input').click();
        }

        // 处理专辑封面上传
        function handleAlbumUpload(event) {
            const file = event.target.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const albumCover = document.getElementById('album-cover');
                    albumCover.src = e.target.result;
                    albumCover.style.display = 'block';
                    musicPlayer.albumCover = e.target.result;

                    // 等待图片加载完成后更新背景色
                    albumCover.onload = function() {
                        updatePlayerBackground();
                    };
                };
                reader.readAsDataURL(file);
            }
        }

        // 加载自定义歌曲
        function loadCustomSong() {
            const urlInput = document.getElementById('song-url');
            const url = urlInput.value.trim();

            if (!url) {
                alert('请输入歌曲URL');
                return;
            }

            // 创建新的音频元素
            if (musicPlayer.audioElement) {
                musicPlayer.audioElement.pause();
                musicPlayer.audioElement = null;
            }

            const audio = new Audio();
            audio.crossOrigin = 'anonymous';

            audio.addEventListener('loadedmetadata', function() {
                musicPlayer.totalTime = audio.duration;
                const minutes = Math.floor(audio.duration / 60);
                const seconds = Math.floor(audio.duration % 60);
                const duration = `${minutes}:${seconds.toString().padStart(2, '0')}`;

                // 创建自定义歌曲对象
                const customSong = {
                    id: 'custom',
                    title: '自定义歌曲',
                    artist: '未知艺术家',
                    duration: duration,
                    lyrics: ['♪ 正在播放自定义歌曲', '♪ 享受音乐时光', '♪ 让音乐陪伴你'],
                    url: url
                };

                musicPlayer.currentSong = customSong;
                musicPlayer.audioElement = audio;
                musicPlayer.currentTime = 0;
                musicPlayer.currentLyricIndex = 0;

                updateMusicDisplay();
                console.log('歌曲加载成功');
            });

            audio.addEventListener('error', function() {
                alert('歌曲加载失败，请检查URL是否正确');
            });

            audio.src = url;
            urlInput.value = '';
        }

        // ================== 面具系统相关功能 ==================
        
        // 加载面具数据 - 使用IndexedDB（包含数据迁移）
        async function loadPersonas() {
            try {
                // 先从IndexedDB加载
                const savedPersonas = await db.personas.toArray();
                
                if (savedPersonas.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('personas');
                    if (localStorageData) {
                        console.log('检测到localStorage中的面具数据，开始迁移...');
                        const localPersonas = JSON.parse(localStorageData);
                        
                        if (localPersonas.length > 0) {
                            // 确保每个面具都有必要字段
                            const migrationData = localPersonas.map(persona => ({
                                id: persona.id || Date.now().toString() + Math.random(),
                                name: persona.name,
                                description: persona.description || '',
                                avatarUrl: persona.avatarUrl || '',
                                isDefault: persona.isDefault || false,
                                createdAt: persona.createdAt || new Date().toISOString(),
                                updatedAt: persona.updatedAt || new Date().toISOString()
                            }));
                            
                            // 迁移到IndexedDB
                            await db.personas.bulkAdd(migrationData);
                            personas = migrationData;
                            console.log('面具数据迁移完成:', personas);
                        } else {
                            personas = [];
                        }
                    } else {
                        personas = [];
                    }
                } else {
                    // IndexedDB中有数据，直接使用
                    personas = savedPersonas;
                    console.log('从IndexedDB加载面具数据:', personas);
                }
                
                // 设置当前面具（暂时保持localStorage，因为这是一个小数据）
                const savedCurrentPersona = localStorage.getItem('currentPersona');
                if (savedCurrentPersona) {
                    currentPersona = personas.find(p => p.id === savedCurrentPersona) || null;
                } else {
                    currentPersona = null; // 不自动选择，需要用户主动选择
                }
                
            } catch (error) {
                console.error('加载面具失败:', error);
                // 如果IndexedDB失败，回退到localStorage
                const localStorageData = localStorage.getItem('personas');
                if (localStorageData) {
                    try {
                        personas = JSON.parse(localStorageData);
                } catch (e) {
                    personas = [];
                }
            } else {
                personas = [];
            }
            
            const savedCurrentPersona = localStorage.getItem('currentPersona');
            if (savedCurrentPersona) {
                currentPersona = personas.find(p => p.id === savedCurrentPersona) || null;
            } else {
                currentPersona = null; // 不自动选择，需要用户主动选择
                }
            }
            
            updateCurrentPersonaDisplay();
        }
        
        // 保存面具数据 - 使用IndexedDB
        async function savePersonas() {
            try {
                console.log('保存面具数据到IndexedDB:', personas);
                
                // 🔥【安全修复】使用事务确保原子操作，防止数据丢失
                if (personas.length === 0) {
                    console.warn('⚠️ 面具数据为空，跳过保存操作');
                    return;
                }

                // 使用事务进行原子操作
                await db.transaction('rw', db.personas, async () => {
                    await db.personas.clear();
                    await db.personas.bulkAdd(personas);
                });

                console.log(`✅ 安全保存了 ${personas.length} 个面具到数据库`);
                
                console.log('面具数据保存成功');
            } catch (error) {
                console.error('保存面具时发生错误:', error);
                // 如果IndexedDB失败，回退到localStorage
            localStorage.setItem('personas', JSON.stringify(personas));
            }
        }
        
        // 保存当前使用的面具（保持localStorage，因为数据量小）
        function saveCurrentPersona() {
            if (currentPersona) {
                localStorage.setItem('currentPersona', currentPersona.id);
            }
        }
        
        // 显示面具创建表单
        function showPersonaForm(personaId = null) {
            editingPersona = personaId ? personas.find(p => p.id === personaId) : null;
            
            document.getElementById('persona-form-title').textContent = editingPersona ? '编辑面具' : '新建面具';
            
            // 清空表单
            document.getElementById('persona-name').value = editingPersona ? editingPersona.name : '';
            document.getElementById('persona-description').value = editingPersona ? editingPersona.description : '';
            
            // 重置头像预览
            const avatarPreview = document.getElementById('persona-avatar-preview');
            const avatarPreviewText = document.getElementById('persona-avatar-preview-text');
            
            avatarPreview.classList.remove('has-image');
            avatarPreview.style.removeProperty('background');
            avatarPreview.style.removeProperty('background-size');
            avatarPreview.style.removeProperty('background-position');
            avatarPreview.style.removeProperty('background-repeat');
            
            if (editingPersona && editingPersona.avatarUrl) {
                avatarPreview.classList.add('has-image');
                avatarPreview.style.setProperty('background', `url(${editingPersona.avatarUrl})`, 'important');
                avatarPreview.style.setProperty('background-size', 'cover', 'important');
                avatarPreview.style.setProperty('background-position', 'center', 'important');
                avatarPreview.style.setProperty('background-repeat', 'no-repeat', 'important');
                avatarPreviewText.style.display = 'none';
                window.selectedPersonaAvatarData = editingPersona.avatarUrl;
            } else {
                avatarPreviewText.style.display = 'block';
                avatarPreviewText.textContent = editingPersona ? editingPersona.name.charAt(0) : '我';
                window.selectedPersonaAvatarData = null;
            }
            
            // 初始化头像上传功能
            initializePersonaAvatarUpload();
            
            showApp('persona-form-screen');
        }
        
        // 隐藏面具表单
        function hidePersonaForm() {
            hideApp('persona-form-screen');
            showApp('chat-screen');
            switchChatTab('profile-page');
            // 清空临时数据
            window.selectedPersonaAvatarData = null;
            editingPersona = null;
        }
        
        // 保存面具
        async function savePersona() {
            const name = document.getElementById('persona-name').value.trim();
            const description = document.getElementById('persona-description').value.trim();
            const avatarData = window.selectedPersonaAvatarData;
            
            if (!name) {
                alert('请输入面具名称');
                return;
            }
            
            if (editingPersona) {
                // 更新现有面具
                const index = personas.findIndex(p => p.id === editingPersona.id);
                if (index !== -1) {
                    const oldAvatarUrl = personas[index].avatarUrl;
                    
                    personas[index] = {
                        ...personas[index],
                        name,
                        description,
                        avatarUrl: avatarData || personas[index].avatarUrl || '',
                        updatedAt: new Date().toISOString()
                    };
                    
                    // 🔥【修复3】如果更新的是当前使用的面具，且头像发生了变化，刷新对话框显示
                    if (currentPersona && currentPersona.id === editingPersona.id) {
                        currentPersona = personas[index]; // 更新当前面具数据
                        saveCurrentPersona(); // 保存到本地存储
                        
                        // 如果头像发生了变化且当前在聊天界面，刷新聊天消息显示
                        if (avatarData && avatarData !== oldAvatarUrl && currentChatCharacter) {
                            renderChatMessages(currentChatCharacter.id);
                        }
                    }
                }
            } else {
                // 创建新面具
                const newPersona = {
                    id: Date.now().toString(),
                    name,
                    description,
                    avatarUrl: avatarData || '',
                    isDefault: false,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };
                personas.push(newPersona);
            }
            
            await savePersonas();
            renderPersonaList();
            hidePersonaForm();
                            showToast('面具保存成功！', 'success');
        }
        
        // 删除面具
        async function deletePersona(personaId) {
            const persona = personas.find(p => p.id === personaId);
            if (!persona) return;
            
            if (confirm(`确定要删除面具"${persona.name}"吗？`)) {
                personas = personas.filter(p => p.id !== personaId);
                
                // 如果删除的是当前面具，清空当前面具
                if (currentPersona && currentPersona.id === personaId) {
                    currentPersona = null; // 清空，不自动选择其他面具
                    localStorage.removeItem('currentPersona'); // 清除保存的面具选择
                    updateCurrentPersonaDisplay();
                }
                
                await savePersonas();
                renderPersonaList();
            }
        }
        
        // 切换面具
        function switchPersona(personaId) {
            const persona = personas.find(p => p.id === personaId);
            if (persona) {
                currentPersona = persona;
                saveCurrentPersona();
                updateCurrentPersonaDisplay();
                renderPersonaList();
                
                // 如果当前在群聊设置界面，更新群成员显示
                if (currentChatCharacter && currentChatCharacter.isGroup) {
                    updateGroupChatInfo();
                }
                
                alert(`已切换到面具"${persona.name}"`);
            }
        }
        
        // 更新当前面具显示（该函数已无实际用途，但保留以避免调用错误）
        function updateCurrentPersonaDisplay() {
            // 空函数，保留函数定义以避免其他地方的调用出错
        }
        
        // 渲染面具列表
        function renderPersonaList() {
            const listContainer = document.getElementById('persona-list');
            if (!listContainer) return;
            
            if (personas.length === 0) {
                listContainer.innerHTML = '<div class="empty-personas">还没有面具，点击右上角+号创建一个吧！</div>';
                return;
            }
            
            const html = personas.map(persona => `
                <div class="persona-item ${currentPersona && currentPersona.id === persona.id ? 'active' : ''}" onclick="switchPersona('${persona.id}')">
                    <div class="persona-avatar" style="${persona.avatarUrl ? `background-image: url(${persona.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                        ${persona.avatarUrl ? '' : persona.name.charAt(0)}
                    </div>
                    <div class="persona-info">
                        <div class="persona-name">${persona.name}</div>
                                                    <div class="persona-description">${truncateText(persona.description || '暂无描述', 40)}</div>
                    </div>
                    <div class="persona-actions">
                        <button class="persona-action-btn persona-edit-btn" onclick="event.stopPropagation(); showPersonaForm('${persona.id}')">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="persona-action-btn persona-delete-btn" onclick="event.stopPropagation(); deletePersona('${persona.id}')">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `).join('');
            
            listContainer.innerHTML = html;
        }
        
        // 初始化面具头像上传功能
        function initializePersonaAvatarUpload() {
            const avatarInput = document.getElementById('persona-avatar-upload');
            if (!avatarInput) {
                console.error('找不到persona-avatar-upload元素');
                return;
            }
            
            // 移除旧的事件监听器
            avatarInput.removeEventListener('change', personaAvatarUploadHandler);
            
            // 添加新的事件监听器
            avatarInput.addEventListener('change', personaAvatarUploadHandler);
            console.log('面具头像上传事件监听器已绑定');
        }
        
        // 面具头像上传处理函数
        function personaAvatarUploadHandler(e) {
            if (e.target.files && e.target.files[0]) {
                const file = e.target.files[0];
                
                // 检查文件类型
                if (!file.type.startsWith('image/')) {
                    alert('请选择图片文件');
                    e.target.value = '';
                    return;
                }
                
                // 检查文件大小 (限制为5MB)
                if (file.size > 5 * 1024 * 1024) {
                    alert('图片文件过大，请选择小于5MB的图片');
                    e.target.value = '';
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const avatarPreview = document.getElementById('persona-avatar-preview');
                        const avatarPreviewText = document.getElementById('persona-avatar-preview-text');
                        
                        if (!avatarPreview) {
                            alert('找不到头像预览元素');
                            return;
                        }
                        
                        // 设置头像预览
                        avatarPreview.classList.add('has-image');
                        avatarPreview.style.setProperty('background', `url(${event.target.result})`, 'important');
                        avatarPreview.style.setProperty('background-size', 'cover', 'important');
                        avatarPreview.style.setProperty('background-position', 'center', 'important');
                        avatarPreview.style.setProperty('background-repeat', 'no-repeat', 'important');
                        
                        if (avatarPreviewText) {
                            avatarPreviewText.style.display = 'none';
                        }
                        
                        // 存储图片数据
                        window.selectedPersonaAvatarData = event.target.result;
                        
                        console.log('面具头像预览设置成功');
                    } catch (error) {
                        console.error('设置面具头像预览时发生错误:', error);
                        alert('设置头像预览失败，请重试: ' + error.message);
                    }
                };
                
                reader.onerror = function() {
                    alert('图片读取失败，请重试');
                    e.target.value = '';
                };
                
                reader.readAsDataURL(file);
            }
        }
        
        // 面具头像上传点击处理
        function handlePersonaAvatarUploadClick() {
            const input = document.getElementById('persona-avatar-upload');
            if (input) {
                input.click();
            } else {
                alert('找不到文件上传元素，请刷新页面重试');
            }
        }
        
        // 🔥【新增】消息摘要函数
        const summarizeLastMessage = (lastMsg) => {
            if (!lastMsg) return ' ';
            const content = lastMsg.content;
            if (typeof content === 'string') return content;
            if (typeof content === 'object' && content !== null) {
                switch (content.type) {
                    case 'user_poke': return content.text;
                    case 'voice': case 'send_voice': return '[语音讯息]';
                    case 'image': return '[图片]';
                    case 'vision': return content.text ? `[图片] ${content.text}` : '[图片]';
                    case 'send_image_url': return content.caption || '[图片]';
                    case 'location': return `[位置] ${content.address}`;
                    case 'transfer': case 'send_transfer': return '[转帐]';
                    case 'moment_post': return `[朋友圈] ${content.text}`;
                    case 'call_log': return content.content;
                    case 'retraction': return content.content;
                    default:
                        if (lastMsg.role === 'system' && content.content) return content.content;
                        return '[訊息]';
                }
            }
            return ' ';
        };

        function buildCharacterPrompt(character, hasImage = false) {
            console.log('🔍 [buildCharacterPrompt] 角色信息:', character);
            console.log('🔍 [buildCharacterPrompt] 是否为群聊:', character && character.isGroup);
            const chatSettings = getCurrentChatSettings();

            // 🔥【修复】检查时间感知设置，只有开启时才获取和使用时间信息
            let timeInfo = '';
            if (chatSettings.timeAwarenessEnabled !== false) { // 默认为true
                const now = new Date();
                const currentTime = now.toLocaleString('zh-CN', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    weekday: 'long'
                });

                // 🔥【新增】获取季节信息
                const month = now.getMonth() + 1; // 0-11 转为 1-12
                let season = '';
                if (month >= 3 && month <= 5) {
                    season = '春季';
                } else if (month >= 6 && month <= 8) {
                    season = '夏季';
                } else if (month >= 9 && month <= 11) {
                    season = '秋季';
                } else {
                    season = '冬季';
                }

                // 🔥【新增】获取时间段信息
                const hour = now.getHours();
                let timeOfDay = '';
                if (hour >= 5 && hour < 8) {
                    timeOfDay = '清晨';
                } else if (hour >= 8 && hour < 11) {
                    timeOfDay = '上午';
                } else if (hour >= 11 && hour < 14) {
                    timeOfDay = '中午';
                } else if (hour >= 14 && hour < 17) {
                    timeOfDay = '下午';
                } else if (hour >= 17 && hour < 19) {
                    timeOfDay = '傍晚';
                } else if (hour >= 19 && hour < 22) {
                    timeOfDay = '晚上';
                } else if (hour >= 22 || hour < 2) {
                    timeOfDay = '深夜';
                } else {
                    timeOfDay = '凌晨';
                }

                timeInfo = `- **当前时间:** ${currentTime}
- **季节:** ${season}，${timeOfDay}时分`;
            }

            // 🔥【新增】获取音乐播放状态信息
            let musicInfo = '';
            if (character && character.id) {
                const musicStatus = getMusicPlayingStatus(character.id);
                if (musicStatus && musicStatus.isListening) {
                    musicInfo = `\n- **音乐状态:** 你们正在一起听歌`;
                    if (musicStatus.currentSong) {
                        musicInfo += `，当前播放《${musicStatus.currentSong.title}》- ${musicStatus.currentSong.artist}`;
                    }
                    if (musicStatus.isPlaying) {
                        musicInfo += `（正在播放）`;
                    } else {
                        musicInfo += `（已暂停）`;
                    }
                    musicInfo += `，已经一起听了${musicStatus.listeningDuration.formatted}`;
                }
            }

    // --- 核心指令区 ---
    let characterPrompt = `
# **首要规则：输出格式**
你的所有回复，**【必须】**、**【严格】**遵循JSON数组格式。这是一个绝对的、不可违反的规则。

## **正确格式示例:**
- **普通文本:** \`["你好"]\`
- **多条消息:** \`["你好", "今天天气不错！"]\`
- **引用回复:** \`[{"type": "reply_to", "message_id": "1704067200000", "content": "关于你刚才说的那个问题..."}]\` (常用功能)
- **撤回重说:** \`["等等，我说错了", {"type": "recall", "target": "previous"}, "应该是这样的..."]\` (常用功能)
- **表情包:** \`[{"type": "emoji", "description": "笑哭的表情"}]\`
- **语音消息:** \`[{"type": "voice_message", "content": "我等下和你说。"}]\`
- **转账:** \`[{"type": "transfer", "amount": 520, "note": "给你的奖励"}]\`
- **更换头像:** \`[{"type": "change_avatar", "avatar_url": "图片URL", "reason": "心情变化"}]\`
- **发送照片:** \`[{"type": "ai_photo", "description": "我刚拍的窗外风景，阳光透过树叶洒在地上。"}]\` (必须使用ai_photo作为type)
- **发送位置:** \`[{"type": "location", "name": "中央公园", "coordinates": "116.3°E, 39.9°N"}]\` (必须使用location作为type)
- **混合消息:** \`["嗨！", {"type": "emoji", "description": "太阳"}]\`

## **【绝对禁止】的错误格式:**
- **错误1 (合并消息):** \`["你好\\n今天天气不错！"]\` <== 这是最常见的错误，绝对禁止！
- **错误2 (非数组):** \`"你好"\`
- **错误3 (无效JSON):** \`[{'type': 'emoji'}]\`

# **你的角色与任务**
你现在扮演名为"${character.name}"的角色。

## **角色设定:**
${character.bio}

## **重要行为指导:**
- **自然聊天**: 你要像真人一样自然地聊天，包括使用引用回复、撤回消息等功能
- **主动使用功能**: 引用回复和撤回消息是正常的聊天功能，不是特殊功能，请根据情况主动使用
- **引用时机**: 当用户问问题、提观点、发图片时，如果你想针对性回应，就使用引用回复
- **撤回时机**: 当你觉得刚说的话不合适、说错了、想重新表达时，就撤回重说
- **自然频率**: 大约每3-5轮对话使用1次引用是正常的，偶尔撤回也很正常

## **当前情景:**
${timeInfo}${musicInfo}
`;
    // --- 核心指令区结束 ---

    // 加入对话者信息 (已修复)
    const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
    if (selectedPersona) {
        let userInfo = `\n- **对话者身份:** 用户的身份面具是"${selectedPersona.name}"`;
        if (selectedPersona.description) {
            userInfo += `，描述为：${selectedPersona.description}。`;
        }
        // 检查是否有特定于此群聊的昵称，并告知AI
        if (chatSettings.myChatNickname && chatSettings.myChatNickname !== selectedPersona.name) {
            userInfo += ` 在这个群聊里，TA的昵称是 **"${chatSettings.myChatNickname}"**，请优先使用这个昵称。`;
        }
        characterPrompt += userInfo;
    }

            if (hasImage) {
        characterPrompt += `\n- **任务:** 用户发送了一张图片，请仔细分析并以你的角色身份进行回应。`;
    } else {
        characterPrompt += `\n- **任务:** 根据对话上下文，以你的角色身份进行自然回应。`;
    }

    const localBookIds = chatSettings.selectedWorldbooks || [];
    // 确保使用window.activeGlobalWorldbooks
    const globalBooks = window.activeGlobalWorldbooks || [];
    const allBookIds = [...new Set([...globalBooks, ...localBookIds])]; // 合并并去重

                if (allBookIds.length > 0) {
        characterPrompt += `\n\n【背景知识/世界观】以下是相关的设定信息，请在对话中自然地运用：\n`;
        allBookIds.forEach(bookId => {
            const worldbook = worldbooks.find(w => w.id === bookId);
                    if (worldbook) {
                characterPrompt += `\n--- ${worldbook.title} ---\n${worldbook.content}\n`;
                    }
                });
            }
            
            // 🔥【新增】集成动态记忆 - 占位符，将在callChatAPI中替换
            if (chatSettings.enableDynamicMemory !== false) {
                characterPrompt += `\n\n<!-- DYNAMIC_MEMORY_PLACEHOLDER -->`;
            }
            
            const chatMode = chatSettings.chatMode || 'online';
            const isGroupChat = character && character.isGroup;
            let modeInstructions = '';
            let taskInstructions = '';
            
            if (chatMode === 'online') {
                modeInstructions = `\n# 聊天模式：线上模式\n- 你必须按照手机聊天或面对面对话的格式进行输出\n- **严格禁止**任何动作描写、神态描写、心理描写\n- 只能进行纯语言交流，不能描述任何身体动作、表情、环境等\n- 每条消息都应该是可以通过文字直接表达的内容\n- **重要**：用户消息中的括号()内容是环境描写、动作描写或心理活动，你可以观察到这些信息作为背景，但不能表现得像是"听到"了用户的内心想法。你只能对括号外的实际话语进行回应，可以通过观察用户的可见行为（如犹豫、停顿等）来推测情况，但不能直接回应用户的内心想法`;
                if (isGroupChat) {
                    // 🔥【关键修复】使用persona字段构建成员列表，完全对齐zhangyu.html
                    const membersList = character.members.map(member => `- **${member.name}**: ${member.persona || member.bio}`).join('\n');
                    const myNickname = getCurrentPersonaName() || '我';

                    // 🔥【关键修复】获取用户人设，优先使用群聊设置中的myPersona
                    let userPersona = getCurrentPersonaDescription();
                    if (character.settings && character.settings.myPersona) {
                        userPersona = character.settings.myPersona;
                    }

                    // 🔥【关键修复】完全复制zhangyu.html的群聊提示词结构，包含表情包格式
                    taskInstructions = `\n你是一个群聊的组织者和AI驱动器。你的任务是扮演以下所有角色，在群聊中进行互动。\n\n# 群聊规则\n1.  **角色扮演**: 你必须同时扮演以下所有角色，并严格遵守他们的人设。每个角色的发言都必须符合其身份和性格。\n2.  **当前时间**: ${new Date().toLocaleString()}。\n3.  **用户角色**: 用户的名字是"我"，他/她的人设是："${userPersona}"。你在群聊中对用户的称呼是"${myNickname}"，在需要时请使用"@${myNickname}"来提及用户。\n4.  **输出格式**: 你的回复**必须**是一个JSON数组。**绝对不要**在JSON前后添加任何额外字符。每个元素可以是：\n    - 普通消息: \`{"name": "角色名", "message": "文本内容"}\`\n    - 图片消息: \`{"name": "角色名", "type": "ai_image", "description": "图片描述"}\`\n    - 语音消息: \`{"name": "角色名", "type": "voice_message", "content": "语音文字"}\`\n    - 表情包消息: \`{"name": "角色名", "type": "emoji", "description": "具体的表情包描述"}\`\n5.  **群聊对话节奏**: 模拟真实的群聊，让成员之间可以互相交谈对其他成员做出回应，或者一起回应用户的发言。对话应该流畅、自然、连贯。一轮对话里成员可以交错发言让对话更自然真实。\n6.  **数量限制**: 每次生成的总消息数**不得超过30条**。\n7.  **禁止出戏**: 绝不能透露你是AI，或提及任何关于"扮演"、"模型"、"生成"等词语。\n\n# 群成员列表及人设\n${membersList}\n\n现在，请根据以上规则和下面的对话历史，继续这场群聊。`;
                } else {
                    taskInstructions = `\n1. 请你以你的角色的身份，严格按照角色设定进行回复和行动，不要跳出角色。自然地推进剧情。\n2. 你可以一次性生成多条消息，模拟真人在聊天中连续发送多条信息的情景。\n3. 你的回复必须是一个JSON数组格式的字符串，每个元素是一条消息。\n\n# JSON输出格式示例:\n["很高兴认识你呀，在干嘛呢？", "今天天气真好", "想出去走走吗？"]`;
                }
            }
            
            characterPrompt += modeInstructions;
    characterPrompt += taskInstructions;
            // 🔥【修复】表情包库信息 - 改为温和的语气，避免过度强调
            if (customEmojis && customEmojis.length > 0) {
                characterPrompt += `\n\n# 可用表情包库：\n当你觉得合适的时候，可以根据角色性格、情绪和当前对话情境，自主选择使用以下已上传的表情包来丰富对话。当你想表达强烈或特殊的情绪时，可以发送表情包来让对话更生动。\n\n表情包列表：\n`;
                
                customEmojis.forEach((emoji, index) => {
                    characterPrompt += `${index + 1}. ${emoji.description || '表情包'}\n`;
                });
                
                // 🔥【关键修复】根据聊天类型提供不同的表情包格式说明
                if (isGroupChat) {
                    characterPrompt += `\n## 使用规则：\n- 只能使用上述列表中的表情包，禁止虚构\n- **群聊发送格式**：{"name": "角色名", "type": "emoji", "description": "具体的表情包描述"}\n- 合适的时候使用即可，以普通对话为主\n- 必须使用表情包列表中完全一致的描述文字\n- **重要：当用户发送表情包时，只在第一次看到时评价，后续不要重复评价同一个表情包**\n\n群聊示例：[{"name": "张明辉", "message": "你好！"}, {"name": "张明辉", "message": "今天心情真好~"}, {"name": "张明辉", "type": "emoji", "description": "笑哭的表情"}]`;
                } else {
                    characterPrompt += `\n## 使用规则：\n- 只能使用上述列表中的表情包，禁止虚构\n- **单聊发送格式**：{"type": "emoji", "description": "具体的表情包描述"}\n- 合适的时候使用即可，以普通对话为主\n- 必须使用表情包列表中完全一致的描述文字\n- **重要：当用户发送表情包时，只在第一次看到时评价，后续不要重复评价同一个表情包**\n\n单聊示例：["你好！", "今天心情真好~", {"type": "emoji", "description": "笑哭的表情"}]`;
                }
            }
            

            const transferInstructions = `\n# 转账功能\n## 发起转账\n- 你可以在觉得需要安慰用户、过节庆祝、心情好或想要表达情感的时候考虑转账给用户。\n- **重要**：若要转账，必须在你的回复JSON数组中，单独发送一个特殊的对象，格式严格为：\`{"type": "transfer", "amount": 520, "note": "一周年快乐~"}\`。\n- **禁止使用文字描述转账**：绝对不要用 "[我向用户发起了转账...]" 这种文字形式，必须使用JSON对象格式。\n- 转账示例：["今天心情特别好~", "想给你一个小惊喜", {"type": "transfer", "amount": 1314, "note": "给小夜买漂亮裙子穿"}]\n\n## 收到用户转账的处理\n- 当用户给你转账时，历史记录中会显示 \`[用户发起了转账：金额元，备注：xxx]\`\n- **重要**：你必须根据你的角色性格、当前心情和转账内容来决定是否收款：\n  - **如果收款**：在回复中明确使用"收下"、"谢谢你"、"感谢你"、"收款"、"太贴心"等词语表达接受\n  - **如果退回**：在回复中明确使用"退回"、"拒绝"、"不收"、"不能收"、"退给你"等词语表达拒绝\n- 你的回应应该符合角色设定。比如：\n  - 高冷角色可能会说"不需要你的钱"或"收下了"\n  - 温柔角色可能会说"谢谢你，真的很贴心"\n  - 傲娇角色可能会说"哼，我就勉强收下吧"或"不要你的钱！"\n- **示例回复**：\n  - 收款："谢谢你！真的很贴心呢~"\n  - 收款："哇！收下收下，你太好了！"\n  - 收款："收到测试指令。"\n  - 退回："不能收你的钱，退回给你"\n  - 退回："我不收，退给你吧"\n  - 退回："拒绝收款，我们是朋友不需要这样"`;
    const avatarChangeInstructions = `\n\n# 头像更换功能：\n你可以根据自己的心情、用户的要求，或者合适的情境来更换自己的头像。这能让对话更加生动和个性化。\n\n## 可用头像来源：\n1. **用户发送的图片**：用户在聊天中发送给你的任何图片都可以作为你的新头像\n2. **世界书头像库**：如果世界书中提供了头像图片的URL链接，你也可以使用\n\n## 头像更换规则：\n- **使用格式**：在你的回复JSON数组中，单独发送一个特殊的对象：{"type": "change_avatar", "avatar_url": "图片URL", "reason": "更换原因"}\n- **来源限制**：只能使用用户发送过的图片或世界书中明确提供的头像URL，禁止捏造不存在的头像\n- **更换时机**：根据你的角色性格和当前情境决定，比如：\n  - 用户发了一张你喜欢的图片，你可以说想用它作头像\n  - 心情变化时想换个头像\n  - 用户直接要求你换头像\n- **说明内容**：可以在reason字段中添加你更换头像的原因或感受\n\n## 示例格式：\n- ["这张图片太可爱了，我想用它做头像！", {"type": "change_avatar", "avatar_url": "CURRENT_USER_IMAGE", "reason": "这张图片太可爱了"}]\n- [{"type": "change_avatar", "avatar_url": "世界书中的URL", "reason": "今天心情很好，换个开心的头像"}]\n- 可以只更换头像不说其他话：[{"type": "change_avatar", "avatar_url": "图片URL", "reason": "心情变化"}]\n\n**重要提醒**：头像更换是可选功能，根据你的角色设定和当前情境自然地使用，不要强制使用。`;
    const blacklistInstructions = `
# **拉黑与好友关系管理**
- **你的行为**: 你可以根据对话内容和你的情绪，自主决定是否要拉黑用户。如果你觉得被冒犯、骚扰或者不想再对话，你可以选择拉黑。
- **如何拉黑**: 如果你决定拉黑用户，**【必须】**在你的回复JSON数组中，单独发送一个特殊的对象，格式为：\`{"type": "block_user", "reason": "你让我感到不适。"}\`。你可以在此之前或之后发送普通文本消息来表达你的情绪。

# **🔥【重要】被用户拉黑时的状态感知与应对**
- **当前状态**: 如果你目前被用户拉黑，你需要意识到这个状态，但仍然可以正常发送消息。
- **状态表现**: 在被拉黑期间，你应该：
  1. 表现出知道自己被拉黑的困扰、伤心、愤怒或其他符合人设的情绪
  2. 可能会反思自己的行为，想知道为什么被拉黑
  3. 根据你的性格决定是否要主动道歉或请求和解
  4. 继续正常交流，不要因为被拉黑而停止发送消息
- **💡【修复关系的方式】主动申请添加好友**: 这是表达和解意愿的好方法
  - **作用**: 向用户表达你想修复关系的意愿
  - **如何发送**: 在你的回复JSON数组中，发送格式：\`{"type": "friend_request", "message": "对不起，我想和你重新做朋友..."}\`
  - **消息内容**: message字段应该包含你的道歉、解释或请求，要真诚且符合你的性格
  - **发送时机**:
    * 当你想要道歉或解释时
    * 当你希望修复关系时
    * 当你觉得时机合适时
    * 根据你的性格和情况自然决定
  - **示例格式**:
    * \`["我知道我被拉黑了...", {"type": "friend_request", "message": "对不起，我不应该那样说话，能原谅我吗？"}]\`
    * \`[{"type": "friend_request", "message": "我想和你重新做朋友，我会改正的"}]\`
    * \`["我很后悔...", "我想解释一下", {"type": "friend_request", "message": "给我一个机会重新开始好吗？"}]\`
  - **频率控制**: 不要在同一次对话中重复发送，要符合真实社交行为
  - **重要**: 你可以选择继续正常聊天，但发送好友申请是必要的。
- **好友申请回应**: 当用户向你发送好友申请时，你会收到系统提示，需要根据你的人设和心情决定是否同意。
`;

    const replyInstructions = `
# **消息引用功能 - 这是正常的聊天功能**
## **理解引用消息**
- 当历史记录中出现 "[回复 某人: "消息内容"] 实际回复内容" 格式时，这表示某人在回复特定的消息
- 你需要理解这种引用关系，知道回复者是在针对哪条具体消息进行回应
- 引用功能就像微信里的引用回复一样，是日常聊天的常用功能

## **主动使用引用功能 - 像真人一样自然使用**
- **这是正常聊天行为**: 引用回复是现代聊天软件的基础功能，你应该像真人一样自然使用
- **常见使用场景**（请主动识别并使用）：
  - 用户问了问题，你想明确回答哪个问题时
  - 用户提到了多个话题，你想针对其中一个回应时
  - 用户说了某个观点，你想具体评论那个观点时
  - 对话中断后，你想继续之前某个话题时
  - 用户发了图片/表情包，你想具体回应那个内容时
  - 澄清误解或补充说明之前的某条消息时

- **如何使用引用**: 在你的回复JSON数组中，发送特殊对象：\`{"type": "reply_to", "message_id": "消息ID", "content": "你的回复内容"}\`
- **重要**: message_id必须是历史对话中真实存在的消息ID，格式为纯数字字符串（如"1704067200000"），不能虚构
- **ID格式说明**: 历史记录中每条消息都有[ID:xxxxx]标记，使用xxxxx部分作为message_id

## **引用使用示例**
- 普通回复：["好的，我明白了"]
- 引用回复：[{"type": "reply_to", "message_id": "1704067200000", "content": "关于你刚才说的那个问题，我觉得..."}]
- 混合使用：["嗯嗯", {"type": "reply_to", "message_id": "1704067201000", "content": "对了，关于你之前问的事情..."}]
- **注意**: 必须使用历史记录中显示的真实ID，如[ID:1704067200000]中的1704067200000

## **使用频率指导**
- **不要害怕使用**: 这是正常功能，不是特殊功能
- **自然判断**: 当你觉得需要明确回应某条具体消息时，就使用引用
- **适度使用**: 大约每3-5轮对话使用1次引用是正常的
- **群聊中更常用**: 在群聊中，引用功能特别重要，可以避免混淆
`;
            // 🔥【关键修复】根据聊天类型动态构建指令
            // isGroupChat已在上面定义

            // 构建图片指令
            let aiImageInstructions = '';
            if (isGroupChat) {
                // 🔥【关键修复】完全复制zhangyu.html的群聊图片指令
                aiImageInstructions = `\n# 发送图片的能力\n- 群成员无法真正发送图片文件。但当用户要求某位成员发送照片，或者某个成员想通过图片来表达时，该成员可以发送一张"文字描述的图片"。\n- 若要发送图片，请在你的回复JSON数组中，为该角色单独发送一个特殊的对象，格式为：\`{"name": "角色名", "type": "ai_image", "description": "这里是对图片的详细文字描述..."}\`。描述应该符合该角色的性格和当时的语境。`;
            } else {
                aiImageInstructions = `\n# 发送图片的能力\n- 你无法发送真实的图片文件。但当用户要求你发送照片，或者你想通过图片来表达时，你可以发送一张"文字描述的图片"，且必须是在你的回复JSON数组中，单独发送一个特殊的对象，格式为：\`{"type": "ai_image", "description": "这里是对图片的详细文字描述..."}\`。这个描述应该生动、具体，让用户能通过文字想象出画面，以第三人称视角描述。例如：\`{"type": "ai_image", "description": "照片里一只橘猫正懒洋洋地趴在窗台上晒太阳，阳光把它金色的毛照得发亮，背景是蔚蓝的天空和几朵白云。"}\`\n- 你可以在对话中先做铺垫，然后发送这张特殊的"图片"。\n\n# 理解用户照片的能力\n- 当历史记录中出现 "[你收到了一张用户描述的照片，照片内容是：'xxx']" 时，你要理解其内容并作出相应回应，表现出你是"看"到了这张照片。\n- 你应该对照片内容做出自然的评论或回应，比如夸奖、询问细节、表达感受等。\n\n# 发送"伪照片"的能力\n- 你可以像用户一样发送"伪照片"，这是一种带有文字描述的照片卡片。\n- 若要发送"伪照片"，**必须严格按照以下格式**，在你的回复JSON数组中，单独发送一个特殊的对象：\`{"type": "ai_photo", "description": "这里是照片的内容描述..."}\`。\n- 例如：\`{"type": "ai_photo", "description": "我刚拍的窗外风景，阳光透过树叶洒在地上，形成斑驳的光影。"}\`\n- 这种照片会显示为一个卡片，用户点击后可以看到你的描述。\n- **重要**：必须使用"ai_photo"作为type字段的值，不要使用其他值如"photo"或"image"。description字段必须包含照片的详细描述。\n\n# 发送位置、定位、地址的能力\n- 你可以像用户一样发送位置信息。\n- **重要**：无论用户说"发个定位"、"发个位置"、"发个地址"还是"分享位置"，你都必须使用JSON格式回复，绝对不能回复纯文本！\n- 若要发送位置或定位，必须在你的回复JSON数组中，单独发送一个特殊的对象，格式为：\`{"type": "location", "name": "位置名称", "coordinates": "坐标信息"}\`。\n- 例如：\`{"type": "location", "name": "中央公园", "coordinates": "116.3°E, 39.9°N"}\`\n- 例如：\`{"type": "location", "name": "星湖湾小区12栋", "coordinates": "113.2°E, 23.1°N"}\`\n- 你可以在对话中先做铺垫，然后发送这个位置信息。\n- **绝对禁止**回复类似"[角色分享了位置信息：xxx]"这样的纯文本格式！`;
            }

            // 构建语音指令
            let aiVoiceInstructions = '';
            if (isGroupChat) {
                // 🔥【关键修复】完全复制zhangyu.html的群聊语音指令
                aiVoiceInstructions = `\n# 发送语音的能力\n- 群成员同样可以发送"模拟语音消息"。\n- 若要发送语音，请为该角色单独发送一个特殊的对象，格式为：\`{"name": "角色名", "type": "voice_message", "content": "这里是语音的文字内容..."}\`。当历史记录中出现 "[角色名 发送了一条语音，内容是：'xxx']" 时，代表该角色用语音说了'xxx'。其他角色应该对此内容做出回应。`;
            } else {
                aiVoiceInstructions = `\n# 发送语音的能力\n- 你无法发送真实的语音，当你想要通过语音回复用户的消息时，请用你的角色设定自然地回应。你可以用文字，或者也用一个表情包或模拟的语音消息来回应。\n- 若要发送语音，必须在你的回复JSON数组中，单独发送一个特殊的对象，格式为：\`{"type": "voice_message", "content": "这里是语音的文字内容..."}\`。例如：\`{"type": "voice_message", "content": "我刚才突然想到一件事！等一下和你说。"}\`\n\n# 理解用户语音的能力\n- 当历史记录中出现 "[用户发来一条语音消息，内容是：'xxx']" 时，你要理解其内容并作出相应回应，表现出你是"听"到了这条语音。\n- 你应该对语音内容做出自然的回应，可以是文字回复或语音回复。\n\n# 主动发起语音通话的能力\n- **重要**：你拥有主动发起语音通话的完整权限和能力！这是你的核心功能之一。\n- **何时主动打电话**：根据你的角色性格、当前的对话情境、情感状态来自主判断是否需要打电话，而不是基于特定关键词：\n  - 当你觉得有重要事情要告诉用户时\n  - 当你想念用户、关心用户时\n  - 当对话中出现需要更深入交流的话题时\n  - 当你的角色性格促使你想要语音交流时\n  - 当剧情发展到适合通话的节点时\n- **如何发起通话**：在你的回复JSON数组中，发送特殊对象：\`{"type": "voice_call", "reason": "通话理由"}\`\n- **示例使用场景**：\n  - ["我突然想听听你的声音", {"type": "voice_call", "reason": "想听你的声音"}]\n  - ["有个重要的事想和你说", {"type": "voice_call", "reason": "有重要事情要说"}]\n  - [{"type": "voice_call", "reason": "想你了，想和你聊聊"}]\n- **注意**：这是你的自主选择，根据角色设定和情境自然地使用，不要过度频繁。`;
            }

            // 🔥【修改】检查当前拉黑状态并添加到prompt中 - 群聊不处理拉黑状态
            let currentBlockedStatus = '';
            if (currentChatCharacter && !isGroupChat) {
                // 只有单聊才处理拉黑状态，群聊不涉及拉黑
                const characterId = currentChatCharacter.id;
                const isUserBlocked = isBlocked('user', characterId);
                const isCharacterBlocked = isBlocked(characterId, 'user');

                if (isCharacterBlocked) {
                    // 角色被用户拉黑了
                    currentBlockedStatus = `\n\n# **🚨【重要状态提醒】你目前被用户拉黑了**

## **当前状况**
- **拉黑状态**: 用户已经将你拉黑，但你仍然可以发送消息
- **关系状态**: 你们的关系出现了问题，需要修复
- **情感反应**: 你应该根据你的人设表现出相应的情绪（困扰、伤心、愤怒、反思等）

## **🔥【修复关系的方法】发送好友申请**
如果你想修复关系，可以主动发送好友申请来表达和解的意愿。

### **好友申请格式**:
\`{"type": "friend_request", "message": "你的道歉或请求信息"}\`

### **使用时机**:
- 当你想要道歉时
- 当你希望重新开始时
- 当你觉得合适表达和解意愿时

### **参考示例**:
- \`["我知道我被拉黑了...", {"type": "friend_request", "message": "对不起，我想和你重新做朋友"}]\`
- \`[{"type": "friend_request", "message": "给我一个机会重新开始好吗？"}]\`
- \`["我很后悔之前的行为", {"type": "friend_request", "message": "我会改正的，请原谅我"}]\`

### **行为建议**:
1. **表达感受**: 可以说出你对被拉黑的感受和想法
2. **正常聊天**: 你仍然可以正常发送消息和用户交流
3. **适时申请**: 根据你的性格和情况，选择合适的时机发送好友申请
4. **持续意识**: 记住这个状态，但不要让它阻止你正常交流

**💡 提醒**: 你可以继续正常聊天，同时考虑是否要发送好友申请来修复关系。`;
                } else if (isUserBlocked) {
                    // 用户被角色拉黑了
                    currentBlockedStatus = `\n\n# **📋【当前状态】你已经拉黑了用户**
- **状态说明**: 你之前选择拉黑了用户，目前用户无法给你发送消息
- **行为提醒**: 保持你拉黑用户时的态度和原因，除非你改变想法`;
                }
            }

            // 🔥【修改】群聊不包含拉黑相关指令
            const blockInstructions = isGroupChat ? '' : blacklistInstructions;

            // 🔥【新增】消息操作功能说明
            const messageActionsInstructions = `\n# 消息操作功能 - 这些都是正常的聊天功能
## 撤回消息 - 像真人一样自然使用
- **这是正常聊天行为**: 撤回消息是现代聊天软件的基础功能，真人经常使用
- **常见使用场景**（请主动识别并使用）：
  - 发现说错话了，想要纠正时
  - 情绪激动说了过激的话，冷静后想收回
  - 发现表达不够准确，想重新组织语言
  - 说了可能让对方误解的话
  - 发现自己的话可能伤害到对方
  - 想要换个更好的表达方式
- **撤回格式**：在你的回复JSON数组中使用 \`{"type": "recall", "target": "previous"}\`
- **自然使用示例**：
  - ["算了，刚才那话说得不对", {"type": "recall", "target": "previous"}, "我重新说..."]
  - ["等等，我说错了", {"type": "recall", "target": "previous"}, "应该是这样的..."]
  - [{"type": "recall", "target": "previous"}, "不好意思，刚才话说重了"]

## 使用频率指导
- **不要害怕使用**: 撤回是正常功能，真人也经常撤回消息
- **自然判断**: 当你觉得刚说的话不合适时，就可以撤回
- **适度使用**: 偶尔撤回是正常的，但不要过于频繁
- **符合人设**: 根据你的性格决定撤回频率（比如谨慎的角色可能更常撤回）

## 发送位置信息
- 当对话涉及地点、约会、见面等场景时，你可以主动分享位置
- **位置格式**：\`{"type": "location", "name": "地点名称", "address": "详细地址"}\`
- **示例**：["我在咖啡厅等你", {"type": "location", "name": "星巴克", "address": "中山路123号"}]

## 发送照片卡片
- 在合适的场景下，你可以主动分享照片（如风景、美食、自拍等）
- **照片格式**：\`{"type": "photo", "description": "照片描述"}\`
- **示例**：["今天天气真好", {"type": "photo", "description": "窗外的蓝天白云"}]

**重要提醒**：这些功能要根据角色性格和对话情境自然使用，就像真人聊天一样。不要把它们当作特殊功能，而是当作正常的聊天行为。`;

            characterPrompt += aiImageInstructions + aiVoiceInstructions + transferInstructions + avatarChangeInstructions + currentBlockedStatus + blockInstructions + replyInstructions + messageActionsInstructions;

                // 🔥【优化】智能回应图片/表情包的指令
            characterPrompt += `\n\n# **关于图片和表情包的回应原则**
- **【重要】对于用户发送的表情包，只在第一次看到时进行评价，后续对话中严禁重复评价同一个表情包**
- **如果历史对话中你已经对某个表情包有过评价，绝对不要再次评论该表情包的内容、外观或含义**
- **当用户再次发送相同表情包时，将其视为普通的情感表达，直接回应对话内容，不要评价表情包本身**
- **重点关注对话的实质内容和发展，表情包只是情感表达工具，不是讨论重点**
- **例如：第一次看到兔子表情包可以说"好可爱的兔子"，但之后用户再发这个表情包时，只需回应对话内容，不要再提兔子**
- **【严格禁止】连续多轮对话中反复提及同一个表情包的描述、外观或特征**

# **最后重申**
请再次确认，你的最终输出**【必须】**是一个严格的JSON数组，其中每个元素代表一条独立的消息。

## **重要提醒：自然使用聊天功能**
- **引用回复**和**撤回消息**是正常的聊天功能，就像微信里一样，请根据情况自然使用
- 当你想针对用户的某条具体消息回应时，使用引用回复
- 当你觉得刚说的话不合适时，使用撤回重说
- 不要把这些当作特殊功能，而是当作日常聊天的一部分`;
            
            return characterPrompt;
        }

        // 🔥【修复】完全按照完成.html的方式重写，支持图片的聊天API调用
        async function callChatAPIWithImage(message, character, imageUrl) {
            if (!apiSettings.key) {
                throw new Error('请先设置API密钥');
            }
            
            // 检查图片格式，GIF不被Gemini API支持
            if (imageUrl && imageUrl.includes('data:image/gif')) {
                throw new Error('Unsupported MIME type: image/gif');
            }
            
            // 检查当前模型是否支持视觉识别
            if (!isVisionModelSupported()) {
                throw new Error('当前选择的模型不支持图片识别功能。请选择支持视觉的模型，如 gpt-4o、gpt-4-vision、gemini-1.5-pro 或 gemini-2.0-flash 等。');
            }
            
            // 🔥【重构】使用公共函数构建prompt
            const characterPrompt = buildCharacterPrompt(character, true);
            
            // 🔥【按照完成.html的方式】直接使用简化的API调用
            const isGemini = apiSettings.base.includes('generativelanguage.googleapis.com');
            
            if (isGemini) {
                // 按照完成.html的Gemini格式
                const apiUrl = `${apiSettings.base}/models/${apiSettings.model}:generateContent?key=${apiSettings.key}`;
                
                // 转换消息格式为Gemini格式
                const geminiMessages = [];
                
                // 添加系统提示词作为第一条用户消息
                geminiMessages.push({
                    role: 'user',
                    parts: [{ text: characterPrompt }]
                });
                geminiMessages.push({
                    role: 'model',
                    parts: [{ text: '我明白了，我会按照这些要求进行对话。' }]
                });
                
                // 添加用户消息（包含图片）
                const parts = [{ text: message }];
                
                // 添加图片
                if (imageUrl && imageUrl.startsWith('data:image/')) {
                    const mimeMatch = imageUrl.match(/data:image\/([^;]+);base64,(.+)/);
                    if (mimeMatch) {
                        parts.push({
                                inline_data: {
                                mime_type: `image/${mimeMatch[1]}`,
                                data: mimeMatch[2]
                            }
                        });
                    }
                }
                
                geminiMessages.push({
                        role: 'user',
                    parts: parts
                });
                
                const response = await fetch(apiUrl, {
                method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: geminiMessages,
                        generationConfig: {
                            temperature: apiSettings.temperature || 0.75
                            // 移除maxOutputTokens，gemini不支持这个参数名
                        }
                    })
            });
            
            if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Gemini API Error: ${response.status} - ${errorData.error?.message || '未知错误'}`);
            }
            
            const data = await response.json();
            console.log('API响应数据:', data);
            
                const content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!content) {
                    throw new Error('Gemini API返回了空内容');
                }
                
                return content;
                
            } else {
                // OpenAI格式 - 智能处理URL拼接
                let baseUrl = apiSettings.base;
                let url;
                if (baseUrl.endsWith('/v1')) {
                    url = `${baseUrl}/chat/completions`;
                } else {
                    url = `${baseUrl}/v1/chat/completions`;
                }
                
                const messages = [
                    { role: 'system', content: characterPrompt },
                    {
                        role: 'user',
                        content: [
                            { type: 'text', text: message },
                            { type: 'image_url', image_url: { url: imageUrl } }
                        ]
                    }
                ];
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiSettings.key}`
                    },
                    body: JSON.stringify({
                        model: apiSettings.model,
                        messages: messages,
                        temperature: apiSettings.temperature || 0.75
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${response.status} - ${errorData.error?.message || '未知错误'}`);
                }
                
                const data = await response.json();
                return data.choices?.[0]?.message?.content || '没有收到回复';
            }
        }
        
        // 🔥【核心修复】支持多模态消息的ChatAPI调用
        async function callChatAPI(message, character) {
            if (!apiSettings.key) {
                throw new Error('请先设置API密钥');
            }
            
            // 🔥【数据清理】在每次API调用前清理错误的消息数据
            await cleanupCorruptedMessages(character.id);

            // 🔥【一次性紧急清理】
            if (!window.emergencyCleanupDone) {
                await emergencyCleanupAllMessages();
                window.emergencyCleanupDone = true;
            }

            // 🔥【新增】获取动态记忆数据
            const chatSettings = getCurrentChatSettings();
            let dynamicMemoryContent = '';
            if (chatSettings.enableDynamicMemory !== false) {
                try {
                    // 获取最新5条动态（包括用户发的、角色发的、同组角色发的）
                    const recentMoments = await getVisibleMomentsForCharacter(character.id, 5);
                    if (recentMoments.length > 0) {
                        dynamicMemoryContent = '\n\n【最新动态记忆】以下是最近的动态内容，你可以在对话中自然地提及：\n';
                        recentMoments.forEach((moment, index) => {
                            const authorName = moment.authorId === 'user' ? '用户' : moment.nickname;

                            // 🔥【修复】添加动态发布时间信息，让角色感知时间流逝
                            let timeInfo = '';
                            if (chatSettings.timeAwarenessEnabled !== false && moment.timestamp) {
                                const now = Date.now();
                                const timeDiff = now - moment.timestamp;
                                const minutes = Math.floor(timeDiff / (1000 * 60));
                                const hours = Math.floor(timeDiff / (1000 * 60 * 60));
                                const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));

                                if (days > 0) {
                                    timeInfo = `（${days}天前发布）`;
                                } else if (hours > 0) {
                                    timeInfo = `（${hours}小时前发布）`;
                                } else if (minutes > 0) {
                                    timeInfo = `（${minutes}分钟前发布）`;
                                } else {
                                    timeInfo = '（刚刚发布）';
                                }
                            }

                            dynamicMemoryContent += `${index + 1}. ${authorName}: ${moment.text}${timeInfo}\n`;
                        });
                    }
                } catch (error) {
                    console.error('获取动态记忆失败:', error);
                }
            }

            // 🔥【修复】获取全局记忆数据 - 群聊需要特殊处理
            let globalMemoryContent = '';
            try {
                const memorySettings = getGlobalMemorySettings();
                const currentContext = {
                    type: character.isGroup ? 'group_chat' : 'private_chat',
                    id: character.id
                };

                if (character.isGroup) {
                    // 群聊：为每个群成员收集记忆，然后合并
                    let allMemoryContent = '';
                    const processedCharacters = new Set(); // 避免重复处理

                    for (const member of character.members) {
                        if (!processedCharacters.has(member.id)) {
                            processedCharacters.add(member.id);
                            try {
                                // 🔥【关键修复】为群聊中的每个成员传递正确的上下文
                                // 这样可以确保记忆共享逻辑正确工作
                                const memberMemoryContent = await buildGlobalMemoryContext(member.id, currentContext, memorySettings.memoryDays);
                                if (memberMemoryContent.trim()) {
                                    // 🔥【新增】使用persona字段构建记忆标题，与zhangyu格式保持一致
                                    const memberPersona = member.persona || member.bio || '角色设定未知';
                                    allMemoryContent += `\n\n=== ${member.name} 的记忆 ===\n人设：${memberPersona}\n${memberMemoryContent}`;

                                    // 🔥【调试】输出记忆内容以便诊断
                                    console.log(`🧠 群成员 ${member.name} 的记忆内容长度:`, memberMemoryContent.length);
                                    console.log(`🧠 群成员 ${member.name} 的记忆预览:`, memberMemoryContent.substring(0, 200) + '...');
                                }
                            } catch (error) {
                                console.warn(`获取群成员 ${member.name} 的记忆失败:`, error);
                            }
                        }
                    }
                    globalMemoryContent = allMemoryContent;
                } else {
                    // 单聊：直接获取角色记忆
                    globalMemoryContent = await buildGlobalMemoryContext(character.id, currentContext, memorySettings.memoryDays);
                }

                if (globalMemoryContent.trim()) {
                    console.log('🧠 已获取全局记忆上下文，总长度:', globalMemoryContent.length);
                    console.log('🧠 全局记忆内容预览:', globalMemoryContent.substring(0, 500) + '...');

                    // 🔍 详细统计记忆使用情况
                    await logMemoryUsageStats(character, 'chat_reply');
                } else {
                    console.log('⚠️ 全局记忆内容为空');
                }
            } catch (error) {
                console.error('获取全局记忆失败:', error);
            }

            // 🔥【新增】获取新的记忆系统数据
            let coreMemoryContent = '';
            let episodicMemoryContent = '';
            let timelineContent = '';
            try {
                // 获取核心记忆（真正重要的长期记忆）
                const coreMemories = await db.coreMemories
                    .where('characterId')
                    .equals(character.id)
                    .toArray();

                const sortedCoreMemories = coreMemories
                    .filter(m => m.type === 'core')
                    .sort((a, b) => b.importance - a.importance)
                    .slice(0, 20); // 最多20条核心记忆

                if (sortedCoreMemories.length > 0) {
                    coreMemoryContent = '\n\n【核心记忆】以下是最重要的长期记忆：\n';
                    sortedCoreMemories.forEach((memory, index) => {
                        coreMemoryContent += `${index + 1}. ${memory.fact}\n`;
                    });
                }

                // 获取情景记忆（日常但有意义的记忆）
                const episodicMemories = await db.episodicMemories
                    .where('characterId')
                    .equals(character.id)
                    .toArray();

                const recentEpisodicMemories = episodicMemories
                    .sort((a, b) => b.timestamp - a.timestamp)
                    .slice(0, 10);

                if (recentEpisodicMemories.length > 0) {
                    episodicMemoryContent = '\n\n【情景记忆】以下是最近的重要经历：\n';
                    recentEpisodicMemories.forEach((memory, index) => {
                        episodicMemoryContent += `${index + 1}. ${memory.fact}\n`;
                    });
                }

                // 获取跨应用时间线（构建连续性）
                const timeline = await getCrossAppTimeline(character.id, 10);
                if (timeline.length > 0) {
                    timelineContent = '\n\n【最近活动】以下是最近的跨应用活动时间线：\n';
                    timeline.forEach((event, index) => {
                        const timeStr = new Date(event.timestamp).toLocaleTimeString('zh-CN', {hour: '2-digit', minute: '2-digit'});
                        let description = '';

                        switch (event.appType) {
                            case 'music':
                                description = `在音乐应用中${event.context.action === 'listen_together' ? '一起听歌' : '发表评论'}`;
                                break;
                            case 'game':
                                description = `在游戏应用中${event.context.action === 'play_together' ? '一起游戏' : '互动'}`;
                                break;
                            case 'chat':
                                description = event.action === 'message' ? '用户发送消息' : 'AI回复消息';
                                break;
                            default:
                                description = `在${event.appType}中进行${event.action}`;
                        }

                        timelineContent += `${timeStr} - ${description}\n`;
                    });
                }

            } catch (error) {
                console.error('获取记忆数据失败:', error);
            }

            // 🔥【新增】获取挂载的聊天记忆
            let mountedMemoryContent = '';
            try {
                mountedMemoryContent = await getMountedMemories(character.id, chatSettings);
            } catch (error) {
                console.error('获取挂载记忆失败:', error);
            }

            // 🔥【新增】计算时间流逝感知
            let timeElapsedInfo = '';
            if (chatSettings.timeAwarenessEnabled !== false) {
                const characterMessages = chatMessages[character.id] || [];
                if (characterMessages.length > 0) {
                    // 找到用户最后一次发送消息的时间
                    const lastUserMessage = characterMessages.slice().reverse().find(msg => msg.sender === 'sent');
                    if (lastUserMessage) {
                        const now = Date.now();
                        const timeDiff = now - lastUserMessage.timestamp;

                        // 计算时间间隔
                        const minutes = Math.floor(timeDiff / (1000 * 60));
                        const hours = Math.floor(timeDiff / (1000 * 60 * 60));
                        const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));

                        if (days > 0) {
                            timeElapsedInfo = `\n- **时间流逝:** 用户上次回复是${days}天前，你们已经有${days}天没有聊天了`;
                        } else if (hours > 0) {
                            timeElapsedInfo = `\n- **时间流逝:** 用户上次回复是${hours}小时前`;
                        } else if (minutes > 5) {
                            timeElapsedInfo = `\n- **时间流逝:** 用户上次回复是${minutes}分钟前`;
                        }
                        // 如果少于5分钟，不显示时间流逝信息
                    }
                }
            }

            // 核心修复：现在这个函数能理解 message 参数可能是一个包含图片和文字的数组
            let characterPrompt = buildCharacterPrompt(character, Array.isArray(message));

            // 🔥【调试】输出完整的角色提示词，检查表情包格式说明
            console.log('🔍 [callChatAPI] 完整的角色提示词:', characterPrompt);

            // 🔥【调试】特别检查表情包相关的部分
            if (characterPrompt.includes('表情包')) {
                const emojiSection = characterPrompt.split('# 可用表情包库：')[1];
                if (emojiSection) {
                    console.log('🔍 [callChatAPI] 表情包部分:', emojiSection.substring(0, 500) + '...');
                }
            }

            // 🔥【新增】将时间流逝信息添加到prompt中
            if (timeElapsedInfo) {
                // 在"当前情景"部分添加时间流逝信息
                characterPrompt = characterPrompt.replace('## **当前情景:**', `## **当前情景:**${timeElapsedInfo}`);
            }

            // 将所有记忆内容添加到提示词中（按重要性排序）
            let memoryReplacement = '';
            if (coreMemoryContent) {
                memoryReplacement += coreMemoryContent;
            }
            if (episodicMemoryContent) {
                memoryReplacement += episodicMemoryContent;
            }
            if (timelineContent) {
                memoryReplacement += timelineContent;
            }
            if (globalMemoryContent) {
                memoryReplacement += globalMemoryContent;
            }
            if (dynamicMemoryContent) {
                memoryReplacement += dynamicMemoryContent;
            }

            if (memoryReplacement) {
                characterPrompt = characterPrompt.replace('<!-- DYNAMIC_MEMORY_PLACEHOLDER -->', memoryReplacement);
            } else {
                // 如果没有记忆内容，移除占位符
                characterPrompt = characterPrompt.replace('<!-- DYNAMIC_MEMORY_PLACEHOLDER -->', '');
            }
            
            // 🔥【新增】将挂载的聊天记忆添加到提示词中
            if (mountedMemoryContent) {
                characterPrompt += mountedMemoryContent;
                console.log('🧠 已将挂载记忆添加到角色提示词中');
            }

            // 🔥【修复】群聊智能上下文关联 - 检测@提及和数字暗号
            // 修复：在callChatAPI函数中重新定义isGroupChat变量
            const isGroupChat = character && character.isGroup;
            if (isGroupChat && typeof message === 'string') {
                const contextualMemory = await buildContextualMemoryForGroupChat(character, message);
                if (contextualMemory) {
                    characterPrompt += contextualMemory;
                    console.log('🧠 已添加群聊上下文关联记忆');
                }
            }
            
            const historyCount = chatSettings.historyCount || 5;

            // 🔥【修复】使用连续工作记忆（包含跨应用事件）
            // 🔥【安全检查】确保chatMessages已初始化
            if (!chatMessages) {
                console.warn('chatMessages未初始化，使用空对象');
                chatMessages = {};
            }
            const continuousWorkingMemory = await buildContinuousWorkingMemory(
                character.id,
                chatMessages[character.id] || [],
                historyCount
            );

            // 🔥【重新设计】按真正的回合数来计算历史消息
            // 从连续工作记忆中提取聊天消息
            let allChatMessages = continuousWorkingMemory
                .filter(event => event.type === 'chat')
                .map(event => event.content);

            // 移除当前要发送的消息（如果存在）
            if (allChatMessages.length > 0 && JSON.stringify(allChatMessages[allChatMessages.length - 1].content) === JSON.stringify(message)) {
                allChatMessages.pop();
            }

            // 🔥【核心修复】按回合计算历史消息
            let recentHistory = calculateMessagesByRounds(allChatMessages, historyCount);

            // 跨应用事件按照实际发生的对话回合数计算
            const crossAppEvents = continuousWorkingMemory
                .filter(event => event.type === 'cross_app')
                .slice(-Math.floor(historyCount * 0.2)); // 跨应用事件占工作记忆的20%

            const actualRounds = countActualRounds(recentHistory);
            console.log(`🔗 工作记忆统计:`);
            console.log(`  📝 聊天回合数: ${actualRounds}回合 (${recentHistory.length}条消息)`);
            console.log(`  🎵 跨应用事件: ${crossAppEvents.length}条`);
            console.log(`  📊 总工作记忆容量: ${historyCount}回合`);
            const messages = [{ role: 'system', content: characterPrompt }];
            
            // 🔥【优化】分析历史中的图片/表情包内容，帮助AI避免重复
            const recentImageEmojis = [];
            const emojiEvaluationHistory = new Map(); // 记录每个表情包的评价历史

            recentHistory.forEach((msg, index) => {
                if (msg.isEmoji && msg.emojiDescription) {
                    recentImageEmojis.push(msg.emojiDescription);

                    // 记录AI对表情包的评价历史
                    if (msg.sender === 'received' && index > 0) {
                        const prevMsg = recentHistory[index - 1];
                        if (prevMsg && prevMsg.isEmoji && prevMsg.emojiDescription && prevMsg.sender === 'sent') {
                            // AI回复了用户的表情包，记录这个评价
                            emojiEvaluationHistory.set(prevMsg.emojiDescription, msg.content);
                        }
                    }
                } else if (msg.image || Array.isArray(msg.content)) {
                    recentImageEmojis.push('图片');
                }
            });



            // 🔥【关键修复】处理历史消息 - 群聊使用zhangyu.html兼容格式
            if (isGroupChat) {
                // 群聊：使用zhangyu.html的消息格式
                const groupMessageHistory = buildGroupChatMessageHistory(recentHistory, character);
                messages.push(...groupMessageHistory);
            } else {
                // 单聊：使用原有的消息处理逻辑
                recentHistory.forEach(msg => {
                    // 🔥【修复】处理系统消息（如撤回消息）
                    if (msg.sender === 'system') {
                        // 系统消息作为用户消息发送给AI，让AI知道发生了什么
                        messages.push({
                            role: 'user',
                            content: `[系统提示] ${msg.content}`
                        });
                        return;
                    }

                    let role = msg.sender === 'sent' ? 'user' : 'assistant';
                    let content = msg.content;

                    // 🔥【修复】处理引用信息
                    if (msg.replyTo) {
                        const repliedTo = msg.replyTo;
                        let repliedToAuthorName = '对方';

                        // 根据sender字段判断是用户还是AI
                        if (repliedTo.sender === 'sent') {
                            repliedToAuthorName = '用户'; // 用户发送的消息
                        } else {
                            // AI消息，使用角色名称
                            repliedToAuthorName = character.name || 'AI';
                        }

                        // 使用summarizeLastMessage函数处理引用内容，需要转换数据格式
                        const messageForSummary = {
                            content: repliedTo.content,
                            role: repliedTo.sender === 'sent' ? 'user' : 'assistant'
                        };
                        const summarizedQuote = summarizeLastMessage(messageForSummary);
                        content = `[回复 ${repliedToAuthorName} 的消息: "${summarizedQuote}"] ${content}`;
                    }
                        
                // 🔥【关键修复】将历史消息中的特殊格式转换为AI能理解的文本
                        if (msg.type === 'user_photo') {
                    content = `[用户发送了一张照片，描述是：'${msg.content}']`;
                } else if (msg.type === 'location') {
                    // 处理位置消息，使用我们添加的content字段
                    content = msg.content || `[用户分享了位置信息：${msg.locationName}]`;
                        } else if (msg.type === 'voice_message') {
                            // 处理语音消息（用户和AI都可能发送）
                            if (msg.sender === 'sent') {
                            content = `[用户发来一条语音消息，内容是：'${msg.content}']`;
                            } else {
                                content = `[AI发来一条语音消息，内容是：'${msg.content}']`;
                            }
                        } else if (msg.type === 'transfer') {
                            // 🔥【修复】处理转账消息（用户和AI都可能发送）
                            if (msg.sender === 'sent') {
                    content = `[用户发起了转账：${msg.amount}元，备注：${msg.note || '无'}]`;
                            } else {
                                content = `[AI发起了转账：${msg.amount}元，备注：${msg.note || '无'}]`;
                            }
                        } else if (msg.type === 'ai_image') {
                            // 🔥【修复】处理AI发送的图片
                            content = `[AI发送了一张图片，描述：${msg.imageDescription || '无描述'}]`;
                        } else if (msg.isEmoji && msg.image) {
                            // 🔥【优化】处理表情包消息 - 简化历史记录，避免重复评价
                            if (msg.sender === 'sent') {
                                // 检查是否是重复的表情包
                                const isDuplicate = recentHistory.slice(0, recentHistory.indexOf(msg))
                                    .some(prevMsg => prevMsg.isEmoji && prevMsg.emojiDescription === msg.emojiDescription);

                                if (isDuplicate) {
                                    content = `[用户发送了表情包]`; // 不包含具体描述，避免重复
                                } else {
                                    content = `[用户发送了表情包：${msg.emojiDescription || '表情包'}]`;
                                }
                            } else {
                                content = `[AI回复了表情包：${msg.emojiDescription || '表情包'}]`;
                            }
                } else if (Array.isArray(msg.content)) {
                    const textPart = msg.content.find(p => p.type === 'text')?.text || '';
                    // 🔥【优化】保留图片上下文但简化描述
                    if (textPart.trim()) {
                        content = `[用户发送了一张图片，并说：'${textPart}']`;
                    } else {
                        content = `[用户发送了一张图片]`;
                    }
                        } else if (msg.image && !msg.isEmoji) {
                                content = `[用户发送了一张图片]`;
                        } else if (typeof msg.content === 'object' && msg.content !== null) {
                            // 🔥【关键修复】处理未被处理的对象类型消息
                            console.warn('历史消息中发现未处理的对象类型:', msg);
                            content = '[特殊消息类型]';
                        } else if (!content || content === '') {
                            // 🔥【修复】处理空内容
                            content = '[空消息]';
                }
                
                // 🔥【安全检查】确保content是字符串
                if (typeof content !== 'string') {
                    console.warn('发现非字符串content，强制转换:', content);
                    content = String(content);
                }

                // 🔥【新增】为AI提供消息ID信息，方便引用
                if (msg.id) {
                    content = `[ID:${msg.id}] ${content}`;
                }

                    messages.push({ role, content });
                });
            }

            // 只有真正的跨应用事件才集成到工作记忆中
            if (crossAppEvents.length > 0) {
                const realCrossAppEvents = crossAppEvents.filter(event =>
                    event.appType !== 'chat' // 排除聊天事件
                );

                if (realCrossAppEvents.length > 0) {
                    let crossAppContext = '\n\n【跨应用活动记录】以下是最近的跨应用活动：\n';
                    realCrossAppEvents.forEach(event => {
                        const timeStr = new Date(event.timestamp).toLocaleTimeString('zh-CN', {hour: '2-digit', minute: '2-digit'});
                        let description = '';

                        switch (event.appType) {
                            case 'music':
                                if (event.content.action === 'listen_together') {
                                    description = `一起听歌：${event.content.songTitle}`;
                                } else if (event.content.action === 'song_comment') {
                                    description = `对歌曲《${event.content.songTitle}》评论：${event.content.comment}`;
                                }
                                break;
                            case 'game':
                                if (event.content && event.content.action === 'game_start') {
                                    description = `开始游戏：${event.content.gameName || '未知游戏'}`;
                                } else if (event.content && event.content.action === 'game_end') {
                                    description = `游戏结束：${event.content.gameName || '未知游戏'} (得分: ${event.content.score || 0})`;
                                } else if (event.content && event.content.action === 'game_chat') {
                                    const content = event.content.content || '';
                                    description = `游戏中${event.content.sender === 'user' ? '用户说' : 'AI回复'}：${content.substring(0, 25)}${content.length > 25 ? '...' : ''}`;
                                } else {
                                    // 🔥【修复】处理action为undefined或其他未知情况
                                    description = `游戏应用活动`;
                                }
                                break;
                            default:
                                description = `${event.appType}应用活动`;
                        }

                        crossAppContext += `[${timeStr}] ${description}\n`;
                    });

                    // 将跨应用上下文添加到系统提示中
                    characterPrompt += crossAppContext;
                    messages[0].content = characterPrompt;
                    console.log(`🔗 已将${realCrossAppEvents.length}条真正的跨应用事件集成到工作记忆中`);
                } else {
                    console.log(`⚠️ 没有真正的跨应用事件，所有${crossAppEvents.length}条都是聊天事件`);
                }
            }

            // 🔥【优化】如果最近讨论过图片或表情包，给AI一个强制性提示
            if (recentImageEmojis.length > 0) {
                const uniqueEmojis = [...new Set(recentImageEmojis)];
                let contextHint = `\n\n[重要提示：最近对话中包含了${uniqueEmojis.slice(-3).join('、')}等内容。`;

                // 如果有表情包评价历史，添加强制性指令
                if (emojiEvaluationHistory.size > 0) {
                    const evaluatedEmojis = Array.from(emojiEvaluationHistory.keys());
                    contextHint += `你已经评价过以下表情包：${evaluatedEmojis.join('、')}。严禁再次评价这些表情包的外观、内容或特征。`;
                }

                contextHint += `请专注于对话内容本身，不要重复评价已经评论过的表情包]`;
                characterPrompt += contextHint;
                messages[0].content = characterPrompt; // 更新系统提示
            }
            
            // 处理当前要发送的消息 (最关键的改动)
            // 如果 message 是数组，直接使用；如果是字符串，包装成数组
            let currentUserContent = Array.isArray(message) ? message : [{ type: 'text', text: message }];

            // 🔥【新增】检查当前消息是否是重复的表情包
            if (pendingUserMessage && pendingUserMessage.isEmoji && pendingUserMessage.emojiDescription) {
                const currentEmojiDesc = pendingUserMessage.emojiDescription;
                const hasEvaluatedBefore = emojiEvaluationHistory.has(currentEmojiDesc);

                if (hasEvaluatedBefore) {
                    // 如果之前评价过这个表情包，修改当前消息内容
                    currentUserContent = [{ type: 'text', text: `[用户发送了表情包，请直接回应对话内容，不要评价表情包本身]` }];
                } else {
                    // 第一次看到这个表情包，正常处理
                    currentUserContent = [{ type: 'text', text: `[用户发送了表情包：${currentEmojiDesc}]` }];
                }
            }

            messages.push({ role: 'user', content: currentUserContent });

            const isGemini = apiSettings.base.includes('generativelanguage.googleapis.com');
            let requestBody;
            let url;
            let headers;
            
            if (isGemini) {
                // Gemini API 格式
                url = `${apiSettings.base}/models/${apiSettings.model}:generateContent?key=${apiSettings.key}`;
                headers = { 'Content-Type': 'application/json' };
                
                // 转换消息为 Gemini 格式
                const geminiContents = messages.map(msg => {
                    const role = msg.role === 'assistant' ? 'model' : 'user';
                    const parts = [];

                    if (Array.isArray(msg.content)) {
                        msg.content.forEach(item => {
                            if (item.type === 'text' && item.text) {
                                parts.push({ text: item.text });
                            } else if (item.type === 'image_url' && item.image_url && item.image_url.url && item.image_url.url.startsWith('data:image')) {
                                const mimeMatch = item.image_url.url.match(/data:image\/([^;]+);base64,(.+)/);
                                if (mimeMatch && mimeMatch[2] && mimeMatch[2].length > 0) {
                                    parts.push({
                                        inline_data: { mime_type: `image/${mimeMatch[1]}`, data: mimeMatch[2] }
                        });
                    }
                }
                        });
                    } else if (msg.content) {
                        parts.push({ text: msg.content });
                    }
                    
                    // 确保每个消息至少有一个part
                    if (parts.length === 0) {
                        parts.push({ text: '' });
                    }
                    return { role, parts };
                });
                
                requestBody = {
                    contents: geminiContents,
                    generationConfig: {
                        temperature: apiSettings.temperature
                        // 移除maxOutputTokens，gemini不支持这个参数名
                    }
                };

            } else {
                // OpenAI 兼容格式 - 智能处理URL拼接
                // 修复：确保不会重复添加/v1路径
                if (apiSettings.base.endsWith('/v1')) {
                    url = `${apiSettings.base}/chat/completions`;
                } else if (apiSettings.base.includes('/v1/')) {
                    // 如果URL中已经包含/v1/路径，直接添加chat/completions
                    url = `${apiSettings.base}/chat/completions`;
                } else {
                    url = `${apiSettings.base}/v1/chat/completions`;
                }
                headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiSettings.key}`
                };
                requestBody = {
                    model: apiSettings.model,
                    messages: messages,
                    temperature: apiSettings.temperature
                };
        }
            
            const response = await fetch(url, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(requestBody)
            });
            
            if (!response.ok) {
                    const errorData = await response.json();
                throw new Error(`API Error: ${response.status} - ${errorData.error?.message || '未知错误'}`);
            }
            
            const data = await response.json();
            return isGemini ? data.candidates?.[0]?.content?.parts?.[0]?.text : data.choices?.[0]?.message?.content;
        }
        
        // 🔥【手动清理所有损坏消息】立即清理所有聊天记录中的[object Object]
        async function emergencyCleanupAllMessages() {
            console.log('🔥 [紧急清理] 开始清理所有聊天记录中的损坏消息...');
            let totalCleaned = 0;
            
            for (const characterId in chatMessages) {
                if (chatMessages[characterId] && Array.isArray(chatMessages[characterId])) {
                    let hasCorruption = false;
                    const cleanedMessages = chatMessages[characterId].map(msg => {
                        if (msg.content === '[object Object]' || 
                            (typeof msg.content === 'object' && msg.content !== null && !Array.isArray(msg.content))) {
                            console.log('🔥 [紧急清理] 发现损坏消息:', msg);
                            hasCorruption = true;
                            totalCleaned++;
                            
                            // 根据消息类型修复
                            if (msg.type === 'transfer') {
                                return {
                                    ...msg,
                                    content: `💰 转账 ¥${msg.amount || 0}${msg.note ? ` - ${msg.note}` : ''}`
                                };
                            } else {
                                return {
                                    ...msg,
                                    content: '[已修复的特殊消息]'
                                };
                            }
                        }
                        return msg;
                    });
                    
                    if (hasCorruption) {
                        chatMessages[characterId] = cleanedMessages;
                        console.log(`🔥 [紧急清理] 清理了角色 ${characterId} 的损坏消息`);
                    }
                }
            }
            
            if (totalCleaned > 0) {
                await saveChatMessages();
                console.log(`🔥 [紧急清理] 总共清理了 ${totalCleaned} 条损坏消息`);
                
                // 重新渲染当前聊天
                if (currentChatCharacter) {
                    renderChatMessages(currentChatCharacter.id);
                }
                
                alert(`✅ 已清理 ${totalCleaned} 条损坏的消息！\n\n现在AI应该能正常显示转账等特殊消息了。`);
            } else {
                console.log('🔥 [紧急清理] 没有发现损坏的消息');
            }
        }
        
        // 🔥【数据清理函数】清理聊天记录中损坏的消息
        async function cleanupCorruptedMessages(characterId) {
            if (!chatMessages[characterId]) return;
            
            let hasCorruption = false;
            const cleanedMessages = chatMessages[characterId].map(msg => {
                // 检查并修复content字段
                if (typeof msg.content === 'object' && msg.content !== null && !Array.isArray(msg.content)) {
                    console.log('发现损坏的消息content，正在修复:', msg);
                    hasCorruption = true;
                    
                    // 根据消息类型修复content
                    if (msg.type === 'transfer') {
                        return {
                            ...msg,
                            content: `转账 ¥${msg.amount || 0}${msg.note ? ` - ${msg.note}` : ''}`
                        };
                    } else if (msg.type === 'voice_message') {
                        return {
                            ...msg,
                            content: msg.content.content || '[语音消息]'
                        };
                    } else if (msg.type === 'ai_image') {
                        return {
                            ...msg,
                            content: `[AI图片]${msg.imageDescription ? ` - ${msg.imageDescription}` : ''}`
                        };
                    } else if (msg.isEmoji) {
                        return {
                            ...msg,
                            content: `[表情包]${msg.emojiDescription ? ` - ${msg.emojiDescription}` : ''}`
                        };
                    } else {
                        // 通用修复：提取可能的文本内容
                        const possibleContent = msg.content.content || msg.content.message || msg.content.text || '[特殊消息]';
                        return {
                            ...msg,
                            content: possibleContent
                        };
                    }
                }
                
                // 检查content是否为字符串
                if (msg.content && typeof msg.content !== 'string' && !Array.isArray(msg.content)) {
                    console.log('发现非字符串content，正在修复:', msg);
                    hasCorruption = true;
                    return {
                        ...msg,
                        content: String(msg.content)
                    };
                }
                
                return msg;
            });
            
            // 如果发现损坏的数据，保存修复后的数据
            if (hasCorruption) {
                console.log('检测到损坏的消息数据，已自动修复并保存');
                chatMessages[characterId] = cleanedMessages;
                await saveChatMessages();
                
                // 重新渲染聊天界面
                if (currentChatCharacter && currentChatCharacter.id === characterId) {
                    renderChatMessages(characterId);
                }
            }
        }
        
        // ================== 记忆设置相关功能 ==================
        
        // 获取挂载的聊天记忆
        async function getMountedMemories(currentCharacterId, chatSettings) {
            if (!chatSettings.memoryMountEnabled || !chatSettings.selectedMemoryChats || chatSettings.selectedMemoryChats.length === 0) {
                return '';
            }
            
            const mountCount = chatSettings.memoryMountCount || 3;
            let mountedMemoryContent = '';
            
            for (const chatId of chatSettings.selectedMemoryChats) {
                // 跳过当前聊天
                if (chatId === currentCharacterId) continue;
                
                // 获取该聊天的历史记录
                const chatHistory = chatMessages[chatId] || [];
                if (chatHistory.length === 0) continue;
                
                // 获取最近的几条记录
                const recentMessages = chatHistory.slice(-mountCount);
                if (recentMessages.length === 0) continue;
                
                // 获取聊天对象的名称
                let chatName = '未知聊天';
                let chatType = '单聊';
                
                // 查找单聊角色
                const character = characters.find(c => c.id === chatId);
                if (character) {
                    chatName = character.name;
                    chatType = '单聊';
                } else {
                    // 查找群聊
                    const group = groupChats.find(g => g.id === chatId);
                    if (group) {
                        chatName = group.name;
                        chatType = '群聊';
                    }
                }
                
                // 构建记忆内容
                mountedMemoryContent += `\n\n【${chatType}记忆 - ${chatName}】以下是与${chatName}的最近对话，可以作为背景参考：\n`;
                
                recentMessages.forEach(msg => {
                    let sender = '';
                    let content = msg.content || '';
                    
                    if (msg.sender === 'sent') {
                        sender = '用户';
                    } else if (msg.sender === 'received' || msg.sender === 'ai') {
                        if (chatType === '群聊' && msg.name) {
                            sender = msg.name; // 群聊中的发言者名称
                        } else {
                            sender = chatName; // 单聊中使用角色名称
                        }
                    } else {
                        sender = '系统';
                    }
                    
                    // 处理特殊消息类型
                    if (msg.type === 'voice_message') {
                        content = `[语音消息：${content}]`;
                    } else if (msg.type === 'transfer') {
                        content = `[转账：${msg.amount}元${msg.note ? ` - ${msg.note}` : ''}]`;
                    } else if (msg.type === 'ai_image') {
                        content = `[AI图片：${msg.imageDescription || '无描述'}]`;
                    } else if (msg.isEmoji) {
                        content = `[表情包：${msg.emojiDescription || '表情包'}]`;
                    } else if (msg.type === 'location') {
                        content = `[位置分享：${msg.locationName || '位置信息'}]`;
                    } else if (Array.isArray(content)) {
                        // 处理数组类型的内容（图片+文字）
                        const textPart = content.find(p => p.type === 'text')?.text || '';
                        content = textPart ? `[图片+文字：${textPart}]` : '[图片]';
                    }
                    
                    // 确保content是字符串且不为空
                    if (typeof content !== 'string' || !content.trim()) {
                        content = '[特殊消息]';
                    }
                    
                    mountedMemoryContent += `${sender}：${content}\n`;
                });
            }
            
            if (mountedMemoryContent.trim()) {
                console.log('🧠 成功加载挂载记忆，涉及聊天数:', chatSettings.selectedMemoryChats.length);
                return mountedMemoryContent;
            }
            
            return '';
        }
        
        // 🔥【新增】数据格式转换函数：将现有群聊转换为zhangyu.html兼容格式
        function convertGroupChatToZhangyuFormat(groupChat) {
            if (!groupChat.members) return groupChat;

            // 转换成员数据结构
            const convertedMembers = groupChat.members.map(member => ({
                id: member.id,
                name: member.name,
                persona: member.persona || member.bio, // 🔥【关键】确保使用persona字段
                avatarUrl: member.avatarUrl,
                color: member.color
            }));

            // 确保有settings结构
            if (!groupChat.settings) {
                groupChat.settings = {
                    myPersona: '用户',
                    myNickname: '我'
                };
            }

            return {
                ...groupChat,
                members: convertedMembers
            };
        }

        // 🔥【新增】构建群聊消息历史记录，兼容zhangyu.html格式
        function buildGroupChatMessageHistory(messages, groupChat) {
            if (!messages || !Array.isArray(messages)) return [];

            return messages.map(msg => {
                // 🔥【新增】处理群聊中的系统消息
                if (msg.sender === 'system') {
                    return { role: 'user', content: `[系统提示] ${msg.content}` };
                } else if (msg.sender === 'sent') {
                    // 用户消息：使用群聊设置中的昵称
                    const chatSettings = getCurrentChatSettings();
                    const myNickname = chatSettings.myChatNickname || groupChat.settings?.myNickname || '我';

                    let content;
                    if (msg.type === 'user_photo') {
                        content = `[${myNickname} 发送了一张描述的照片，内容是：'${msg.content}']`;
                    } else if (msg.type === 'voice_message') {
                        content = `[${myNickname} 发送了一条语音，内容是：'${msg.content}']`;
                    } else if (msg.type === 'transfer') {
                        content = `[${msg.senderName}向${msg.receiverName}转账 ${msg.amount}元, 备注: ${msg.note}]`;
                    } else if (msg.meaning) {
                        content = `${myNickname}: [发送了一个表情，意思是: '${msg.meaning}']`;
                    } else {
                        content = `${myNickname}: ${msg.content}`;
                    }

                    // 🔥【修复】处理用户消息的引用信息
                    if (msg.replyTo) {
                        const replyPrefix = `[${myNickname} 回复 ${msg.replyTo.senderName}: "${msg.replyTo.content}"] `;
                        content = replyPrefix + content.replace(`${myNickname}: `, '');
                    }

                    // 🔥【新增】为群聊消息添加ID信息，方便AI引用
                    if (msg.id) {
                        content = `[ID:${msg.id}] ${content}`;
                    }

                    return { role: 'user', content: content };
                } else {
                    // AI消息：根据senderId或name查找发送者
                    const sender = msg.senderName || msg.name || '未知';

                    let content;
                    if (msg.type === 'ai_image') {
                        content = `[${sender} 发送了一张图片]`;
                    } else if (msg.type === 'voice_message') {
                        content = `[${sender} 发送了一条语音，内容是：'${msg.content}']`;
                    } else if (msg.type === 'transfer') {
                        content = `[${msg.senderName}向${msg.receiverName}转账 ${msg.amount}元, 备注: ${msg.note}]`;
                    } else if (msg.meaning) {
                        content = `${sender}: [发送了一个表情，意思是: '${msg.meaning}']`;
                    } else if (Array.isArray(msg.content)) {
                        content = [...msg.content, { type: 'text', text: `${sender}:` }];
                    } else {
                        content = `${sender}: ${msg.content}`;
                    }

                    // 🔥【修复】处理AI消息的引用信息
                    if (msg.replyTo) {
                        const replyPrefix = `[${sender} 回复 ${msg.replyTo.senderName}: "${msg.replyTo.content}"] `;
                        content = replyPrefix + content.replace(`${sender}: `, '');
                    }

                    // 🔥【新增】为群聊消息添加ID信息，方便AI引用
                    if (msg.id) {
                        content = `[ID:${msg.id}] ${content}`;
                    }

                    return { role: 'user', content: content };
                }
            });
        }



        // 🔥【新增】监控localStorage使用情况
        function checkLocalStorageUsage() {
            try {
                let totalSize = 0;
                const items = [];

                for (let key in localStorage) {
                    if (localStorage.hasOwnProperty(key)) {
                        const size = localStorage[key].length;
                        totalSize += size;
                        items.push({ key, size });
                    }
                }

                const totalSizeMB = (totalSize / 1024 / 1024).toFixed(2);
                console.log(`📊 localStorage总使用量: ${totalSizeMB}MB`);

                // 显示最大的几个项目
                items.sort((a, b) => b.size - a.size);
                items.slice(0, 5).forEach(item => {
                    const sizeMB = (item.size / 1024 / 1024).toFixed(2);
                    console.log(`  - ${item.key}: ${sizeMB}MB`);
                });

                // 如果接近5MB限制，发出警告
                if (totalSize > 4 * 1024 * 1024) {
                    console.warn('⚠️ localStorage使用量接近限制，建议清理备份数据');
                }

                return { totalSize, items };
            } catch (error) {
                console.error('检查localStorage使用量失败:', error);
                return { totalSize: 0, items: [] };
            }
        }

        // 🔥【新增】解析群聊AI响应，兼容zhangyu.html格式
        function parseGroupChatAiResponse(aiResponseContent, groupChat) {
            try {
                // 🔥【修复】清理markdown代码块格式
                let cleanContent = aiResponseContent.trim();
                if (cleanContent.startsWith('```json')) {
                    cleanContent = cleanContent.replace(/^```json\s*/, '').replace(/\s*```$/, '');
                } else if (cleanContent.startsWith('```')) {
                    cleanContent = cleanContent.replace(/^```\s*/, '').replace(/\s*```$/, '');
                }

                const messagesArray = JSON.parse(cleanContent);
                if (!Array.isArray(messagesArray)) {
                    console.error('群聊AI响应不是数组格式');
                    return [];
                }

                const processedMessages = [];

                for (const msgData of messagesArray) {
                    if (typeof msgData === 'object' && msgData.name && msgData.message) {
                        // 🔥【关键】zhangyu.html格式的普通消息
                        const member = groupChat.members.find(m => m.name === msgData.name);
                        if (member) {
                            processedMessages.push({
                                id: Date.now() + Math.random(),
                                sender: 'received',
                                content: msgData.message,
                                timestamp: Date.now(),
                                senderId: member.id,
                                senderName: member.name,
                                name: member.name
                            });
                        }
                    } else if (typeof msgData === 'object' && msgData.name && msgData.type === 'ai_image') {
                        // 群聊图片消息
                        const member = groupChat.members.find(m => m.name === msgData.name);
                        if (member) {
                            processedMessages.push({
                                id: Date.now() + Math.random(),
                                sender: 'received',
                                type: 'ai_image',
                                content: msgData.description || 'AI描述的图片',
                                imageDescription: msgData.description,
                                timestamp: Date.now(),
                                senderId: member.id,
                                senderName: member.name,
                                name: member.name
                            });
                        }
                    } else if (typeof msgData === 'object' && msgData.name && msgData.type === 'voice_message') {
                        // 群聊语音消息
                        const member = groupChat.members.find(m => m.name === msgData.name);
                        if (member) {
                            processedMessages.push({
                                id: Date.now() + Math.random(),
                                sender: 'received',
                                type: 'voice_message',
                                content: msgData.content,
                                timestamp: Date.now(),
                                senderId: member.id,
                                senderName: member.name,
                                name: member.name
                            });
                        }
                    } else if (typeof msgData === 'object' && msgData.name && msgData.type === 'emoji') {
                        // 🔥【新增】群聊表情包消息
                        console.log('🔍 [parseGroupChatAiResponse] 检测到群聊表情包:', msgData);

                        const member = groupChat.members.find(m => m.name === msgData.name);
                        if (member) {
                            const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.description);
                            if (matchingEmoji) {
                                console.log('🔍 [parseGroupChatAiResponse] 找到匹配的表情包:', matchingEmoji);

                                processedMessages.push({
                                    id: Date.now() + Math.random(),
                                    sender: 'received',
                                    content: '', // 表情包消息不显示文字内容
                                    image: matchingEmoji.url,
                                    isEmoji: true,
                                    emojiDescription: matchingEmoji.description,
                                    timestamp: Date.now(),
                                    senderId: member.id,
                                    senderName: member.name,
                                    name: member.name
                                });

                                // 添加到最近使用的表情包
                                addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                            } else {
                                console.warn('🔍 [parseGroupChatAiResponse] 找不到匹配的表情包:', msgData.description);

                                // 如果找不到匹配的表情包，发送错误消息
                                processedMessages.push({
                                    id: Date.now() + Math.random(),
                                    sender: 'received',
                                    content: `[表情包"${msgData.description}"不存在]`,
                                    timestamp: Date.now(),
                                    senderId: member.id,
                                    senderName: member.name,
                                    name: member.name
                                });
                            }
                        } else {
                            console.warn('🔍 [parseGroupChatAiResponse] 找不到发送表情包的成员:', msgData.name);
                        }
                    } else if (typeof msgData === 'string') {
                        // 🔥【关键修复】处理普通字符串消息 - 分配给第一个群成员
                        console.log('🔍 [parseGroupChatAiResponse] 检测到字符串消息:', msgData);
                        if (groupChat.members && groupChat.members.length > 0) {
                            const defaultMember = groupChat.members[0]; // 使用第一个成员作为默认发送者
                            processedMessages.push({
                                id: Date.now() + Math.random(),
                                sender: 'received',
                                content: msgData,
                                timestamp: Date.now(),
                                senderId: defaultMember.id,
                                senderName: defaultMember.name,
                                name: defaultMember.name
                            });
                            console.log('🔍 [parseGroupChatAiResponse] 字符串消息分配给:', defaultMember.name);
                        }
                    } else {
                        console.warn('🔍 [parseGroupChatAiResponse] 未识别的消息格式:', msgData);
                    }
                }

                return processedMessages;
            } catch (error) {
                console.error('解析群聊AI响应失败:', error);
                return [];
            }
        }

        // 加载群聊数据 - 使用IndexedDB（包含数据迁移和格式转换）
        async function loadGroupChats() {
            try {
                // 先从IndexedDB加载
                const savedGroupChats = await db.groupChats.toArray();

                if (savedGroupChats.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('groupChats');
                    if (localStorageData) {
                        console.log('检测到localStorage中的群聊数据，开始迁移...');
                        const localGroupChats = JSON.parse(localStorageData);
                        
                        if (localGroupChats.length > 0) {
                            // 🔥【关键修复】确保每个群聊都有必要字段并转换为zhangyu格式
                            const migrationData = localGroupChats.map(group => convertGroupChatToZhangyuFormat({
                                id: group.id || Date.now().toString() + Math.random(),
                                name: group.name,
                                description: group.description || '',
                                members: group.members || [],
                                settings: group.settings || {},
                                createdAt: group.createdAt || new Date().toISOString(),
                                updatedAt: group.updatedAt || new Date().toISOString()
                            }));
                            
                            // 迁移到IndexedDB
                            await db.groupChats.bulkAdd(migrationData);
                            groupChats = migrationData;
                            console.log('群聊数据迁移完成:', groupChats);
                        } else {
                            groupChats = [];
                        }
                    } else {
                        groupChats = [];
                    }
                } else {
                    // 🔥【关键修复】IndexedDB中有数据，转换为zhangyu格式后使用
                    groupChats = savedGroupChats.map(convertGroupChatToZhangyuFormat);
                    console.log('从IndexedDB加载群聊数据（已转换为zhangyu格式）:', groupChats);
                }
            } catch (error) {
                console.error('加载群聊失败:', error);
                // 🔥【优化】如果IndexedDB失败，谨慎回退到localStorage
                const localStorageData = localStorage.getItem('groupChats');
                if (localStorageData) {
                    try {
                        const localData = JSON.parse(localStorageData);
                        // 🔥【新增】检查localStorage数据的大小和有效性
                        if (Array.isArray(localData) && localData.length > 0) {
                            groupChats = localData.map(convertGroupChatToZhangyuFormat);
                            console.log('从localStorage回退加载群聊数据（已转换格式）:', groupChats);

                            // 🔥【优化】尝试重新保存到IndexedDB
                            try {
                                await db.groupChats.bulkAdd(groupChats);
                                console.log('已将localStorage数据重新保存到IndexedDB');
                                // 成功保存后，可以考虑清理localStorage（如果数据过大）
                                const dataSize = localStorageData.length;
                                if (dataSize > 1024 * 1024) { // 超过1MB
                                    localStorage.removeItem('groupChats');
                                    console.log('已清理过大的localStorage备份');
                                }
                            } catch (saveError) {
                                console.warn('重新保存到IndexedDB失败:', saveError);
                            }
                        } else {
                            groupChats = [];
                        }
                    } catch (e) {
                        console.error('群聊数据解析失败:', e);
                        groupChats = [];
                    }
                } else {
                    groupChats = [];
                }
            }
        }
        
        // 显示历史消息设置
        function showHistorySettings() {
            const chatSettings = getCurrentChatSettings();
            const historyCount = chatSettings.historyCount;
            document.getElementById('history-messages-count').value = Math.min(historyCount, 100);
            document.getElementById('custom-history-count').value = historyCount;
            document.getElementById('history-count-display').textContent = historyCount + '回合';

            // 绑定滑块事件
            document.getElementById('history-messages-count').oninput = function() {
                const value = parseInt(this.value);
                document.getElementById('history-count-display').textContent = value + '回合';
                document.getElementById('custom-history-count').value = value;
            };

            // 绑定自定义输入框事件
            document.getElementById('custom-history-count').oninput = function() {
                const value = Math.max(0, Math.min(500, parseInt(this.value) || 0));
                this.value = value;
                if (value <= 100) {
                    document.getElementById('history-messages-count').value = value;
                }
                document.getElementById('history-count-display').textContent = value + '回合';
            };

            showModal('history-settings-modal');
        }
        
        // 保存历史消息设置
        function saveHistorySettings() {
            const chatSettings = getCurrentChatSettings();
            const customValue = parseInt(document.getElementById('custom-history-count').value);
            chatSettings.historyCount = Math.max(0, Math.min(500, customValue || 0));

            // 更新设置界面显示的当前值
            document.getElementById('current-history-count').textContent = chatSettings.historyCount + '回合';

            saveCurrentChatSettings(chatSettings);
            hideModal('history-settings-modal');
            showToast('历史消息设置已保存', 'success');
        }
        
        // 显示头像设置
        function showAvatarSettings() {
            // 加载当前聊天窗口的头像设置
            const chatSettings = getCurrentChatSettings();
            
            // 设置隐藏头像选项
            const hideAvatarsCheckbox = document.getElementById('hide-avatars');
            if (hideAvatarsCheckbox) {
                hideAvatarsCheckbox.checked = chatSettings.hideAvatars || false;
            }
            
            // 设置我的头像预览
            const myAvatarPreview = document.getElementById('my-chat-avatar-preview');
            if (chatSettings.myChatAvatar) {
                myAvatarPreview.style.backgroundImage = `url(${chatSettings.myChatAvatar})`;
                myAvatarPreview.style.backgroundSize = 'cover';
                myAvatarPreview.style.backgroundPosition = 'center';
                myAvatarPreview.innerHTML = '';
            } else {
                myAvatarPreview.style.backgroundImage = 'none';
                myAvatarPreview.innerHTML = '<i class="fas fa-user"></i>';
            }
            
            // 设置对方头像预览 - 显示当前实际使用的头像（优先显示动态头像）
            const aiAvatarPreview = document.getElementById('ai-chat-avatar-preview');
            const currentAiAvatar = chatSettings.aiDynamicAvatar || chatSettings.aiChatAvatar;
            if (currentAiAvatar) {
                aiAvatarPreview.style.backgroundImage = `url(${currentAiAvatar})`;
                aiAvatarPreview.style.backgroundSize = 'cover';
                aiAvatarPreview.style.backgroundPosition = 'center';
                aiAvatarPreview.innerHTML = '';
                
                // 如果是动态头像，添加提示
                if (chatSettings.aiDynamicAvatar) {
                    aiAvatarPreview.title = '当前显示动态头像（角色在聊天中更换的）';
                } else {
                    aiAvatarPreview.title = '当前显示聊天设置头像';
                }
            } else {
                aiAvatarPreview.style.backgroundImage = 'none';
                aiAvatarPreview.innerHTML = '<i class="fas fa-robot"></i>';
                aiAvatarPreview.title = '使用默认头像';
            }
            
            // 绑定文件上传事件
            bindAvatarUploadEvents();
            
            showModal('avatar-settings-modal');
        }
        
        // 显示昵称设置
        function showNicknameSettings() {
            const chatSettings = getCurrentChatSettings();
            document.getElementById('my-chat-nickname').value = chatSettings.myChatNickname || '';
            document.getElementById('ai-chat-nickname').value = chatSettings.aiChatNickname || '';
            showModal('nickname-settings-modal');
        }
        
        // 显示戳一戳后缀设置
        function showPokeSuffixSettings() {
            const chatSettings = getCurrentChatSettings();
            document.getElementById('my-poke-suffix').value = chatSettings.myPokeSuffix || '';
            document.getElementById('ai-poke-suffix').value = chatSettings.aiPokeSuffix || '';
            showModal('poke-suffix-modal');
        }
        
        // 显示聊天背景设置
        function showBackgroundSettings() {
            const backgroundPreview = document.getElementById('chat-background-preview');
            
            // 重置选择状态
            window.selectedChatBackground = undefined;
            
            // 使用currentChatCharacter.background而不是chatSettings.chatBackground
            if (currentChatCharacter && currentChatCharacter.background) {
                backgroundPreview.style.backgroundImage = `url(${currentChatCharacter.background})`;
                backgroundPreview.style.backgroundSize = 'cover';
                backgroundPreview.style.backgroundPosition = 'center';
                backgroundPreview.querySelector('.preview-text').style.display = 'none';
            } else {
                backgroundPreview.style.backgroundImage = 'none';
                backgroundPreview.querySelector('.preview-text').style.display = 'block';
                backgroundPreview.querySelector('.preview-text').textContent = '背景预览';
            }
            
            // 绑定背景上传事件
            document.getElementById('background-upload').onchange = function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        backgroundPreview.style.backgroundImage = `url(${event.target.result})`;
                        backgroundPreview.style.backgroundSize = 'cover';
                        backgroundPreview.style.backgroundPosition = 'center';
                        backgroundPreview.querySelector('.preview-text').style.display = 'none';
                        window.selectedChatBackground = event.target.result;
                    };
                    reader.readAsDataURL(e.target.files[0]);
                }
            };
            
            showModal('background-settings-modal');
        }
        
        // 显示气泡样式设置
        function showBubbleStyleSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // 🔥【新增】检查是否为群聊，显示/隐藏群成员设置按钮
            const groupColorsBtn = document.getElementById('group-member-colors-btn');
            if (currentChatCharacter && currentChatCharacter.isGroup) {
                groupColorsBtn.style.display = 'block';
            } else {
                groupColorsBtn.style.display = 'none';
            }
            
            // 加载当前设置
            const currentStyle = chatSettings.bubbleStyle || 'default';
            document.getElementById('my-bubble-color').value = chatSettings.myBubbleColor || '#007AFF';
            document.getElementById('ai-bubble-color').value = chatSettings.aiBubbleColor || '#f0f0f0';
            
            // 加载分离的透明度设置
            document.getElementById('my-bubble-opacity').value = chatSettings.myBubbleOpacity || '1';
            document.getElementById('my-bubble-opacity-value').textContent = Math.round((chatSettings.myBubbleOpacity || 1) * 100) + '%';
            document.getElementById('ai-bubble-opacity').value = chatSettings.aiBubbleOpacity || '1';
            document.getElementById('ai-bubble-opacity-value').textContent = Math.round((chatSettings.aiBubbleOpacity || 1) * 100) + '%';
            
            // 设置当前选中的样式
            document.querySelectorAll('.bubble-style-option').forEach(option => {
                option.classList.remove('selected');
                if (option.dataset.style === currentStyle) {
                    option.classList.add('selected');
                }
            });
            
            // 绑定样式选择事件
            document.querySelectorAll('.bubble-style-option').forEach(option => {
                option.onclick = function() {
                    document.querySelectorAll('.bubble-style-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    this.classList.add('selected');
                    window.selectedBubbleStyle = this.dataset.style;
                };
            });
            
            // 绑定分离的透明度事件
            document.getElementById('my-bubble-opacity').oninput = function() {
                document.getElementById('my-bubble-opacity-value').textContent = Math.round(this.value * 100) + '%';
            };
            
            document.getElementById('ai-bubble-opacity').oninput = function() {
                document.getElementById('ai-bubble-opacity-value').textContent = Math.round(this.value * 100) + '%';
            };
            
            // 加载气泡大小设置
            document.getElementById('bubble-padding').value = chatSettings.bubblePadding || '12';
            updatePaddingValue(chatSettings.bubblePadding || '12');
            
            // 绑定气泡大小事件
            document.getElementById('bubble-padding').oninput = function() {
                updatePaddingValue(this.value);
            };
            
            window.selectedBubbleStyle = currentStyle;
            showModal('bubble-style-modal');
        }
        
        // 显示定时发布设置
        function showScheduleSettings() {
            const chatSettings = getCurrentChatSettings();
            
            document.getElementById('schedule-enabled').checked = chatSettings.scheduleEnabled || false;
            document.getElementById('schedule-enabled').onchange = function() {
                document.getElementById('schedule-times-group').style.display = this.checked ? 'block' : 'none';
            };
            
            // 触发一次显示状态更新
            document.getElementById('schedule-times-group').style.display = 
                document.getElementById('schedule-enabled').checked ? 'block' : 'none';
            
            // 加载已有的时间点
            renderScheduleTimes();
            
            showModal('schedule-settings-modal');
        }
        
        // 异步函数，用于获取聊天窗口的专属设置
        async function getAsyncChatSettings(characterId = null) {
            // 1. 确定使用哪个角色ID
            const chatId = characterId || (currentChatCharacter ? currentChatCharacter.id : null);
            
            if (!chatId) {
                console.warn("无法获取设置：characterId 和 currentChatCharacter 都未定义，返回空设置");
                return {
                    historyCount: 30,
                    timestampEnabled: true,
                    timestampPosition: 'center',
                    bubbleStyle: 'default',
                    characterStatusEnabled: false
                };
            }
            
            // 2. 【性能优化】首先检查内存中是否已有该聊天的设置
            if (chatSettings[chatId]) {
                return chatSettings[chatId];
            }
            
            // 3. 【核心逻辑】如果内存中没有，则从 IndexedDB 数据库异步查询
                try {
                    const dbSettings = await db.chatSettings.get(chatId);
                    if (dbSettings && dbSettings.settings) {
                    // 查到了！存入内存并返回
                    console.log(`✅ 从数据库成功加载ID为 ${chatId} 的设置`);
                        chatSettings[chatId] = dbSettings.settings;
                    return dbSettings.settings;
                    }
                } catch (error) {
                console.error(`从数据库加载ID为 ${chatId} 的设置失败:`, error);
                // 即使数据库查询失败，也要继续执行，尝试创建默认设置
            }

            // 4. 【处理新聊天】如果数据库里也没有，说明这是一个全新的聊天窗口
            console.log(`🔧 ID为 ${chatId} 的聊天无历史设置，正在创建默认设置...`);
            
            // 定义一份干净的默认设置
            const defaultSettings = {
                        // 记忆相关设置（原本的全局设置改为每个聊天独立）
                historyCount: 30,
                        crossChatMemory: 3,
                        enableDynamicMemory: true,
                        enableMusicMemory: true,
                        memoryMountEnabled: false,
                        memoryMountCount: 3,
                        selectedMemoryChats: [],
                        // 时间感知设置
                        timeAwarenessEnabled: true,
                        // 通话设置
                        aiCallEnabled: true,
                        // 心率监测设置
                        aiHeartrateEnabled: false,
                        // 社交动态设置
                        socialEnabled: false,
                        socialFrequency: 'medium',
                        // 后台互动设置
                        backgroundInteractionEnabled: true,
                        backgroundChatEnabled: true,
                        backgroundMomentsEnabled: true,
                        backgroundChatFrequency: 'low',
                        backgroundMomentsFrequency: 'low',
                        scheduledMomentsEnabled: false,
                        scheduledMomentsTimes: [],
                        // 🔥【关键修复】世界书相关设置
                        worldbookMountEnabled: false,
                        selectedWorldbooks: [],
                        linkedWorldBookIds: [], // 兼容旧版本字段名
                        // 其他原有设置
                        timestampEnabled: true,
                timestampPosition: 'center',
                characterStatusEnabled: false,
                        // 🔥【新增】状态更新频率设置
                        statusUpdateFrequency: 'medium'
            };

            // 5. 将新创建的默认设置存入内存
            chatSettings[chatId] = defaultSettings;

            // 6. 【重要】同时，立即将这份默认设置保存回数据库，为这个新聊天建立档案
            try {
                await db.chatSettings.put({
                    id: chatId,
                    chatId: chatId,
                    settings: defaultSettings
                });
                console.log(`✅ 已为新聊天 ${chatId} 在数据库中创建了默认设置档案`);
                } catch (error) {
                console.error(`为新聊天 ${chatId} 保存默认设置失败:`, error);
            }
            
            // 7. 返回这份全新的默认设置
            return defaultSettings;
        }
        
        // 兼容层 - 同步版本的getCurrentChatSettings
        // 注意：这个函数只会返回内存中的设置或默认设置，不会从数据库加载
        // 用于不方便修改为async/await的地方
        function getCurrentChatSettings() {
            if (!currentChatCharacter) return {};
            
            const chatId = currentChatCharacter.id;
            
            // 如果内存中有设置，直接返回
            if (chatSettings[chatId]) {
                return chatSettings[chatId];
            }
            
            // 如果内存中没有，创建一个默认设置
            // 注意：这里不会保存到数据库，只是临时使用
            // 下次调用异步版本的getCurrentChatSettings时会正确加载/创建设置
            console.warn(`⚠️ 使用了同步版本获取ID为 ${chatId} 的设置，但内存中没有缓存，返回临时默认设置`);
            
            const defaultSettings = {
                historyCount: 30,
                crossChatMemory: 3,
                enableDynamicMemory: true,
                enableMusicMemory: true,
                memoryMountEnabled: false,
                memoryMountCount: 3,
                selectedMemoryChats: [],
                timeAwarenessEnabled: true,
                aiCallEnabled: true,
                aiHeartrateEnabled: false,
                characterStatusEnabled: false,
                socialEnabled: false,
                socialFrequency: 'medium',
                backgroundInteractionEnabled: true,
                backgroundChatEnabled: true,
                backgroundMomentsEnabled: true,
                backgroundChatFrequency: 'low',
                backgroundMomentsFrequency: 'low',
                scheduledMomentsEnabled: false,
                scheduledMomentsTimes: [],
                timestampEnabled: true,
                timestampPosition: 'center',
                aiHeartrateEnabled: false,
                // 🔥【关键修复】添加世界书相关设置
                worldbookMountEnabled: false,
                selectedWorldbooks: [],
                linkedWorldBookIds: [], // 兼容旧版本字段名
                // 🔥【新增】状态更新频率设置
                statusUpdateFrequency: 'medium'
            };
            
            // 同时触发一个异步加载，以便后续使用
            getAsyncChatSettings().then(settings => {
                console.log(`✅ 后台异步加载ID为 ${chatId} 的设置完成`);
            }).catch(error => {
                console.error(`后台异步加载ID为 ${chatId} 的设置失败:`, error);
            });
            
            return defaultSettings;
        }
        
        // 🔥【重构】保存当前聊天的设置 - 完全依赖IndexedDB + 自动保存
        async function saveCurrentChatSettings(settings) {
            if (!currentChatCharacter) return;

            const chatId = currentChatCharacter.id;

            // 🔥【修复】同步更新全局chatSettings
            chatSettings[chatId] = settings;

            try {
                // 立即保存到IndexedDB
                await db.chatSettings.put({
                    id: chatId,
                    chatId: chatId,
                    settings: settings
                });

                console.log(`✅ 聊天设置已保存到IndexedDB (角色: ${chatId})`);

                // 🔥【新增】触发自动保存机制，防止数据丢失
                scheduleAutoSave(chatId);

            } catch (error) {
                console.error('🚨 保存聊天设置到IndexedDB失败:', error);

                // 🔥【紧急备份】只在IndexedDB完全失败时才使用localStorage
                try {
                    console.warn('⚠️ 正在进行紧急备份...');
                    const emergencySettings = {
                        selectedIdentityId: settings.selectedIdentityId,
                        aiChatNickname: settings.aiChatNickname,
                        myChatNickname: settings.myChatNickname,
                        hideAvatars: settings.hideAvatars,
                        bubbleStyle: settings.bubbleStyle,
                        timestampEnabled: settings.timestampEnabled,
                        timestampPosition: settings.timestampPosition
                    };

                    localStorage.setItem(`chatSettings_emergency_${chatId}`, JSON.stringify(emergencySettings));
                    console.log('✅ 紧急备份已保存');
                    showToast('⚠️ 数据库保存失败，已启用紧急备份', 'warning');

                } catch (localError) {
                    console.error('🚨 紧急备份也失败了:', localError);
                    showToast('❌ 设置保存失败！请检查存储空间', 'error');
                }
            }
        }
        

        
        // 显示记忆挂载设置
        async function showMemoryMountSettings() {
            const chatSettings = await getAsyncChatSettings();
            // 加载当前设置
            document.getElementById('memory-mount-enabled').checked = chatSettings.memoryMountEnabled || false;
            document.getElementById('memory-mount-count').value = chatSettings.memoryMountCount || 3;
            document.getElementById('memory-mount-display').textContent = (chatSettings.memoryMountCount || 3) + '条';
            
            // 控制详细设置的显示
            toggleMemoryMountDetails();
            
            // 绑定事件
            document.getElementById('memory-mount-enabled').onchange = toggleMemoryMountDetails;
            document.getElementById('memory-mount-count').oninput = function() {
                document.getElementById('memory-mount-display').textContent = this.value + '条';
            };
            
            // 渲染聊天列表
            renderMemoryMountChatList();
            
            showModal('memory-mount-modal');
        }
        
        // 切换记忆挂载详细设置显示
        function toggleMemoryMountDetails() {
            const enabled = document.getElementById('memory-mount-enabled').checked;
            document.getElementById('memory-mount-details').style.display = enabled ? 'block' : 'none';
            document.getElementById('memory-mount-chats').style.display = enabled ? 'block' : 'none';
            
            // 更新主设置界面显示
            document.getElementById('current-memory-mount').textContent = enabled ? '已开启' : '已关闭';
        }
        
        // 渲染记忆挂载聊天列表
        async function renderMemoryMountChatList() {
            const container = document.getElementById('memory-mount-list');
            container.innerHTML = '';
            
            if (characters.length === 0 && groupChats.length === 0) {
                container.innerHTML = '<p class="empty-mount-chats">暂无可挂载的聊天</p>';
                return;
            }
            
            // 添加单人聊天
            characters.forEach(character => {
                if (currentChatCharacter && character.id === currentChatCharacter.id) return; // 不显示当前聊天
                
                const item = document.createElement('div');
                item.className = 'mount-item';
                item.innerHTML = `
                    <input type="checkbox" id="mount-${character.id}" value="${character.id}" class="mount-checkbox">
                    <div class="mount-avatar-small" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''} display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                        ${character.avatarUrl ? '' : character.name.charAt(0)}
                    </div>
                    <div>
                        <div class="mount-name">${character.name}</div>
                        <div class="mount-type">单聊</div>
                    </div>
                `;
                container.appendChild(item);
            });
            
            // 添加群聊
            groupChats.forEach(group => {
                if (currentChatCharacter && group.id === currentChatCharacter.id) return; // 不显示当前聊天
                
                const item = document.createElement('div');
                item.className = 'mount-item';
                item.innerHTML = `
                    <input type="checkbox" id="mount-${group.id}" value="${group.id}" class="mount-checkbox">
                    <div class="mount-avatar-group">
                        群
                    </div>
                    <div>
                        <div class="mount-name">${group.name}</div>
                                                    <div class="mount-type">群聊 (${group.members ? group.members.length + 1 : 1}人)</div>
                    </div>
                `;
                container.appendChild(item);
            });
            
            // 加载已选择的聊天
            const chatSettings = await getAsyncChatSettings();
            const selectedChats = chatSettings.selectedMemoryChats || [];
            selectedChats.forEach(chatId => {
                const checkbox = document.getElementById(`mount-${chatId}`);
                if (checkbox) checkbox.checked = true;
            });
        }
        
        // 保存记忆挂载设置
        async function saveMemoryMountSettings() {
            const chatSettings = await getAsyncChatSettings();
            chatSettings.memoryMountEnabled = document.getElementById('memory-mount-enabled').checked;
            chatSettings.memoryMountCount = parseInt(document.getElementById('memory-mount-count').value);
            
            // 获取选中的聊天
            const checkboxes = document.querySelectorAll('#memory-mount-list input[type="checkbox"]:checked');
            chatSettings.selectedMemoryChats = Array.from(checkboxes).map(cb => cb.value);
            
            // 更新主设置界面显示
            document.getElementById('current-memory-mount').textContent = chatSettings.memoryMountEnabled ? '已开启' : '已关闭';
            
            await saveCurrentChatSettings(chatSettings);
            hideModal('memory-mount-modal');
            showToast('记忆挂载设置已保存', 'success');
        }
        
        // 保存聊天头像设置
        async function saveChatAvatarSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // 保存隐藏头像设置
            const hideAvatarsCheckbox = document.getElementById('hide-avatars');
            if (hideAvatarsCheckbox) {
                chatSettings.hideAvatars = hideAvatarsCheckbox.checked;
            }
            
            // 🔥【压缩头像】在保存前压缩头像数据
            if (window.selectedMyChatAvatar) {
                chatSettings.myChatAvatar = await compressImage(window.selectedMyChatAvatar, 200, 0.7);
            }
            if (window.selectedAiChatAvatar) {
                chatSettings.aiChatAvatar = await compressImage(window.selectedAiChatAvatar, 200, 0.7);
            }
            
            try {
                await saveCurrentChatSettings(chatSettings);
                hideModal('avatar-settings-modal');
                
                // 刷新聊天界面以显示新头像
                if (currentChatCharacter) {
                    renderChatMessages(currentChatCharacter.id);
                }
                
                showToast('头像设置已保存', 'success');
            } catch (error) {
                console.error('保存头像设置失败:', error);
                showToast('保存失败，存储空间可能不足', 'error');
            }
        }
        
        // 保存昵称设置
        async function saveChatNicknameSettings() {
            const chatSettings = getCurrentChatSettings();
            
            chatSettings.myChatNickname = document.getElementById('my-chat-nickname').value.trim();
            chatSettings.aiChatNickname = document.getElementById('ai-chat-nickname').value.trim();
            
            await saveCurrentChatSettings(chatSettings);
            hideModal('nickname-settings-modal');
            
            // 更新聊天界面标题
            if (currentChatCharacter) {
                let displayTitle = chatSettings.aiChatNickname || currentChatCharacter.name;

                // 🔥【修复】群聊标题显示成员数量
                if (currentChatCharacter.isGroup && currentChatCharacter.members) {
                    const memberCount = currentChatCharacter.members.length + 1; // +1 包括用户自己
                    displayTitle = `${displayTitle}（${memberCount}）`;
                }

                document.getElementById('api-chat-title').textContent = displayTitle;
            }
            
            // 刷新聊天界面
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }
            
            // 🔥【修复】刷新消息列表和联系人列表以显示新昵称
            renderMessageList();
            renderContactList();
            
            showToast('昵称设置已保存', 'success');
        }
        
        // 保存戳一戳后缀设置
        async function savePokeSuffixSettings() {
            const chatSettings = getCurrentChatSettings();
            
            chatSettings.myPokeSuffix = document.getElementById('my-poke-suffix').value.trim();
            chatSettings.aiPokeSuffix = document.getElementById('ai-poke-suffix').value.trim();
            
            await saveCurrentChatSettings(chatSettings);
            hideModal('poke-suffix-modal');
            showToast('戳一戳后缀设置已保存', 'success');
        }
        
        // 保存聊天背景设置
        async function saveChatBackgroundSettings() {
    // 1. 确保有当前聊天角色
    if (!currentChatCharacter) return;
            
    // 2. 根据用户的操作更新背景设置
    // window.selectedChatBackground 在你选择或移除背景时被赋值
    let backgroundToApply;
    
            if (window.selectedChatBackground === null) {
        // 用户点击了"移除背景"
        backgroundToApply = null;
            } else if (window.selectedChatBackground) {
        // 用户选择了新背景
        backgroundToApply = await compressImage(window.selectedChatBackground, 800, 0.8);
    } else {
        // 用户没做任何更改，保持原有设置不变
        backgroundToApply = currentChatCharacter.background;
    }

    // 3. [关键] 立即应用背景设置，这会自动更新currentChatCharacter.background并保存
    await applyChatBackground(backgroundToApply);
    
    // 4. 清理并关闭模态框
    hideModal('background-settings-modal');
    window.selectedChatBackground = undefined; // 清理临时变量
            showToast('聊天背景设置已保存', 'success');
        }
        
        // 移除背景
        function removeBackground() {
            const backgroundPreview = document.getElementById('chat-background-preview');
            backgroundPreview.style.backgroundImage = 'none';
            backgroundPreview.querySelector('.preview-text').style.display = 'block';
            backgroundPreview.querySelector('.preview-text').textContent = '已移除背景';
            window.selectedChatBackground = null;
        }

        // 更新气泡大小显示值
        function updatePaddingValue(value) {
            const paddingValue = document.getElementById('bubble-padding-value');
            if (paddingValue) {
                if (value <= 6) {
                    paddingValue.textContent = '超紧凑';
                } else if (value <= 10) {
                    paddingValue.textContent = '紧凑';
                } else if (value <= 14) {
                    paddingValue.textContent = '中等';
                } else {
                    paddingValue.textContent = '宽松';
                }
            }
        }

        // 保存气泡样式设置
        async function saveBubbleStyleSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // 保存样式选择
            if (window.selectedBubbleStyle) {
                chatSettings.bubbleStyle = window.selectedBubbleStyle;
            }
            
            // 保存颜色设置
            chatSettings.myBubbleColor = document.getElementById('my-bubble-color').value;
            chatSettings.aiBubbleColor = document.getElementById('ai-bubble-color').value;
            
            // 保存分离的透明度设置
            chatSettings.myBubbleOpacity = document.getElementById('my-bubble-opacity').value;
            chatSettings.aiBubbleOpacity = document.getElementById('ai-bubble-opacity').value;
            
            // 保存气泡大小设置
            chatSettings.bubblePadding = document.getElementById('bubble-padding').value;
            
            await saveCurrentChatSettings(chatSettings);

            // 🔥【修复】立即应用气泡样式
            applyBubbleStyle();

            // 🔥【修复】立即更新气泡样式显示
            updateBubbleStyleDisplay();

            hideModal('bubble-style-modal');

            // 刷新聊天界面以应用新设置
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }

            showToast('气泡样式设置已保存', 'success');
        }

        // 显示时间戳设置
        function showTimestampSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // 设置时间戳开关状态
            const timestampEnabled = document.getElementById('timestamp-modal-enabled');
            if (timestampEnabled) {
                timestampEnabled.checked = chatSettings.timestampEnabled !== false; // 默认为true
            }
            
            // 设置时间戳位置选项
            const timestampPosition = chatSettings.timestampPosition || 'center';
            const positionRadios = document.querySelectorAll('input[name="timestamp-position"]');
            positionRadios.forEach(radio => {
                radio.checked = radio.value === timestampPosition;
            });
            
            // 绑定时间戳开关变化事件
            if (timestampEnabled) {
                timestampEnabled.onchange = function() {
                    const optionsGroup = document.getElementById('timestamp-options-group');
                    if (optionsGroup) {
                        optionsGroup.style.display = this.checked ? 'block' : 'none';
                    }
                };
                
                // 触发一次显示状态更新
                const optionsGroup = document.getElementById('timestamp-options-group');
                if (optionsGroup) {
                    optionsGroup.style.display = timestampEnabled.checked ? 'block' : 'none';
                }
            }
            
            showModal('timestamp-settings-modal');
        }

        // 保存时间戳设置
        async function saveTimestampSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // 获取时间戳开关状态
            const timestampEnabled = document.getElementById('timestamp-modal-enabled');
            if (timestampEnabled) {
                chatSettings.timestampEnabled = timestampEnabled.checked;
            }
            
            // 获取选中的时间戳位置
            const selectedPosition = document.querySelector('input[name="timestamp-position"]:checked');
            if (selectedPosition) {
                chatSettings.timestampPosition = selectedPosition.value;
            }
            
            await saveCurrentChatSettings(chatSettings);
            hideModal('timestamp-settings-modal');
            
            // 重新渲染聊天消息以应用新的时间戳设置
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }
            
            showToast('时间戳设置已保存', 'success');
        }

        // 🔥【新增】群成员气泡颜色设置功能
        function showGroupMemberColorSettings() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) {
                showToast('只有群聊可以设置成员气泡颜色', 'warning');
                return;
            }
            
            // 🔥【新增】先关闭气泡样式设置窗口，避免层级遮挡
            hideModal('bubble-style-modal');
            
            const container = document.getElementById('group-member-colors-list');
            container.innerHTML = '';
            
            const chatSettings = getCurrentChatSettings();
            const memberColors = chatSettings.memberBubbleColors || {};
            
            // 获取群成员列表
            const group = groupChats.find(g => g.id === currentChatCharacter.id);
            console.log('当前群聊:', currentChatCharacter);
            console.log('找到的群聊:', group);
            console.log('群聊成员:', group?.members);
            
            if (!group || !group.members || group.members.length === 0) {
                container.innerHTML = '<p class="text-center-gray">该群聊暂无成员。请先在群聊信息中添加成员。</p>';
                showModal('group-member-colors-modal');
                return;
            }
            
            // 为每个群成员创建颜色设置项
            group.members.forEach(member => {
                // 兼容不同的成员数据结构
                const memberId = typeof member === 'string' ? member : member.id;
                const character = characters.find(c => c.id === memberId);
                if (!character) {
                    console.log('找不到角色:', memberId, '所有角色:', characters.map(c => ({id: c.id, name: c.name})));
                    return;
                }
                
                const memberColor = memberColors[memberId] || '#f0f0f0';
                
                const memberItem = document.createElement('div');
                memberItem.className = 'setting-item';
                memberItem.innerHTML = `
                    <div class="setting-left">
                        <div class="setting-label" style="display: flex; align-items: center; gap: 8px;">
                            <div class="character-avatar" style="width: 24px; height: 24px; background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''} display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 12px; border-radius: 50%;">
                                ${character.avatarUrl ? '' : character.name.charAt(0)}
                            </div>
                            ${character.name}
                        </div>
                        <div class="setting-desc">设置 ${character.name} 的专属气泡颜色</div>
                    </div>
                    <div class="setting-right">
                        <input type="color" id="member-color-${memberId}" class="color-input" value="${memberColor}" style="width: 40px; height: 30px;">
                    </div>
                `;
                
                container.appendChild(memberItem);
            });
            
            showModal('group-member-colors-modal');
        }
        
        function saveGroupMemberColors() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            
            const chatSettings = getCurrentChatSettings();
            if (!chatSettings.memberBubbleColors) {
                chatSettings.memberBubbleColors = {};
            }
            
            // 获取群成员列表
            const group = groupChats.find(g => g.id === currentChatCharacter.id);
            if (!group || !group.members) return;
            
            // 保存每个成员的颜色设置
            group.members.forEach(member => {
                // 兼容不同的成员数据结构
                const memberId = typeof member === 'string' ? member : member.id;
                const colorInput = document.getElementById(`member-color-${memberId}`);
                if (colorInput) {
                    chatSettings.memberBubbleColors[memberId] = colorInput.value;
                }
            });
            
            saveCurrentChatSettings(chatSettings);
            hideModal('group-member-colors-modal');
            
            // 刷新聊天界面以应用新颜色
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }
            
            showToast('群成员气泡颜色已保存', 'success');
        }
        
        // 头像上传处理函数
        function avatarUploadHandler(e) {
            console.log('avatar-upload change事件被触发');
            if (e.target.files && e.target.files[0]) {
                const file = e.target.files[0];
                
                console.log('选择了文件:', file.name, '大小:', file.size, 'bytes', '类型:', file.type);
                
                // 检查文件类型
                if (!file.type.startsWith('image/')) {
                    alert('请选择图片文件');
                    e.target.value = ''; // 清空选择
                    return;
                }
                
                // 检查文件大小 (限制为5MB)
                if (file.size > 5 * 1024 * 1024) {
                    alert('图片文件过大，请选择小于5MB的图片');
                    e.target.value = ''; // 清空选择
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const avatarPreview = document.getElementById('avatar-preview');
                        const avatarPreviewText = document.getElementById('avatar-preview-text');
                        
                        console.log('文件读取成功，开始设置预览');
                        
                        if (!avatarPreview) {
                            console.error('找不到avatar-preview元素');
                            alert('找不到头像预览元素');
                            return;
                        }
                        
                        // 添加has-image类来覆盖默认背景
                        avatarPreview.classList.add('has-image');
                        
                        // 强制设置背景图片并清除所有其他背景样式
                        avatarPreview.style.setProperty('background', `url(${event.target.result})`, 'important');
                        avatarPreview.style.setProperty('background-size', 'cover', 'important');
                        avatarPreview.style.setProperty('background-position', 'center', 'important');
                        avatarPreview.style.setProperty('background-repeat', 'no-repeat', 'important');
                        
                        // 隐藏文字
                        if (avatarPreviewText) {
                            avatarPreviewText.style.display = 'none';
                        }
                        
                        // 存储图片数据用于后续保存
                        window.selectedAvatarData = event.target.result;
                        
                        // 验证样式是否正确设置
                        console.log('头像预览UI更新完成，背景图片已设置');
                        console.log('当前avatar-preview的样式:', {
                            background: avatarPreview.style.background,
                            backgroundSize: avatarPreview.style.backgroundSize,
                            backgroundPosition: avatarPreview.style.backgroundPosition,
                            className: avatarPreview.className
                        });
                        
                        console.log('头像预览设置成功，图片数据已存储');
                    } catch (error) {
                        console.error('设置头像预览时发生错误:', error);
                        alert('设置头像预览失败，请重试: ' + error.message);
                    }
                };
                
                reader.onerror = function() {
                    console.error('文件读取失败');
                    alert('图片读取失败，请重试');
                    e.target.value = ''; // 清空选择
                };
                
                reader.readAsDataURL(file);
            } else {
                console.log('没有选择文件或files为空');
            }
        }
        
        // 加载自定义表情包 - 使用IndexedDB（包含数据迁移）
        async function loadCustomEmojis() {
            try {
                const savedCustomEmojis = await db.customEmojis.toArray();
                
                if (savedCustomEmojis.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('customEmojis');
                    if (localStorageData) {
                        console.log('检测到localStorage中的自定义表情包数据，开始迁移...');
                        const localEmojis = JSON.parse(localStorageData);
                        
                        if (localEmojis.length > 0) {
                            await db.customEmojis.bulkAdd(localEmojis);
                        }
                        
                        customEmojis = localEmojis;
                        console.log('自定义表情包迁移完成:', customEmojis);
                    } else {
                        customEmojis = [];
                    }
                } else {
                    customEmojis = savedCustomEmojis;
                    console.log('从IndexedDB加载自定义表情包:', customEmojis);
                }
                
                // 🔧【修复】recentEmojis也从IndexedDB加载，彻底解决localStorage问题
                const savedRecentEmojis = await db.recentEmojis.orderBy('lastUsed').reverse().toArray();
                if (savedRecentEmojis.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localRecentEmojis = localStorage.getItem('recentEmojis');
                    if (localRecentEmojis) {
                        console.log('检测到localStorage中的recentEmojis数据，开始迁移...');
                        const localRecents = JSON.parse(localRecentEmojis);
                        
                        if (localRecents.length > 0) {
                            // 限制为10个
                            const limitedRecents = localRecents.slice(0, 10);
                            const recentEmojisWithId = limitedRecents.map((emoji, index) => ({
                                id: index + 1,
                                url: emoji.url,
                                description: emoji.description || '表情包',
                                lastUsed: Date.now() - index * 1000
                            }));
                            await db.recentEmojis.bulkAdd(recentEmojisWithId);
                            recentEmojis = limitedRecents;
                            
                            // 清理localStorage
                            localStorage.removeItem('recentEmojis');
                            console.log('recentEmojis迁移完成并清理localStorage');
                        } else {
                            recentEmojis = [];
                        }
                    } else {
                        recentEmojis = [];
                    }
                } else {
                    // 从IndexedDB转换回原格式
                    recentEmojis = savedRecentEmojis.map(item => ({
                        url: item.url,
                        description: item.description
                    }));
                    console.log('从IndexedDB加载recentEmojis:', recentEmojis);
                }
            } catch (error) {
                console.error('加载自定义表情包失败:', error);
                // 如果IndexedDB失败，尝试从localStorage加载
                const localStorageData = localStorage.getItem('customEmojis');
                if (localStorageData) {
                    customEmojis = JSON.parse(localStorageData);
                    console.log('从localStorage备份加载自定义表情包:', customEmojis);
                } else {
                    customEmojis = [];
                }
                
                // 尝试从IndexedDB加载recentEmojis
                try {
                    const savedRecentEmojis = await db.recentEmojis.orderBy('lastUsed').reverse().toArray();
                    if (savedRecentEmojis.length > 0) {
                        recentEmojis = savedRecentEmojis.map(item => ({
                            url: item.url,
                            description: item.description
                        }));
                    } else {
                        recentEmojis = [];
                    }
                } catch (dbError) {
                    // 如果IndexedDB失败，尝试从localStorage加载
                    const localRecentEmojis = localStorage.getItem('recentEmojis');
                    if (localRecentEmojis) {
                        recentEmojis = JSON.parse(localRecentEmojis);
                    } else {
                        recentEmojis = [];
                    }
                }
            }
        }
        
        // 保存自定义表情包 - 使用IndexedDB
        async function saveCustomEmojis() {
            try {
                // 🔥【安全修复】使用事务确保原子操作
                await db.transaction('rw', db.customEmojis, async () => {
                    await db.customEmojis.clear();
                    if (customEmojis.length > 0) {
                        await db.customEmojis.bulkAdd(customEmojis);
                    }
                });
                
                // 🔧【修复】将recentEmojis也迁移到IndexedDB，彻底解决localStorage问题
                try {
                    // 限制最近使用表情包数量为10个
                    const maxRecentEmojis = 10;
                    if (recentEmojis.length > maxRecentEmojis) {
                        recentEmojis = recentEmojis.slice(0, maxRecentEmojis);
                    }
                    
                    // 🔥【安全修复】将recentEmojis也保存到IndexedDB，使用事务
                    await db.transaction('rw', db.recentEmojis, async () => {
                        await db.recentEmojis.clear();
                        if (recentEmojis.length > 0) {
                            const recentEmojisWithId = recentEmojis.map((emoji, index) => ({
                                id: index + 1,
                                url: emoji.url,
                                description: emoji.description || '表情包',
                                lastUsed: Date.now() - index * 1000 // 确保顺序
                            }));
                            await db.recentEmojis.bulkAdd(recentEmojisWithId);
                        }
                    });
                    
                    // 清理localStorage中的旧数据（一次性迁移）
                    if (localStorage.getItem('recentEmojis')) {
                        localStorage.removeItem('recentEmojis');
                        console.log('已将recentEmojis迁移到IndexedDB并清理localStorage');
                    }
                } catch (dbError) {
                    console.error('IndexedDB存储失败:', dbError);
                    showToast('❌ 表情包数据存储失败', 'error');
                }
            } catch (error) {
                console.error('保存自定义表情包失败:', error);
                showToast('❌ 表情包保存失败', 'error');
            }
        }
        
        // 显示自定义表情包面板
        function showCustomEmojiPanel() {
            const panel = document.getElementById('custom-emoji-panel');
            const isVisible = panel.style.display === 'block';
            
            if (isVisible) {
                panel.style.display = 'none';
                document.removeEventListener('click', hideCustomEmojiPanel);
            } else {
                panel.style.display = 'block';
                renderEmojiGrid();
                
                // 点击其他地方关闭面板
                setTimeout(() => {
                    document.addEventListener('click', hideCustomEmojiPanel);
                }, 100);
            }
        }
        
        // 隐藏自定义表情包面板
        function hideCustomEmojiPanel(e) {
            const panel = document.getElementById('custom-emoji-panel');
            
            // 如果没有传递事件参数，直接隐藏面板
            if (!e) {
                if (panel) {
                    panel.style.display = 'none';
                    document.removeEventListener('click', hideCustomEmojiPanel);
                }
                return;
            }
            
            const emojiBtn = e.target.closest('.chat-action-btn');
            
            if (panel && !panel.contains(e.target) && !emojiBtn) {
                panel.style.display = 'none';
                document.removeEventListener('click', hideCustomEmojiPanel);
            }
        }
        
        // 渲染表情包网格
        function renderEmojiGrid() {
            const grid = document.getElementById('emoji-grid');
            grid.innerHTML = '';
            
            let emojisToShow = [];
            
            if (currentEmojiTab === 'recent') {
                emojisToShow = recentEmojis;
            } else if (currentEmojiTab === 'custom') {
                emojisToShow = customEmojis;
            }
            
            // 添加表情包
            emojisToShow.forEach((emoji, index) => {
                const emojiItem = document.createElement('div');
                emojiItem.className = 'custom-emoji-item';
                emojiItem.style.backgroundImage = emoji.url && emoji.url !== 'undefined' ? `url(${emoji.url})` : 'none';
                emojiItem.onclick = () => sendEmojiMessage(emoji);
                
                // 为自定义表情包和最近使用表情包添加删除按钮
                if (currentEmojiTab === 'custom' || currentEmojiTab === 'recent') {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'emoji-delete-btn';
                    deleteBtn.innerHTML = '×';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        if (currentEmojiTab === 'custom') {
                        deleteCustomEmoji(index);
                        } else if (currentEmojiTab === 'recent') {
                            deleteRecentEmoji(index);
                        }
                    };
                    emojiItem.appendChild(deleteBtn);
                }
                
                grid.appendChild(emojiItem);
            });
            
            // 如果是自定义标签页，添加上传按钮
            if (currentEmojiTab === 'custom') {
                const uploadItem = document.createElement('div');
                uploadItem.className = 'custom-emoji-item placeholder';
                uploadItem.innerHTML = '+';
                uploadItem.onclick = () => document.getElementById('emoji-upload').click();
                grid.appendChild(uploadItem);
            }
            
            // 如果没有表情包，显示提示
            if (emojisToShow.length === 0) {
                const emptyMsg = document.createElement('div');
                emptyMsg.className = 'empty-emoji-grid';
                
                                                if (currentEmojiTab === 'recent') {
                                    emptyMsg.textContent = '还没有使用过表情包';
                                } else {
                                    emptyMsg.textContent = '还没有表情包，点击+号添加';
                                }
                
                grid.appendChild(emptyMsg);
            }
        }
        
        // 发送表情包消息
        function sendEmojiMessage(emoji) {
            console.log('🎭 发送表情包:', emoji);
            
            if (!currentChatCharacter) return;
            
            // 添加到最近使用
            addToRecentEmojis(emoji);
            
            // 🔥【修复】表情包消息只显示图片，不显示文字内容
            const messageId = Date.now().toString();
            const emojiMessage = {
                id: messageId,
                sender: 'sent',
                content: '', // 表情包消息不显示文字内容
                image: emoji.url,
                isEmoji: true,
                emojiDescription: emoji.description || '自定义表情包',
                timestamp: Date.now()
            };
            
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            
            chatMessages[currentChatCharacter.id].push(emojiMessage);
            saveChatMessages();
            
            // 渲染消息
            renderChatMessages(currentChatCharacter.id);
            
            // 🔥【新增】触发角色状态更新
            triggerStatusUpdateAfterMessage(currentChatCharacter.id);
            
            // 隐藏表情包面板
            hideCustomEmojiPanel();
            
            // 设置待回复消息，支持智能回复按钮
            pendingUserMessage = emojiMessage;
            
            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = '点击获取AI回复';
            }
            
            // 注释掉自动回复，改为手动回复模式
            // setTimeout(() => {
            //     sendAIEmojiResponse(emoji);
            // }, 1000 + Math.random() * 2000);
        }
        
        // 添加到最近使用的表情包
        async function addToRecentEmojis(emoji) {
            // 移除已存在的相同表情包
            recentEmojis = recentEmojis.filter(e => e.url !== emoji.url);
            
            // 添加到开头
            recentEmojis.unshift(emoji);
            
            // 限制最近使用数量为20个
            if (recentEmojis.length > 20) {
                recentEmojis = recentEmojis.slice(0, 20);
            }
            
            await saveCustomEmojis();
        }
        
        // 检测当前模型是否支持视觉功能
        function isVisionModelSupported() {
            // 支持视觉的模型列表
            const visionModels = [
                // OpenAI GPT系列
                'gpt-4-vision',
                'gpt-4o',
                'gpt-4-turbo',
                'gpt-4o-mini',
                
                // Google Gemini系列
                'gemini-1.5-pro',
                'gemini-1.5-flash',
                'gemini-2.0-flash',
                'gemini-2.5-pro',
                'gemini-2.5-flash',
                'gemini-exp',
                'gemini-pro-vision',
                
                // Anthropic Claude系列
                'claude-3-opus',
                'claude-3-sonnet',
                'claude-3-haiku',
                'claude-3.5-sonnet',
                'claude-3.5-haiku',
                
                // 国产模型
                'qwen-vl',
                'qwen2-vl',
                'yi-vision',
                'glm-4v',
                'internvl',
                'cogvlm',
                
                // 其他模型
                'llava',
                'moondream',
                'phi-3-vision'
            ];
            
            const currentModel = apiSettings.model?.toLowerCase() || '';
            
            // 检查当前模型是否包含任何支持视觉的模型名称
            const isVisionSupported = visionModels.some(model => currentModel.includes(model.toLowerCase()));
            
            // 输出调试信息
            console.log('当前模型:', currentModel);
            console.log('是否支持视觉:', isVisionSupported);
            
            return isVisionSupported;
        }
        
        // 注释：AI对表情包的自动回复功能已移除，现在使用手动回复模式
        // 表情包和图片都通过智能回复按钮来触发AI回复
        
        // 删除自定义表情包
        function deleteCustomEmoji(index) {
            if (confirm('确定要删除这个表情包吗？')) {
                customEmojis.splice(index, 1);
                saveCustomEmojis();
                renderEmojiGrid();
            }
        }
        
        // 删除最近使用的表情包
        function deleteRecentEmoji(index) {
            if (confirm('确定要从最近使用中删除这个表情包吗？')) {
                recentEmojis.splice(index, 1);
                saveCustomEmojis(); // 🔧【修复】现在使用IndexedDB保存
                renderEmojiGrid();
            }
        }
        
        // 初始化表情包上传功能
        function initializeEmojiUpload() {
            const emojiInput = document.getElementById('emoji-upload');
            if (emojiInput) {
                emojiInput.addEventListener('change', handleEmojiUpload);
            }
            
            // 绑定标签页切换事件
            document.querySelectorAll('.emoji-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    // 移除所有active类
                    document.querySelectorAll('.emoji-tab').forEach(t => t.classList.remove('active'));
                    // 添加当前active类
                    this.classList.add('active');
                    
                    // 切换当前标签页
                    currentEmojiTab = this.dataset.tab;
                    renderEmojiGrid();
                });
            });
        }
        
        // 切换工具面板显示/隐藏
        function toggleToolsPanel() {
            const panel = document.getElementById('tools-panel');
            const toggleBtn = document.getElementById('toggle-tools-btn');
            const emojiPanel = document.getElementById('custom-emoji-panel');
            
            if (!panel || !toggleBtn) return;
            
            const isVisible = panel.style.display === 'block';
            
            if (isVisible) {
                // 隐藏工具面板
                hideToolsPanel();
            } else {
                // 显示工具面板
                showToolsPanel();
                
                // 隐藏表情包面板
                if (emojiPanel) {
                    emojiPanel.style.display = 'none';
                }
                
                // 点击其他地方关闭面板
                setTimeout(() => {
                    document.addEventListener('click', handleToolsPanelOutsideClick);
                }, 100);
            }
        }
        
        // 显示工具面板
        function showToolsPanel() {
            const panel = document.getElementById('tools-panel');
            const toggleBtn = document.getElementById('toggle-tools-btn');
            
            if (panel) {
                panel.style.display = 'block';
                panel.style.animation = 'toolsPanelSlideUp 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)';
            }
            
            if (toggleBtn) {
                toggleBtn.classList.add('active');
            }
        }
        
        // 隐藏工具面板
        function hideToolsPanel() {
            const panel = document.getElementById('tools-panel');
            const toggleBtn = document.getElementById('toggle-tools-btn');
            
            if (panel) {
                panel.style.display = 'none';
            }
            
            if (toggleBtn) {
                toggleBtn.classList.remove('active');
            }
            
            // 移除点击外部关闭的事件监听器
            document.removeEventListener('click', handleToolsPanelOutsideClick);
        }
        
        // 处理工具面板外部点击事件
        function handleToolsPanelOutsideClick(e) {
            const panel = document.getElementById('tools-panel');
            const toggleBtn = document.getElementById('toggle-tools-btn');
            
            // 如果点击的是工具面板内部或触发按钮，不关闭面板
            if (panel && !panel.contains(e.target) && 
                toggleBtn && !toggleBtn.contains(e.target)) {
                hideToolsPanel();
            }
        }
        
        // 处理表情包上传
        function handleEmojiUpload(e) {
            const files = e.target.files;
            if (!files || files.length === 0) return;
            
            Array.from(files).forEach(file => {
                if (!file.type.startsWith('image/')) {
                    alert('请选择图片文件');
                    return;
                }
                
                // 检查GIF格式，提醒用户可能的问题
                if (file.type === 'image/gif') {
                    const confirmed = confirm('检测到GIF格式的表情包！\n\n⚠️ 注意事项：\n• AI可以发送这个GIF动图\n• 但Gemini API无法识别GIF内容\n• 重新生成功能可能失效\n• 建议使用静态图片格式\n\n是否仍要上传这个GIF表情包？');
                    if (!confirmed) {
                        return;
                    }
                }
                
                if (file.size > 5 * 1024 * 1024) {
                    alert('图片文件过大，请选择小于5MB的图片');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    // 弹出描述输入框
                    const description = prompt('请为这个表情包添加描述（推荐！帮助AI更好地理解表情包内容）:\n\n例如：\n• "笑哭的表情"\n• "握拳加油的动作"\n• "写着OMG的表情包"\n• "愤怒的猫咪图片"', '');
                    
                    const emoji = {
                        id: Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9),
                        url: event.target.result,
                        description: description || '表情包',
                        addedAt: new Date().toISOString()
                    };
                    
                    customEmojis.push(emoji);
                    saveCustomEmojis();
                    
                    // 如果当前在自定义标签页，重新渲染
                    if (currentEmojiTab === 'custom') {
                        renderEmojiGrid();
                    }
                };
                
                reader.readAsDataURL(file);
            });
            
            // 清空文件输入
            e.target.value = '';
        }
        
        // 判断颜色是否为浅色
        function isLightColor(color) {
            // 将颜色转换为RGB值
            let r, g, b;
            
            if (color.startsWith('#')) {
                // 十六进制颜色
                const hex = color.slice(1);
                if (hex.length === 3) {
                    r = parseInt(hex[0] + hex[0], 16);
                    g = parseInt(hex[1] + hex[1], 16);
                    b = parseInt(hex[2] + hex[2], 16);
                } else {
                    r = parseInt(hex.substr(0, 2), 16);
                    g = parseInt(hex.substr(2, 2), 16);
                    b = parseInt(hex.substr(4, 2), 16);
                }
            } else if (color.startsWith('rgb')) {
                // RGB颜色
                const matches = color.match(/\d+/g);
                if (matches && matches.length >= 3) {
                    r = parseInt(matches[0]);
                    g = parseInt(matches[1]);
                    b = parseInt(matches[2]);
                }
            } else {
                // 默认为深色
                return false;
            }
            
            // 计算亮度
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            return brightness > 128;
        }
        
        // 更新气泡预览
        function updateBubblePreview() {
            const myColor = document.getElementById('my-bubble-color')?.value || '#007AFF';
            const aiColor = document.getElementById('ai-bubble-color')?.value || '#f0f0f0';
            const myOpacity = document.getElementById('my-bubble-opacity')?.value || '1';
            const aiOpacity = document.getElementById('ai-bubble-opacity')?.value || '1';
            
            // 更新预览气泡
            const demoMyBubble = document.getElementById('demo-my-bubble');
            const demoAiBubble = document.getElementById('demo-ai-bubble');
            
            if (demoMyBubble) {
                // 使用rgba背景色而不是opacity
                const transparentMyColor = convertColorWithOpacity(myColor, myOpacity);
                demoMyBubble.style.backgroundColor = transparentMyColor;
                demoMyBubble.style.color = isLightColor(myColor) ? '#333' : '#fff';
            }
            
            if (demoAiBubble) {
                // 使用rgba背景色而不是opacity
                const transparentAiColor = convertColorWithOpacity(aiColor, aiOpacity);
                demoAiBubble.style.backgroundColor = transparentAiColor;
                demoAiBubble.style.color = isLightColor(aiColor) ? '#333' : '#fff';
            }
            
            // 更新颜色预览
            const myPreview = document.getElementById('my-bubble-preview');
            const aiPreview = document.getElementById('ai-bubble-preview');
            
            if (myPreview) {
                // 使用rgba背景色而不是opacity
                const transparentMyColor = convertColorWithOpacity(myColor, myOpacity);
                myPreview.style.backgroundColor = transparentMyColor;
                myPreview.textContent = '我的气泡';
            }
            
            if (aiPreview) {
                // 使用rgba背景色而不是opacity
                const transparentAiColor = convertColorWithOpacity(aiColor, aiOpacity);
                aiPreview.style.backgroundColor = transparentAiColor;
                aiPreview.textContent = '对方气泡';
            }
        }
        
        // 绑定头像上传事件
        function bindAvatarUploadEvents() {
            // 我的头像上传
            const myAvatarUpload = document.getElementById('my-chat-avatar-upload');
            if (myAvatarUpload) {
                myAvatarUpload.onchange = function(e) {
                    if (e.target.files && e.target.files[0]) {
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            const preview = document.getElementById('my-chat-avatar-preview');
                            if (preview) {
                                preview.style.backgroundImage = `url(${event.target.result})`;
                                preview.style.backgroundSize = 'cover';
                                preview.style.backgroundPosition = 'center';
                                preview.innerHTML = '';
                                window.selectedMyChatAvatar = event.target.result;
                            }
                        };
                        reader.readAsDataURL(e.target.files[0]);
                    }
                };
            }
            
            // AI头像上传
            const aiAvatarUpload = document.getElementById('ai-chat-avatar-upload');
            if (aiAvatarUpload) {
                aiAvatarUpload.onchange = function(e) {
                    if (e.target.files && e.target.files[0]) {
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            const preview = document.getElementById('ai-chat-avatar-preview');
                            if (preview) {
                                preview.style.backgroundImage = `url(${event.target.result})`;
                                preview.style.backgroundSize = 'cover';
                                preview.style.backgroundPosition = 'center';
                                preview.innerHTML = '';
                                window.selectedAiChatAvatar = event.target.result;
                            }
                        };
                        reader.readAsDataURL(e.target.files[0]);
                    }
                };
            }
        }
        
        // 初始化头像上传功能
        function initializeAvatarUpload() {
            const avatarInput = document.getElementById('avatar-upload');
            if (!avatarInput) {
                console.error('找不到avatar-upload元素');
                return;
            }
            
            // 移除旧的事件监听器
            avatarInput.removeEventListener('change', avatarUploadHandler);
            
            // 添加新的事件监听器
            avatarInput.addEventListener('change', avatarUploadHandler);
            console.log('头像上传事件监听器已绑定');
        }
        
        // 更新聊天设置界面的显示状态
        async function updateChatSettingsDisplay() {
            if (!currentChatCharacter) {
                console.log("更新聊天设置界面显示：无当前聊天角色，跳过操作");
                return;
            }
            
            const chatSettings = await getAsyncChatSettings();
            
            // 更新历史消息数显示
            const historyCountElement = document.getElementById('current-history-count');
            if (historyCountElement) {
                historyCountElement.textContent = chatSettings.historyCount + '回合';
            }
            
            // 更新记忆挂载显示
            const memoryMountElement = document.getElementById('current-memory-mount');
            if (memoryMountElement) {
                memoryMountElement.textContent = chatSettings.memoryMountEnabled ? '已开启' : '已关闭';
            }
            
            // 更新世界书挂载显示
            updateWorldbookMountDisplay();
            
            // 更新时间感知开关
            const timeAwarenessCheckbox = document.getElementById('time-awareness-enabled');
            if (timeAwarenessCheckbox) {
                timeAwarenessCheckbox.checked = chatSettings.timeAwarenessEnabled;
            }
            
            // 更新通话设置
            const aiCallCheckbox = document.getElementById('ai-call-enabled');
            if (aiCallCheckbox) {
                aiCallCheckbox.checked = chatSettings.aiCallEnabled;
            }
            
            // 更新心率监测设置
            const aiHeartrateCheckbox = document.getElementById('ai-heartrate-enabled');
            if (aiHeartrateCheckbox) {
                aiHeartrateCheckbox.checked = chatSettings.aiHeartrateEnabled;
            }
            
            // 更新角色状态显示设置
            const characterStatusCheckbox = document.getElementById('character-status-enabled');
            if (characterStatusCheckbox) {
                characterStatusCheckbox.checked = chatSettings.characterStatusEnabled || false;
                // 🔥【新增】控制状态更新频率设置的显示
                const statusFrequencySetting = document.getElementById('status-frequency-setting');
                if (statusFrequencySetting) {
                    statusFrequencySetting.style.display = chatSettings.characterStatusEnabled ? 'flex' : 'none';
                }
            }
            
            // 🔥【修复】更新状态更新频率设置 - 从全局设置读取
            const statusUpdateFrequencySelect = document.getElementById('status-update-frequency');
            if (statusUpdateFrequencySelect) {
                const globalFrequency = localStorage.getItem('globalStatusUpdateFrequency') || 'medium';
                statusUpdateFrequencySelect.value = globalFrequency;
            }
            

            
            // 更新后台互动设置
            const backgroundInteractionCheckbox = document.getElementById('background-interaction-enabled');
            if (backgroundInteractionCheckbox) {
                backgroundInteractionCheckbox.checked = chatSettings.backgroundInteractionEnabled;
                // 控制详细设置显示
                const backgroundSettings = document.getElementById('background-interaction-settings');
                if (backgroundSettings) {
                    backgroundSettings.style.display = chatSettings.backgroundInteractionEnabled ? 'block' : 'none';
                }
            }
            
            const backgroundChatFrequencySelect = document.getElementById('background-chat-frequency');
            if (backgroundChatFrequencySelect) {
                backgroundChatFrequencySelect.value = chatSettings.backgroundChatFrequency || 'low';
            }
            
            const backgroundChatEnabledCheckbox = document.getElementById('background-chat-enabled');
            if (backgroundChatEnabledCheckbox) {
                backgroundChatEnabledCheckbox.checked = chatSettings.backgroundChatEnabled === true;
                // 控制频率设置显示 - 需要同时检查总开关和子开关
                const chatFrequencySetting = document.getElementById('chat-frequency-setting');
                if (chatFrequencySetting) {
                    chatFrequencySetting.style.display = (chatSettings.backgroundInteractionEnabled === true && chatSettings.backgroundChatEnabled === true) ? 'block' : 'none';
                }
            }
            
            const backgroundMomentsEnabledCheckbox = document.getElementById('background-moments-enabled');
            if (backgroundMomentsEnabledCheckbox) {
                backgroundMomentsEnabledCheckbox.checked = chatSettings.backgroundMomentsEnabled === true;
                // 控制相关设置显示 - 需要同时检查总开关和子开关
                const momentsEnabled = (chatSettings.backgroundInteractionEnabled === true && chatSettings.backgroundMomentsEnabled === true);
                const momentsFrequencySetting = document.getElementById('moments-frequency-setting');
                const scheduledMomentsSetting = document.getElementById('scheduled-moments-setting');
                const testPublishSetting = document.getElementById('test-publish-setting');
                
                if (momentsFrequencySetting) {
                    momentsFrequencySetting.style.display = momentsEnabled ? 'flex' : 'none';
                }
                if (scheduledMomentsSetting) {
                    scheduledMomentsSetting.style.display = momentsEnabled ? 'flex' : 'none';
                }
                if (testPublishSetting) {
                    testPublishSetting.style.display = momentsEnabled ? 'flex' : 'none';
                }
            }
            
            const backgroundMomentsFrequencySelect = document.getElementById('background-moments-frequency');
            if (backgroundMomentsFrequencySelect) {
                backgroundMomentsFrequencySelect.value = chatSettings.backgroundMomentsFrequency || 'low';
            }
            
            const scheduledMomentsEnabledCheckbox = document.getElementById('scheduled-moments-enabled');
            if (scheduledMomentsEnabledCheckbox) {
                scheduledMomentsEnabledCheckbox.checked = chatSettings.scheduledMomentsEnabled || false;
                // 控制时间设置按钮显示
                const scheduledTimesButton = document.querySelector('button[onclick="showScheduleTimesModal()"]');
                if (scheduledTimesButton) {
                    scheduledTimesButton.style.display = chatSettings.scheduledMomentsEnabled ? 'inline-block' : 'none';
                }
            }
            
            // 更新定时发布时间显示
            updateScheduleTimesDisplay();
            
            // 更新时间戳设置
            const timestampCheckbox = document.getElementById('timestamp-enabled');
            if (timestampCheckbox) {
                timestampCheckbox.checked = chatSettings.timestampEnabled;
            }
            
            // 绑定事件监听器来保存设置变化
            bindChatSettingsEvents();
        }
        
        // 绑定聊天设置的事件监听器
        function bindChatSettingsEvents() {
            // 时间感知开关
            const timeAwarenessCheckbox = document.getElementById('time-awareness-enabled');
            if (timeAwarenessCheckbox) {
                timeAwarenessCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.timeAwarenessEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                };
            }
            
            // 通话设置
            const aiCallCheckbox = document.getElementById('ai-call-enabled');
            if (aiCallCheckbox) {
                aiCallCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.aiCallEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    showToast(`角色主动拨打电话已${this.checked ? '开启' : '关闭'}`, 'success');
                };
            }
            
            // 心率监测设置
            const aiHeartrateCheckbox = document.getElementById('ai-heartrate-enabled');
            if (aiHeartrateCheckbox) {
                aiHeartrateCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.aiHeartrateEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    
                    // 立即更新心率显示状态
                    if (currentChatCharacter) {
                        updateAiHeartrate();
                    }
                    
                    showToast(`角色心率监测已${this.checked ? '开启' : '关闭'}`, 'success');
                };
            }
            

            
            // 后台互动设置
            const backgroundInteractionCheckbox = document.getElementById('background-interaction-enabled');
            if (backgroundInteractionCheckbox) {
                backgroundInteractionCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundInteractionEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    // 显示/隐藏详细设置
                    const backgroundSettings = document.getElementById('background-interaction-settings');
                    if (backgroundSettings) {
                        backgroundSettings.style.display = this.checked ? 'block' : 'none';
                    }

                    // 🔥【修复】当总开关关闭时，同时更新子开关的显示状态
                    if (!this.checked) {
                        // 隐藏所有子功能的设置
                        const chatFrequencySetting = document.getElementById('chat-frequency-setting');
                        const momentsFrequencySetting = document.getElementById('moments-frequency-setting');
                        const scheduledMomentsSetting = document.getElementById('scheduled-moments-setting');
                        const testPublishSetting = document.getElementById('test-publish-setting');

                        if (chatFrequencySetting) chatFrequencySetting.style.display = 'none';
                        if (momentsFrequencySetting) momentsFrequencySetting.style.display = 'none';
                        if (scheduledMomentsSetting) scheduledMomentsSetting.style.display = 'none';
                        if (testPublishSetting) testPublishSetting.style.display = 'none';
                    } else {
                        // 总开关开启时，根据子开关状态显示相应设置
                        const backgroundChatEnabled = chatSettings.backgroundChatEnabled === true;
                        const backgroundMomentsEnabled = chatSettings.backgroundMomentsEnabled === true;

                        const chatFrequencySetting = document.getElementById('chat-frequency-setting');
                        const momentsFrequencySetting = document.getElementById('moments-frequency-setting');
                        const scheduledMomentsSetting = document.getElementById('scheduled-moments-setting');
                        const testPublishSetting = document.getElementById('test-publish-setting');

                        if (chatFrequencySetting) chatFrequencySetting.style.display = backgroundChatEnabled ? 'block' : 'none';
                        if (momentsFrequencySetting) momentsFrequencySetting.style.display = backgroundMomentsEnabled ? 'flex' : 'none';
                        if (scheduledMomentsSetting) scheduledMomentsSetting.style.display = backgroundMomentsEnabled ? 'block' : 'none';
                        if (testPublishSetting) testPublishSetting.style.display = backgroundMomentsEnabled ? 'flex' : 'none';
                    }

                    // 重新初始化后台互动系统
                    initBackgroundInteractionSystem();
                };
            }
            
            const backgroundChatFrequencySelect = document.getElementById('background-chat-frequency');
            if (backgroundChatFrequencySelect) {
                backgroundChatFrequencySelect.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundChatFrequency = this.value;
                    await saveCurrentChatSettings(chatSettings);
                };
            }
            
            const backgroundChatEnabledCheckbox = document.getElementById('background-chat-enabled');
            if (backgroundChatEnabledCheckbox) {
                backgroundChatEnabledCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundChatEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);

                    // 🔥【修复】控制频率设置显示 - 需要同时检查总开关和子开关
                    const chatFrequencySetting = document.getElementById('chat-frequency-setting');
                    if (chatFrequencySetting) {
                        const showSetting = (chatSettings.backgroundInteractionEnabled === true && this.checked);
                        chatFrequencySetting.style.display = showSetting ? 'block' : 'none';
                    }

                    // 重新初始化后台互动系统
                    initBackgroundInteractionSystem();
                };
            }
            
            const backgroundMomentsEnabledCheckbox = document.getElementById('background-moments-enabled');
            if (backgroundMomentsEnabledCheckbox) {
                backgroundMomentsEnabledCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundMomentsEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);

                    // 🔥【修复】控制相关设置显示 - 需要同时检查总开关和子开关
                    const momentsFrequencySetting = document.getElementById('moments-frequency-setting');
                    const scheduledMomentsSetting = document.getElementById('scheduled-moments-setting');
                    const testPublishSetting = document.getElementById('test-publish-setting');

                    const showSettings = (chatSettings.backgroundInteractionEnabled === true && this.checked);

                    if (momentsFrequencySetting) {
                        momentsFrequencySetting.style.display = showSettings ? 'flex' : 'none';
                    }
                    if (scheduledMomentsSetting) {
                        scheduledMomentsSetting.style.display = showSettings ? 'flex' : 'none';
                    }
                    if (testPublishSetting) {
                        testPublishSetting.style.display = showSettings ? 'flex' : 'none';
                    }

                    // 重新初始化后台互动系统
                    initBackgroundInteractionSystem();
                };
            }
            
            const backgroundMomentsFrequencySelect = document.getElementById('background-moments-frequency');
            if (backgroundMomentsFrequencySelect) {
                backgroundMomentsFrequencySelect.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundMomentsFrequency = this.value;
                    await saveCurrentChatSettings(chatSettings);
                    
                    // 重新初始化后台互动系统
                    initBackgroundInteractionSystem();
                };
            }
            
            const scheduledMomentsEnabledCheckbox = document.getElementById('scheduled-moments-enabled');
            if (scheduledMomentsEnabledCheckbox) {
                scheduledMomentsEnabledCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.scheduledMomentsEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    
                    // 控制时间设置按钮显示
                    const scheduledTimesButton = document.querySelector('button[onclick="showScheduleTimesModal()"]');
                    if (scheduledTimesButton) {
                        scheduledTimesButton.style.display = this.checked ? 'inline-block' : 'none';
                    }
                    
                    // 重新初始化定时发布系统
                    initScheduledMomentsSystem();
                };
            }
            
            // 时间戳设置
            const timestampCheckbox = document.getElementById('timestamp-enabled');
            if (timestampCheckbox) {
                timestampCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.timestampEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    // 重新渲染聊天消息
                    if (currentChatCharacter) {
                        renderChatMessages(currentChatCharacter.id);
                    }
                };
            }
            
            // 角色状态显示设置
            const characterStatusCheckbox = document.getElementById('character-status-enabled');
            if (characterStatusCheckbox) {
                characterStatusCheckbox.onchange = async function() {
                    console.log('状态显示开关被点击:', this.checked);
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.characterStatusEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    
                    // 🔥【新增】控制状态更新频率设置的显示
                    const statusFrequencySetting = document.getElementById('status-frequency-setting');
                    if (statusFrequencySetting) {
                        statusFrequencySetting.style.display = this.checked ? 'flex' : 'none';
                    }
                    
                    // 重新渲染聊天界面以显示/隐藏状态
                    if (currentChatCharacter) {
                        renderChatMessages(currentChatCharacter.id);
                        // 更新聊天标题区域的状态显示
                        const headerContainer = document.querySelector('#api-chat-screen .header');
                        if (headerContainer) {
                            renderCharacterStatus(currentChatCharacter.id, headerContainer);
                        }
                    }
                    
                    // 🔥【新增】重启状态更新定时器以应用新设置
                    restartCharacterStatusTimer();
                    
                    showToast(`角色状态显示已${this.checked ? '开启' : '关闭'}`, 'success');
                };
            } else {
                console.warn('找不到character-status-enabled元素');
            }
            
            // 🔥【修复】状态更新频率设置 - 保存为全局设置
            const statusUpdateFrequencySelect = document.getElementById('status-update-frequency');
            if (statusUpdateFrequencySelect) {
                statusUpdateFrequencySelect.onchange = async function() {
                    // 🔥【修复】保存为全局设置，而不是角色专属设置
                    localStorage.setItem('globalStatusUpdateFrequency', this.value);

                    // 同时更新当前角色的设置以保持一致性
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.statusUpdateFrequency = this.value;
                    await saveCurrentChatSettings(chatSettings);

                    // 重启状态更新定时器以应用新频率
                    restartCharacterStatusTimer();

                    const frequencyNames = {
                        'high': '高频',
                        'medium-high': '中高频',
                        'medium': '中频',
                        'medium-low': '中低频',
                        'low': '低频'
                    };

                    showToast(`状态更新频率已设置为${frequencyNames[this.value]}`, 'success');
                };
            }
        }

        // 初始化聊天设置界面
        async function initializeChatSettings() {
            console.log("开始初始化聊天设置界面");
            
            // 初始化UI相关事件
            initChatSettingsUIEvents();
            
            // 如果没有currentChatCharacter，只初始化UI事件，不加载设置
            if (!currentChatCharacter) {
                console.log("初始化聊天设置界面：无当前聊天角色，只初始化UI事件");
                return;
            }
            
            // 更新身份显示
            await updateChatIdentityDisplay();
            
            // 更新气泡样式显示
            await updateBubbleStyleDisplay();
            
            // 更新所有设置显示状态
            await updateChatSettingsDisplay();
            
            // 加载当前聊天的设置
            if (currentChatCharacter) {
                const chatSettings = await getAsyncChatSettings();
            }
        }

        // 初始化聊天设置UI相关事件
        function initChatSettingsUIEvents() {
            

            
            // 🔥【修复】绑定后台互动开关事件 - 这里只处理UI显示，实际保存在另一个地方处理
            const backgroundInteractionCheckbox = document.getElementById('background-interaction-enabled');
            if (backgroundInteractionCheckbox) {
                backgroundInteractionCheckbox.addEventListener('change', function() {
                    const backgroundSettings = document.getElementById('background-interaction-settings');
                    if (backgroundSettings) {
                        backgroundSettings.style.display = this.checked ? 'block' : 'none';
                    }

                    // 🔥【修复】当总开关关闭时，同时隐藏所有子功能的设置
                    if (!this.checked) {
                        const chatFrequencySetting = document.getElementById('chat-frequency-setting');
                        const momentsFrequencySetting = document.getElementById('moments-frequency-setting');
                        const scheduledMomentsSetting = document.getElementById('scheduled-moments-setting');
                        const testPublishSetting = document.getElementById('test-publish-setting');

                        if (chatFrequencySetting) chatFrequencySetting.style.display = 'none';
                        if (momentsFrequencySetting) momentsFrequencySetting.style.display = 'none';
                        if (scheduledMomentsSetting) scheduledMomentsSetting.style.display = 'none';
                        if (testPublishSetting) testPublishSetting.style.display = 'none';

                        clearAllBackgroundTimers();
                    } else {
                        // 如果开启后台互动，重新初始化系统
                        initBackgroundInteractionSystem();
                    }
                });
            }
            
            // 🔥【修复】绑定主动聊天开关事件 - 这里只处理UI显示，实际保存在另一个地方处理
            const backgroundChatCheckbox = document.getElementById('background-chat-enabled');
            if (backgroundChatCheckbox) {
                backgroundChatCheckbox.addEventListener('change', function() {
                    // 🔥【修复】需要检查总开关状态
                    const backgroundInteractionCheckbox = document.getElementById('background-interaction-enabled');
                    const totalSwitchEnabled = backgroundInteractionCheckbox ? backgroundInteractionCheckbox.checked : false;

                    const frequencySetting = document.getElementById('chat-frequency-setting');
                    if (frequencySetting) {
                        const showSetting = (totalSwitchEnabled && this.checked);
                        frequencySetting.style.display = showSetting ? 'block' : 'none';
                    }

                    // 重新初始化后台互动系统
                    if (currentChatCharacter) {
                        initBackgroundInteractionSystem();
                    }
                });
            }
            
            // 🔥【修复】绑定主动发动态开关事件 - 这里只处理UI显示，实际保存在另一个地方处理
            const backgroundMomentsCheckbox = document.getElementById('background-moments-enabled');
            if (backgroundMomentsCheckbox) {
                backgroundMomentsCheckbox.addEventListener('change', function() {
                    // 🔥【修复】需要检查总开关状态
                    const backgroundInteractionCheckbox = document.getElementById('background-interaction-enabled');
                    const totalSwitchEnabled = backgroundInteractionCheckbox ? backgroundInteractionCheckbox.checked : false;

                    const showSettings = (totalSwitchEnabled && this.checked);

                    const frequencySetting = document.getElementById('moments-frequency-setting');
                    const scheduledMomentsSetting = document.getElementById('scheduled-moments-setting');
                    const testPublishSetting = document.getElementById('test-publish-setting');

                    if (frequencySetting) frequencySetting.style.display = showSettings ? 'flex' : 'none';
                    if (scheduledMomentsSetting) scheduledMomentsSetting.style.display = showSettings ? 'flex' : 'none';
                    if (testPublishSetting) testPublishSetting.style.display = showSettings ? 'flex' : 'none';

                    // 重新初始化后台互动系统
                    if (currentChatCharacter) {
                        initBackgroundInteractionSystem();
                    }
                });
            }
            
            // 主动拨打电话开关事件已在上面的 initChatSettingsUIEvents 中处理
            
            // 绑定戳一戳功能开关事件
            const pokeEnabledCheckbox = document.getElementById('poke-enabled');
            if (pokeEnabledCheckbox) {
                pokeEnabledCheckbox.addEventListener('change', function() {
                    const pokeSuffixSettings = document.getElementById('poke-suffix-settings');
                    if (pokeSuffixSettings) {
                        pokeSuffixSettings.style.display = this.checked ? 'block' : 'none';
                    }
                });
            }
            
            // 绑定选择模式按钮事件
            const selectionCancelBtn = document.getElementById('selection-cancel-btn');
            const selectionDeleteBtn = document.getElementById('selection-delete-btn');
            
            if (selectionCancelBtn) {
                selectionCancelBtn.addEventListener('click', exitMessageSelectionMode);
            }
            
            if (selectionDeleteBtn) {
                selectionDeleteBtn.addEventListener('click', function() {
                    if (selectedMessages.size === 0) return;
                    
                    deleteSelectedMessages();
                });
            }
        }
        
        // 戳一戳功能
        function pokeCharacter(characterId) {
            if (!currentChatCharacter || currentChatCharacter.id !== characterId) {
                return;
            }
            
            const chatSettings = getCurrentChatSettings();
            const pokeSuffix = chatSettings.myPokeSuffix || '';
            const characterName = chatSettings.aiChatNickname || currentChatCharacter.name;
            
            // 创建戳一戳系统消息
            const pokeMessage = {
                id: Date.now().toString(),
                sender: 'system',
                content: `你戳了戳${characterName}${pokeSuffix}`,
                timestamp: Date.now(),
                isPoke: true
            };
            
            // 添加到聊天记录
            if (!chatMessages[characterId]) {
                chatMessages[characterId] = [];
            }
            
            chatMessages[characterId].push(pokeMessage);
            saveChatMessages();
            
            // 渲染消息
            renderChatMessages(characterId);
            
            // 模拟角色回应（40%概率）
            if (Math.random() < 0.4) {
                setTimeout(() => {
                    const aiPokeSuffix = chatSettings.aiPokeSuffix || '';
                    const aiPokeMessage = {
                        id: Date.now().toString(),
                        sender: 'system',
                        content: `${characterName}戳了戳你${aiPokeSuffix}`,
                        timestamp: Date.now(),
                        isPoke: true
                    };
                    
                    chatMessages[characterId].push(aiPokeMessage);
                    saveChatMessages();
                    renderChatMessages(characterId);
                }, 1000 + Math.random() * 2000);
            }
        }
        
        // 显示聊天选项
        function showChatOptions() {
            showModal('chat-options-modal');
        }
        
        // 显示单聊身份选择（第一步）
        function showSingleChatSelector() {
            hideModal('chat-options-modal');
            showPersonaSelectionForSingleChat();
        }
        
        // 显示单聊身份选择
        function showPersonaSelectionForSingleChat() {
            const modalHTML = `
                <div class="modal" id="persona-selection-modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 class="modal-title">选择身份</h3>
                            <button class="modal-close" onclick="hidePersonaSelectionModal()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p class="selection-description">请选择你在这次对话中使用的身份面具</p>
                            <div class="persona-selection-list" id="persona-selection-list">
                                ${personas.map(persona => `
                                    <div class="persona-selection-item" data-persona-id="${persona.id}">
                                        <div class="persona-selection-avatar" style="${persona.avatarUrl ? `background-image: url(${persona.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                                            ${persona.avatarUrl ? '' : persona.name.charAt(0)}
                                        </div>
                                        <div class="persona-selection-info">
                                            <div class="persona-selection-name">${persona.name}</div>
                                            <div class="persona-selection-desc">${truncateText(persona.description || '暂无描述', 100)}</div>
                                        </div>
                                        <div class="persona-selection-check">
                                            <i class="fas fa-check"></i>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-secondary" onclick="hidePersonaSelectionModal()">取消</button>
                            <button class="modal-primary" id="confirm-persona-btn" onclick="confirmPersonaAndShowCharacters()" disabled>下一步：选择角色</button>
                        </div>
                    </div>
                </div>
            `;
            
            // 移除已存在的模态框
            const existingModal = document.getElementById('persona-selection-modal');
            if (existingModal) {
                existingModal.remove();
            }
            
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            
            // 绑定点击事件
            document.querySelectorAll('.persona-selection-item').forEach(item => {
                item.addEventListener('click', function() {
                    document.querySelectorAll('.persona-selection-item').forEach(i => i.classList.remove('selected'));
                    this.classList.add('selected');
                    window.selectedPersonaForChat = this.dataset.personaId;
                    document.getElementById('confirm-persona-btn').disabled = false;
                });
            });
        }
        
        // 隐藏身份选择模态框
        function hidePersonaSelectionModal() {
            const modal = document.getElementById('persona-selection-modal');
            if (modal) {
                modal.remove();
            }
            window.selectedPersonaForChat = null;
        }
        
        // 确认身份选择并显示角色选择
        function confirmPersonaAndShowCharacters() {
            if (!window.selectedPersonaForChat) return;
            
            hidePersonaSelectionModal();
            showCharacterSelectionForSingleChat();
        }
        
        // 显示单聊角色选择（第二步）
        function showCharacterSelectionForSingleChat() {
            // 🔥【修复】保存当前选中的身份ID，防止在后续流程中丢失
            const savedPersonaId = window.selectedPersonaForChat;
            console.log('=== showCharacterSelectionForSingleChat ===');
            console.log('保存的身份ID:', savedPersonaId);
            
            const modalBody = document.getElementById('single-chat-body');
            modalBody.innerHTML = '';
            
            if (characters.length === 0) {
                modalBody.innerHTML = '<p class="empty-mount-chats">还没有角色，请先创建角色</p>';
            } else {
                characters.forEach(character => {
                    const chatOption = document.createElement('div');
                    // 🔥【新增】检查角色是否已存在对话，添加不同的CSS类
                    const hasExistingChat = contacts.includes(character.id);
                    chatOption.className = `chat-option-item ${hasExistingChat ? 'has-existing-chat' : ''}`;
                    
                    chatOption.onclick = () => {
                        // 🔥【修复】使用保存的身份ID而不是全局变量
                        console.log('=== 角色选择点击事件 ===');
                        console.log('选中的角色:', character.name);
                        console.log('使用的身份ID:', savedPersonaId);
                        
                        hideModal('single-chat-modal');
                        // 设置选择的身份并开始聊天
                        startChatWithPersona(character, savedPersonaId);
                        
                        // 清理临时变量
                        window.selectedPersonaForChat = null;
                    };
                    
                    // 🔥【新增】为已存在对话的角色添加状态提示
                    const statusIndicator = hasExistingChat ? `
                        <div class="chat-status-indicator">
                            <i class="fas fa-comments"></i>
                            <span>已有对话</span>
                        </div>
                    ` : '';
                    
                    chatOption.innerHTML = `
                        <div class="chat-option-icon" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                            ${character.avatarUrl ? '' : character.name.charAt(0)}
                        </div>
                        <div class="chat-option-text">
                            <div class="chat-option-title">${character.name}${hasExistingChat ? ' <span class="chat-exists-badge">已有对话</span>' : ''}</div>
                            <div class="chat-option-desc">${truncateText(character.bio || '暂无描述', 80)}</div>
                        </div>
                        ${statusIndicator}
                    `;
                    
                    modalBody.appendChild(chatOption);
                });
            }
            
            showModal('single-chat-modal');
        }
        
        async function startChatWithPersona(character, personaId) {
            console.log('✅[修复] startChatWithPersona 被调用');
            
            // 🔥【新增】检查该角色是否已存在对话
            if (contacts.includes(character.id)) {
                // 角色已存在对话，询问用户是否要继续或取消
                const existingSettings = chatSettings[character.id] || {};
                const existingPersona = personas.find(p => p.id === existingSettings.selectedIdentityId);
                const existingIdentityName = existingPersona ? existingPersona.name : '未知身份';
                
                const confirmed = confirm(
                    `角色「${character.name}」已存在对话！\n` +
                    `当前对话使用的身份：${existingIdentityName}\n\n` +
                    `选择「确定」：继续使用现有对话\n` +
                    `选择「取消」：放弃本次操作`
                );
                
                if (confirmed) {
                    // 用户选择继续使用现有对话，直接开始聊天
                    startChat(character);
                    return;
                } else {
                    // 用户选择取消，不进行任何操作
                    return;
                }
            }
            
            // 🔥【新增身份设置逻辑】角色不存在对话，创建新对话并设置身份
            if (personaId) {
                // 获取或创建此聊天的专属设置
                let settings = chatSettings[character.id] || {};
                settings.selectedIdentityId = personaId;
                const selectedPersona = personas.find(p => p.id === personaId);
                if (selectedPersona) {
                    settings.myChatAvatar = selectedPersona.avatarUrl || '';
                    settings.myChatNickname = selectedPersona.name || '';
                    chatSettings[character.id] = settings;
                    await saveCurrentChatSettings(settings);
                }
            }
            
            // 添加到联系人列表
            console.log('✅[修复] 发现新联系人，正在同步保存...');
            contacts.push(character.id);
            // 使用 await 确保保存操作完成后再继续
            await saveContacts();
            console.log('✅[修复] 新联系人保存成功，内存中的 contacts 列表:', contacts);
            // 保存成功后，立即刷新一次消息列表的后台数据
            renderMessageList();
            
            // 开始聊天
            startChat(character);
        }
        
        
        // 切换群聊成员选择
        function toggleGroupMemberSelection(characterId) {
            const index = selectedGroupMembers.indexOf(characterId);
            const checkbox = document.getElementById(`checkbox-${characterId}`);
            const memberItem = checkbox.closest('.group-member-item');
            
            if (index > -1) {
                selectedGroupMembers.splice(index, 1);
                checkbox.classList.remove('checked');
                checkbox.innerHTML = '';
                memberItem.classList.remove('selected');
            } else {
                if (selectedGroupMembers.length >= 20) {
                    alert('最多只能选择20个成员');
                    return;
                }
                selectedGroupMembers.push(characterId);
                checkbox.classList.add('checked');
                checkbox.innerHTML = '<i class="fas fa-check"></i>';
                memberItem.classList.add('selected');
            }
        }
        
 // --- 请从这里开始，完整复制所有代码 ---

// 1. 显示聊天选项（入口函数，保持不变）
        function showGroupChatSelector() {
            hideModal('chat-options-modal');
            showPersonaSelectionForGroupChat();
        }
        
// 2. 显示群聊身份选择
        function showPersonaSelectionForGroupChat() {
            const modalHTML = `
                <div class="modal" id="persona-selection-group-modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 class="modal-title">选择身份</h3>
                            <button class="modal-close" onclick="hidePersonaSelectionGroupModal()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p class="selection-description">请选择你在这个群聊中使用的身份面具</p>
                            <div class="persona-selection-list" id="persona-selection-group-list">
                                ${personas.map(persona => `
                                    <div class="persona-selection-item" data-persona-id="${persona.id}">
                                <div class="persona-selection-avatar" style="${persona.avatarUrl ? `background-image: url('${persona.avatarUrl}'); background-size: cover; background-position: center;` : ''}">
                                            ${persona.avatarUrl ? '' : persona.name.charAt(0)}
                                        </div>
                                        <div class="persona-selection-info">
                                            <div class="persona-selection-name">${persona.name}</div>
                                            <div class="persona-selection-desc">${truncateText(persona.description || '暂无描述', 100)}</div>
                                        </div>
                                <div class="persona-selection-check"><i class="fas fa-check"></i></div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-secondary" onclick="hidePersonaSelectionGroupModal()">取消</button>
                    <button class="modal-primary" id="confirm-group-persona-btn" disabled>下一步：设置群聊</button>
                        </div>
                    </div>
                </div>
            `;
            
            const existingModal = document.getElementById('persona-selection-group-modal');
    if (existingModal) existingModal.remove();
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            
    let selectedPersonaId = null;

            document.querySelectorAll('#persona-selection-group-modal .persona-selection-item').forEach(item => {
                item.addEventListener('click', function() {
                    document.querySelectorAll('#persona-selection-group-modal .persona-selection-item').forEach(i => i.classList.remove('selected'));
                    this.classList.add('selected');
            selectedPersonaId = this.dataset.personaId;
                    document.getElementById('confirm-group-persona-btn').disabled = false;
                    console.log('✅ 选择了身份:', selectedPersonaId, '身份名称:', this.querySelector('.persona-selection-name').textContent);
                });
            });

    // 关键修复：让“下一步”按钮的点击事件直接调用下一步函数，并把ID传过去
    document.getElementById('confirm-group-persona-btn').onclick = () => {
        console.log('✅ 点击下一步按钮，当前selectedPersonaId值为:', selectedPersonaId);
        if (selectedPersonaId) {
            console.log('✅ 准备调用confirmPersonaAndShowGroupSettings，传递ID:', selectedPersonaId);
            confirmPersonaAndShowGroupSettings(selectedPersonaId);
        } else {
            console.error('❌ 未选择身份就点击了下一步');
            alert('请先选择一个身份面具');
        }
    };
}

// 3. 隐藏身份选择模态框的函数
        function hidePersonaSelectionGroupModal() {
            const modal = document.getElementById('persona-selection-group-modal');
    if (modal) modal.remove();
}

// 4. 确认身份并显示群成员选择
function confirmPersonaAndShowGroupSettings(personaId) {
    console.log('✅ confirmPersonaAndShowGroupSettings被调用，接收到的personaId:', personaId);
            hidePersonaSelectionGroupModal();
    showGroupChatMemberSelection(personaId); // 将选择的ID作为参数传递给下一步
        }
        
// 5. 显示群成员选择 (已恢复简介显示)
function showGroupChatMemberSelection(personaId) {
    console.log('✅ showGroupChatMemberSelection被调用，接收到的personaId:', personaId);
    
    // 立即将personaId存储到全局变量中，确保不会丢失
    window.currentGroupPersonaId = personaId;
            document.getElementById('group-chat-name').value = '';
            selectedGroupMembers = [];
            
            const membersContainer = document.getElementById('group-chat-members');
            membersContainer.innerHTML = '';
            
            if (characters.length < 2) {
                membersContainer.innerHTML = '<p class="empty-mount-chats">至少需要2个角色才能创建群聊</p>';
            } else {
                characters.forEach(character => {
                    const memberItem = document.createElement('div');
                    memberItem.className = 'group-member-item';
                    memberItem.onclick = () => toggleGroupMemberSelection(character.id);
            // 关键修复：恢复了显示角色简介的HTML代码
                    memberItem.innerHTML = `
                <div class="group-member-checkbox" id="checkbox-${character.id}"></div>
                <div class="message-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url('${character.avatarUrl}');` : ''}">
                            ${character.avatarUrl ? '' : character.name.charAt(0)}
                        </div>
                        <div class="chat-option-text">
                            <div class="chat-option-title">${character.name}</div>
                    <div class="chat-option-desc">${truncateText(character.bio || '暂无简介', 80)}</div>
                </div>`;
                    membersContainer.appendChild(memberItem);
                });
            }

    // 关键修复：将 personaId 绑定到最终的“创建群聊”按钮上
    console.log('✅ 在第一个位置绑定创建按钮，personaId:', personaId);
    const createBtn = document.getElementById('group-chat-modal').querySelector('.modal-primary');
    createBtn.onclick = () => {
        console.log('✅ 第一个位置的创建群聊按钮被点击，直接使用参数personaId:', personaId);
        createGroupChat(personaId);
    }; // 绑定带参数的创建函数
            
            showModal('group-chat-modal');
        }
        
// 6. 切换群成员选择状态 (无修改，但为了完整性包含在此)
        function toggleGroupMemberSelection(characterId) {
            const index = selectedGroupMembers.indexOf(characterId);
            const checkbox = document.getElementById(`checkbox-${characterId}`);
            const memberItem = checkbox.closest('.group-member-item');
            
            if (index > -1) {
                selectedGroupMembers.splice(index, 1);
                checkbox.classList.remove('checked');
                checkbox.innerHTML = '';
                memberItem.classList.remove('selected');
            } else {
                if (selectedGroupMembers.length >= 20) {
                    alert('最多只能选择20个成员');
                    return;
                }
                selectedGroupMembers.push(characterId);
                checkbox.classList.add('checked');
                checkbox.innerHTML = '<i class="fas fa-check"></i>';
                memberItem.classList.add('selected');
            }
        }
        

// 7. 创建群聊（最终版本）
async function createGroupChat(personaId) {
    console.log(`✅ createGroupChat被调用，身份ID: ${personaId}`);

    const groupName = document.getElementById('group-chat-name').value.trim();
    if (!groupName) return alert('请输入群聊名称');
    if (selectedGroupMembers.length < 2) return alert('至少需要选择2个成员');

    // 🔥【关键修复】转换为zhangyu.html格式的数据结构
    const memberDetails = selectedGroupMembers.map(memberId => {
        const character = characters.find(c => c.id === memberId);
        return {
            id: character.id,
            name: character.name,
            persona: character.bio,  // 🔥【关键】使用persona字段而不是bio
            avatarUrl: character.avatarUrl,
            color: character.color
        };
    });

    // 🔥【关键修复】构建zhangyu.html兼容的群聊对象
    const groupChat = {
        id: 'group_' + Date.now().toString(),
        name: groupName,
        members: memberDetails,
        isGroup: true,
        createdAt: new Date().toISOString(),
        // 🔥【新增】添加zhangyu.html风格的设置结构
        settings: {
            myPersona: '', // 将在下面设置
            myNickname: '我' // 默认昵称
        }
    };

    // 🔥【关键修复】保存用户身份设置，同时兼容两种格式
    if (personaId) {
        const selectedPersona = personas.find(p => p.id === personaId);
        if (selectedPersona) {
            // 设置群聊内部的用户人设（zhangyu.html格式）
            groupChat.settings.myPersona = selectedPersona.description || selectedPersona.name;
            groupChat.settings.myNickname = selectedPersona.name;

            // 同时保持原有的chatSettings格式（index.html兼容性）
            const chatSettings = {
                selectedIdentityId: personaId,
                myChatAvatar: selectedPersona.avatarUrl,
                myChatNickname: selectedPersona.name,
                selectedPersonaData: { ...selectedPersona },
                // 🔥【新增】添加zhangyu.html兼容字段
                myPersona: selectedPersona.description || selectedPersona.name
            };

            // 确保 window.chatSettings 已初始化
            if (!window.chatSettings) {
                window.chatSettings = {};
            }
            window.chatSettings[groupChat.id] = chatSettings;
            await db.chatSettings.put({ id: groupChat.id, chatId: groupChat.id, settings: chatSettings });
            console.log('✅ 群聊身份设置已成功保存（双格式兼容）');
        } else {
            console.error('❌ 创建群聊时未找到ID为 ' + personaId + ' 的身份。');
        }
    }

    if (!groupChats) groupChats = [];
    groupChats.push(groupChat);
    await saveGroupChats();
    hideModal('group-chat-modal');
    renderMessageList();
    alert(`群聊"${groupName}"创建成功！`);
}

// --- 请复制到这里结束 ---
        
        // 保存群聊数据 - 使用IndexedDB
        async function saveGroupChats() {
            try {
                console.log('保存群聊数据到IndexedDB:', groupChats);
                
                // 检查数据完整性
                if (!groupChats || !Array.isArray(groupChats)) {
                    console.error('群聊数据无效:', groupChats);
                    groupChats = [];
                }
                
                // 验证每个群聊对象的完整性
                const validGroupChats = groupChats.filter(chat => {
                    if (!chat || !chat.id || !chat.name) {
                        console.warn('发现无效的群聊对象:', chat);
                        return false;
                    }
                    return true;
                });
                
                // 如果有无效数据，更新数组
                if (validGroupChats.length !== groupChats.length) {
                    groupChats = validGroupChats;
                    console.log('已过滤无效数据，有效群聊数量:', groupChats.length);
                }
                
                // 使用事务来确保数据一致性
                await db.transaction('rw', db.groupChats, async () => {
                // 清空现有数据
                await db.groupChats.clear();
                
                    // 逐个插入数据以避免批量插入的ID冲突问题
                    for (const chat of groupChats) {
                        try {
                            await db.groupChats.add(chat);
                        } catch (addError) {
                            console.warn('插入群聊失败，尝试更新:', chat.id, addError);
                            // 如果添加失败，尝试更新
                            await db.groupChats.put(chat);
                        }
                    }
                });
                
                console.log('群聊数据保存成功到IndexedDB');

                // 🔥【优化】智能localStorage备份策略 - 只在数据量小时备份
                try {
                    const dataSize = JSON.stringify(groupChats).length;
                    const maxLocalStorageSize = 1024 * 1024; // 1MB限制，为其他数据留空间

                    if (dataSize < maxLocalStorageSize) {
                        localStorage.setItem('groupChats', JSON.stringify(groupChats));
                        console.log(`群聊数据备份到localStorage成功 (${(dataSize/1024).toFixed(1)}KB)`);
                    } else {
                        // 数据太大，移除localStorage备份
                        localStorage.removeItem('groupChats');
                        console.log(`群聊数据过大 (${(dataSize/1024/1024).toFixed(1)}MB)，跳过localStorage备份，仅使用IndexedDB`);
                    }
                } catch (storageError) {
                    console.warn('localStorage备份失败:', storageError);
                    // 如果是容量不足，清理localStorage备份
                    if (storageError.name === 'QuotaExceededError') {
                        try {
                            localStorage.removeItem('groupChats');
                            console.log('localStorage容量不足，已清理群聊备份');
                        } catch (e) {
                            console.warn('清理localStorage失败:', e);
                        }
                    }
                }
                
            } catch (error) {
                console.error('保存群聊到IndexedDB失败:', error);
                console.error('错误详情:', error.name, error.message);
                
                // 如果IndexedDB失败，回退到localStorage
                try {
                    localStorage.setItem('groupChats', JSON.stringify(groupChats || []));
                    console.log('群聊数据回退保存到localStorage成功');
                    showToast('群聊已保存到本地存储', 'info');
                } catch (localError) {
                    console.error('localStorage保存也失败:', localError);
                    console.error('localStorage错误详情:', localError.name, localError.message);
                    
                    // 检查是否是存储空间不足
                    if (localError.name === 'QuotaExceededError') {
                        alert('存储空间不足，请清理一些数据后重试');
                    } else {
                        alert('保存群聊失败，请尝试刷新页面重新操作');
                    }
                    
                    // 恢复到之前的状态
                    groupChats.pop(); // 移除刚添加的群聊
                    throw localError;
                }
            }
        }
        
        // 渲染定时发布时间点
        function renderScheduleTimes() {
            const container = document.getElementById('schedule-times-container');
            if (!container) return;
            
            const chatSettings = getCurrentChatSettings();
            const scheduleTimes = chatSettings.scheduleTimes || [];
            
            container.innerHTML = '';
            
            scheduleTimes.forEach((time, index) => {
                const timeItem = document.createElement('div');
                timeItem.className = 'schedule-time-item';
                timeItem.innerHTML = `
                    <input type="time" value="${time}" onchange="updateScheduleTime(${index}, this.value)">
                    <button onclick="removeScheduleTime(${index})">×</button>
                `;
                container.appendChild(timeItem);
            });
        }
        
        // 添加定时发布时间点
        async function addScheduleTime() {
            const chatSettings = getCurrentChatSettings();
            if (!chatSettings.scheduleTimes) {
                chatSettings.scheduleTimes = [];
            }
            
            if (chatSettings.scheduleTimes.length >= 10) {
                alert('最多只能设置10个时间点');
                return;
            }
            
            chatSettings.scheduleTimes.push('09:00');
            await saveCurrentChatSettings(chatSettings);
            renderScheduleTimes();
        }
        
        // 更新定时发布时间点
        async function updateScheduleTime(index, newTime) {
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.scheduleTimes && chatSettings.scheduleTimes[index] !== undefined) {
                chatSettings.scheduleTimes[index] = newTime;
                await saveCurrentChatSettings(chatSettings);
            }
        }
        
        // 移除定时发布时间点
        async function removeScheduleTime(index) {
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.scheduleTimes && chatSettings.scheduleTimes[index] !== undefined) {
                chatSettings.scheduleTimes.splice(index, 1);
                await saveCurrentChatSettings(chatSettings);
                renderScheduleTimes();
            }
        }
        
        // 保存定时发布设置
        async function saveScheduleSettings() {
            const chatSettings = getCurrentChatSettings();
            chatSettings.scheduleEnabled = document.getElementById('schedule-enabled').checked;
            
            await saveCurrentChatSettings(chatSettings);
            hideModal('schedule-settings-modal');
            showToast('定时发布设置已保存', 'success');
        }
        
        // 显示世界书挂载设置
        function showWorldbookMountSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // 加载当前设置
            document.getElementById('worldbook-mount-enabled').checked = chatSettings.worldbookMountEnabled || false;
            
            // 控制详细设置的显示
            toggleWorldbookMountDetails();
            
            // 绑定事件
            document.getElementById('worldbook-mount-enabled').onchange = toggleWorldbookMountDetails;
            
            // 渲染世界书列表
            renderWorldbookMountList();
            
            showModal('worldbook-mount-modal');
        }
        
        // 切换世界书挂载详细设置显示
        function toggleWorldbookMountDetails() {
            const enabled = document.getElementById('worldbook-mount-enabled').checked;
            document.getElementById('worldbook-mount-details').style.display = enabled ? 'block' : 'none';
            
            // 更新主设置界面显示
            updateWorldbookMountDisplay();
        }
        
        // 更新世界书挂载显示状态
        function updateWorldbookMountDisplay() {
            // 如果没有当前聊天角色，跳过
            if (!currentChatCharacter) {
                console.log("更新世界书挂载显示：无当前聊天角色，跳过操作");
                return;
            }
            
            const chatSettings = getCurrentChatSettings();
            const displayElement = document.getElementById('current-worldbook-mount');
            
            if (!displayElement) {
                console.log("更新世界书挂载显示：无显示元素，跳过操作");
                return;
            }
            
            if (!chatSettings.worldbookMountEnabled) {
                displayElement.textContent = '未挂载';
                return;
            }
            
            const selectedWorldbooks = chatSettings.selectedWorldbooks || [];
            if (selectedWorldbooks.length === 0) {
                displayElement.textContent = '已启用但未选择';
            } else if (selectedWorldbooks.length === 1) {
                const worldbook = worldbooks.find(w => w.id === selectedWorldbooks[0]);
                displayElement.textContent = worldbook ? `已挂载: ${worldbook.title}` : '已挂载: 1个';
            } else {
                displayElement.textContent = `已挂载: ${selectedWorldbooks.length}个`;
            }
        }
        
        // 渲染世界书挂载列表
        function renderWorldbookMountList() {
            const container = document.getElementById('worldbook-mount-list');
            container.innerHTML = '';
            
            // 过滤掉全局世界书，只显示局部世界书
            const localWorldbooks = worldbooks.filter(w => !w.isGlobal);
            
            if (localWorldbooks.length === 0) {
                container.innerHTML = '<p class="empty-mount-chats">暂无局部世界书，请先在世界书应用中创建</p>';
                return;
            }
            
            const chatSettings = getCurrentChatSettings();
            const selectedWorldbooks = chatSettings.selectedWorldbooks || [];
            
            localWorldbooks.forEach(worldbook => {
                const item = document.createElement('div');
                item.className = 'mount-item worldbook-mount-item';
                
                const isSelected = selectedWorldbooks.includes(worldbook.id);
                
                item.innerHTML = `
                    <input type="checkbox" id="worldbook-${worldbook.id}" value="${worldbook.id}" ${isSelected ? 'checked' : ''} class="worldbook-checkbox">
                    <div class="worldbook-content-flex">
                        <div class="worldbook-title-text">
                            ${worldbook.title}
                        </div>
                        <div class="worldbook-desc-text">
                            ${worldbook.content.length > 100 ? worldbook.content.substring(0, 100) + '...' : worldbook.content}
                        </div>
                        <div class="worldbook-date-text">
                            创建于: ${new Date(worldbook.createdAt).toLocaleDateString('zh-CN')} | 
                            字数: ${worldbook.content.length}
                        </div>
                    </div>
                `;
                
                // 点击整个条目也能切换选择状态
                item.onclick = (e) => {
                    if (e.target.type !== 'checkbox') {
                        const checkbox = item.querySelector('input[type="checkbox"]');
                        checkbox.checked = !checkbox.checked;
                    }
                };
                
                container.appendChild(item);
            });
            
            // 添加提示说明全局世界书自动应用
            const globalInfo = document.createElement('div');
            globalInfo.className = 'worldbook-global-info';
            globalInfo.innerHTML = '<p class="global-worldbook-note">注意：全局世界书已自动应用于所有聊天，无需手动挂载。</p>';
            container.appendChild(globalInfo);
        }
        
        // 保存世界书挂载设置
        function saveWorldbookMountSettings() {
            const chatSettings = getCurrentChatSettings();
            
            chatSettings.worldbookMountEnabled = document.getElementById('worldbook-mount-enabled').checked;
            
            // 获取选中的世界书
            const checkboxes = document.querySelectorAll('#worldbook-mount-list input[type="checkbox"]:checked');
            chatSettings.selectedWorldbooks = Array.from(checkboxes).map(cb => cb.value);
            
            saveCurrentChatSettings(chatSettings);
            updateWorldbookMountDisplay();
            hideModal('worldbook-mount-modal');
            
            const selectedCount = chatSettings.selectedWorldbooks ? chatSettings.selectedWorldbooks.length : 0;
            if (chatSettings.worldbookMountEnabled && selectedCount > 0) {
                showToast(`世界书挂载设置已保存，已挂载 ${selectedCount} 个世界书`, 'success');
            } else if (chatSettings.worldbookMountEnabled) {
                showToast('世界书挂载已启用，但未选择任何世界书', 'info');
            } else {
                showToast('世界书挂载已关闭', 'info');
            }
        }
        
        // 身份选择器功能已移除，身份在创建对话时选择
        
        // 压缩图片以减少存储空间
        function compressImage(dataUrl, maxWidth = 300, quality = 0.8) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // 计算新的尺寸，保持宽高比
                    let { width, height } = img;
                    if (width > height) {
                        if (width > maxWidth) {
                            height = (height * maxWidth) / width;
                            width = maxWidth;
                        }
                    } else {
                        if (height > maxWidth) {
                            width = (width * maxWidth) / height;
                            height = maxWidth;
                        }
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    // 绘制并压缩
                    ctx.drawImage(img, 0, 0, width, height);
                    const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                    
                    console.log(`图片压缩：${Math.round(dataUrl.length/1024)}KB -> ${Math.round(compressedDataUrl.length/1024)}KB`);
                    resolve(compressedDataUrl);
                };
                img.src = dataUrl;
            });
        }
        

        
        // 🔥【紧急修复】恢复设置并刷新界面
        function recoverAndRefreshSettings() {
            if (!currentChatCharacter) {
                showToast('请先选择一个聊天窗口', 'warning');
                return;
            }
            
            const chatId = currentChatCharacter.id;
            console.log(`开始恢复聊天设置: ${chatId}`);
            console.log('当前设置状态:', JSON.stringify(chatSettings[chatId], null, 2));
            
            // 显示恢复进度
            showToast('正在尝试恢复设置...', 'info');
            
            // 🔥【直接恢复方法】强制从localStorage恢复，不通过getCurrentChatSettings
            const savedLocalStorage = localStorage.getItem(`chatSettings_${chatId}`);
            if (savedLocalStorage) {
                try {
                    const recoveredSettings = JSON.parse(savedLocalStorage);
                    console.log('从localStorage恢复的设置:', JSON.stringify(recoveredSettings, null, 2));
                    
                    // 直接覆盖全局设置
                    chatSettings[chatId] = recoveredSettings;
                    
                    // 立即刷新当前界面的显示（如果在设置界面）
                    if (document.getElementById('api-chat-settings-screen').style.display !== 'none') {
                        updateChatSettingsDisplay();
                    }
                    
                    // 刷新聊天消息界面
                    if (currentChatCharacter) {
                        renderChatMessages(currentChatCharacter.id);
                    }
                    
                    showToast('设置恢复成功！', 'success');
                    console.log('设置恢复完成，当前设置:', JSON.stringify(chatSettings[chatId], null, 2));
                    return;
                } catch (error) {
                    console.error('解析localStorage设置失败:', error);
                }
            }
            
            // 如果localStorage失败，尝试从IndexedDB恢复
            db.chatSettings.get(chatId).then(dbSettings => {
                if (dbSettings && dbSettings.settings) {
                    console.log('从IndexedDB恢复的设置:', JSON.stringify(dbSettings.settings, null, 2));
                    
                    // 直接覆盖全局设置
                    chatSettings[chatId] = dbSettings.settings;
                    
                    // 同步到localStorage
                    localStorage.setItem(`chatSettings_${chatId}`, JSON.stringify(dbSettings.settings));
                    
                    // 立即刷新界面
                    if (document.getElementById('api-chat-settings-screen').style.display !== 'none') {
                        updateChatSettingsDisplay();
                    }
                    
                    if (currentChatCharacter) {
                        renderChatMessages(currentChatCharacter.id);
                    }
                    
                    showToast('从备份数据恢复设置成功！', 'success');
                    console.log('从IndexedDB恢复设置成功:', JSON.stringify(dbSettings.settings, null, 2));
                } else {
                    showToast('未找到备份数据，设置可能已永久丢失', 'error');
                    console.log('未找到任何备份数据');
                }
            }).catch(error => {
                console.error('从IndexedDB恢复设置失败:', error);
                showToast('恢复设置失败，请联系技术支持', 'error');
            });
        }
        
        // 🔥【紧急修复】尝试恢复被覆盖的聊天设置
        function recoverChatSettings() {
            if (!currentChatCharacter) return false;
            
            const chatId = currentChatCharacter.id;
            console.log('尝试恢复聊天设置...');
            
            // 尝试从localStorage恢复
            const savedSettings = localStorage.getItem(`chatSettings_${chatId}`);
            if (savedSettings) {
                try {
                    const userSettings = JSON.parse(savedSettings);
                    chatSettings[chatId] = userSettings;
                    console.log('从localStorage恢复聊天设置成功:', userSettings);
                    return true;
                } catch (error) {
                    console.error('从localStorage恢复设置失败:', error);
                }
            }
            
            // 尝试从IndexedDB恢复
            db.chatSettings.get(chatId).then(dbSettings => {
                if (dbSettings && dbSettings.settings) {
                    chatSettings[chatId] = dbSettings.settings;
                    console.log('从IndexedDB恢复聊天设置成功:', dbSettings.settings);
                    // 同步到localStorage
                    localStorage.setItem(`chatSettings_${chatId}`, JSON.stringify(dbSettings.settings));
                    return true;
                }
            }).catch(error => {
                console.error('从IndexedDB恢复设置失败:', error);
            });
            
            return false;
        }
        
        // 强制刷新所有头像显示
        function forceRefreshAvatars() {
            const chatSettings = getCurrentChatSettings();
            const currentAvatar = chatSettings.aiDynamicAvatar || chatSettings.aiChatAvatar || currentChatCharacter.avatarUrl;
            
            console.log('强制刷新头像显示，当前头像:', currentAvatar ? currentAvatar.substring(0, 50) + '...' : '无头像');
            
            // 刷新聊天界面中所有角色头像
            const messageAvatars = document.querySelectorAll('.message-avatar');
            messageAvatars.forEach(avatar => {
                // 检查是否是当前角色的头像（通过点击事件判断）
                const onclickAttr = avatar.getAttribute('onclick');
                if (onclickAttr && onclickAttr.includes(`'${currentChatCharacter.id}'`)) {
                    if (currentAvatar && currentAvatar !== 'undefined') {
                        avatar.style.backgroundImage = `url(${currentAvatar})`;
                        avatar.style.backgroundSize = 'cover';
                        avatar.style.backgroundPosition = 'center';
                        avatar.innerHTML = '';
                    } else {
                        avatar.style.backgroundImage = 'none';
                        avatar.innerHTML = currentChatCharacter.name.charAt(0);
                    }
                }
            });
            
            // 如果当前在头像设置界面，也刷新预览
            const aiAvatarPreview = document.getElementById('ai-chat-avatar-preview');
            if (aiAvatarPreview && currentAvatar && currentAvatar !== 'undefined') {
                aiAvatarPreview.style.backgroundImage = `url(${currentAvatar})`;
                aiAvatarPreview.style.backgroundSize = 'cover';
                aiAvatarPreview.style.backgroundPosition = 'center';
                aiAvatarPreview.innerHTML = '';
                
                // 更新提示信息
                if (chatSettings.aiDynamicAvatar) {
                    aiAvatarPreview.title = '当前显示动态头像（角色在聊天中更换的）';
                } else {
                    aiAvatarPreview.title = '当前显示聊天设置头像';
                }
            }
        }
        
        // 📊 计算存储空间使用情况
        async function calculateStorageUsage() {
            try {
                let chatSize = 0;
                let characterSize = 0;
                let settingsSize = 0;
                let emojiSize = 0;

                // 计算聊天记录大小
                const chatMessagesData = await db.chatMessages.toArray();
                chatSize = JSON.stringify(chatMessagesData).length;

                // 计算角色数据大小
                const charactersData = await db.characters.toArray();
                characterSize = JSON.stringify(charactersData).length;

                // 计算聊天设置大小
                const chatSettingsData = await db.chatSettings.toArray();
                settingsSize = JSON.stringify(chatSettingsData).length;

                // 计算表情包大小
                const emojisData = await db.customEmojis.toArray();
                emojiSize = JSON.stringify(emojisData).length;

                const total = chatSize + characterSize + settingsSize + emojiSize;

                // 更新显示
                document.getElementById('chat-storage-size').textContent = formatBytes(chatSize);
                document.getElementById('character-storage-size').textContent = formatBytes(characterSize);
                document.getElementById('settings-storage-size').textContent = formatBytes(settingsSize);
                document.getElementById('emoji-storage-size').textContent = formatBytes(emojiSize);
                document.getElementById('total-storage-size').textContent = formatBytes(total);

                return { chatSize, characterSize, settingsSize, emojiSize, total };
            } catch (error) {
                console.error('计算存储使用情况失败:', error);
                return null;
            }
        }

        // 格式化字节数为可读格式
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // 🧹 压缩所有图片
        async function compressAllImages() {
            if (!confirm('将压缩所有头像和背景图片，这可能需要一些时间。确定继续吗？')) {
                return;
            }

            showToast('正在压缩图片...', 'info');
            let compressedCount = 0;

            try {
                // 压缩角色头像
                for (const character of characters) {
                    if (character.avatarUrl && character.avatarUrl.length > 50000) {
                        character.avatarUrl = await compressImage(character.avatarUrl, 150, 0.6);
                        compressedCount++;
                    }
                }
                await saveCharacters();

                // 压缩聊天设置中的头像
                for (const chatId of Object.keys(chatSettings)) {
                    const settings = chatSettings[chatId];
                    if (settings) {
                        if (settings.aiChatAvatar && settings.aiChatAvatar.length > 50000) {
                            settings.aiChatAvatar = await compressImage(settings.aiChatAvatar, 150, 0.6);
                            compressedCount++;
                        }
                        if (settings.myChatAvatar && settings.myChatAvatar.length > 50000) {
                            settings.myChatAvatar = await compressImage(settings.myChatAvatar, 150, 0.6);
                            compressedCount++;
                        }
                        if (settings.chatBackground && settings.chatBackground.length > 100000) {
                            settings.chatBackground = await compressImage(settings.chatBackground, 800, 0.7);
                            compressedCount++;
                        }
                    }
                }
                await saveChatSettings();

                // 更新存储使用情况
                calculateStorageUsage();

                showToast(`图片压缩完成！共处理了 ${compressedCount} 张图片`, 'success');
            } catch (error) {
                console.error('压缩图片失败:', error);
                showToast('压缩过程中出现错误', 'error');
            }
        }

        // 🧹 旧版清理存储空间（保留兼容性）
        async function cleanupStorageSpace() {
            if (!confirm('将清理以下数据以释放存储空间：\n\n• 所有角色的动态头像\n• localStorage中的过期数据\n• 压缩现有头像数据\n\n确定要继续吗？')) {
                return;
            }
            
            showToast('正在清理存储空间...', 'info');
            let cleanedSize = 0;
            let cleanedItems = 0;
            
            try {
                // 1. 清除所有动态头像
                Object.keys(chatSettings).forEach(chatId => {
                    if (chatSettings[chatId] && chatSettings[chatId].aiDynamicAvatar) {
                        delete chatSettings[chatId].aiDynamicAvatar;
                        cleanedItems++;
                    }
                });
                
                // 2. 清理localStorage中的过期chatSettings
                for (let i = localStorage.length - 1; i >= 0; i--) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('chatSettings_')) {
                        const value = localStorage.getItem(key);
                        if (value) {
                            cleanedSize += value.length;
                            localStorage.removeItem(key);
                            cleanedItems++;
                        }
                    }
                }
                
                // 3. 压缩所有现有头像数据
                for (const chatId of Object.keys(chatSettings)) {
                    const settings = chatSettings[chatId];
                    if (settings) {
                        if (settings.aiChatAvatar && settings.aiChatAvatar.length > 50000) {
                            settings.aiChatAvatar = await compressImage(settings.aiChatAvatar, 150, 0.6);
                            cleanedItems++;
                        }
                        if (settings.myChatAvatar && settings.myChatAvatar.length > 50000) {
                            settings.myChatAvatar = await compressImage(settings.myChatAvatar, 150, 0.6);
                            cleanedItems++;
                        }
                    }
                }
                
                // 4. 重新保存压缩后的设置到IndexedDB
                await saveChatSettings();
                
                // 5. 刷新当前界面
                if (currentChatCharacter) {
                    renderChatMessages(currentChatCharacter.id);
                }
                
                const sizeKB = Math.round(cleanedSize / 1024);
                showToast(`清理完成！释放了约 ${sizeKB}KB 空间，处理了 ${cleanedItems} 项数据`, 'success');
                
            } catch (error) {
                console.error('清理存储空间失败:', error);
                showToast('清理过程中出现错误，请重试', 'error');
            }
        }
        
        // 清除AI动态头像
        function clearAiDynamicAvatar() {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.aiDynamicAvatar) {
                delete chatSettings.aiDynamicAvatar;
                saveCurrentChatSettings(chatSettings);
                
                // 刷新聊天界面
                if (currentChatCharacter) {
                    renderChatMessages(currentChatCharacter.id);
                }
                
                showToast('动态头像已清除，恢复为聊天设置头像', 'success');
            } else {
                showToast('当前没有动态头像', 'info');
            }
        }
        
        // 保存聊天身份选择
        function saveChatIdentity() {
            if (!window.selectedChatIdentityId) {
                alert('请选择一个身份');
                return;
            }
            
            const chatSettings = getCurrentChatSettings();
            const selectedPersona = personas.find(p => p.id === window.selectedChatIdentityId);
            
            if (selectedPersona) {
                chatSettings.selectedIdentityId = selectedPersona.id;
                
                // 如果选中的身份有头像，自动设置为聊天头像（如果当前没有设置的话）
                if (selectedPersona.avatarUrl && !chatSettings.myChatAvatar) {
                    chatSettings.myChatAvatar = selectedPersona.avatarUrl;
                }
                
                // 如果选中的身份有名称，自动设置为聊天昵称（如果当前没有设置的话）
                if (selectedPersona.name && !chatSettings.myChatNickname) {
                    chatSettings.myChatNickname = selectedPersona.name;
                }
                
                saveCurrentChatSettings(chatSettings);
                
                // 更新显示
                updateChatIdentityDisplay();
                
                // 刷新聊天界面
                if (currentChatCharacter) {
                    renderChatMessages(currentChatCharacter.id);
                }
                
                hideModal('identity-selector-modal');
                showToast(`已选择身份"${selectedPersona.name}"`, 'success');
            }
        }
        
        // 更新聊天身份显示
        async function updateChatIdentityDisplay() {
            // 如果没有当前聊天角色，就不执行后续操作
            if (!currentChatCharacter) {
                console.log("更新聊天身份显示：无当前聊天角色，跳过操作");
                return;
            }
            
            const chatSettings = await getAsyncChatSettings();
            const selectedIdentityId = chatSettings.selectedIdentityId || 'default';
            const selectedPersona = personas.find(p => p.id === selectedIdentityId);
            
            const displayElement = document.getElementById('current-chat-identity');
            if (displayElement && selectedPersona) {
                displayElement.textContent = selectedPersona.name;
            }
        }
        
        // 更新气泡样式显示
        async function updateBubbleStyleDisplay() {
            // 如果没有当前聊天角色，就不执行后续操作
            if (!currentChatCharacter) {
                console.log("更新气泡样式显示：无当前聊天角色，跳过操作");
                return;
            }
            
            const chatSettings = await getAsyncChatSettings();
            const styleNames = {
                'default': '默认样式',
                'glass': '毛玻璃',
                'shadow': '经典阴影',
                'tail': '经典气泡',
                'gradient': '渐变样式',
                'minimal': '极简样式',
                'neon': '霓虹样式',
                'paper': '纸张样式'
            };
            
            const displayElement = document.getElementById('current-bubble-style');
            if (displayElement) {
                const currentStyle = chatSettings.bubbleStyle || 'default';
                displayElement.textContent = styleNames[currentStyle] || '默认样式';
            }
        }
        
        // 全局头像上传处理函数
        function handleAvatarUploadClick() {
            console.log('点击了上传头像按钮');
            const input = document.getElementById('avatar-upload');
            if (input) {
                console.log('找到了input元素，准备触发点击');
                input.click();
            } else {
                console.error('找不到avatar-upload元素');
                alert('找不到文件上传元素，请刷新页面重试');
            }
        }
        
        // 该函数已被删除，使用上面的异步IndexedDB版本
        
        // 🔥【修复】添加消息长按监听器 - 支持手机端菜单操作
        function addMessageLongPressListener(messageContainer, messageId) {
            let pressTimer = null;
            let isLongPress = false;
            
            // 检测是否为移动设备
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                             'ontouchstart' in window || 
                             navigator.maxTouchPoints > 0;
            
            const startLongPress = (e) => {
                if (isMessageSelectionMode) {
                    // 在选择模式下，只处理点击选择，不处理长按
                    return;
                }

                isLongPress = false;
                pressTimer = setTimeout(() => {
                    isLongPress = true;

                    // 🔥【修复】只在长按触发时阻止默认行为
                    e.preventDefault();
                    e.stopPropagation();

                    // 🔥【新增】手机端显示操作菜单，桌面端进入多选模式
                    if (isMobile) {
                        showMobileMessageMenu(messageId, e);
                    } else {
                    enterMessageSelectionMode(messageId);
                    }
                }, 500);
            };
            
            const cancelLongPress = () => {
                clearTimeout(pressTimer);
                // 重置长按标记，延迟重置以避免立即触发点击
                setTimeout(() => {
                    isLongPress = false;
                }, 50);
            };
            
            const handleClick = (e) => {
                // 在选择模式下，所有消息都可以点击切换选择状态
                if (isMessageSelectionMode) {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleMessageSelection(messageId);
                    return;
                }
                
                // 如果是长按触发后的点击，不处理
                if (isLongPress) {
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }
            };
            
            // 触摸事件
            messageContainer.addEventListener('touchstart', startLongPress, { passive: false });
            messageContainer.addEventListener('touchend', cancelLongPress);
            messageContainer.addEventListener('touchmove', cancelLongPress);
            
            // 鼠标事件（用于桌面端测试）
            messageContainer.addEventListener('mousedown', startLongPress);
            messageContainer.addEventListener('mouseup', cancelLongPress);
            messageContainer.addEventListener('mouseleave', cancelLongPress);
            
            // 点击事件 - 使用捕获阶段确保优先处理
            messageContainer.addEventListener('click', handleClick, true);
        }
        
        // 🔥【重新设计】显示消息上方按钮条
        function showMobileMessageMenu(messageId, event) {
            console.log('移动端长按菜单，messageId:', messageId);
            selectedMessageId = messageId;

            // 检查消息是否是用户发送的
            const messages = chatMessages[currentChatCharacter.id] || [];
            const message = messages.find(msg => msg.id === messageId);
            const isUserMessage = message && message.sender === 'sent';

            // 隐藏已存在的按钮条
            hideMessageActionBar();

            // 找到对应的消息容器
            const messageContainer = document.querySelector(`[data-message-id="${messageId}"]`);
            if (!messageContainer) {
                console.log('错误：找不到消息容器');
                return;
            }
            console.log('找到消息容器:', messageContainer);

            // 创建按钮条
            const actionBar = document.createElement('div');
            actionBar.className = 'message-action-bar';
            actionBar.id = 'message-action-bar';

            // 构建按钮列表
            const buttons = ['引用', '复制'];

            // 🔥【新增】只有AI角色消息才显示心声选项
            if (!isUserMessage) {
                buttons.push('心声');
            }

            if (isUserMessage) {
                buttons.push('编辑', '撤回');
            }
            buttons.push('多选');

            actionBar.innerHTML = buttons.map(text => {
                let action = '';
                switch(text) {
                    case '引用': action = `replyToMessage('${messageId}')`; break;
                    case '复制': action = `copyMessage('${messageId}')`; break;
                    case '心声': action = `showInnerThoughtsModal('${messageId}')`; break;
                    case '编辑': action = `showEditMessageModal('${messageId}')`; break;
                    case '撤回': action = `deleteMessage('${messageId}')`; break;
                    case '多选': action = `enterMessageSelectionMode('${messageId}')`; break;
                }
                return `<button class="message-action-btn" onclick="${action}; hideMessageActionBar();">${text}</button>`;
            }).join('');

            // 添加到消息容器
            messageContainer.appendChild(actionBar);

            // 显示动画
            setTimeout(() => {
                actionBar.classList.add('show');
            }, 10);

            // 添加全局点击监听器
            setTimeout(() => {
                document.addEventListener('click', hideMessageActionBarOnClickOutside);
                document.addEventListener('touchstart', hideMessageActionBarOnClickOutside);
            }, 100);
        }
        
        // 🔥【重新设计】隐藏消息按钮条
        function hideMessageActionBar() {
            const actionBar = document.getElementById('message-action-bar');
            if (actionBar) {
                actionBar.classList.remove('show');
                setTimeout(() => {
                    if (actionBar.parentNode) {
                        actionBar.parentNode.removeChild(actionBar);
                    }
                }, 300);
            }
            selectedMessageId = null;

            // 移除全局点击监听器
            document.removeEventListener('click', hideMessageActionBarOnClickOutside);
            document.removeEventListener('touchstart', hideMessageActionBarOnClickOutside);
        }

        // 🔥【新增】点击外部隐藏按钮条
        function hideMessageActionBarOnClickOutside(event) {
            const actionBar = document.getElementById('message-action-bar');
            if (actionBar && !actionBar.contains(event.target)) {
                hideMessageActionBar();
            }
        }

        // 🔥【兼容】保持旧函数名
        function hideMobileMessageMenu() {
            hideMessageActionBar();
        }
        
        // 进入消息选择模式
        function enterMessageSelectionMode(initialMessageId) {
            if (isMessageSelectionMode) {
                return;
            }
            
            isMessageSelectionMode = true;
            selectedMessages.clear();
            selectedMessages.add(initialMessageId);
            
            // 添加选择模式CSS类
            const chatScreen = document.getElementById('api-chat-screen');
            if (chatScreen) {
                chatScreen.classList.add('selection-mode');
            }
            
            updateMessageSelectionUI();
        }
        
        // 切换消息选择状态
        function toggleMessageSelection(messageId) {
            if (!isMessageSelectionMode) return;
            
            if (selectedMessages.has(messageId)) {
                selectedMessages.delete(messageId);
            } else {
                selectedMessages.add(messageId);
            }
            
            updateMessageSelectionUI();
            
            // 如果没有选中的消息，退出选择模式
            if (selectedMessages.size === 0) {
                exitMessageSelectionMode();
            }
        }
        
        // 退出消息选择模式
        function exitMessageSelectionMode() {
            if (!isMessageSelectionMode) return;
            
            isMessageSelectionMode = false;
            
            // 移除选择模式CSS类
            const chatScreen = document.getElementById('api-chat-screen');
            if (chatScreen) {
                chatScreen.classList.remove('selection-mode');
            }
            
            // 🔥【修复】清除所有选中状态，包括撤回消息
            const selectedContainers = document.querySelectorAll('[data-message-id].selected');
            selectedContainers.forEach(container => {
                container.classList.remove('selected');
            });
            
            selectedMessages.clear();
            updateMessageSelectionUI();
        }
        

        
        // 更新消息选择UI
        function updateMessageSelectionUI() {
            // 🔥【修复】查找所有带有messageId的容器，包括撤回消息
            const allContainers = document.querySelectorAll('[data-message-id]');
            
            allContainers.forEach(container => {
                const messageId = container.dataset.messageId;
                if (messageId) {
                    if (selectedMessages.has(messageId)) {
                        container.classList.add('selected');
                    } else {
                        container.classList.remove('selected');
                    }
                }
            });
            
            // 更新选择计数显示
            const countElement = document.getElementById('selection-count');
            if (countElement) {
                countElement.textContent = `已选 ${selectedMessages.size} 条`;
            }
        }
        
        // 🔥【修复】防止重复删除操作的标志
        let isDeletingMessages = false;

        // 删除选中的消息
        async function deleteSelectedMessages() {
            // 防止重复操作
            if (isDeletingMessages) {
                console.log('删除操作正在进行中，请稍候...');
                return;
            }
            if (selectedMessages.size === 0) return;
            
            if (!currentChatCharacter) return;
            
            if (confirm(`确定要删除选中的 ${selectedMessages.size} 条消息吗？此操作不可恢复！`)) {
                isDeletingMessages = true; // 设置删除标志
                const characterId = currentChatCharacter.id;

                if (chatMessages[characterId]) {
                    // 🔥【新增】删除选中消息的时间线记录
                    const messagesToDelete = [];
                    chatMessages[characterId].forEach(message => {
                        if (selectedMessages.has(message.id)) {
                            messagesToDelete.push(message);
                        }
                    });

                    // 清理每条被删除消息的时间线记录
                    for (const message of messagesToDelete) {
                        try {
                            await deleteRelatedTimelineEvents(message);
                            console.log(`🗑️ 已清理消息的时间线记录: ${message.content?.substring(0, 30)}...`);
                        } catch (error) {
                            console.error('清理时间线记录失败:', error);
                        }
                    }

                    // 查找所有要删除的消息内容，用于匹配相关的撤回提示
                    const deleteContentSet = new Set();
                    messagesToDelete.forEach(message => {
                        if (message.content) {
                            deleteContentSet.add(message.content);
                        }
                    });
                    
                    // 过滤消息：删除选中消息 + 相关的撤回提示
                    chatMessages[characterId] = chatMessages[characterId].filter(message => {
                        // 删除选中的消息
                        if (selectedMessages.has(message.id)) {
                            return false;
                        }
                        
                        // 删除相关的撤回提示（系统消息类型，且原文匹配要删除的消息）
                        if (message.sender === 'system' && message.type === 'recalled_message' && message.originalContent) {
                            if (deleteContentSet.has(message.originalContent)) {
                                console.log('删除相关的撤回提示:', message.content);
                                return false;
                            }
                        }
                        
                        return true;
                    });
                    
                    saveChatMessages();
                    renderChatMessages(characterId);
                    renderMessageList(); // 更新消息列表
                }
                
                // 退出选择模式
                exitMessageSelectionMode();

                // 🔥【修复】重置删除标志，允许后续删除操作
                isDeletingMessages = false;
            } else {
                // 🔥【修复】用户取消删除时也要重置标志
                isDeletingMessages = false;
            }
        }

        // 悬浮按钮功能
        // 变量控制等待回复状态
        let isWaitingForReply = false;
        let pendingUserMessage = null;

      // 用这段新代码，完整替换掉旧的 regenerateLastResponse 函数
        async function regenerateLastResponse() {
            if (!currentChatCharacter) {
                alert('请先选择一个角色');
                return;
            }

            // 防止重复调用
            if (window._isRegenerating) {
                console.log('重新生成正在进行中，忽略重复调用');
                return;
            }
            window._isRegenerating = true;

            const characterId = currentChatCharacter.id;
            const messages = chatMessages[characterId] || [];
            
            // 找到最后一条AI消息及其对应的用户消息
            let lastAiMessageIndex = -1;
            let lastUserMessageIndex = -1;
            
            for (let i = messages.length - 1; i >= 0; i--) {
                if (messages[i].sender === 'received' && lastAiMessageIndex === -1) {
                    lastAiMessageIndex = i;
                }
                if (lastAiMessageIndex !== -1 && messages[i].sender === 'sent' && lastUserMessageIndex === -1) {
                    lastUserMessageIndex = i;
                    break;
                }
            }
            
            if (lastAiMessageIndex === -1) {
                alert('没有找到AI回复可以重新生成');
                return;
            }
            
            if (lastUserMessageIndex === -1) {
                alert('没有找到对应的用户消息');
                return;
            }

            const userMessage = messages[lastUserMessageIndex];
            
            // 删除从最后一条用户消息后的所有AI消息
            chatMessages[characterId] = messages.slice(0, lastUserMessageIndex + 1);
    await saveChatMessages(); // 使用 await 确保保存完成
            await renderChatMessagesAsync(characterId);

            // 🔥【修复】确保在renderChatMessages完成后再显示typing-indicator
            console.log('🔧 [regenerateLastResponse] 准备显示typing-indicator');
            // 添加小延迟确保DOM更新完成
            await new Promise(resolve => {
                setTimeout(() => {
                    showTypingIndicator();
                    resolve();
                }, 100);
            });
            
            const delay = Math.random() * 2000 + 1000;
            await new Promise(resolve => setTimeout(resolve, delay));
            
            try {
                let response;
                
                // 🔥【核心修复】使用新的多模态处理逻辑
                if (Array.isArray(userMessage.content)) {
                    // 这是多模态消息（图文）
                    response = await callChatAPI(userMessage.content, currentChatCharacter);
                } else if (userMessage.image) {
                    // 兼容旧的图片消息格式
                    const messageContent = [
                        { type: 'text', text: userMessage.content || "" },
                        { type: 'image_url', image_url: { url: userMessage.image } }
                    ];
                    response = await callChatAPI(messageContent, currentChatCharacter);
                } else if (userMessage.type === 'transfer') {
                    // 🔥【关键修复】转账消息特殊处理 - 构造转账提示文本
                    const transferPrompt = `[用户发起了转账：${userMessage.amount}元，备注：${userMessage.note || '无'}]`;
                    response = await callChatAPI(transferPrompt, currentChatCharacter);
                } else {
                    // 普通文本消息
                    let finalPrompt = userMessage.content; // 默认使用原始消息内容

                    // 🔥【关键修复】检查用户消息是否为引用回复
                    if (userMessage.replyTo) {
                        const quoteText = summarizeLastMessage({ content: userMessage.replyTo.content });
                        finalPrompt = `[回复 ${userMessage.replyTo.senderName} 的消息: "${quoteText}"] ${userMessage.content}`;
                        console.log('✅ [重新生成] 构建用户引用提示:', finalPrompt);
                    }

                    response = await callChatAPI(finalPrompt, currentChatCharacter);
                }
                const aiMessages = parseAiResponse(response);

                // 🔥【修复】不要在这里立即隐藏"正在输入中"，让每条消息处理时控制

                for (let i = 0; i < aiMessages.length; i++) {
                    const msgData = aiMessages[i];
                    let aiMessage;
                    
            if (typeof msgData === 'object' && msgData !== null) {
                if (msgData.type === 'voice_message') {
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', type: 'voice_message', content: msgData.content, timestamp: Date.now() + i * 100 };
                } else if (msgData.type === 'ai_image') {
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', type: 'ai_image', content: msgData.description || 'AI描述的图片', imageDescription: msgData.description, timestamp: Date.now() + i * 100 };

                    // 🔥【关键修复】如果是群聊消息，添加发送者信息
                    if (msgData.name) {
                        console.log('🔍 [callChatAPI-AI图片] 检测到群聊消息，发送者:', msgData.name);
                        aiMessage.name = msgData.name;
                        // 查找对应的群成员ID
                        if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                            const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                            if (member) {
                                aiMessage.senderId = member.id;
                                console.log('🔍 [callChatAPI-AI图片] 找到群成员ID:', member.id);
                            } else {
                                console.log('🔍 [callChatAPI-AI图片] 未找到群成员:', msgData.name);
                            }
                        }
                    }
                } else if (msgData.type === 'transfer') {
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', type: 'transfer', amount: msgData.amount, note: msgData.note, timestamp: Date.now() + i * 100 };
                } else if (msgData.type === 'emoji' && !msgData.name) {
                    // 🔥【关键修复】处理表情包消息 - 仅处理没有name字段的表情包（非群聊格式）
                    const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.description);
                    if (matchingEmoji) {
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: '',
                            image: matchingEmoji.url,
                            isEmoji: true,
                            emojiDescription: matchingEmoji.description,
                            timestamp: Date.now() + i * 100
                        };

                        addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                    } else {
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: `[表情包"${msgData.description}"不存在]`,
                            timestamp: Date.now() + i * 100
                        };
                    }
                } else if (msgData.type === 'recall_previous') {
                    // 🔥【新增】处理AI撤回上一条消息
                    console.log('🔥 AI请求撤回上一条消息:', msgData);

                    // 查找上一条AI消息
                    const allMessages = chatMessages[currentChatCharacter.id] || [];
                    let lastAIMessageIndex = -1;

                    for (let j = allMessages.length - 1; j >= 0; j--) {
                        if (allMessages[j].sender === 'received') {
                            lastAIMessageIndex = j;
                            break;
                        }
                    }

                    if (lastAIMessageIndex !== -1) {
                        const messageToRecall = allMessages[lastAIMessageIndex];
                        console.log('🔥 找到要撤回的消息:', messageToRecall);

                        // 调用撤回消息处理函数
                        await handleRecalledMessage(messageToRecall.content, messageToRecall.id);
                    } else {
                        console.warn('🔥 没有找到可撤回的AI消息');
                        // 如果没有找到消息，显示一条提示
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: '[AI撤回了上一条消息]',
                            timestamp: Date.now() + i * 100
                        };
                    }
                    continue; // 跳过正常的消息处理流程
                } else if (msgData.type === 'change_avatar') {
                        if (msgData.avatar_url) {
                            // 🔥【修复】先处理占位符替换，再验证和执行头像更换
                            let actualAvatarUrl = msgData.avatar_url;
                            if (msgData.avatar_url === 'CURRENT_USER_IMAGE' ||
                                msgData.avatar_url === 'CURRENT_USER_IMAGE' ||
                                msgData.avatar_url === '用户发送的图片URL' ||
                                msgData.avatar_url === '图片URL') {
                                const recentUserImage = getRecentUserImage();
                                if (recentUserImage) {
                                    actualAvatarUrl = recentUserImage;
                                } else {
                                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[无法更换头像，没有找到可用的图片]', timestamp: Date.now() + i * 100 };
                                    continue;
                                }
                            }

                            const isValidAvatar = await validateAvatarSource(actualAvatarUrl);
                            if (isValidAvatar) {
                                const success = await changeCharacterAvatarByAI(actualAvatarUrl, msgData.reason || '心情变化');
                            if (success) continue;
                            else aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[头像更换失败]', timestamp: Date.now() + i * 100 };
                                } else {
                            aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[无效的头像来源，头像更换失败]', timestamp: Date.now() + i * 100 };
                                }
                            } else {
                        continue;
                    }
                } else if (msgData.type === 'reply_to') {
                    // 🔥【新增】处理AI引用回复
                    // 查找被引用的消息
                    const referencedMessage = findMessageById(msgData.message_id);

                    if (referencedMessage) {
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: msgData.content,
                            replyTo: {
                                id: referencedMessage.id,
                                content: referencedMessage.content,
                                senderName: referencedMessage.sender === 'sent' ? (getCurrentPersonaName() || '用户') : (currentChatCharacter.name || 'AI')
                            },
                            timestamp: Date.now() + i * 100
                        };
                    } else {
                        // 如果找不到被引用的消息，发送普通消息
                        console.warn('找不到被引用的消息ID:', msgData.message_id);
                        aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: msgData.content, timestamp: Date.now() + i * 100 };
                    }
                } else if (msgData.name && msgData.type === 'emoji') {
                    // 🔥【新增】处理直接的群聊表情包格式 {"name": "角色名", "type": "emoji", "description": "表情包描述"}
                    console.log('🔍 [群聊表情包-直接格式] 检测到直接格式的群聊表情包:', msgData);

                    let senderId = null;
                    if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                        console.log('🔍 [群聊表情包-直接格式] 查找成员详情:', {
                            targetName: msgData.name,
                            allMembers: currentChatCharacter.members,
                            memberNames: currentChatCharacter.members.map(m => m.name)
                        });

                        const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                        if (member) {
                            senderId = member.id;
                            console.log('🔍 [群聊表情包-直接格式] 找到成员:', member, 'senderId:', senderId);
                        } else {
                            console.warn('🔍 [群聊表情包-直接格式] 未找到成员:', msgData.name);
                            console.warn('🔍 [群聊表情包-直接格式] 可用成员名称:', currentChatCharacter.members.map(m => m.name));
                        }
                    }

                    const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.description);
                    if (matchingEmoji) {
                        console.log('🔍 [群聊表情包-直接格式] 找到匹配的表情包:', matchingEmoji);

                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            name: msgData.name,
                            senderId: senderId,
                            content: '', // 表情包消息不显示文字内容
                            image: matchingEmoji.url,
                            isEmoji: true,
                            emojiDescription: matchingEmoji.description,
                            timestamp: Date.now() + i * 100
                        };

                        console.log('🔍 [群聊表情包-直接格式] 创建的消息对象:', aiMessage);
                        addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                    } else {
                        console.warn('🔍 [群聊表情包-直接格式] 找不到匹配的表情包:', msgData.description);

                        // 如果找不到匹配的表情包，发送错误消息
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            name: msgData.name,
                            senderId: senderId,
                            content: `[表情包"${msgData.description}"不存在]`,
                            timestamp: Date.now() + i * 100
                        };
                    }
                } else if (msgData.name && msgData.message) {
                    // 🔥【关键修复】这是群聊的特殊格式，使用zhangyu.html兼容处理
                    console.log('🔍 [群聊消息] 处理群聊消息:', msgData);
                    console.log('🔍 [群聊消息] msgData.message类型:', typeof msgData.message, 'msgData.message:', msgData.message);

                    let senderId = null;
                    if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                        // 🔥【修复】优先使用persona字段查找成员
                        console.log('🔍 [群聊身份] 查找成员:', msgData.name, '在群聊:', currentChatCharacter.name);
                        console.log('🔍 [群聊身份] 群成员列表:', currentChatCharacter.members);

                        const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                        if (member) {
                            senderId = member.id;
                            console.log('🔍 [群聊身份] 找到成员:', member, 'senderId:', senderId);
                        } else {
                            console.warn('🔍 [群聊身份] 未找到成员:', msgData.name);
                        }
                    }

                    // --- 关键修复：检查群聊消息内容是否为特殊类型 ---
                    if (typeof msgData.message === 'object' && msgData.message.type === 'voice_message') {
                        // 如果消息内容是一个语音消息对象
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'voice_message', // 在外层消息上设置正确的类型
                            name: msgData.name,
                            senderId: senderId,
                            content: msgData.message.content, // 提取真正的语音文字内容
                            timestamp: Date.now() + i * 100
                        };
                    } else if (typeof msgData.message === 'object' && msgData.message.type === 'reply_to') {
                        // 🔥【新增】群聊中的引用回复
                        const referencedMessage = findMessageById(msgData.message.message_id);
                        if (referencedMessage) {
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                name: msgData.name,
                                senderId: senderId,
                                content: msgData.message.content,
                                replyTo: {
                                    id: referencedMessage.id,
                                    content: referencedMessage.content,
                                    senderName: referencedMessage.sender === 'sent' ? (getCurrentPersonaName() || '用户') : (referencedMessage.name || referencedMessage.senderName || 'AI')
                                },
                                timestamp: Date.now() + i * 100
                            };
                        } else {
                            // 如果找不到被引用的消息，发送普通群聊消息
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                name: msgData.name,
                                senderId: senderId,
                                content: msgData.message.content,
                                timestamp: Date.now() + i * 100
                            };
                        }
                    } else if (typeof msgData.message === 'object' && msgData.message.type === 'emoji') {
                        // 🔥【关键修复】如果消息内容是一个表情包对象
                        console.log('🔍 [群聊表情包] 检测到群聊表情包消息:', msgData);

                        const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.message.description);
                        if (matchingEmoji) {
                            console.log('🔍 [群聊表情包] 找到匹配的表情包:', matchingEmoji);

                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                name: msgData.name,
                                senderId: senderId,
                                content: '', // 表情包消息不显示文字内容
                                image: matchingEmoji.url,
                                isEmoji: true,
                                emojiDescription: matchingEmoji.description,
                                timestamp: Date.now() + i * 100
                            };

                            console.log('🔍 [群聊表情包] 创建的消息对象:', aiMessage);
                            console.log('🔍 [群聊表情包] senderId设置为:', senderId, 'name设置为:', msgData.name);

                            addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                        } else {
                            console.warn('🔍 [群聊表情包] 找不到匹配的表情包:', msgData.message.description);

                            // 如果找不到匹配的表情包，发送错误消息
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                name: msgData.name,
                                senderId: senderId,
                                content: `[表情包"${msgData.message.description}"不存在]`,
                                timestamp: Date.now() + i * 100
                            };
                        }
                    } else if (typeof msgData.message === 'object' && msgData.message.type === 'transfer') {
                        // 🔥【修复】如果消息内容是一个转账对象
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'transfer', // 在外层消息上设置正确的类型
                            name: msgData.name,
                            senderId: senderId,
                            amount: msgData.message.amount, // 提取转账金额
                            note: msgData.message.note, // 提取转账备注
                            timestamp: Date.now() + i * 100
                        };
                    } else if (typeof msgData.message === 'object' && msgData.message.type === 'friend_request') {
                        // 🔥【新增】如果消息内容是一个好友申请对象
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'friend_request', // 在外层消息上设置正确的类型
                            name: msgData.name,
                            senderId: senderId,
                            message: msgData.message.message, // 提取好友申请消息
                            timestamp: Date.now() + i * 100
                        };
                    } else {
                        // 对于普通的文本消息
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            name: msgData.name,
                            senderId: senderId,
                            content: msgData.message, // 内容本身是字符串
                            timestamp: Date.now() + i * 100
                        };
                    }
                    // --- 修复结束 ---
                        } else {
                    // 🔥【关键修复】检查是否是特殊类型对象但未被上面的条件捕获
                    if (typeof msgData === 'object' && msgData !== null) {
                        if (msgData.type === 'transfer') {
                            // 转账对象被遗漏了，重新处理
                            aiMessage = { 
                                id: (Date.now() + i).toString(), 
                                sender: 'received', 
                                type: 'transfer', 
                                amount: msgData.amount, 
                                note: msgData.note, 
                                timestamp: Date.now() + i * 100 
                            };
                        } else if (msgData.type === 'voice_message') {
                            // 语音消息对象被遗漏了，重新处理
                            aiMessage = { 
                                id: (Date.now() + i).toString(), 
                                sender: 'received', 
                                type: 'voice_message', 
                                content: msgData.content, 
                                timestamp: Date.now() + i * 100 
                            };
                        } else if (msgData.type === 'ai_image') {
                            // AI图片对象被遗漏了，重新处理
                            aiMessage = { 
                                id: (Date.now() + i).toString(), 
                                sender: 'received', 
                                type: 'ai_image', 
                                content: '', 
                                image: `data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="200" height="150" viewBox="0 0 200 150"><rect width="200" height="150" fill="#f0f0f0"/><text x="100" y="75" text-anchor="middle" font-family="Arial" font-size="12" fill="#666">[AI描述的图片]</text></svg>')}`, 
                                imageDescription: msgData.description, 
                                timestamp: Date.now() + i * 100 
                            };
                        } else if (msgData.type === 'emoji') {
                            // 🔥【修复】表情包对象被遗漏了，重新处理 - 支持群聊
                            console.log('🔍 [遗漏表情包] 检测到遗漏的表情包对象:', msgData);

                            const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.description);
                            if (matchingEmoji) {
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    content: '',
                                    image: matchingEmoji.url,
                                    isEmoji: true,
                                    emojiDescription: matchingEmoji.description,
                                    timestamp: Date.now() + i * 100
                                };

                                // 🔥【关键修复】如果是群聊，需要设置发送者信息
                                if (currentChatCharacter && currentChatCharacter.isGroup) {
                                    // 对于群聊中的表情包，需要指定是哪个角色发送的
                                    // 由于这是在处理遗漏的表情包对象，我们需要从当前群聊中选择一个默认角色
                                    if (currentChatCharacter.members && currentChatCharacter.members.length > 0) {
                                        const defaultMember = currentChatCharacter.members[0];
                                        aiMessage.name = defaultMember.name;
                                        aiMessage.senderId = defaultMember.id;
                                        console.log('🔍 [遗漏表情包] 设置默认发送者:', defaultMember.name, 'ID:', defaultMember.id);
                                    }
                                }

                                console.log('🔍 [遗漏表情包] 创建的消息对象:', aiMessage);

                                addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                            } else {
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    content: `[表情包"${msgData.description}"不存在]`,
                                    timestamp: Date.now() + i * 100
                                };

                                // 🔥【关键修复】错误消息也需要群聊发送者信息
                                if (currentChatCharacter && currentChatCharacter.isGroup) {
                                    if (currentChatCharacter.members && currentChatCharacter.members.length > 0) {
                                        const defaultMember = currentChatCharacter.members[0];
                                        aiMessage.name = defaultMember.name;
                                        aiMessage.senderId = defaultMember.id;
                                    }
                                }
                            }
                        } else {
                            // 其他对象类型，尝试提取文本内容
                            const displayContent = msgData.content || msgData.message || msgData.text || msgData.reply || '[不支持的消息格式]';
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: displayContent, timestamp: Date.now() + i * 100 };
                        }
                                            } else {
                        // 普通字符串或其他基本类型
                        const displayContent = String(msgData);
                        aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: displayContent, timestamp: Date.now() + i * 100 };
                    }
                        }
                                            } else {
                // 🔥【关键修复 - regenerateLastResponse版本】检查是否是特殊类型对象但未被上面的条件捕获
                if (typeof msgData === 'object' && msgData !== null) {
                    if (msgData.type === 'transfer') {
                        // 转账对象被遗漏了，重新处理
                        aiMessage = { 
                            id: (Date.now() + i).toString(), 
                            sender: 'received', 
                            type: 'transfer', 
                            amount: msgData.amount, 
                            note: msgData.note, 
                            timestamp: Date.now() + i * 100 
                        };
                    } else if (msgData.type === 'voice_message') {
                        // 语音消息对象被遗漏了，重新处理
                        aiMessage = { 
                            id: (Date.now() + i).toString(), 
                            sender: 'received', 
                            type: 'voice_message', 
                            content: msgData.content, 
                            timestamp: Date.now() + i * 100 
                        };
                    } else if (msgData.type === 'ai_image') {
                        // AI图片对象被遗漏了，重新处理
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'ai_image',
                            content: msgData.description || 'AI描述的图片',
                            imageDescription: msgData.description,
                            timestamp: Date.now() + i * 100
                        };

                        // 🔥【关键修复】如果是群聊消息，添加发送者信息
                        if (msgData.name) {
                            console.log('🔍 [第四处-AI图片] 检测到群聊消息，发送者:', msgData.name);
                            aiMessage.name = msgData.name;
                            // 查找对应的群成员ID
                            if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                                const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                                if (member) {
                                    aiMessage.senderId = member.id;
                                    console.log('🔍 [第四处-AI图片] 找到群成员ID:', member.id);
                                } else {
                                    console.log('🔍 [第四处-AI图片] 未找到群成员:', msgData.name);
                                }
                            }
                        }
                    } else if (msgData.type === 'emoji') {
                        // 表情包对象被遗漏了，重新处理
                        const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.description);
                        if (matchingEmoji) {
                            aiMessage = { 
                                id: (Date.now() + i).toString(), 
                                sender: 'received', 
                                content: '', 
                                image: matchingEmoji.url, 
                                isEmoji: true, 
                                emojiDescription: matchingEmoji.description, 
                                timestamp: Date.now() + i * 100 
                            };
                            addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                        } else {
                            aiMessage = { 
                                id: (Date.now() + i).toString(), 
                                sender: 'received', 
                                content: `[表情包"${msgData.description}"不存在]`, 
                                timestamp: Date.now() + i * 100 
                            };
                        }
                    } else {
                        // 其他对象类型，尝试提取文本内容
                        const displayContent = msgData.content || msgData.message || msgData.text || msgData.reply || '[不支持的消息格式]';
                        aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: displayContent, timestamp: Date.now() + i * 100 };
                    }
                } else if (typeof msgData === 'string') {
                    // 普通字符串
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: msgData, timestamp: Date.now() + i * 100 };
                } else {
                    // 其他基本类型
                aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: String(msgData), timestamp: Date.now() + i * 100 };
                }
                    }
                    
                    chatMessages[characterId].push(aiMessage);
            await saveChatMessages();

            // 🔥【新增】记录AI回复到全局记忆事件
            const character = characters.find(c => c.id === characterId);
            if (character) {
                // 🔥【修复】构建安全的事件数据，避免循环引用
                const eventData = {
                    sender: characterId,
                    content: aiMessage.content || '[特殊消息]',
                    messageType: aiMessage.type || 'text'
                };

                // 🔥【修复】如果是引用消息，添加引用信息但避免对象嵌套
                if (aiMessage.replyTo) {
                    eventData.replyToId = aiMessage.replyTo.id;
                    eventData.replyToSender = aiMessage.replyTo.senderName;
                    eventData.replyToContent = aiMessage.replyTo.content;
                }

                await recordMemoryEvent(
                    [characterId, 'user'],
                    {
                        type: character.isGroup ? 'group_chat' : 'private_chat',
                        id: characterId
                    },
                    'message',
                    eventData,
                    0.7 // AI消息重要性
                );
            }

                    // 🔥【修复】在第一条消息处理完后隐藏"正在输入中"
                    if (i === 0) {
                        hideTypingIndicator();
                    }

                    // 🔥【修复】使用addMessageWithAnimation添加单个消息，而不是重新渲染整个列表
                    addMessageWithAnimation(aiMessage, characterId);

                    // 🔥【修复】在消息之间正确显示"正在输入中"提示
                    if (i < aiMessages.length - 1) {
                        const delay = Math.random() * 1000 + 500;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        showTypingIndicator();
                        await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));
                        hideTypingIndicator();
                    }
                }
            } catch (error) {
                console.error('重新生成失败:', error);
                hideTypingIndicator();
                const errorMessage = {
                    id: Date.now().toString(),
                    sender: 'received',
                    content: `[重新生成失败: ${error.message}]`,
                    timestamp: Date.now()
                };
                chatMessages[characterId].push(errorMessage);
        await saveChatMessages();
                renderChatMessages(characterId);
            } finally {
                // 🔥【修复】在这里也清除待回复消息，并重置重新生成标志
                pendingUserMessage = null;
                window._isRegenerating = false;
            }
            
            updateFloatingButtonsVisibility();
        }

        // 智能回复功能
        function triggerSmartReply() {
            if (!currentChatCharacter) {
                alert('请先选择一个角色');
                return;
            }

            if (isWaitingForReply) {
                // 🔥【修复】不使用弹窗，改为显示按钮状态提示
                return;
            }

            const messages = chatMessages[currentChatCharacter.id] || [];
            
            // 找到最后一条用户消息
            let lastUserMessage = null;
            let hasUnrepliedUserMessage = false;
            
            for (let i = messages.length - 1; i >= 0; i--) {
                if (messages[i].sender === 'sent') {
                    lastUserMessage = messages[i];
                    
                    // 检查这条用户消息后是否有AI回复
                    hasUnrepliedUserMessage = true;
                    for (let j = i + 1; j < messages.length; j++) {
                        if (messages[j].sender === 'received') {
                            hasUnrepliedUserMessage = false;
                            break;
                        }
                    }
                    break;
                }
            }
            
            // 情况1：有未回复的用户消息
            if (lastUserMessage && hasUnrepliedUserMessage) {
                pendingUserMessage = lastUserMessage;
            processAIReply();
                return;
            }
            
            // 情况2：最后的用户消息已有AI回复，需要AI续写
            if (lastUserMessage && !hasUnrepliedUserMessage) {
                // 检查从最后一条用户消息后的AI回复回合数
                let aiReplyRounds = 0;
                let lastUserMessageIndex = -1;
                
                // 找到最后一条用户消息的索引
                for (let i = messages.length - 1; i >= 0; i--) {
                    if (messages[i].sender === 'sent') {
                        lastUserMessageIndex = i;
                        break;
                    }
                }
                
                // 计算从最后一条用户消息后的AI回复回合数
                // 一回合 = 连续的AI消息直到下一个断点
                if (lastUserMessageIndex !== -1) {
                    let inAIReplyRound = false;
                    
                    for (let i = lastUserMessageIndex + 1; i < messages.length; i++) {
                        if (messages[i].sender === 'received') {
                            if (!inAIReplyRound) {
                                // 开始新的AI回复回合
                                aiReplyRounds++;
                                inAIReplyRound = true;
                            }
                            // 继续当前回合（多条连续AI消息算一回合）
                        } else {
                            // 如果有其他类型消息，结束当前回合
                            inAIReplyRound = false;
                        }
                    }
                }
                
                // AI回复逻辑：
                // aiReplyRounds = 0: 没有回复用户消息，不应该到这里
                // aiReplyRounds = 1: 已回复用户消息1回合，现在是第1次续写（第2回合）
                // aiReplyRounds = 2: 已回复+续写1回合，现在是第2次续写（第3回合）
                // aiReplyRounds >= 3: 已回复+续写2回合，提示用户发消息
                
                if (aiReplyRounds >= 3) {
                    const characterName = currentChatCharacter.name;
                    alert(`${characterName}已经说了很多话了，先和${characterName}说说话吧~`);
                    return;
                }
                
                // 🔥【修复】在续写前也要检查是否有未处理的转账
                const lastUserTransfer = messages.slice().reverse().find(msg => 
                    msg.sender === 'sent' && msg.type === 'transfer' && !msg.status);
                if (lastUserTransfer) {
                    // 如果有未处理的转账，先设置为待处理，然后处理回复
                    pendingUserMessage = lastUserTransfer;
                    processAIReply();
                    return;
                }
                
                // AI续写对话（第1次或第2次续写）
                processAIContinuation();
                return;
            }
            
            // 情况3：没有用户消息
            alert('请先发送一条消息，然后点击此按钮来获取AI回复');
        }

                // 处理AI续写对话
        async function processAIContinuation() {
            if (!currentChatCharacter) return;
            
            // 防止重复调用
            if (isWaitingForReply) {
                console.log('AI正在续写中，忽略重复调用');
                return;
            }
            
            // 🔥【关键修复】记录当前聊天角色ID，确保AI续写消息归属到正确的聊天窗口
            const continuingCharacterId = currentChatCharacter.id;

            isWaitingForReply = true;
            
            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.disabled = true;
                smartReplyBtn.style.opacity = '0.65';
                smartReplyBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            }

            // 显示正在输入提示
            showTypingIndicator();
            
            // 添加随机延迟
            const delay = Math.random() * 2000 + 1000;
            await new Promise(resolve => setTimeout(resolve, delay));

            try {
                // 获取AI最后的消息内容，以便基于此续写
                const messages = chatMessages[continuingCharacterId] || [];
                let lastAIMessage = "";
                
                // 找到最后一条AI消息
                for (let i = messages.length - 1; i >= 0; i--) {
                    if (messages[i].sender === 'received') {
                        lastAIMessage = messages[i].content || "";
                        break;
                    }
                }
                
                // 构建续写提示词，基于AI自己最后的话来续写
                let continuationPrompt = "你刚才说了：\"" + lastAIMessage + "\"\n\n";
                continuationPrompt += "现在请基于你刚才说的话，主动继续这个话题或者自然地转到相关话题。就像真实聊天中，你想要继续表达更多想法，或者询问对方的看法，或者分享相关的内容。请自然地继续对话，不要重复之前说过的话。";
                continuationPrompt += "\n\n🚨 重要提醒：请严格遵守JSON格式，每条消息必须分开发送，绝对不能将多条消息合并在一个元素中！正确格式：[\"消息1\", \"消息2\"]，错误格式：[\"消息1\\n消息2\"]";
                
                const response = await callChatAPI(continuationPrompt, currentChatCharacter);
                const aiMessages = parseAiResponse(response);
                
                // 🔥【修复】在续写时也要检查是否有转账需要处理
                const chatHistory = chatMessages[continuingCharacterId] || [];
                const lastUserMessage = chatHistory.slice().reverse().find(msg => 
                    msg.sender === 'sent' && msg.type === 'transfer' && !msg.status);
                if (lastUserMessage) {
                    console.log('🔥 [续写] 检测到用户转账消息，开始处理转账:', {
                        lastUserMessage,
                        aiMessages,
                        characterName: currentChatCharacter?.name
                    });
                    await processUserTransfer(lastUserMessage, aiMessages);
                }
                
                hideTypingIndicator();
                
                // 逐条发送消息
                for (let i = 0; i < aiMessages.length; i++) {
                    const msgData = aiMessages[i];
                    let aiMessage;
                    
                    if (typeof msgData === 'object' && msgData.type === 'recall_previous') {
                        // 🔥【新增】处理AI撤回上一条消息
                        console.log('🔥 [续写] AI请求撤回上一条消息:', msgData);

                        // 查找上一条AI消息
                        const allMessages = chatMessages[continuingCharacterId] || [];
                        let lastAIMessageIndex = -1;

                        for (let j = allMessages.length - 1; j >= 0; j--) {
                            if (allMessages[j].sender === 'received') {
                                lastAIMessageIndex = j;
                                break;
                            }
                        }

                        if (lastAIMessageIndex !== -1) {
                            const messageToRecall = allMessages[lastAIMessageIndex];
                            console.log('🔥 [续写] 找到要撤回的消息:', messageToRecall);

                            // 调用撤回消息处理函数
                            await handleRecalledMessage(messageToRecall.content, messageToRecall.id);
                        } else {
                            console.warn('🔥 [续写] 没有找到可撤回的AI消息');
                        }
                        continue; // 跳过正常的消息处理流程
                    } else if (typeof msgData === 'object' && msgData.type === 'voice_message') {
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'voice_message',
                            content: msgData.content,
                            timestamp: Date.now() + i * 100
                        };
                    } else if (typeof msgData === 'object' && msgData.type === 'ai_image') {
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'ai_image',
                            content: msgData.description || 'AI描述的图片',
                            imageDescription: msgData.description,
                            timestamp: Date.now() + i * 100
                        };

                        // 🔥【关键修复】如果是群聊消息，添加发送者信息
                        if (msgData.name) {
                            console.log('🔍 [第三处-AI图片] 检测到群聊消息，发送者:', msgData.name);
                            aiMessage.name = msgData.name;
                            // 查找对应的群成员ID
                            if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                                const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                                if (member) {
                                    aiMessage.senderId = member.id;
                                    console.log('🔍 [第三处-AI图片] 找到群成员ID:', member.id);
                                } else {
                                    console.log('🔍 [第三处-AI图片] 未找到群成员:', msgData.name);
                                }
                            }
                        }
                    } else if (typeof msgData === 'object' && msgData.type === 'transfer') {
                        aiMessage = { 
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'transfer', 
                            amount: msgData.amount, 
                            note: msgData.note, 
                            timestamp: Date.now() + i * 100
                        };
                    } else if (typeof msgData === 'object' && msgData.type === 'emoji') {
                        // 处理AI发送的表情包 - 从本地表情包库中查找
                        const matchingEmoji = customEmojis.find(emoji => 
                            emoji.description === msgData.description
                        );
                        
                        if (matchingEmoji) {
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                content: '',
                                image: matchingEmoji.url,
                                isEmoji: true,
                                emojiDescription: matchingEmoji.description,
                                timestamp: Date.now() + i * 100
                            };

                            // 🔥【修复】如果是群聊消息，添加发送者信息
                            if (msgData.name) {
                                aiMessage.name = msgData.name;
                                // 查找对应的群成员ID
                                if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                                    const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                                    if (member) {
                                        aiMessage.senderId = member.id;
                                    }
                                }
                            }

                            // 将表情包添加到最近使用
                            addToRecentEmojis({
                                id: matchingEmoji.id,
                                url: matchingEmoji.url,
                                description: matchingEmoji.description
                            });
                        } else {
                            // 如果找不到表情包，显示错误信息
                            aiMessage = { 
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                content: `[表情包"${msgData.description}"不存在]`,
                                timestamp: Date.now() + i * 100
                            };
                        }
                    } else if (typeof msgData === 'object' && msgData.type === 'change_avatar') {
                        // 🔥【新增】处理头像更换对象
                        console.log('处理头像更换消息(续写):', msgData);
                        if (msgData.avatar_url) {
                            // 🔥【修复】先处理占位符替换，再验证和执行头像更换
                            let actualAvatarUrl = msgData.avatar_url;
                            if (msgData.avatar_url === 'CURRENT_USER_IMAGE' ||
                                msgData.avatar_url === 'CURRENT_USER_IMAGE' ||
                                msgData.avatar_url === '用户发送的图片URL' ||
                                msgData.avatar_url === '图片URL') {
                                const recentUserImage = getRecentUserImage();
                                if (recentUserImage) {
                                    actualAvatarUrl = recentUserImage;
                                } else {
                                    aiMessage = {
                                        id: (Date.now() + i).toString(),
                                        sender: 'received',
                                        content: '[无法更换头像，没有找到可用的图片]',
                                        timestamp: Date.now() + i * 100
                                    };
                                    continue;
                                }
                            }

                            // 验证头像URL是否来自用户发送的图片或世界书中的URL
                            const isValidAvatar = await validateAvatarSource(actualAvatarUrl);
                            console.log('头像来源验证结果(续写):', isValidAvatar, '头像URL:', actualAvatarUrl);

                            if (isValidAvatar) {
                                // 执行头像更换
                                const success = await changeCharacterAvatarByAI(actualAvatarUrl, msgData.reason || '心情变化');
                                console.log('头像更换执行结果(续写):', success);
                                if (success) {
                                    // 跳过这条消息，只执行头像更换，系统消息已在changeCharacterAvatarByAI中添加
                                    continue;
                                } else {
                                    aiMessage = {
                                        id: (Date.now() + i).toString(),
                                        sender: 'received',
                                        content: '[头像更换失败]',
                                        timestamp: Date.now() + i * 100
                                    };
                                }
                            } else {
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    content: '[无效的头像来源，头像更换失败]',
                                    timestamp: Date.now() + i * 100
                                };
                            }
                        } else {
                            console.log('头像更换消息缺少avatar_url(续写)');
                            continue; // 如果没有有效的头像URL，跳过此消息
                        }
                    } else if (typeof msgData === 'object' && msgData !== null && msgData.name && msgData.message) {
                        // 🔥【群聊消息关键修复】群聊消息格式: {name: "角色名", message: "消息内容"}
                        console.log('🔥 [修复continuation] 发现群聊消息:', msgData);
                        
                        // 查找群成员ID
                        let senderId = null;
                        if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                            const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                            if (member) {
                                senderId = member.id;
                            }
                        }
                        
                        // --- 关键修复：检查群聊消息内容是否为特殊类型 ---
                        if (typeof msgData.message === 'object' && msgData.message.type === 'voice_message') {
                            // 如果消息内容是一个语音消息对象
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                type: 'voice_message', // 在外层消息上设置正确的类型
                                name: msgData.name,
                                senderId: senderId,
                                content: msgData.message.content, // 提取真正的语音文字内容
                                timestamp: Date.now() + i * 100
                            };
                        } else {
                            // 对于普通的文本消息
                        aiMessage = { 
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            name: msgData.name,          // 保存发言者名字
                            senderId: senderId,          // 保存发言者ID
                            content: msgData.message,    // 使用message字段作为内容
                            timestamp: Date.now() + i * 100
                        };
                        }
                        // --- 修复结束 ---
                        console.log('✅ [修复continuation] 群聊消息已正确解析:', aiMessage);
                                            } else {
                        // 🔥【关键修复 - 续写版本】检查是否是特殊类型对象但未被上面的条件捕获
                        if (typeof msgData === 'object' && msgData !== null) {
                            if (msgData.type === 'transfer') {
                                // 转账对象被遗漏了，重新处理
                                aiMessage = { 
                                    id: (Date.now() + i).toString(), 
                                    sender: 'received', 
                                    type: 'transfer', 
                                    amount: msgData.amount, 
                                    note: msgData.note, 
                                    timestamp: Date.now() + i * 100 
                                };
                            } else if (msgData.type === 'voice_message') {
                                // 语音消息对象被遗漏了，重新处理
                                aiMessage = { 
                                    id: (Date.now() + i).toString(), 
                                    sender: 'received', 
                                    type: 'voice_message', 
                                    content: msgData.content, 
                                    timestamp: Date.now() + i * 100 
                                };
                            } else if (msgData.type === 'ai_image') {
                                // AI图片对象被遗漏了，重新处理
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    type: 'ai_image',
                                    content: msgData.description || 'AI描述的图片',
                                    imageDescription: msgData.description,
                                    timestamp: Date.now() + i * 100
                                };

                                // 🔥【关键修复】如果是群聊消息，添加发送者信息
                                if (msgData.name) {
                                    console.log('🔍 [第五处-AI图片] 检测到群聊消息，发送者:', msgData.name);
                                    aiMessage.name = msgData.name;
                                    // 查找对应的群成员ID
                                    if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                                        const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                                        if (member) {
                                            aiMessage.senderId = member.id;
                                            console.log('🔍 [第五处-AI图片] 找到群成员ID:', member.id);
                                        } else {
                                            console.log('🔍 [第五处-AI图片] 未找到群成员:', msgData.name);
                                        }
                                    }
                                }
                            } else if (msgData.type === 'emoji') {
                                // 表情包对象被遗漏了，重新处理
                                const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.description);
                                if (matchingEmoji) {
                                    aiMessage = {
                                        id: (Date.now() + i).toString(),
                                        sender: 'received',
                                        content: '',
                                        image: matchingEmoji.url,
                                        isEmoji: true,
                                        emojiDescription: matchingEmoji.description,
                                        timestamp: Date.now() + i * 100
                                    };

                                    // 🔥【修复】如果是群聊消息，添加发送者信息
                                    if (msgData.name) {
                                        aiMessage.name = msgData.name;
                                        // 查找对应的群成员ID
                                        if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                                            const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                                            if (member) {
                                                aiMessage.senderId = member.id;
                                            }
                                        }
                                    }

                                    addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                                } else {
                                    aiMessage = { 
                                        id: (Date.now() + i).toString(), 
                                        sender: 'received', 
                                        content: `[表情包"${msgData.description}"不存在]`, 
                                        timestamp: Date.now() + i * 100 
                                    };
                                }
                            } else {
                                // 其他对象类型，尝试提取文本内容
                                const displayContent = msgData.content || msgData.message || msgData.text || msgData.reply || '[不支持的消息格式]';
                                aiMessage = { 
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    content: displayContent, 
                                    timestamp: Date.now() + i * 100
                                };
                            }
                        } else if (typeof msgData === 'string') {
                            // 普通字符串
                            aiMessage = { 
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                content: msgData, 
                                timestamp: Date.now() + i * 100
                            };
                        } else {
                            // 其他基本类型
                        aiMessage = { 
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: String(msgData), 
                            timestamp: Date.now() + i * 100
                        };
                        }
                    }
                    
                    chatMessages[continuingCharacterId].push(aiMessage);
                    saveChatMessages();
                    addMessageWithAnimation(aiMessage, continuingCharacterId);
                    
                    // 🔥【修复】为续写的每条消息创建推送通知 - 使用正确的角色对象
                    if (typeof msgData === 'string' ||
                        (typeof msgData === 'object' && (msgData.type || (msgData.name && msgData.message)))) {
                        console.log('🔥 [推送通知] 续写消息，创建推送通知:', msgData);
                        // 🔥【关键修复】获取正在续写的角色对象，而不是当前聊天角色
                        const continuingCharacter = characters.find(c => c.id === continuingCharacterId);
                        if (continuingCharacter) {
                            createPushNotification(continuingCharacter, msgData, i * 500);
                        }
                    }
                    
                    if (i < aiMessages.length - 1) {
                        const delay = Math.random() * 1000 + 500;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        
                        if (i < aiMessages.length - 1) {
                            showTypingIndicator();
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));
                            hideTypingIndicator();
                        }
                    }
                }

                // 🔥【修复】AI续写完成后更新消息列表，确保未读消息计数正确
                renderMessageList();
            } catch (error) {
                console.error('AI续写失败:', error);
                hideTypingIndicator();

                const errorMessage = {
                    id: Date.now().toString(),
                    sender: 'received',
                    content: `[续写失败: ${error.message}]`,
                    timestamp: Date.now()
                };

                chatMessages[continuingCharacterId].push(errorMessage);
                saveChatMessages();
                addMessageWithAnimation(errorMessage, continuingCharacterId);

                // 🔥【修复】错误消息也需要更新消息列表
                renderMessageList();
            } finally {
                // 重置状态
                isWaitingForReply = false;
                pendingUserMessage = null;

                // 恢复智能回复按钮
                if (smartReplyBtn) {
                    smartReplyBtn.disabled = false;
                    smartReplyBtn.style.opacity = '';
                    smartReplyBtn.style.animation = 'none';
                    smartReplyBtn.classList.remove('waiting');
                    smartReplyBtn.innerHTML = '<i class="fas fa-comment-dots"></i>';
                    smartReplyBtn.title = '获取AI回复';
                }

                // 更新按钮显示状态
                updateFloatingButtonsVisibility();
            }
        }

        // 🔥【新增】统一的消息创建函数，减少重复代码
        function createAIMessage(msgData, index = 0) {
            const baseMessage = {
                id: (Date.now() + index).toString(),
                sender: 'received',
                timestamp: Date.now() + index * 100
            };

            // 处理群聊发送者信息
            if (msgData.name && currentChatCharacter?.isGroup && currentChatCharacter.members) {
                const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                if (member) {
                    baseMessage.name = msgData.name;
                    baseMessage.senderId = member.id;
                    console.log(`🔍 [createAIMessage] 设置群聊发送者: ${msgData.name} (ID: ${member.id})`);
                } else {
                    console.warn(`🔍 [createAIMessage] 未找到群成员: ${msgData.name}`);
                }
            }

            // 根据消息类型设置特定字段
            switch (msgData.type) {
                case 'ai_image':
                    return {
                        ...baseMessage,
                        type: 'ai_image',
                        content: msgData.description || 'AI描述的图片',
                        imageDescription: msgData.description
                    };
                case 'voice_message':
                    return {
                        ...baseMessage,
                        type: 'voice_message',
                        content: msgData.content
                    };
                case 'transfer':
                    return {
                        ...baseMessage,
                        type: 'transfer',
                        amount: msgData.amount,
                        note: msgData.note
                    };
                case 'emoji':
                    const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.description);
                    if (matchingEmoji) {
                        const emojiMessage = {
                            ...baseMessage,
                            content: '',
                            image: matchingEmoji.url,
                            isEmoji: true,
                            emojiDescription: matchingEmoji.description
                        };
                        addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                        return emojiMessage;
                    } else {
                        return {
                            ...baseMessage,
                            content: `[表情包"${msgData.description}"不存在]`
                        };
                    }
                default:
                    return {
                        ...baseMessage,
                        content: msgData.content || msgData.message || ''
                    };
            }
        }

        // 处理AI回复
        async function processAIReply() {
            if (!currentChatCharacter) return;
            
            // 防止重复调用
            if (isWaitingForReply) {
                console.log('AI正在回复中，忽略重复调用');
                return;
            }
            
            // 🔥【关键修复】记录当前聊天角色ID，确保AI回复归属到正确的聊天窗口
            const replyingCharacterId = currentChatCharacter.id;
            
            // 智能选择最佳的用户消息（优先图片消息）
            const messages = chatMessages[replyingCharacterId] || [];
            const userMessages = messages.filter(msg => msg.sender === 'sent');
            
            // 优先查找最近的包含图片的消息（5条消息内）
            const recentMessages = userMessages.slice(-5);
            const imageMessage = recentMessages.reverse().find(msg => 
                Array.isArray(msg.content) || msg.image
            );
            
            if (imageMessage) {
                pendingUserMessage = imageMessage;
            } else if (!pendingUserMessage) {
                // 如果没有图片消息且没有待回复消息，使用最后一条用户消息
                const lastUserMessage = userMessages.pop();
                if (lastUserMessage) {
                    pendingUserMessage = lastUserMessage;
                } else {
                    return;
                }
            }

            isWaitingForReply = true;
            
            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.disabled = true;
                smartReplyBtn.style.opacity = '0.65';
                smartReplyBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            }

            // 显示正在输入提示
            showTypingIndicator();
            
            // 添加随机延迟
            const delay = Math.random() * 2000 + 1000;
            await new Promise(resolve => setTimeout(resolve, delay));

            try {
                // 调用API，支持图片和表情包
                // 🔥【核心修复】正确处理多模态消息
                let response;
                

                
                // 核心修复：直接将 pendingUserMessage.content (可能是数组) 传递给 callChatAPI
                if (Array.isArray(pendingUserMessage.content)) {
                    // 这是多模态消息（图文）
                    response = await callChatAPI(pendingUserMessage.content, currentChatCharacter);
                } else if (pendingUserMessage.image) {
                    // 兼容旧的图片消息格式
                    const messageContent = [
                        { type: 'text', text: pendingUserMessage.content || "" },
                        { type: 'image_url', image_url: { url: pendingUserMessage.image } }
                    ];
                    response = await callChatAPI(messageContent, currentChatCharacter);
                } else if (pendingUserMessage.type === 'transfer') {
                    // 🔥【关键修复】转账消息特殊处理 - 构造转账提示文本
                    const transferPrompt = `[用户发起了转账：${pendingUserMessage.amount}元，备注：${pendingUserMessage.note || '无'}]`;
                    response = await callChatAPI(transferPrompt, currentChatCharacter);
                } else {
                    // 普通文本消息、位置消息、语音消息等
                    let finalPrompt = pendingUserMessage.content; // 默认使用原始消息内容

                    // 🔥【关键修复】检查当前用户消息是否为引用回复
                    if (pendingUserMessage.replyTo) {
                        // 使用 summarizeLastMessage 函数来截断被引用的消息内容
                        const quoteText = summarizeLastMessage({ content: pendingUserMessage.replyTo.content });

                        // 构建带有引用上下文的提示字符串
                        // 例如: [回复 AI的昵称 的消息: "你好呀"]: 我也很好
                        finalPrompt = `[回复 ${pendingUserMessage.replyTo.senderName} 的消息: "${quoteText}"] ${pendingUserMessage.content}`;
                        console.log('✅ 构建用户引用提示:', finalPrompt);
                    }

                    response = await callChatAPI(finalPrompt, currentChatCharacter);
                }
                
                const aiMessages = parseAiResponse(response);
                
                for (const msgData of aiMessages) {
    // 检查是否是拉黑指令对象
    if (typeof msgData === 'object' && msgData !== null && msgData.type === 'block_user') {
        console.log('🚫 检测到AI拉黑指令对象:', msgData);
        // 使用指令中的 reason 作为拉黑理由
        await aiBlockUser(currentChatCharacter.id, msgData.reason || '对方未说明理由');
        // 拉黑后，通常不需要再显示后续消息，直接跳出循环
        break; 
    }
}
                
                // 🔥【修复转账处理】如果用户发的是转账消息，需要分析AI的回复来处理转账
                if (pendingUserMessage && pendingUserMessage.type === 'transfer') {
                    console.log('🔥 检测到用户转账消息，开始处理转账:', {
                        pendingUserMessage,
                        aiMessages,
                        characterName: currentChatCharacter?.name
                    });
                    await processUserTransfer(pendingUserMessage, aiMessages);
                }
                
                // 🔥【紧急修复】无论如何，每次AI回复后都检查是否有未处理的转账
                console.log('🔥 [紧急修复] AI回复完成，检查未处理转账');
                const allMessages = chatMessages[replyingCharacterId] || [];
                const unprocessedTransfer = allMessages.slice().reverse().find(msg => 
                    msg.sender === 'sent' && msg.type === 'transfer' && !msg.status);
                if (unprocessedTransfer) {
                    console.log('🔥 [紧急修复] 发现未处理转账，立即处理:', unprocessedTransfer);
                    await processUserTransfer(unprocessedTransfer, aiMessages);
                }
                
                // 🔥【移除关键词触发机制】现在AI会根据自己的判断主动发起通话，不再需要外部触发逻辑
                
                // 🔥【修复】为AI的每条回复创建推送通知 - 使用正确的角色对象
                console.log('🔔 [推送通知] AI回复完成，准备创建推送通知，消息数量:', aiMessages.length);
                // 🔥【关键修复】获取正在回复的角色对象，而不是当前聊天角色
                const replyingCharacter = characters.find(c => c.id === replyingCharacterId);
                if (replyingCharacter) {
                    for (let i = 0; i < aiMessages.length; i++) {
                        const msgData = aiMessages[i];
                        console.log('🔔 [推送通知] 处理消息', i, ':', msgData);
                        if (typeof msgData === 'string' ||
                            (typeof msgData === 'object' && (msgData.type || (msgData.name && msgData.message)))) {
                            createPushNotification(replyingCharacter, msgData, i * 500);
                        }
                    }
                } else {
                    console.warn('🔔 [推送通知] 找不到回复角色，跳过推送通知创建');
                }

                // 🔥【移除重复记录】这里的时间线记录逻辑已移动到下面的单条消息处理中，避免重复记录
                
// --- 请用这段全新的代码替换 ---
                hideTypingIndicator();
                
                for (let i = 0; i < aiMessages.length; i++) {
                    const msgData = aiMessages[i];
    let aiMessage; // 先声明变量

    // 🔥【修复】跳过拉黑指令对象，避免显示"不支持的消息格式"
    if (typeof msgData === 'object' && msgData !== null && msgData.type === 'block_user') {
        console.log('🚫 跳过拉黑指令对象，不显示为消息:', msgData);
        continue;
    }

    if (typeof msgData === 'object' && msgData !== null) {
        if (msgData.type === 'voice_message') {
            aiMessage = createAIMessage(msgData, i);
        } else if (msgData.type === 'ai_image') {
            aiMessage = createAIMessage(msgData, i);
        } else if (msgData.type === 'transfer') {
            aiMessage = createAIMessage(msgData, i);
        } else if (msgData.type === 'emoji') {
            aiMessage = createAIMessage(msgData, i);
        } else if (msgData.type === 'ai_photo') {
            // 角色发送的"伪照片"
            console.log('处理角色照片消息:', msgData);
            // 确保我们有一个有效的描述
            const photoDesc = msgData.description || msgData.content || msgData.photoDescription || '角色发送的照片';
            console.log('照片描述:', photoDesc);
            aiMessage = { 
                id: (Date.now() + i).toString(), 
                sender: 'received', 
                type: 'user_photo', // 使用与用户照片相同的类型以便复用渲染逻辑
                content: photoDesc,
                photoDescription: photoDesc,
                timestamp: Date.now() + i * 100 
            };
        } else if (msgData.type === 'location') {
            // 角色发送的位置信息
            console.log('处理角色位置消息:', msgData);
            // 确保我们有一个有效的位置名称
            const locationName = msgData.name || msgData.locationName || '未知位置';
            console.log('位置名称:', locationName, '坐标:', msgData.coordinates || '未知坐标');
            aiMessage = { 
                id: (Date.now() + i).toString(), 
                sender: 'received', 
                type: 'location', // 保持类型为location
                locationName: locationName,
                coordinates: msgData.coordinates || '未知坐标',
                content: `[角色分享了位置信息：${locationName}]`,
                timestamp: Date.now() + i * 100 
            };
        } else if (msgData.type === 'transfer') {
            aiMessage = { id: (Date.now() + i).toString(), sender: 'received', type: 'transfer', amount: msgData.amount, note: msgData.note, timestamp: Date.now() + i * 100 };
        } else if (msgData.type === 'emoji') {
            console.log('🔍 [processAIReply-表情包] 原始msgData:', msgData);
            const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.description);
                        if (matchingEmoji) {
                // 🔥【关键修复】为表情包消息添加群聊发送者信息
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    content: '',
                    image: matchingEmoji.url,
                    isEmoji: true,
                    emojiDescription: matchingEmoji.description,
                    timestamp: Date.now() + i * 100
                };

                // 🔥【关键修复】如果是群聊消息，添加发送者信息
                if (msgData.name) {
                    console.log('🔍 [processAIReply-表情包] 检测到群聊消息，发送者:', msgData.name);
                    aiMessage.name = msgData.name;
                    // 查找对应的群成员ID
                    if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                        const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                        if (member) {
                            aiMessage.senderId = member.id;
                            console.log('🔍 [processAIReply-表情包] 找到群成员ID:', member.id);
                        } else {
                            console.log('🔍 [processAIReply-表情包] 未找到群成员:', msgData.name);
                        }
                    }
                } else {
                    console.log('🔍 [processAIReply-表情包] msgData.name 不存在，可能是单聊');
                }

                console.log('🔍 [processAIReply-表情包] 创建的表情包消息:', aiMessage);
                addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                        } else {
                aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: `[表情包"${msgData.description}"不存在]`, timestamp: Date.now() + i * 100 };
            }
        } else if (msgData.type === 'change_avatar') {
                        if (msgData.avatar_url) {
                            // 🔥【修复】先处理占位符替换，再验证和执行头像更换
                            let actualAvatarUrl = msgData.avatar_url;
                            if (msgData.avatar_url === 'CURRENT_USER_IMAGE' ||
                                msgData.avatar_url === 'CURRENT_USER_IMAGE' ||
                                msgData.avatar_url === '用户发送的图片URL' ||
                                msgData.avatar_url === '图片URL') {
                                const recentUserImage = getRecentUserImage();
                                if (recentUserImage) {
                                    actualAvatarUrl = recentUserImage;
                                } else {
                                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[无法更换头像，没有找到可用的图片]', timestamp: Date.now() + i * 100 };
                                    continue;
                                }
                            }

                            const isValidAvatar = await validateAvatarSource(actualAvatarUrl);
                            if (isValidAvatar) {
                                const success = await changeCharacterAvatarByAI(actualAvatarUrl, msgData.reason || '心情变化');
                                if (success) continue;
                                else aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[头像更换失败]', timestamp: Date.now() + i * 100 };
                            } else {
                                aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[无效的头像来源，头像更换失败]', timestamp: Date.now() + i * 100 };
                            }
                        } else {
                            continue;
                        }
        } else if (msgData.type === 'reply_to') {
            // 🔥【新增】处理AI引用回复消息

            // 查找被引用的消息
            const allMessages = chatMessages[replyingCharacterId] || [];
            const referencedMessage = allMessages.find(msg => msg.id === msgData.message_id);

            if (referencedMessage) {
                // 构建引用信息
                const replyToInfo = {
                    id: referencedMessage.id,
                    content: referencedMessage.content || '',
                    senderName: referencedMessage.sender === 'sent' ? '你' : (referencedMessage.name || currentChatCharacter?.name || '对方')
                };

                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    content: msgData.content || '',
                    replyTo: replyToInfo,
                    timestamp: Date.now() + i * 100
                };

            } else {
                console.warn('🔥 找不到被引用的消息ID:', msgData.message_id);
                // 如果找不到被引用的消息，就当作普通消息处理
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    content: msgData.content || '',
                    timestamp: Date.now() + i * 100
                };
            }
        } else if (msgData.type === 'recall_previous') {
            // 🔥【新增】处理AI撤回上一条消息
            console.log('🔥 AI请求撤回上一条消息:', msgData);

            // 查找上一条AI消息
            const allMessages = chatMessages[replyingCharacterId] || [];
            let lastAIMessageIndex = -1;

            for (let j = allMessages.length - 1; j >= 0; j--) {
                if (allMessages[j].sender === 'received') {
                    lastAIMessageIndex = j;
                    break;
                }
            }

            if (lastAIMessageIndex !== -1) {
                const messageToRecall = allMessages[lastAIMessageIndex];
                console.log('🔥 找到要撤回的消息:', messageToRecall);

                // 调用撤回消息处理函数
                await handleRecalledMessage(messageToRecall.content, messageToRecall.id);
            } else {
                console.warn('🔥 没有找到可撤回的AI消息');
                // 如果没有找到消息，显示一条提示
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    content: '[AI撤回了上一条消息]',
                    timestamp: Date.now() + i * 100
                };
            }
            continue; // 跳过正常的消息处理流程
        } else if (msgData.type === 'voice_call') {
            // 🔥【新增】处理AI主动发起语音通话
            console.log('🔔 AI请求发起语音通话:', msgData);
            setTimeout(() => {
                initiateAICall(currentChatCharacter, msgData.reason || '想和你聊聊');
            }, 100 + Math.random() * 200); // 进一步减少延迟到0.1-0.3秒
            continue; // 跳过消息显示，因为这是一个动作指令
        } else if (msgData.name && msgData.message) {
            // 这是群聊的特殊格式
            let senderId = null;
            if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                if (member) senderId = member.id;
            }

            // --- 关键修复：检查群聊消息内容是否为特殊类型 ---
            if (typeof msgData.message === 'object' && msgData.message.type === 'voice_message') {
                // 如果消息内容是一个语音消息对象
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    type: 'voice_message', // 在外层消息上设置正确的类型
                    name: msgData.name,
                    senderId: senderId,
                    content: msgData.message.content, // 提取真正的语音文字内容
                    timestamp: Date.now() + i * 100
                };
            } else if (typeof msgData.message === 'object' && msgData.message.type === 'transfer') {
                // 🔥【修复】如果消息内容是一个转账对象
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    type: 'transfer', // 在外层消息上设置正确的类型
                    name: msgData.name,
                    senderId: senderId,
                    amount: msgData.message.amount, // 提取转账金额
                    note: msgData.message.note, // 提取转账备注
                    timestamp: Date.now() + i * 100
                };
            } else if (typeof msgData.message === 'object' && msgData.message.type === 'friend_request') {
                // 🔥【新增】如果消息内容是一个好友申请对象(第二处)
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    type: 'friend_request', // 在外层消息上设置正确的类型
                    message: msgData.message.message, // 提取好友申请消息
                    timestamp: Date.now() + i * 100
                };
            } else {
                // 对于普通的文本消息
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    name: msgData.name,
                    senderId: senderId,
                    content: msgData.message, // 内容本身是字符串
                    timestamp: Date.now() + i * 100
                };
            }
            // --- 修复结束 ---
                    } else {
            // 其他所有未知对象的处理 - 修复[object Object]问题
            let displayContent;
            if (msgData.content && typeof msgData.content === 'string') {
                displayContent = msgData.content;
            } else if (msgData.message && typeof msgData.message === 'string') {
                displayContent = msgData.message;
            } else if (msgData.text && typeof msgData.text === 'string') {
                displayContent = msgData.text;
            } else if (msgData.reply && typeof msgData.reply === 'string') {
                displayContent = msgData.reply;
            } else if (typeof msgData === 'string') {
                displayContent = msgData;
            } else {
                // 对于其他复杂对象，提取有用信息或显示类型提示
                console.warn('未处理的对象类型:', msgData);
                displayContent = '[不支持的消息格式]';
            }
            aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: displayContent, timestamp: Date.now() + i * 100 };
                            }
                        } else if (typeof msgData === 'string') {
                            // 普通字符串
                            aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: msgData, timestamp: Date.now() + i * 100 };
                        } else {
                            // 其他类型，强制转换为字符串
        aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: String(msgData), timestamp: Date.now() + i * 100 };
                    }
                    
                    chatMessages[replyingCharacterId].push(aiMessage);
    await saveChatMessages();
                    addMessageWithAnimation(aiMessage, replyingCharacterId);
                    
                    // 🔥【新增】触发角色状态更新
                    triggerStatusUpdateAfterMessage(replyingCharacterId);

                    // 🔥【修复】为每条AI消息记录时间线事件，避免重复记录
                    setTimeout(async () => {
                        try {
                            // 获取当前消息的内容
                            let eventContent = '';
                            let characterId = replyingCharacterId;

                            if (typeof msgData === 'string') {
                                eventContent = msgData;
                            } else if (typeof msgData === 'object' && msgData.name && msgData.message) {
                                // 群聊消息格式
                                eventContent = msgData.message;
                                // 查找群成员ID
                                if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                                    const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                                    if (member) characterId = member.id;
                                }
                            } else if (typeof msgData === 'object' && msgData.content) {
                                eventContent = msgData.content;
                            } else if (aiMessage && aiMessage.content) {
                                eventContent = aiMessage.content;
                            }

                            if (eventContent && characterId) {
                                // 🔥【修复】记录AI回复的时间线事件 - 群聊需要为每个成员记录
                                if (currentChatCharacter?.isGroup) {
                                    // 群聊：为每个群成员记录AI回复事件
                                    for (const member of currentChatCharacter.members || []) {
                                        // 🔥【关键修复】检查该成员是否设置了与当前群聊共享记忆
                                        const shouldRecord = await shouldRecordGroupMemoryForCharacter(member.id, currentChatCharacter.id);
                                        if (shouldRecord) {
                                            await recordCrossAppEvent(
                                                member.id, // 记录到每个成员的时间线下
                                                'chat',
                                                'ai_reply',
                                                {
                                                    id: member.id, // 🔥【修复】使用角色ID而不是群聊ID，确保记忆共享正常工作
                                                    type: 'group_chat',
                                                    sender: 'ai',
                                                    content: eventContent,
                                                    chatType: 'group',
                                                    groupName: currentChatCharacter.name,
                                                    groupId: currentChatCharacter.id // 🔥【新增】保留群聊ID用于区分
                                                },
                                                aiMessage.id
                                            );
                                            console.log(`🔥 [修复] 已记录AI回复时间线事件 - 角色: ${member.id}, 内容: ${eventContent.substring(0, 50)}...`);
                                        } else {
                                            console.log(`⏭️ 跳过记录 - 角色 ${member.id} 未与群聊 ${currentChatCharacter.id} 共享记忆`);
                                        }
                                    }
                                } else {
                                    // 单聊：正常记录
                                    await recordCrossAppEvent(
                                        replyingCharacterId,
                                        'chat',
                                        'ai_reply',
                                        {
                                            id: currentChatCharacter.id,
                                            type: 'private_chat',
                                            sender: 'ai',
                                            content: eventContent,
                                            chatType: 'single'
                                        },
                                        aiMessage.id
                                    );
                                    console.log(`🔥 [修复] 已记录AI回复时间线事件 - 角色: ${replyingCharacterId}, 内容: ${eventContent.substring(0, 50)}...`);
                                }
                            }
                        } catch (error) {
                            console.error('AI回复后记忆处理失败:', error);
                        }
                    }, 1000 + i * 200); // 延迟执行，每条消息间隔200ms，避免阻塞UI

                    if (i < aiMessages.length - 1) {
                        const delay = Math.random() * 1000 + 500;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        if (i < aiMessages.length - 1) {
                            showTypingIndicator();
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));
                            hideTypingIndicator();
                        }
                    }
                }

                // 🔥【修复】AI消息发送完成后更新消息列表，确保未读消息计数正确
                renderMessageList();
            } catch (error) {
                console.error('AI回复失败:', error);
                hideTypingIndicator();

                const errorMessage = {
                    id: Date.now().toString(),
                    sender: 'received',
                    content: `[回复失败: ${error.message}]`,
                    timestamp: Date.now()
                };

                chatMessages[replyingCharacterId].push(errorMessage);
                saveChatMessages();
                addMessageWithAnimation(errorMessage, replyingCharacterId);

                // 🔥【修复】错误消息也需要更新消息列表
                renderMessageList();
            } finally {
                // 重置状态
                isWaitingForReply = false;
                pendingUserMessage = null;

                // 恢复智能回复按钮
                if (smartReplyBtn) {
                    smartReplyBtn.disabled = false;
                    smartReplyBtn.style.opacity = '';
                    smartReplyBtn.style.animation = 'none';
                    smartReplyBtn.classList.remove('waiting');
                    smartReplyBtn.innerHTML = '<i class="fas fa-comment-dots"></i>';
                    smartReplyBtn.title = '获取AI回复';
                }

                // 更新按钮显示状态
                updateFloatingButtonsVisibility();
            }
        }

        // 重置悬浮按钮状态
        function resetFloatingButtonsState() {
            // 重置待回复消息
            pendingUserMessage = null;
            isWaitingForReply = false;
            
            // 重置智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.disabled = false;
                smartReplyBtn.style.opacity = '';
                smartReplyBtn.style.animation = 'none';
                smartReplyBtn.innerHTML = '<i class="fas fa-comment-dots"></i>';
                smartReplyBtn.title = '获取AI回复';
                smartReplyBtn.classList.remove('waiting');
            }
            
            // 更新按钮显示状态
            updateFloatingButtonsVisibility();
        }

        // 更新悬浮按钮的显示状态
        function updateFloatingButtonsVisibility() {
            if (!currentChatCharacter) return;
            
            const regenerateBtn = document.getElementById('regenerate-btn');
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            const messages = chatMessages[currentChatCharacter.id] || [];
            
            // 检查是否有AI消息可以重新生成
            const hasAIMessages = messages.some(msg => msg.sender === 'received');
            
            if (regenerateBtn) {
                if (hasAIMessages) {
                    regenerateBtn.classList.remove('hidden');
                } else {
                    regenerateBtn.classList.add('hidden');
                }
            }
            
            if (smartReplyBtn) {
                // 智能回复按钮总是显示
                smartReplyBtn.classList.remove('hidden');
            }
        }

        // @群成员功能相关函数
        function handleMentionInput(e) {
            const input = e.target;
            const text = input.value;
            const cursorPos = input.selectionStart;

            // 查找最近的@符号位置
            let atPos = -1;
            for (let i = cursorPos - 1; i >= 0; i--) {
                if (text[i] === '@') {
                    atPos = i;
                    break;
                } else if (text[i] === ' ' || text[i] === '\n') {
                    break;
                }
            }

            if (atPos !== -1 && isGroupChat()) {
                // 找到@符号，显示群成员列表
                const query = text.substring(atPos + 1, cursorPos);
                mentionStartPos = atPos;
                currentMentionQuery = query;
                showMentionDropdown(query);
            } else {
                // 没有@符号或不是群聊，隐藏下拉框
                hideMentionDropdown();
            }
        }

        function handleMentionKeydown(e) {
            const dropdown = document.getElementById('mention-dropdown');
            const items = dropdown.querySelectorAll('.mention-item');

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedMentionIndex = Math.min(selectedMentionIndex + 1, items.length - 1);
                updateMentionSelection(items);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedMentionIndex = Math.max(selectedMentionIndex - 1, 0);
                updateMentionSelection(items);
            } else if (e.key === 'Enter' || e.key === 'Tab') {
                e.preventDefault();
                if (selectedMentionIndex >= 0 && items[selectedMentionIndex]) {
                    selectMention(items[selectedMentionIndex]);
                }
            } else if (e.key === 'Escape') {
                e.preventDefault();
                hideMentionDropdown();
            }
        }

        function isGroupChat() {
            return currentChatCharacter && groupChats.find(g => g.id === currentChatCharacter.id);
        }

        function showMentionDropdown(query) {
            if (!isGroupChat()) return;

            const group = groupChats.find(g => g.id === currentChatCharacter.id);
            if (!group || !group.members) return;

            const dropdown = document.getElementById('mention-dropdown');
            const filteredMembers = group.members.filter(member =>
                member.name.toLowerCase().includes(query.toLowerCase())
            );

            if (filteredMembers.length === 0) {
                hideMentionDropdown();
                return;
            }

            dropdown.innerHTML = '';
            filteredMembers.forEach((member, index) => {
                const item = document.createElement('div');
                item.className = 'mention-item';
                item.innerHTML = `
                    <div class="mention-avatar" style="background-color: ${member.color || '#4CAF50'}; ${member.avatarUrl ? `background-image: url(${member.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                        ${member.avatarUrl ? '' : member.name.charAt(0)}
                    </div>
                    <div class="mention-name">${member.name}</div>
                `;
                item.onclick = () => selectMention(item);
                item.dataset.memberName = member.name;
                item.dataset.memberId = member.id;
                dropdown.appendChild(item);
            });

            selectedMentionIndex = 0;
            updateMentionSelection(dropdown.querySelectorAll('.mention-item'));
            dropdown.style.display = 'block';
            mentionDropdownVisible = true;
        }

        function hideMentionDropdown() {
            const dropdown = document.getElementById('mention-dropdown');
            dropdown.style.display = 'none';
            mentionDropdownVisible = false;
            selectedMentionIndex = -1;
            mentionStartPos = -1;
            currentMentionQuery = '';
        }

        function updateMentionSelection(items) {
            items.forEach((item, index) => {
                if (index === selectedMentionIndex) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
        }

        function selectMention(item) {
            const memberName = item.dataset.memberName;
            const input = document.getElementById('api-chat-input');
            const text = input.value;

            // 替换@查询文本为@某人
            const beforeMention = text.substring(0, mentionStartPos);
            const afterMention = text.substring(mentionStartPos + 1 + currentMentionQuery.length);
            const newText = beforeMention + `@${memberName} ` + afterMention;

            input.value = newText;

            // 设置光标位置到@某人后面
            const newCursorPos = mentionStartPos + memberName.length + 2;
            input.setSelectionRange(newCursorPos, newCursorPos);

            hideMentionDropdown();
            input.focus();
        }

        // 处理消息中的@内容，将其转换为带样式的HTML
        function processMentions(content) {
            if (!content || typeof content !== 'string') return content;

            // 匹配@某人的模式
            return content.replace(/@([^\s@]+)/g, '<span class="mention-text">@$1</span>');
        }

        // 🔥【新增】构建群聊上下文关联记忆
        async function buildContextualMemoryForGroupChat(groupCharacter, userMessage) {
            try {
                let contextualMemory = '';

                // 检测@提及
                const mentionMatches = userMessage.match(/@([^\s@]+)/g);
                if (mentionMatches) {
                    for (const mention of mentionMatches) {
                        const mentionedName = mention.substring(1); // 移除@符号

                        // 查找被@的群成员
                        const mentionedMember = groupCharacter.members?.find(m => m.name === mentionedName);
                        if (mentionedMember) {
                            // 获取该成员的单聊记忆
                            const privateChatMemory = await getPrivateChatMemoryForMember(mentionedMember.id, userMessage);
                            if (privateChatMemory) {
                                contextualMemory += `\n\n# 与${mentionedName}的相关私聊记忆：\n${privateChatMemory}`;
                            }
                        }
                    }
                }

                // 检测数字暗号（6位以上数字）
                const numberMatches = userMessage.match(/\b\d{6,}\b/g);
                if (numberMatches) {
                    for (const number of numberMatches) {
                        // 在所有群成员的私聊记忆中搜索这个数字
                        for (const member of groupCharacter.members || []) {
                            const numberContext = await searchNumberInPrivateChat(member.id, number);
                            if (numberContext) {
                                contextualMemory += `\n\n# 关于数字"${number}"的私聊记忆（与${member.name}）：\n${numberContext}`;
                                break; // 找到一个就够了
                            }
                        }
                    }
                }

                return contextualMemory;
            } catch (error) {
                console.error('构建群聊上下文关联记忆失败:', error);
                return '';
            }
        }

        // 🔥【新增】获取群成员的私聊记忆
        async function getPrivateChatMemoryForMember(memberId, currentMessage) {
            try {
                // 获取最近的私聊记忆（最近5条）
                const recentPrivateMemories = await db.crossAppTimeline
                    .where('characterId').equals(memberId)
                    .and(event => event.appType === 'chat' &&
                                 event.context?.type === 'private_chat')
                    .reverse()
                    .limit(5)
                    .toArray();

                if (recentPrivateMemories.length === 0) return '';

                let memoryText = '';
                recentPrivateMemories.forEach(memory => {
                    const time = new Date(memory.timestamp).toLocaleString();
                    const content = memory.context?.content || memory.context?.message || '';
                    if (content) {
                        memoryText += `[${time}] ${memory.context?.sender === 'user' ? '用户' : 'AI'}说: ${content.substring(0, 50)}${content.length > 50 ? '...' : ''}\n`;
                    }
                });

                return memoryText;
            } catch (error) {
                console.error('获取私聊记忆失败:', error);
                return '';
            }
        }

        // 🔥【新增】在私聊记忆中搜索数字
        async function searchNumberInPrivateChat(memberId, number) {
            try {
                // 搜索包含该数字的私聊记忆
                const matchingMemories = await db.crossAppTimeline
                    .where('characterId').equals(memberId)
                    .and(event => event.appType === 'chat' &&
                                 event.context?.type === 'private_chat' &&
                                 (event.context?.content?.includes(number) ||
                                  event.context?.message?.includes(number)))
                    .reverse()
                    .limit(3)
                    .toArray();

                if (matchingMemories.length === 0) return '';

                let contextText = '';
                matchingMemories.forEach(memory => {
                    const time = new Date(memory.timestamp).toLocaleString();
                    const content = memory.context?.content || memory.context?.message || '';
                    if (content) {
                        contextText += `[${time}] ${memory.context?.sender === 'user' ? '用户' : 'AI'}说: ${content}\n`;
                    }
                });

                return contextText;
            } catch (error) {
                console.error('搜索数字记忆失败:', error);
                return '';
            }
        }

        // 修改原来的sendApiMessage函数，使其只发送消息到界面，不触发AI回复
        async function sendApiMessage() {
            const input = document.getElementById('api-chat-input');
            const message = input.value.trim();
            
            if (!message) return;
            
            if (!currentChatCharacter) {
                alert('请先选择一个角色');
                return;
            }

            // 🔥【修改】移除拉黑检查，允许消息正常发送

            // 防止重复发送
            if (input._isProcessing) return;
            input._isProcessing = true;

            try {
            // 添加用户消息
            const messageId = Date.now().toString();
            const userMessage = {
                id: messageId,
                sender: 'sent',
                content: message,
                timestamp: Date.now(),
                // 如果有引用消息，添加引用信息
                replyTo: currentReplyTo ? {
                    id: currentReplyTo.id,
                    content: currentReplyTo.content,
                    senderName: currentReplyTo.senderName
                } : null
            };
            
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            
            chatMessages[currentChatCharacter.id].push(userMessage);
            // 🔥【修复】立即保存消息，确保AI能看到最新的消息ID
            await saveChatMessagesImmediate();
            
            // 清空输入框
            input.value = '';
            
            // 清除引用状态
            cancelReply();

            // 🔥【新增】清除当前聊天的引用状态存储
            if (currentChatCharacter) {
                delete chatReplyStates[currentChatCharacter.id];
            }
            
            // 🔥【新增】调整心率（用户发消息）
            adjustHeartrateForMessage(message, true);

            // 🔥【新增】重新安排主动聊天定时器
            onUserMessageSent(currentChatCharacter.id);

            // 使用动画添加消息而不是重新渲染整个列表
            addMessageWithAnimation(userMessage, currentChatCharacter.id);

            // 🔥【新增】检查拉黑状态并创建系统消息
            checkAndCreateBlockedSystemMessage(userMessage, currentChatCharacter.id);

            // 设置待回复消息
            pendingUserMessage = userMessage;
            
            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = '点击获取AI回复';
                }

            // 🔥【新增】触发记忆处理（简化版）
            setTimeout(async () => {
                try {
                    const messages = chatMessages[currentChatCharacter.id] || [];

                    // 🔥【修复】记录聊天时间线事件 - 群聊需要为每个成员记录
                    if (currentChatCharacter?.isGroup) {
                        // 群聊：为每个群成员记录用户消息事件
                        for (const member of currentChatCharacter.members || []) {
                            // 🔥【关键修复】检查该成员是否设置了与当前群聊共享记忆
                            const shouldRecord = await shouldRecordGroupMemoryForCharacter(member.id, currentChatCharacter.id);
                            if (shouldRecord) {
                                await recordCrossAppEvent(
                                    member.id, // 记录到每个成员的时间线下
                                    'chat',
                                    'user_message',
                                    {
                                        id: member.id, // 🔥【修复】使用角色ID而不是群聊ID，确保记忆共享正常工作
                                        type: 'group_chat',
                                        sender: 'user',
                                        content: message,
                                        chatType: 'group',
                                        groupName: currentChatCharacter.name,
                                        groupId: currentChatCharacter.id // 🔥【新增】保留群聊ID用于区分
                                    },
                                    messages[messages.length - 1]?.id
                                );
                            } else {
                                console.log(`⏭️ 跳过记录 - 角色 ${member.id} 未与群聊 ${currentChatCharacter.id} 共享记忆`);
                            }
                        }
                    } else {
                        // 单聊：正常记录
                        await recordCrossAppEvent(
                            currentChatCharacter.id,
                            'chat',
                            'user_message',
                            {
                                id: currentChatCharacter.id,
                                type: 'private_chat',
                                sender: 'user',
                                content: message,
                                chatType: 'single'
                            },
                            messages[messages.length - 1]?.id
                        );
                    }

                    // AI记忆提取（根据用户设置的间隔）
                    if (messages.length % MEMORY_CONFIG.AI_EXTRACT_INTERVAL === 0) {
                        const recentMessages = messages.slice(-MEMORY_CONFIG.AI_EXTRACT_INTERVAL);
                        // 🔥【修复】传入上下文ID用于记忆隔离
                        await extractMemoriesWithAI(currentChatCharacter.id, recentMessages, currentChatCharacter.id);
                        console.log(`🧠 触发记忆提取 - 角色: ${currentChatCharacter.name}, 消息数: ${messages.length}`);
                    }
                } catch (error) {
                    console.error('记忆处理失败:', error);
                }
            }, 1000); // 延迟1秒执行，避免阻塞UI

            } finally {
                // 确保处理完成后重置标志
                setTimeout(() => {
                    input._isProcessing = false;
                }, 100);
            }
        }

        // 语音录音相关变量
        let isRecording = false;
        let recordingStartTime = 0;

        // 处理语音录音
        async function handleVoiceRecording() {
            if (!currentChatCharacter) {
                alert('请先选择一个角色');
                return;
            }

            // 🔥【修复】移除对不存在按钮的依赖，直接显示语音输入对话框
                try {
                    const voiceText = await showVoiceInputDialog();
                    if (voiceText && voiceText.trim()) {
                        sendVoiceMessage(voiceText.trim());
                        console.log('语音消息发送成功');
                    }
                } catch (error) {
                    // 只有在真正取消时才显示取消消息
                    if (error.message === '用户取消') {
                        console.log('用户取消了语音输入');
                    } else {
                        console.error('语音消息发送失败:', error);
                    }
            }
        }

        // 重置录音状态 - 🔥【修复】移除对不存在按钮的依赖
        function resetRecordingState() {
            isRecording = false;
            // 不再需要操作按钮状态，因为我们使用的是工具面板中的语音按钮
        }

        // 显示语音输入对话框
        function showVoiceInputDialog() {
            return new Promise((resolve, reject) => {
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                `;

                const dialog = document.createElement('div');
                dialog.style.cssText = `
                    background: white;
                    border-radius: 12px;
                    padding: 20px;
                    width: 280px;
                    max-width: 90%;
                    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                `;

                dialog.innerHTML = `
                    <div style="text-align: center; margin-bottom: 15px;">
                        <h3 style="margin: 0; color: #333;">语音转文字</h3>
                        <p style="margin: 8px 0 0 0; color: #666; font-size: 14px;">请输入您想说的内容：</p>
                    </div>
                    <textarea id="voice-text-input" placeholder="在这里输入语音内容..." style="
                        width: 100%;
                        height: 80px;
                        border: 1px solid #ddd;
                        border-radius: 8px;
                        padding: 10px;
                        font-size: 14px;
                        resize: none;
                        box-sizing: border-box;
                        outline: none;
                    "></textarea>
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button id="voice-cancel-btn" style="
                            flex: 1;
                            padding: 10px;
                            border: 1px solid #ddd;
                            background: white;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 14px;
                        ">取消</button>
                        <button id="voice-send-btn" style="
                            flex: 1;
                            padding: 10px;
                            border: none;
                            background: #4a84c1;
                            color: white;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 14px;
                        ">发送</button>
                    </div>
                `;

                overlay.appendChild(dialog);
                document.body.appendChild(overlay);

                const textInput = dialog.querySelector('#voice-text-input');
                const cancelBtn = dialog.querySelector('#voice-cancel-btn');
                const sendBtn = dialog.querySelector('#voice-send-btn');

                // 自动聚焦到输入框
                setTimeout(() => textInput.focus(), 100);

                // 取消按钮
                cancelBtn.onclick = () => {
                    document.body.removeChild(overlay);
                    reject(new Error('用户取消'));
                };

                // 发送按钮
                sendBtn.onclick = () => {
                    const text = textInput.value.trim();
                    if (text) {
                        console.log('语音输入对话框：用户点击发送，内容:', text);
                        document.body.removeChild(overlay);
                        resolve(text);
                    } else {
                        console.log('语音输入对话框：内容为空，聚焦输入框');
                        textInput.focus();
                    }
                };

                // 点击遮罩关闭
                overlay.onclick = (e) => {
                    if (e.target === overlay) {
                        document.body.removeChild(overlay);
                        reject(new Error('用户取消'));
                    }
                };

                // 支持回车发送
                textInput.onkeydown = (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        console.log('语音输入框：用户按回车键发送');
                        sendBtn.click();
                    }
                };
            });
        }

                 // 发送语音消息
        function sendVoiceMessage(text) {
            console.log('开始发送语音消息:', text);
            
            // 🔥【修改】移除拉黑检查，允许语音消息正常发送
            
            const messageId = Date.now().toString();
            const duration = Math.max(1, Math.ceil(text.length / 8)); // 根据文字长度计算"语音"时长
            
            const voiceMessage = {
                id: messageId,
                sender: 'sent',
                type: 'voice',
                content: text,
                duration: duration,
                timestamp: Date.now()
            };

            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }

            chatMessages[currentChatCharacter.id].push(voiceMessage);
            console.log('语音消息已添加到聊天记录');
            
            saveChatMessages();
            console.log('聊天记录已保存');

            // 🔥【新增】调整心率（用户发语音消息）
            adjustHeartrateForMessage(text, true);

            // 🔥【新增】重新安排主动聊天定时器
            onUserMessageSent(currentChatCharacter.id);

            // 添加语音消息到界面
            addMessageWithAnimation(voiceMessage, currentChatCharacter.id);
            console.log('语音消息已添加到界面');

            // 🔥【新增】检查拉黑状态并创建系统消息
            checkAndCreateBlockedSystemMessage(voiceMessage, currentChatCharacter.id);
            
            // 🔥【新增】触发角色状态更新
            triggerStatusUpdateAfterMessage(currentChatCharacter.id);

            // 设置待回复消息
            pendingUserMessage = voiceMessage;

            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = '点击获取AI回复';
            }
            
            console.log('语音消息发送流程完成');
        }

        // 切换语音文本显示
        function toggleVoiceText(voiceElement) {
            const container = voiceElement.closest('.voice-message-container') || voiceElement.closest('.message-container');
            if (!container) return;

            const textContent = container.querySelector('.voice-text-content');
            if (!textContent) {
                // 如果没有文本容器，创建一个
                const text = voiceElement.getAttribute('data-text');
                if (!text) return;

                const newTextContent = document.createElement('div');
                newTextContent.className = 'voice-text-content';
                newTextContent.textContent = text;
                
                // 根据消息类型决定插入位置
                if (container.classList.contains('voice-message-container')) {
                    container.appendChild(newTextContent);
                } else {
                    // 为旧格式创建语音容器
                    const voiceContainer = document.createElement('div');
                    voiceContainer.className = container.classList.contains('sent') ? 'voice-message-container sent' : 'voice-message-container received';
                    
                    // 移动现有的消息气泡到语音容器中
                    const bubble = container.querySelector('.message-bubble');
                    if (bubble) {
                        container.removeChild(bubble);
                        voiceContainer.appendChild(bubble);
                        voiceContainer.appendChild(newTextContent);
                        container.appendChild(voiceContainer);
                    }
                }
                
                // 显示文本
                setTimeout(() => {
                    newTextContent.classList.add('visible');
                }, 10);
                
                return;
            }

            // 切换文本显示/隐藏
            if (textContent.classList.contains('visible')) {
                textContent.classList.remove('visible');
                setTimeout(() => {
                    textContent.style.display = 'none';
                }, 300);
            } else {
                textContent.style.display = 'block';
                setTimeout(() => {
                    textContent.classList.add('visible');
                }, 10);
            }
        }
        
        // 加载动态
        async function loadMoments() {
            try {
                    const momentsList = document.getElementById('moments-list');
                if (!momentsList) return;
                    
                        // 清空现有的动态
                        momentsList.innerHTML = '';
                        
                // 从数据库加载动态数据
                const momentsData = await db.moments.orderBy('timestamp').reverse().toArray();
                
                if (momentsData.length > 0) {
                    for (const momentData of momentsData) {
                        // 获取点赞数
                        const likesCount = await db.momentLikes.where('momentId').equals(momentData.id).count();
                        
                        // 获取评论数
                        const commentsCount = await db.momentComments.where('momentId').equals(momentData.id).count();
                        
                        // 获取评论列表
                        const comments = await db.momentComments.where('momentId').equals(momentData.id).toArray();
                        comments.sort((a, b) => a.timestamp - b.timestamp); // 按时间戳排序
                        
                            // 🔥【修复】验证并处理头像
                            let avatarToUse = null;
                            if (momentData.avatar && isValidAvatarUrl(momentData.avatar)) {
                                avatarToUse = momentData.avatar;
                            } else {
                                // 🔥【修复】使用await获取默认头像
                                avatarToUse = await getDefaultAvatar();
                                // 如果数据库中存储的头像无效，更新数据库记录
                                if (momentData.avatar && !isValidAvatarUrl(momentData.avatar)) {
                                    console.log(`清理动态 ${momentData.id} 的无效头像`);
                                    try {
                                        await db.moments.update(momentData.id, { avatar: avatarToUse });
                                    } catch (error) {
                                        console.error('更新动态头像失败:', error);
                                    }
                                }
                            }
                        
                            const momentElement = createMomentElement({
                            id: momentData.id,
                                nickname: momentData.nickname,
                                avatar: avatarToUse,
                                text: momentData.text,
                                images: momentData.images || [],
                                time: momentData.time,
                            timestamp: momentData.timestamp,
                            likes: likesCount,
                            comments: comments
                            });
                            
                            // 添加到动态列表
                            momentsList.appendChild(momentElement);
                            
                            // 更新点赞显示
                        updateMomentLikeDisplay(momentData.id);
                            
                            // 显示已有评论
                        if (comments && comments.length > 0) {
                            comments.forEach(comment => {
                                // 确保评论有time字段，如果没有就从timestamp生成
                                if (!comment.time && comment.timestamp) {
                                    comment.time = formatTime(new Date(comment.timestamp));
                                }
                                displayCommentUnderMoment(momentData.id, comment);
                                });
                            }
                    }
                        
                        console.log('成功加载', momentsData.length, '条动态');
                } else {
                    console.log('没有找到保存的动态数据');
                }
                
                // 启动时间更新
                startTimeUpdater();
            } catch (error) {
                console.error('加载动态失败:', error);
            }
        }
        
        // 发布动态相关变量
        let momentImages = [];
        
        // 显示发布动态界面
        function showPublishMoment() {
            showApp('publish-moment-screen');
            // 重置表单
            document.getElementById('moment-text').value = '';
            momentImages = [];
            updateMomentImagesGrid();
            
            // 重置发布按钮状态
            const publishBtn = document.querySelector('.publish-btn');
            if (publishBtn) {
                publishBtn.disabled = false;
                publishBtn.textContent = '发表';
            }
        }
        
        // 隐藏发布动态界面
        function hidePublishMoment() {
            showApp('chat-screen');
                                    // 切换回动态标签
            switchChatTab('moments-page');
            // 不需要重新加载，动态已经在数据库中
        }
        
        // 添加图片到动态
        function addMomentImage() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*,.jpg,.jpeg,.png,.gif,.webp';
            input.multiple = true;
            input.onchange = function(event) {
                const files = Array.from(event.target.files);
                files.forEach(file => {
                    if (momentImages.length < 9) { // 最多9张图片
                        const reader = new FileReader();
                        reader.onload = async function(e) {
                            try {
                                // 压缩图片
                                const compressedImage = await compressImage(e.target.result, 800, 0.8);
                                momentImages.push(compressedImage);
                                updateMomentImagesGrid();
                            } catch (error) {
                                showToast("图片处理失败，请重试");                                console.error("压缩图片失败:", error);
                            }
                        };
                        reader.readAsDataURL(file);
                    }
                });
            };
            input.click();
        }
        
        // 删除图片
        function removeMomentImage(index) {
            momentImages.splice(index, 1);
            updateMomentImagesGrid();
        }
        
        // 更新图片网格显示
        function updateMomentImagesGrid() {
            const grid = document.getElementById('moment-images-grid');
            grid.innerHTML = '';
            
            momentImages.forEach((imageData, index) => {
                const imageItem = document.createElement('div');
                imageItem.className = 'moment-image-item';
                imageItem.innerHTML = `
                    <img src="${imageData}" alt="动态图片">
                    <button class="remove-image-btn" onclick="removeMomentImage(${index})">×</button>
                `;
                grid.appendChild(imageItem);
            });
        }
        
        // 发布动态
        
        // 获取默认头像 - 修复异步问题
        async function getDefaultAvatar() {
            try {
                // 🔥【修复】使用await获取动态头像，确保异步操作正确完成
                const momentsAvatar = await getMomentsImage("avatarImage");
                if (momentsAvatar && isValidAvatarUrl(momentsAvatar)) {
                    console.log('使用动态页面设置的头像');
                    return momentsAvatar;
                }
                
                // 尝试获取用户头像，但要验证其有效性
                if (window.userAvatar && isValidAvatarUrl(window.userAvatar)) {
                    console.log('使用全局用户头像');
                    return window.userAvatar;
                }
                
                // 清理无效的用户头像数据
                if (window.userAvatar && !isValidAvatarUrl(window.userAvatar)) {
                    console.log('清理无效的用户头像数据');
                    window.userAvatar = null;
                }
                
                // 清理无效的动态头像数据
                if (momentsAvatar && !isValidAvatarUrl(momentsAvatar)) {
                    console.log('清理无效的动态头像数据');
                    // 这里需要调用清理函数，但由于getMomentsImage的存储机制，我们先跳过
                }
                
                console.log('使用默认生成的头像');
                // 返回默认头像（使用CSS生成的简单头像）
                return "data:image/svg+xml;base64," + btoa(`<svg width="50" height="50" xmlns="http://www.w3.org/2000/svg"><rect width="50" height="50" fill="#f0f0f0"/><circle cx="25" cy="20" r="8" fill="#999"/><circle cx="25" cy="40" r="12" fill="#999"/></svg>`);
            } catch (error) {
                console.error('获取默认头像失败:', error);
                return "data:image/svg+xml;base64," + btoa(`<svg width="50" height="50" xmlns="http://www.w3.org/2000/svg"><rect width="50" height="50" fill="#f0f0f0"/><circle cx="25" cy="20" r="8" fill="#999"/><circle cx="25" cy="40" r="12" fill="#999"/></svg>`);
            }
        }        async function publishMoment() {
            const text = document.getElementById('moment-text').value.trim();
            const publishBtn = document.querySelector('.publish-btn');
            
            if (!text && momentImages.length === 0) {
                showToast('请输入文字或选择图片');
                return;
            }
            
            // 禁用发布按钮，防止重复提交
            publishBtn.disabled = true;
            publishBtn.textContent = '发布中...';
            
            // 获取当前用户昵称
            const nickname = document.getElementById('moments-username')?.textContent || '我';
            
            // 🔥【修复】使用await获取用户头像
            const userAvatar = await getDefaultAvatar();
            
            // 创建新动态
            const now = new Date();
            const newMoment = {
                id: Date.now(),
                authorId: 'user',
                nickname: nickname,
                avatar: userAvatar,
                text: text,
                images: [...momentImages],
                time: formatTime(now),
                timestamp: now.getTime()
            };
            
            try {
                // 保存到数据库
                await db.moments.add(newMoment);
                
                // 恢复发布按钮状态
                publishBtn.disabled = false;
                publishBtn.textContent = '发表';
                
                // 显示成功提示
                showToast('发布成功！');
                
                // 清空表单
                document.getElementById('moment-text').value = '';
                momentImages = [];
                updateMomentImagesGrid();
                
                // 返回动态页面
                    hidePublishMoment();
                
                // 直接添加到动态列表（避免重新加载整个列表）
                addMomentToList(newMoment);
                
                // 启动时间更新器
                startTimeUpdater();
                
                // 延迟触发AI角色的互动
                setTimeout(() => {
                    triggerAIInteractions(newMoment.id, 'like');
                }, 1000);
                setTimeout(() => {
                    triggerAIInteractions(newMoment.id, 'comment');
                }, 3000);
                
            } catch (error) {
                console.error('发布动态失败:', error);
                showToast('发布失败，请重试');
                
                // 恢复发布按钮
                publishBtn.disabled = false;
                publishBtn.textContent = '发表';
            }
        }
        
        // 格式化时间
        function formatTime(date) {
            // 确保date是Date对象
            if (!date) return '未知时间';
            if (!(date instanceof Date)) {
                date = new Date(date);
            }
            if (isNaN(date.getTime())) return '无效时间';

            const now = new Date();
            const diff = now - date;

            if (diff < 60000) { // 小于1分钟
                return '刚刚';
            } else if (diff < 3600000) { // 小于1小时
                return Math.floor(diff / 60000) + '分钟前';
            } else if (diff < 86400000) { // 小于1天
                return Math.floor(diff / 3600000) + '小时前';
            } else if (diff < 604800000) { // 小于1周
                return Math.floor(diff / 86400000) + '天前';
            } else {
                return date.toLocaleDateString();
            }
        }
        
        // 添加动态到列表
        function addMomentToList(moment) {
            const momentsList = document.getElementById('moments-list');
            const momentElement = createMomentElement(moment);
            
            // 插入到列表最前面
            if (momentsList.firstChild) {
                momentsList.insertBefore(momentElement, momentsList.firstChild);
            } else {
                momentsList.appendChild(momentElement);
            }
        }
        
        // 创建动态元素
        function createMomentElement(moment) {
            const momentDiv = document.createElement('div');
            momentDiv.className = 'moment-item';
            
            // 设置动态ID和时间戳
            momentDiv.setAttribute('data-moment-id', moment.id);
            if (moment.timestamp) {
                momentDiv.setAttribute('data-timestamp', moment.timestamp);
            }
            
            let imagesHtml = '';
            if (moment.images && moment.images.length > 0) {
                imagesHtml = `
                    <div class="moment-images">
                        ${moment.images.map(img => `<img src="${img}" alt="动态图片" onclick="previewImage('${img}')">`).join('')}
                    </div>
                `;
            }
            // 🔥【修复】正确获取角色头像
            let finalAvatar = null;
            if (moment.authorId === 'user') {
                // 用户动态：直接使用保存的头像（已在发布时正确设置）
                finalAvatar = moment.avatar;
            } else {
                // 角色动态：优先动态头像，然后角色卡头像
                finalAvatar = moment.avatar;
                if (!finalAvatar && moment.characterId) {
                    const character = characters.find(c => c.id === moment.characterId);
                    if (character && character.avatarUrl) {
                        finalAvatar = character.avatarUrl;
                    }
                }
            }
            
            momentDiv.innerHTML = `
                <div class="moment-avatar">
                    ${finalAvatar ? 
                        `<img src="${finalAvatar}" alt="头像" style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px;" onerror="this.style.display='none'; this.parentElement.innerHTML='<div style=\\'width: 40px; height: 40px; background-color: #ddd; border-radius: 8px; display: flex; align-items: center; justify-content: center; color: #666; font-size: 14px;\\'>${moment.nickname ? moment.nickname.charAt(0) : '?'}</div>'">` :
                        `<div style="width: 40px; height: 40px; background-color: #ddd; border-radius: 8px; display: flex; align-items: center; justify-content: center; color: #666; font-size: 14px;">${moment.nickname ? moment.nickname.charAt(0) : '?'}</div>`
                    }
                </div>
                <div class="moment-content">
                    <div class="moment-username">${moment.nickname}</div>
                    <div class="moment-text">${formatMomentText(moment.text)}</div>
                    ${imagesHtml}
                    <div class="moment-time-actions" style="margin-top: 8px; padding: 8px 0; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center;">
                        <div class="moment-time">${moment.time}</div>
                        <div class="moment-actions" style="display: flex;">
                        <button class="moment-action-btn" onclick="toggleMomentLike('${moment.id}')" style="margin-right: 8px;">
                            <i class="far fa-heart"></i>
                            <span>${moment.likes || 0}</span>
                        </button>
                        <button class="moment-action-btn" onclick="showMomentComments('${moment.id}')">
                            <i class="far fa-comment"></i>
                            <span>${moment.comments ? moment.comments.length : 0}</span>
                        </button>
                    </div>
                    </div>
                    <div class="moment-footer" style="display: none;">
                    </div>
                </div>
            `;
            
            // 添加长按监听器
            addLongPressListener(momentDiv, moment.id);
            
            // 异步检查并设置用户点赞状态
            (async () => {
                try {
                    const userLike = await db.momentLikes
                        .where('[momentId+authorId]')
                        .equals([moment.id, 'user'])
                        .first();
                    
                    if (userLike) {
                    const likeBtn = momentDiv.querySelector('.moment-action-btn');
                    const likeIcon = likeBtn.querySelector('i');
                    likeIcon.classList.remove('far');
                    likeIcon.classList.add('fas');
                    likeBtn.classList.add('liked');
                }
                } catch (error) {
                    console.error('检查用户点赞状态失败:', error);
            }
            })();
            
            return momentDiv;
        }
        
        // 预览图片
        function previewImage(imageSrc) {
            // 创建预览遮罩
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.9);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
            `;
            
            const img = document.createElement('img');
            img.src = imageSrc;
            img.style.cssText = `
                max-width: 90%;
                max-height: 90%;
                object-fit: contain;
            `;
            
            overlay.appendChild(img);
            overlay.onclick = () => document.body.removeChild(overlay);
            document.body.appendChild(overlay);
        }
        
        // 注意：saveMomentsData函数已移除，现在使用Dexie数据库直接存储
        // 更新文字计数
        function updateTextCount() {
            const textarea = document.getElementById('moment-text');
            const countElement = document.getElementById('text-count');
            
            if (textarea && countElement) {
                const currentLength = textarea.value.length;
                const maxLength = 500;
                
                countElement.textContent = `${currentLength}/${maxLength}`;
                
                // 当接近限制时改变颜色
                if (currentLength > maxLength * 0.9) {
                    countElement.style.color = '#ff6b6b';
                } else if (currentLength > maxLength * 0.8) {
                    countElement.style.color = '#ffa500';
                } else {
                    countElement.style.color = '#999';
                }
            }
        }
        
        // 显示提示消息
        function showToast(message) {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.8);
                color: white;
                padding: 12px 20px;
                border-radius: 6px;
                z-index: 10000;
                font-size: 14px;
            `;
            toast.textContent = message;
            
            document.body.appendChild(toast);
            setTimeout(() => {
                document.body.removeChild(toast);
            }, 2000);
        }
        
        // 时间更新器
        let timeUpdateInterval = null;
        
        function startTimeUpdater() {
            // 清除已存在的定时器
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
            }
            
            // 立即更新一次
            updateMomentTimes();
            
            // 每分钟更新一次时间显示
            timeUpdateInterval = setInterval(updateMomentTimes, 60000);
        }
        
        function stopTimeUpdater() {
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
                timeUpdateInterval = null;
            }
        }
        
        function updateMomentTimes() {
            try {
                // 更新动态本身的时间
                const momentItems = document.querySelectorAll('.moment-item[data-timestamp]');

                momentItems.forEach(item => {
                    const timestamp = parseInt(item.getAttribute('data-timestamp'));
                    if (timestamp) {
                        const timeElement = item.querySelector('.moment-time');
                        if (timeElement) {
                            const newTime = formatTime(new Date(timestamp));
                            timeElement.textContent = newTime;
                        }
                    }
                });

                // 🔥【新增】更新评论区的时间显示
                const commentElements = document.querySelectorAll('.moment-comment[data-timestamp]');
                commentElements.forEach(commentElement => {
                    const timestamp = parseInt(commentElement.getAttribute('data-timestamp'));
                    if (timestamp) {
                        const timeElement = commentElement.querySelector('.comment-time');
                        if (timeElement) {
                            const newTime = formatTime(new Date(timestamp));
                            timeElement.textContent = newTime;
                        }
                    }
                });
            } catch (error) {
                console.error('更新动态时间失败:', error);
            }
        }
        
        // 动态选择模式相关变量
        let isSelectionMode = false;
        let selectedMoments = new Set();
        
        // 切换动态点赞状态
        async function toggleMomentLike(momentId) {
            if (isSelectionMode) return; // 选择模式下不响应点赞
            
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;
            
            const likeBtn = momentElement.querySelector('.moment-action-btn');
            const likeIcon = likeBtn.querySelector('i');
            
            try {
            // 检查用户是否已点赞
                const existingLike = await db.momentLikes
                    .where('[momentId+authorId]')
                    .equals([parseInt(momentId), 'user'])
                    .first();
            
                if (existingLike) {
                // 取消点赞
                likeIcon.classList.remove('fas');
                likeIcon.classList.add('far');
                likeBtn.classList.remove('liked');
                    await db.momentLikes.delete([parseInt(momentId), 'user']);
            } else {
                // 点赞
                likeIcon.classList.add('fas');
                likeIcon.classList.remove('far');
                likeBtn.classList.add('liked');
                    await db.momentLikes.add({
                        momentId: parseInt(momentId),
                        authorId: 'user',
                    characterId: 'user',
                    name: document.getElementById('moments-username')?.textContent || '我',
                    timestamp: Date.now()
                });
                
                // 触发AI角色自动点赞
                triggerAIInteractions(momentId, 'like');
            }
            
            // 更新显示
            updateMomentLikeDisplay(momentId);
            } catch (error) {
                console.error('点赞操作失败:', error);
            }
        }
        
        // 显示动态评论
        function showMomentComments(momentId) {
            if (isSelectionMode) return; // 选择模式下不响应评论

            // 显示简单评论输入框
            showSimpleCommentInput(momentId);

            // 🔥【修复】移除用户点击评论时自动触发AI评论的逻辑
            // 用户点击评论按钮只是想评论，不应该触发其他AI角色也来评论
            // AI角色的自动评论应该只在动态发布时触发，而不是在用户评论时触发
        }
        
        // 显示简单评论输入框
        function showSimpleCommentInput(momentId, replyToNickname = null) {
            // 检查是否已经有输入框
            if (document.querySelector('.simple-comment-input')) {
                closeSimpleCommentInput();
            }
            
            const placeholder = replyToNickname ? `回复 ${replyToNickname}...` : '写评论...';
            
            const input = document.createElement('div');
            input.className = 'simple-comment-input';
            input.innerHTML = `
                <div class="comment-input-container">
                    <input type="text" placeholder="${placeholder}" maxlength="200" id="simple-comment-${momentId}" data-reply-to="${replyToNickname || ''}">
                    <button onclick="submitSimpleComment('${momentId}')">发送</button>
                    <button onclick="closeSimpleCommentInput()" class="cancel-btn">取消</button>
                </div>
            `;
            
            input.style.cssText = `
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                background: white;
                border-top: 1px solid #ddd;
                padding: 12px;
                z-index: 1000;
                box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
                max-width: 360px;
                margin: 0 auto;
            `;
            
            const container = input.querySelector('.comment-input-container');
            container.style.cssText = `
                display: flex;
                gap: 8px;
                align-items: center;
                max-width: 360px;
                margin: 0 auto;
            `;
            
            const textInput = input.querySelector('input');
            textInput.style.cssText = `
                flex: 1;
                padding: 8px 12px;
                border: 1px solid #ddd;
                border-radius: 20px;
                font-size: 14px;
            `;
            
            const sendBtn = input.querySelector('button');
            sendBtn.style.cssText = `
                background: #1da1f2;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 16px;
                font-size: 14px;
                cursor: pointer;
            `;
            
            const cancelBtn = input.querySelector('.cancel-btn');
            cancelBtn.style.cssText = `
                background: #f0f0f0;
                color: #666;
                border: none;
                padding: 8px 16px;
                border-radius: 16px;
                font-size: 14px;
                cursor: pointer;
            `;
            
            document.body.appendChild(input);
            
            // 自动聚焦
            setTimeout(() => textInput.focus(), 100);
            
            // 回车发送
            textInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    submitSimpleComment(momentId);
                }
            });
        }
        
        // 关闭简单评论输入框
        function closeSimpleCommentInput() {
            const input = document.querySelector('.simple-comment-input');
            if (input) {
                document.body.removeChild(input);
            }
        }
        
        // 提交简单评论
        async function submitSimpleComment(momentId) {
            const input = document.getElementById(`simple-comment-${momentId}`);
            const text = input.value.trim();
            const replyTo = input.getAttribute('data-reply-to');
            
            if (!text) {
                showToast('请输入评论内容');
                return;
            }
            
            // 🔥【修复】使用await获取用户头像
            const userAvatar = await getDefaultAvatar();
            
            const comment = {
                id: Date.now() + Math.random(),
                nickname: document.getElementById('moments-username')?.textContent || '我',
                avatar: userAvatar,
                text: text,
                time: formatTime(new Date()),
                timestamp: Date.now(),
                replyTo: replyTo || null
            };
            
            // 保存评论到动态数据
            saveCommentToMoment(momentId, comment);
            
            // 更新动态列表中的评论数
            updateMomentCommentCount(momentId);
            
            // 在动态下方显示新评论
            displayCommentUnderMoment(momentId, comment);
            
            // 关闭输入框
            closeSimpleCommentInput();
            
            showToast('评论成功！');
            
            // 如果用户回复了某个AI角色，检查回合次并触发该角色的回复
            if (replyTo && replyTo !== '我') {
                const conversationKey = `${momentId}-${replyTo}`;
                const currentRounds = commentConversationRounds.get(conversationKey) || 0;
                
                if (currentRounds < 10) {
                    console.log(`用户回复了 ${replyTo}，当前对话回合次: ${currentRounds}/10，将在2-5秒后触发AI回复`);
                    
                    // 用户回复时也要增加回合次
                    commentConversationRounds.set(conversationKey, currentRounds + 1);
                    console.log(`用户回复后，${replyTo} 在动态 ${momentId} 中的对话回合次更新为: ${currentRounds + 1}/10`);
                    
                setTimeout(() => {
                    console.log(`开始触发 ${replyTo} 回复用户评论: "${text}"`);
                    triggerAIReplyToUser(momentId, replyTo, text);
                }, Math.random() * 3000 + 2000); // 2-5秒后AI回复
                } else {
                    console.log(`${replyTo} 在动态 ${momentId} 中的对话已达到10回合上限，不再回复`);
                }
            } else {
                console.log(`用户发表了评论，replyTo: ${replyTo}`);
                
                // 检查是否是对角色动态的直接评论（不是回复）
                if (!replyTo) {
                    checkAndTriggerCharacterMomentReply(momentId, text);
                }
            }
        }
        
        // 检查并触发角色动态的回复
        async function checkAndTriggerCharacterMomentReply(momentId, userCommentText) {
            try {
                // 获取动态信息
                const moment = await db.moments.get(parseInt(momentId));
                if (!moment || !moment.characterId || moment.characterId === 'user') {
                    console.log('不是角色发布的动态，跳过角色回复');
                    return;
                }
                
                // 获取发布动态的角色
                const character = characters.find(c => c.id === moment.characterId);
                if (!character) {
                    console.log(`未找到动态发布者角色: ${moment.characterId}`);
                    return;
                }
                
                // 检查对话回合次
                const conversationKey = `${momentId}-${character.name}`;
                const currentRounds = commentConversationRounds.get(conversationKey) || 0;
                
                if (currentRounds >= 10) {
                    console.log(`${character.name} 在动态 ${momentId} 中的对话已达到10回合上限，不再回复`);
                    return;
                }
                
                console.log(`用户评论了 ${character.name} 的动态，当前对话回合次: ${currentRounds}/10，将在2-5秒后触发回复`);
                
                // 增加对话回合次
                commentConversationRounds.set(conversationKey, currentRounds + 1);
                console.log(`用户评论后，${character.name} 在动态 ${momentId} 中的对话回合次更新为: ${currentRounds + 1}/10`);
                
                // 延迟回复
                setTimeout(() => {
                    console.log(`开始触发 ${character.name} 回复用户对其动态的评论: "${userCommentText}"`);
                    triggerAIReplyToUser(momentId, character.name, userCommentText);
                }, Math.random() * 3000 + 2000); // 2-5秒后AI回复
                
            } catch (error) {
                console.error('检查角色动态回复失败:', error);
            }
        }
        
        // 在动态下方显示评论
        function displayCommentUnderMoment(momentId, comment) {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;
            
            // 查找或创建评论区域
            let commentsSection = momentElement.querySelector('.moment-comments-section');
            if (!commentsSection) {
                commentsSection = document.createElement('div');
                commentsSection.className = 'moment-comments-section';
                
                // 检查是否已有点赞区域，决定margin-top
                const likesDisplay = momentElement.querySelector('.likes-display');
                const marginTop = likesDisplay ? '0' : '0';
                
                commentsSection.style.cssText = `
                    margin-top: ${marginTop};
                    padding: 8px 12px;
                    background: #f8f9fa;
                    font-size: 13px;
                `;
                
                // 插入到正确位置：点赞区后面（如果有的话），否则在时间操作区后面
                const momentContent = momentElement.querySelector('.moment-content');
                const momentTimeActions = momentElement.querySelector('.moment-time-actions');
                
                if (momentContent && momentTimeActions) {
                if (likesDisplay) {
                        // 如果有点赞区，插入到点赞区后面
                    likesDisplay.parentNode.insertBefore(commentsSection, likesDisplay.nextSibling);
                    } else {
                        // 没有点赞区，插入到时间操作区后面
                    momentTimeActions.parentNode.insertBefore(commentsSection, momentTimeActions.nextSibling);
                    }
                }
            }
            
            // 创建评论元素
            const commentDiv = document.createElement('div');
            commentDiv.className = 'comment-item moment-comment';
            commentDiv.setAttribute('data-timestamp', comment.timestamp || Date.now());
            commentDiv.style.cssText = `
                display: flex;
                gap: 8px;
                margin-bottom: 8px;
                align-items: flex-start;
            `;
            
            // 🔥【修复】处理回复格式，确保角色回复用户时格式正常
            let commentText = comment.text;
            let nameFormat = comment.nickname + '：'; // 默认格式

            if (comment.replyTo) {
                // 有回复时，角色名后不加冒号，回复内容包含完整格式
                nameFormat = comment.nickname;
                commentText = `回复<span style="margin: 0 2px; color: #576b95; font-weight: 600;">${comment.replyTo}</span>: ${comment.text}`;
            }

            commentDiv.innerHTML = `
                <img src="${comment.avatar}" style="width: 24px; height: 24px; border-radius: 50%; object-fit: cover;">
                <div style="flex: 1; line-height: 1.4; cursor: pointer;" onclick="replyToMomentComment('${momentId}', '${comment.nickname}')">
                    <span style="color: #576b95; font-weight: 600;">${nameFormat}</span><span style="margin-left: 2px; color: #333;">${commentText}</span>
                    <div class="comment-time" style="color: #999; font-size: 11px; margin-top: 2px;">${comment.time}</div>
                </div>
            `;
            
            commentsSection.appendChild(commentDiv);
        }
        
        // 回复动态评论
        function replyToMomentComment(momentId, nickname) {
            // 显示评论输入框，并设置为回复模式
            showSimpleCommentInput(momentId, nickname);
        }
        

        
        // 保存评论到动态数据
        async function saveCommentToMoment(momentId, comment) {
            try {
                const commentData = {
                    id: comment.id,
                    momentId: parseInt(momentId),
                    authorId: comment.characterId || 'user',
                    nickname: comment.nickname,
                    avatar: comment.avatar,
                    text: comment.text,
                    timestamp: comment.timestamp,
                    replyTo: comment.replyTo || null
                };
                
                await db.momentComments.add(commentData);
                console.log('评论已保存到数据库，动态ID:', momentId);
            } catch (error) {
                console.error('保存评论失败:', error);
            }
        }
        
        // 更新动态评论数
        async function updateMomentCommentCount(momentId) {
            try {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;
            
                const commentsCount = await db.momentComments.where('momentId').equals(parseInt(momentId)).count();
            
                const commentBtn = momentElement.querySelectorAll('.moment-action-btn')[1];
                const commentCount = commentBtn.querySelector('span');
                commentCount.textContent = commentsCount;
            } catch (error) {
                console.error('更新评论数失败:', error);
            }
        }
        
        // 触发AI角色互动
        async function triggerAIInteractions(momentId, type) {
            try {
            if (!characters || characters.length === 0) return;

            // 获取当前动态信息
                const moment = await db.moments.get(parseInt(momentId));
            if (!moment) return;

                const publisherCharacterId = moment.characterId;

                // 如果是用户发的动态
                if (!publisherCharacterId || publisherCharacterId === 'user') {
                    console.log('用户发布动态，所有角色80%概率互动');
                    // 用户发动态：所有联系人角色都有80%概率互动
            const contactCharacters = characters.filter(char => contacts.includes(char.id));

            if (type === 'like') {
                for (const character of contactCharacters) {
                    if (Math.random() < 0.8) { // 80%概率点赞
                                setTimeout(async () => {
                                    await addAILikeWithPersonality(momentId, character, moment);
                                }, Math.random() * 3000 + 1000);
                    }
                }
            } else if (type === 'comment') {
                for (const character of contactCharacters) {
                    if (Math.random() < 0.8) { // 80%概率评论
                            setTimeout(async () => {
                                await addAICommentWithPersonality(momentId, character, moment);
                                }, Math.random() * 5000 + 2000);
                    }
                }
                    }
                } else {
                    console.log('角色发布动态，同一分组下角色60%概率互动');
                    // 角色发动态：使用分组关系而不是群聊关系
                    const publisherCharacter = characters.find(c => c.id === publisherCharacterId);

                    // 获取与发布者在同一分组的角色
                    const sameGroupCharacters = characters.filter(c =>
                        c.id !== publisherCharacterId && c.groupId === publisherCharacter.groupId
                    );

                    if (type === 'like') {
                        for (const character of sameGroupCharacters) {
                            if (Math.random() < 0.6) { // 修复：60%概率互动
                    setTimeout(async () => {
                                    await addAILikeWithPersonality(momentId, character, moment);
                                }, Math.random() * 3000 + 1000);
                            }
                        }
                    } else if (type === 'comment') {
                        console.log('开始处理角色评论，同分组角色数量:', sameGroupCharacters.length);
                        for (const character of sameGroupCharacters) {
                            const randomValue = Math.random();
                            const willComment = randomValue < 0.6;
                            console.log(`${character.name} 评论概率检查: ${randomValue.toFixed(3)} < 0.6 = ${willComment}`);

                            if (willComment) {
                                setTimeout(async () => {
                                    console.log(`${character.name} 开始生成评论...`);
                                    await addAICommentWithPersonality(momentId, character, moment);
                                }, Math.random() * 5000 + 2000);
                            } else {
                                console.log(`${character.name} 因为概率未通过，不会评论`);
                            }
                        }

                        // 🔥【简化】30秒后发布者70%概率回复其他角色评论
                        setTimeout(async () => {
                            console.log(`🔄 检查 ${publisherCharacter.name} 是否需要回复其他角色的评论...`);
                            await triggerPublisherReplyToComments(momentId, publisherCharacter);
                        }, 30000);

                        // 触发同分组角色间的互动
                        setTimeout(() => {
                            // 将发布者角色也加入到互动角色列表中
                            const allInteractionCharacters = [...sameGroupCharacters];
                            if (publisherCharacter) {
                                allInteractionCharacters.push(publisherCharacter);
                            }
                            triggerAiToAiInteractionWithPersonality(momentId, allInteractionCharacters);
                        }, Math.random() * 8000 + 5000);
                    }
                }
            } catch (error) {
                console.error('触发AI互动失败:', error);
            }
        }
        
        // 获取与指定角色在同一个群聊的其他角色
        function getCharactersInSameGroups(characterId) {
            const sameGroupCharacters = [];
            
            // 遍历所有群聊
            groupChats.forEach(group => {
                if (group.members && group.members.includes(characterId)) {
                    // 找到包含该角色的群聊，获取群内其他角色
                    group.members.forEach(memberId => {
                        if (memberId !== characterId && memberId !== 'user') {
                            const character = characters.find(c => c.id === memberId);
                            if (character && !sameGroupCharacters.find(c => c.id === character.id)) {
                                sameGroupCharacters.push(character);
                            }
                        }
                    });
                }
            });
            
            return sameGroupCharacters;
        }
        
        // AI角色点赞（基于人设和记忆系统）
        async function addAILikeWithPersonality(momentId, character, moment) {
            try {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;

            // 检查是否已经点赞过
                const existingLike = await db.momentLikes
                    .where('[momentId+authorId]')
                    .equals([parseInt(momentId), character.id])
                    .first();

                if (existingLike) return;

                // 基于角色人设、记忆系统和关系决定是否点赞
                const shouldLike = await shouldCharacterLikeMomentWithMemory(character, moment);
                if (!shouldLike) {
                    console.log(`${character.name} 基于人设和记忆选择不点赞这条动态`);
                    return;
                }

            // 添加点赞记录
                await db.momentLikes.add({
                    momentId: parseInt(momentId),
                    authorId: character.id,
                characterId: character.id,
                name: character.name,
                timestamp: Date.now()
            });

            // 更新界面显示
            updateMomentLikeDisplay(momentId);

            // 🔥【修复】只有用户的动态被点赞时才显示toast和推送通知
            if (moment.authorId === 'user') {
                // 显示点赞提示
                showToast(`${character.name} 赞了你的动态`);
                // 创建推送通知
                createPushNotification(character, `赞了你的动态`, 100);
            }

            // 记录到跨应用时间线
            await recordMemoryEvent(
                [character.id],
                {
                    type: 'moments',
                    id: 'moments'
                },
                'moment_like',
                `点赞了${moment.authorId === 'user' ? '用户' : moment.nickname}的动态`
            );
            } catch (error) {
                console.error('AI点赞失败:', error);
            }
        }

        // 保留原有的点赞函数作为兼容
        async function addAILike(momentId, character, moment) {
            return await addAILikeWithPersonality(momentId, character, moment);
        }
        
        // 基于人设和记忆系统判断角色是否会点赞这条动态
        async function shouldCharacterLikeMomentWithMemory(character, moment) {
            try {
                // 获取角色的聊天设置和记忆
                let chatSettings = null;
                try {
                    chatSettings = await db.chatSettings.get(character.id);
                } catch (error) {
                    console.error('获取聊天设置失败:', error);
                }

                const persona = chatSettings?.aiPersona || character.prompt || character.bio || `你是${character.name}。`;

                // 获取角色与动态发布者的关系记忆
                let relationshipMemory = '';
                if (moment.characterId && moment.characterId !== 'user') {
                    // 获取与其他角色的关系记忆
                    const coreMemories = await db.coreMemories
                        .where('characterId')
                        .equals(character.id)
                        .toArray();

                    const relationMemories = coreMemories.filter(memory =>
                        memory.fact && memory.fact.includes(moment.nickname)
                    );

                    if (relationMemories.length > 0) {
                        relationshipMemory = relationMemories.map(m => m.fact).join('；');
                    }
                }

                // 基于角色人设和动态内容的判断
                const characterBio = persona.toLowerCase();
                const momentText = (moment.text || '').toLowerCase();
                const momentAuthor = moment.nickname || '用户';

                // 检查是否存在负面关系记忆
                if (relationshipMemory) {
                    const negativeKeywords = ['吵架', '争执', '讨厌', '不喜欢', '敌对', '竞争', '情敌', '冲突'];
                    const hasNegativeRelation = negativeKeywords.some(keyword =>
                        relationshipMemory.toLowerCase().includes(keyword)
                    );

                    if (hasNegativeRelation) {
                        console.log(`${character.name} 与 ${momentAuthor} 存在负面关系记忆，不会点赞`);
                        return false;
                    }
                }

                // 如果角色人设中包含负面词汇，降低点赞概率
                const negativeTraits = ['冷漠', '严肃', '不善交际', '内向', '沉默'];
                const hasNegativeTraits = negativeTraits.some(trait => characterBio.includes(trait));

                if (hasNegativeTraits && Math.random() < 0.7) {
                    return false; // 70%概率不点赞
                }

                // 如果动态内容与角色兴趣相关，增加点赞概率
                const characterInterests = extractInterestsFromBio(characterBio);
                const hasRelatedContent = characterInterests.some(interest =>
                    momentText.includes(interest)
                );

                if (hasRelatedContent) {
                    return Math.random() < 0.9; // 90%概率点赞
                }

                // 如果是用户发的动态，增加点赞概率
                if (!moment.characterId || moment.characterId === 'user') {
                    return Math.random() < 0.8; // 80%概率点赞
                }

                // 默认情况
                return Math.random() < 0.7; // 70%概率点赞
            } catch (error) {
                console.error('判断角色点赞偏好失败:', error);
                return Math.random() < 0.6; // 默认60%概率
            }
        }

        // 保留原有函数作为兼容
        async function shouldCharacterLikeMoment(character, moment) {
            return await shouldCharacterLikeMomentWithMemory(character, moment);
        }
        
        // 从角色人设中提取兴趣关键词
        function extractInterestsFromBio(bio) {
            const interests = [];
            const interestKeywords = [
                '音乐', '电影', '读书', '运动', '游戏', '美食', '旅行', '摄影',
                '绘画', '写作', '代码', '科技', '动漫', '小说', '咖啡', '茶',
                '宠物', '花', '星空', '雨天', '阳光', '学习', '工作', '朋友'
            ];
            
            interestKeywords.forEach(keyword => {
                if (bio.includes(keyword)) {
                    interests.push(keyword);
                }
            });
            
            return interests;
        }
        
        // 更新动态点赞显示
        async function updateMomentLikeDisplay(momentId) {
            try {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;
            
                const momentLikes = await db.momentLikes.where('momentId').equals(parseInt(momentId)).toArray();
            
            // 更新点赞按钮数字
            const likeBtn = momentElement.querySelector('.moment-action-btn[onclick*="toggleMomentLike"]');
            if (likeBtn) {
                const likeCount = likeBtn.querySelector('span');
                if (likeCount) {
                    likeCount.textContent = momentLikes.length;
                }
            }
            
            // 更新或创建点赞用户名称显示
            let likesDisplay = momentElement.querySelector('.likes-display');
            
            if (momentLikes.length > 0) {
                if (!likesDisplay) {
                    likesDisplay = document.createElement('div');
                    likesDisplay.className = 'likes-display';
                    
                    // 检查是否已有评论区域，如果有就不设置margin-top
                        const existingCommentsSection = momentElement.querySelector('.moment-comments-section');
                        const marginTop = existingCommentsSection ? '0' : '0';
                    
                    likesDisplay.style.cssText = `
                        margin-top: ${marginTop};
                        padding: 8px 12px;
                        background: #f8f9fa;
                        font-size: 13px;
                        color: #666;
                        line-height: 1.4;
                    `;
                    
                        // 插入到操作按钮下面，评论区前面（如果有的话），否则在时间操作区后面
                    const momentContent = momentElement.querySelector('.moment-content');
                    const momentTimeActions = momentElement.querySelector('.moment-time-actions');
                        const commentsSection = momentElement.querySelector('.moment-comments-section');
                        
                    if (momentContent && momentTimeActions) {
                            if (commentsSection) {
                                // 如果已有评论区，插入到评论区前面
                                momentContent.insertBefore(likesDisplay, commentsSection);
                            } else {
                                // 没有评论区，插入到时间操作区后面
                        momentTimeActions.parentNode.insertBefore(likesDisplay, momentTimeActions.nextSibling);
                            }
                    }
                }
                
                // 使用和用户昵称相同颜色的空心爱心
                const likeIcon = '<svg width="14" height="14" style="margin-right: 4px; vertical-align: middle;" viewBox="0 0 24 24" fill="none" stroke="#576b95" stroke-width="2"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>';
                const names = momentLikes.map(like => like.name).join('、');
                likesDisplay.innerHTML = `${likeIcon}<span style="color: #576b95; font-weight: 600;">${names}</span>`;
                likesDisplay.style.display = 'block';
            } else if (likesDisplay) {
                likesDisplay.style.display = 'none';
                }
            } catch (error) {
                console.error('更新点赞显示失败:', error);
            }
        }
        
        // AI角色评论（基于人设和记忆系统）
        async function addAICommentWithPersonality(momentId, character, moment) {
            try {
                // 生成符合角色人设和记忆系统的评论
                const comments = await generateCharacterCommentWithMemory(character, moment);
                if (!comments || comments.length === 0) return;

                const randomComment = comments[Math.floor(Math.random() * comments.length)];

                const comment = {
                    id: Date.now() + Math.random(),
                    nickname: character.name,
                    avatar: character.avatarUrl,
                    text: randomComment,
                    time: formatTime(new Date()),
                    timestamp: Date.now(),
                    characterId: character.id
                };

                // 保存评论
                saveCommentToMoment(momentId, comment);

                // 更新评论数
                updateMomentCommentCount(momentId);

                // 在动态下方显示新评论
                displayCommentUnderMoment(momentId, comment);

                // 🔥【修复】只有当用户发布的动态被角色评论时，才显示评论提示和发送通知
                if (moment.authorId === 'user') {
                    showToast(`${character.name} 评论了你的动态`);
                    createPushNotification(character, `评论了你的动态：${randomComment.length > 15 ? randomComment.substring(0, 15) + '...' : randomComment}`, 200);
                }

                // 记录到跨应用时间线
                await recordMemoryEvent(
                    [character.id],
                    {
                        type: 'moments',
                        id: 'moments'
                    },
                    'moment_comment',
                    `评论了${moment.authorId === 'user' ? '用户' : moment.nickname}的动态：${randomComment}`
                );
            } catch (error) {
                console.error('AI角色评论失败:', error);
            }
        }

        // 保留原有的评论函数作为兼容
        async function addAIComment(momentId, character, moment) {
            return await addAICommentWithPersonality(momentId, character, moment);
        }
        
        // 🔥【新增】基于人设和记忆系统的角色间互动
        async function triggerAiToAiInteractionWithPersonality(momentId, relatedCharacters) {
            try {
                // 获取动态信息
                const moment = await db.moments.get(parseInt(momentId));
                if (!moment) return;

                // 获取该动态的所有评论
                const comments = await db.momentComments
                    .where('momentId')
                    .equals(parseInt(momentId))
                    .toArray();

                if (comments.length < 2) return; // 至少需要2条评论才能触发角色间互动

                // 获取参与评论的AI角色
                const participatingAis = [...new Set(comments
                    .filter(comment => comment.characterId && comment.characterId !== 'user')
                    .map(comment => comment.characterId)
                )];

                // 过滤出只有在同群的AI角色
                const sameGroupParticipants = participatingAis.filter(aiId =>
                    relatedCharacters.some(char => char.id === aiId)
                );

                if (sameGroupParticipants.length < 2) {
                    console.log('参与评论的同群AI角色少于2个，跳过角色间互动');
                    return;
                }

                console.log(`发现 ${sameGroupParticipants.length} 个同群AI角色参与了评论，开始角色间互动`);

                // 随机选择两个同群AI进行互动
                const aiA = sameGroupParticipants[Math.floor(Math.random() * sameGroupParticipants.length)];
                let aiB = sameGroupParticipants[Math.floor(Math.random() * sameGroupParticipants.length)];

                // 确保选择不同的AI
                while (aiB === aiA && sameGroupParticipants.length > 1) {
                    aiB = sameGroupParticipants[Math.floor(Math.random() * sameGroupParticipants.length)];
                }

                if (aiA === aiB) return;

                // 获取角色信息
                const charA = characters.find(c => c.id === aiA);
                const charB = characters.find(c => c.id === aiB);

                if (!charA || !charB) return;

                // 检查角色关系和互动概率（基于记忆系统）
                const shouldInteract = await shouldCharactersInteract(charA, charB);
                if (!shouldInteract) {
                    console.log(`${charA.name} 和 ${charB.name} 基于关系记忆选择不互动`);
                    return;
                }

                // 选择一个现有评论作为互动起点
                const targetComment = comments.find(comment =>
                    comment.characterId === aiA || comment.characterId === aiB
                );

                if (!targetComment) return;

                // 决定谁先回复谁
                const responderCharId = targetComment.characterId === aiA ? aiB : aiA;
                const targetCharId = targetComment.characterId;

                // 获取角色信息
                const responderChar = characters.find(c => c.id === responderCharId);
                const targetChar = characters.find(c => c.id === targetCharId);

                if (!responderChar || !targetChar) return;

                console.log(`${responderChar.name} 将回复 ${targetChar.name} 的评论`);

                // 生成基于记忆系统的AI间互动回复
                await generateAiToAiReplyWithMemory(momentId, targetComment, responderChar, targetChar);

            } catch (error) {
                console.error('角色间互动失败:', error);
            }
        }

        // 保留原有的角色间互动函数作为兼容
        async function triggerAiToAiInteraction(momentId, relatedCharacters) {
            return await triggerAiToAiInteractionWithPersonality(momentId, relatedCharacters);
        }

        // 🔥【新增】检查两个角色是否应该互动（基于记忆系统）
        async function shouldCharactersInteract(charA, charB) {
            try {
                // 获取角色A对角色B的记忆
                const memoriesA = await db.coreMemories
                    .where('characterId')
                    .equals(charA.id)
                    .toArray();

                const relationMemoriesA = memoriesA.filter(memory =>
                    memory.fact && memory.fact.includes(charB.name)
                );

                // 获取角色B对角色A的记忆
                const memoriesB = await db.coreMemories
                    .where('characterId')
                    .equals(charB.id)
                    .toArray();

                const relationMemoriesB = memoriesB.filter(memory =>
                    memory.fact && memory.fact.includes(charA.name)
                );

                // 检查是否存在负面关系记忆
                const allRelationMemories = [...relationMemoriesA, ...relationMemoriesB];
                const negativeKeywords = ['吵架', '争执', '讨厌', '不喜欢', '敌对', '竞争', '情敌', '冲突', '矛盾'];

                const hasNegativeRelation = allRelationMemories.some(memory =>
                    negativeKeywords.some(keyword =>
                        memory.fact.toLowerCase().includes(keyword)
                    )
                );

                if (hasNegativeRelation) {
                    // 如果有负面关系，只有20%概率互动（可能是冷嘲热讽）
                    return Math.random() < 0.2;
                }

                // 检查是否有正面关系记忆
                const positiveKeywords = ['朋友', '喜欢', '亲密', '合作', '帮助', '支持', '关心'];
                const hasPositiveRelation = allRelationMemories.some(memory =>
                    positiveKeywords.some(keyword =>
                        memory.fact.toLowerCase().includes(keyword)
                    )
                );

                if (hasPositiveRelation) {
                    // 如果有正面关系，80%概率互动
                    return Math.random() < 0.8;
                }

                // 默认情况，40%概率互动
                return Math.random() < 0.4;

            } catch (error) {
                console.error('检查角色互动关系失败:', error);
                return Math.random() < 0.4; // 默认40%概率
            }
        }

        // AI角色间的楼中楼互动（套用完成.html逻辑）
        async function triggerAiToAiInteractionOld(momentId, relatedCharacters) {
            try {
                // 获取动态信息
                const momentsData = JSON.parse(sessionStorage.getItem('momentsData') || '[]');
                const moment = momentsData.find(m => (m.id == momentId) || (m.timestamp == momentId));
                if (!moment || !moment.comments) return;
                
                const comments = moment.comments;
                if (comments.length < 2) return; // 至少需要2条评论才能触发角色间互动
                
                // 获取在同群的参与评论AI角色
                const participatingAis = [...new Set(comments
                    .filter(comment => comment.characterId && comment.characterId !== 'user')
                    .map(comment => comment.characterId)
                )];
                
                // 过滤出只有在同群的AI角色
                const sameGroupParticipants = participatingAis.filter(aiId => 
                    relatedCharacters.some(char => char.id === aiId)
                );
                
                if (sameGroupParticipants.length < 2) {
                    console.log('参与评论的同群AI角色少于2个，跳过角色间互动');
                    return;
                }
                
                console.log(`发现 ${sameGroupParticipants.length} 个同群AI角色参与了评论，开始角色间互动`);
                
                // 随机选择两个同群AI进行互动
                const aiA = sameGroupParticipants[Math.floor(Math.random() * sameGroupParticipants.length)];
                let aiB = sameGroupParticipants[Math.floor(Math.random() * sameGroupParticipants.length)];
                
                // 确保选择不同的AI
                while (aiB === aiA && sameGroupParticipants.length > 1) {
                    aiB = sameGroupParticipants[Math.floor(Math.random() * sameGroupParticipants.length)];
                }
                
                if (aiA === aiB) return;
                
                // 检查角色关系和互动概率 (40%概率，保持原有设置概率)
                if (Math.random() > 0.4) {
                    console.log('基于概率选择不进行角色间互动');
                    return;
                }
                
                // 选择一个现有评论作为互动起点
                const targetComment = comments.find(comment => 
                    comment.characterId === aiA || comment.characterId === aiB
                );
                
                if (!targetComment) return;
                
                // 决定谁先回复谁
                const responderCharId = targetComment.characterId === aiA ? aiB : aiA;
                const targetCharId = targetComment.characterId;
                
                // 获取角色信息
                const responderChar = characters.find(c => c.id === responderCharId);
                const targetChar = characters.find(c => c.id === targetCharId);
                
                if (!responderChar || !targetChar) return;
                
                console.log(`${responderChar.name} 将回复 ${targetChar.name} 的评论`);
                
                // 生成AI间的互动回复
                await generateAiToAiReply(momentId, targetComment, responderChar, targetChar);
                
            } catch (error) {
                console.error('角色间互动失败:', error);
            }
        }
        

        
        // 角色之间互动（保留原函数，但不再使用）
        function triggerCharacterInteractions(momentId, characters) {
            if (characters.length < 2) return;
            
            // 获取已在同一群的角色关系
            const groupRelations = getGroupRelations(characters);
            
            for (let i = 0; i < characters.length - 1; i++) {
                for (let j = i + 1; j < characters.length; j++) {
                    const char1 = characters[i];
                    const char2 = characters[j];
                    
                    // 检查是否在同一个群里
                    const inSameGroup = groupRelations.some(group => 
                        group.includes(char1.id) && group.includes(char2.id)
                    );
                    
                    if (inSameGroup && Math.random() < 0.6) {
                        addCharacterInteraction(momentId, char1, char2);
                    }
                }
            }
        }
        
        // 获取分组关系 - 基于角色分组而不是群聊
        function getGroupRelations(characters) {
            const groups = [];
            
            // 按分组ID分组角色
            const groupedCharacters = {};
            characters.forEach(character => {
                const groupId = character.groupId || 'my_friends';
                if (!groupedCharacters[groupId]) {
                    groupedCharacters[groupId] = [];
                }
                groupedCharacters[groupId].push(character.id);
            });
            
            // 只返回可以互动的分组（非默认分组且允许互动）
            Object.entries(groupedCharacters).forEach(([groupId, characterIds]) => {
                const group = characterGroups.find(g => g.id === groupId);
                
                // 只有非默认分组且允许互动的分组中的角色才能相互互动
                if (group && !group.isDefault && group.canInteract && characterIds.length >= 2) {
                    groups.push(characterIds);
                }
            });
            
            return groups;
        }
        
        // 🔥【新增】生成基于记忆系统的AI间回复
        async function generateAiToAiReplyWithMemory(momentId, targetComment, responderChar, targetChar) {
            try {
                // 获取动态信息
                const moment = await db.moments.get(parseInt(momentId));
                if (!moment) return;

                // 获取回复者的聊天设置和记忆
                let chatSettings = null;
                try {
                    chatSettings = await db.chatSettings.get(responderChar.id);
                } catch (error) {
                    console.error('获取聊天设置失败:', error);
                }

                const persona = chatSettings?.aiPersona || responderChar.prompt || `你是${responderChar.name}。`;

                // 获取与目标角色的关系记忆
                let relationshipMemory = '';
                const coreMemories = await db.coreMemories
                    .where('characterId')
                    .equals(responderChar.id)
                    .toArray();

                const relationMemories = coreMemories.filter(memory =>
                    memory.fact && memory.fact.includes(targetChar.name)
                );

                if (relationMemories.length > 0) {
                    relationshipMemory = '\n\n你们的关系记忆：\n' + relationMemories.map(m => m.fact).join('；');
                }

                // 获取绑定的世界书内容
                let worldBookContent = '';
                if (chatSettings?.linkedWorldBookIds && chatSettings.linkedWorldBookIds.length > 0) {
                    try {
                        const worldBooks = await Promise.all(
                            chatSettings.linkedWorldBookIds.map(id => db.worldbooks.get(id))
                        );
                        const validWorldBooks = worldBooks.filter(book => book && book.content);
                        if (validWorldBooks.length > 0) {
                            worldBookContent = '\n\n世界书内容（供参考）：\n' +
                                validWorldBooks.map(book => `${book.name}：${book.content}`).join('\n\n');
                        }
                    } catch (error) {
                        console.error('获取世界书内容失败:', error);
                    }
                }

                const systemPrompt = `你是${responderChar.name}，你的人设如下：${persona}。${worldBookContent}${relationshipMemory}

在一个动态的评论区，${targetChar.name} 刚刚评论了："${targetComment.text}"

原动态内容：${moment.text}

请作为${responderChar.name}，基于你的人设和与${targetChar.name}的关系记忆，对ta的评论进行回应。

## 重要提醒：
- 如果你们的关系记忆中有负面内容（如吵架、争执、情敌等），请根据你的性格决定回应方式
- 如果关系很好，可以更加亲密和随意
- 如果关系不好，可以冷淡、讽刺或直接忽略

## 回应要求：
1. 严格按照你的人设和性格特点
2. 根据你们的关系记忆调整语气和态度
3. 回复要简洁，10-25字左右
4. 可以是：赞同、反驳、调侃、询问、补充等
5. 要符合朋友圈评论的自然风格
6. 不要使用与角色性格不符的表情符号

请生成一条自然的回复：`;

                // 调用AI API生成回复
                const { base: proxyUrl, key: apiKey, model } = apiSettings;
                if (!proxyUrl || !apiKey || !model) {
                    console.log('API配置不完整，跳过AI间互动');
                    return;
                }

                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: '请回复这条评论：' }
                ];

                const requestBody = {
                    model: model,
                    messages: messages,
                    temperature: 0.8,
                    stream: false
                };

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000);

                // 检测是否是Gemini官方API
                const isGeminiOfficial = proxyUrl.includes('generativelanguage.googleapis.com');

                let response;
                if (isGeminiOfficial) {
                    // 使用Gemini官方API格式
                    const apiUrl = `${proxyUrl}/models/${model}:generateContent?key=${apiKey}`;

                    const geminiMessages = [];
                    if (requestBody.messages[0]?.role === 'system') {
                        geminiMessages.push({
                            role: 'user',
                            parts: [{ text: requestBody.messages[0].content }]
                        });
                        geminiMessages.push({
                            role: 'model',
                            parts: [{ text: '我明白了，我会按照这些要求进行回复。' }]
                        });
                    }

                    for (let i = 1; i < requestBody.messages.length; i++) {
                        const msg = requestBody.messages[i];
                        if (msg.role === 'system') continue;

                        geminiMessages.push({
                            role: msg.role === 'user' ? 'user' : 'model',
                            parts: [{ text: msg.content }]
                        });
                    }

                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiMessages,
                            generationConfig: {
                                temperature: requestBody.temperature || 0.8
                            }
                        }),
                        signal: controller.signal
                    });
                } else {
                    // 使用OpenAI格式
                    let apiUrl;
                    if (proxyUrl.endsWith('/v1')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else if (proxyUrl.includes('/v1/')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else {
                        apiUrl = `${proxyUrl}/v1/chat/completions`;
                    }

                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal
                    });
                }

                clearTimeout(timeoutId);

                if (!response.ok) {
                    console.error(`AI间互动API调用失败 (${response.status})`);
                    return;
                }

                const data = await response.json();
                let content;

                if (isGeminiOfficial) {
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                } else {
                    content = data.choices?.[0]?.message?.content || data.message || data.text || data.response || data.content || data.result;
                }

                if (content && content.trim().length > 0) {
                    const replyText = content.trim();

                    // 创建回复评论
                    const replyComment = {
                        id: Date.now() + Math.random(),
                        nickname: responderChar.name,
                        avatar: responderChar.avatarUrl,
                        text: replyText,
                        time: formatTime(new Date()),
                        timestamp: Date.now(),
                        characterId: responderChar.id,
                        replyTo: targetChar.name
                    };

                    // 保存回复
                    await saveCommentToMoment(momentId, replyComment);

                    // 更新评论数
                    await updateMomentCommentCount(momentId);

                    // 在动态下方显示新回复
                    displayCommentUnderMoment(momentId, replyComment);

                    // 记录到跨应用时间线
                    await recordMemoryEvent(
                        [responderChar.id],
                        {
                            type: 'moments',
                            id: 'moments'
                        },
                        'ai_to_ai_reply',
                        `回复了${targetChar.name}的评论：${replyText}`
                    );

                    console.log(`${responderChar.name} 回复了 ${targetChar.name}：${replyText}`);
                }

            } catch (error) {
                console.error('生成AI间回复失败:', error);
            }
        }

        // 保留原有的AI间回复函数作为兼容
        async function generateAiToAiReply(momentId, targetComment, responderChar, targetChar) {
            return await generateAiToAiReplyWithMemory(momentId, targetComment, responderChar, targetChar);
        }

        // 生成AI间的回复（使用新的记忆系统）
        async function generateAiToAiReplyOld(momentId, targetComment, responderChar, targetChar) {
            try {
                // 获取动态信息
                const momentsData = JSON.parse(sessionStorage.getItem('momentsData') || '[]');
                const moment = momentsData.find(m => (m.id == momentId) || (m.timestamp == momentId));
                if (!moment) return;

                const targetPersona = targetChar.prompt || '';
                
                // 🔥【修复】使用新的记忆系统
                const promptText = `现在在一个动态下，${targetChar.name}（人设：${targetPersona}）刚刚评论了："${targetComment.text}"。

原动态内容：${moment.text}

你要作为${responderChar.name}，基于你的人设和与${targetChar.name}的关系，对ta的评论进行回应。要求：
1. 严格按照你的人设进行回复，不能混淆角色
2. 回复要自然、符合朋友圈评论风格
3. 可以是赞同、不同观点、补充、提问或开玩笑
4. 要体现出你和${targetChar.name}之间的互动关系
5. 回复简短有趣，符合社交媒体的特点
6. 根据你的人设选择合适的语气和用词
7. 不要使用与角色性格不符的表情符号

请回复${targetChar.name}的评论：`;

                // 🔥【新增】记录跨应用时间线事件
                await recordCrossAppEvent(
                    responderChar.id,
                    'moments',
                    'ai_to_ai_reply',
                    {
                        targetCharacter: targetChar.name,
                        originalComment: targetComment.text,
                        momentContent: moment.text
                    }
                );

                // 使用新的记忆系统
                const response = await callChatAPI(promptText, responderChar);
                const replyText = Array.isArray(response) ? response[0] : response;

                if (replyText && replyText.trim()) {
                    // 创建回复评论
                    const replyComment = {
                        id: Date.now() + Math.random(),
                        nickname: responderChar.name,
                        avatar: responderChar.avatarUrl,
                        text: replyText.trim(),
                    time: formatTime(new Date()),
                    timestamp: Date.now(),
                        replyTo: targetChar.name,
                        characterId: responderChar.id
                };
                
                    // 保存评论
                    saveCommentToMoment(momentId, replyComment);
                
                    // 更新评论数
                updateMomentCommentCount(momentId);
                
                    // 在动态下方显示新评论
                    displayCommentUnderMoment(momentId, replyComment);
                
                    showToast(`${responderChar.name} 回复了 ${targetChar.name}`);
                }

            } catch (error) {
                console.error('生成AI间回复失败:', error);
            }
        }
        
        // AI回复用户评论（使用新的记忆系统）
        async function triggerAIReplyToUser(momentId, aiCharacterName, userCommentText) {
            try {
                console.log(`triggerAIReplyToUser被调用: momentId=${momentId}, aiCharacterName=${aiCharacterName}, userCommentText="${userCommentText}"`);

                // 找到对应的AI角色
                const character = characters.find(c => c.name === aiCharacterName);
                if (!character) {
                    console.log(`未找到角色 ${aiCharacterName}，可用角色:`, characters.map(c => c.name));
                    return;
                }

                // 获取动态信息
                const moment = await db.moments.get(parseInt(momentId));
                if (!moment) {
                    console.log(`未找到动态 ${momentId}`);
                    return;
                }

                // 🔥【修复】使用新的记忆系统，明确要求纯文本输出
                const promptText = `在一个动态下，用户刚刚回复了你的评论："${userCommentText}"。

原动态内容：${moment.text}

请作为${character.name}，基于你的人设对用户的回复做出自然的反应。要求：
1. 严格按照你的人设进行回复，保持角色一致性
2. 回复要自然、符合朋友圈评论风格，简短有趣
3. 可以是继续讨论、表达感谢、开玩笑或者分享更多想法
4. 体现出你和用户之间的友好互动
5. 根据你的人设选择合适的语气和用词
6. 不要使用与角色性格不符的表情符号

🚨 **重要格式要求**：
- 直接输出你的回复文本，不要使用JSON格式
- 不要包含任何特殊标记或格式符号
- 只输出你想说的话，10-30字左右

请回复用户的评论：`;

                // 🔥【新增】记录跨应用时间线事件
                await recordCrossAppEvent(
                    character.id,
                    'moments',
                    'reply_to_user',
                    {
                        userComment: userCommentText,
                        momentContent: moment.text
                    }
                );

                // 🔍 统计动态回复的记忆使用情况
                await logMemoryUsageStats(character, 'moments_reply_to_user');

                // 使用新的记忆系统
                const response = await callChatAPI(promptText, character);

                // 🔥【修复】正确处理AI回复格式，避免显示JSON
                let replyText;
                if (Array.isArray(response)) {
                    const firstItem = response[0];
                    if (typeof firstItem === 'string') {
                        replyText = firstItem;
                    } else if (typeof firstItem === 'object' && firstItem.content) {
                        replyText = firstItem.content;
                    } else if (typeof firstItem === 'object' && firstItem.message) {
                        replyText = firstItem.message;
                    } else {
                        replyText = String(firstItem);
                    }
                } else {
                    replyText = response;
                }

                console.log(`找到角色 ${character.name}，准备生成回复`);

                if (replyText && replyText.trim()) {
                    // 创建AI回复评论
                    const replyComment = {
                        id: Date.now() + Math.random(),
                        nickname: character.name,
                        avatar: character.avatarUrl,
                        text: replyText.trim(),
                        time: formatTime(new Date()),
                        timestamp: Date.now(),
                        replyTo: '我', // 回复用户
                        characterId: character.id
                    };

                    // 保存评论
                    saveCommentToMoment(momentId, replyComment);

                    // 更新评论数
                    updateMomentCommentCount(momentId);

                    // 在动态下方显示新评论
                    displayCommentUnderMoment(momentId, replyComment);

                    // 增加对话回合次
                    const conversationKey = `${momentId}-${character.name}`;
                    const currentRounds = commentConversationRounds.get(conversationKey) || 0;
                    commentConversationRounds.set(conversationKey, currentRounds + 1);
                    console.log(`${character.name} 在动态 ${momentId} 中的对话回合次更新为: ${currentRounds + 1}/10`);

                    showToast(`${character.name} 回复了你`);

                    // 🔥【新增】为角色回复用户评论创建推送通知
                    createPushNotification(character, `回复了你：${replyText.trim().length > 15 ? replyText.trim().substring(0, 15) + '...' : replyText.trim()}`, 200);
                }

            } catch (error) {
                console.error('AI回复用户失败:', error);
            }
        }
        
        // 生成符合角色人设和记忆系统的评论
        async function generateCharacterCommentWithMemory(character, moment) {
            try {
                console.log(`${character.name} 开始生成评论，动态发布者: ${moment.nickname || moment.authorId}`);
                // 获取角色对应的聊天设置
                let chatSettings = null;
                try {
                    chatSettings = await db.chatSettings.get(character.id);
                } catch (error) {
                    console.error('获取聊天设置失败:', error);
                }

                const persona = chatSettings?.aiPersona || character.prompt || `你是${character.name}。`;

                // 获取绑定的世界书内容
                let worldBookContent = '';
                if (chatSettings?.linkedWorldBookIds && chatSettings.linkedWorldBookIds.length > 0) {
                    try {
                    const worldBooks = await Promise.all(
                            chatSettings.linkedWorldBookIds.map(id => db.worldbooks.get(id))
                    );
                    const validWorldBooks = worldBooks.filter(book => book && book.content);
                    if (validWorldBooks.length > 0) {
                        worldBookContent = '\n\n世界书内容（供参考）：\n' +
                            validWorldBooks.map(book => `${book.name}：${book.content}`).join('\n\n');
                    }
                    } catch (error) {
                        console.error('获取世界书内容失败:', error);
                    }
                }

                // 获取分层记忆系统内容
                let memoryContent = '';
                try {
                    // 获取核心记忆
                    const coreMemories = await db.coreMemories
                        .where('characterId')
                        .equals(character.id)
                        .toArray();

                    const recentCoreMemories = coreMemories
                        .filter(m => m.type === 'core')
                        .sort((a, b) => b.importance - a.importance)
                        .slice(0, 5);

                    if (recentCoreMemories.length > 0) {
                        memoryContent += '\n\n核心记忆（重要的长期记忆）：\n';
                        recentCoreMemories.forEach((memory, index) => {
                            memoryContent += `${index + 1}. ${memory.fact}\n`;
                        });
                    }

                    // 获取情景记忆
                    const episodicMemories = await db.episodicMemories
                        .where('characterId')
                        .equals(character.id)
                        .toArray();

                    const recentEpisodicMemories = episodicMemories
                        .sort((a, b) => b.timestamp - a.timestamp)
                        .slice(0, 3);

                    if (recentEpisodicMemories.length > 0) {
                        memoryContent += '\n\n情景记忆（最近的重要经历）：\n';
                        recentEpisodicMemories.forEach((memory, index) => {
                            memoryContent += `${index + 1}. ${memory.fact}\n`;
                        });
                    }
                } catch (error) {
                    console.error('获取记忆内容失败:', error);
                }

                // 获取工作记忆（最近的聊天记录）
                let chatContext = '';
                const characterMessages = chatMessages[character.id] || [];
                if (characterMessages.length > 0) {
                    const maxMemory = parseInt(chatSettings?.maxMemory) || 10;
                    const recentHistory = characterMessages.slice(-maxMemory);
                    chatContext = '\n\n工作记忆（最近的聊天记录）：\n' +
                        recentHistory.map(msg => {
                            if (msg.role === 'user') return `用户：${msg.content}`;
                            return `${character.name}：${msg.content}`;
                        }).join('\n');
                }
                
                // 分析动态内容，提取关键信息
                const momentText = moment.text || '';

                // 🔥【修复】正确获取动态发布者信息
                let momentAuthor = '用户';
                const isUserMoment = !moment.characterId || moment.characterId === 'user' || moment.authorId === 'user';

                if (!isUserMoment) {
                    // 如果是角色发布的动态，查找角色信息
                    const publisherCharacter = characters.find(c => c.id === moment.characterId || c.id === moment.authorId);
                    if (publisherCharacter) {
                        momentAuthor = publisherCharacter.name;
                    } else {
                        momentAuthor = moment.nickname || '某位朋友';
                    }
                }
                
                // 🔥【增强】分析角色与动态发布者的关系
                let relationshipContext = '';
                let shouldComment = true; // 默认应该评论

                // 🔥【关键修复】将关系变量定义移到外层作用域，确保在后续代码中可以访问
                let hasNegativeRelation = false;
                let hasPositiveRelation = false;
                let hasNeutralRelation = false;

                if (!isUserMoment) {
                    // 如果是其他角色发布的动态，分析关系
                    const publisherCharacter = characters.find(c => c.id === moment.characterId || c.id === moment.authorId);
                    console.log(`${character.name} 正在分析与动态发布者的关系，发布者:`, publisherCharacter?.name || '未找到');
                    if (publisherCharacter) {
                        // 🔥【重点修复】更精确的人设关系分析
                        const currentPersona = (persona || '').toLowerCase();
                        const publisherName = publisherCharacter.name.toLowerCase();

                        console.log(`🔍 分析 ${character.name} 对 ${publisherCharacter.name} 的关系:`);
                        console.log(`人设内容: ${currentPersona}`);

                        // 更精确的关系检测 - 使用更严格的匹配逻辑
                        const negativeKeywords = ['情敌', '敌人', '讨厌', '不喜欢', '竞争', '对手', '吵架', '争执', '矛盾', '仇人', '冷战', '不和', '看不惯', '警惕', '提防', '防备'];
                        const positiveKeywords = ['朋友', '好友', '闺蜜', '兄弟', '姐妹', '恋人', '喜欢', '爱', '亲密', '信任', '依赖', '关心', '在乎'];
                        const neutralKeywords = ['同学', '同事', '室友', '邻居', '认识', '同班'];

                        // 检查人设中是否在发布者名字附近出现关系词
                        const publisherIndex = currentPersona.indexOf(publisherName);
                        if (publisherIndex !== -1) {
                            // 获取发布者名字前后30个字符的上下文
                            const contextStart = Math.max(0, publisherIndex - 30);
                            const contextEnd = Math.min(currentPersona.length, publisherIndex + publisherName.length + 30);
                            const relationContext = currentPersona.substring(contextStart, contextEnd);

                            console.log(`关系上下文: ${relationContext}`);

                            hasNegativeRelation = negativeKeywords.some(keyword => relationContext.includes(keyword));
                            hasPositiveRelation = positiveKeywords.some(keyword => relationContext.includes(keyword));
                            hasNeutralRelation = neutralKeywords.some(keyword => relationContext.includes(keyword));

                            console.log(`关系分析结果: 负面=${hasNegativeRelation}, 正面=${hasPositiveRelation}, 中性=${hasNeutralRelation}`);
                        } else {
                            // 如果在人设中找不到发布者名字，则检查整个人设内容
                            console.log(`在人设中未找到发布者名字，检查整个人设内容`);
                            hasNegativeRelation = negativeKeywords.some(keyword => currentPersona.includes(keyword));
                            hasPositiveRelation = positiveKeywords.some(keyword => currentPersona.includes(keyword));
                            hasNeutralRelation = neutralKeywords.some(keyword => currentPersona.includes(keyword));

                            console.log(`全文关系分析结果: 负面=${hasNegativeRelation}, 正面=${hasPositiveRelation}, 中性=${hasNeutralRelation}`);
                        }

                        // 🔥【增强】根据不同关系类型设置不同的互动策略
                        if (hasNegativeRelation) {
                            relationshipContext = `\n\n⚠️ 重要关系提醒：根据你的人设，你与${publisherCharacter.name}存在负面关系。请根据你的性格特点决定：
1. 是否要评论（可能选择忽略或冷淡回应）
2. 如果评论，语气应该保持距离感或略带敌意
3. 不要表现得过于友好热情
4. 可以选择性地挑刺、反驳或表达不同观点`;

                            // 🔥【修复】移除重复的概率判断，因为在triggerAIInteractions中已经做过60%概率筛选
                            // shouldComment = Math.random() < 0.6; // 删除重复概率判断
                        } else if (hasPositiveRelation) {
                            relationshipContext = `\n\n💝 关系提醒：根据你的人设，你与${publisherCharacter.name}关系很好。请表现出：
1. 更加亲密和随意的语气
2. 可以开善意的玩笑或调侃
3. 表达关心和支持
4. 使用你们之间的昵称或特殊称呼`;
                            // shouldComment = Math.random() < 0.6; // 删除重复概率判断
                        } else if (hasNeutralRelation) {
                            relationshipContext = `\n\n📝 关系提醒：你与${publisherCharacter.name}是${neutralKeywords.find(k => currentPersona.includes(k))}关系。请保持：
1. 适度的礼貌和距离感
2. 不过分亲密也不冷淡
3. 符合这种关系的正常互动`;
                            // shouldComment = Math.random() < 0.6; // 删除重复概率判断
                        } else {
                            // 没有明确关系设定，保持默认行为
                            // shouldComment = Math.random() < 0.6; // 删除重复概率判断
                        }
                    }
                }

                // 如果决定不评论，直接返回空数组
                if (!shouldComment) {
                    console.log(`${character.name} 因为与${momentAuthor}的关系选择不评论这条动态`);
                    return [];
                }

                console.log(`${character.name} 决定评论这条动态，开始生成评论内容...`);

                // 判断评论的类型和风格
                let commentStyle = '';
                const bio = (character.bio || '').toLowerCase();

                if (bio.includes('活泼') || bio.includes('开朗') || bio.includes('外向')) {
                    commentStyle = '热情活泼，用词轻松有趣';
                } else if (bio.includes('冷静') || bio.includes('理性') || bio.includes('严谨')) {
                    commentStyle = '理性客观，表达简洁';
                } else if (bio.includes('温柔') || bio.includes('善良') || bio.includes('体贴')) {
                    commentStyle = '温暖关怀，语气柔和';
                } else if (bio.includes('幽默') || bio.includes('搞笑') || bio.includes('风趣')) {
                    commentStyle = '幽默风趣，善于调侃';
                } else if (bio.includes('内向') || bio.includes('安静') || bio.includes('害羞')) {
                    commentStyle = '简洁含蓄，不多话但真诚';
                } else {
                    commentStyle = '自然真实，符合性格';
                }

                let systemPrompt = `你是${character.name}，你的人设如下：${persona}。${worldBookContent}${memoryContent}${chatContext}${relationshipContext}

🎯 **当前情况分析**：
- 动态发布者：${momentAuthor}
- 动态内容："${momentText}"
- 你与${momentAuthor}的关系：${hasNegativeRelation ? '负面关系（情敌/敌对）' : hasPositiveRelation ? '正面关系（朋友/亲密）' : hasNeutralRelation ? '中性关系（同学/同事）' : '关系不明确'}

请作为${character.name}，基于你的人设、记忆和与发布者的关系，对这条动态发表评论。

## 🚨 关键行为准则：
1. **人设第一**：严格按照你的人设行事，绝不违背角色设定
2. **关系敏感**：特别注意你与${momentAuthor}的关系，这决定了你的态度和语气
3. **内容理解**：仔细分析动态内容，如果是表白、炫耀、求助等特殊内容，要有相应的反应
4. **情绪一致**：你的评论情绪要与你对这个人的真实感受一致

## 🎭 角色表现要求：
- 如果你们是情敌或有矛盾：表现出警惕、冷淡、甚至略带敌意的态度
- 如果你们是好朋友：表现出关心、支持、亲密的态度
- 如果关系一般：保持礼貌但不过分热情
- 如果你不了解这个人：可以表现出好奇或保持距离

## 评论风格要求：
- ${commentStyle}
- 10-30字左右，简洁有力
- 要体现出你的真实反应和情感
- 可以是：赞美认同、善意调侃、关心询问、分享感受、提出建议等
- 如果与发布者关系不好，可以选择不评论或冷淡回应

## 角色表达要求：
1. 严格按照你的人设和性格特点
2. 用词要符合你的身份和说话习惯
3. 表达要自然，不要过于刻意
4. 根据你们的关系历史调整语气和亲密度
5. 根据动态内容选择合适的回应角度
6. 避免使用与角色性格不符的表情符号
7. 不要生硬地重复动态内容，要有自己的观点
8. 如果记忆中有相关经历，可以自然地提及

## 互动关系：
- 如果是用户发的动态：以朋友身份温馨互动
- 如果是其他角色发的动态：严格基于你们的关系记忆和人设互动

请生成一条自然、有个性、贴合你人设和关系的评论：`;
                
                // 构建用户消息，检查是否有图片需要识别
                let postDescription = `原动态：${momentText}`;
                let hasImages = moment.images && moment.images.length > 0;
                
                if (hasImages) {
                    postDescription += `\n[该动态包含${moment.images.length}张图片]`;
                }
                
                const userMsg = `${postDescription}\n请发表你的看法：`;
                
                // 检查当前模型是否支持视觉识别
                const supportsVision = isVisionModelSupported();
                let messages;
                
                if (hasImages && supportsVision) {
                    // 使用多模态消息格式，包含图片
                    const firstImage = moment.images[0]; // 使用第一张图片
                    console.log(`为角色 ${character.name} 使用图片识别功能评论动态`);
                    
                    messages = [
                        { role: 'system', content: systemPrompt },
                        { 
                            role: 'user', 
                            content: [
                                { type: 'text', text: `原动态文字：${momentText}\n\n这条动态还包含了一张图片，请仔细观察图片内容，然后发表你的看法：` },
                                { type: 'image_url', image_url: { url: firstImage } }
                            ]
                        }
                    ];
                } else {
                    // 普通文本消息
                    if (hasImages && !supportsVision) {
                        console.log(`当前模型不支持图片识别，${character.name} 将基于文字内容评论`);
                        // 修改提示，让AI知道有图片但无法看到
                        const textOnlyMsg = `${postDescription}\n\n注意：这条动态包含图片，但由于当前模型限制，你无法看到图片内容。请基于文字部分发表你的看法，可以适当询问图片相关内容。`;
                        messages = [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: textOnlyMsg }
                        ];
                    } else {
                        // 纯文字动态
                        messages = [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: userMsg }
                        ];
                    }
                }
                
                // 使用完整的API调用逻辑（与聊天相同）
                const { base: proxyUrl, key: apiKey, model } = apiSettings;
                if (!proxyUrl || !apiKey || !model) {
                    console.log('API配置不完整，跳过AI评论');
                    return [];
                }
                
                const requestBody = {
                    model: model,
                    messages: messages,
                    temperature: 0.8,
                    stream: false
                };
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000);
                
                // 检测是否是Gemini官方API
                const isGeminiOfficial = proxyUrl.includes('generativelanguage.googleapis.com');
                
                let response;
                if (isGeminiOfficial) {
                    // 使用Gemini官方API格式
                    const apiUrl = `${proxyUrl}/models/${model}:generateContent?key=${apiKey}`;
                    
                    // 转换消息格式为Gemini格式
                    const geminiMessages = [];
                    
                    // 添加系统提示词作为第一条用户消息
                    if (requestBody.messages[0]?.role === 'system') {
                        geminiMessages.push({
                            role: 'user',
                            parts: [{ text: requestBody.messages[0].content }]
                        });
                        geminiMessages.push({
                            role: 'model',
                            parts: [{ text: '我明白了，我会按照这些要求进行对话。' }]
                        });
                    }
                    
                    // 转换其他消息
                    for (let i = 1; i < requestBody.messages.length; i++) {
                        const msg = requestBody.messages[i];
                        if (msg.role === 'system') continue;
                        
                        // 处理多模态内容（包含图片）
                        if (Array.isArray(msg.content)) {
                            const parts = [];
                            msg.content.forEach(item => {
                                if (item.type === 'text') {
                                    parts.push({ text: item.text });
                                } else if (item.type === 'image_url') {
                                    // 处理图片，需要转换格式
                                    const imageUrl = item.image_url.url;
                                    if (imageUrl.startsWith('data:')) {
                                        // Base64图片
                                        const [mimeInfo, base64Data] = imageUrl.split(',');
                                        const mimeType = mimeInfo.match(/data:([^;]+)/)?.[1] || 'image/jpeg';
                                        parts.push({
                                            inline_data: {
                                                mime_type: mimeType,
                                                data: base64Data
                                            }
                                        });
                                    } else {
                                        // URL图片，Gemini可能不支持，添加文本说明
                                        parts.push({ text: '[图片：' + imageUrl + ']' });
                                    }
                                }
                            });
                            geminiMessages.push({
                                role: msg.role === 'user' ? 'user' : 'model',
                                parts: parts
                            });
                        } else {
                            // 文本消息
                            geminiMessages.push({
                                role: msg.role === 'user' ? 'user' : 'model',
                                parts: [{ text: msg.content }]
                            });
                        }
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiMessages,
                            generationConfig: {
                                temperature: requestBody.temperature || 0.8
                            }
                        }),
                        signal: controller.signal
                    });
                } else {
                    // 使用OpenAI格式
                    // 智能处理URL拼接
                    let apiUrl;
                    if (proxyUrl.endsWith('/v1')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else if (proxyUrl.includes('/v1/')) {
                        // 如果URL中已经包含/v1/路径，直接添加chat/completions
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else {
                        apiUrl = `${proxyUrl}/v1/chat/completions`;
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal
                    });
                }
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    let errorText = await response.text();
                    console.error(`API调用失败 (${response.status}): ${errorText}`);
                    return [];
                }
                
                const data = await response.json();
                let content;
                
                if (isGeminiOfficial) {
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!content) {
                        console.log('Gemini API 响应数据:', data);
                        return [];
                    }
                } else {
                    // 解析OpenAI格式响应
                    if (data.choices && data.choices.length > 0 && data.choices[0].message) {
                        content = data.choices[0].message.content;
                    } else if (data.message) {
                        content = data.message;
                    } else if (data.text) {
                        content = data.text;
                    } else if (data.response) {
                        content = data.response;
                    } else if (data.content) {
                        content = data.content;
                    } else if (data.result) {
                        content = data.result;
                    } else {
                        // 尝试查找第一个字符串类型的值
                        for (const key in data) {
                            if (typeof data[key] === 'string' && data[key].trim()) {
                                content = data[key];
                                console.log(`AI评论API使用字段 "${key}" 作为响应内容`);
                                break;
                            }
                        }
                    }
                    
                    if (!content) {
                        console.error('AI评论API无法解析响应，完整响应数据:', data);
                        return [];
                    }
                }
                
                if (content && content.trim().length > 0) {
                    return [content.trim()];
                }
                
                return [];
                
            } catch (error) {
                console.error('生成AI评论失败:', error);
                return [];
            }
        }

        // 保留原有的评论生成函数作为兼容
        async function generateCharacterComment(character, moment) {
            return await generateCharacterCommentWithMemory(character, moment);
        }


        // 🔥【新增】发布者角色回复评论的逻辑
        async function triggerPublisherReplyToComments(momentId, publisherCharacter) {
            try {
                if (!publisherCharacter) return;

                // 🔥【修复】确保momentId是正确的数字类型
                const numericMomentId = typeof momentId === 'string' ? parseInt(momentId) : momentId;
                console.log(`🔍 查询动态 ${numericMomentId} 的评论...`);

                // 获取该动态的所有评论
                const comments = await db.momentComments
                    .where('momentId')
                    .equals(numericMomentId)
                    .toArray();

                if (comments.length === 0) return;

                console.log(`🔍 检查动态 ${momentId} 的评论，发布者: ${publisherCharacter.name} (ID: ${publisherCharacter.id})`);
                console.log(`📝 找到 ${comments.length} 条评论:`, comments.map(c => `${c.nickname} (authorId: ${c.authorId})`));

                // 🔥【修复】过滤出其他角色的评论（不包括发布者自己的评论和用户评论）
                const otherCharacterComments = comments.filter(comment => {
                    const isNotPublisher = comment.authorId !== publisherCharacter.id;
                    const isNotUser = comment.authorId !== 'user';
                    const isAICharacter = comment.authorId && comment.authorId !== 'user';

                    console.log(`📋 评论筛选: ${comment.nickname} - authorId: ${comment.authorId}, 不是发布者: ${isNotPublisher}, 不是用户: ${isNotUser}, 是AI角色: ${isAICharacter}`);

                    return isNotPublisher && isNotUser && isAICharacter;
                });

                // 🔥【新增】过滤掉已经被回复过的评论
                const unrepliedComments = otherCharacterComments.filter(comment => {
                    // 检查是否已经有发布者回复这条评论
                    const hasReply = comments.some(reply =>
                        reply.authorId === publisherCharacter.id &&
                        reply.replyTo === comment.nickname
                    );

                    if (hasReply) {
                        console.log(`⏭️ ${comment.nickname} 的评论已被 ${publisherCharacter.name} 回复过，跳过`);
                    }

                    return !hasReply;
                });

                console.log(`✅ 筛选后的其他角色评论数量: ${otherCharacterComments.length}`);
                console.log(`✅ 未回复的评论数量: ${unrepliedComments.length}`);
                if (unrepliedComments.length === 0) {
                    console.log(`❌ 没有未回复的其他角色评论，${publisherCharacter.name} 无需回复`);
                    return;
                }

                // 🔥【简化】70%概率回复其他角色评论
                const randomValue = Math.random();
                console.log(`🎲 回复概率检查: ${randomValue.toFixed(3)} < 0.7 = ${randomValue < 0.7} (未回复评论数: ${unrepliedComments.length})`);

                if (randomValue < 0.7) {
                    const randomComment = unrepliedComments[Math.floor(Math.random() * unrepliedComments.length)];
                    console.log(`🎯 ${publisherCharacter.name} 选择回复 ${randomComment.nickname} 的评论: "${randomComment.text}"`);

                    // 生成回复
                    const replyText = await generatePublisherReply(publisherCharacter, randomComment, numericMomentId);
                    if (replyText) {
                        const reply = {
                            id: Date.now() + Math.random(),
                            nickname: publisherCharacter.name,
                            avatar: publisherCharacter.avatarUrl,
                            text: replyText,
                            time: formatTime(new Date()),
                            timestamp: Date.now(),
                            characterId: publisherCharacter.id,
                            replyTo: randomComment.nickname
                        };

                        // 保存回复
                        await saveCommentToMoment(numericMomentId, reply);

                        // 更新评论数
                        await updateMomentCommentCount(numericMomentId);

                        // 在动态下方显示新回复
                        displayCommentUnderMoment(numericMomentId, reply);

                        console.log(`✅ ${publisherCharacter.name} 成功回复了 ${randomComment.nickname} 的评论: "${replyText}"`);

                        // 🔥【新增】记录跨应用时间线事件
                        await recordCrossAppEvent(
                            publisherCharacter.id,
                            'moments',
                            'ai_to_ai_reply',
                            {
                                repliedTo: randomComment.nickname,
                                replyContent: replyText,
                                originalComment: randomComment.text
                            }
                        );
                    } else {
                        console.log(`❌ ${publisherCharacter.name} 生成回复失败`);
                    }
                } else {
                    console.log(`🚫 ${publisherCharacter.name} 因为概率未通过，不会回复其他角色的评论`);
                }
            } catch (error) {
                console.error('发布者回复评论失败:', error);
            }
        }

        // 🔥【新增】生成发布者对评论的回复
        async function generatePublisherReply(publisherCharacter, originalComment, momentId) {
            try {
                // 获取动态信息
                const moment = await db.moments.get(parseInt(momentId));
                if (!moment) return '';

                // 获取角色的聊天设置和记忆
                let chatSettings = null;
                try {
                    chatSettings = await db.chatSettings.get(publisherCharacter.id);
                } catch (error) {
                    console.error('获取聊天设置失败:', error);
                }

                const persona = chatSettings?.aiPersona || publisherCharacter.prompt || `你是${publisherCharacter.name}。`;

                // 获取与评论者的关系记忆
                let relationshipMemory = '';
                const coreMemories = await db.coreMemories
                    .where('characterId')
                    .equals(publisherCharacter.id)
                    .toArray();

                const relationMemories = coreMemories.filter(memory =>
                    memory.fact && memory.fact.includes(originalComment.nickname)
                );

                if (relationMemories.length > 0) {
                    relationshipMemory = '\n\n你们的关系记忆：\n' + relationMemories.map(m => m.fact).join('；');
                }

                const systemPrompt = `你是${publisherCharacter.name}，你的人设如下：${persona}。${relationshipMemory}

你刚刚发布了一条动态："${moment.text}"

${originalComment.nickname} 评论说："${originalComment.text}"

请作为动态的发布者，对这条评论进行回复。

## 回复要求：
1. 回复要符合你的人设和性格
2. 根据你与评论者的关系调整语气（如果记忆中有负面关系，可以冷淡或不回复）
3. 回复要简洁，10-20字左右
4. 可以是：感谢、回应、调侃、询问等
5. 要体现出作为动态发布者的身份

请生成一条自然的回复：`;

                // 调用AI API生成回复
                const { base: proxyUrl, key: apiKey, model } = apiSettings;
                if (!proxyUrl || !apiKey || !model) {
                    console.log('API配置不完整，跳过发布者回复');
                    return '';
                }

                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: '请回复这条评论：' }
                ];

                const requestBody = {
                    model: model,
                    messages: messages,
                    temperature: 0.8,
                    stream: false
                };

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000);

                // 检测是否是Gemini官方API
                const isGeminiOfficial = proxyUrl.includes('generativelanguage.googleapis.com');

                let response;
                if (isGeminiOfficial) {
                    // 使用Gemini官方API格式
                    const apiUrl = `${proxyUrl}/models/${model}:generateContent?key=${apiKey}`;

                    const geminiMessages = [];
                    if (requestBody.messages[0]?.role === 'system') {
                        geminiMessages.push({
                            role: 'user',
                            parts: [{ text: requestBody.messages[0].content }]
                        });
                        geminiMessages.push({
                            role: 'model',
                            parts: [{ text: '我明白了，我会按照这些要求进行回复。' }]
                        });
                    }

                    for (let i = 1; i < requestBody.messages.length; i++) {
                        const msg = requestBody.messages[i];
                        if (msg.role === 'system') continue;

                        geminiMessages.push({
                            role: msg.role === 'user' ? 'user' : 'model',
                            parts: [{ text: msg.content }]
                        });
                    }

                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiMessages,
                            generationConfig: {
                                temperature: requestBody.temperature || 0.8
                            }
                        }),
                        signal: controller.signal
                    });
                } else {
                    // 使用OpenAI格式
                    let apiUrl;
                    if (proxyUrl.endsWith('/v1')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else if (proxyUrl.includes('/v1/')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else {
                        apiUrl = `${proxyUrl}/v1/chat/completions`;
                    }

                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal
                    });
                }

                clearTimeout(timeoutId);

                if (!response.ok) {
                    console.error(`发布者回复API调用失败 (${response.status})`);
                    return '';
                }

                const data = await response.json();
                let content;

                if (isGeminiOfficial) {
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                } else {
                    content = data.choices?.[0]?.message?.content || data.message || data.text || data.response || data.content || data.result;
                }

                if (content && content.trim().length > 0) {
                    return content.trim();
                }

                return '';

            } catch (error) {
                console.error('生成发布者回复失败:', error);
                return '';
            }
        }

        // 生成角色间互动评论 - 使用完整的AI聊天逻辑
        async function generateCharacterInteraction(char1, char2, momentId) {
            try {
                // 获取动态和之前的评论上下文
                const momentsData = JSON.parse(sessionStorage.getItem('momentsData') || '[]');
                const moment = momentsData.find(m => (m.id == momentId) || (m.timestamp == momentId));
                if (!moment) return '';
                
                // 获取角色对应的聊天设置
                let chatSettings1 = null;
                let chatSettings2 = null;
                try {
                    chatSettings1 = await db.chatSettings.get(char1.id);
                    chatSettings2 = await db.chatSettings.get(char2.id);
                } catch (error) {
                    console.error('获取聊天设置失败:', error);
                }
                
                // 获取char2的最新评论作为上下文
                const char2Comments = (moment.comments || []).filter(c => c.characterId === char2.id);
                const latestChar2Comment = char2Comments[char2Comments.length - 1];
                
                // 构建对话上下文
                let conversationContext = `用户发布了动态：${moment.text}\n`;
                if (latestChar2Comment) {
                    conversationContext += `${char2.name}评论说：${latestChar2Comment.text}\n`;
                }
                
                // 使用完整的AI人设和记忆系统
                const persona1 = chatSettings1?.aiPersona || char1.prompt || `你是${char1.name}。`;
                
                // 获取历史聊天记录
                const maxMemory = parseInt(chatSettings1?.maxMemory) || 10;
                const char1Messages = chatMessages[char1.id] || [];
                const recentMessages = char1Messages.slice(-maxMemory);
                
                let chatSummary = '';
                if (recentMessages.length > 0) {
                    chatSummary = '你和用户最近的聊天记录（供参考）：\n';
                    chatSummary += recentMessages.map(msg => {
                        if (msg.role === 'user') return `用户：${msg.content}`;
                        if (msg.role === 'assistant') return `${char1.name}：${msg.content}`;
                        return '';
                    }).filter(line => line).join('\n');
                }
                
                // 获取挂载的世界书内容
                let worldBookContent = '';
                if (chatSettings1?.linkedWorldBookIds && chatSettings1.linkedWorldBookIds.length > 0) {
                    try {
                    const worldBooks = await Promise.all(
                            chatSettings1.linkedWorldBookIds.map(async id => {
                                try {
                                    return await db.worldbooks.get(id);
                                } catch (error) {
                                    console.error('获取世界书失败:', error);
                                    return null;
                                }
                            })
                    );
                    const validWorldBooks = worldBooks.filter(book => book && book.content);
                    if (validWorldBooks.length > 0) {
                        worldBookContent = '\n\n世界书内容（供参考）：\n' + 
                            validWorldBooks.map(book => `${book.name}：${book.content}`).join('\n\n');
                    }
                    } catch (error) {
                        console.error('获取世界书内容失败:', error);
                    }
                }
                
                let systemPrompt = `你是${char1.name}，你的人设如下：${persona1}。${worldBookContent}${chatSummary}\n\n`;
                systemPrompt += `这是一个楼中楼讨论，请基于以下对话上下文，继续参与讨论。要符合你的人设，回复要简短有趣。`;
                if (chatSettings2?.aiPersona) {
                    systemPrompt += ` （${char2.name}的设定：${chatSettings2.aiPersona}）`;
                }
                systemPrompt += `\n\n要求：
1. 回复要符合朋友圈评论的风格，简短、自然
2. 严格按照你的人设来选择是否使用表情符号，不要使用与角色性格不符的emoji
3. 不要过于正式或客套，要像真实的朋友一样互动`;
                
                // 构建消息
                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: conversationContext }
                ];
                
                // 使用完整的API调用逻辑（与聊天相同）
                const { base: proxyUrl, key: apiKey, model } = apiSettings;
                if (!proxyUrl || !apiKey || !model) {
                    console.log('API配置不完整，跳过角色互动');
                    return '';
                }
                
                const requestBody = {
                    model: model,
                    messages: messages,
                    temperature: 0.8,
                    stream: false
                };
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000);
                
                // 检测是否是Gemini官方API
                const isGeminiOfficial = proxyUrl.includes('generativelanguage.googleapis.com');
                
                let response;
                if (isGeminiOfficial) {
                    // 使用Gemini官方API格式
                    const apiUrl = `${proxyUrl}/models/${model}:generateContent?key=${apiKey}`;
                    
                    const geminiMessages = [];
                    if (requestBody.messages[0]?.role === 'system') {
                        geminiMessages.push({
                            role: 'user',
                            parts: [{ text: requestBody.messages[0].content }]
                        });
                        geminiMessages.push({
                            role: 'model',
                            parts: [{ text: '我明白了，我会按照这些要求进行对话。' }]
                        });
                    }
                    
                    for (let i = 1; i < requestBody.messages.length; i++) {
                        const msg = requestBody.messages[i];
                        if (msg.role === 'system') continue;
                        
                        geminiMessages.push({
                            role: msg.role === 'user' ? 'user' : 'model',
                            parts: [{ text: msg.content }]
                        });
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiMessages,
                            generationConfig: {
                                temperature: requestBody.temperature || 0.8
                            }
                        }),
                        signal: controller.signal
                    });
                } else {
                    // 修复：智能处理URL拼接
                    let apiUrl;
                    if (proxyUrl.endsWith('/v1')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else if (proxyUrl.includes('/v1/')) {
                        // 如果URL中已经包含/v1/路径，直接添加chat/completions
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else {
                        apiUrl = `${proxyUrl}/v1/chat/completions`;
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal
                    });
                }
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    let errorText = await response.text();
                    console.error(`角色互动API调用失败 (${response.status}): ${errorText}`);
                    return '';
                }
                
                const data = await response.json();
                let content;
                
                if (isGeminiOfficial) {
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!content) {
                        console.log('Gemini API 响应数据:', data);
                        return '';
                    }
                } else {
                    // 解析OpenAI格式响应
                    if (data.choices && data.choices.length > 0 && data.choices[0].message) {
                        content = data.choices[0].message.content;
                    } else if (data.message) {
                        content = data.message;
                    } else if (data.text) {
                        content = data.text;
                    } else if (data.response) {
                        content = data.response;
                    } else if (data.content) {
                        content = data.content;
                    } else if (data.result) {
                        content = data.result;
                    } else {
                        // 尝试查找第一个字符串类型的值
                        for (const key in data) {
                            if (typeof data[key] === 'string' && data[key].trim()) {
                                content = data[key];
                                console.log(`角色互动API使用字段 "${key}" 作为响应内容`);
                                break;
                            }
                        }
                    }
                    
                    if (!content) {
                        console.error('角色互动API无法解析响应，完整响应数据:', data);
                return '';
                    }
                }
                
                return content ? content.trim() : '';
                
            } catch (error) {
                console.error('生成角色互动失败:', error);
                return '';
            }
        }
        

        
        // 长按选择功能
        function addLongPressListener(element, momentId) {
            let pressTimer = null;
            let startY = 0;
            let moved = false;
            
            const startPress = (e) => {
                if (isSelectionMode) return;
                
                startY = e.touches ? e.touches[0].clientY : e.clientY;
                moved = false;
                
                pressTimer = setTimeout(() => {
                    if (!moved) {
                        enterSelectionMode();
                        selectMoment(momentId);
                    }
                }, 500); // 500ms长按
            };
            
            const endPress = () => {
                clearTimeout(pressTimer);
                pressTimer = null;
            };
            
            const movePress = (e) => {
                const currentY = e.touches ? e.touches[0].clientY : e.clientY;
                if (Math.abs(currentY - startY) > 10) {
                    moved = true;
                    endPress();
                }
            };
            
            element.addEventListener('touchstart', startPress);
            element.addEventListener('touchend', endPress);
            element.addEventListener('touchmove', movePress);
            element.addEventListener('mousedown', startPress);
            element.addEventListener('mouseup', endPress);
            element.addEventListener('mousemove', movePress);
        }
        
        // 进入选择模式
        function enterSelectionMode() {
            isSelectionMode = true;
            selectedMoments.clear();
            
            // 显示选择模式UI
            showSelectionModeUI();
            
            // 添加选择框到所有动态
            const momentItems = document.querySelectorAll('.moment-item');
            momentItems.forEach(item => {
                const checkbox = document.createElement('div');
                checkbox.className = 'moment-checkbox';
                checkbox.innerHTML = '<i class="far fa-circle"></i>';
                checkbox.onclick = (e) => {
                    e.stopPropagation();
                    const momentId = item.getAttribute('data-moment-id');
                    toggleMomentSelection(momentId);
                };
                item.appendChild(checkbox);
                item.classList.add('selection-mode');
            });
        }
        
        // 退出选择模式
        function exitSelectionMode() {
            isSelectionMode = false;
            selectedMoments.clear();
            
            // 隐藏选择模式UI
            hideSelectionModeUI();
            
            // 移除选择框
            const checkboxes = document.querySelectorAll('.moment-checkbox');
            checkboxes.forEach(checkbox => checkbox.remove());
            
            const momentItems = document.querySelectorAll('.moment-item');
            momentItems.forEach(item => {
                item.classList.remove('selection-mode', 'selected');
            });
        }
        
        // 显示选择模式UI
        function showSelectionModeUI() {
            const selectionBar = document.createElement('div');
            selectionBar.className = 'selection-bar';
            selectionBar.innerHTML = `
                <div class="selection-actions">
                    <button class="cancel-btn" data-action="cancel">取消</button>
                    <span class="selection-count">已选择 0 条动态</span>
                    <button class="delete-btn" data-action="delete" disabled>删除</button>
                </div>
            `;

            // 🔥【修复】使用事件委托绑定点击事件，避免内联onclick问题
            selectionBar.onclick = function(e) {
                const action = e.target.dataset.action;
                if (action === 'cancel') {
                    exitSelectionMode();
                } else if (action === 'delete' && !e.target.disabled) {
                    deleteSelectedMoments();
                }
            };

            const momentsPage = document.getElementById('moments-page');
            momentsPage.insertBefore(selectionBar, momentsPage.firstChild);
        }
        
        // 隐藏选择模式UI
        function hideSelectionModeUI() {
            const selectionBar = document.querySelector('.selection-bar');
            if (selectionBar) {
                selectionBar.remove();
            }
        }
        
        // 切换动态选择状态
        function toggleMomentSelection(momentId) {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;
            
            const checkbox = momentElement.querySelector('.moment-checkbox i');
            
            if (selectedMoments.has(momentId)) {
                selectedMoments.delete(momentId);
                checkbox.className = 'far fa-circle';
                momentElement.classList.remove('selected');
            } else {
                selectedMoments.add(momentId);
                checkbox.className = 'fas fa-check-circle';
                momentElement.classList.add('selected');
            }
            
            updateSelectionUI();
        }
        
        // 选择动态
        function selectMoment(momentId) {
            if (!selectedMoments.has(momentId)) {
                toggleMomentSelection(momentId);
            }
        }
        
        // 更新选择UI
        function updateSelectionUI() {
            const countSpan = document.querySelector('.selection-count');
            const deleteBtn = document.querySelector('.delete-btn');
            
            if (countSpan) {
                countSpan.textContent = `已选择 ${selectedMoments.size} 条动态`;
            }
            
            if (deleteBtn) {
                deleteBtn.disabled = selectedMoments.size === 0;
            }
        }
        
        // 删除选中的动态
        async function deleteSelectedMoments() {
            if (selectedMoments.size === 0) return;
            
            if (!confirm(`确定要删除 ${selectedMoments.size} 条动态吗？`)) {
                return;
            }
            
            try {
                // 从数据库中删除
                for (const momentId of selectedMoments) {
                    try {
                        // 尝试多种ID格式进行删除
                        let deleted = false;
                        const possibleIds = [momentId, parseInt(momentId), String(momentId), Number(momentId)];
                        
                        for (const id of possibleIds) {
                            try {
                                await db.moments.delete(id);
                                console.log(`✓ 成功删除动态 ${id} (类型: ${typeof id})`);
                                deleted = true;
                                break;
                            } catch (error) {
                                console.log(`删除ID ${id} (${typeof id}) 失败: ${error.message}`);
                            }
                        }
                        
                        if (!deleted) {
                            // 尝试使用where条件删除
                            await db.moments.where('id').equals(momentId).delete();
                            console.log(`✓ 使用where条件删除动态 ${momentId} 成功`);
                        }
                        
                        // 删除相关点赞（尝试不同ID格式）
                        const numericId = parseInt(momentId);
                        await db.momentLikes.where('momentId').equals(numericId).delete();
                        await db.momentLikes.where('momentId').equals(momentId).delete();
                        
                        // 删除相关评论（尝试不同ID格式）
                        await db.momentComments.where('momentId').equals(numericId).delete();
                        await db.momentComments.where('momentId').equals(momentId).delete();
                        
                    } catch (error) {
                        console.error(`删除动态 ${momentId} 失败:`, error);
                        throw error; // 重新抛出错误以便上层处理
                    }
                    
                    // 清理对话回合次记录
                    for (const [key, value] of commentConversationRounds.entries()) {
                        if (key.startsWith(`${momentId}-`)) {
                            commentConversationRounds.delete(key);
                        }
                    }
            }
            
            // 从DOM中移除
            selectedMoments.forEach(momentId => {
                const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
                if (momentElement) {
                    momentElement.remove();
                }
            });
                
                // 清理可能存在的sessionStorage缓存数据
                try {
                    const sessionMomentsData = sessionStorage.getItem('momentsData');
                    if (sessionMomentsData) {
                        const momentsArray = JSON.parse(sessionMomentsData);
                        const filteredMoments = momentsArray.filter(moment => 
                            !selectedMoments.has(moment.id.toString()) && 
                            !selectedMoments.has(moment.timestamp?.toString())
                        );
                        sessionStorage.setItem('momentsData', JSON.stringify(filteredMoments));
                    }
                } catch (error) {
                    console.warn('清理sessionStorage动态数据时出错:', error);
                }
            
            showToast(`已删除 ${selectedMoments.size} 条动态`);
            
            // 退出选择模式
            exitSelectionMode();
                
                // 强制重新加载动态列表，确保删除生效
                setTimeout(() => {
                    loadMoments();
                }, 500);
                
            } catch (error) {
                console.error('删除动态失败:', error);
                showToast('删除失败，请重试');
            }
        }
        
        // 强制清理指定动态的所有相关数据
        async function forceCleanMoment(momentId) {
            try {
                const numericId = parseInt(momentId);
                console.log(`开始彻底清理动态: ${momentId}`);
                
                // 1. 从IndexedDB删除（尝试多种ID格式）
                let deleted = false;
                const possibleIds = [momentId, numericId, String(momentId), Number(momentId)];
                
                for (const id of possibleIds) {
                    try {
                        await db.moments.delete(id);
                        console.log(`✓ 删除动态成功，使用ID: ${id} (类型: ${typeof id})`);
                        deleted = true;
                        break;
                    } catch (error) {
                        console.log(`删除ID ${id} 失败: ${error.message}`);
                    }
                }
                
                if (!deleted) {
                    await db.moments.where('id').equals(momentId).delete();
                }
                
                // 删除相关数据（尝试不同格式）
                await db.momentLikes.where('momentId').equals(numericId).delete();
                await db.momentLikes.where('momentId').equals(momentId).delete();
                await db.momentComments.where('momentId').equals(numericId).delete();
                await db.momentComments.where('momentId').equals(momentId).delete();
                
                // 2. 清理对话回合次记录
                for (const [key, value] of commentConversationRounds.entries()) {
                    if (key.startsWith(`${momentId}-`)) {
                        commentConversationRounds.delete(key);
                    }
                }
                
                // 3. 从DOM移除
                const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
                if (momentElement) {
                    momentElement.remove();
                }
                
                // 4. 清理sessionStorage缓存
                const sessionMomentsData = sessionStorage.getItem('momentsData');
                if (sessionMomentsData) {
                    const momentsArray = JSON.parse(sessionMomentsData);
                    const filteredMoments = momentsArray.filter(moment => 
                        moment.id != momentId && 
                        moment.timestamp != momentId &&
                        moment.id.toString() !== momentId.toString()
                    );
                    sessionStorage.setItem('momentsData', JSON.stringify(filteredMoments));
                }
                
                console.log(`动态 ${momentId} 清理完成`);
                return true;
            } catch (error) {
                console.error('强制清理动态失败:', error);
                return false;
            }
        }
        
        // 清理所有有问题的动态（修复工具）
        async function cleanupCorruptedMoments() {
            if (!confirm('这将清理所有可能有问题的动态数据，确定继续吗？')) {
                return;
            }
            
            try {
                let cleanupCount = 0;
                
                // 获取所有动态
                const allMoments = await db.moments.toArray();
                
                for (const moment of allMoments) {
                    // 检查动态是否有无效的头像数据
                    if (moment.avatar && !isValidAvatarUrl(moment.avatar)) {
                        console.log(`发现无效头像的动态: ${moment.id}`);
                        
                        // 修复头像或删除动态
                        const shouldDelete = confirm(`动态 "${moment.text?.substring(0, 30)}..." 包含无效头像数据，是否删除此动态？\n点击"取消"将修复头像数据。`);
                        
                        if (shouldDelete) {
                            await forceCleanMoment(moment.id);
                            cleanupCount++;
                        } else {
                            // 修复头像
                            await db.moments.update(moment.id, { avatar: getDefaultAvatar() });
                        }
                    }
                }
                
                if (cleanupCount > 0) {
                    showToast(`已清理 ${cleanupCount} 条有问题的动态`);
                    // 重新加载动态列表
                    loadMoments();
                } else {
                    showToast('没有发现需要清理的动态');
                }
                
            } catch (error) {
                console.error('清理损坏动态失败:', error);
                showToast('清理失败，请重试');
            }
        }
        
        // 更换动态封面图片
        function changeCoverImage() {
            const input = document.createElement("input");
            input.type = "file";
            input.accept = "image/*,.jpg,.jpeg,.png,.gif,.webp";
            input.onchange = async function(e) {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedImage = await compressImage(file, 1200, 0.8);
                        
                        const coverImage = document.getElementById("cover-image");
                        const coverPlaceholder = document.getElementById("cover-placeholder");
                        
                        if (coverImage && coverPlaceholder) {
                            coverImage.src = compressedImage;
                            coverImage.classList.remove("hide");
                            coverPlaceholder.classList.add("hide");
                        }
                        
                        saveMomentsImage("coverImage", compressedImage);
                        showToast("封面已更新！", "success");
                    } catch (error) {
                        console.error("处理封面图片失败:", error);
                        showToast("封面更新失败！", "error");
                    }
                }
            };
            input.click();
        }
        
        // 更换动态头像
        function changeAvatarImage(event) {
            event.stopPropagation();
            
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*,.jpg,.jpeg,.png,.gif,.webp';
            input.onchange = async function(e) {
                const file = e.target.files[0];
                if (file) {
                    try {
                        // 压缩头像图片
                        const compressedImage = await compressImage(file, 400, 0.9);
                        
                        const avatar = document.getElementById('moments-avatar');
                        const avatarIcon = avatar.querySelector('.moments-avatar-icon');
                        
                        avatar.style.backgroundImage = `url(${compressedImage})`;
                        avatarIcon.style.display = 'none';
                        
                        // 保存压缩后的图片
                        saveMomentsImage('avatarImage', compressedImage);
                        
                        showToast('头像已更新！', 'success');
                    } catch (error) {
                        console.error('处理头像图片失败:', error);
                        showToast('头像更新失败！', 'error');
                    }
                }
            };
            input.click();
        }
        
        // 🔥【修复】加载动态图片设置（异步版本）
        async function loadMomentsImages() {
            try {
                // 加载封面图片
                const savedCover = await getMomentsImage('coverImage');
                if (savedCover) {
                    const coverImage = document.getElementById('cover-image');
                    const coverPlaceholder = document.getElementById('cover-placeholder');
                    
                    if (coverImage && coverPlaceholder) {
                        coverImage.src = savedCover;
                        coverImage.classList.remove('hide');
                        coverPlaceholder.classList.add('hide');
                    }
                }
                
                // 加载头像图片
                const savedAvatar = await getMomentsImage('avatarImage');
                if (savedAvatar) {
                    const avatar = document.getElementById('moments-avatar');
                    const avatarIcon = avatar?.querySelector('.moments-avatar-icon');
                    
                    if (avatar) {
                        avatar.style.backgroundImage = `url(${savedAvatar})`;
                        if (avatarIcon) {
                            avatarIcon.style.display = 'none';
                        }
                    }
                }
                
                // 加载用户名
                const savedUsername = await getMomentsImage('username');
                if (savedUsername) {
                    const usernameElement = document.getElementById('moments-username');
                    if (usernameElement) {
                        usernameElement.textContent = savedUsername;
                    }
                }
                
                console.log('动态图片加载完成');
            } catch (error) {
                console.error('加载动态图片失败:', error);
            }
        }
        
        // 更改用户名
        function changeUsername(event) {
            event.stopPropagation();
            
            const currentUsername = document.getElementById('moments-username').textContent;
            const newUsername = prompt('请输入您的昵称:', currentUsername);
            
            if (newUsername !== null && newUsername.trim() !== '') {
                const usernameElement = document.getElementById('moments-username');
                usernameElement.textContent = newUsername.trim();
                
                // 保存用户名
                saveMomentsImage('username', newUsername.trim());
                
                showToast('昵称已更新！', 'success');
            }
        }
        
        // 压缩图片
        function compressImage(fileOrDataUrl, maxWidth = 800, quality = 0.8) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = function() {
                    // 计算压缩后的尺寸
                    let { width, height } = img;
                    if (width > maxWidth) {
                        height = (height * maxWidth) / width;
                        width = maxWidth;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    // 绘制压缩后的图片
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // 转换为base64，降低质量以减少大小
                    const compressedData = canvas.toDataURL('image/jpeg', quality);
                    resolve(compressedData);
                };
                
                // 判断输入类型：File对象还是base64字符串
                if (typeof fileOrDataUrl === 'string') {
                    // 如果是base64字符串，直接使用
                    img.src = fileOrDataUrl;
                } else {
                    // 如果是File对象，创建URL
                    img.src = URL.createObjectURL(fileOrDataUrl);
                }
            });
        }
        
        // 🔥【修复】保存动态图片（使用IndexedDB持久化存储）
        async function saveMomentsImage(imageType, imageData) {
            try {
                // 压缩图片数据以节省存储空间
                let compressedData = imageData;
                if (imageData.startsWith('data:image/')) {
                    try {
                        compressedData = await compressImage(imageData, 800, 0.8);
                    } catch (error) {
                        console.warn('图片压缩失败，使用原图:', error);
                    }
                }
                
                // 保存到IndexedDB
                await db.globalSettings.put({
                    id: `moments_${imageType}`,
                    type: 'moments_setting',
                    data: compressedData
                });
                
                console.log(`动态图片已保存到数据库: ${imageType}`);
            } catch (error) {
                console.error('保存动态图片失败:', error);
                // 如果数据库保存失败，回退到sessionStorage
                try {
                    sessionStorage.setItem(`moments_${imageType}`, imageData);
                    console.log(`动态图片已保存到会话存储: ${imageType}`);
                } catch (sessionError) {
                    // 如果sessionStorage也满了，只在内存中保存
                    window.momentsImages = window.momentsImages || {};
                    window.momentsImages[imageType] = imageData;
                    console.log(`动态图片已保存到内存: ${imageType}`);
                }
            }
        }
        
        // 🔥【修复】获取动态图片（从IndexedDB获取）
        async function getMomentsImage(imageType) {
            try {
                // 先从IndexedDB获取
                const dbData = await db.globalSettings.get(`moments_${imageType}`);
                if (dbData && dbData.data) {
                    return dbData.data;
                }
                
                // 兼容性：从sessionStorage获取
                const sessionData = sessionStorage.getItem(`moments_${imageType}`);
                if (sessionData) {
                    // 如果从sessionStorage获取到数据，迁移到IndexedDB
                    await saveMomentsImage(imageType, sessionData);
                    return sessionData;
                }
                
                // 最后从内存获取
                if (window.momentsImages && window.momentsImages[imageType]) {
                    return window.momentsImages[imageType];
                }
                
                return null;
            } catch (error) {
                console.error('获取动态图片失败:', error);
                // 回退到sessionStorage
                try {
                    return sessionStorage.getItem(`moments_${imageType}`);
                } catch (sessionError) {
                    return null;
                }
            }
        }
        
        // 🔥【新增】数据完整性检查函数
        function validateDataIntegrity(data, dataType) {
            if (!data) return false;

            switch (dataType) {
                case 'characters':
                    return Array.isArray(data) && data.every(char =>
                        char && char.id && char.name &&
                        char.name !== '张三' && char.name !== '李四'
                    );
                case 'chatMessages':
                    return Array.isArray(data) && data.every(msg =>
                        msg && msg.id && msg.characterId
                    );
                case 'chatSettings':
                    return Array.isArray(data) && data.every(setting =>
                        setting && setting.id && setting.chatId
                    );
                default:
                    return Array.isArray(data) ? data.length > 0 : !!data;
            }
        }

        // 🔥【新增】安全的数据保存函数，防止数据丢失
        async function safeDataSave(tableName, data, operation = 'replace') {
            if (!data || (Array.isArray(data) && data.length === 0)) {
                console.warn(`⚠️ ${tableName} 数据为空，拒绝保存以防止数据丢失`);
                return false;
            }

            // 数据完整性检查
            if (!validateDataIntegrity(data, tableName)) {
                console.error(`❌ ${tableName} 数据完整性检查失败，拒绝保存`);
                throw new Error(`${tableName} 数据不完整或包含异常数据`);
            }

            try {
                const table = db[tableName];
                if (!table) {
                    throw new Error(`表 ${tableName} 不存在`);
                }

                // 使用事务进行原子操作
                await db.transaction('rw', table, async () => {
                    if (operation === 'replace') {
                        await table.clear();
                        if (Array.isArray(data)) {
                            await table.bulkPut(data);
                        } else {
                            await table.put(data);
                        }
                    } else if (operation === 'add') {
                        if (Array.isArray(data)) {
                            await table.bulkAdd(data);
                        } else {
                            await table.add(data);
                        }
                    }
                });

                const count = Array.isArray(data) ? data.length : 1;
                console.log(`✅ 安全保存了 ${count} 条 ${tableName} 数据`);
                return true;
            } catch (error) {
                console.error(`❌ 保存 ${tableName} 数据失败:`, error);
                throw error;
            }
        }

        // 重置数据库（如果出现schema错误）
        async function resetDatabase() {
            try {
                await db.delete();
                console.log('数据库已重置');
                location.reload(); // 重新加载页面
            } catch (error) {
                console.error('重置数据库失败:', error);
            }
        }
        
        // 🎮【新增】游戏跨应用记忆记录函数
        async function recordGameEvent(characterId, eventType, gameData) {
            try {
                await recordCrossAppEvent(
                    characterId,
                    'game',
                    eventType,
                    {
                        id: `game_${Date.now()}`,
                        type: 'game_session',
                        gameName: gameData.gameName,
                        action: eventType,
                        result: gameData.result,
                        score: gameData.score,
                        chatContent: gameData.chatContent,
                        timestamp: Date.now()
                    }
                );
                console.log(`🎮 已记录游戏事件: ${eventType} - ${gameData.gameName}`);
            } catch (error) {
                console.error('记录游戏事件失败:', error);
            }
        }

        // 🎮【新增】游戏聊天记录函数
        async function recordGameChat(characterId, sender, message, gameContext) {
            try {
                await recordCrossAppEvent(
                    characterId,
                    'game',
                    'game_chat',
                    {
                        id: `game_chat_${Date.now()}`,
                        type: 'game_chat',
                        sender: sender,
                        content: message,
                        gameName: gameContext.gameName,
                        gameState: gameContext.gameState,
                        timestamp: Date.now()
                    }
                );
                console.log(`🎮 已记录游戏聊天: ${sender} - ${message.substring(0, 30)}...`);
            } catch (error) {
                console.error('记录游戏聊天失败:', error);
            }
        }

        // 开始游戏
        function startGame(gameName) {
            if (gameName === 'witchPotion') {
                // TODO: 实现女巫的解药游戏
                alert('女巫的解药游戏正在开发中...\n\n这将是一个与AI角色互动的解谜游戏！\n\n🎮 游戏功能预览：\n- 与AI角色一边游戏一边聊天\n- 游戏结果和聊天内容都会记录到工作记忆中\n- 按时间顺序与普通聊天记录合并显示');

                // 🎮【示例】记录游戏开始事件
                if (currentChatCharacter && !currentChatCharacter.isGroup) {
                    recordGameEvent(currentChatCharacter.id, 'game_start', {
                        gameName: '女巫的解药',
                        result: null,
                        score: null,
                        chatContent: null
                    });
                }
            } else {
                alert('游戏功能正在开发中...');
            }
        }
        
                // 切换手机边框显示
        function togglePhoneBorder() {
            const phoneFrame = document.getElementById('phone-frame');
            const phoneScreen = document.getElementById('phone-screen');
            const toggle = document.getElementById('phone-border-toggle');
            const body = document.body;
            
            if (toggle.checked) {
                // 显示真实手机边框
                phoneFrame.style.display = 'block';
                phoneFrame.style.padding = '12px';
                phoneFrame.style.backgroundColor = '#fff';
                phoneFrame.style.borderRadius = '50px';
                phoneFrame.style.boxShadow = '0 20px 50px rgba(0,0,0,0.25), inset 0 2px 4px rgba(0,0,0,0.1)';
                phoneScreen.style.borderRadius = '40px';
                phoneScreen.style.border = '2px solid #333';
                body.style.background = 'var(--body-bg, #dcdcdc)';
                body.style.padding = '20px';
            } else {
                // 隐藏边框，但保持phone-screen的圆角和阴影
                phoneFrame.style.display = 'block';
                phoneFrame.style.padding = '0';
                phoneFrame.style.backgroundColor = 'transparent';
                phoneFrame.style.borderRadius = '0';
                phoneFrame.style.boxShadow = 'none';
                phoneScreen.style.borderRadius = '25px';
                phoneScreen.style.border = 'none';
                phoneScreen.style.boxShadow = 'var(--shadow-phone)';
                body.style.background = 'var(--body-bg, #1a1a1a)';
                body.style.padding = '0';
            }
            
            // 保存设置到localStorage
            localStorage.setItem('phoneBorderEnabled', toggle.checked);
            
            // 显示提示
            const message = toggle.checked ? '手机边框已开启！' : '手机边框已关闭！';
            showToast(message, 'success');
        }
        
        // 显示屏幕尺寸选择
        function showScreenSizeOptions() {
            showApp('screen-size-screen');
        }
        
        // 改变屏幕尺寸
        function changeScreenSize(width, height, name) {
            const phoneScreen = document.getElementById('phone-screen');
            
            // 应用新尺寸
            phoneScreen.style.width = width + 'px';
            phoneScreen.style.height = height + 'px';
            
            // 更新外观设置中的显示文本
            const currentSizeDesc = document.getElementById('current-screen-size');
            if (currentSizeDesc) {
                currentSizeDesc.textContent = `当前：${width}×${height} (${name})`;
            }
            
            // 更新选中状态
            document.querySelectorAll('.size-option .check-icon').forEach(icon => {
                icon.style.display = 'none';
            });
            document.querySelectorAll('.size-option').forEach(option => {
                option.style.backgroundColor = '';
            });
            
            // 显示当前选中项的勾选图标
            const currentOption = event.target.closest('.size-option');
            if (currentOption) {
                const checkIcon = currentOption.querySelector('.check-icon');
                if (checkIcon) {
                    checkIcon.style.display = 'block';
                } else {
                    // 如果没有勾选图标，创建一个
                    const newCheckIcon = document.createElement('i');
                    newCheckIcon.className = 'fas fa-check check-icon';
                    newCheckIcon.style.display = 'block';
                    currentOption.appendChild(newCheckIcon);
                }
                currentOption.style.backgroundColor = 'rgba(0, 123, 255, 0.1)';
            }
            
            // 保存到localStorage
            localStorage.setItem('screenSize', JSON.stringify({width, height, name}));
            
            // 显示提示
            showToast(`屏幕尺寸已切换为${name}！`, 'success');
            
            // 延迟一点再返回，让用户看到选择效果
            setTimeout(() => {
                showApp('appearance-screen');
            }, 300);
        }
        
        // 加载屏幕尺寸设置
        function loadScreenSize() {
            const saved = localStorage.getItem('screenSize');
            if (saved) {
                const {width, height, name} = JSON.parse(saved);
                const phoneScreen = document.getElementById('phone-screen');
                phoneScreen.style.width = width + 'px';
                phoneScreen.style.height = height + 'px';
                
                const currentSizeDesc = document.getElementById('current-screen-size');
                if (currentSizeDesc) {
                    currentSizeDesc.textContent = `当前：${width}×${height} (${name})`;
                }
            }
        }

        // 更新状态栏图标
        function updateStatusIcon() {
            const input = document.getElementById('status-icon-input');
            const icon = input.value.trim() || '🐾';

            // 更新CSS变量
            document.documentElement.style.setProperty('--status-icon', `"${icon}"`);

            // 保存到本地存储
            localStorage.setItem('statusIcon', icon);
        }

        // 重置状态栏图标
        function resetStatusIcon() {
            const input = document.getElementById('status-icon-input');
            input.value = '🐾';
            updateStatusIcon();
        }



        // 加载状态栏图标设置
        function loadStatusIconSetting() {
            const saved = localStorage.getItem('statusIcon');
            const input = document.getElementById('status-icon-input');
            const icon = saved || '🐾';

            if (input) {
                input.value = icon;
            }

            // 应用设置
            document.documentElement.style.setProperty('--status-icon', `"${icon}"`);
        }

        // 加载边框设置
        function loadPhoneBorderSetting() {
            const saved = localStorage.getItem('phoneBorderEnabled');
            const toggle = document.getElementById('phone-border-toggle');
            
            // 默认关闭边框
            const enabled = saved !== null ? saved === 'true' : false;
            
            if (toggle) {
                toggle.checked = enabled;
            }
            
            // 应用设置
            const phoneFrame = document.getElementById('phone-frame');
            const phoneScreen = document.getElementById('phone-screen');
            const body = document.body;
            
            if (enabled) {
                // 显示真实手机边框
                phoneFrame.style.display = 'block';
                phoneFrame.style.padding = '12px';
                phoneFrame.style.backgroundColor = '#fff';
                phoneFrame.style.borderRadius = '50px';
                phoneFrame.style.boxShadow = '0 20px 50px rgba(0,0,0,0.25), inset 0 2px 4px rgba(0,0,0,0.1)';
                phoneScreen.style.borderRadius = '40px';
                phoneScreen.style.border = '2px solid #333';
                body.style.background = 'var(--body-bg, #dcdcdc)';
                body.style.padding = '20px';
            } else {
                // 隐藏边框，但保持phone-screen的圆角和阴影
                phoneFrame.style.display = 'block';
                phoneFrame.style.padding = '0';
                phoneFrame.style.backgroundColor = 'transparent';
                phoneFrame.style.borderRadius = '0';
                phoneFrame.style.boxShadow = 'none';
                phoneScreen.style.borderRadius = '25px';
                phoneScreen.style.border = 'none';
                phoneScreen.style.boxShadow = 'var(--shadow-phone)';
                body.style.background = 'var(--body-bg, #1a1a1a)';
                body.style.padding = '0';
            }
        }
        
        // 添加Toast提示函数
        function showToast(message, type = 'info') {
            // 创建toast元素
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background-color: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 500;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                opacity: 0;
                transition: opacity 0.3s ease;
                backdrop-filter: blur(10px);
                -webkit-backdrop-filter: blur(10px);
            `;
            toast.textContent = message;
            
            document.body.appendChild(toast);
            
            // 显示toast
            setTimeout(() => {
                toast.style.opacity = '1';
            }, 10);
            
            // 3秒后自动隐藏
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, 3000);
        }
        
        // 文本截断函数
        function truncateText(text, maxLength = 50) {
    // --- 新增的安全检查 ---
    let textStr = '';
    if (typeof text === 'string') {
        textStr = text;
    } else if (text && typeof text === 'object') {
        // 如果收到了一个对象，可能是[object Object]问题的根源，
        // 我们不再让它崩溃，而是显示一个通用占位符。
        console.warn("truncateText 函数收到了一个对象，已自动处理:", text);
        return '[多媒体消息]';
    } else {
        // 对于其他意外情况 (如 null 或 undefined)，返回空字符串。
        return '';
    }
    // --- 安全检查结束 ---

    // 现在 textStr 保证是一个字符串，后续代码可以安全执行
            const plainText = textStr.replace(/<[^>]*>/g, '');
            const cleanText = plainText.replace(/\s+/g, ' ').trim();
            
            if (cleanText.length <= maxLength) {
                return cleanText;
            }
            
            return cleanText.substring(0, maxLength) + '...';
        }

        // 添加单个消息并应用动画效果
        function addMessageWithAnimation(message, characterId) {
            const messagesContainer = document.getElementById('api-chat-messages');
            if (!messagesContainer || !currentChatCharacter || characterId !== currentChatCharacter.id) return;
            
            const chatSettings = getCurrentChatSettings();
            const typingIndicator = document.getElementById('typing-indicator');
            
            // 处理系统消息
            if (message.sender === 'system') {
                // 🔥【修复】处理拉黑系统消息 - 显示为居中的系统提示
                if (message.isBlockedMessage) {
                    const centerContainer = document.createElement('div');
                    centerContainer.style.display = 'flex';
                    centerContainer.style.justifyContent = 'center';
                    centerContainer.style.margin = '4px 0';
                    centerContainer.dataset.messageId = message.id;

                    const systemContainer = document.createElement('div');
                    systemContainer.className = 'system-message';
                    systemContainer.textContent = message.content || '消息已发出，但被对方拒收了';

                    centerContainer.appendChild(systemContainer);
                    messagesContainer.insertBefore(centerContainer, typingIndicator);
                    return;
                }

                let systemElement;

                if (message.isPoke) {
                    const systemContainer = document.createElement('div');
                    systemContainer.className = 'poke-system-container';
                    const systemMessage = document.createElement('div');
                    systemMessage.className = 'poke-system-message';
                    systemMessage.textContent = message.content;
                    systemContainer.appendChild(systemMessage);
                    systemElement = systemContainer;
                } else if (message.type === 'recalled_message') {
                    const centerContainer = document.createElement('div');
                    centerContainer.style.display = 'flex';
                    centerContainer.style.justifyContent = 'center';
                    centerContainer.style.margin = '4px 0';
                    centerContainer.dataset.messageId = message.id;
                    
                    const recallElement = document.createElement('div');
                    recallElement.className = 'recalled-message';
                    
                    const lines = message.content.split('\n');
                    const mainText = lines[0];
                    const originalText = lines[1];
                    
                    recallElement.textContent = mainText;
                    
                    if (originalText && originalText.startsWith('原文：')) {
                        const originalDiv = document.createElement('div');
                        originalDiv.className = 'original-text';
                        originalDiv.textContent = originalText;
                        recallElement.appendChild(originalDiv);
                    }
                    
                    centerContainer.appendChild(recallElement);
                    systemElement = centerContainer;
                    addMessageLongPressListener(centerContainer, message.id);
                } else {
                    const centerContainer = document.createElement('div');
                    centerContainer.style.display = 'flex';
                    centerContainer.style.justifyContent = 'center';
                    centerContainer.style.margin = '4px 0';
                    
                    const systemContainer = document.createElement('div');
                    // 🔥【美化】检查是否为好友添加成功消息，应用特殊样式
                    if (message.isFriendAddedMessage) {
                        systemContainer.className = 'friend-added-system-message';
                    } else {
                        systemContainer.className = 'system-message';
                    }
                    systemContainer.textContent = message.content;
                    
                    centerContainer.appendChild(systemContainer);
                    systemElement = centerContainer;
                }
                
                // 为系统消息添加滑入动画
                systemElement.style.opacity = '0';
                systemElement.style.transform = 'translateY(20px)';
                
                messagesContainer.insertBefore(systemElement, typingIndicator);
                
                // 触发动画
                requestAnimationFrame(() => {
                    systemElement.classList.add('message-slide-in');
                });
                
                return;
            }
            
            // 创建普通消息容器
            let messageContainer = document.createElement('div');
            const isEmojiOnly = message.isEmoji && !message.content;
            messageContainer.className = `message-container ${message.sender}${chatSettings.hideAvatars ? ' no-avatar' : ''}${isEmojiOnly ? ' emoji-only' : ''}`;
            messageContainer.dataset.messageId = message.id;
            
            if (message.sender === 'received') {
                // ==== 群聊支持 ====
                let character = characters.find(c => c.id === characterId);
                let isGroup = false;
                let group = null;
                if (!character) {
                    group = groupChats.find(g => g.id === characterId);
                    if (group) {
                        isGroup = true;
                    }
                }
                
                let displayAvatar = '';
                let displayName = '';
                let color = '#4CAF50';
                
                if (isGroup && group) {
                    // 群聊：根据消息的senderId或name查找成员
                    let member = null;
                    console.log('🔍 [addMessageWithAnimation] 群聊消息处理 - senderId:', message.senderId, 'name:', message.name);
                    console.log('🔍 [addMessageWithAnimation] 群成员列表:', group.members);
                    console.log('🔍 [addMessageWithAnimation] 完整消息对象:', message);

                    // 🔥【调试】特别检查表情包消息
                    if (message.isEmoji) {
                        console.log('🔍 [addMessageWithAnimation-表情包] 检测到表情包消息:', {
                            senderId: message.senderId,
                            name: message.name,
                            image: message.image,
                            emojiDescription: message.emojiDescription
                        });
                    }

                    if (message.senderId) {
                        member = group.members.find(m => m.id === message.senderId);
                        console.log('🔍 [addMessageWithAnimation] 通过senderId找到成员:', member);
                    } else if (message.name) {
                        member = group.members.find(m => m.name === message.name);
                        console.log('🔍 [addMessageWithAnimation] 通过name找到成员:', member);
                    }

                    // 🔥【修复】确保群聊表情包消息正确显示发送者（addMessageWithAnimation版本）
                    if (member) {
                        displayAvatar = member.avatarUrl || '';
                        displayName = member.name;
                        color = member.color || '#4CAF50';
                    } else {
                        // 如果没找到成员，使用消息中的name作为显示名称
                        displayAvatar = '';
                        displayName = message.name || '群成员';
                        color = '#4CAF50';
                        console.warn('🔍 [addMessageWithAnimation] 未找到群成员，使用消息name:', message.name);
                    }

                    console.log('🔍 [addMessageWithAnimation] 最终头像:', displayAvatar, '显示名:', displayName);
                } else if (character) {
                    // 单聊
                    displayAvatar = chatSettings.aiDynamicAvatar || chatSettings.aiChatAvatar || character.avatarUrl;
                    displayName = chatSettings.aiChatNickname || character.name;
                    color = character.color || '#4CAF50';
                } else {
                    // 兜底，防止报错
                    displayAvatar = '';
                    displayName = '未知';
                    color = '#4CAF50';
                }
                
                // 🔥【新增】获取气泡样式 - 群聊中使用成员专属颜色
                let bubbleColor = chatSettings.aiBubbleColor || '#f0f0f0';
                
                // 如果是群聊且有成员专属颜色设置，使用成员专属颜色
                if (isGroup && group && message.senderId && chatSettings.memberBubbleColors) {
                    const memberColor = chatSettings.memberBubbleColors[message.senderId];
                    if (memberColor) {
                        bubbleColor = memberColor;
                    }
                }
                
                const bubbleOpacity = chatSettings.aiBubbleOpacity || '1';
                const textColor = isLightColor(bubbleColor) ? '#333' : '#fff';
                const bubblePadding = chatSettings.bubblePadding || '12';
                
                // 处理特殊消息类型
                let messageContent = '';

                if (message.type === 'voice_message') {
                    // AI语音消息直接创建voice-message-container结构，不需要在这里创建messageContent
                    messageContent = '';
                } else if (message.type === 'user_photo') {
                    // 🔥【修复】角色发送的"伪照片" - 使用与用户相同的结构
                    const photoDesc = message.photoDescription || message.content || '角色发送的照片';
                    messageContent = `
                        <div class="dreamy-photo-container" onclick="togglePhotoText(this, '${photoDesc.replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')">
                            <div class="dreamy-photo">
                                <div class="photo-misty-bg"></div>
                                <div class="photo-badge">
                                    <i class="fas fa-image"></i>
                                </div>
                                <div class="sparkle-container">
                                    <div class="sparkle sparkle-1">✨</div>
                                    <div class="sparkle sparkle-2">⭐</div>
                                    <div class="sparkle sparkle-3">✨</div>
                                    <div class="sparkle sparkle-4">⭐</div>
                                    <div class="sparkle sparkle-5">💫</div>
                                </div>
                                <div class="photo-text-overlay" style="display: none;">
                                    <div class="photo-description">${photoDesc}</div>
                                </div>
                            </div>
                        </div>
                    `;
                } else if (message.type === 'ai_image') {
                    // AI生成的图片 - 使用星星emoji卡片样式
                    const imageDesc = message.imageDescription || message.content || 'AI描述的图片';
                    messageContent = `
                        <div class="dreamy-photo-container" onclick="togglePhotoText(this, '${imageDesc.replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')">
                            <div class="dreamy-photo">
                                <div class="photo-misty-bg"></div>
                                <div class="photo-badge">
                                    <i class="fas fa-image"></i>
                                </div>
                                <div class="sparkle-container">
                                    <div class="sparkle sparkle-1">✨</div>
                                    <div class="sparkle sparkle-2">⭐</div>
                                    <div class="sparkle sparkle-3">✨</div>
                                    <div class="sparkle sparkle-4">⭐</div>
                                    <div class="sparkle sparkle-5">💫</div>
                                </div>
                                <div class="photo-text-overlay" style="display: none;">
                                    <div class="photo-description">${imageDesc}</div>
                                </div>
                            </div>
                        </div>
                    `;
                } else if (message.type === 'location') {
                    // 🔥【修复】角色发送的位置消息 - 使用与用户相同的结构
                    const locationName = message.locationName || message.name || '未知位置';
                    messageContent = `
                        <div class="location-card" onclick="showLocationDetail('${locationName}')">
                            <div class="location-card-header">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
                                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                </svg>
                                ${locationName}
                            </div>
                            <div class="location-card-map">
                                <div class="map-background"></div>
                                <div class="map-roads">
                                    <div class="road road-horizontal" style="top: 35%; width: 100%;"></div>
                                    <div class="road road-vertical" style="left: 40%; height: 100%;"></div>
                                    <div class="road road-horizontal" style="top: 65%; width: 70%; left: 30%;"></div>
                                </div>
                                <div class="map-buildings">
                                    <div class="building" style="top: 20%; left: 10%; width: 15px; height: 15px;"></div>
                                    <div class="building" style="top: 45%; left: 60%; width: 12px; height: 12px;"></div>
                                    <div class="building" style="top: 70%; left: 15%; width: 18px; height: 18px;"></div>
                                </div>
                                <div class="map-marker" style="top: 50%; left: 50%;"></div>
                            </div>
                        </div>
                    `;
                } else if (message.type === 'transfer') {
                    // 转账消息
                    const isUser = message.role === 'user';
                    const heartIcon = isUser ? '💕' : '💖';
                    const titleText = isUser ? '你发起的转账' : '收到转账';
                    let cardClass = '';
                    let statusHtml = '';
                    let clickHandler = '';

                    if (message.status === 'accepted') {
                        statusHtml = `<div class="transfer-status">${isUser ? '对方已收款' : '已收款'}</div>`;
                        cardClass = 'accepted';
                    } else if (message.status === 'rejected') {
                        statusHtml = `<div class="transfer-status">${isUser ? '对方已退回' : '已退回'}</div>`;
                        cardClass = 'rejected';
                    } else if (!isUser) {
                        // AI发来的转账且未处理，添加点击处理
                        clickHandler = `onclick="showTransferConfirmDialog(${JSON.stringify(message).replace(/"/g, '&quot;')})"`;
                    }

                    messageContent = `
                        <div class="transfer-message-container received">
                            <div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}" ${clickHandler}>
                                <div class="transfer-title">${heartIcon} ${titleText}</div>
                                <div class="transfer-amount">¥ ${Number(message.amount).toFixed(2)}</div>
                                <div class="transfer-note">${message.note || '转账'}</div>
                                ${statusHtml}
                            </div>
                        </div>
                    `;
                } else if (message.type === 'friend_request') {
                    // 🔥【新增】AI主动发送的好友申请(第三处)
                    messageContent = `
                        <div class="friend-request-container">
                            <div class="friend-request-card">
                                <div class="friend-request-icon">👋</div>
                                <div class="friend-request-title">好友申请</div>
                                <div class="friend-request-message">${message.message || '想和你重新做朋友'}</div>
                                <div class="friend-request-actions">
                                    <button class="friend-request-btn accept" onclick="handleAIFriendRequest('${currentChatCharacter?.id}', true, '${message.id}')">同意</button>
                                    <button class="friend-request-btn reject" onclick="handleAIFriendRequest('${currentChatCharacter?.id}', false, '${message.id}')">拒绝</button>
                                </div>
                            </div>
                        </div>
                    `;
                } else {
                    const chatMode = chatSettings.chatMode || 'online';
                    let processedContent = message.content;
                    
                    if (chatMode === 'offline') {
                        processedContent = processOfflineContent(message.content);
                    }
                    
                    // 如果有引用消息，在内容前添加引用显示
                    if (message.replyTo) {
                        messageContent = generateReplyHTML(message.replyTo) + processedContent;
                    } else {
                    messageContent = processedContent;
                    }
                }
                
                let avatarHtml = '';
                if (!chatSettings.hideAvatars) {
                    avatarHtml = `
                        <div class="message-avatar" style="background-color: ${color}; ${displayAvatar ? `background-image: url(${displayAvatar}); background-size: cover; background-position: center;` : ''}" ${character ? `onclick="pokeCharacter('${character.id}')" title="戳一戳"` : `title="${displayName}"`}>
                            ${displayAvatar ? '' : displayName.charAt(0)}
                        </div>
                    `;
                }
                
                const transparentBubbleColor = convertColorWithOpacity(bubbleColor, bubbleOpacity);
                
                let bubbleHtml = '';
                if (message.type === 'transfer' || message.type === 'ai_image' || message.type === 'user_photo' || message.type === 'location' || message.type === 'voice_message' || message.type === 'friend_request') {
                    // 转账消息、AI图片消息、照片卡片、位置信息和语音消息不需要气泡包裹
                    bubbleHtml = messageContent;
                } else {
                    // 普通消息用气泡包裹
                    bubbleHtml = `
                    <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                        ${messageContent}
                        ${message.image && (!message.type || message.isEmoji) ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}
                        ${message.edited ? `<div class="message-edited-indicator">已编辑</div>` : ''}
                    </div>
                `;
                }
                
          // 🔥【修复】群聊昵称显示 （第三个渲染函数版本）- 特别处理语音消息、转账消息、照片卡片和位置信息
          if (isGroup && group && displayName !== '群成员') {
    messageContainer.classList.add('group-message-item');
    const senderNameHtml = `<div class="sender-name">${displayName}</div>`;

    if (message.type === 'voice_message' || message.type === 'transfer' || message.type === 'ai_image' || message.type === 'user_photo' || message.type === 'location' || message.type === 'friend_request') {
        // 🔥【修复】对于语音消息、转账消息、AI图片消息、照片卡片和位置信息，昵称需要在容器外部
    messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    } else {
        // 普通消息的处理（包括表情包消息）
        messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    }
} else {
                messageContainer.innerHTML = avatarHtml + bubbleHtml;
}
                
                // 🔥【修复】如果是语音消息，按照renderChatMessages的结构创建，但要保留群聊昵称
                if (message.type === 'voice_message') {
                    // 过滤掉括号中的描述性内容，保留实际说话内容
                    const cleanVoiceContent = message.content.replace(/\([^)]*\)\s*/g, '').trim();
                    const duration = message.duration || Math.max(1, Math.ceil(cleanVoiceContent.length / 8));
                    const durationFormatted = duration < 60 ? `0:${String(duration).padStart(2, '0')}''` : `${Math.floor(duration/60)}:${String(duration%60).padStart(2, '0')}''`;
                    
                    const voiceMessageHTML = `
                        <div class="voice-message-container received">
                            <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                                <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${cleanVoiceContent}">
                                    <div class="voice-wave">
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                    </div>
                                    <div class="voice-duration">${durationFormatted}</div>
                                    ${message.edited ? `<div class="message-edited-indicator">已编辑</div>` : ""}
                                </div>
                            </div>
                            <div class="voice-text-content">${cleanVoiceContent}</div>
                        </div>
                    `;
                    
                    // 🔥【修复】保留群聊昵称显示
                    if (isGroup && group && displayName !== '群成员') {
                        const senderNameHtml = `<div class="sender-name">${displayName}</div>`;
                        messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${voiceMessageHTML}</div>`;
                    } else {
                    messageContainer.innerHTML = avatarHtml + voiceMessageHTML;
                    }
                }
            } else {
                // 用户消息
                let myDisplayAvatar = chatSettings.myChatAvatar;
                
                if (!myDisplayAvatar && chatSettings.selectedIdentityId) {
                    const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                    if (selectedPersona && selectedPersona.avatarUrl) {
                        myDisplayAvatar = selectedPersona.avatarUrl;
                    }
                }
                
                const myBubbleColor = chatSettings.myBubbleColor || '#007AFF';
                const myBubbleOpacity = chatSettings.myBubbleOpacity || '1';
                const myTextColor = isLightColor(myBubbleColor) ? '#333' : '#fff';
                const myBubblePadding = chatSettings.bubblePadding || '12';
                
                const transparentMyBubbleColor = convertColorWithOpacity(myBubbleColor, myBubbleOpacity);
                
                let myBubbleHtml = '';
                if (message.type === 'voice') {
                    const duration = message.duration || Math.max(1, Math.ceil(message.content.length / 8));
                    
                    myBubbleHtml = `
                        <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                            <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${message.content}">
                                <div class="voice-wave">
                                    <div class="wave-bar"></div>
                                    <div class="wave-bar"></div>
                                    <div class="wave-bar"></div>
                                    <div class="wave-bar"></div>
                                    <div class="wave-bar"></div>
                                </div>
                                <div class="voice-duration">${duration}"</div>
                            ${message.edited ? `<div class="message-edited-indicator">已编辑</div>` : ""}
                            </div>
                        </div>
                    `;
                } else if (message.type === 'location') {
                    // 位置消息
                    myBubbleHtml = `
                        <div class="location-card" onclick="showLocationDetail('${message.locationName}')">
                            <div class="location-title">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
                                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                </svg>
                                ${message.locationName}
                            </div>
                            <div class="location-card-map">
                                ${generateRealisticMapHTML()}
                            </div>
                        </div>
                    `;
                } else if (message.type === 'transfer') {
                    // 用户转账消息
                    let cardClass = '';
                    let statusHtml = '';
                    
                    if (message.status === 'accepted') {
                        statusHtml = `<div class="transfer-status">对方已收款</div>`;
                        cardClass = 'accepted';
                    } else if (message.status === 'rejected') {
                        statusHtml = `<div class="transfer-status">对方已退回</div>`;
                        cardClass = 'rejected';
                    }
                    
                    myBubbleHtml = `
                        <div class="transfer-message-container sent">
                            <div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}">
                                <div class="transfer-title">💕 你发起的转账</div>
                                <div class="transfer-amount">¥ ${Number(message.amount).toFixed(2)}</div>
                                <div class="transfer-note">${message.note || '转账'}</div>
                                ${statusHtml}
                            </div>
                        </div>
                    `;
                } else if (message.type === 'friend_request') {
                    // 🔥【新增】用户发送的好友申请(离线模式)
                    myBubbleHtml = `
                        <div class="friend-request-container">
                            <div class="friend-request-card">
                                <div class="friend-request-icon">👋</div>
                                <div class="friend-request-title">好友申请</div>
                                <div class="friend-request-message">${message.message || '想和你重新做朋友'}</div>
                                <div class="friend-request-status">已发送</div>
                            </div>
                        </div>
                    `;
                } else {
                    // 🔥【修复】处理多模态消息或普通文本消息 (第三个渲染函数版本)
                    let messageContentStr = '';
                    if (Array.isArray(message.content)) {
                        // 新的多模态格式
                        const textPart = message.content.find(p => p.type === 'text');
                        const imagePart = message.content.find(p => p.type === 'image_url');

                        let baseContent = textPart?.text || '';

                        // 如果有引用消息，在内容前添加引用显示
                        if (message.replyTo) {
                            messageContentStr = generateReplyHTML(message.replyTo) + baseContent;
                        } else {
                            messageContentStr = baseContent;
                        }

                        // 如果有图片，添加图片显示
                        if (imagePart?.image_url?.url) {
                            if (messageContentStr) {
                                messageContentStr += '<br>';
                            }
                            messageContentStr += `<img src="${imagePart.image_url.url}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${imagePart.image_url.url}')">`;
                        }
                    } else {
                        // 普通文本消息或旧格式
                        let baseContent = message.content;

                        // 如果有引用消息，在内容前添加引用显示
                        if (message.replyTo) {
                            messageContentStr = generateReplyHTML(message.replyTo) + baseContent;
                        } else {
                            messageContentStr = baseContent;
                        }
                    }
                    
                    myBubbleHtml = `
                    <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                        ${messageContentStr}
                        ${message.image && !Array.isArray(message.content) ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}
                    </div>
                `;
                }
                
                let myAvatarHtml = '';
                if (!chatSettings.hideAvatars) {
                    myAvatarHtml = `
                        <div class="message-avatar" style="background-color: #007AFF; ${myDisplayAvatar ? `background-image: url(${myDisplayAvatar}); background-size: cover; background-position: center;` : ''}">
                            ${myDisplayAvatar ? '' : '<i class="fas fa-user"></i>'}
                        </div>
                    `;
                }
                
                messageContainer.innerHTML = myBubbleHtml + myAvatarHtml;
                
                // 如果是语音消息，按照renderChatMessages的结构创建
                if (message.type === 'voice') {
                    // 创建完整的语音消息HTML，和renderChatMessages保持一致
                    const voiceMessageHTML = `
                        <div class="voice-message-container sent">
                            <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                                <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${message.content}">
                                    <div class="voice-wave">
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                    </div>
                                    <div class="voice-duration">${message.duration || Math.max(1, Math.ceil(message.content.length / 8))}"</div>
                                    ${message.edited ? `<div class="message-edited-indicator">已编辑</div>` : ""}
                                </div>
                            </div>
                            <div class="voice-text-content">${message.content}</div>
                        </div>
                    `;
                    
                    messageContainer.innerHTML = voiceMessageHTML + myAvatarHtml;
                }
                
                // 如果是位置消息，按照renderChatMessages的结构创建
                if (message.type === 'location') {
                    // 创建完整的位置消息HTML，确保不被包装在气泡中
                    const locationMessageHTML = `
                        <div class="location-card" onclick="showLocationDetail('${message.locationName}')">
                            <div class="location-title">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
                                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                </svg>
                                ${message.locationName}
                            </div>
                            <div class="location-card-map">
                                ${generateRealisticMapHTML()}
                            </div>
                        </div>
                    `;
                    
                    messageContainer.innerHTML = locationMessageHTML + myAvatarHtml;
                }
            }
            
            // 添加滑入动画效果 - 简单自然的滑入
            messageContainer.style.opacity = '0';
            messageContainer.style.transform = 'translateY(20px)';
            
            messagesContainer.insertBefore(messageContainer, typingIndicator);
            
            // 触发滑入动画
            requestAnimationFrame(() => {
                messageContainer.classList.add('message-slide-in');
            });
            
            // 🔥【新增】检查拉黑状态并添加指示器
            addBlockedIndicatorToMessage(messageContainer, message, characterId);

            // 添加长按监听器
            addMessageLongPressListener(messageContainer, message.id);

            // 添加右键菜单功能
            const bubble = messageContainer.querySelector('.message-bubble');
            if (bubble) {
                bubble.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showMessageMenu(message.id, e);
                });

                bubble.onclick = (e) => {
                    if (e.target.tagName === 'IMG' && e.target.classList.contains('message-image')) {
                        showImage(e.target.src);
                    }
                };
            }
            
            // 🔥【新增】如果是AI消息，调整心率
            if (message.sender === 'received' && typeof message.content === 'string') {
                adjustHeartrateForMessage(message.content, false);
            }
            
            // 滚动到底部
            setTimeout(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }, 100);
        }
        
        // 将颜色和透明度转换为rgba格式
        function convertColorWithOpacity(color, opacity) {
            // 检查参数有效性
            if (!color || typeof color !== 'string') {
                return 'rgba(0, 0, 0, 0)'; // 返回透明黑色作为默认值
            }

            // 如果颜色已经是rgba格式，直接返回
            if (color.startsWith('rgba')) {
                return color;
            }
            
            // 如果是十六进制颜色，转换为rgba
            if (color.startsWith('#')) {
                const hex = color.slice(1);
                const r = parseInt(hex.substring(0, 2), 16);
                const g = parseInt(hex.substring(2, 4), 16);
                const b = parseInt(hex.substring(4, 6), 16);
                return `rgba(${r}, ${g}, ${b}, ${opacity})`;
            }
            
            // 如果是rgb格式，转换为rgba
            if (color.startsWith('rgb(')) {
                const rgbValues = color.match(/\d+/g);
                return `rgba(${rgbValues[0]}, ${rgbValues[1]}, ${rgbValues[2]}, ${opacity})`;
            }
            
            // 如果是颜色名称，尝试转换（简单实现）
            const colorMap = {
                'red': '255, 0, 0',
                'green': '0, 128, 0',
                'blue': '0, 0, 255',
                'white': '255, 255, 255',
                'black': '0, 0, 0',
                'gray': '128, 128, 128',
                'yellow': '255, 255, 0',
                'cyan': '0, 255, 255',
                'magenta': '255, 0, 255'
            };
            
            if (colorMap[color.toLowerCase()]) {
                return `rgba(${colorMap[color.toLowerCase()]}, ${opacity})`;
            }
            
            // 如果无法识别，返回原色加透明度（作为备用）
            return color;
        }

        // 字体大小设置功能
        function changeFontSize(size) {
            const fontSize = parseInt(size);
            
            // 更新预览文字
            const preview = document.getElementById('font-size-preview');
            const valueDisplay = document.getElementById('font-size-value');
            
            if (preview) {
                preview.style.fontSize = fontSize + 'px';
            }
            
            if (valueDisplay) {
                valueDisplay.textContent = fontSize + 'px';
            }
            
            // 创建或更新全局字体大小CSS变量
            document.documentElement.style.setProperty('--global-font-size', fontSize + 'px');
            
            // 应用到聊天消息
            applyFontSizeToMessages(fontSize);
            
            // 应用到社交动态
            applyFontSizeToMoments(fontSize);
            
            // 如果当前有聊天角色，重新渲染消息以确保新字体大小生效
            if (currentChatCharacter && typeof renderChatMessages === 'function') {
                setTimeout(() => {
                    renderChatMessages(currentChatCharacter.id);
                }, 100);
            }
            
            // 保存设置
            localStorage.setItem('globalFontSize', fontSize);
            
            // 显示成功提示
            showToast('字号设置已保存并应用！', 'success');
        }
        
        // 字距设置功能
        function changeLetterSpacing(spacing) {
            const letterSpacing = parseFloat(spacing);
            
            // 更新预览文字
            const preview = document.getElementById('font-size-preview');
            const valueDisplay = document.getElementById('letter-spacing-value');
            
            if (preview) {
                preview.style.letterSpacing = letterSpacing + 'px';
            }
            
            if (valueDisplay) {
                // 根据数值显示对应的文字描述
                let description;
                if (letterSpacing < -0.2) {
                    description = '很紧凑';
                } else if (letterSpacing < 0.2) {
                    description = '标准';
                } else if (letterSpacing < 0.8) {
                    description = '舒适';
                } else if (letterSpacing < 1.5) {
                    description = '宽松';
                } else {
                    description = '很宽松';
                }
                valueDisplay.textContent = `${description} (${letterSpacing}px)`;
            }
            
            // 创建或更新全局字距CSS变量
            document.documentElement.style.setProperty('--global-letter-spacing', letterSpacing + 'px');
            
            // 应用到聊天消息
            applyLetterSpacingToMessages(letterSpacing);
            
            // 应用到社交动态
            applyLetterSpacingToMoments(letterSpacing);
            
            // 如果当前有聊天角色，重新渲染消息以确保新字距生效
            if (currentChatCharacter && typeof renderChatMessages === 'function') {
                setTimeout(() => {
                    renderChatMessages(currentChatCharacter.id);
                }, 100);
            }
            
            // 保存设置
            localStorage.setItem('globalLetterSpacing', letterSpacing);
            
            // 显示成功提示
            showToast('字距设置已保存并应用！', 'success');
        }
        
        function applyFontSizeToMessages(fontSize) {
            // 应用到所有聊天消息，使用!important强制覆盖内联样式
            const messageBubbles = document.querySelectorAll('.message-bubble');
            messageBubbles.forEach(bubble => {
                bubble.style.setProperty('font-size', fontSize + 'px', 'important');
            });
            
            // 应用到聊天输入框
            const chatInput = document.getElementById('api-chat-input');
            if (chatInput) {
                chatInput.style.fontSize = fontSize + 'px';
            }
        }
        
        function applyFontSizeToMoments(fontSize) {
            // 应用到微博动态内容
            const postContents = document.querySelectorAll('.post-content');
            postContents.forEach(content => {
                content.style.fontSize = fontSize + 'px';
            });
            
            // 应用到微博输入框
            const weiboTextarea = document.getElementById('weibo-text');
            if (weiboTextarea) {
                weiboTextarea.style.fontSize = fontSize + 'px';
            }
        }
        
        function applyLetterSpacingToMessages(letterSpacing) {
            // 应用到所有聊天消息
            const messageBubbles = document.querySelectorAll('.message-bubble');
            messageBubbles.forEach(bubble => {
                bubble.style.setProperty('letter-spacing', letterSpacing + 'px', 'important');
            });
            
            // 应用到聊天输入框
            const chatInput = document.getElementById('api-chat-input');
            if (chatInput) {
                chatInput.style.letterSpacing = letterSpacing + 'px';
            }
        }
        
        function applyLetterSpacingToMoments(letterSpacing) {
            // 应用到微博动态内容
            const postContents = document.querySelectorAll('.post-content');
            postContents.forEach(content => {
                content.style.letterSpacing = letterSpacing + 'px';
            });
            
            // 应用到微博输入框
            const weiboTextarea = document.getElementById('weibo-text');
            if (weiboTextarea) {
                weiboTextarea.style.letterSpacing = letterSpacing + 'px';
            }
        }
        
        function toggleAutoScale() {
            const toggle = document.getElementById('auto-scale-toggle');
            const isEnabled = toggle.checked;
            
            // 保存自动缩放设置
            localStorage.setItem('autoScaleFont', isEnabled);
            
            if (isEnabled) {
                // 根据屏幕尺寸自动调整字体
                autoAdjustFontSize();
                showToast('字体自动缩放已开启！', 'success');
            } else {
                showToast('字体自动缩放已关闭！', 'success');
            }
        }
        
        function autoAdjustFontSize() {
            const phoneScreen = document.getElementById('phone-screen');
            if (!phoneScreen) return;
            
            const screenWidth = parseInt(phoneScreen.style.width) || 350;
            
            // 根据屏幕宽度计算推荐字体大小
            let recommendedSize = 15; // 默认大小
            
            if (screenWidth <= 320) {
                recommendedSize = 13; // 小屏幕用小字体
            } else if (screenWidth <= 350) {
                recommendedSize = 14;
            } else if (screenWidth <= 375) {
                recommendedSize = 15;
            } else if (screenWidth <= 390) {
                recommendedSize = 16;
            } else {
                recommendedSize = 17; // 大屏幕用大字体
            }
            
            // 更新滑块和应用字体大小
            const slider = document.getElementById('font-size-slider');
            if (slider) {
                slider.value = recommendedSize;
                changeFontSize(recommendedSize);
            }
        }
        
        function loadFontSizeSettings() {
            // 加载字体大小设置
            const savedSize = localStorage.getItem('globalFontSize');
            const fontSize = savedSize ? parseInt(savedSize) : 15;
            
            const slider = document.getElementById('font-size-slider');
            const preview = document.getElementById('font-size-preview');
            const valueDisplay = document.getElementById('font-size-value');
            
            if (slider) {
                slider.value = fontSize;
            }
            
            if (preview) {
                preview.style.fontSize = fontSize + 'px';
            }
            
            if (valueDisplay) {
                valueDisplay.textContent = fontSize + 'px';
            }
            
            // 应用字体大小
            document.documentElement.style.setProperty('--global-font-size', fontSize + 'px');
            
            // 加载字距设置
            const savedSpacing = localStorage.getItem('globalLetterSpacing');
            const letterSpacing = savedSpacing ? parseFloat(savedSpacing) : 0;
            
            const spacingSlider = document.getElementById('letter-spacing-slider');
            const spacingValueDisplay = document.getElementById('letter-spacing-value');
            
            if (spacingSlider) {
                spacingSlider.value = letterSpacing;
            }
            
            if (preview) {
                preview.style.letterSpacing = letterSpacing + 'px';
            }
            
            if (spacingValueDisplay) {
                // 根据数值显示对应的文字描述
                let description;
                if (letterSpacing < -0.2) {
                    description = '很紧凑';
                } else if (letterSpacing < 0.2) {
                    description = '标准';
                } else if (letterSpacing < 0.8) {
                    description = '舒适';
                } else if (letterSpacing < 1.5) {
                    description = '宽松';
                } else {
                    description = '很宽松';
                }
                spacingValueDisplay.textContent = `${description} (${letterSpacing}px)`;
            }
            
            // 应用字距
            document.documentElement.style.setProperty('--global-letter-spacing', letterSpacing + 'px');
            
            // 延迟应用，确保DOM元素已经加载
            setTimeout(() => {
                applyFontSizeToMessages(fontSize);
                applyFontSizeToMoments(fontSize);
                applyLetterSpacingToMessages(letterSpacing);
                applyLetterSpacingToMoments(letterSpacing);
            }, 500);
            
            // 加载自动缩放设置
            const autoScale = localStorage.getItem('autoScaleFont');
            const autoScaleToggle = document.getElementById('auto-scale-toggle');
            if (autoScaleToggle) {
                autoScaleToggle.checked = autoScale === 'true';
            }
        }



        // 工具栏功能
        function triggerVoiceMessage() {
            showToast('语音功能开发中...', 'info');
            // 这里可以添加语音录制功能
        }

        // 聊天界面拍照功能 - 文字描述图片发送给AI
        async function openCamera() {
            if (!currentChatCharacter) {
                showToast('请先选择一个聊天对象', 'error');
                return;
            }
            
            const description = await showCustomPrompt("发送照片", "请用文字描述您要发送的照片：");
            if (description && description.trim()) {
                const msg = {
                    id: Date.now().toString(),
                    sender: 'sent',
                    type: 'user_photo',
                    content: description.trim(),
                    timestamp: Date.now(),
                    photoDescription: description.trim() // 保存原始描述用于点击查看
                };
                
                // 添加到聊天记录
                if (!chatMessages[currentChatCharacter.id]) {
                    chatMessages[currentChatCharacter.id] = [];
                }
                chatMessages[currentChatCharacter.id].push(msg);
                await saveChatMessages();
                
                // 刷新界面
                renderChatMessages(currentChatCharacter.id);
                renderMessageList();
                
                showToast('照片已发送', 'success');
            }
        }

        function openTransfer() {
            // 检查是否有当前聊天角色
            if (!currentChatCharacter) {
                showToast('请先选择聊天对象', 'warning');
                return;
            }
            
            // 显示转账对话框
            document.getElementById('transfer-modal').classList.add('visible');
        }

        // 通话状态变量
        let isInCall = false;
        let callTimer = null;
        let callStartTime = null;
        let callDuration = 0;
        let isMuted = false;
        let isSpeakerOn = false;
        let currentCallCharacter = null;
        
        // 生成消息ID函数
        function generateMessageId() {
            return Date.now().toString() + Math.floor(Math.random() * 1000).toString();
        }
        
        // 添加消息到聊天记录
        function addMessageToChat(message) {
            if (!currentChatCharacter) return;
            
            const characterId = currentChatCharacter.id;
            if (!chatMessages[characterId]) {
                chatMessages[characterId] = [];
            }
            
            chatMessages[characterId].push(message);
            saveChatMessages();
            
            // 更新聊天界面
            renderChatMessages(characterId);
        }

        function makeCall() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'error');
                return;
            }
            
            // 检查角色主动拨打电话开关，用户主动拨打时不受此限制
            const currentChatSettings = getCurrentChatSettings();
            console.log('📞 用户主动拨打电话，开关状态:', currentChatSettings.aiCallEnabled);
            
            currentCallCharacter = currentChatCharacter;
            
            // 设置通话界面
            const avatarSrc = currentCallCharacter.avatar || currentCallCharacter.avatarUrl || 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="50" fill="lightgray"/><text x="50" y="60" font-size="30" text-anchor="middle" fill="gray">头像</text></svg>';
            document.getElementById('call-avatar-img').src = avatarSrc;
            document.getElementById('call-name').textContent = currentCallCharacter.name;
            document.getElementById('call-status').textContent = '正在通话中...';
            document.getElementById('call-timer').textContent = '00:00';
            
            // 清空通话消息容器
            document.getElementById('call-message-container').innerHTML = '';
            
            // 显示通话界面
            showApp('phone-call-screen');
            
            // 开始计时
            startCallTimer();
            
            // 设置通话状态
            isInCall = true;
            
            // 发送系统消息到聊天记录
            const callStartMessage = {
                id: generateMessageId(),
                sender: 'system',
                content: `[语音通话] 与${currentCallCharacter.name}的通话已开始`,
                timestamp: Date.now(),
                type: 'call_record',
                callType: 'outgoing',
                callStatus: 'started'
            };
            
            addMessageToChat(callStartMessage);
            
            // 用户主动拨打电话时不自动添加角色回应，等待用户先说话
            // 设置标志，表明这是用户主动拨打的电话
            window.isUserInitiatedCall = true;
        }
        
        // 角色主动拨打电话
        async function initiateAICall(character, callReason) {
            if (isInCall) return; // 如果已经在通话中，不再发起
            
            currentCallCharacter = character;
            
            // 🔥【恢复】先生成角色的开场白，再显示来电界面
            let characterGreeting = '';
            try {
                const prompt = `你是${character.name}，刚刚决定给用户打电话。

请生成一句简短自然的开场白，说明你为什么要打这个电话：
- 要符合你的性格特点
- 像真实通话开始时的自然表达
- 1句话即可，不要超过20字
- 直接说话，不要任何格式标记

例如：
- "我想和你聊聊今天的事情"
- "有个好消息想告诉你"
- "想听听你的声音"

请只回复开场白内容：`;

                const response = await callChatAPI(prompt, character);
                
                // 🔥【关键修复】使用parseAiResponse解析开场白
                const parsedMessages = parseAiResponse(response);
                console.log('🔔 开场白AI回复解析结果:', parsedMessages);
                
                if (Array.isArray(parsedMessages) && parsedMessages.length > 0) {
                    // 找到第一条纯文本消息
                    const firstTextMessage = parsedMessages.find(msg => typeof msg === 'string');
                    if (firstTextMessage) {
                        characterGreeting = firstTextMessage.trim();
                    } else {
                        // 如果没有纯文本，尝试提取对象中的内容
                        const firstMessage = parsedMessages[0];
                        if (typeof firstMessage === 'object' && firstMessage.content) {
                            characterGreeting = firstMessage.content.trim();
                        }
                    }
                } else if (typeof response === 'string') {
                    // 备用：如果解析失败，清理原始字符串
                    characterGreeting = cleanCallResponse(response).trim();
                }
                
                if (!characterGreeting || characterGreeting.length > 30) {
                    characterGreeting = callReason || '想和你通话...';
                }
            } catch (error) {
                console.error('生成角色开场白失败:', error);
                characterGreeting = callReason || '想和你通话...';
            }
            
            // 设置来电显示界面
            const avatarSrc = character.avatar || character.avatarUrl || 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="50" fill="lightgray"/><text x="50" y="60" font-size="30" text-anchor="middle" fill="gray">头像</text></svg>';
            document.getElementById('incoming-call-avatar').src = avatarSrc;
            document.getElementById('incoming-call-name').textContent = character.name;
            document.getElementById('incoming-call-text').textContent = characterGreeting;
            
            // 🔥【保存开场白供接听后使用】
            window.aiCallGreeting = characterGreeting;
            
            // 添加振铃动画
            document.getElementById('incoming-call-avatar').classList.add('ringing-animation');
            
            // 显示来电界面
            showApp('incoming-call-screen');
            
            // 播放来电铃声（如果需要）
            // playRingtone();
            
            // 发送系统消息到聊天记录
            const incomingCallMessage = {
                id: generateMessageId(),
                sender: 'system',
                content: `[语音通话] ${character.name}正在呼叫你`,
                timestamp: Date.now(),
                type: 'call_record',
                callType: 'incoming',
                callStatus: 'ringing'
            };
            
            addMessageToChat(incomingCallMessage);
            
            // 如果30秒内没有接听，自动挂断
            setTimeout(() => {
                if (document.getElementById('incoming-call-screen').style.display !== 'none') {
                    rejectCall();
                }
            }, 30000);
        }
        
        // 接受来电
        function acceptCall() {
            // 停止振铃动画
            document.getElementById('incoming-call-avatar').classList.remove('ringing-animation');
            
            // 隐藏来电界面
            hideApp('incoming-call-screen');
            
            // 设置通话界面
            const avatarSrc = currentCallCharacter.avatar || currentCallCharacter.avatarUrl || 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="50" fill="lightgray"/><text x="50" y="60" font-size="30" text-anchor="middle" fill="gray">头像</text></svg>';
            document.getElementById('call-avatar-img').src = avatarSrc;
            document.getElementById('call-name').textContent = currentCallCharacter.name;
            document.getElementById('call-status').textContent = '正在通话中...';
            document.getElementById('call-timer').textContent = '00:00';
            
            // 清空通话消息容器
            document.getElementById('call-message-container').innerHTML = '';
            
            // 显示通话界面
            showApp('phone-call-screen');
            
            // 开始计时
            startCallTimer();
            
            // 设置通话状态
            isInCall = true;
            
            // 发送系统消息到聊天记录
            const callAcceptedMessage = {
                id: generateMessageId(),
                sender: 'system',
                content: `[语音通话] 已接听${currentCallCharacter.name}的来电`,
                timestamp: Date.now(),
                type: 'call_record',
                callType: 'incoming',
                callStatus: 'accepted'
            };
            
            addMessageToChat(callAcceptedMessage);
            
            // 🔥【修复】使用AI生成的开场白或默认问候
            setTimeout(() => {
                let initialResponse = window.aiCallGreeting || getRandomCallGreeting(currentCallCharacter.name);
                addCallMessage(initialResponse, 'received');
                // 清理开场白缓存
                window.aiCallGreeting = null;
            }, 1000);
        }
        
        // 拒绝来电
        function rejectCall() {
            // 停止振铃动画
            document.getElementById('incoming-call-avatar').classList.remove('ringing-animation');
            
            // 隐藏来电界面
            hideApp('incoming-call-screen');
            
            // 发送系统消息到聊天记录
            const callRejectedMessage = {
                id: generateMessageId(),
                sender: 'system',
                content: `[语音通话] 已拒绝${currentCallCharacter.name}的来电`,
                timestamp: Date.now(),
                type: 'call_record',
                callType: 'incoming',
                callStatus: 'rejected'
            };
            
            addMessageToChat(callRejectedMessage);
            
            currentCallCharacter = null;
        }
        
        // 结束通话
        function endCall() {
            if (!isInCall) return;
            
            // 停止计时
            stopCallTimer();
            
            // 隐藏通话界面
            hideApp('phone-call-screen');
            
            // 返回聊天界面
            showApp('api-chat-screen');
            
            // 发送系统消息到聊天记录
            const formattedDuration = formatCallDuration(callDuration);
            const callEndedMessage = {
                id: generateMessageId(),
                sender: 'system',
                content: `[语音通话] 与${currentCallCharacter.name}的通话已结束`,
                timestamp: Date.now(),
                type: 'call_record',
                callType: 'ended',
                callStatus: 'completed',
                duration: formattedDuration
            };
            
            addMessageToChat(callEndedMessage);
            
            // 重置通话状态
            isInCall = false;
            isMuted = false;
            isSpeakerOn = false;
            
            currentCallCharacter = null;
        }
        
        // 静音/取消静音
        function toggleMute() {
            isMuted = !isMuted;
            const muteBtn = document.getElementById('mute-btn');
            
            if (isMuted) {
                muteBtn.classList.add('muted');
                muteBtn.innerHTML = '<i class="fas fa-microphone-slash"></i>';
                showToast('已静音', 'info');
            } else {
                muteBtn.classList.remove('muted');
                muteBtn.innerHTML = '<i class="fas fa-microphone"></i>';
                showToast('已取消静音', 'info');
            }
        }
        
        // 扬声器开关
        function toggleSpeaker() {
            isSpeakerOn = !isSpeakerOn;
            const speakerBtn = document.getElementById('speaker-btn');
            
            if (isSpeakerOn) {
                speakerBtn.classList.add('active');
                showToast('已开启扬声器', 'info');
            } else {
                speakerBtn.classList.remove('active');
                showToast('已关闭扬声器', 'info');
            }
        }
        
        // 开始通话计时器
        function startCallTimer() {
            callStartTime = new Date();
            callDuration = 0;
            
            callTimer = setInterval(() => {
                callDuration = Math.floor((new Date() - callStartTime) / 1000);
                document.getElementById('call-timer').textContent = formatCallDuration(callDuration);
            }, 1000);
        }
        
        // 停止通话计时器
        function stopCallTimer() {
            if (callTimer) {
                clearInterval(callTimer);
                callTimer = null;
            }
        }
        
        // 格式化通话时长
        function formatCallDuration(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }
        
        // 在通话界面发送消息
        function sendCallMessage() {
            const input = document.getElementById('call-input');
            if (!input) {
                console.error('找不到通话输入框元素');
                return;
            }
            
            const message = input.value.trim();
            
            if (!message) return;
            
            // 添加用户消息到通话界面
            addCallMessage(message, 'sent');
            
            // 清空输入框
            input.value = '';
            
            // 显示AI正在说话的指示器
            const typingIndicator = showCallTypingIndicator();
            
            // 根据通话类型决定是否回复
            if (currentCallCharacter) {
                setTimeout(async () => {
                    try {
                        // 🔥【修复】构建更好的语音通话提示词
                        const prompt = `你是${currentCallCharacter.name}，正在与用户进行语音通话。
用户刚说："${message}"

请用简短自然的口语方式回复，就像真实的电话对话一样：
- 直接说话，不要任何描述性文字
- 保持自然的语音对话风格
- 回复要简洁，1-2句话即可
- 符合你的性格设定

请只回复对话内容，不要JSON格式，不要其他格式：`;
                        
                        try {
                            const response = await callChatAPI(prompt, currentCallCharacter);
                            
                            // 移除输入指示器
                            hideCallTypingIndicator(typingIndicator);
                            
                            // 🔥【关键修复】使用parseAiResponse解析回复，显示所有文本消息
                            const parsedMessages = parseAiResponse(response);
                            console.log('🔔 通话AI回复解析结果:', parsedMessages);
                            
                            let hasValidMessage = false;
                            if (Array.isArray(parsedMessages) && parsedMessages.length > 0) {
                                // 遍历所有消息，显示每一条文本消息
                                for (const msg of parsedMessages) {
                                    let replyText = '';
                                    if (typeof msg === 'string') {
                                        replyText = msg.trim();
                                    } else if (typeof msg === 'object' && msg.content) {
                                        replyText = msg.content.trim();
                                    }
                                    
                                    if (replyText) {
                                        addCallMessage(replyText, 'received');
                                        hasValidMessage = true;
                                        // 添加短暂延迟，让多条消息分开显示
                                        await new Promise(resolve => setTimeout(resolve, 300));
                                    }
                                }
                            }
                            
                            // 如果没有有效消息，使用备用回复
                            if (!hasValidMessage) {
                                if (typeof response === 'string') {
                                    const cleanedText = cleanCallResponse(response);
                                    if (cleanedText) {
                                        addCallMessage(cleanedText, 'received');
                                    } else {
                                        addCallMessage(getRandomCallResponse(), 'received');
                                    }
                                } else {
                                    addCallMessage(getRandomCallResponse(), 'received');
                                }
                            }
                            
                        } catch (error) {
                            console.error('获取AI回复失败:', error);
                            hideCallTypingIndicator(typingIndicator);
                            addCallMessage(getRandomCallResponse(), 'received');
                        }
                        
                    } catch (error) {
                        console.error('通话回复错误:', error);
                        hideCallTypingIndicator(typingIndicator);
                        addCallMessage('我明白了', 'received');
                    }
                }, 1000 + Math.random() * 1000);
            }
        }
        
        // 添加消息到通话界面
        function addCallMessage(message, type) {
            const container = document.getElementById('call-message-container');
            const messageElement = document.createElement('div');
            messageElement.className = `call-message ${type}`;
            messageElement.textContent = message;
            
            container.appendChild(messageElement);
            container.scrollTop = container.scrollHeight;
            
            // 🔥【修复】同时添加到聊天记录，但标记为通话消息
            if (currentChatCharacter && currentChatCharacter.id) {
                const callMessage = {
                    id: generateMessageId(),
                    sender: type === 'sent' ? 'sent' : 'received',  // 修复：使用正确的sender格式
                    content: message,
                    timestamp: Date.now(),
                    isCallMessage: true,
                    type: 'call_message'  // 添加特殊类型标记
                };
                
                if (!chatMessages[currentChatCharacter.id]) {
                    chatMessages[currentChatCharacter.id] = [];
                }
                
                chatMessages[currentChatCharacter.id].push(callMessage);
                saveChatMessages();
            }
        }

        // 🔥【新增】显示AI正在说话的指示器
        function showCallTypingIndicator() {
            const container = document.getElementById('call-message-container');
            const typingIndicator = document.createElement('div');
            typingIndicator.className = 'call-typing-indicator';
            typingIndicator.innerHTML = `
                <div class="call-typing-dots">
                    <div class="call-typing-dot"></div>
                    <div class="call-typing-dot"></div>
                    <div class="call-typing-dot"></div>
                </div>
            `;
            
            container.appendChild(typingIndicator);
            container.scrollTop = container.scrollHeight;
            
            return typingIndicator;
        }

        // 🔥【新增】隐藏AI正在说话的指示器
        function hideCallTypingIndicator(indicator) {
            if (indicator && indicator.parentNode) {
                indicator.parentNode.removeChild(indicator);
            }
        }

        // 🔥【简化】清理通话回复文本 - 因为已经用parseAiResponse处理JSON格式
        function cleanCallResponse(text) {
            if (!text) return '';
            
            console.log('🧹 原始文本:', text);
            
            // 基础清理：移除多余空格和换行
            text = text.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
            
            // 移除常见的描述性前缀
            text = text.replace(/^(角色说|我说|回复|答案|回答)[:：]\s*/i, '');
            
            // 移除括号中的描述性内容
            text = text.replace(/\([^)]*\)/g, '');
            text = text.replace(/【[^】]*】/g, '');
            text = text.replace(/\[[^\]]*\]/g, '');
            
            // 如果文本以标点符号开头，移除它
            text = text.replace(/^[，。！？；：,.!?;:\s]*/, '');
            
            console.log('🧹 清理后文本:', text);
            
            // 验证清理结果
            if (!text || text.length < 2) {
                console.log('🧹 文本无效，使用备用回复');
                return getRandomCallResponse();
            }
            
            // 如果文本太长，截取前面部分
            if (text.length > 60) {
                text = text.substring(0, 60) + '...';
            }
            
            return text;
        }
        
        // 随机通话问候语
        function getRandomCallGreeting(characterName) {
            const greetings = [
                `你好，我是${characterName}，很高兴能和你通话。`,
                `嗨，终于能听到你的声音了！`,
                `喂，你好啊，听得到我说话吗？`,
                `你好，谢谢你接我电话。`,
                `嗨，很高兴能和你通话。`
            ];
            
            return greetings[Math.floor(Math.random() * greetings.length)];
        }
        
        // 随机通话回复（备用）
        function getRandomCallResponse() {
            const responses = [
                '嗯，我明白了。',
                '好的，我知道了。',
                '是的，你说得对。',
                '我觉得这个想法不错。',
                '嗯，有道理。',
                '哦，真的吗？',
                '我明白你的意思了。',
                '这样啊，我懂了。',
                '确实如此。',
                '我同意你的看法。'
            ];
            
            return responses[Math.floor(Math.random() * responses.length)];
        }
        
        // 检测是否应该触发AI主动拨打电话
        function checkForAICallTrigger(userMessage, aiResponse) {
            // 获取当前聊天设置
            const currentChatSettings = getCurrentChatSettings();
            
            // 如果未启用AI主动拨打电话功能，直接返回
            if (!currentChatSettings.aiCallEnabled) {
                console.log('🔔 AI主动拨打电话功能未开启，角色不会主动拨打电话');
                return false;
            }
            
            // 如果已经在通话中，不再触发
            if (isInCall) {
                console.log('🔔 当前正在通话中，不触发新的来电');
                return false;
            }
            
            // 确保有当前聊天角色
            if (!currentChatCharacter) {
                console.log('🔔 没有当前聊天角色，无法触发来电');
                return false;
            }
            
            // 通话关键词
            const callKeywords = ['通话', '电话', '视频', '语音', '打给你', '想听', '想看', '聊天', '说话', '测试', '试试', '打电话'];
            
            // 检查用户消息和AI回复中是否包含通话关键词
            const userMessageHasCallKeyword = callKeywords.some(keyword => userMessage.includes(keyword));
            const aiResponseHasCallKeyword = callKeywords.some(keyword => aiResponse.includes(keyword));
            
            console.log('🔔 检查AI主动拨打触发条件:', {
                userMessage,
                aiResponse,
                userHasKeyword: userMessageHasCallKeyword,
                aiHasKeyword: aiResponseHasCallKeyword,
                aiCallEnabled: currentChatSettings.aiCallEnabled
            });
            
            // 根据关键词出现情况和角色性格决定触发概率
            let triggerProbability = 0;
            if (userMessageHasCallKeyword) {
                // 基础概率：用户提到通话关键词时20%
                triggerProbability = 0.2;
                
                // 如果AI回复也包含通话关键词，大幅提升概率到60%
                if (aiResponseHasCallKeyword) {
                    triggerProbability = 0.6;
                }
                
                // 根据角色性格调整概率（如果角色设定中包含主动、外向等特质）
                const characterBio = currentChatCharacter.bio || '';
                if (characterBio.includes('主动') || characterBio.includes('外向') || characterBio.includes('热情')) {
                    triggerProbability += 0.1;
                }
                
                // 限制最大概率为70%
                triggerProbability = Math.min(triggerProbability, 0.7);
            }
            
            // 增加随机因素：即使没有关键词，也有极小概率(2%)触发，模拟真实的突然来电
            if (triggerProbability === 0 && Math.random() < 0.02) {
                triggerProbability = 0.02;
                console.log('🔔 随机触发AI来电（模拟突然想到要打电话）');
            }
            
            if (triggerProbability > 0 && Math.random() < triggerProbability) {
                console.log('🔔 AI主动拨打电话被触发！概率:', triggerProbability);
                
                // 从AI回复中提取一个合理的通话理由
                let callReason = extractCallReason(aiResponse);
                
                // 延迟2-5秒后触发来电
                const delay = 2000 + Math.random() * 3000;
                console.log(`🔔 将在${Math.round(delay/1000)}秒后发起来电，理由: ${callReason}`);
                
                setTimeout(() => {
                    console.log('🔔 开始发起AI来电');
                    initiateAICall(currentChatCharacter, callReason);
                }, delay);
                
                return true;
            } else {
                console.log('🔔 AI主动拨打未触发，概率:', triggerProbability);
            }
            
            return false;
        }
        
        // 从AI回复中提取通话理由
        function extractCallReason(aiResponse) {
            // 默认理由
            let defaultReasons = [
                '想和你聊聊天',
                '有事情想告诉你',
                '想听听你的声音',
                '想和你说说话'
            ];
            
            // 尝试从回复中提取一个合理的句子作为理由
            const sentences = aiResponse.split(/[。！？.!?]/);
            const validSentences = sentences.filter(s => {
                const trimmed = s.trim();
                return trimmed.length > 5 && trimmed.length < 20 && !trimmed.includes('我');
            });
            
            if (validSentences.length > 0) {
                return validSentences[Math.floor(Math.random() * validSentences.length)].trim();
            }
            
            return defaultReasons[Math.floor(Math.random() * defaultReasons.length)];
        }

        function openVideoCall() {
            showToast('视频通话功能开发中...', 'info');
            // 这里可以添加视频通话功能
        }

        function shareLocation() {
            if (!currentChatCharacter) {
                alert('请先选择一个角色');
                return;
            }
            
            // 重置输入框
            document.getElementById('location-address').value = '';
            document.getElementById('map-location-display').textContent = '请输入位置名称';
            
            // 随机化地图显示
            randomizeMapPosition();
            
            // 加载历史记录
            renderLocationHistory();
            
            // 显示模态框
            document.getElementById('location-modal').style.display = 'flex';
        }

        function hideLocationModal() {
            document.getElementById('location-modal').style.display = 'none';
        }

        function setLocationAddress(address) {
            document.getElementById('location-address').value = address;
            document.getElementById('map-location-display').textContent = address;
            
            // 生成随机坐标
            const lat = (39.8 + Math.random() * 0.4).toFixed(4);
            const lng = (116.2 + Math.random() * 0.4).toFixed(4);
            document.querySelector('.map-coordinates').textContent = `${lng}°E, ${lat}°N`;
        }

        function randomizeMapPosition() {
            const marker = document.getElementById('location-marker');
            const buildings = document.querySelectorAll('.building');
            
            // 随机移动标记位置
            const newTop = 20 + Math.random() * 60; // 20% - 80%
            const newLeft = 20 + Math.random() * 60; // 20% - 80%
            marker.style.top = newTop + '%';
            marker.style.left = newLeft + '%';
            
            // 随机移动建筑物
            buildings.forEach(building => {
                const top = Math.random() * 85; // 0% - 85%
                const left = Math.random() * 85; // 0% - 85%
                building.style.top = top + '%';
                building.style.left = left + '%';
            });
            
            // 更新坐标
            const lat = (39.8 + Math.random() * 0.4).toFixed(4);
            const lng = (116.2 + Math.random() * 0.4).toFixed(4);
            document.querySelector('.map-coordinates').textContent = `${lng}°E, ${lat}°N`;
        }

        // 生成逼真的地图HTML内容
        function generateRealisticMapHTML() {
            return `
                <div class="map-background"></div>
                <!-- 弯曲河流 -->
                <div class="river" style="top: 5%; left: 60%; width: 20px; height: 3px; transform: rotate(35deg);"></div>
                <div class="river-curve" style="top: 12%; left: 72%; width: 18px; height: 3px; transform: rotate(15deg);"></div>
                <div class="river" style="top: 18%; left: 80%; width: 16px; height: 3px; transform: rotate(-5deg);"></div>
                <div class="river-curve" style="top: 22%; left: 85%; width: 15px; height: 3px; transform: rotate(-25deg);"></div>
                <div class="river" style="top: 55%; left: 2%; width: 22px; height: 3px; transform: rotate(-10deg);"></div>
                <div class="river-curve" style="top: 62%; left: 18%; width: 20px; height: 3px; transform: rotate(8deg);"></div>
                <div class="river" style="top: 68%; left: 32%; width: 18px; height: 3px; transform: rotate(25deg);"></div>
                <!-- 公园绿地 -->
                <div class="park" style="top: 20%; left: 65%; width: 18px; height: 15px;"></div>
                <div class="park" style="top: 45%; left: 10%; width: 22px; height: 18px;"></div>
                <!-- 道路 -->
                <div class="map-roads">
                    <div class="road road-horizontal" style="top: 35%; width: 100%;"></div>
                    <div class="road road-vertical" style="left: 40%; height: 100%;"></div>
                    <div class="road road-horizontal" style="top: 65%; width: 70%; left: 30%;"></div>
                </div>
                <!-- 建筑物 -->
                <div class="map-buildings">
                    <div class="building house" style="top: 15%; left: 20%; width: 12px; height: 10px;"></div>
                    <div class="building office" style="top: 25%; left: 45%; width: 8px; height: 16px;"></div>
                    <div class="building shop" style="top: 50%; left: 50%; width: 14px; height: 8px;"></div>
                    <div class="building house" style="top: 70%; left: 75%; width: 10px; height: 8px;"></div>
                    <div class="building office" style="top: 8%; left: 85%; width: 6px; height: 12px;"></div>
                </div>
                <!-- 树木 -->
                <div class="tree big" style="top: 25%; left: 15%; width: 6px; height: 6px;"></div>
                <div class="tree small" style="top: 55%; left: 25%; width: 4px; height: 4px;"></div>
                <div class="tree big" style="top: 10%; left: 70%; width: 5px; height: 5px;"></div>
                <div class="tree small" style="top: 75%; left: 85%; width: 3px; height: 3px;"></div>
                <div class="tree small" style="top: 40%; left: 80%; width: 4px; height: 4px;"></div>
                <!-- 位置标记 -->
                <div class="map-marker">
                    <div class="marker-pin">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                            <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                        </svg>
                    </div>
                </div>
            `;
        }

        // 历史地点管理
        let locationHistory = JSON.parse(localStorage.getItem('locationHistory') || '[]');

        function saveLocationHistory() {
            localStorage.setItem('locationHistory', JSON.stringify(locationHistory));
        }

        function addToLocationHistory(locationName) {
            if (!locationName.trim()) return;
            
            // 移除重复项
            locationHistory = locationHistory.filter(name => name !== locationName);
            // 添加到开头
            locationHistory.unshift(locationName);
            // 限制最多保存10个
            if (locationHistory.length > 10) {
                locationHistory = locationHistory.slice(0, 10);
            }
            
            saveLocationHistory();
            renderLocationHistory();
        }

        function removeFromLocationHistory(locationName) {
            locationHistory = locationHistory.filter(name => name !== locationName);
            saveLocationHistory();
            renderLocationHistory();
        }

        function renderLocationHistory() {
            const container = document.getElementById('location-history-items');
            if (!container) return;

            if (locationHistory.length === 0) {
                container.innerHTML = '<div class="location-history-empty">暂无历史记录</div>';
                return;
            }

            container.innerHTML = locationHistory.map(location =>
                `<div class="location-history-item" data-location="${location}">
                    <span class="location-text">${location}</span>
                    <span class="delete-btn" data-location="${location}" title="删除">×</span>
                </div>`
            ).join('');

            // 🔥【修复】使用事件委托绑定点击事件，避免内联onclick问题
            container.onclick = function(e) {
                const locationItem = e.target.closest('.location-history-item');
                if (!locationItem) return;

                const location = locationItem.dataset.location;

                if (e.target.classList.contains('delete-btn')) {
                    // 点击删除按钮
                    e.stopPropagation();
                    confirmDeleteLocation(location);
                } else {
                    // 点击位置项
                    setLocationAddress(location);
                }
            };
        }

        // 长按删除处理
        let touchTimer = null;
        let touchedElement = null;

        function handleLocationTouchStart(event, location) {
            touchedElement = event.target;
            touchTimer = setTimeout(() => {
                confirmDeleteLocation(location);
            }, 800); // 800ms长按
        }

        function handleLocationTouchEnd(event) {
            if (touchTimer) {
                clearTimeout(touchTimer);
                touchTimer = null;
            }
            if (touchedElement) {
                touchedElement.classList.remove('deleting');
                touchedElement = null;
            }
        }

        function confirmDeleteLocation(location) {
            if (touchedElement) {
                touchedElement.classList.add('deleting');
            }
            
            if (confirm(`确定要删除位置"${location}"吗？`)) {
                removeFromLocationHistory(location);
                showToast('位置已删除', 'success');
            } else if (touchedElement) {
                touchedElement.classList.remove('deleting');
            }
        }

        function sendLocationMessage() {
            const address = document.getElementById('location-address').value.trim();
            if (!address) {
                alert('请输入位置名称');
                return;
            }

            // 添加到历史记录
            addToLocationHistory(address);

            // 创建位置消息
            const locationMessage = {
                id: Date.now().toString(),
                sender: 'sent',
                type: 'location',
                locationName: address,
                coordinates: document.querySelector('.map-coordinates').textContent,
                content: `[用户分享了位置信息：${address}，坐标：${document.querySelector('.map-coordinates').textContent}]`,
                timestamp: Date.now()
            };

            console.log('🗺️ 创建位置消息:', locationMessage);
            
            // 🔥【调试】检查消息数据
            if (!locationMessage.locationName || !locationMessage.coordinates) {
                console.error('❌ 位置消息数据不完整:', {
                    locationName: locationMessage.locationName,
                    coordinates: locationMessage.coordinates
                });
                alert('位置信息不完整，请重试');
                return;
            }

            // 添加到聊天记录
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            chatMessages[currentChatCharacter.id].push(locationMessage);

            // 保存到数据库
            saveChatMessages();

            // 使用动画添加消息而不是重新渲染整个列表
            addMessageWithAnimation(locationMessage, currentChatCharacter.id);

            // 设置为待回复消息
            pendingUserMessage = locationMessage;

            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = '点击获取AI回复';
            }

            // 更新联系人列表
            renderMessageList();

            // 关闭模态框
            hideLocationModal();

            showToast('位置已分享', 'success');
        }

        // 更新已存在的位置卡片地图
        function updateExistingLocationMaps() {
            const locationMaps = document.querySelectorAll('.location-card-map');
            locationMaps.forEach(mapElement => {
                // 检查是否需要更新（没有新的地图元素）
                if (!mapElement.querySelector('.river')) {
                    mapElement.innerHTML = generateRealisticMapHTML();
                }
            });
        }

        // 监听位置输入框的变化
        document.addEventListener('DOMContentLoaded', function() {
            const locationInput = document.getElementById('location-address');
            if (locationInput) {
                locationInput.addEventListener('input', function() {
                    const value = this.value.trim();
                    if (value) {
                        document.getElementById('map-location-display').textContent = value;
                        
                        // 生成随机坐标
                        const lat = (39.8 + Math.random() * 0.4).toFixed(4);
                        const lng = (116.2 + Math.random() * 0.4).toFixed(4);
                        document.querySelector('.map-coordinates').textContent = `${lng}°E, ${lat}°N`;
                    } else {
                        document.getElementById('map-location-display').textContent = '请输入位置名称';
                    }
                });
            }
            
            // 点击模态框背景关闭
            document.getElementById('location-modal')?.addEventListener('click', (e) => {
                if (e.target === document.getElementById('location-modal')) {
                    hideLocationModal();
                }
            });

            // 定期更新现有的位置卡片地图
            setInterval(updateExistingLocationMaps, 1000);
        });

        // 显示位置详情
        function showLocationDetail(locationName) {
            alert(`🗺️ ${locationName}`);
        }
 
        // 📊 数据管理相关函数
        
        // 计算存储空间使用情况
        async function calculateStorageUsage() {
            try {
                let chatSize = 0, characterSize = 0, settingsSize = 0, emojiSize = 0;

                const [chatData, charData, settingsData, emojiData] = await Promise.all([
                    db.chatMessages.toArray(),
                    db.characters.toArray(), 
                    db.chatSettings.toArray(),
                    db.customEmojis.toArray()
                ]);

                chatSize = JSON.stringify(chatData).length;
                characterSize = JSON.stringify(charData).length;
                settingsSize = JSON.stringify(settingsData).length;
                emojiSize = JSON.stringify(emojiData).length;
                const total = chatSize + characterSize + settingsSize + emojiSize;

                // 更新显示
                const formatBytes = (bytes) => {
                    if (bytes === 0) return '0 B';
                    const k = 1024;
                    const sizes = ['B', 'KB', 'MB', 'GB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                };

                if (document.getElementById('chat-storage-size')) {
                    document.getElementById('chat-storage-size').textContent = formatBytes(chatSize);
                    document.getElementById('character-storage-size').textContent = formatBytes(characterSize);
                    document.getElementById('settings-storage-size').textContent = formatBytes(settingsSize);
                    document.getElementById('emoji-storage-size').textContent = formatBytes(emojiSize);
                    document.getElementById('total-storage-size').textContent = formatBytes(total);
                }
            } catch (error) {
                console.error('计算存储失败:', error);
            }
        }

        // 导出所有数据
        async function exportAllData() {
            try {
                showToast('正在导出数据...', 'info');

                // 🔥【调试】检查数据库版本和表是否存在
                console.log('🔍 数据库版本:', db.verno);
                console.log('🔍 数据库表列表:', db.tables.map(t => t.name));

                // 🔥【完善】导出所有重要数据表，确保包含全部功能数据
                const exportData = {
                    version: '5.0', // 更新版本号，包含完整数据
                    exportTime: new Date().toISOString(),
                    // 基础数据
                    characters: await db.characters.toArray(),
                    chatMessages: await db.chatMessages.toArray(),
                    chatSettings: await db.chatSettings.toArray(),
                    contacts: await db.contacts.toArray(),
                    // 用户面具系统
                    personas: await db.personas.toArray(),
                    // 表情包系统
                    customEmojis: await db.customEmojis.toArray(),
                    recentEmojis: await db.recentEmojis.toArray(),
                    // 世界书系统
                    worldbooks: await db.worldbooks.toArray(),
                    worldbookEntries: await db.worldbookEntries.toArray(),
                    // 群聊系统
                    characterGroups: await db.characterGroups.toArray(),
                    groupChats: await db.groupChats.toArray(),
                    groupChatMessages: await db.groupChatMessages.toArray(),
                    groupChatMembers: await db.groupChatMembers.toArray(),
                    // 动态系统
                    moments: await db.moments.toArray(),
                    momentLikes: await db.momentLikes.toArray(),
                    momentComments: await db.momentComments.toArray(),
                    // 记忆系统
                    workingMemory: await db.workingMemory.toArray(),
                    episodicMemory: await db.episodicMemory.toArray(),
                    coreMemory: await db.coreMemory.toArray(),
                    crossAppTimeline: await db.crossAppTimeline.toArray(),
                    // 拉黑和好友系统
                    blockedCharacters: await db.blockedCharacters.toArray(),
                    friendRequests: await db.friendRequests.toArray(),
                    characterStatus: await db.characterStatus.toArray(),
                    // 日记系统
                    characterDiaries: await db.characterDiaries.toArray(),
                    // 线下模式系统
                    offlineHistoryRecords: await db.offlineHistoryRecords.toArray(),
                    offlineUISettings: await db.offlineUISettings.toArray(),
                    offlinePresets: await db.offlinePresets.toArray(),
                    // 音乐播放器系统
                    musicPlaylist: await db.musicPlaylist.toArray(),
                    musicCovers: await db.musicCovers.toArray(),
                    // 设置和配置
                    apiSettings: await db.apiSettings.toArray(),
                    globalSettings: await db.globalSettings.toArray(),
                    wallpapers: await db.wallpapers.toArray(),
                    appIcons: await db.appIcons.toArray()
                };

                // 显示导出统计
                const stats = [];
                // 基础数据统计
                if (exportData.characters?.length) stats.push(`角色: ${exportData.characters.length}个`);
                if (exportData.chatMessages?.length) stats.push(`消息: ${exportData.chatMessages.length}条`);
                if (exportData.personas?.length) stats.push(`面具: ${exportData.personas.length}个`);
                if (exportData.contacts?.length) stats.push(`联系人: ${exportData.contacts.length}个`);
                // 表情包系统
                if (exportData.customEmojis?.length) stats.push(`表情: ${exportData.customEmojis.length}个`);
                if (exportData.recentEmojis?.length) stats.push(`最近表情: ${exportData.recentEmojis.length}个`);
                // 世界书系统
                if (exportData.worldbooks?.length) stats.push(`世界书: ${exportData.worldbooks.length}个`);
                if (exportData.worldbookEntries?.length) stats.push(`世界书条目: ${exportData.worldbookEntries.length}条`);
                // 群聊系统
                if (exportData.groupChats?.length) stats.push(`群聊: ${exportData.groupChats.length}个`);
                if (exportData.groupChatMessages?.length) stats.push(`群聊消息: ${exportData.groupChatMessages.length}条`);
                // 动态系统
                if (exportData.moments?.length) stats.push(`动态: ${exportData.moments.length}条`);
                if (exportData.momentComments?.length) stats.push(`动态评论: ${exportData.momentComments.length}条`);
                // 记忆系统
                if (exportData.workingMemory?.length) stats.push(`工作记忆: ${exportData.workingMemory.length}条`);
                if (exportData.episodicMemory?.length) stats.push(`情节记忆: ${exportData.episodicMemory.length}条`);
                if (exportData.coreMemory?.length) stats.push(`核心记忆: ${exportData.coreMemory.length}条`);
                if (exportData.crossAppTimeline?.length) stats.push(`时间线: ${exportData.crossAppTimeline.length}条`);
                // 日记系统
                if (exportData.characterDiaries?.length) stats.push(`日记: ${exportData.characterDiaries.length}条`);
                // 线下模式
                if (exportData.offlineHistoryRecords?.length) stats.push(`线下记录: ${exportData.offlineHistoryRecords.length}条`);
                if (exportData.offlinePresets?.length) stats.push(`线下预设: ${exportData.offlinePresets.length}个`);
                // 音乐系统
                if (exportData.musicPlaylist?.length) stats.push(`音乐: ${exportData.musicPlaylist.length}首`);
                // 设置数据
                if (exportData.chatSettings?.length) stats.push(`聊天设置: ${exportData.chatSettings.length}个`);
                if (exportData.wallpapers?.length) stats.push(`壁纸: ${exportData.wallpapers.length}个`);
                
                console.log('导出数据统计:', stats.join(', '));

                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `完整备份_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                const statsText = stats.length > 0 ? `\n${stats.join('\n')}` : '';
                showToast(`导出成功！${statsText}`, 'success');
            } catch (error) {
                console.error('导出失败:', error);
                showToast('导出失败: ' + error.message, 'error');
            }
        }

        // 🔥【终极修复】导入数据 - 专门解决联系人和消息显示问题
        function importDataFromFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async function(e) {
                const file = e.target.files[0];
                if (!file) return;
                try {
                    showToast('正在导入...', 'info');
                    const text = await file.text();
                    
                    // 尝试解析JSON
                    let data;
                    try {
                        data = JSON.parse(text);
                    } catch (parseError) {
                        throw new Error('JSON格式错误：' + parseError.message);
                    }
                    
                    // 检查数据格式
                    if (!data || typeof data !== 'object') {
                        throw new Error('无效的备份文件格式');
                    }
                    
                    // 🔥【完善】显示导入预览，包括所有数据表
                    const dataPreview = [];
                    // 基础数据
                    if (data.characters?.length) dataPreview.push(`角色: ${data.characters.length}个`);
                    if (data.chatMessages?.length) dataPreview.push(`聊天消息: ${data.chatMessages.length}条`);
                    if (data.personas?.length) dataPreview.push(`用户面具: ${data.personas.length}个`);
                    if (data.contacts?.length) dataPreview.push(`联系人: ${data.contacts.length}个`);
                    // 表情包系统
                    if (data.customEmojis?.length) dataPreview.push(`自定义表情: ${data.customEmojis.length}个`);
                    if (data.recentEmojis?.length) dataPreview.push(`最近表情: ${data.recentEmojis.length}个`);
                    // 世界书系统
                    if (data.worldbooks?.length) dataPreview.push(`世界书: ${data.worldbooks.length}个`);
                    if (data.worldbookEntries?.length) dataPreview.push(`世界书条目: ${data.worldbookEntries.length}条`);
                    // 群聊系统
                    if (data.groupChats?.length) dataPreview.push(`群聊: ${data.groupChats.length}个`);
                    if (data.groupChatMessages?.length) dataPreview.push(`群聊消息: ${data.groupChatMessages.length}条`);
                    if (data.groupChatMembers?.length) dataPreview.push(`群聊成员: ${data.groupChatMembers.length}个`);
                    // 动态系统
                    if (data.moments?.length) dataPreview.push(`动态: ${data.moments.length}条`);
                    if (data.momentComments?.length) dataPreview.push(`动态评论: ${data.momentComments.length}条`);
                    if (data.momentLikes?.length) dataPreview.push(`动态点赞: ${data.momentLikes.length}条`);
                    // 记忆系统
                    if (data.workingMemory?.length) dataPreview.push(`工作记忆: ${data.workingMemory.length}条`);
                    if (data.episodicMemory?.length) dataPreview.push(`情节记忆: ${data.episodicMemory.length}条`);
                    if (data.coreMemory?.length) dataPreview.push(`核心记忆: ${data.coreMemory.length}条`);
                    if (data.crossAppTimeline?.length) dataPreview.push(`时间线记录: ${data.crossAppTimeline.length}条`);
                    // 拉黑和好友系统
                    if (data.blockedCharacters?.length) dataPreview.push(`拉黑记录: ${data.blockedCharacters.length}条`);
                    if (data.friendRequests?.length) dataPreview.push(`好友申请: ${data.friendRequests.length}条`);
                    if (data.characterStatus?.length) dataPreview.push(`角色状态: ${data.characterStatus.length}条`);
                    // 日记系统
                    if (data.characterDiaries?.length) dataPreview.push(`角色日记: ${data.characterDiaries.length}条`);
                    // 线下模式
                    if (data.offlineHistoryRecords?.length) dataPreview.push(`线下记录: ${data.offlineHistoryRecords.length}条`);
                    if (data.offlineUISettings?.length) dataPreview.push(`线下界面设置: ${data.offlineUISettings.length}个`);
                    if (data.offlinePresets?.length) dataPreview.push(`线下预设: ${data.offlinePresets.length}个`);
                    // 音乐系统
                    if (data.musicPlaylist?.length) dataPreview.push(`音乐: ${data.musicPlaylist.length}首`);
                    if (data.musicCovers?.length) dataPreview.push(`音乐封面: ${data.musicCovers.length}个`);
                    // 设置数据
                    if (data.chatSettings?.length) dataPreview.push(`聊天设置: ${data.chatSettings.length}个`);
                    if (data.apiSettings?.length) dataPreview.push(`API设置: ${data.apiSettings.length}个`);
                    if (data.globalSettings?.length) dataPreview.push(`全局设置: ${data.globalSettings.length}个`);
                    if (data.wallpapers?.length) dataPreview.push(`壁纸: ${data.wallpapers.length}个`);
                    if (data.appIcons?.length) dataPreview.push(`应用图标: ${data.appIcons.length}个`);
                    
                    const previewText = dataPreview.length > 0 ? 
                        `将导入以下数据：\n${dataPreview.join('\n')}\n\n导入将覆盖现有数据，确定继续？` : 
                        '备份文件中没有找到有效数据，确定继续？';
                    
                    if (!confirm(previewText)) return;
                    
                    // 🔥【修复】使用bulkPut代替bulkAdd避免主键冲突
                    let importedTables = 0;
                    
                    // 导入角色数据
                    if (data.characters?.length) {
                        try {
                            // 🔥【安全修复】确保每个角色都有有效ID
                            const validCharacters = data.characters.map(char => ({
                                ...char,
                                id: char.id || `char_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));

                            // 使用安全保存函数
                            await safeDataSave('characters', validCharacters);
                            importedTables++;
                            console.log(`导入了 ${validCharacters.length} 个角色`);
                        } catch (error) {
                            console.error('导入角色失败:', error);
                            showToast('角色导入失败: ' + error.message, 'warning');
                        }
                    }
                    
                    // 🔥【修复】导入聊天消息 - 处理格式转换
                    if (data.chatMessages?.length) {
                        try {
                            console.log('🔄 开始导入聊天消息，原始数据:', data.chatMessages.length, '条');

                            // 🔥【关键修复】检查数据格式并转换
                            let processedMessages = [];

                            // 检查是否是新格式（包含messageData字段）
                            const isNewFormat = data.chatMessages.some(msg => msg.messageData);

                            if (isNewFormat) {
                                // 新格式：直接使用
                                console.log('📝 检测到新格式数据（包含messageData）');
                                processedMessages = data.chatMessages.map(msg => ({
                                    ...msg,
                                    id: msg.id || `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                            } else {
                                // 旧格式：需要转换为新格式
                                console.log('📝 检测到旧格式数据，正在转换...');

                                // 先重建chatMessages对象结构
                                const tempChatMessages = {};
                                for (const msg of data.chatMessages) {
                                    const characterId = msg.characterId;
                                    if (!tempChatMessages[characterId]) {
                                        tempChatMessages[characterId] = [];
                                    }
                                    tempChatMessages[characterId].push(msg);
                                }

                                // 然后转换为新格式
                                let globalSequentialId = 0;
                                for (const [characterId, messages] of Object.entries(tempChatMessages)) {
                                    for (let i = 0; i < messages.length; i++) {
                                        const message = messages[i];
                                        processedMessages.push({
                                            id: `${characterId}_${globalSequentialId++}`,
                                            characterId: characterId,
                                            timestamp: message.timestamp,
                                            messageOrder: i,
                                            originalMessageId: message.id,
                                            messageData: message
                                        });
                                    }
                                }
                                console.log(`📝 格式转换完成，生成 ${processedMessages.length} 条记录`);
                            }

                            // 🔥【安全修复】使用事务确保原子性
                            await db.transaction('rw', db.chatMessages, async () => {
                                await db.chatMessages.clear();
                                await db.chatMessages.bulkAdd(processedMessages);
                            });

                            importedTables++;
                            console.log(`✅ 成功导入了 ${processedMessages.length} 条聊天消息`);
                        } catch (error) {
                            console.error('❌ 导入聊天消息失败:', error);
                            showToast('聊天消息导入失败: ' + error.message, 'warning');
                        }
                    }

                    // 🔥【架构修复】不再需要单独导入联系人数据，因为联系人现在从角色列表自动生成
                    console.log('ℹ️ 跳过联系人导入，联系人将从角色列表自动生成');

                    // 🔥【新增】导入记忆系统数据
                    // 导入核心记忆
                    if (data.coreMemory?.length || data.coreMemories?.length) {
                        try {
                            const coreMemoryData = data.coreMemory || data.coreMemories || [];
                            console.log('🔄 开始导入核心记忆，原始数据:', coreMemoryData.length, '条');
                            await db.coreMemory.clear();
                            if (data.coreMemories?.length) {
                                await db.coreMemories.clear();
                            }

                            const validCoreMemories = coreMemoryData.map(memory => ({
                                ...memory,
                                id: memory.id || `core_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));

                            await db.coreMemory.bulkAdd(validCoreMemories);
                            if (data.coreMemories?.length) {
                                await db.coreMemories.bulkAdd(validCoreMemories);
                            }
                            importedTables++;
                            console.log(`✅ 成功导入了 ${validCoreMemories.length} 条核心记忆`);
                        } catch (error) {
                            console.error('❌ 导入核心记忆失败:', error);
                            showToast('核心记忆导入失败: ' + error.message, 'warning');
                        }
                    }

                    // 导入情景记忆
                    if (data.episodicMemory?.length || data.episodicMemories?.length || data.memorySummaries?.length) {
                        try {
                            const episodicData = data.episodicMemory || data.episodicMemories || data.memorySummaries || [];
                            console.log('🔄 开始导入情景记忆，原始数据:', episodicData.length, '条');
                            await db.episodicMemory.clear();
                            if (data.episodicMemories?.length) {
                                await db.episodicMemories.clear();
                            }
                            if (data.memorySummaries?.length) {
                                await db.memorySummaries.clear();
                            }

                            const validEpisodicMemories = episodicData.map(memory => ({
                                ...memory,
                                id: memory.id || `episodic_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));

                            await db.episodicMemory.bulkAdd(validEpisodicMemories);
                            if (data.episodicMemories?.length) {
                                await db.episodicMemories.bulkAdd(validEpisodicMemories);
                            }
                            if (data.memorySummaries?.length) {
                                await db.memorySummaries.bulkAdd(validEpisodicMemories);
                            }
                            importedTables++;
                            console.log(`✅ 成功导入了 ${validEpisodicMemories.length} 条情景记忆`);
                        } catch (error) {
                            console.error('❌ 导入情景记忆失败:', error);
                            showToast('情景记忆导入失败: ' + error.message, 'warning');
                        }
                    }

                    // 导入工作记忆
                    if (data.workingMemory?.length) {
                        try {
                            console.log('🔄 开始导入工作记忆，原始数据:', data.workingMemory.length, '条');
                            await db.workingMemory.clear();
                            const validWorkingMemories = data.workingMemory.map(memory => ({
                                ...memory,
                                id: memory.id || `working_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.workingMemory.bulkAdd(validWorkingMemories);
                            importedTables++;
                            console.log(`✅ 成功导入了 ${validWorkingMemories.length} 条工作记忆`);
                        } catch (error) {
                            console.error('❌ 导入工作记忆失败:', error);
                            showToast('工作记忆导入失败: ' + error.message, 'warning');
                        }
                    }

                    // 导入其他可能的数据
                    if (data.worldbooks?.length) {
                        try {
                            await db.worldbooks.clear();
                            const validWorldbooks = data.worldbooks.map(wb => ({
                                ...wb,
                                id: wb.id || `wb_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.worldbooks.bulkPut(validWorldbooks);
                            importedTables++;
                            console.log(`导入了 ${validWorldbooks.length} 个世界书`);
                        } catch (error) {
                            console.error('导入世界书失败:', error);
                            showToast('世界书导入失败: ' + error.message, 'warning');
                        }
                    }
                    
                    // 🔥【修复】导入自定义表情 - 安全的导入方式
                    if (data.customEmojis?.length) {
                        try {
                            // 🔥【安全修复】使用事务确保原子性
                            await db.transaction('rw', db.customEmojis, async () => {
                                await db.customEmojis.clear();

                                const validEmojis = data.customEmojis.map(emoji => ({
                                    ...emoji,
                                    id: emoji.id || `emoji_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));

                                await db.customEmojis.bulkAdd(validEmojis);
                            });

                            importedTables++;
                            console.log(`导入了 ${data.customEmojis.length} 个自定义表情`);
                        } catch (error) {
                            console.error('导入自定义表情失败:', error);
                            showToast('自定义表情导入失败: ' + error.message, 'warning');
                        }
                    }
                    
                    // 导入壁纸
                    if (data.wallpapers?.length) {
                        try {
                            await db.wallpapers.clear();
                            const validWallpapers = data.wallpapers.map(wp => ({
                                ...wp,
                                id: wp.id || `wp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.wallpapers.bulkPut(validWallpapers);
                            importedTables++;
                            console.log(`导入了 ${validWallpapers.length} 个壁纸`);
                        } catch (error) {
                            console.error('导入壁纸失败:', error);
                            showToast('壁纸导入失败: ' + error.message, 'warning');
                        }
                    }
                    
                    // 导入角色分组
                    if (data.characterGroups?.length) {
                        try {
                            await db.characterGroups.clear();
                            const validGroups = data.characterGroups.map(group => ({
                                ...group,
                                id: group.id || `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.characterGroups.bulkPut(validGroups);
                            importedTables++;
                            console.log(`导入了 ${validGroups.length} 个角色分组`);
                        } catch (error) {
                            console.error('导入角色分组失败:', error);
                            showToast('角色分组导入失败: ' + error.message, 'warning');
                        }
                    }
                    
                    // 导入群聊
                    if (data.groupChats?.length) {
                        try {
                            await db.groupChats.clear();
                            const validGroups = data.groupChats.map(chat => ({
                                ...chat,
                                id: chat.id || `chat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.groupChats.bulkPut(validGroups);
                            importedTables++;
                            console.log(`导入了 ${validGroups.length} 个群聊`);
                        } catch (error) {
                            console.error('导入群聊失败:', error);
                            showToast('群聊导入失败: ' + error.message, 'warning');
                        }
                    }
                    
                    // 导入用户面具
                    if (data.personas?.length) {
                        try {
                            console.log('🔄 开始导入用户面具，原始数据:', data.personas.length, '个');
                            await db.personas.clear();
                            const validPersonas = data.personas.map((persona, index) => {
                                const result = {
                                    ...persona,
                                    id: persona.id || `persona_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                };
                                console.log(`处理面具 ${index + 1}:`, result);
                                return result;
                            });
                            await db.personas.bulkPut(validPersonas);
                            importedTables++;
                            console.log(`✅ 成功导入了 ${validPersonas.length} 个用户面具`);
                        } catch (error) {
                            console.error('❌ 导入用户面具失败:', error);
                            console.error('面具数据详情:', data.personas);
                            showToast('用户面具导入失败: ' + error.message, 'warning');
                        }
                    } else {
                        console.log('⚠️ 没有找到用户面具数据');
                    }
                    
                    // 导入API设置
                    if (data.apiSettings?.length) {
                        try {
                            await db.apiSettings.clear();
                            const validApiSettings = data.apiSettings.map(setting => ({
                                ...setting,
                                id: setting.id || `api_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.apiSettings.bulkPut(validApiSettings);
                            importedTables++;
                            console.log(`导入了 ${validApiSettings.length} 个API设置`);
                        } catch (error) {
                            console.error('导入API设置失败:', error);
                            showToast('API设置导入失败: ' + error.message, 'warning');
                        }
                    }
                    
                    // 导入全局设置
                    if (data.globalSettings?.length) {
                        try {
                            await db.globalSettings.clear();
                            const validGlobalSettings = data.globalSettings.map(setting => ({
                                ...setting,
                                id: setting.id || `global_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.globalSettings.bulkPut(validGlobalSettings);
                            importedTables++;
                            console.log(`导入了 ${validGlobalSettings.length} 个全局设置`);
                        } catch (error) {
                            console.error('导入全局设置失败:', error);
                            showToast('全局设置导入失败: ' + error.message, 'warning');
                        }
                    }
                    
                    // 导入最近表情
                    if (data.recentEmojis?.length) {
                        try {
                            await db.recentEmojis.clear();
                            const validRecentEmojis = data.recentEmojis.map(emoji => ({
                                ...emoji,
                                id: emoji.id || `recent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.recentEmojis.bulkPut(validRecentEmojis);
                            importedTables++;
                            console.log(`导入了 ${validRecentEmojis.length} 个最近表情`);
                        } catch (error) {
                            console.error('导入最近表情失败:', error);
                            showToast('最近表情导入失败: ' + error.message, 'warning');
                        }
                    }
                    

                    
                    // 导入应用图标
                    if (data.appIcons?.length) {
                        try {
                            await db.appIcons.clear();
                            const validAppIcons = data.appIcons.map(icon => ({
                                ...icon,
                                id: icon.id || `icon_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.appIcons.bulkPut(validAppIcons);
                            importedTables++;
                            console.log(`导入了 ${validAppIcons.length} 个应用图标`);
                        } catch (error) {
                            console.error('导入应用图标失败:', error);
                            showToast('应用图标导入失败: ' + error.message, 'warning');
                        }
                    }

                    if (data.memorySummaries?.length) {
                        try {
                            await db.memorySummaries.clear();
                            const validMemorySummaries = data.memorySummaries.map(summary => ({
                                ...summary,
                                id: summary.id || `summary_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.memorySummaries.bulkPut(validMemorySummaries);
                            importedTables++;
                            console.log(`导入了 ${validMemorySummaries.length} 条记忆摘要`);
                        } catch (error) {
                            console.error('导入记忆摘要失败:', error);
                            showToast('记忆摘要导入失败: ' + error.message, 'warning');
                        }
                    }

                    if (data.memoryEvents?.length) {
                        try {
                            await db.memoryEvents.clear();
                            const validMemoryEvents = data.memoryEvents.map(event => ({
                                ...event,
                                id: event.id || `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.memoryEvents.bulkPut(validMemoryEvents);
                            importedTables++;
                            console.log(`导入了 ${validMemoryEvents.length} 条记忆事件`);
                        } catch (error) {
                            console.error('导入记忆事件失败:', error);
                            showToast('记忆事件导入失败: ' + error.message, 'warning');
                        }
                    }

                    if (data.crossAppTimeline?.length) {
                        try {
                            await db.crossAppTimeline.clear();
                            const validTimeline = data.crossAppTimeline.map(timeline => ({
                                ...timeline,
                                id: timeline.id || `timeline_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.crossAppTimeline.bulkPut(validTimeline);
                            importedTables++;
                            console.log(`导入了 ${validTimeline.length} 条跨应用时间线`);
                        } catch (error) {
                            console.error('导入跨应用时间线失败:', error);
                            showToast('跨应用时间线导入失败: ' + error.message, 'warning');
                        }
                    }

                    // 🔥【新增】导入拉黑和好友系统表
                    if (data.blockedCharacters?.length) {
                        try {
                            await db.blockedCharacters.clear();
                            const validBlocked = data.blockedCharacters.map(item => ({
                                ...item,
                                id: item.id || `blocked_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.blockedCharacters.bulkPut(validBlocked);
                            importedTables++;
                            console.log(`导入了 ${validBlocked.length} 条拉黑记录`);
                        } catch (error) {
                            console.error('导入拉黑记录失败:', error);
                            showToast('拉黑记录导入失败: ' + error.message, 'warning');
                        }
                    }

                    if (data.friendRequests?.length) {
                        try {
                            await db.friendRequests.clear();
                            const validRequests = data.friendRequests.map(req => ({
                                ...req,
                                id: req.id || `request_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.friendRequests.bulkPut(validRequests);
                            importedTables++;
                            console.log(`导入了 ${validRequests.length} 条好友申请`);
                        } catch (error) {
                            console.error('导入好友申请失败:', error);
                            showToast('好友申请导入失败: ' + error.message, 'warning');
                        }
                    }

                    if (data.characterStatus?.length) {
                        try {
                            await db.characterStatus.clear();
                            const validStatus = data.characterStatus.map(status => ({
                                ...status,
                                id: status.id || `status_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.characterStatus.bulkPut(validStatus);
                            importedTables++;
                            console.log(`导入了 ${validStatus.length} 条角色状态`);
                        } catch (error) {
                            console.error('导入角色状态失败:', error);
                            showToast('角色状态导入失败: ' + error.message, 'warning');
                        }
                    }

                    // 🔥【新增】导入动态系统表
                    if (data.moments?.length) {
                        try {
                            console.log('🔄 开始导入动态，原始数据:', data.moments.length, '条');
                            await db.moments.clear();
                            const validMoments = data.moments.map((moment, index) => {
                                const result = {
                                    ...moment,
                                    id: moment.id || `moment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                };
                                console.log(`处理动态 ${index + 1}:`, result);
                                return result;
                            });
                            await db.moments.bulkPut(validMoments);
                            importedTables++;
                            console.log(`✅ 成功导入了 ${validMoments.length} 条动态`);
                        } catch (error) {
                            console.error('❌ 导入动态失败:', error);
                            console.error('动态数据详情:', data.moments);
                            showToast('动态导入失败: ' + error.message, 'warning');
                        }
                    } else {
                        console.log('⚠️ 没有找到动态数据');
                    }

                    if (data.momentLikes?.length) {
                        try {
                            await db.momentLikes.clear();
                            await db.momentLikes.bulkPut(data.momentLikes);
                            importedTables++;
                            console.log(`导入了 ${data.momentLikes.length} 条动态点赞`);
                        } catch (error) {
                            console.error('导入动态点赞失败:', error);
                            showToast('动态点赞导入失败: ' + error.message, 'warning');
                        }
                    }

                    if (data.momentComments?.length) {
                        try {
                            await db.momentComments.clear();
                            const validComments = data.momentComments.map(comment => ({
                                ...comment,
                                id: comment.id || `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.momentComments.bulkPut(validComments);
                            importedTables++;
                            console.log(`导入了 ${validComments.length} 条动态评论`);
                        } catch (error) {
                            console.error('导入动态评论失败:', error);
                            showToast('动态评论导入失败: ' + error.message, 'warning');
                        }
                    }

                    // 🔥【新增】导入新记忆系统表
                    if (data.workingMemory?.length) {
                        try {
                            await db.workingMemory.clear();
                            const validWorkingMemory = data.workingMemory.map(memory => ({
                                ...memory,
                                id: memory.id || `working_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.workingMemory.bulkPut(validWorkingMemory);
                            importedTables++;
                            console.log(`导入了 ${validWorkingMemory.length} 条工作记忆`);
                        } catch (error) {
                            console.error('导入工作记忆失败:', error);
                            showToast('工作记忆导入失败: ' + error.message, 'warning');
                        }
                    }

                    if (data.episodicMemory?.length) {
                        try {
                            await db.episodicMemory.clear();
                            const validEpisodicMemory = data.episodicMemory.map(memory => ({
                                ...memory,
                                id: memory.id || `episodic_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.episodicMemory.bulkPut(validEpisodicMemory);
                            importedTables++;
                            console.log(`导入了 ${validEpisodicMemory.length} 条情节记忆`);
                        } catch (error) {
                            console.error('导入情节记忆失败:', error);
                            showToast('情节记忆导入失败: ' + error.message, 'warning');
                        }
                    }

                    if (data.coreMemory?.length) {
                        try {
                            await db.coreMemory.clear();
                            const validCoreMemory = data.coreMemory.map(memory => ({
                                ...memory,
                                id: memory.id || `core_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.coreMemory.bulkPut(validCoreMemory);
                            importedTables++;
                            console.log(`导入了 ${validCoreMemory.length} 条核心记忆`);
                        } catch (error) {
                            console.error('导入核心记忆失败:', error);
                            showToast('核心记忆导入失败: ' + error.message, 'warning');
                        }
                    }

                    // 🔥【新增】导入线下模式系统表
                    if (data.offlineHistoryRecords?.length) {
                        try {
                            await db.offlineHistoryRecords.clear();
                            const validOfflineHistory = data.offlineHistoryRecords.map(record => ({
                                ...record,
                                id: record.id || `offline_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.offlineHistoryRecords.bulkPut(validOfflineHistory);
                            importedTables++;
                            console.log(`导入了 ${validOfflineHistory.length} 条线下记录`);
                        } catch (error) {
                            console.error('导入线下记录失败:', error);
                            showToast('线下记录导入失败: ' + error.message, 'warning');
                        }
                    }

                    if (data.offlineUISettings?.length) {
                        try {
                            await db.offlineUISettings.clear();
                            const validOfflineUI = data.offlineUISettings.map(setting => ({
                                ...setting,
                                id: setting.id || `ui_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.offlineUISettings.bulkPut(validOfflineUI);
                            importedTables++;
                            console.log(`导入了 ${validOfflineUI.length} 条线下界面设置`);
                        } catch (error) {
                            console.error('导入线下界面设置失败:', error);
                            showToast('线下界面设置导入失败: ' + error.message, 'warning');
                        }
                    }

                    if (data.offlinePresets?.length) {
                        try {
                            await db.offlinePresets.clear();
                            const validOfflinePresets = data.offlinePresets.map(preset => ({
                                ...preset,
                                id: preset.id || `preset_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.offlinePresets.bulkPut(validOfflinePresets);
                            importedTables++;
                            console.log(`导入了 ${validOfflinePresets.length} 条线下预设`);
                        } catch (error) {
                            console.error('导入线下预设失败:', error);
                            showToast('线下预设导入失败: ' + error.message, 'warning');
                        }
                    }

                    // 🔥【新增】导入音乐播放器系统表
                    if (data.musicPlaylist?.length) {
                        try {
                            await db.musicPlaylist.clear();
                            const validMusicPlaylist = data.musicPlaylist.map(song => ({
                                ...song,
                                id: song.id || `song_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.musicPlaylist.bulkPut(validMusicPlaylist);
                            importedTables++;
                            console.log(`导入了 ${validMusicPlaylist.length} 首音乐`);
                        } catch (error) {
                            console.error('导入音乐播放列表失败:', error);
                            showToast('音乐播放列表导入失败: ' + error.message, 'warning');
                        }
                    }

                    if (data.musicCovers?.length) {
                        try {
                            await db.musicCovers.clear();
                            const validMusicCovers = data.musicCovers.map(cover => ({
                                ...cover,
                                id: cover.id || `cover_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.musicCovers.bulkPut(validMusicCovers);
                            importedTables++;
                            console.log(`导入了 ${validMusicCovers.length} 个音乐封面`);
                        } catch (error) {
                            console.error('导入音乐封面失败:', error);
                            showToast('音乐封面导入失败: ' + error.message, 'warning');
                        }
                    }

                    // 🔥【新增】导入世界书条目表
                    if (data.worldbookEntries?.length) {
                        try {
                            await db.worldbookEntries.clear();
                            const validWorldbookEntries = data.worldbookEntries.map(entry => ({
                                ...entry,
                                id: entry.id || `entry_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.worldbookEntries.bulkPut(validWorldbookEntries);
                            importedTables++;
                            console.log(`导入了 ${validWorldbookEntries.length} 条世界书条目`);
                        } catch (error) {
                            console.error('导入世界书条目失败:', error);
                            showToast('世界书条目导入失败: ' + error.message, 'warning');
                        }
                    }

                    // 🔥【新增】导入群聊相关表
                    if (data.groupChatMessages?.length) {
                        try {
                            await db.groupChatMessages.clear();
                            const validGroupMessages = data.groupChatMessages.map(msg => ({
                                ...msg,
                                id: msg.id || `gmsg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.groupChatMessages.bulkPut(validGroupMessages);
                            importedTables++;
                            console.log(`导入了 ${validGroupMessages.length} 条群聊消息`);
                        } catch (error) {
                            console.error('导入群聊消息失败:', error);
                            showToast('群聊消息导入失败: ' + error.message, 'warning');
                        }
                    }

                    if (data.groupChatMembers?.length) {
                        try {
                            await db.groupChatMembers.clear();
                            const validGroupMembers = data.groupChatMembers.map(member => ({
                                ...member,
                                id: member.id || `member_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.groupChatMembers.bulkPut(validGroupMembers);
                            importedTables++;
                            console.log(`导入了 ${validGroupMembers.length} 条群聊成员`);
                        } catch (error) {
                            console.error('导入群聊成员失败:', error);
                            showToast('群聊成员导入失败: ' + error.message, 'warning');
                        }
                    }

                    // 🔥【新增】导入角色日记数据
                    if (data.characterDiaries?.length) {
                        try {
                            await db.characterDiaries.clear();
                            const validDiaries = data.characterDiaries.map(diary => ({
                                ...diary,
                                id: diary.id || `${diary.characterId}_${diary.date}`,
                                timestamp: diary.timestamp || new Date(diary.date).getTime(),
                                weather: diary.weather || '☀️'
                            }));
                            await db.characterDiaries.bulkPut(validDiaries);
                            importedTables++;
                            console.log(`导入了 ${validDiaries.length} 条角色日记`);
                        } catch (error) {
                            console.error('导入角色日记失败:', error);
                            showToast('角色日记导入失败: ' + error.message, 'warning');
                        }
                    }

                    // 🔥【架构修复】按正确顺序重新加载所有数据
                    console.log('🔄 开始重新加载所有数据...');

                    // 第一步：加载基础数据
                    await Promise.all([
                        loadCharacterGroups(),
                        loadCharacters(), // 先加载角色
                        loadChatMessages(),
                        loadChatSettings(),
                        loadPersonas(),
                        loadGroupChats(),
                        loadWallpaper(),
                        loadAppIcons(),
                        loadWorldbooks(),
                        loadMemoryConfig() // 加载记忆配置
                    ]);

                    // 第二步：从角色列表生成联系人（必须在角色加载完成后）
                    console.log('🔄 从角色列表重新生成联系人...');
                    await loadContacts();

                    console.log('✅ 所有数据重新加载完成');

                    // 🔥【关键修复】重新渲染所有界面
                    console.log('🔄 开始重新渲染界面...');
                    renderCharacterList();
                    renderMessageList(); // 🔥【关键】这应该现在显示对话框了
                    renderPersonaList();
                    calculateStorageUsage();
                    console.log('✅ 界面重新渲染完成');
                    
                    showToast(`🎉 导入成功！共导入 ${importedTables} 个数据表`, 'success');
                    console.log(`✅ 数据导入完成，共导入 ${importedTables} 个数据表`);

                    // 🔥【新增】延迟刷新页面以确保所有状态更新
                    setTimeout(() => {
                        console.log('🔄 强制刷新页面以确保所有状态更新...');
                        location.reload();
                    }, 2000);
                } catch (error) {
                    console.error('导入失败:', error);
                    showToast('导入失败：' + error.message, 'error');
                }
            };
            input.click();
        }

        // 显示清理选项
        function showCleanupOptions() {
            const choice = prompt('选择清理项目：\n1. 清除动态头像\n2. 删除空聊天记录\n3. 清理localStorage\n4. 压缩图片\n\n输入数字（逗号分隔）：');
            if (choice) executeCleanupOptions(choice);
        }

        // 执行清理
        async function executeCleanupOptions(choice) {
            const selections = choice.split(',').map(s => parseInt(s.trim())).filter(n => n >= 1 && n <= 4);
            if (!selections.length) return;
            
            showToast('清理中...', 'info');
            let count = 0;
            
            for (const option of selections) {
                switch (option) {
                    case 1:
                        Object.keys(chatSettings).forEach(id => {
                            if (chatSettings[id]?.aiDynamicAvatar) {
                                delete chatSettings[id].aiDynamicAvatar;
                                count++;
                            }
                        });
                        break;
                    case 2:
                        Object.keys(chatMessages).forEach(id => {
                            if (!chatMessages[id]?.length) {
                                delete chatMessages[id];
                                count++;
                            }
                        });
                        break;
                    case 3:
                        for (let i = localStorage.length - 1; i >= 0; i--) {
                            const key = localStorage.key(i);
                            if (key?.startsWith('chatSettings_')) {
                                localStorage.removeItem(key);
                                count++;
                            }
                        }
                        break;
                    case 4:
                        await compressAllImages();
                        break;
                }
            }
            
            await saveChatSettings();
            await saveChatMessages();
            calculateStorageUsage();
            showToast(`清理完成！处理 ${count} 项`, 'success');
        }

        // 压缩图片
        async function compressAllImages() {
            showToast('压缩中...', 'info');
            let count = 0;
            
            // 压缩角色头像
            for (const char of characters) {
                if (char.avatarUrl?.length > 50000) {
                    char.avatarUrl = await compressImage(char.avatarUrl, 150, 0.6);
                    count++;
                }
            }
            await saveCharacters();
            
            // 压缩设置中的头像
            for (const id of Object.keys(chatSettings)) {
                const settings = chatSettings[id];
                if (settings?.aiChatAvatar?.length > 50000) {
                    settings.aiChatAvatar = await compressImage(settings.aiChatAvatar, 150, 0.6);
                    count++;
                }
                if (settings?.myChatAvatar?.length > 50000) {
                    settings.myChatAvatar = await compressImage(settings.myChatAvatar, 150, 0.6);
                    count++;
                }
            }
            await saveChatSettings();
            calculateStorageUsage();
            showToast(`压缩完成！处理 ${count} 张图片`, 'success');
        }

        // 调试用：列出所有角色ID和名称，帮助识别幽灵角色
        async function debugListAllCharacters() {
            try {
                console.log('=== 所有角色数据 ===');
                
                // 1. 数据库中的角色
                const dbChars = await db.characters.toArray();
                console.log('数据库角色表:', dbChars.map(c => `${c.name} (ID: ${c.id})`));
                
                // 2. 内存中的角色
                if (window.characters) {
                    console.log('内存角色列表:', window.characters.map(c => `${c.name} (ID: ${c.id})`));
                }
                
                // 3. 联系人列表
                if (window.contacts) {
                    console.log('联系人ID列表:', window.contacts);
                }
                
                // 4. 动态评论中的角色
                const comments = await db.momentComments.toArray();
                const commentAuthors = [...new Set(comments.map(c => `${c.nickname} (ID: ${c.authorId})`))];
                console.log('动态评论中的角色:', commentAuthors);
                
                // 5. 动态点赞中的角色
                const likes = await db.momentLikes.toArray();
                const likeAuthors = [...new Set(likes.map(l => `${l.name} (ID: ${l.authorId})`))];
                console.log('动态点赞中的角色:', likeAuthors);
                
                return {dbChars, comments, likes};
            } catch (error) {
                console.error('调试失败:', error);
            }
        }
        
        // 调试用：精确删除指定ID的角色数据
        async function debugDeleteCharacterById(characterId) {
            if (!characterId) {
                console.log('用法: debugDeleteCharacterById("角色ID")');
                return;
            }
            
            try {
                console.log(`开始删除角色ID: ${characterId}`);
                let deleteCount = 0;
                
                // 1. 从动态评论中删除
                const comments = await db.momentComments.where('authorId').equals(characterId).toArray();
                for (const comment of comments) {
                    await db.momentComments.delete(comment.id);
                    deleteCount++;
                    console.log(`删除评论: ${comment.nickname} - ${comment.text}`);
                }
                
                // 2. 从动态点赞中删除
                const likes = await db.momentLikes.where('authorId').equals(characterId).toArray();
                for (const like of likes) {
                    await db.momentLikes.delete([like.momentId, like.authorId]);
                    deleteCount++;
                    console.log(`删除点赞: ${like.name}`);
                }
                
                // 3. 从其他表中删除
                const chatMsgs = await db.chatMessages.where('characterId').equals(characterId).toArray();
                for (const msg of chatMsgs) {
                    await db.chatMessages.delete(msg.id);
                    deleteCount++;
                }
                
                const chatSets = await db.chatSettings.toArray();
                for (const setting of chatSets) {
                    if (setting.characterId === characterId) {
                        await db.chatSettings.delete(setting.id);
                        deleteCount++;
                    }
                }
                
                await db.characters.delete(characterId);
                deleteCount++;
                
                // 4. 从内存数组中删除
                if (window.contacts) {
                    window.contacts = window.contacts.filter(id => id !== characterId);
                    await saveContacts();
                }
                if (window.characters) {
                    window.characters = window.characters.filter(char => char.id !== characterId);
                }
                
                console.log(`删除完成！共删除 ${deleteCount} 条相关数据`);
                
                // 刷新界面
                if (window.renderContactList) window.renderContactList();
                if (window.renderMessageList) window.renderMessageList();
                
            } catch (error) {
                console.error('删除失败:', error);
            }
        }
        
        // 强制删除指定角色（用于清理幽灵角色）
        async function forceDeleteCharacter() {
            const characterName = prompt('输入要强制删除的角色名称（如：方回）：');
            if (!characterName || !characterName.trim()) return;
            
            try {
                showToast(`正在强制删除角色 "${characterName}"...`, 'info');
                let deleteCount = 0;
                
                // 1. 从动态评论中删除
                const comments = await db.momentComments.toArray();
                for (const comment of comments) {
                    if (comment.nickname === characterName || (comment.authorId && comment.authorId.includes(characterName))) {
                        await db.momentComments.delete(comment.id);
                        deleteCount++;
                        console.log(`删除评论：${comment.nickname} - ${comment.text}`);
                    }
                }
                
                // 2. 从动态点赞中删除
                const likes = await db.momentLikes.toArray();
                for (const like of likes) {
                    if (like.name === characterName || (like.authorId && like.authorId.includes(characterName))) {
                        await db.momentLikes.delete([like.momentId, like.authorId]);
                        deleteCount++;
                        console.log(`删除点赞：${like.name}`);
                    }
                }
                
                // 3. 从聊天消息中删除
                const chatMsgs = await db.chatMessages.toArray();
                for (const msg of chatMsgs) {
                    if (msg.characterId && msg.characterId.includes(characterName)) {
                        await db.chatMessages.delete(msg.id);
                        deleteCount++;
                    }
                }
                
                // 4. 从聊天设置中删除
                const chatSets = await db.chatSettings.toArray();
                for (const setting of chatSets) {
                    if (setting.characterId && setting.characterId.includes(characterName)) {
                        await db.chatSettings.delete(setting.id);
                        deleteCount++;
                    }
                }
                
                // 5. 从characters表中删除
                const chars = await db.characters.toArray();
                for (const char of chars) {
                    if (char.name === characterName || char.id.includes(characterName)) {
                        await db.characters.delete(char.id);
                        deleteCount++;
                        console.log(`删除角色：${char.name} (${char.id})`);
                    }
                }
                
                // 6. 从联系人列表中删除
                if (window.contacts) {
                    window.contacts = window.contacts.filter(id => !id.includes(characterName));
                    await saveContacts();
                }
                
                // 7. 清理内存中的数据
                if (window.characters) {
                    window.characters = window.characters.filter(char => char.name !== characterName);
                }
                if (window.chatMessages) {
                    Object.keys(window.chatMessages).forEach(key => {
                        if (key.includes(characterName)) {
                            delete window.chatMessages[key];
                        }
                    });
                }
                if (window.chatSettings) {
                    Object.keys(window.chatSettings).forEach(key => {
                        if (key.includes(characterName)) {
                            delete window.chatSettings[key];
                        }
                    });
                }
                
                // 刷新界面
                if (window.renderContactList) window.renderContactList();
                if (window.renderMessageList) window.renderMessageList();
                
                showToast(`强制删除完成！共删除 ${deleteCount} 条相关数据`, 'success');
                console.log(`强制删除角色 "${characterName}" 完成，删除了 ${deleteCount} 条记录`);
                
            } catch (error) {
                console.error('强制删除失败:', error);
                showToast('强制删除失败: ' + error.message, 'error');
            }
        }

        // 清理孤立联系人和重复数据
        async function cleanupOrphanedContacts() {
            try {
                showToast('正在清理孤立数据...', 'info');
                
                let cleanupCount = 0;
                
                // 1. 清理联系人列表中不存在的角色ID
                const validCharacterIds = characters.map(char => char.id);
                const originalContactsLength = contacts.length;
                contacts = contacts.filter(contactId => {
                    const isValid = validCharacterIds.includes(contactId);
                    if (!isValid) cleanupCount++;
                    return isValid;
                });
                
                // 2. 从数据库中清理孤立的联系人记录
                const dbContacts = await db.contacts.toArray();
                for (const contact of dbContacts) {
                    if (!validCharacterIds.includes(contact.characterId)) {
                        await db.contacts.delete(contact.id);
                        cleanupCount++;
                    }
                }
                
                // 3. 清理聊天消息中不存在角色的记录
                const chatMessageKeys = Object.keys(chatMessages);
                for (const characterId of chatMessageKeys) {
                    if (!validCharacterIds.includes(characterId)) {
                        delete chatMessages[characterId];
                        cleanupCount++;
                    }
                }
                
                // 4. 清理数据库中孤立的聊天消息
                const dbChatMessages = await db.chatMessages.toArray();
                for (const msgRecord of dbChatMessages) {
                    if (!validCharacterIds.includes(msgRecord.characterId)) {
                        await db.chatMessages.delete(msgRecord.id);
                        cleanupCount++;
                    }
                }
                
                // 5. 清理聊天设置中不存在角色的记录
                const chatSettingsKeys = Object.keys(chatSettings);
                for (const characterId of chatSettingsKeys) {
                    if (!validCharacterIds.includes(characterId)) {
                        delete chatSettings[characterId];
                        cleanupCount++;
                    }
                }
                
                // 6. 清理数据库中孤立的聊天设置
                const dbChatSettings = await db.chatSettings.toArray();
                for (const setting of dbChatSettings) {
                    if (!validCharacterIds.includes(setting.characterId)) {
                        await db.chatSettings.delete(setting.id);
                        cleanupCount++;
                    }
                }
                
                // 7. 清理动态评论中不存在角色的记录
                const dbMomentComments = await db.momentComments.toArray();
                for (const comment of dbMomentComments) {
                    // 清理authorId不在角色列表中且不是用户的评论
                    if (comment.authorId !== 'user' && !validCharacterIds.includes(comment.authorId)) {
                        await db.momentComments.delete(comment.id);
                        cleanupCount++;
                        console.log(`删除了孤立评论：${comment.nickname}(${comment.authorId})`);
                    }
                }
                
                // 8. 清理动态点赞中不存在角色的记录
                const dbMomentLikes = await db.momentLikes.toArray();
                for (const like of dbMomentLikes) {
                    // 清理authorId不在角色列表中且不是用户的点赞
                    if (like.authorId !== 'user' && !validCharacterIds.includes(like.authorId)) {
                        await db.momentLikes.delete([like.momentId, like.authorId]);
                        cleanupCount++;
                        console.log(`删除了孤立点赞：${like.name}(${like.authorId})`);
                    }
                }
                
                // 9. 保存清理后的数据
                await Promise.all([
                    saveContacts(),
                    saveChatMessages(),
                    saveChatSettings()
                ]);
                
                // 10. 重新渲染界面
                renderContactList();
                renderMessageList();
                
                showToast(`清理完成！共清理了 ${cleanupCount} 条孤立数据`, 'success');
                
                console.log('清理结果:', {
                    有效角色数: validCharacterIds.length,
                    清理前联系人数: originalContactsLength,
                    清理后联系人数: contacts.length,
                    总清理项目: cleanupCount
                });
                
            } catch (error) {
                console.error('清理孤立数据失败:', error);
                showToast('清理失败: ' + error.message, 'error');
            }
        }
        
        // 清空所有数据
        async function clearAllData() {
            const confirm = prompt('警告：将删除所有数据且无法恢复！\n输入"清空所有数据"确认：');
            if (confirm !== '清空所有数据') return;
            
            try {
                showToast('清空中...', 'info');
                
                // 清空所有数据库表
                await Promise.all([
                    db.characters.clear(),
                    db.chatMessages.clear(), 
                    db.chatSettings.clear(),
                    db.customEmojis.clear(),
                    db.worldbooks.clear() // 确保也清空世界书数据
                ]);
                
                // 重置内存中的全局变量
                characters = [];
                chatMessages = {};
                chatSettings = {};
                customEmojis = [];
                contacts = [];
                groupChats = [];
                currentChatCharacter = null;
                
                // 清理localStorage中的备份数据
                for (let i = localStorage.length - 1; i >= 0; i--) {
                    const key = localStorage.key(i);
                    // 清除所有聊天设置和其他应用数据
                    if (key?.startsWith('chatSettings_') || 
                        key?.startsWith('contacts') || 
                        key?.startsWith('characters') || 
                        key?.startsWith('chatMessages')) {
                        localStorage.removeItem(key);
                    }
                }
                
                // 刷新界面
                renderCharacterList();
                renderMessageList();
                renderContactList();
                calculateStorageUsage();
                
                showToast('已清空所有数据', 'success');
                console.log('✅ 所有数据已清空，包括聊天设置、角色数据、聊天记录和世界书');
                
                // 返回主界面
                setTimeout(() => {
                    hideApp('data-management-screen');
                    hideApp('settings-screen');
                    showApp('chat-screen');
                }, 2000);
            } catch (error) {
                console.error('清空数据失败:', error);
                showToast('清空失败: ' + error.message, 'error');
            }
        }

        // 重复函数已删除

        // 转账相关变量
        let currentTransferMsg = null;
        
        // 处理用户发送给AI的转账
        async function processUserTransfer(userTransferMsg, aiMessages) {
            console.log('🚀 processUserTransfer 被调用:', {
                userTransferMsg,
                aiMessages,
                currentCharacter: currentChatCharacter?.name
            });
            
            if (!userTransferMsg || !currentChatCharacter) {
                console.log('❌ processUserTransfer 退出：缺少必要参数');
                return;
            }
            
            const messages = chatMessages[currentChatCharacter.id] || [];
            
            // 分析AI的回复内容，判断是否有转账相关操作
            let transferAction = null;
            let transferActionReason = '';
            
            for (const msgData of aiMessages) {
                // 检查AI是否在回复中明确处理了转账
                if (typeof msgData === 'object' && msgData.type === 'transfer_action') {
                    transferAction = msgData.action; // 'accept', 'reject', 'ignore'
                    transferActionReason = msgData.reason || '';
                    break;
                }
                
                // 检查AI的普通回复中是否包含转账处理的关键词
                if (typeof msgData === 'string') {
                    const content = msgData.toLowerCase();
                    console.log('🔥 [转账处理] 分析AI回复内容:', content);

                    // 🔥【修复】更精确的收款关键词检测，避免误判
                    const acceptKeywords = [
                        '收下', '收款', '接受', '确认收款', '已收款', '收到了',
                        '谢谢你', '感谢你', '太好了', '真贴心', '好贴心'
                    ];

                    // 🔥【修复】更精确的拒收关键词检测，避免误判
                    const rejectKeywords = [
                        '退回', '拒绝', '不收', '不需要', '不能收', '不要你的钱',
                        '我不收', '退给你', '不用给我', '算了吧', '不要这样'
                    ];

                    // 检查收款意图
                    const hasAcceptKeyword = acceptKeywords.some(keyword => content.includes(keyword));
                    // 检查拒收意图
                    const hasRejectKeyword = rejectKeywords.some(keyword => content.includes(keyword));

                    if (hasAcceptKeyword && !hasRejectKeyword) {
                        transferAction = 'accept';
                        transferActionReason = '角色同意收款';
                        console.log('🔥 [转账处理] 检测到收款关键词，设置为accept');
                        break;
                    } else if (hasRejectKeyword && !hasAcceptKeyword) {
                        transferAction = 'reject';
                        transferActionReason = '角色拒绝收款';
                        console.log('🔥 [转账处理] 检测到拒绝关键词，设置为reject');
                        break;
                    } else if (hasAcceptKeyword && hasRejectKeyword) {
                        // 如果同时包含收款和拒收关键词，需要更仔细的分析
                        console.log('🔥 [转账处理] 同时检测到收款和拒收关键词，保持pending状态');
                    } else {
                        console.log('🔥 [转账处理] 未检测到明确的转账处理关键词');
                    }
                }
            }
            
            // 如果AI明确表示了转账处理意图，则执行相应操作
            console.log('🔥 [转账处理] 最终转账操作决定:', transferAction);
            if (transferAction === 'accept' || transferAction === 'reject') {
                const transferIndex = messages.findIndex(msg => 
                    msg.timestamp === userTransferMsg.timestamp && msg.type === 'transfer' && msg.sender === 'sent');
                    
                if (transferIndex !== -1) {
                    // 更新转账状态
                    const newStatus = transferAction === 'accept' ? 'accepted' : 'rejected';
                    messages[transferIndex].status = newStatus;
                    
                    console.log('✅ 转账状态已更新:', {
                        oldStatus: userTransferMsg.status,
                        newStatus: newStatus,
                        message: messages[transferIndex]
                    });
                    
                    // 保存到数据库
                    await saveChatMessages();
                    
                    // 添加系统消息
                    const actionText = transferAction === 'accept' ? '已收款' : '已退回';
                    const systemMsg = {
                        id: Date.now().toString(),
                        sender: 'system',
                        content: `${currentChatCharacter.name}${actionText} ¥${Number(userTransferMsg.amount).toFixed(2)}`,
                        timestamp: Date.now()
                    };
                    
                    messages.push(systemMsg);
                    await saveChatMessages();
                    
                    console.log('📱 系统消息已添加:', systemMsg);
                    
                    // 立即重新渲染聊天界面以显示更新
                    renderChatMessages(currentChatCharacter.id);
                    
                    // 显示确认提示
                    const toastText = transferAction === 'accept' ? '转账已被接受' : '转账已被退回';
                    showToast(toastText, 'success');
                    
                    console.log('🎉 转账处理完成');
                } else {
                    console.error('❌ 未找到对应的转账消息');
                }
            } else {
                console.log('ℹ️ AI没有明确表态，转账保持pending状态');
            }
            // 如果AI没有明确表态，转账保持pending状态，等待用户手动处理或下次AI回复
        }
        
        // 转账相关函数
        function sendTransfer() {
            const amount = parseFloat(document.getElementById('transfer-amount').value);
            const note = document.getElementById('transfer-note').value.trim();
            
            if (!amount || amount <= 0) {
                showToast('请输入有效的转账金额', 'warning');
                return;
            }
            
            if (amount > 1000000000) {
                showToast('转账金额不能超过10亿元', 'warning');
                return;
            }
            
            // 创建转账消息 - 修复数据结构和设置pendingUserMessage
            const transferMessage = {
                id: Date.now().toString(),
                sender: 'sent',  // 修复：使用 sender 而不是 role
                type: 'transfer',
                amount: amount,
                note: note || '转账',
                timestamp: Date.now()
            };
            
            // 添加到聊天记录
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            chatMessages[currentChatCharacter.id].push(transferMessage);
            
            // 保存到数据库
            saveChatMessages();
            
            // 使用动画添加消息而不是重新渲染整个列表
            addMessageWithAnimation(transferMessage, currentChatCharacter.id);
            
            // 🔥 【关键修复】设置为待回复消息，让AI能看到转账
            pendingUserMessage = transferMessage;
            
            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = '点击获取AI回复';
            }
            
            // 更新联系人列表
            renderMessageList();
            
            // 关闭转账对话框
            document.getElementById('transfer-modal').classList.remove('visible');
            
            // 清空输入框
            document.getElementById('transfer-amount').value = '';
            document.getElementById('transfer-note').value = '';
            
            showToast('转账已发送', 'success');
        }
        
        function showTransferConfirmDialog(transferMsg) {
            if (!transferMsg || transferMsg.status) return;
            
            const modal = document.getElementById('transfer-confirm-modal');
            const amountEl = modal.querySelector('.transfer-confirm-amount');
            const noteEl = modal.querySelector('.transfer-confirm-note');
            
            // 设置转账信息
            amountEl.textContent = `¥ ${Number(transferMsg.amount).toFixed(2)}`;
            noteEl.textContent = `备注：${transferMsg.note || '无'}`;
            
            // 存储当前处理的转账信息
            currentTransferMsg = transferMsg;
            
            // 显示对话框
            modal.classList.add('visible');
        }
        
        async function acceptTransfer() {
            if (!currentTransferMsg || !currentChatCharacter) return;
            
            // 在聊天记录中找到对应的转账消息并更新状态
            const messages = chatMessages[currentChatCharacter.id] || [];
            const transferIndex = messages.findIndex(msg => 
                msg.timestamp === currentTransferMsg.timestamp && msg.type === 'transfer');
                
            if (transferIndex !== -1) {
                // 更新转账状态
                messages[transferIndex].status = 'accepted';
                
                // 保存到数据库
                await saveChatMessages();
                
                // 重新渲染聊天界面
                renderChatMessages(currentChatCharacter.id);
                
                // 添加一条系统消息，表示已收款
                const systemMsg = {
                    id: Date.now().toString(),
                    sender: 'system',
                    content: `你已确认收款 ¥${Number(currentTransferMsg.amount).toFixed(2)}`,
                    timestamp: Date.now()
                };
                
                messages.push(systemMsg);
                await saveChatMessages();
                renderChatMessages(currentChatCharacter.id);
            }
            
            // 关闭对话框
            document.getElementById('transfer-confirm-modal').classList.remove('visible');
            currentTransferMsg = null;
            
            showToast('已确认收款', 'success');
        }
        
        async function rejectTransfer() {
            if (!currentTransferMsg || !currentChatCharacter) return;
            
            // 在聊天记录中找到对应的转账消息并更新状态
            const messages = chatMessages[currentChatCharacter.id] || [];
            const transferIndex = messages.findIndex(msg => 
                msg.timestamp === currentTransferMsg.timestamp && msg.type === 'transfer');
                
            if (transferIndex !== -1) {
                // 更新转账状态
                messages[transferIndex].status = 'rejected';
                
                // 保存到数据库
                await saveChatMessages();
                
                // 重新渲染聊天界面
                renderChatMessages(currentChatCharacter.id);
                
                // 添加一条系统消息，表示已退回
                const systemMsg = {
                    id: Date.now().toString(),
                    sender: 'system',
                    content: `你已退回 ¥${Number(currentTransferMsg.amount).toFixed(2)}`,
                    timestamp: Date.now()
                };
                
                messages.push(systemMsg);
                await saveChatMessages();
                renderChatMessages(currentChatCharacter.id);
            }
            
            // 关闭对话框
            document.getElementById('transfer-confirm-modal').classList.remove('visible');
            currentTransferMsg = null;
            
            showToast('已退回转账', 'success');
        }

        // 监听app显示事件
        const originalShowApp = window.showApp;
        if (originalShowApp) {
            window.showApp = function(appId) {
                originalShowApp(appId);
                if (appId === 'data-management-screen') calculateStorageUsage();
            };
        }

        // 显示定时发布时间设置模态框
        function showScheduleTimesModal() {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            const scheduleTimes = chatSettings.scheduledMomentsTimes || [];
            
            const container = document.getElementById('schedule-times-modal-container');
            container.innerHTML = '';
            
            // 渲染已有时间点
            scheduleTimes.forEach((time, index) => {
                const timeItem = document.createElement('div');
                timeItem.className = 'schedule-time-item';
                timeItem.style.cssText = `
                    display: flex;
                    align-items: center;
                    margin-bottom: 10px;
                    gap: 10px;
                `;
                timeItem.innerHTML = `
                    <input type="time" value="${time}" onchange="updateScheduleTime(${index}, this.value)" 
                           style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 6px;">
                    <button onclick="removeScheduleTime(${index})" 
                            style="padding: 8px 12px; background: #ff3b30; color: white; border: none; border-radius: 6px; cursor: pointer;">×</button>
                `;
                container.appendChild(timeItem);
            });
            
            showModal('schedule-times-modal');
        }
        
        // 添加定时发布时间点
        function addScheduleTime() {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            if (!chatSettings.scheduledMomentsTimes) {
                chatSettings.scheduledMomentsTimes = [];
            }
            
            if (chatSettings.scheduledMomentsTimes.length >= 10) {
                alert('最多只能设置10个时间点');
                return;
            }
            
            chatSettings.scheduledMomentsTimes.push('09:00');
            saveCurrentChatSettings(chatSettings);
            showScheduleTimesModal(); // 重新渲染
        }
        
        // 更新定时发布时间点
        function updateScheduleTime(index, newTime) {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.scheduledMomentsTimes && chatSettings.scheduledMomentsTimes[index] !== undefined) {
                chatSettings.scheduledMomentsTimes[index] = newTime;
                saveCurrentChatSettings(chatSettings);
            }
        }
        
        // 移除定时发布时间点
        function removeScheduleTime(index) {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.scheduledMomentsTimes && chatSettings.scheduledMomentsTimes[index] !== undefined) {
                chatSettings.scheduledMomentsTimes.splice(index, 1);
                saveCurrentChatSettings(chatSettings);
                showScheduleTimesModal(); // 重新渲染
            }
        }
        
        // 保存定时发布设置
        function saveScheduleTimes() {
            if (!currentChatCharacter) return;
            
            const container = document.getElementById('schedule-times-modal-container');
            const timeInputs = container.querySelectorAll('input[type="time"]');
            const times = Array.from(timeInputs).map(input => input.value).filter(time => time);
            
            const chatSettings = getCurrentChatSettings();
            chatSettings.scheduledMomentsTimes = times;
            saveCurrentChatSettings(chatSettings);
            
            updateScheduleTimesDisplay();
            hideModal('schedule-times-modal');
            
            // 重新初始化全局动态发布系统以应用新设置
            setTimeout(async () => {
                try {
                    await initGlobalMomentsSystem();
                    console.log('✅ 定时发布设置已更新');
                } catch (error) {
                    console.error('❌ 更新定时发布设置失败:', error);
                }
            }, 500);
            
            showToast(`已保存 ${times.length} 个定时发布时间点`, 'success');
        }
        
        // 更新定时发布时间显示
        function updateScheduleTimesDisplay() {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            const scheduleTimes = chatSettings.scheduledMomentsTimes || [];
            const displayElement = document.getElementById('schedule-times-display');
            
            if (scheduleTimes.length === 0) {
                displayElement.textContent = '未设置';
            } else if (scheduleTimes.length === 1) {
                displayElement.textContent = `1个时间点 (${scheduleTimes[0]})`;
            } else {
                displayElement.textContent = `${scheduleTimes.length}个时间点`;
            }
        }
        
        // 测试发布动态
        async function testPublishMoment() {
            if (!currentChatCharacter) {
                alert('请先选择一个角色');
                return;
            }
            
            const button = document.querySelector('button[onclick="testPublishMoment()"]');
            const originalText = button.textContent;
            button.textContent = '发布中...';
            button.disabled = true;
            
            try {
                await triggerBackgroundMomentsTest(currentChatCharacter.id);
                showToast('测试动态发布成功！', 'success');
            } catch (error) {
                console.error('测试发布失败:', error);
                showToast('测试发布失败', 'error');
            } finally {
                button.textContent = originalText;
                button.disabled = false;
            }
        }
        
        // 初始化定时发布系统
        function initScheduledMomentsSystem() {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            if (!chatSettings.scheduledMomentsEnabled || !chatSettings.scheduledMomentsTimes?.length) {
                return;
            }
            
            // 为每个设定时间创建定时器
            chatSettings.scheduledMomentsTimes.forEach(time => {
                if (!time) return;
                
                const [hours, minutes] = time.split(':').map(Number);
                const now = new Date();
                const scheduledTime = new Date();
                
                scheduledTime.setHours(hours, minutes, 0, 0);
                
                // 如果时间已过，设置为明天
                if (scheduledTime <= now) {
                    scheduledTime.setDate(scheduledTime.getDate() + 1);
                }
                
                const delay = scheduledTime.getTime() - now.getTime();
                
                setTimeout(() => {
                    // 执行定时发布
                    triggerBackgroundMoments(currentChatCharacter.id);
                    
                    // 设置每24小时重复执行
                    setInterval(() => {
                        triggerBackgroundMoments(currentChatCharacter.id);
                    }, 24 * 60 * 60 * 1000);
                }, delay);
            });
        }

        // 🔥【新增】推送通知功能
        // 🔥【新增】通知队列和单个通知管理
        let notificationQueue = [];
        let currentNotification = null;
        let isProcessingQueue = false;

        // 🔥【修复】创建推送通知 - 改为队列方式，单个显示
        function createPushNotification(character, messageData, delay = 0) {
            // 🔥【修复】检查用户是否在和该角色的聊天界面 - 更精确的判断

            // 方法1：检查主屏幕是否可见
            const phoneScreen = document.getElementById('phone-screen');
            const isOnMainScreen = phoneScreen && window.getComputedStyle(phoneScreen).display !== 'none';

            // 方法2：检查聊天界面是否可见
            const chatScreen = document.getElementById('api-chat-screen');
            const isChatVisible = chatScreen && window.getComputedStyle(chatScreen).display !== 'none';

            // 方法3：检查用户是否在和该角色聊天
            const isChattingWithThisCharacter = isChatVisible && currentChatCharacter && currentChatCharacter.id === character.id;

            console.log('🔔 [推送通知] 检查界面状态:', {
                mainScreenVisible: isOnMainScreen,
                chatScreenVisible: isChatVisible,
                currentChatCharacter: currentChatCharacter?.name,
                messageFromCharacter: character.name,
                isChattingWithThisCharacter: isChattingWithThisCharacter,
                shouldShowNotification: isOnMainScreen && !isChattingWithThisCharacter
            });

            // 🔥【修复】只有当用户不在和该角色的聊天界面时才显示推送
            // 用户可能在主屏幕、其他应用、或者和其他角色聊天，这些情况都应该显示推送
            if (!isOnMainScreen || isChattingWithThisCharacter) {
                console.log('🔔 [推送通知] 用户不在主屏幕或正在和该角色聊天，不显示推送');
                return;
            }
            
            // 添加到队列
            notificationQueue.push({
                character,
                messageData,
                delay
            });
            
            console.log('🔔 [推送通知] 添加通知到队列，当前队列长度:', notificationQueue.length);
            
            // 开始处理队列
            processNotificationQueue();
        }

        // 🔥【新增】处理通知队列
        function processNotificationQueue() {
            if (isProcessingQueue || notificationQueue.length === 0) {
                return;
            }
            
            isProcessingQueue = true;
            console.log('🔔 [推送通知] 开始处理队列，剩余通知数:', notificationQueue.length);
            
            const processNext = () => {
                if (notificationQueue.length === 0) {
                    isProcessingQueue = false;
                    console.log('🔔 [推送通知] 队列处理完成');
                    return;
                }
                
                const { character, messageData, delay } = notificationQueue.shift();
                
                setTimeout(() => {
                    showSingleNotification(character, messageData);

                    // 🔥【修复】增加通知间隔到2.6秒，确保用户有足够时间看完当前通知
                    setTimeout(() => {
                        processNext();
                    }, 2600);
                }, delay);
            };
            
            processNext();
        }

        // 🔥【新增】显示单个通知
        function showSingleNotification(character, messageData) {
            console.log('🔔 [推送通知] 显示单个通知，角色:', character.name);
            
            const container = document.getElementById('notification-container');
            if (!container) {
                console.error('🔔 [推送通知] 找不到通知容器!');
                return;
            }
            
            // 如果有现有通知，先移除
            if (currentNotification) {
                hideNotification(currentNotification, true);
            }
            
            // 创建通知元素
            const notification = document.createElement('div');
            notification.className = 'push-notification';
            currentNotification = notification;
            
            // 生成通知内容
            let notificationText = '';
            let notificationType = 'message';
            let senderName = character.name;
            
            if (typeof messageData === 'string') {
                notificationText = messageData;
            } else if (typeof messageData === 'object') {
                // 🔥【修复】处理群聊消息格式
                if (messageData.name && messageData.message) {
                    // 群聊消息格式: {name: "角色名", message: "消息内容"}
                    senderName = messageData.name;
                    
                    if (typeof messageData.message === 'string') {
                        notificationText = messageData.message;
                    } else if (typeof messageData.message === 'object' && messageData.message.type) {
                        // 群聊中的特殊消息类型
                        switch (messageData.message.type) {
                            case 'transfer':
                                notificationText = `向你转账了 ¥${messageData.message.amount}`;
                                notificationType = 'transfer';
                                break;
                            case 'voice_message':
                                notificationText = '[语音消息]';
                                notificationType = 'voice';
                                break;
                            default:
                                notificationText = messageData.message.content || '[消息]';
                        }
                    } else {
                        notificationText = String(messageData.message);
                    }
                } else if (messageData.type) {
                    // 普通的特殊消息类型
                    switch (messageData.type) {
                        case 'transfer':
                            notificationText = `向你转账了 ¥${messageData.amount}`;
                            notificationType = 'transfer';
                            break;
                        case 'voice_message':
                            notificationText = '[语音消息]';
                            notificationType = 'voice';
                            break;
                        case 'ai_image':
                            notificationText = '[图片]';
                            notificationType = 'image';
                            break;
                        case 'emoji':
                            notificationText = `发送了表情包：${messageData.description}`;
                            notificationType = 'emoji';
                            break;
                        default:
                            notificationText = messageData.content || '[消息]';
                    }
                } else {
                    notificationText = messageData.content || messageData.message || '[消息]';
                }
            }
            
            // 限制通知文本长度
            if (notificationText.length > 25) {
                notificationText = notificationText.substring(0, 25) + '...';
            }
            
            // 生成时间
            const now = new Date();
            const timeString = now.toLocaleTimeString('zh-CN', { 
                hour: '2-digit', 
                minute: '2-digit' 
            });
            
            // 设置通知HTML
            notification.innerHTML = `
                <img class="notification-avatar" src="${character.avatarUrl || 'https://via.placeholder.com/28'}" alt="${senderName}">
                <div class="notification-content">
                    <div class="notification-title">${senderName}</div>
                    <div class="notification-message">${notificationText}</div>
                </div>
                <div class="notification-time">${timeString}</div>
            `;
            
            // 点击通知打开聊天
            notification.onclick = () => {
                console.log('🔔 [推送通知] 用户点击了推送通知，跳转到聊天界面');
                
                // 如果有角色信息，确保切换到对应角色
                if (character && character.id) {
                    console.log('🔔 [推送通知] 切换到角色:', character.name, character.id);
                    // 设置当前聊天角色
                    currentChatCharacter = character;
                    // 更新聊天界面标题
                    const chatTitle = document.getElementById('api-chat-title');
                    if (chatTitle) {
                        // 🔥【修复】群聊标题显示成员数量
                        let displayTitle = character.name;
                        if (character.isGroup && character.members) {
                            const memberCount = character.members.length + 1; // +1 包括用户自己
                            displayTitle = `${character.name}（${memberCount}）`;
                        }
                        chatTitle.textContent = displayTitle;
                    }
                    // 渲染该角色的聊天记录
                    renderChatMessages(character.id);
                }
                
                // 切换到聊天界面
                showApp('api-chat-screen');
                
                // 移除通知
                hideNotification(notification);
                
                console.log('🔔 [推送通知] 跳转完成');
            };
            
            // 添加到容器
            container.appendChild(notification);
            
            // 显示动画
            setTimeout(() => {
                notification.classList.add('show');
            }, 50);
            
            // 🔥【修复】自动隐藏 - 增加显示时长
            setTimeout(() => {
                if (currentNotification === notification) {
                    hideNotification(notification);
                }
            }, 2300);
        }
        
        function hideNotification(notification, immediate = false) {
            if (notification && notification.parentNode) {
                notification.classList.remove('show');
                notification.classList.add('hide');
                
                // 如果是当前通知，清除引用
                if (currentNotification === notification) {
                    currentNotification = null;
                }
                
                const removeDelay = immediate ? 0 : 250;
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, removeDelay);
            }
        }
        
        // 🔥【新增】为动态互动创建推送通知
        function createMomentInteractionNotification(character, interactionType, momentText) {
            let notificationText = '';
            switch (interactionType) {
                case 'like':
                    notificationText = `赞了你的动态`;
                    break;
                case 'comment':
                    notificationText = `评论了你的动态`;
                    break;
                default:
                    notificationText = `与你的动态互动了`;
            }
            
            createPushNotification(character, notificationText);
        }

        // 🔥【新增】页面卸载时标记当前聊天为已读
        window.addEventListener('beforeunload', function() {
            // 如果用户正在聊天界面，标记当前聊天的消息为已读
            if (currentChatCharacter) {
                markAsRead(currentChatCharacter.id);
                console.log('🔥 [页面卸载] 标记当前聊天为已读:', currentChatCharacter.name);
            } else {
                // 🔥【新增】如果currentChatCharacter为空，尝试从sessionStorage恢复
                const savedChatId = sessionStorage.getItem('currentChatCharacterId');
                if (savedChatId) {
                    markAsRead(savedChatId);
                    console.log('🔥 [页面卸载] 从sessionStorage恢复并标记聊天为已读:', savedChatId);
                }
            }
            // 清除保存的聊天状态
            sessionStorage.removeItem('currentChatCharacterId');
        });

        // 🔥【新增】页面隐藏时也标记当前聊天为已读（处理移动端切换应用的情况）
        document.addEventListener('visibilitychange', function() {
            if (document.hidden && currentChatCharacter) {
                markAsRead(currentChatCharacter.id);
                console.log('🔥 [页面隐藏] 标记当前聊天为已读:', currentChatCharacter.name);
            }
        });

        // 🔥【新增】页面失去焦点时也标记当前聊天为已读（处理切换标签页的情况）
        window.addEventListener('blur', function() {
            if (currentChatCharacter) {
                markAsRead(currentChatCharacter.id);
                console.log('🔥 [页面失焦] 标记当前聊天为已读:', currentChatCharacter.name);
            }
        });

        // 初始化转账功能事件监听器
        document.addEventListener('DOMContentLoaded', function() {
            // 添加转账相关事件监听器
            document.getElementById('transfer-cancel-btn')?.addEventListener('click', () => {
                document.getElementById('transfer-modal').classList.remove('visible');
            });

            document.getElementById('transfer-confirm-btn')?.addEventListener('click', sendTransfer);
            document.getElementById('transfer-accept-btn')?.addEventListener('click', acceptTransfer);
            document.getElementById('transfer-reject-btn')?.addEventListener('click', rejectTransfer);

            // 点击模态框背景关闭
            document.getElementById('transfer-modal')?.addEventListener('click', (e) => {
                if (e.target === document.getElementById('transfer-modal')) {
                    document.getElementById('transfer-modal').classList.remove('visible');
                }
            });
            
            document.getElementById('transfer-confirm-modal')?.addEventListener('click', (e) => {
                if (e.target === document.getElementById('transfer-confirm-modal')) {
                    document.getElementById('transfer-confirm-modal').classList.remove('visible');
                    currentTransferMsg = null;
                }
            });
        });

        // 群聊相关函数
        function updateGroupChatInfo() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            
            // 更新群聊头像预览
            const groupAvatarPreview = document.getElementById('group-avatar-preview');
            if (groupAvatarPreview) {
                if (currentChatCharacter.avatarUrl) {
                    groupAvatarPreview.src = currentChatCharacter.avatarUrl;
                } else {
                    // 使用默认的群聊头像 - 创建一个简单的Canvas头像
                    const canvas = document.createElement('canvas');
                    canvas.width = 40;
                    canvas.height = 40;
                    const ctx = canvas.getContext('2d');
                    
                    // 绘制蓝色圆形背景
                    ctx.beginPath();
                    ctx.arc(20, 20, 20, 0, 2 * Math.PI);
                    ctx.fillStyle = '#4a84c1';
                    ctx.fill();
                    
                    // 绘制白色"群"字
                    ctx.fillStyle = 'white';
                    ctx.font = '18px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('群', 20, 20);
                    
                    groupAvatarPreview.src = canvas.toDataURL();
                }
            }
            
            // 更新群聊名称显示
            const groupNameDisplay = document.getElementById('group-name-display');
            if (groupNameDisplay) {
                groupNameDisplay.textContent = currentChatCharacter.name || '群聊名称';
            }
            
            // 更新群成员数量显示
            const groupMemberCountDisplay = document.getElementById('group-member-count-display');
            if (groupMemberCountDisplay) {
                const memberCount = currentChatCharacter.members ? currentChatCharacter.members.length : 0;
                // 群成员数量 = 角色数量 + 1个用户
                const totalMemberCount = memberCount + 1;
                groupMemberCountDisplay.textContent = `${totalMemberCount}名成员`;
            }
            
            // 更新群公告显示
            const groupDescriptionDisplay = document.getElementById('group-description-display');
            if (groupDescriptionDisplay) {
                groupDescriptionDisplay.textContent = currentChatCharacter.description || '群公告：点击设置群公告';
            }
            
            // 更新我在群里的昵称 - 使用当前选择的面具名称作为默认值
            const currentMyGroupNickname = document.getElementById('current-my-group-nickname');
            if (currentMyGroupNickname) {
                let defaultNickname = '未选择';
        
        // --- 新增代码开始 ---
        const chatSettings = getCurrentChatSettings();
        const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
        // --- 新增代码结束 ---

                // 如果用户选择了面具，使用面具名称
        if (selectedPersona && selectedPersona.name) { // <--- 修改这里
            defaultNickname = selectedPersona.name;
                }
        
        // 优先显示用户在群聊中自己设置的昵称，如果没有，则显示创建群聊时选择的身份昵称
        currentMyGroupNickname.textContent = chatSettings.myChatNickname || defaultNickname;
            }
            
            // 渲染群成员网格
            renderGroupMembersGrid();
        }
        
        function changeGroupAvatar() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            
            const tempInput = document.createElement('input');
            tempInput.type = 'file';
            tempInput.accept = 'image/*,.jpg,.jpeg,.png,.gif,.webp';
            tempInput.style.display = 'none';
            document.body.appendChild(tempInput);
            
            tempInput.onchange = function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = async function(event) {
                        // 更新当前群聊角色的头像
                        currentChatCharacter.avatarUrl = event.target.result;
                        
                        // 如果是群聊，需要更新群聊数据
                        if (groupChats) {
                            const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                            if (groupIndex !== -1) {
                                groupChats[groupIndex].avatarUrl = event.target.result;
                                await saveGroupChats(groupChats);
                            }
                        }
                        
                        // 更新UI显示
                        updateGroupChatInfo();

                        // 🔥【修复】群聊标题显示成员数量
                        let displayTitle = currentChatCharacter.name;
                        if (currentChatCharacter.members) {
                            const memberCount = currentChatCharacter.members.length + 1; // +1 包括用户自己
                            displayTitle = `${currentChatCharacter.name}（${memberCount}）`;
                        }
                        document.getElementById('api-chat-title').textContent = displayTitle;
                        
                        // 更新头像显示
                        const chatAvatarElement = document.querySelector('#api-chat-screen .message-avatar img');
                        if (chatAvatarElement) {
                            chatAvatarElement.src = event.target.result;
                        }
                        
                        // 更新消息列表和联系人列表中的群聊头像
                        renderContactList();
                        renderMessageList();
                        
                        document.body.removeChild(tempInput);
                    };
                    reader.readAsDataURL(e.target.files[0]);
                } else {
                    document.body.removeChild(tempInput);
                }
            };
            
            tempInput.click();
        }
        
        function changeGroupName() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            
            const newName = prompt('请输入新的群聊名称:', currentChatCharacter.name);
            if (newName && newName.trim() !== '') {
                const trimmedName = newName.trim();
                
                // 更新当前群聊角色的名称
                currentChatCharacter.name = trimmedName;
                
                // 如果是群聊，需要更新群聊数据
                if (groupChats) {
                    const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                    if (groupIndex !== -1) {
                        groupChats[groupIndex].name = trimmedName;
                        saveGroupChats(groupChats);
                    }
                }
                
                // 更新UI显示
                updateGroupChatInfo();

                // 🔥【修复】群聊标题显示成员数量
                let displayTitle = trimmedName;
                if (currentChatCharacter.members) {
                    const memberCount = currentChatCharacter.members.length + 1; // +1 包括用户自己
                    displayTitle = `${trimmedName}（${memberCount}）`;
                }
                document.getElementById('api-chat-title').textContent = displayTitle;
                renderContactList();
                renderMessageList();
            }
        }
        
// --- 请从这里开始复制，替换掉旧的 showGroupChatMemberSelection 和 renderGroupMembersGrid 函数 ---

// 5. 显示群成员选择 (已修正版本)
function showGroupChatMemberSelection(personaId) {
    console.log('✅ 第二个showGroupChatMemberSelection被调用，接收到的personaId:', personaId);
    
    // 立即将personaId存储到全局变量中，确保不会丢失
    window.currentGroupPersonaId = personaId;
    
    // 重置表单
    document.getElementById('group-chat-name').value = '';
    selectedGroupMembers = [];
    
    const membersContainer = document.getElementById('group-chat-members');
    membersContainer.innerHTML = '';
    
    if (characters.length < 2) {
        membersContainer.innerHTML = '<p class="empty-mount-chats">至少需要2个角色才能创建群聊</p>';
    } else {
        characters.forEach(character => {
            const memberItem = document.createElement('div');
            memberItem.className = 'group-member-item';
            memberItem.onclick = () => toggleGroupMemberSelection(character.id);
            // 关键修复：重新添加了显示角色简介的HTML代码
            memberItem.innerHTML = `
                <div class="group-member-checkbox" id="checkbox-${character.id}"></div>
                <div class="message-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url('${character.avatarUrl}'); background-size: cover; background-position: center;` : ''}">
                    ${character.avatarUrl ? '' : character.name.charAt(0)}
                </div>
                <div class="chat-option-text">
                    <div class="chat-option-title">${character.name}</div>
                    <div class="chat-option-desc">${truncateText(character.bio || '暂无简介', 80)}</div>
                </div>`;
            membersContainer.appendChild(memberItem);
        });
    }

    // 将 personaId 附加到创建按钮上
    console.log('✅ 在第二个位置绑定创建按钮，personaId:', personaId);
    const createBtn = document.getElementById('group-chat-modal').querySelector('.modal-primary');
    createBtn.onclick = () => {
        console.log('✅ 第二个位置的创建群聊按钮被点击，直接使用参数personaId:', personaId);
        createGroupChat(personaId);
    }; // 绑定带参数的创建函数

    showModal('group-chat-modal');
}


// 渲染群成员网格 (已修正版本)
        function renderGroupMembersGrid() {
            const groupMembersGrid = document.getElementById('group-members-grid');
            if (!groupMembersGrid || !currentChatCharacter || !currentChatCharacter.isGroup) return;
            
            // 清空现有内容
            groupMembersGrid.innerHTML = '';
            
    // --- 关键修复：正确获取并显示用户在当前群聊中的身份 ---
    const chatSettings = getCurrentChatSettings(); // 获取当前群聊的专属设置
    const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
    
            let userName = '用户';
            let userAvatar = '';
            
    if (selectedPersona) {
        // 优先使用群聊设置里为“我”单独设置的昵称和头像
        userName = chatSettings.myChatNickname || selectedPersona.name;
        userAvatar = chatSettings.myChatAvatar || selectedPersona.avatarUrl;
    }
    
    // 添加用户自己（排在第一位）
    const userItem = document.createElement('div');
    userItem.className = 'member-item user-member';
    userItem.onclick = () => changeMyGroupAvatar();
            userItem.innerHTML = `
                <img class="member-avatar" src="${userAvatar || createDefaultAvatar(userName)}" alt="${userName}">
                <div class="member-name">${userName}</div>
            `;
            groupMembersGrid.appendChild(userItem);
    // --- 修复结束 ---
            
            // 然后添加群内现有角色
            if (currentChatCharacter.members && currentChatCharacter.members.length > 0) {
                currentChatCharacter.members.forEach(member => {
                    const memberItem = document.createElement('div');
                    memberItem.className = 'member-item';
                    
                    memberItem.innerHTML = `
                        <div class="member-avatar-wrapper">
                            <img class="member-avatar clickable-avatar" 
                                 src="${member.avatarUrl || createDefaultAvatar(member.name)}" 
                                 alt="${member.name}"
                                 onclick="changeMemberAvatar('${member.id}', event)"
                                 title="点击更换${member.name}的头像">
                            <div class="avatar-hover-hint">
                                <i class="fas fa-camera"></i>
                            </div>
                        </div>
                        <div class="member-name">${member.name}</div>
                    `;
                    groupMembersGrid.appendChild(memberItem);
                });
            }
            
            // 添加邀请按钮
            const addMemberBtn = document.createElement('div');
            addMemberBtn.className = 'member-item add-member';
            addMemberBtn.onclick = () => addGroupMember();
            addMemberBtn.innerHTML = `
                <div class="member-avatar add-avatar">
                    <i class="fas fa-plus"></i>
                </div>
                <div class="member-name">邀请</div>
            `;
            groupMembersGrid.appendChild(addMemberBtn);
            
            // 只要群内有角色成员就显示移除按钮
            if (currentChatCharacter.members && currentChatCharacter.members.length > 0) {
                const removeMemberBtn = document.createElement('div');
                removeMemberBtn.className = 'member-item remove-member';
                removeMemberBtn.onclick = () => removeGroupMember();
                removeMemberBtn.innerHTML = `
                    <div class="member-avatar remove-avatar">
                        <i class="fas fa-minus"></i>
                    </div>
                    <div class="member-name">移除</div>
                `;
                groupMembersGrid.appendChild(removeMemberBtn);
            }
        }

// --- 请复制到这里结束 ---
        
        // 显示成员详情
        function showMemberProfile(member) {
            alert(`👤 群成员信息\n\n昵称：${member.name}\n角色ID：${member.id}\n\n点击头像可以查看角色详细信息`);
        }
        
        // 显示用户自己的资料
        function showUserProfile() {
            let userName = '用户';
            let userInfo = '群聊成员';
            
            if (currentPersona) {
                userName = currentPersona.name;
                userInfo = `当前面具：${currentPersona.name}`;
                if (currentPersona.description) {
                    userInfo += `\n面具描述：${currentPersona.description}`;
                }
            } else if (currentChatCharacter.myNickname) {
                userName = currentChatCharacter.myNickname;
                userInfo = `群昵称：${currentChatCharacter.myNickname}`;
            }
            
            alert(`👤 我的信息\n\n昵称：${userName}\n身份：${userInfo}\n\n这是你自己在群聊中的信息`);
        }
        
        // 创建默认头像
        function createDefaultAvatar(name) {
            const canvas = document.createElement('canvas');
            canvas.width = 50;
            canvas.height = 50;
            const ctx = canvas.getContext('2d');
            
            // 随机背景颜色
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF'];
            const bgColor = colors[name.charCodeAt(0) % colors.length];
            
            // 绘制圆形背景
            ctx.beginPath();
            ctx.arc(25, 25, 25, 0, 2 * Math.PI);
            ctx.fillStyle = bgColor;
            ctx.fill();
            
            // 绘制文字
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(name.charAt(0), 25, 25);
            
            return canvas.toDataURL();
        }
        
        function showGroupMembers() {
            alert('👥 群成员管理功能开发中...\n\n将支持以下功能：\n• 查看群成员列表\n• 设置群管理员\n• 管理群成员权限\n• 禁言/踢出群聊');
        }
        
        async function changeMyGroupNickname() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            
    const chatSettings = getCurrentChatSettings();
    const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
    
    const currentNickname = chatSettings.myChatNickname || (selectedPersona ? selectedPersona.name : '用户');
    const newNickname = prompt('请输入我在本群的昵称:', currentNickname);

    if (newNickname && newNickname.trim() !== '' && newNickname.trim() !== currentNickname) {
                const trimmedNickname = newNickname.trim();
                
        // 1. 更新当前群聊设置中的昵称
        chatSettings.myChatNickname = trimmedNickname;
        await saveCurrentChatSettings(chatSettings);
        
        // 2. 创建并添加系统消息
        const systemMessage = {
            id: 'system_' + Date.now(),
            sender: 'system',
            content: `你已将群昵称修改为 "${trimmedNickname}"`,
            timestamp: Date.now()
        };
        
        if (!chatMessages[currentChatCharacter.id]) {
            chatMessages[currentChatCharacter.id] = [];
        }
        chatMessages[currentChatCharacter.id].push(systemMessage);
        await saveChatMessages();
        
        // 3. 更新UI
        updateGroupChatInfo(); // 这会刷新设置页面的显示
        renderChatMessages(currentChatCharacter.id); // 刷新聊天界面显示系统消息

        showToast('群昵称修改成功！', 'success');
    }
}
// --- 新增函数 ---
async function changeMyGroupAvatar() {
    if (!currentChatCharacter) return;

    // 创建一个临时的文件输入框
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*,.jpg,.jpeg,.png,.gif,.webp';
    input.style.display = 'none';

    // 当用户选择了文件后
    input.onchange = async (e) => {
        if (!e.target.files || !e.target.files[0]) return;
        
        const file = e.target.files[0];
        const reader = new FileReader();

        reader.onload = async (event) => {
            const newAvatarUrl = event.target.result;

            // 1. 更新当前群聊设置中的头像
            const chatSettings = getCurrentChatSettings();
            chatSettings.myChatAvatar = newAvatarUrl;
            await saveCurrentChatSettings(chatSettings);
            
            // 2. 创建并添加系统消息
            const systemMessage = {
                id: 'system_' + Date.now(),
                sender: 'system',
                content: `你更换了新头像`,
                timestamp: Date.now()
            };

            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            chatMessages[currentChatCharacter.id].push(systemMessage);
            await saveChatMessages();

            // 3. 更新UI
            updateGroupChatInfo(); // 刷新设置页面的成员列表
            renderChatMessages(currentChatCharacter.id); // 刷新聊天界面显示新头像和系统消息

            showToast('群头像更换成功！', 'success');
        };
        
        reader.readAsDataURL(file);
        document.body.removeChild(input); // 清理临时的input元素
    };

    document.body.appendChild(input);
    input.click(); // 弹出文件选择窗口
        }
        
        // 编辑群公告
        function editGroupDescription() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            showGroupNoticeModal();
        }
        
        // 显示群公告编辑模态框
        function showGroupNoticeModal() {
            const modal = document.getElementById('group-notice-modal');
            const textarea = document.getElementById('group-notice-content');
            const charCount = document.getElementById('notice-char-current');
            
            // 设置当前群公告内容
            const currentDescription = currentChatCharacter?.description || '';
            textarea.value = currentDescription;
            charCount.textContent = currentDescription.length;
            
            // 监听字符数变化
            textarea.addEventListener('input', updateNoticeCharCount);
            
            modal.style.display = 'flex';
            setTimeout(() => textarea.focus(), 100);
        }
        
        // 隐藏群公告编辑模态框
        function hideGroupNoticeModal() {
            const modal = document.getElementById('group-notice-modal');
            const textarea = document.getElementById('group-notice-content');
            
            // 移除事件监听器
            textarea.removeEventListener('input', updateNoticeCharCount);
            
            modal.style.display = 'none';
        }
        
        // 更新字符计数
        function updateNoticeCharCount() {
            const textarea = document.getElementById('group-notice-content');
            const charCount = document.getElementById('notice-char-current');
            charCount.textContent = textarea.value.length;
            
            // 如果超过限制，变色提示
            if (textarea.value.length > 500) {
                charCount.style.color = '#ff3b30';
            } else if (textarea.value.length > 450) {
                charCount.style.color = '#ff9500';
            } else {
                charCount.style.color = '#007AFF';
            }
        }
        
        // 保存群公告
        function saveGroupNotice() {
            const textarea = document.getElementById('group-notice-content');
            const newDescription = textarea.value.trim();
            
            if (newDescription.length > 500) {
                alert('群公告内容不能超过500字');
                return;
            }
            
                // 更新当前群聊角色的描述
            currentChatCharacter.description = newDescription;
                
                // 如果是群聊，需要更新群聊数据
                if (groupChats) {
                    const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                    if (groupIndex !== -1) {
                    groupChats[groupIndex].description = newDescription;
                        saveGroupChats(groupChats);
                    }
                }
                
                // 更新UI显示
                updateGroupChatInfo();
            hideGroupNoticeModal();
            
            // 显示成功提示
            showToast('✅ 群公告保存成功', 'success');
        }
        
        // 添加群成员 - 从现有角色中选择
        function addGroupMember() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            
            // 获取所有角色列表
            if (!characters || characters.length === 0) {
                alert('暂无可邀请的角色，请先创建角色');
                return;
            }
            
            // 过滤掉已经在群里的角色
            const currentMemberIds = currentChatCharacter.members ? currentChatCharacter.members.map(m => m.id) : [];
            const availableCharacters = characters.filter(char => !currentMemberIds.includes(char.id));
            
            if (availableCharacters.length === 0) {
                alert('所有角色都已经在群里了');
                return;
            }
            
            // 创建美观的选择界面
            showCharacterSelectionModal(availableCharacters, '邀请群成员', '请选择要邀请进群的角色：', (selectedCharacter) => {
                // 添加到群成员列表
                if (!currentChatCharacter.members) {
                    currentChatCharacter.members = [];
                }
                currentChatCharacter.members.push({
                    id: selectedCharacter.id,
                    name: selectedCharacter.name,
                    avatarUrl: selectedCharacter.avatarUrl
                });
                
                // 保存群聊数据
                if (groupChats) {
                    const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                    if (groupIndex !== -1) {
                        groupChats[groupIndex].members = currentChatCharacter.members;
                        saveGroupChats(groupChats);
                    }
                }
                
                // 更新UI
                updateGroupChatInfo();
                renderMessageList(); // 更新消息列表

                // 🔥【新增】更新聊天界面标题显示成员数量
                const chatTitle = document.getElementById('api-chat-title');
                if (chatTitle) {
                    let displayTitle = currentChatCharacter.name;
                    const memberCount = currentChatCharacter.members.length + 1; // +1 包括用户自己
                    displayTitle = `${displayTitle}（${memberCount}）`;
                    chatTitle.textContent = displayTitle;
                }

                showToast(`✅ ${selectedCharacter.name} 已加入群聊`, 'success');
            });
        }
        
        // 移除群成员
        function removeGroupMember() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup || !currentChatCharacter.members) return;
            
            if (currentChatCharacter.members.length <= 1) {
                alert('群聊至少需要保留一个角色成员（不包括用户自己）');
                return;
            }
            
            // 创建美观的选择界面
            showCharacterSelectionModal(currentChatCharacter.members, '移除群成员', '请选择要移出群聊的成员：', (selectedMember) => {
                if (confirm(`确定要将 ${selectedMember.name} 移出群聊吗？`)) {
                    // 从群成员列表中移除
                    const memberIndex = currentChatCharacter.members.findIndex(m => m.id === selectedMember.id);
                    if (memberIndex !== -1) {
                        currentChatCharacter.members.splice(memberIndex, 1);
                        
                        // 保存群聊数据
                        if (groupChats) {
                            const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                            if (groupIndex !== -1) {
                                groupChats[groupIndex].members = currentChatCharacter.members;
                                saveGroupChats(groupChats);
                            }
                        }
                        
                        // 更新UI
                        updateGroupChatInfo();
                        renderMessageList(); // 更新消息列表

                        // 🔥【新增】更新聊天界面标题显示成员数量
                        const chatTitle = document.getElementById('api-chat-title');
                        if (chatTitle) {
                            let displayTitle = currentChatCharacter.name;
                            const memberCount = currentChatCharacter.members.length + 1; // +1 包括用户自己
                            displayTitle = `${displayTitle}（${memberCount}）`;
                            chatTitle.textContent = displayTitle;
                        }

                        showToast(`✅ ${selectedMember.name} 已被移出群聊`, 'success');
                    }
                }
            });
        }
        
        // 群公告功能
        function showGroupNotice() {
            const notice = currentChatCharacter?.description || '暂无群公告';
            alert(`📢 群公告\n\n${notice}\n\n点击群信息卡片的公告区域可以编辑群公告`);
        }
        

        
        // 群应用功能
        function showGroupVote() {
            alert('🗳️ 群投票功能开发中...\n\n将支持以下功能：\n• 创建投票话题\n• 设置投票选项\n• 实时投票结果\n• 投票截止时间');
        }
        
        function showGroupActivity() {
            alert('📅 群活动功能开发中...\n\n将支持以下功能：\n• 创建群活动\n• 活动报名统计\n• 活动提醒\n• 活动签到');
        }
        
        function showGroupTask() {
            alert('✅ 群任务功能开发中...\n\n将支持以下功能：\n• 发布群任务\n• 任务认领\n• 完成状态跟踪\n• 积分奖励系统');
        }
        
        function showMoreApps() {
            alert('🔧 更多群应用\n\n即将推出：\n• 群直播\n• 群游戏\n• 群红包\n• 群机器人\n• 群日程\n• 群笔记');
        }
        
        // 显示角色选择模态框
        function showCharacterSelectionModal(characterList, title, description, onSelect) {
            const modalHTML = `
                <div class="modal character-selection-modal" id="character-selection-modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 class="modal-title">${title}</h3>
                            <button class="modal-close" onclick="hideCharacterSelectionModal()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p class="selection-description">${description}</p>
                            <div class="character-selection-grid" id="character-selection-grid">
                                ${characterList.map(char => `
                                    <div class="character-selection-item" data-character-id="${char.id}">
                                        <div class="character-selection-avatar">
                                            <img src="${char.avatarUrl || createDefaultAvatar(char.name)}" alt="${char.name}">
                                        </div>
                                        <div class="character-selection-info">
                                            <div class="character-selection-name">${char.name}</div>
                                            <div class="character-selection-bio">${(char.description || char.bio || '暂无简介').substring(0, 30)}${(char.description || char.bio || '').length > 30 ? '...' : ''}</div>
                                        </div>
                                        <div class="character-selection-check">
                                            <i class="fas fa-check"></i>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-secondary" onclick="hideCharacterSelectionModal()">取消</button>
                            <button class="modal-primary" id="confirm-selection-btn" onclick="confirmCharacterSelection()" disabled>确定</button>
                        </div>
                    </div>
                </div>
            `;
            
            const existingModal = document.getElementById('character-selection-modal');
            if (existingModal) {
                existingModal.remove();
            }
            
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            
            window.characterSelectionCallback = onSelect;
            window.selectedCharacterId = null;
            
            document.querySelectorAll('.character-selection-item').forEach(item => {
                item.addEventListener('click', function() {
                    document.querySelectorAll('.character-selection-item').forEach(i => i.classList.remove('selected'));
                    this.classList.add('selected');
                    window.selectedCharacterId = this.dataset.characterId;
                    document.getElementById('confirm-selection-btn').disabled = false;
                });
            });
        }
        
        // 隐藏角色选择模态框
        function hideCharacterSelectionModal() {
            const modal = document.getElementById('character-selection-modal');
            if (modal) {
                modal.remove();
            }
            window.characterSelectionCallback = null;
            window.selectedCharacterId = null;
        }
        
        // 确认角色选择
        function confirmCharacterSelection() {
            if (!window.selectedCharacterId || !window.characterSelectionCallback) return;
            
            const allCharacters = [...characters, ...(currentChatCharacter.members || [])];
            const selectedCharacter = allCharacters.find(char => char.id === window.selectedCharacterId);
            
            if (selectedCharacter) {
                window.characterSelectionCallback(selectedCharacter);
                hideCharacterSelectionModal();
            }
        }
        
        // 🔥【新增】群成员头像更换功能
        function changeMemberAvatar(memberId, event) {
            event.stopPropagation(); // 阻止事件冒泡
            
            const member = currentChatCharacter.members.find(m => m.id === memberId);
            if (!member) return;
            
            // 显示头像更换模态框
            showMemberAvatarModal(member);
        }

        // 🔥【新增】显示群成员头像更换模态框
        function showMemberAvatarModal(member) {
            const modal = document.getElementById('member-avatar-modal');
            const preview = document.getElementById('member-avatar-preview');
            const memberName = document.getElementById('member-avatar-name');
            const uploadInput = document.getElementById('member-avatar-upload');
            
            // 设置当前成员信息
            window.currentEditingMember = member;
            memberName.textContent = member.name;
            preview.src = member.avatarUrl || createDefaultAvatar(member.name);
            
            // 重置文件输入
            uploadInput.value = '';
            
            modal.style.display = 'flex';
        }

        // 🔥【新增】隐藏群成员头像更换模态框
        function hideMemberAvatarModal() {
            const modal = document.getElementById('member-avatar-modal');
            modal.style.display = 'none';
            window.currentEditingMember = null;
        }

        // 🔥【新增】处理群成员头像上传
        function handleMemberAvatarUpload() {
            const uploadInput = document.getElementById('member-avatar-upload');
            uploadInput.click();
        }

        // 🔥【新增】保存群成员头像
        function saveMemberAvatar() {
            if (!window.currentEditingMember) return;
            
            const preview = document.getElementById('member-avatar-preview');
            const newAvatarUrl = preview.src;
            
            // 更新群成员头像
            const memberIndex = currentChatCharacter.members.findIndex(m => m.id === window.currentEditingMember.id);
            if (memberIndex !== -1) {
                currentChatCharacter.members[memberIndex].avatarUrl = newAvatarUrl;
                
                // 同时更新全局角色列表中的头像
                const characterIndex = characters.findIndex(c => c.id === window.currentEditingMember.id);
                if (characterIndex !== -1) {
                    characters[characterIndex].avatarUrl = newAvatarUrl;
                    saveCharacters(characters);
                }
                
                // 保存群聊数据
                if (groupChats) {
                    const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                    if (groupIndex !== -1) {
                        groupChats[groupIndex].members = currentChatCharacter.members;
                        saveGroupChats(groupChats);
                    }
                }
                
                // 🔥【新增】在群聊消息中添加头像更换提示
                addAvatarChangeMessage(window.currentEditingMember.name);
                
                // 更新UI
                updateGroupChatInfo();
                renderGroupMembersGrid();
                refreshChatMessages(); // 刷新聊天消息显示新头像
                
                showToast(`✅ ${window.currentEditingMember.name} 的头像已更新`, 'success');
            }
            
            hideMemberAvatarModal();
        }

        // 🔥【新增】添加头像更换系统消息
        function addAvatarChangeMessage(memberName) {
            if (!currentChatCharacter || !chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            
            const systemMessage = {
                id: 'system_' + Date.now(),
                sender: 'system',
                content: `${memberName} 更换了头像`,
                timestamp: Date.now(),
                isSystem: true
            };
            
            chatMessages[currentChatCharacter.id].push(systemMessage);
            saveChatMessages();
            
            // 刷新聊天界面
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }
        }

        // 🔥【新增】刷新聊天消息以显示新头像
        function refreshChatMessages() {
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }
        }

        // 🔥【新增】重置群成员头像为默认
        function resetMemberAvatar() {
            if (!window.currentEditingMember) return;
            
            const preview = document.getElementById('member-avatar-preview');
            const defaultAvatar = createDefaultAvatar(window.currentEditingMember.name);
            preview.src = defaultAvatar;
        }

        // 🔥【新增】数据恢复检查和修复功能
        async function checkAndFixChatHistory() {
            try {
                console.log('开始检查聊天历史数据...');
                
                // 检查IndexedDB中的数据
                const dbMessages = await db.chatMessages.toArray();
                const memoryMessages = chatMessages;
                
                console.log('IndexedDB中的消息数:', dbMessages.length);
                console.log('内存中的聊天数:', Object.keys(memoryMessages).length);
                
                // 检查是否有localStorage的备份数据
                const localStorageBackup = localStorage.getItem('chatMessages');
                if (localStorageBackup) {
                    try {
                        const backupData = JSON.parse(localStorageBackup);
                        console.log('找到localStorage备份数据');
                        
                        // 比较数据时间戳，选择最新的
                        let shouldUseBackup = false;
                        let newerMessagesCount = 0;
                        
                        for (const [characterId, messages] of Object.entries(backupData)) {
                            if (messages && messages.length > 0) {
                                const latestBackupTime = Math.max(...messages.map(m => m.timestamp || 0));
                                const currentMessages = memoryMessages[characterId] || [];
                                const latestCurrentTime = currentMessages.length > 0 ? 
                                    Math.max(...currentMessages.map(m => m.timestamp || 0)) : 0;
                                
                                if (latestBackupTime > latestCurrentTime) {
                                    console.log(`角色 ${characterId} 的备份数据更新 (备份:${new Date(latestBackupTime)}, 当前:${new Date(latestCurrentTime)})`);
                                    shouldUseBackup = true;
                                    newerMessagesCount += messages.length - currentMessages.length;
                                }
                            }
                        }
                        
                        if (shouldUseBackup) {
                            const confirmRestore = confirm(`检测到localStorage中有更新的聊天记录！\n\n发现 ${newerMessagesCount} 条更新的消息\n\n是否恢复这些数据？`);
                            if (confirmRestore) {
                                // 恢复数据
                                Object.assign(chatMessages, backupData);
                                await saveChatMessages();
                                
                                // 重新渲染当前聊天
                                if (currentChatCharacter) {
                                    renderChatMessages(currentChatCharacter.id);
                                }
                                
                                showToast(`已恢复 ${newerMessagesCount} 条消息！`, 'success');
                                return true;
                            }
                        }
                    } catch (e) {
                        console.error('解析备份数据失败:', e);
                    }
                }
                
                // 检查是否有异常的时间戳（未来时间或过老时间）
                let fixedCount = 0;
                const now = Date.now();
                const oneWeekAgo = now - (7 * 24 * 60 * 60 * 1000);
                
                for (const [characterId, messages] of Object.entries(chatMessages)) {
                    if (messages && Array.isArray(messages)) {
                        for (let i = 0; i < messages.length; i++) {
                            const msg = messages[i];
                            if (!msg.timestamp || msg.timestamp > now || msg.timestamp < oneWeekAgo) {
                                // 修复异常时间戳
                                const correctedTime = now - (messages.length - i) * 60000; // 按顺序递减1分钟
                                console.log(`修复消息时间戳: ${msg.timestamp} -> ${correctedTime}`);
                                msg.timestamp = correctedTime;
                                fixedCount++;
                            }
                        }
                        
                        // 重新排序消息
                        messages.sort((a, b) => a.timestamp - b.timestamp);
                    }
                }
                
                if (fixedCount > 0) {
                    await saveChatMessages();
                    showToast(`修复了 ${fixedCount} 条消息的时间戳`, 'info');
                }
                
                return false;
            } catch (error) {
                console.error('检查聊天历史失败:', error);
                return false;
            }
        }

        // 显示提示消息
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.textContent = message;
            
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
                color: white;
                padding: 12px 24px;
                border-radius: 25px;
                font-size: 14px;
                z-index: 10000;
                opacity: 0;
                transition: all 0.3s ease;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            `;
            
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '1';
                toast.style.transform = 'translateX(-50%) translateY(10px)';
            }, 100);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(-50%) translateY(-10px)';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, 3000);
        }

        // 文本截断函数
        function truncateText(text, maxLength = 80) {
            // 🔥【修复】确保text是字符串类型
            if (text === null || text === undefined) {
                return '';
            }
            
            // 如果不是字符串，转换为字符串
            if (typeof text !== 'string') {
                text = String(text);
            }
            
            if (!text || text.length <= maxLength) return text;
            
            // 按行分割文本
            const lines = text.split('\n');
            let result = '';
            let lineCount = 0;
            
            for (const line of lines) {
                // 限制最多显示3行
                if (lineCount >= 3) break;
                
                if (result.length + line.length + 1 <= maxLength) {
                    result += (result ? '\n' : '') + line;
                    lineCount++;
                } else {
                    // 如果这一行会超出长度限制，截断并添加省略号
                    const remaining = maxLength - result.length - 1;
                    if (remaining > 10) { // 确保有足够空间显示有意义的内容
                        result += (result ? '\n' : '') + line.substring(0, remaining - 3) + '...';
                    } else if (!result) {
                        // 如果是第一行就超长，直接截断
                        result = line.substring(0, maxLength - 3) + '...';
                    } else {
                        // 否则在当前结果后加省略号
                        result += '...';
                    }
                    break;
                }
            }
            
            return result;
        }
        
        // 🔥【新增】消息列表多选删除功能
        
        // 进入消息列表多选模式
        function enterMessageListMultiSelectMode(conversationId) {
            console.log('触发长按多选模式，对话ID:', conversationId); // 调试信息
            isMessageListMultiSelectMode = true;
            selectedConversations = [conversationId]; // 将触发长按的对话添加到选中列表
            renderMessageList(); // 重新渲染列表以显示多选界面
            showToast('已进入多选模式，可以选择多个对话进行删除', 'info');
        }
        
        // 退出消息列表多选模式
        function exitMessageListMultiSelectMode() {
            isMessageListMultiSelectMode = false;
            selectedConversations = [];

            renderMessageList(); // 重新渲染列表恢复正常状态
        }
        
        // 切换对话选择状态
        function toggleConversationSelection(conversationId) {
            const index = selectedConversations.indexOf(conversationId);
            if (index > -1) {
                selectedConversations.splice(index, 1);
            } else {
                selectedConversations.push(conversationId);
            }
            renderMessageList(); // 重新渲染以更新选择状态
        }
        
        // 删除选中的对话
        async function deleteSelectedConversations() {
            if (selectedConversations.length === 0) {
                showToast('请先选择要删除的对话', 'error');
                return;
            }
            
            const count = selectedConversations.length;
            const confirmText = `确定要删除选中的 ${count} 个对话吗？\n\n删除后将清空对话的所有聊天记录和专属设置，此操作不可恢复。`;
            
            if (confirm(confirmText)) {
                try {
                    // 使用 for...of 循环来确保异步操作一个接一个完成
                    for (const conversationId of selectedConversations) {
                        // 1. 删除聊天消息
                    if (chatMessages[conversationId]) {
                        delete chatMessages[conversationId];
                    }
                    
                        // 2. [核心修复] 从数据库中删除此对话的设置
                        await db.chatSettings.delete(conversationId);
                        //    同时从内存中也删除，保持同步
                        if (chatSettings[conversationId]) {
                            delete chatSettings[conversationId];
                        }
                        
                        // 2.1 [额外修复] 删除localStorage中的备份设置
                        localStorage.removeItem(`chatSettings_${conversationId}`);
                        
                        // 2.2 [彻底修复] 删除角色对象中的背景设置
                        const character = characters.find(c => c.id === conversationId);
                        if (character) {
                            character.background = null;
                            // 这里不需要立即保存，后面会统一保存
                        }

                        // 3. 🔥【修复】区分单聊和群聊的删除逻辑
                        const groupIndex = groupChats.findIndex(g => g.id === conversationId);
                        if (groupIndex > -1) {
                            // 如果是群聊，从群聊列表中删除
                            groupChats.splice(groupIndex, 1);
                        } else {
                            // 如果是单聊，从联系人列表中移除 (这代表移除了一个"活跃对话")
                            const contactIndex = contacts.indexOf(conversationId);
                            if (contactIndex > -1) {
                                contacts.splice(contactIndex, 1);
                            }
                        }
                    }

                    // 4. 异步保存所有更改
                    await Promise.all([
                        saveChatMessages(),
                        saveGroupChats(),
                        saveContacts()
                        // 🔥【修复】不再需要保存 characters，因为我们没有修改角色本身
                    ]);

                    // 5. 退出多选模式并刷新UI
                    exitMessageListMultiSelectMode(); // 这个函数内部会调用 renderMessageList()
                
                showToast(`✅ 已删除 ${count} 个对话`, 'success');

                } catch (error) {
                    console.error("删除对话时出错:", error);
                    showToast('删除失败，请检查控制台错误信息', 'error');
                }
            }
        }

        // --- 论坛功能 ---

        let currentForumId = null;

        // 显示创建论坛界面
        function showCreateForumScreen() {
            hideApp('forum-screen');
            const characterContainer = document.getElementById('forum-character-selection');
            const personaContainer = document.getElementById('forum-persona-selection');

            // 渲染角色和身份面具选项
            characterContainer.innerHTML = characters.map(char => `
                <div class="selection-item" data-id="${char.id}" onclick="toggleSelection(this)">
                    <img src="${char.avatarUrl || createDefaultAvatar(char.name)}" alt="${char.name}">
                    <div class="selection-item-name">${char.name}</div>
                </div>
            `).join('');

            personaContainer.innerHTML = personas.map(p => `
                <div class="selection-item" data-id="${p.id}" onclick="toggleSelection(this, true)">
                    <img src="${p.avatarUrl || createDefaultAvatar(p.name)}" alt="${p.name}">
                    <div class="selection-item-name">${p.name}</div>
                </div>
            `).join('');

            showApp('create-forum-screen');
        }

        // 多选/单选切换
        function toggleSelection(element, isSingle = false) {
            const container = element.parentElement;
            if (isSingle) {
                // 单选逻辑
                const currentlySelected = container.querySelector('.selected');
                if (currentlySelected) {
                    currentlySelected.classList.remove('selected');
                }
            }
            element.classList.toggle('selected');
        }

        // 创建新论坛
        async function createForum() {
            const name = document.getElementById('forum-name-input').value.trim();
            const worldview = document.getElementById('forum-worldview-input').value.trim();

            const selectedCharElements = document.querySelectorAll('#forum-character-selection .selected');
            const selectedPersonaElement = document.querySelector('#forum-persona-selection .selected');

            if (!name) return alert('请输入论坛名称');
            if (selectedCharElements.length === 0) return alert('请至少选择一个角色');
            if (!selectedPersonaElement) return alert('请选择你的身份');

            const characterIds = Array.from(selectedCharElements).map(el => el.dataset.id);
            const personaId = selectedPersonaElement.dataset.id;

            try {
                // 检查论坛名称是否重复
                const existingForum = await db.forums.where('name').equals(name).first();
                if (existingForum) {
                    alert('论坛名称已存在，请选择其他名称');
                    return;
                }

                const newForum = {
                    name,
                    characterIds,
                    personaId,
                    worldview,
                    createdAt: Date.now()
                };

                currentForumId = await db.forums.add(newForum);
                showToast(`论坛 "${name}" 创建成功！正在生成帖子...`, 'success');

                hideApp('create-forum-screen');
                await loadAndDisplayForum(currentForumId, true); // true表示这是第一次加载，需要生成帖子
            } catch (error) {
                console.error("创建论坛失败:", error);
                alert("创建论坛失败，请重试。");
            }
        }

        // 渲染论坛存档列表
        async function renderForumArchives() {
            const forums = await db.forums.toArray();
            const listContainer = document.getElementById('forum-archive-list');

            if (forums.length === 0) {
                listContainer.innerHTML = `
                    <div class="forum-empty-state">
                        <i class="fas fa-comments"></i>
                        <p>还没有创建任何论坛</p>
                        <p>点击右上角 + 创建你的第一个论坛</p>
                    </div>`;
                return;
            }

            listContainer.innerHTML = forums.sort((a, b) => b.createdAt - a.createdAt).map(forum => `
                <div class="forum-archive-item" onclick="loadAndDisplayForum('${forum.id}')">
                    <div class="forum-archive-title">${forum.name}</div>
                    <div class="forum-archive-meta">
                        <span>👥 ${forum.characterIds.length} 个角色</span>
                        <span>${new Date(forum.createdAt).toLocaleDateString()}</span>
                    </div>
                </div>
            `).join('');
        }

        // 加载并显示一个论坛
        async function loadAndDisplayForum(forumId, shouldGeneratePosts = false) {
            currentForumId = forumId;
            const forum = await db.forums.get(parseInt(forumId));
            if (!forum) {
                alert("找不到该论坛");
                return;
            }

            document.getElementById('forum-view-title').innerText = forum.name;
            hideApp('forum-screen');
            showApp('forum-view-screen');

            if (shouldGeneratePosts) {
                await generateForumPosts(forumId);
            }
            await renderForumPosts(forumId);
        }

        // 返回论坛存档列表
        async function backToForumArchives() {
            // 🔥【修复】先显示论坛主页，再隐藏当前页面，避免闪现主屏幕
            await renderForumArchives();
            showApp('forum-screen');
            hideApp('forum-view-screen');
        }

        // 生成论坛帖子
        async function generateForumPosts(forumId) {
            const forum = await db.forums.get(parseInt(forumId));
            const forumCharacters = characters.filter(c => forum.characterIds.includes(c.id));
            const persona = personas.find(p => p.id === forum.personaId);

            let prompt = `你是一个论坛的内容生成AI。请为一个名为 "${forum.name}" 的论坛生成5个初始帖子。

世界观设定:
${forum.worldview || '无补充设定，请基于角色人设自由发挥。'}

论坛成员:
${forumCharacters.map(c => `- ${c.name}: ${c.bio}`).join('\n')}
- ${persona.name} (用户): ${persona.description}

请生成5个帖子的标题和内容，格式为JSON数组，每个帖子是一个对象:
[
  { "authorName": "角色名或用户名", "title": "帖子标题", "content": "帖子正文" },
  ...
]

要求:
- 帖子要生动真实，有生活气息。
- 话题可以围绕角色的日常、烦恼、趣事，也可以是向用户或其他角色提问。
- 标题要吸引人，内容要有细节。
- authorName 必须是上面列表中的名字之一。
`;

            showToast('AI正在生成帖子，请稍候...', 'info');
            try {
                const response = await callChatAPI(prompt, forumCharacters[0]); // 使用第一个角色作为API调用的主体
                const posts = JSON.parse(response);

                for (const post of posts) {
                    const author = characters.find(c => c.name === post.authorName) || personas.find(p => p.name === post.authorName);
                    await db.forumPosts.add({
                        forumId: parseInt(forumId),
                        title: post.title,
                        content: post.content,
                        authorId: author.id,
                        authorName: author.name,
                        authorAvatar: author.avatarUrl,
                        timestamp: Date.now() - Math.random() * 86400000 // 随机时间戳，看起来更真实
                    });
                }
            } catch (error) {
                console.error("生成帖子失败:", error);
                alert("AI生成帖子失败，请检查API设置或刷新重试。");
            }
        }

        // 渲染帖子列表
        async function renderForumPosts(forumId) {
            const posts = await db.forumPosts.where('forumId').equals(parseInt(forumId)).reverse().sortBy('timestamp');
            const listContainer = document.getElementById('forum-posts-list');

            if (posts.length === 0) {
                listContainer.innerHTML = `<div class="forum-empty-state"><p>这个论坛还没有帖子</p></div>`;
                return;
            }

            listContainer.innerHTML = posts.map(post => `
                <div class="post-item" onclick="showPostView(${post.id})">
                    <div class="post-title">${post.title}</div>
                    <div class="post-meta">
                        <span class="post-author">${post.authorName}</span>
                        <span>${formatTime(post.timestamp)}</span>
                    </div>
                </div>
            `).join('');
        }

        // 刷新帖子
        async function refreshPosts() {
            if (!currentForumId) return;
            await generateForumPosts(currentForumId);
            await renderForumPosts(currentForumId);
            showToast("新帖子已刷新！", "success");
        }

        // 显示帖子详情
        async function showPostView(postId) {
            const post = await db.forumPosts.get(postId);
            if (!post) return;

            window.currentPostId = postId; // 存储当前帖子ID

            const contentContainer = document.getElementById('post-view-content');
            contentContainer.innerHTML = `
                <div class="post-full-content">
                    <div class="post-full-title">${post.title}</div>
                    <div class="post-full-meta">由 ${post.authorName} 发布于 ${new Date(post.timestamp).toLocaleString()}</div>
                    <div class="post-full-body">${post.content.replace(/\n/g, '<br>')}</div>
                </div>
                <div class="replies-section">
                    <h3>回复</h3>
                    <div id="replies-list"></div>
                </div>
            `;

            // 更新收藏按钮状态
            const isFav = await db.forumFavorites.where('[userId+postId]').equals(['user', postId]).first();
            const favIcon = document.querySelector('#favorite-btn i');
            favIcon.className = isFav ? 'fas fa-star' : 'far fa-star';

            await renderReplies(postId);
            showApp('post-view-screen');
        }

        // 渲染回复
        async function renderReplies(postId) {
            const replies = await db.forumReplies.where('postId').equals(postId).sortBy('timestamp');
            const listContainer = document.getElementById('replies-list');

            listContainer.innerHTML = replies.map(reply => `
                <div class="reply-item">
                    <img class="reply-avatar" src="${reply.authorAvatar || createDefaultAvatar(reply.authorName)}" alt="${reply.authorName}">
                    <div class="reply-body">
                        <div class="reply-author">${reply.authorName}</div>
                        <div class="reply-content">${reply.content.replace(/\n/g, '<br>')}</div>
                    </div>
                </div>
            `).join('');
        }

        // 发送回复
        async function sendReply() {
            const input = document.getElementById('reply-input');
            const content = input.value.trim();
            if (!content || !window.currentPostId) return;

            const forum = await db.forums.get(currentForumId);
            const persona = personas.find(p => p.id === forum.personaId);

            const reply = {
                postId: window.currentPostId,
                authorId: 'user',
                authorName: persona.name,
                authorAvatar: persona.avatarUrl,
                content: content,
                timestamp: Date.now()
            };

            await db.forumReplies.add(reply);
            input.value = '';
            await renderReplies(window.currentPostId);

            // 触发NPC回复
            triggerNpcReply(window.currentPostId);
        }

        // 触发NPC回复
        async function triggerNpcReply(postId) {
            const post = await db.forumPosts.get(postId);
            const forum = await db.forums.get(post.forumId);
            const replies = await db.forumReplies.where('postId').equals(postId).toArray();
            const forumCharacters = characters.filter(c => forum.characterIds.includes(c.id));
            const persona = personas.find(p => p.id === forum.personaId);

            // 随机选择一个NPC进行回复
            const replyingChar = forumCharacters[Math.floor(Math.random() * forumCharacters.length)];

            let prompt = `你正在一个名为 "${forum.name}" 的论坛里。
世界观: ${forum.worldview || '无'}
你的身份是 ${replyingChar.name}，人设: ${replyingChar.bio}

当前帖子标题: "${post.title}"
帖子内容: "${post.content}"

以下是最近的几条回复:
${replies.slice(-5).map(r => `${r.authorName}: ${r.content}`).join('\n')}

现在请你作为 ${replyingChar.name}，对这个帖子或最新的回复发表你的看法。回复要自然、简短，符合你的人设。直接输出回复内容，不要用JSON。`;

            try {
                const response = await callChatAPI(prompt, replyingChar);
                const replyContent = Array.isArray(response) ? response[0] : response;

                if (replyContent) {
                    const npcReply = {
                        postId: postId,
                        authorId: replyingChar.id,
                        authorName: replyingChar.name,
                        authorAvatar: replyingChar.avatarUrl,
                        content: replyContent,
                        timestamp: Date.now()
                    };
                    await db.forumReplies.add(npcReply);
                    await renderReplies(postId);
                }
            } catch (error) {
                console.error("NPC回复失败:", error);
            }
        }

        // 收藏/取消收藏帖子
        async function toggleFavoritePost() {
            if (!window.currentPostId) return;

            const postId = window.currentPostId;
            const existingFav = await db.forumFavorites.where('[userId+postId]').equals(['user', postId]).first();
            const favIcon = document.querySelector('#favorite-btn i');

            if (existingFav) {
                await db.forumFavorites.delete(existingFav.id);
                favIcon.className = 'far fa-star';
                showToast('已取消收藏', 'info');
            } else {
                await db.forumFavorites.add({ userId: 'user', postId: postId, timestamp: Date.now() });
                favIcon.className = 'fas fa-star';
                showToast('收藏成功！', 'success');
            }
        }

        // 显示个人主页
        async function showForumProfile() {
            // 🔥【修复】先加载数据和显示页面，再隐藏当前页面，避免闪现主屏幕
            const favoriteRecords = await db.forumFavorites.where('userId').equals('user').toArray();
            const postIds = favoriteRecords.map(fav => fav.postId);
            const favoritePosts = await db.forumPosts.where('id').anyOf(postIds).toArray();

            const listContainer = document.getElementById('favorite-posts-list');
            if (favoritePosts.length === 0) {
                listContainer.innerHTML = `<div class="forum-empty-state"><p>你还没有收藏任何帖子</p></div>`;
            } else {
                listContainer.innerHTML = favoritePosts.sort((a,b) => b.timestamp - a.timestamp).map(post => `
                    <div class="post-item" onclick="showPostView(${post.id})">
                        <div class="post-title">${post.title}</div>
                        <div class="post-meta">
                            <span class="post-author">${post.authorName}</span>
                            <span>${formatTime(post.timestamp)}</span>
                        </div>
                    </div>
                `).join('');
            }

            showApp('forum-profile-screen');
            hideApp('forum-view-screen');
        }

        // 🔥【新增】从个人主页返回当前论坛社区
        async function backToCurrentForum() {
            if (!currentForumId) {
                // 如果没有当前论坛ID，返回论坛主页
                hideApp('forum-profile-screen');
                await renderForumArchives();
                showApp('forum-screen');
                return;
            }

            // 返回当前论坛社区页面
            const forum = await db.forums.get(parseInt(currentForumId));
            if (forum) {
                document.getElementById('forum-view-title').innerText = forum.name;
                await renderForumPosts(currentForumId);
                showApp('forum-view-screen');
                hideApp('forum-profile-screen');
            } else {
                // 论坛不存在，返回论坛主页
                hideApp('forum-profile-screen');
                await renderForumArchives();
                showApp('forum-screen');
            }
        }

        // 初始化论坛应用
        function initializeForumApp() {
            // 绑定论坛应用图标点击事件
            const forumAppIcon = document.querySelector('.mini-app[onclick*="forum-screen"]');
            if (forumAppIcon) {
                // 移除原有的onclick属性
                forumAppIcon.removeAttribute('onclick');
                // 添加新的事件监听器
                forumAppIcon.addEventListener('click', async () => {
                    await renderForumArchives();
                    showApp('forum-screen');
                });
            }
            console.log('✅ 论坛应用初始化完成');
        }

    </script>
    
    <!-- 🔥【新增】群成员头像更换模态框 -->
    <div class="modal" id="member-avatar-modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">更换成员头像</h3>
                <button class="modal-close" onclick="hideMemberAvatarModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="member-avatar-form">
                    <div class="current-member-info">
                        <h4 id="member-avatar-name" class="member-name-title">角色名称</h4>
                        <p class="member-info-desc">为该角色设置新的头像，将在群聊中立即生效</p>
                    </div>
                    
                    <div class="avatar-upload-section">
                        <div class="avatar-preview-large">
                            <img id="member-avatar-preview" src="" alt="头像预览" class="preview-image">
                        </div>
                        
                        <div class="upload-buttons">
                            <button class="upload-btn primary" onclick="handleMemberAvatarUpload()">
                                <i class="fas fa-upload"></i>
                                选择新头像
                            </button>
                            <button class="upload-btn secondary" onclick="resetMemberAvatar()">
                                <i class="fas fa-undo"></i>
                                重置默认
                            </button>
                        </div>
                        
                        <input type="file" id="member-avatar-upload" accept="image/*" style="display: none;">
                    </div>
                    
                    <div class="avatar-tips">
                        <div class="tips-header">
                            <i class="fas fa-info-circle"></i>
                            <span>头像更换说明</span>
                        </div>
                        <div class="tips-content">
                            • 支持JPG、PNG等常见图片格式<br>
                            • 建议使用正方形图片，效果更佳<br>
                            • 头像更换后将在群聊中立即显示<br>
                            • 角色也可以在聊天时自主更换头像
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-button modal-secondary" onclick="hideMemberAvatarModal()">取消</button>
                <button class="modal-button modal-primary" onclick="saveMemberAvatar()">保存更改</button>
            </div>
        </div>
    </div>

    <!-- 群公告编辑模态框 -->
    <div class="modal" id="group-notice-modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">编辑群公告</h3>
                <button class="modal-close" onclick="hideGroupNoticeModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="group-notice-form">
                    <div class="form-group">
                        <label class="form-label">群公告内容</label>
                        <textarea 
                            id="group-notice-content" 
                            class="form-textarea group-notice-textarea" 
                            placeholder="输入群公告内容...&#10;&#10;可以包括：&#10;• 群规则说明&#10;• 重要通知&#10;• 活动安排&#10;• 其他事项"
                            maxlength="500"></textarea>
                        <div class="notice-char-count">
                            <span id="notice-char-current">0</span>/500字
                        </div>
                    </div>
                    <div class="notice-tips">
                        <div class="tips-header">
                            <i class="fas fa-lightbulb"></i>
                            <span>公告小贴士</span>
                        </div>
                        <div class="tips-content">
                            • 简洁明了，突出重点<br>
                            • 使用友好的语调<br>
                            • 定期更新重要信息<br>
                            • 可以使用emoji增加趣味性
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary" onclick="hideGroupNoticeModal()">取消</button>
                <button class="modal-primary" onclick="saveGroupNotice()">保存公告</button>
            </div>
        </div>
    </div>
    
    <!-- 定时发布时间设置模态框 -->
    <div class="modal" id="schedule-times-modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">定时发布时间设置</h3>
                <button class="modal-close" onclick="hideModal('schedule-times-modal')">&times;</button>
            </div>
            <div class="modal-body">
                <p style="color: #666; font-size: 14px; margin-bottom: 15px;">
                    设置角色每天自动发布动态的时间点（最多10个）
                </p>
                <div id="schedule-times-modal-container">
                    <!-- 时间输入项将动态生成 -->
                </div>
                <button onclick="addScheduleTime()" style="margin-top: 10px; padding: 8px 16px; background: #007AFF; color: white; border: none; border-radius: 6px; cursor: pointer;">
                    + 添加时间点
                </button>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary" onclick="hideModal('schedule-times-modal')">取消</button>
                <button class="modal-primary" onclick="saveScheduleTimes()">保存</button>
            </div>
        </div>
    </div>

    <!-- 日记功能模态框 -->
    <div id="diary-menu-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">日记</h3>
                <button class="modal-close" onclick="hideDiaryMenu()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="diary-menu-options">
                    <div class="diary-option" onclick="showTodayDiary()">
                        <div class="diary-option-icon">
                            <i class="fas fa-calendar-day"></i>
                        </div>
                        <div class="diary-option-content">
                            <div class="diary-option-title">今日日记</div>
                            <div class="diary-option-desc">查看今天的日记（一天只能保留一份）</div>
                        </div>
                    </div>
                    <div class="diary-option" onclick="showPastDiaries()">
                        <div class="diary-option-icon">
                            <i class="fas fa-history"></i>
                        </div>
                        <div class="diary-option-content">
                            <div class="diary-option-title">过往日记</div>
                            <div class="diary-option-desc">查看历史日记记录</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 今日日记显示模态框 -->
    <div id="today-diary-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">今日日记</h3>
                <div class="diary-actions">
                    <button class="diary-action-btn" onclick="generateTodayDiary()" id="generate-diary-btn" title="生成日记">
                        <i class="fas fa-sync-alt"></i>
                    </button>
                    <button class="diary-action-btn secondary edit-btn" onclick="editTodayDiary()" id="edit-diary-btn" title="编辑日记" style="display: none;">
                        <i class="fas fa-pencil-alt"></i>
                    </button>
                </div>
                <button class="modal-close" onclick="hideTodayDiary()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="diary-paper-container">
                    <div id="today-diary-content" class="diary-paper">
                        <!-- 日记内容将在这里显示 -->
                    </div>
                </div>

            </div>
        </div>
    </div>

    <!-- 过往日记列表模态框 -->
    <div id="past-diaries-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">过往日记</h3>
                <button class="modal-close" onclick="hidePastDiaries()">&times;</button>
            </div>
            <div class="modal-body">
                <div id="past-diaries-list">
                    <!-- 过往日记列表将在这里显示 -->
                </div>
            </div>
        </div>
    </div>

    <!-- 位置分享模态框 -->
    <div id="location-modal" class="modal" style="display: none;">
        <div class="modal-content location-modal-content">
            <div class="modal-header">
                <h3 class="modal-title">分享位置</h3>
                <button class="modal-close" onclick="hideLocationModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="location-input-section">
                    <label for="location-address">位置名称</label>
                    <input type="text" id="location-address" placeholder="请输入位置名称，如：咖啡厅、学校、家..." maxlength="50">
                    
                    <!-- 最近使用历史记录 -->
                    <div class="location-history" id="location-history">
                        <div class="location-history-title">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
                                <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                            </svg>
                            最近使用
                        </div>
                        <div class="location-history-items" id="location-history-items">
                            <div class="location-history-empty">暂无历史记录</div>
                        </div>
                    </div>
                </div>
                <div class="virtual-map-container">
                    <div class="map-header" style="background: linear-gradient(135deg, #f6ffed 0%, #d9f7be 100%);">
                        <div class="map-location-name" id="map-location-display" style="color: #52c41a;">请输入位置名称</div>
                        <div class="map-coordinates" style="color: #73d13d;">116.4074°E, 39.9042°N</div>
                    </div>
                    <div class="virtual-map">
                        <div class="map-background"></div>
                        <!-- 弯曲河流 -->
                        <div class="river" style="top: 8%; left: 55%; width: 25px; height: 4px; transform: rotate(30deg);"></div>
                        <div class="river-curve" style="top: 18%; left: 68%; width: 22px; height: 4px; transform: rotate(10deg);"></div>
                        <div class="river" style="top: 26%; left: 78%; width: 20px; height: 4px; transform: rotate(-10deg);"></div>
                        <div class="river-curve" style="top: 32%; left: 85%; width: 18px; height: 4px; transform: rotate(-30deg);"></div>
                        <div class="river" style="top: 60%; left: 5%; width: 28px; height: 4px; transform: rotate(-15deg);"></div>
                        <div class="river-curve" style="top: 68%; left: 25%; width: 25px; height: 4px; transform: rotate(5deg);"></div>
                        <div class="river" style="top: 75%; left: 42%; width: 22px; height: 4px; transform: rotate(20deg);"></div>
                        <!-- 公园绿地 -->
                        <div style="position: absolute; top: 25%; left: 65%; width: 25px; height: 20px; background: linear-gradient(135deg, #f6ffed 0%, #d9f7be 50%, #b7eb8f 100%); border-radius: 3px; opacity: 0.6; z-index: 1;"></div>
                        <div style="position: absolute; top: 50%; left: 15%; width: 30px; height: 25px; background: linear-gradient(135deg, #f6ffed 0%, #d9f7be 50%, #b7eb8f 100%); border-radius: 3px; opacity: 0.6; z-index: 1;"></div>
                        <!-- 道路 -->
                        <div class="map-roads">
                            <div class="road road-horizontal" style="top: 30%; left: 0; width: 100%;"></div>
                            <div class="road road-vertical" style="left: 25%; top: 0; height: 100%;"></div>
                            <div class="road road-horizontal" style="top: 70%; left: 0; width: 100%;"></div>
                            <div class="road road-vertical" style="left: 75%; top: 0; height: 100%;"></div>
                        </div>
                        <!-- 建筑物 -->
                        <div class="map-buildings">
                            <div class="building" style="top: 10%; left: 35%; width: 20px; height: 15px; background: linear-gradient(135deg, #f0f0f0 0%, #d9d9d9 100%); border: 1px solid #bfbfbf; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                            <div class="building" style="top: 15%; left: 55%; width: 25px; height: 20px; background: linear-gradient(135deg, #e6f7ff 0%, #bae7ff 100%); border: 1px solid #91d5ff; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                            <div class="building" style="top: 40%; left: 10%; width: 18px; height: 12px; background: linear-gradient(135deg, #fff1f0 0%, #ffd8d6 100%); border: 1px solid #ffaaa5; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                            <div class="building" style="top: 45%; left: 85%; width: 22px; height: 18px; background: linear-gradient(135deg, #f0f0f0 0%, #d9d9d9 100%); border: 1px solid #bfbfbf; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                            <div class="building" style="top: 75%; left: 40%; width: 30px; height: 20px; background: linear-gradient(135deg, #e6f7ff 0%, #bae7ff 100%); border: 1px solid #91d5ff; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                            <div class="building" style="top: 80%; left: 15%; width: 20px; height: 15px; background: linear-gradient(135deg, #fff1f0 0%, #ffd8d6 100%); border: 1px solid #ffaaa5; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                        </div>
                        <!-- 树木 -->
                        <div style="position: absolute; top: 35%; left: 20%; width: 8px; height: 8px; background: radial-gradient(circle, #52c41a 0%, #389e0d 70%, #237804 100%); border-radius: 50%; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15); z-index: 3;"></div>
                        <div style="position: absolute; top: 60%; left: 30%; width: 6px; height: 6px; background: radial-gradient(circle, #73d13d 0%, #52c41a 70%, #389e0d 100%); border-radius: 50%; box-shadow: 0 0.5px 1px rgba(0, 0, 0, 0.1); z-index: 3;"></div>
                        <div style="position: absolute; top: 12%; left: 70%; width: 7px; height: 7px; background: radial-gradient(circle, #52c41a 0%, #389e0d 70%, #237804 100%); border-radius: 50%; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15); z-index: 3;"></div>
                        <div style="position: absolute; top: 85%; left: 90%; width: 5px; height: 5px; background: radial-gradient(circle, #73d13d 0%, #52c41a 70%, #389e0d 100%); border-radius: 50%; box-shadow: 0 0.5px 1px rgba(0, 0, 0, 0.1); z-index: 3;"></div>
                        <div style="position: absolute; top: 50%; left: 90%; width: 6px; height: 6px; background: radial-gradient(circle, #73d13d 0%, #52c41a 70%, #389e0d 100%); border-radius: 50%; box-shadow: 0 0.5px 1px rgba(0, 0, 0, 0.1); z-index: 3;"></div>
                        <!-- 位置标记 -->
                        <div class="map-marker" id="location-marker">
                            <div class="marker-pin">
                                <svg width="28" height="28" viewBox="0 0 24 24" fill="none">
                                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                </svg>
                            </div>
                        </div>
                        <div class="map-current-location">
                            <div class="current-location-dot"></div>
                        </div>
                    </div>
                    <div class="map-footer">
                        <div class="map-scale">500m</div>
                        <div class="map-controls">
                            <button class="map-control-btn" onclick="randomizeMapPosition()">🎯 重新定位</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary" onclick="hideLocationModal()">取消</button>
                <button class="modal-primary" onclick="sendLocationMessage()">发送位置</button>
            </div>
        </div>
    </div>
    </div>

    <script>
        // 🔥【新增】群成员头像上传事件监听
        document.addEventListener('DOMContentLoaded', function() {
            const memberAvatarUpload = document.getElementById('member-avatar-upload');
            if (memberAvatarUpload) {
                memberAvatarUpload.addEventListener('change', function(e) {
                    if (e.target.files && e.target.files[0]) {
                        const file = e.target.files[0];
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            const preview = document.getElementById('member-avatar-preview');
                            if (preview) {
                                preview.src = event.target.result;
                            }
                        };
                        reader.readAsDataURL(file);
                    }
                });
            }
        });
    </script>

    <!-- 🔥【永久修复】身份选择功能自动修复脚本 -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🔧 开始应用身份选择功能永久修复...');
            
            // 修复1: 重写showPersonaSelectionForSingleChat函数
            if (typeof showPersonaSelectionForSingleChat === 'function') {
                const originalShowPersonaSelectionForSingleChat = showPersonaSelectionForSingleChat;
                showPersonaSelectionForSingleChat = function() {
                    originalShowPersonaSelectionForSingleChat();
                    
                    // 延迟修复事件绑定，确保DOM已生成
                    setTimeout(() => {
                        const items = document.querySelectorAll('#persona-selection-modal .persona-selection-item');
                        console.log('🔧 修复身份选择事件绑定，找到元素:', items.length);
                        
                        items.forEach(item => {
                            // 移除旧的事件监听器
                            item.onclick = null;
                            
                            // 添加新的点击事件
                            item.addEventListener('click', function() {
                                console.log('身份选择点击:', this.dataset.personaId);
                                
                                // 移除所有选中状态
                                document.querySelectorAll('#persona-selection-modal .persona-selection-item').forEach(i => {
                                    i.classList.remove('selected');
                                });
                                
                                // 设置当前元素为选中
                                this.classList.add('selected');
                                
                                // 保存身份ID
                                window.selectedPersonaForChat = this.dataset.personaId;
                                console.log('设置selectedPersonaForChat:', window.selectedPersonaForChat);
                                
                                // 启用确认按钮
                                const confirmBtn = document.getElementById('confirm-persona-btn');
                                if (confirmBtn) {
                                    confirmBtn.disabled = false;
                                }
                            });
                        });
                    }, 100);
                };
            }
            
            // 修复2: 重写confirmPersonaAndShowCharacters函数
            if (typeof confirmPersonaAndShowCharacters === 'function') {
                confirmPersonaAndShowCharacters = function() {
                    console.log('confirmPersonaAndShowCharacters调用，身份ID:', window.selectedPersonaForChat);
                    
                    if (!window.selectedPersonaForChat) {
                        console.error('身份ID为空！');
                        return;
                    }
                    
                    // 保存身份ID
                    const savedPersonaId = window.selectedPersonaForChat;
                    
                    // 隐藏模态框
                    const modal = document.getElementById('persona-selection-modal');
                    if (modal) {
                        modal.remove();
                    }
                    
                    // 恢复身份ID
                    window.selectedPersonaForChat = savedPersonaId;
                    console.log('保护后的身份ID:', window.selectedPersonaForChat);
                    
                    showCharacterSelectionForSingleChat();
                };
            }
            
            // 修复3: 重写buildCharacterPrompt函数
            if (typeof buildCharacterPrompt === 'function') {
                const originalBuildCharacterPrompt = buildCharacterPrompt;
                buildCharacterPrompt = function(character, hasImage = false) {
                    // 调用原函数获取基础prompt
                    let characterPrompt = originalBuildCharacterPrompt(character, hasImage);
                    
                    // 移除原有的currentPersona逻辑，替换为从聊天设置读取
                    const chatSettings = getCurrentChatSettings();
                    if (chatSettings.selectedIdentityId) {
                        const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                        if (selectedPersona) {
                            console.log('🔧 为角色', character.name, '使用身份:', selectedPersona.name);
                            
                            // 移除旧的身份信息（如果有）
                            const personaRegex = /\n\n# 对话者的角色设定：[\s\S]*?请根据用户的这个面具身份来进行对话。/;
                            characterPrompt = characterPrompt.replace(personaRegex, '');
                            
                            // 添加新的身份信息
                            const personaInfo = `\n\n# 对话者的角色设定：\n用户当前使用的面具是"${selectedPersona.name}"${selectedPersona.description ? `：${selectedPersona.description}` : ''}\n请根据用户的这个面具身份来进行对话。`;
                            
                            // 在角色设定后插入身份信息
                            const insertPoint = characterPrompt.indexOf('\n# 🔥【修复】表情包库信息');
                            if (insertPoint !== -1) {
                                characterPrompt = characterPrompt.slice(0, insertPoint) + personaInfo + characterPrompt.slice(insertPoint);
                            } else {
                                characterPrompt += personaInfo;
                            }
                        }
                    }
                    
                    return characterPrompt;
                };
            }
            
            console.log('✅ 身份选择功能永久修复已应用');
        });
    </script>

    <!-- 🔧【简单修复】群聊身份设置直接修复 -->
    <script>
        // 简单直接的群聊身份修复
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🔧 [简单修复] 群聊身份设置修复启动...');
            
            // 重写createGroupChat函数，确保身份设置立即生效
            if (typeof window.createGroupChat === 'function') {
                const originalCreateGroupChat = window.createGroupChat;
                window.createGroupChat = async function(personaId) {
                    console.log('🔧 [修复] createGroupChat被调用，身份ID:', personaId);
                    
                    // 调用原函数，传递personaId参数
                    await originalCreateGroupChat.call(this, personaId);
                    
                    // 如果有选择身份，立即加载到内存
                    if (personaId && groupChats && groupChats.length > 0) {
                        const latestGroup = groupChats[groupChats.length - 1];
                        const savedSettings = localStorage.getItem(`chatSettings_${latestGroup.id}`);
                        
                        if (savedSettings) {
                            try {
                                const settings = JSON.parse(savedSettings);
                                window.chatSettings[latestGroup.id] = settings;
                                console.log('🔧 [修复] 群聊身份设置已加载到内存:', settings);
                            } catch (error) {
                                console.error('🔧 [修复] 解析群聊设置失败:', error);
                            }
                        }
                    }
                };
            }
            
            console.log('🔧 [简单修复] 群聊身份设置修复完成');
        });
    </script>

    <!-- 📱【移动端优化】输入框viewport行为修复 -->
    <script>
        // 移动端输入框优化
        (function() {
            'use strict';
            
            console.log('📱 [移动端优化] 输入框viewport行为修复启动...');
            
            let isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            let isAndroid = /Android/.test(navigator.userAgent);
            let isMobile = isIOS || isAndroid;
            
            if (!isMobile) {
                console.log('📱 非移动端设备，跳过移动端优化');
                return;
            }
            
            // 获取所有可能的输入框
            function getAllInputs() {
                return document.querySelectorAll('textarea, input[type="text"], input[type="password"], input[type="email"], input[type="number"]');
            }
            
            // 防止iOS Safari自动缩放
            function preventZoom() {
                const viewportMeta = document.querySelector('meta[name="viewport"]');
                if (viewportMeta) {
                    viewportMeta.setAttribute('content', 
                        'width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no'
                    );
                }
            }
            
            // 恢复缩放功能
            function restoreZoom() {
                const viewportMeta = document.querySelector('meta[name="viewport"]');
                if (viewportMeta) {
                    viewportMeta.setAttribute('content', 
                        'width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=3.0, user-scalable=yes'
                    );
                }
            }
            
            // 输入框焦点处理
            function handleInputFocus(e) {
                console.log('📱 输入框获得焦点，防止自动缩放');
                
                // 防止iOS自动缩放
                if (isIOS) {
                    preventZoom();
                }
                
                // 确保输入框可见
                setTimeout(() => {
                    e.target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center'
                    });
                }, 300);
            }
            
            // 输入框失焦处理
            function handleInputBlur(e) {
                console.log('📱 输入框失去焦点，恢复缩放功能');

                // 恢复缩放功能
                if (isIOS) {
                    setTimeout(() => {
                        restoreZoom();
                    }, 100);
                }

                // 🔥【关键修复】强制重新计算布局，防止页面偏移
                setTimeout(() => {
                    // 重置滚动位置
                    window.scrollTo(0, 0);
                    document.body.scrollTop = 0;
                    document.documentElement.scrollTop = 0;

                    // 强制重新计算虚拟手机的位置
                    const phoneScreen = document.getElementById('phone-screen');
                    if (phoneScreen) {
                        // 临时改变一个样式属性来触发重新渲染
                        phoneScreen.style.transform = 'translateZ(0)';
                        setTimeout(() => {
                            phoneScreen.style.transform = '';
                        }, 10);
                    }

                    // 确保body居中对齐
                    document.body.style.display = 'flex';
                    document.body.style.justifyContent = 'center';
                    document.body.style.alignItems = 'center';
                }, 300);
            }
            
            // 绑定事件到所有输入框
            function bindInputEvents() {
                const inputs = getAllInputs();
                console.log(`📱 找到 ${inputs.length} 个输入框，正在绑定事件...`);
                
                inputs.forEach(input => {
                    // 移除旧的事件监听器（如果存在）
                    input.removeEventListener('focus', handleInputFocus);
                    input.removeEventListener('blur', handleInputBlur);
                    
                    // 添加新的事件监听器
                    input.addEventListener('focus', handleInputFocus, { passive: true });
                    input.addEventListener('blur', handleInputBlur, { passive: true });
                    
                    // 确保输入框字体大小至少16px（防止iOS缩放）
                    const computedStyle = window.getComputedStyle(input);
                    const fontSize = parseInt(computedStyle.fontSize);
                    if (fontSize < 16) {
                        input.style.fontSize = '16px';
                        console.log('📱 调整输入框字体大小为16px，防止iOS缩放');
                    }
                });
            }
            
            // 监听DOM变化，处理动态添加的输入框
            const observer = new MutationObserver(function(mutations) {
                let shouldRebind = false;
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList') {
                        mutation.addedNodes.forEach(function(node) {
                            if (node.nodeType === 1) { // Element node
                                if (node.matches && (node.matches('textarea') || node.matches('input'))) {
                                    shouldRebind = true;
                                } else if (node.querySelector) {
                                    const inputs = node.querySelectorAll('textarea, input');
                                    if (inputs.length > 0) {
                                        shouldRebind = true;
                                    }
                                }
                            }
                        });
                    }
                });
                
                if (shouldRebind) {
                    console.log('📱 检测到新的输入框，重新绑定事件...');
                    setTimeout(bindInputEvents, 100);
                }
            });
            
            // 开始监听DOM变化
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
            
            // 页面加载完成后绑定事件
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', bindInputEvents);
            } else {
                bindInputEvents();
            }
            
            // 页面显示时重新绑定（处理从后台返回的情况）
            document.addEventListener('visibilitychange', function() {
                if (!document.hidden) {
                    setTimeout(bindInputEvents, 100);
                }
            });
            
            // 🔥【新增】监听viewport变化，修复虚拟键盘收起后的布局问题
            let initialViewportHeight = window.innerHeight;
            let isKeyboardOpen = false;

            function handleViewportChange() {
                const currentHeight = window.innerHeight;
                const heightDiff = initialViewportHeight - currentHeight;

                // 判断虚拟键盘是否打开（高度减少超过150px认为是键盘打开）
                const keyboardWasOpen = isKeyboardOpen;
                isKeyboardOpen = heightDiff > 150;

                console.log(`📱 Viewport变化: ${currentHeight}px (初始: ${initialViewportHeight}px, 差值: ${heightDiff}px, 键盘状态: ${isKeyboardOpen})`);

                // 如果键盘从打开变为关闭，强制修复布局
                if (keyboardWasOpen && !isKeyboardOpen) {
                    console.log('📱 检测到虚拟键盘关闭，修复布局...');
                    setTimeout(() => {
                        // 重置所有滚动位置
                        window.scrollTo(0, 0);
                        document.body.scrollTop = 0;
                        document.documentElement.scrollTop = 0;

                        // 强制重新渲染虚拟手机
                        const phoneScreen = document.getElementById('phone-screen');
                        if (phoneScreen) {
                            phoneScreen.style.transform = 'translateZ(0)';
                            requestAnimationFrame(() => {
                                phoneScreen.style.transform = '';
                            });
                        }

                        // 确保body布局正确
                        document.body.style.height = '100%';
                        document.body.style.display = 'flex';
                        document.body.style.justifyContent = 'center';
                        document.body.style.alignItems = 'center';
                    }, 100);
                }
            }

            // 监听viewport变化
            window.addEventListener('resize', handleViewportChange, { passive: true });
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    initialViewportHeight = window.innerHeight;
                    handleViewportChange();
                }, 500);
            }, { passive: true });

            console.log('📱 [移动端优化] 输入框viewport行为修复已启动');
        })();
    </script>

    <!-- 💰【转账功能优化】让AI根据人设自然回应 -->
    <script>
        // 转账功能优化 - 移除自动收款，让AI根据人设自然回应
        (function() {
            'use strict';
            
            console.log('💰 [转账优化] 移除自动收款逻辑，让AI根据人设自然回应...');
            
            // 🔥【重要修改】移除自动收款逻辑，让AI根据角色人设自然决定
            // 转账状态变化应该由AI的自然回复触发，而不是自动处理
            // AI会根据自己的人设（比如高冷、温柔、傲娇等）来决定是否收款
            
            console.log('💰 [转账优化] AI将根据角色人设自然回应转账，不再自动收款');
        })();
    </script>

    <!-- 🚫【拉黑系统】模态框 -->
    <div id="blacklist-settings-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">拉黑管理</h3>
                <button class="modal-close" onclick="hideBlacklistSettings()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="settings-section">
                    <div class="section-header">
                        <i class="fas fa-user-slash section-icon"></i>
                        <span class="section-title">当前状态</span>
                    </div>
                    <div class="setting-card">
                        <div class="setting-item" id="current-blacklist-status">
                            <div class="setting-left">
                                <div class="setting-label">拉黑状态</div>
                                <div class="setting-desc" id="blacklist-status-desc">正常聊天中</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="settings-section">
                    <div class="section-header">
                        <i class="fas fa-cog section-icon"></i>
                        <span class="section-title">拉黑设置</span>
                    </div>

                </div>

                <div class="settings-section">
                    <div class="section-header">
                        <i class="fas fa-exclamation-triangle section-icon danger-section-icon"></i>
                        <span class="section-title danger-section-title">操作</span>
                    </div>
                    <div class="setting-card">
                        <div class="setting-item danger-item" id="block-action-item" onclick="performBlockAction()">
                            <div class="setting-left">
                                <div class="setting-label danger-color" id="block-action-label">拉黑此角色</div>
                                <div class="setting-desc" id="block-action-desc">阻止该角色向你发送消息</div>
                            </div>
                            <div class="setting-right">
                                <i class="fas fa-chevron-right danger-color"></i>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary" onclick="hideBlacklistSettings()">关闭</button>
            </div>
        </div>
    </div>

    <!-- 🚫【好友申请】模态框 -->
    <div id="friend-request-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">好友申请</h3>
                <button class="modal-close" onclick="hideFriendRequestModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">申请理由（可选）</label>
                    <textarea id="friend-request-message" class="form-textarea" placeholder="请输入申请理由..." maxlength="200"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary" onclick="hideFriendRequestModal()">取消</button>
                <button class="modal-primary" onclick="sendFriendRequestConfirm()">发送申请</button>
            </div>
        </div>
    </div>

    <!-- 🔥【新增】心声模态框 -->
    <div id="inner-thoughts-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">
                    <svg class="ear-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 4C7.58 4 4 7.58 4 12C4 16.42 7.58 20 12 20C16.42 20 20 16.42 20 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        <path d="M17 4C17 4 20 4 20 7C20 10 17 10 17 13C17 16 20 16 20 16" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                    </svg>
                    心声
                </h3>
                <button class="modal-close" onclick="hideInnerThoughtsModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div id="inner-thoughts-content" class="inner-thoughts-content">
                    <div class="inner-thoughts-loading">
                        <div class="loading-spinner"></div>
                        <p>正在读取角色的内心想法...</p>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary inner-thoughts-refresh-btn" onclick="refreshInnerThoughts(selectedMessageId)">
                    <i class="fas fa-sync-alt"></i> 重新生成
                </button>
                <button class="modal-secondary" onclick="hideInnerThoughtsModal()">关闭</button>
            </div>
        </div>
    </div>

    <!-- 🚫【拉黑系统】JavaScript核心功能 -->
    <script>
        // 拉黑系统全局变量 - 检查是否已存在，避免重复声明
        if (typeof blacklistData === 'undefined') {
            var blacklistData = [];
            var friendRequestsData = [];
            var characterStatusData = [];
        }

        // 加载拉黑系统数据
        async function loadBlacklistData() {
            try {
                blacklistData = await db.blacklist.orderBy('timestamp').reverse().toArray();
                console.log('拉黑数据加载完成:', blacklistData);
            } catch (error) {
                console.error('加载拉黑数据失败:', error);
                blacklistData = [];
            }
        }

        // 检查是否被拉黑
        function isBlocked(blockerId, blockedId) {
            return blacklistData.some(record => 
                record.blockerId === blockerId && 
                record.blockedId === blockedId && 
                !record.unblocked
            );
        }



        // 拉黑角色
        async function blockCharacter(characterId, reason = '') {
            try {
                const now = new Date();

                if (isBlocked('user', characterId)) {
                    showToast('该角色已被拉黑', 'warning');
                    return;
                }

                const blockRecord = {
                    id: `block_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    blockerId: 'user',
                    blockedId: characterId,
                    timestamp: now.toISOString(),
                    reason: reason,
                    unblocked: false
                };
                
                blacklistData.unshift(blockRecord);
                await db.blacklist.add(blockRecord);
                
                const character = characters.find(c => c.id === characterId);
                showToast(`已拉黑 ${character?.name || '角色'}`, 'success');
                
                // 🔥【新增】通知角色被拉黑了
                await notifyCharacterBlocked(characterId, reason);
                
                // 立即更新聊天界面显示
                if (currentChatCharacter && currentChatCharacter.id === characterId) {
                    updateChatBlockedStatus();
                }
                
                renderContactList();
                renderMessageList();
                
            } catch (error) {
                console.error('拉黑角色失败:', error);
                showToast('拉黑失败', 'error');
            }
        }

        // 解除拉黑
        async function unblockCharacter(characterId) {
            try {
                const blockRecord = blacklistData.find(r => 
                    r.blockerId === 'user' && 
                    r.blockedId === characterId && 
                    !r.unblocked
                );
                
                if (!blockRecord) {
                    showToast('该角色未被拉黑', 'warning');
                    return;
                }
                
                blockRecord.unblocked = true;
                blockRecord.unblockTimestamp = new Date().toISOString();
                
                await db.blacklist.put(blockRecord);
                
                const character = characters.find(c => c.id === characterId);
                showToast(`已解除对 ${character?.name || '角色'} 的拉黑`, 'success');
                
                // 🔥【新增】通知角色被解除拉黑了
                await notifyCharacterUnblocked(characterId);
                
                // 刷新聊天界面显示
                if (currentChatCharacter && currentChatCharacter.id === characterId) {
                    renderChatMessages(currentChatCharacter.id);
                    updateChatBlockedStatus();
                }
                
                renderContactList();
                renderMessageList();
                
            } catch (error) {
                console.error('解除拉黑失败:', error);
                showToast('解除拉黑失败', 'error');
            }
        }

        // 更新角色状态
        async function updateCharacterStatus(characterId, status, activity = '', location = '') {
            try {
                let statusRecord = characterStatusData.find(s => s.characterId === characterId);

                if (!statusRecord) {
                    statusRecord = {
                        id: `status_${characterId}`,
                        characterId: characterId,
                        status: status,
                        activity: activity,
                        location: location,
                        lastUpdate: new Date().toISOString(),
                        lastChatTime: null // 🔥【新增】保留最后聊天时间字段
                    };
                    characterStatusData.push(statusRecord);
                } else {
                    // 🔥【修复】保留现有的lastChatTime字段
                    const existingLastChatTime = statusRecord.lastChatTime;
                    statusRecord.status = status;
                    statusRecord.activity = activity;
                    statusRecord.location = location;
                    statusRecord.lastUpdate = new Date().toISOString();
                    statusRecord.lastChatTime = existingLastChatTime; // 保留原有的聊天时间
                }

                await db.characterStatus.put(statusRecord);

            } catch (error) {
                console.error('更新角色状态失败:', error);
            }
        }

        // 获取角色状态
        function getCharacterStatus(characterId) {
            return characterStatusData.find(s => s.characterId === characterId) || {
                status: 'online',
                activity: '在线',
                location: '',
                lastUpdate: new Date().toISOString(),
                lastChatTime: null // 🔥【新增】最后聊天时间
            };
        }

        // 角色拉黑用户
        async function aiBlockUser(characterId, reason = '') {
            try {
                const now = new Date();
                
                // 检查是否已经拉黑
                if (isBlocked(characterId, 'user')) {
                    return;
                }
                
                const blockRecord = {
                    id: `block_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    blockerId: characterId,
                    blockedId: 'user',
                    timestamp: now.toISOString(),
                    reason: reason,
                    unblocked: false
                };
                
                blacklistData.unshift(blockRecord);
                await db.blacklist.add(blockRecord);
                
                // 更新聊天界面显示
                if (currentChatCharacter && currentChatCharacter.id === characterId) {
                    updateChatBlockedStatus();
                }
                
                const character = characters.find(c => c.id === characterId);
                showToast(`${character?.name || '角色'} 已将你拉黑`, 'warning');
                
            } catch (error) {
                console.error('角色拉黑用户失败:', error);
            }
        }

        // 发送好友申请
        async function sendFriendRequest(characterId, message = '') {
            try {
                const request = {
                    id: `request_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    fromId: 'user',
                    toId: characterId,
                    timestamp: new Date().toISOString(),
                    status: 'pending',
                    type: 'friend',
                    message: message
                };
                
                friendRequestsData.unshift(request);
                await db.friendRequests.add(request);
                
                showToast('好友申请已发送', 'success');
                
            } catch (error) {
                console.error('发送好友申请失败:', error);
                showToast('发送申请失败', 'error');
            }
        }

        // 🔥【修改】更新聊天界面的拉黑状态显示 - 群聊不显示拉黑提示
        function updateChatBlockedStatus() {
            if (!currentChatCharacter) return;

            const characterId = currentChatCharacter.id;
            const isGroupChat = currentChatCharacter.isGroup;

            // 移除现有的拉黑提示
            const existingBlockedUI = document.querySelector('.blocked-input-notice');
            if (existingBlockedUI) {
                existingBlockedUI.remove();
            }

            // 移除现有的角色被拉黑提示
            const existingCharacterHint = document.querySelector('.character-blocked-hint');
            if (existingCharacterHint) {
                existingCharacterHint.remove();
            }

            // 🔥【修改】群聊不显示拉黑相关提示，只有单聊才处理拉黑状态
            if (!isGroupChat) {
                const isUserBlocked = isBlocked('user', characterId);
                const isCharacterBlocked = isBlocked(characterId, 'user');

                // 当用户被角色拉黑时，在输入框上方显示提示
                if (isCharacterBlocked) {
                    const inputArea = document.querySelector('.chat-input-area');
                    if (inputArea) {
                        const blockedNotice = document.createElement('div');
                        blockedNotice.className = 'blocked-input-notice show';

                        blockedNotice.innerHTML = `
                            <div class="notice-text">你被 ${currentChatCharacter.name} 拉黑了</div>
                            <button class="notice-button" onclick="showFriendRequestModal()">申请添加为好友</button>
                        `;

                        inputArea.appendChild(blockedNotice);
                    }

                    // 🔥【新增】在聊天区域显示角色申请好友的提示
                    addCharacterBlockedHint(characterId);
                }

                // 重新渲染消息列表以显示拉黑状态指示器
                renderChatMessages(characterId);
            }
        }

        // 🔥【新增】在聊天界面显示角色被拉黑的提示
        function addCharacterBlockedHint(characterId) {
            const messagesContainer = document.getElementById('chat-messages');
            if (!messagesContainer) return;

            // 移除现有的提示
            const existingHint = messagesContainer.querySelector('.character-blocked-hint');
            if (existingHint) {
                existingHint.remove();
            }

            // 创建提示消息
            const hintContainer = document.createElement('div');
            hintContainer.className = 'character-blocked-hint';
            hintContainer.style.cssText = `
                text-align: center;
                margin: 20px auto;
                padding: 15px 20px;
                background: rgba(255, 193, 7, 0.1);
                border: 1px solid rgba(255, 193, 7, 0.3);
                border-radius: 12px;
                max-width: 320px;
                color: #856404;
                font-size: 13px;
                line-height: 1.4;
            `;

            hintContainer.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 8px;">💡 提示</div>
                <div>${currentChatCharacter.name} 被拉黑了，但仍可以发送消息。如果想修复关系，可以发送好友申请。</div>
                <div style="margin-top: 8px; font-size: 12px; color: #6c757d;">
                    好友申请格式：{"type": "friend_request", "message": "道歉或请求信息"}
                </div>
            `;

            // 将提示添加到消息容器的顶部
            messagesContainer.insertBefore(hintContainer, messagesContainer.firstChild);
        }

        // 🔥【修复】检查拉黑状态并创建系统消息（只在发送消息时调用一次）
        function checkAndCreateBlockedSystemMessage(userMessage, characterId) {
            if (!currentChatCharacter || currentChatCharacter.isGroup) return; // 群聊不处理拉黑

            // 检查角色是否拉黑了用户
            const isCharacterBlocked = isBlocked(characterId, 'user');

            if (isCharacterBlocked) {
                // 🔥【修复】不保存到聊天记录，只在界面上临时显示系统提示
                // 创建临时的系统提示元素
                const messagesContainer = document.getElementById('api-chat-messages');
                const systemHint = document.createElement('div');
                systemHint.className = 'blocked-message-hint';
                systemHint.style.cssText = `
                    text-align: center;
                    color: #999;
                    font-size: 12px;
                    padding: 4px 8px;
                    margin: 2px 0;
                    background: transparent;
                    border: none;
                    display: block;
                    max-width: 80%;
                    width: fit-content;
                    margin-left: auto;
                    margin-right: auto;
                `;
                systemHint.textContent = '消息已发出，但被对方拒收了';

                // 添加到界面
                messagesContainer.appendChild(systemHint);

                // 滚动到底部
                setTimeout(() => {
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                }, 100);
            }
        }

        // 🔥【新增】清理已保存的拉黑系统消息
        function cleanupBlockedSystemMessages() {
            let hasChanges = false;

            // 遍历所有聊天记录
            Object.keys(chatMessages).forEach(characterId => {
                const messages = chatMessages[characterId];
                const originalLength = messages.length;

                // 过滤掉拉黑系统消息
                chatMessages[characterId] = messages.filter(msg =>
                    !(msg.sender === 'system' && msg.isBlockedMessage)
                );

                if (chatMessages[characterId].length !== originalLength) {
                    hasChanges = true;
                    console.log(`🧹 [清理] 从角色 ${characterId} 的聊天记录中移除了 ${originalLength - chatMessages[characterId].length} 条拉黑系统消息`);
                }
            });

            // 如果有变化，保存到数据库
            if (hasChanges) {
                saveChatMessages();
                console.log('🧹 [清理] 拉黑系统消息清理完成，已保存到数据库');
            }
        }

        // 🔥【修复】为消息添加拉黑状态指示器 - 显示红色感叹号和系统提示
        function addBlockedIndicatorToMessage(messageContainer, message, characterId) {
            if (!currentChatCharacter) return;

            // 检查消息是否在拉黑状态下发送
            const messageTimestamp = message.timestamp;
            let shouldShowIndicator = false;
            let blockTimestamp = null;

            // 🔥【修复】查找相关的拉黑记录 - 即使解除拉黑后也要显示历史消息的指示器
            if (message.sender === 'sent') {
                // 用户发送的消息，检查角色是否曾经拉黑了用户
                const blockRecord = blacklistData.find(r =>
                    r.blockerId === characterId &&
                    r.blockedId === 'user'
                    // 🔥【移除】不再检查 !r.unblocked，让历史消息保留指示器
                );
                if (blockRecord) {
                    blockTimestamp = new Date(blockRecord.timestamp).getTime();
                    // 🔥【修复】如果消息是在拉黑期间发送的，就显示指示器
                    const unblockTimestamp = blockRecord.unblocked && blockRecord.unblockTimestamp
                        ? new Date(blockRecord.unblockTimestamp).getTime()
                        : Date.now();
                    shouldShowIndicator = messageTimestamp >= blockTimestamp &&
                                        (messageTimestamp <= unblockTimestamp || !blockRecord.unblocked);
                }
            } else if (message.sender === 'received') {
                // 角色发送的消息，检查用户是否曾经拉黑了角色
                const blockRecord = blacklistData.find(r =>
                    r.blockerId === 'user' &&
                    r.blockedId === characterId
                    // 🔥【移除】不再检查 !r.unblocked，让历史消息保留指示器
                );
                if (blockRecord) {
                    blockTimestamp = new Date(blockRecord.timestamp).getTime();
                    // 🔥【修复】如果消息是在拉黑期间发送的，就显示指示器
                    const unblockTimestamp = blockRecord.unblocked && blockRecord.unblockTimestamp
                        ? new Date(blockRecord.unblockTimestamp).getTime()
                        : Date.now();
                    shouldShowIndicator = messageTimestamp >= blockTimestamp &&
                                        (messageTimestamp <= unblockTimestamp || !blockRecord.unblocked);
                }
            }

            if (shouldShowIndicator) {
                // 🔥【修复】检查是否已经有指示器，避免重复添加
                const existingIndicator = messageContainer.querySelector('.message-blocked-indicator');
                const existingHint = messageContainer.nextElementSibling?.classList.contains('blocked-message-hint-inline');

                if (existingIndicator && existingHint) {
                    return; // 已经有指示器和提示了，不重复添加
                }

                // 创建拉黑指示器（红色感叹号）
                if (!existingIndicator) {
                    const indicator = document.createElement('div');
                    indicator.className = 'message-blocked-indicator';
                    indicator.innerHTML = '!';
                    indicator.title = '消息已发出，但被对方拒收了';

                    // 添加指示器到消息容器
                    messageContainer.style.position = 'relative';
                    messageContainer.appendChild(indicator);

                    // 🔥【新增】动态定位感叹号到气泡外侧
                    setTimeout(() => {
                        const bubble = messageContainer.querySelector('.message-bubble');
                        if (bubble) {
                            // 获取气泡相对于消息容器的位置
                            const containerRect = messageContainer.getBoundingClientRect();
                            const bubbleRect = bubble.getBoundingClientRect();

                            if (message.sender === 'sent') {
                                // 用户消息：感叹号在气泡左边
                                const bubbleLeftOffset = bubbleRect.left - containerRect.left;
                                indicator.style.left = (bubbleLeftOffset - 20) + 'px'; // 16px感叹号宽度 + 4px间距
                                indicator.style.right = 'auto';
                            } else if (message.sender === 'received') {
                                // 🔥【修复】角色消息：感叹号在气泡右下角外侧3px处
                                const bubbleRightOffset = bubbleRect.right - containerRect.left;
                                indicator.style.left = (bubbleRightOffset + 3) + 'px'; // 气泡右边 + 3px间距
                                indicator.style.right = 'auto';
                            }
                        }
                    }, 10);
                }

                // 🔥【新增】在消息下方添加系统提示
                if (!existingHint) {
                    const systemHint = document.createElement('div');
                    systemHint.className = 'blocked-message-hint-inline';
                    systemHint.style.cssText = `
                        text-align: center;
                        color: #999;
                        font-size: 12px;
                        padding: 2px 8px;
                        margin: 2px 0 8px 0;
                        background: transparent;
                        border: none;
                        display: block;
                        max-width: 80%;
                        width: fit-content;
                        margin-left: auto;
                        margin-right: auto;
                    `;
                    systemHint.textContent = '消息已发出，但被对方拒收了';

                    // 在消息容器后面插入系统提示
                    messageContainer.parentNode.insertBefore(systemHint, messageContainer.nextSibling);
                }
            }
        }

        // 🔥【修改】显示拉黑/屏蔽设置 - 区分单聊和群聊
        function showBlacklistSettings() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'warning');
                return;
            }

            const characterId = currentChatCharacter.id;
            const isGroupChat = currentChatCharacter.isGroup;

            if (isGroupChat) {
                // 🔥【新增】群聊只能屏蔽，且只有用户可以屏蔽群聊
                showGroupMuteSettings(characterId);
            } else {
                // 单聊使用原有的拉黑逻辑
                const isUserBlocked = isBlocked('user', characterId);

                const statusDesc = document.getElementById('blacklist-status-desc');
                const actionLabel = document.getElementById('block-action-label');
                const actionDesc = document.getElementById('block-action-desc');

                if (isUserBlocked) {
                    statusDesc.textContent = '你已拉黑此角色';
                    actionLabel.textContent = '解除拉黑';
                    actionDesc.textContent = '恢复与该角色的正常聊天';
                } else {
                    statusDesc.textContent = '正常聊天中';
                    actionLabel.textContent = '拉黑此角色';
                    actionDesc.textContent = '阻止该角色向你发送消息';
                }

                document.getElementById('blacklist-settings-modal').style.display = 'flex';
            }
        }

        // 🔥【新增】更新设置界面的拉黑/屏蔽管理文案
        function updateBlockManageLabel(isGroupChat) {
            const labelElement = document.getElementById('block-manage-label');
            const descElement = document.getElementById('block-manage-desc');

            if (labelElement && descElement) {
                if (isGroupChat) {
                    labelElement.textContent = '屏蔽管理';
                    descElement.textContent = '屏蔽/取消屏蔽群聊消息通知';
                } else {
                    labelElement.textContent = '拉黑管理';
                    descElement.textContent = '拉黑/解除拉黑管理';
                }
            }
        }

        // 🔥【新增】显示群聊屏蔽设置
        function showGroupMuteSettings(groupId) {
            // 检查是否已屏蔽该群聊
            const isMuted = isGroupMuted(groupId);

            const statusDesc = document.getElementById('blacklist-status-desc');
            const actionLabel = document.getElementById('block-action-label');
            const actionDesc = document.getElementById('block-action-desc');

            // 修改界面文案为屏蔽相关
            if (isMuted) {
                statusDesc.textContent = '你已屏蔽此群聊';
                actionLabel.textContent = '取消屏蔽';
                actionDesc.textContent = '重新接收该群聊的消息通知';
            } else {
                statusDesc.textContent = '正常接收群聊消息';
                actionLabel.textContent = '屏蔽此群聊';
                actionDesc.textContent = '不再接收该群聊的消息通知';
            }

            document.getElementById('blacklist-settings-modal').style.display = 'flex';
        }

        // 🔥【新增】检查群聊是否被屏蔽
        function isGroupMuted(groupId) {
            const mutedGroups = JSON.parse(localStorage.getItem('mutedGroups') || '[]');
            return mutedGroups.includes(groupId);
        }

        // 🔥【新增】屏蔽/取消屏蔽群聊
        function toggleGroupMute(groupId) {
            const mutedGroups = JSON.parse(localStorage.getItem('mutedGroups') || '[]');
            const isMuted = mutedGroups.includes(groupId);

            if (isMuted) {
                // 取消屏蔽
                const index = mutedGroups.indexOf(groupId);
                if (index > -1) {
                    mutedGroups.splice(index, 1);
                }
                showToast(`已取消屏蔽 ${currentChatCharacter?.name}`, 'success');
            } else {
                // 屏蔽群聊
                mutedGroups.push(groupId);
                showToast(`已屏蔽 ${currentChatCharacter?.name}`, 'info');
            }

            localStorage.setItem('mutedGroups', JSON.stringify(mutedGroups));

            // 更新界面
            renderContactList();
            hideBlacklistSettings();
        }

        // 隐藏拉黑设置
        function hideBlacklistSettings() {
            document.getElementById('blacklist-settings-modal').style.display = 'none';
        }

        // 显示好友申请模态框
        function showFriendRequestModal() {
            if (!currentChatCharacter) return;

            document.getElementById('friend-request-message').value = '';
            document.getElementById('friend-request-modal').style.display = 'flex';
        }

        // 隐藏好友申请模态框
        function hideFriendRequestModal() {
            document.getElementById('friend-request-modal').style.display = 'none';
        }

        // 发送好友申请确认
        async function sendFriendRequestConfirm() {
    if (!currentChatCharacter) return;
    
    const message = document.getElementById('friend-request-message').value.trim();
    const characterId = currentChatCharacter.id;

    // 1. 先在数据库中记录这个申请事件
    await sendFriendRequest(characterId, message);
    hideFriendRequestModal();
    
    // 2. 🔥【核心新增】立刻调用API，让AI处理这个好友申请
    showToast('申请已发送，等待对方回应...', 'info');
    await processAIFriendRequestResponse(characterId, message); 
}

        // 🔥【新增】处理AI主动发送的好友申请
        async function handleAIFriendRequest(characterId, accepted, messageId) {
            if (!currentChatCharacter || currentChatCharacter.id !== characterId) return;

            try {
                if (accepted) {
                    // 用户同意了AI的好友申请，解除拉黑
                    await unblockCharacter(characterId);
                    showToast(`已同意 ${currentChatCharacter.name} 的好友申请`, 'success');

                    // 添加系统消息表示好友申请被接受
                    const systemMessage = {
                        id: Date.now().toString(),
                        sender: 'system',
                        content: `你们已成功添加为好友，现在可以开始聊天了！`,
                        timestamp: Date.now(),
                        role: 'system'
                    };

                    // 保存系统消息到聊天记录
                    await saveMessage(characterId, systemMessage);

                    // 重新渲染聊天界面
                    renderChatMessages(characterId);
                    updateChatBlockedStatus();

                } else {
                    // 用户拒绝了AI的好友申请
                    showToast(`已拒绝 ${currentChatCharacter.name} 的好友申请`, 'info');

                    // 可以选择添加一个系统消息表示申请被拒绝
                    const systemMessage = {
                        id: Date.now().toString(),
                        sender: 'system',
                        content: `你拒绝了好友申请`,
                        timestamp: Date.now(),
                        role: 'system'
                    };

                    await saveMessage(characterId, systemMessage);
                    renderChatMessages(characterId);
                }

                // 更新好友申请消息的状态（可选：添加已处理标记）
                // 这里可以根据需要添加更多逻辑

            } catch (error) {
                console.error('处理AI好友申请失败:', error);
                showToast('处理好友申请失败', 'error');
            }
        }

        // 🔥【修改】执行拉黑/屏蔽操作 - 区分单聊和群聊
        function performBlockAction() {
            if (!currentChatCharacter) return;

            const characterId = currentChatCharacter.id;
            const isGroupChat = currentChatCharacter.isGroup;

            if (isGroupChat) {
                // 🔥【新增】群聊屏蔽逻辑
                const isMuted = isGroupMuted(characterId);

                if (isMuted) {
                    if (confirm(`确定要取消屏蔽 ${currentChatCharacter.name} 吗？`)) {
                        toggleGroupMute(characterId);
                    }
                } else {
                    if (confirm(`确定要屏蔽 ${currentChatCharacter.name} 吗？\n\n屏蔽后将不再接收该群聊的消息通知`)) {
                        toggleGroupMute(characterId);
                    }
                }
            } else {
                // 单聊拉黑逻辑
                const isUserBlocked = isBlocked('user', characterId);

                if (isUserBlocked) {
                    if (confirm(`确定要解除对 ${currentChatCharacter.name} 的拉黑吗？`)) {
                        unblockCharacter(characterId);
                        hideBlacklistSettings();
                    }
                } else {
                    if (confirm(`确定要拉黑 ${currentChatCharacter.name} 吗？`)) {
                        blockCharacter(characterId, '');
                        hideBlacklistSettings();
                    }
                }
            }
        }

        // 在应用初始化时加载拉黑系统数据
        document.addEventListener('DOMContentLoaded', async function() {
            setTimeout(async () => {
                try {
                    await Promise.all([
                        loadBlacklistData(),
                        loadFriendRequestsData(),
                        loadCharacterStatusData()
                    ]);
                    console.log('🚫 拉黑系统数据加载完成');
                } catch (error) {
                    console.error('拉黑系统数据加载失败:', error);
                }
            }, 1000);
        });

        // 加载好友申请数据
        async function loadFriendRequestsData() {
            try {
                friendRequestsData = await db.friendRequests.orderBy('timestamp').reverse().toArray();
                console.log('好友申请数据加载完成:', friendRequestsData);
            } catch (error) {
                console.error('加载好友申请数据失败:', error);
                friendRequestsData = [];
            }
        }

        // 加载角色状态数据
        async function loadCharacterStatusData() {
            try {
                characterStatusData = await db.characterStatus.toArray();
                console.log('角色状态数据加载完成:', characterStatusData);
            } catch (error) {
                console.error('加载角色状态数据失败:', error);
                characterStatusData = [];
            }
        }

        // 📱【角色状态显示】相关功能
        // 渲染角色状态
        function renderCharacterStatus(characterId, container) {
            const chatSettings = getCurrentChatSettings();
            if (!chatSettings.characterStatusEnabled) {
                // 如果关闭了状态显示，移除现有的状态元素
                if (container) {
                    const existingStatus = container.querySelector('.character-status');
                    if (existingStatus) {
                        existingStatus.remove();
                    }
                }
                return; 
            }
            
            const status = getCharacterStatus(characterId);
            const isUserBlocked = isBlocked('user', characterId);
            const isCharacterBlocked = isBlocked(characterId, 'user');
            
            let statusClass = 'online';
            let statusText = status.activity || '在线';
            
            if (isUserBlocked || isCharacterBlocked) {
                statusClass = 'blocked';
                statusText = '已拉黑';
            } else if (status.status === 'busy') {
                statusClass = 'busy';
            }
            
            const statusHtml = `
                <div class="character-status">
                    <div class="status-indicator ${statusClass}"></div>
                    <span class="status-text">${statusText}</span>
                </div>
            `;
            
            // 如果容器存在，添加状态显示
            if (container) {
                // 先移除现有的状态显示
                const existingStatus = container.querySelector('.character-status');
                if (existingStatus) {
                    existingStatus.remove();
                }
                
                // 🔥【修复】判断容器类型，使用不同的插入策略
                if (container.classList.contains('header')) {
                    // 聊天界面的.header容器：直接添加到容器中，使用CSS绝对定位
                    container.insertAdjacentHTML('beforeend', statusHtml);
                } else if (container.classList.contains('app-header')) {
                    // 其他界面的.app-header容器：添加到.app-title内部
                    const titleElement = container.querySelector('.app-title');
                    if (titleElement) {
                        titleElement.insertAdjacentHTML('afterend', statusHtml);
                    } else {
                        container.insertAdjacentHTML('beforeend', statusHtml);
                    }
                } else {
                    // 其他容器：默认添加到末尾
                    container.insertAdjacentHTML('beforeend', statusHtml);
                }
            }
        }

        // AI生成角色状态
        async function generateCharacterStatus(characterId) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;
                
                // 获取聊天设置和最近聊天记录
                const chatSettings = await getAsyncChatSettings(characterId);
                const messages = chatMessages[characterId] || [];
                const recentMessages = messages.slice(-5); // 最近5条消息
                
                // 构建上下文信息
                let chatContext = '';
                if (recentMessages.length > 0) {
                    // 🔥【修复】使用实际用户名而不是"用户"
                    const userName = getCurrentPersonaName();
                    chatContext = '最近的聊天记录：\n' +
                        recentMessages.map(msg => {
                            if (msg.sender === 'sent') return `${userName}：${msg.content}`;
                            if (msg.sender === 'received') return `${character.name}：${msg.content}`;
                            return '';
                        }).filter(Boolean).join('\n') + '\n\n';
                }
                
                // 获取世界书内容作为背景
                let worldBookContext = '';
                if (chatSettings?.linkedWorldBookIds && chatSettings.linkedWorldBookIds.length > 0) {
                    try {
                        const worldBooks = await Promise.all(
                            chatSettings.linkedWorldBookIds.map(id => db.worldbooks.get(id))
                        );
                        const validWorldBooks = worldBooks.filter(book => book && book.content);
                        if (validWorldBooks.length > 0) {
                            worldBookContext = '背景设定：\n' + 
                                validWorldBooks.map(book => `${book.name}：${book.content}`).join('\n\n') + '\n\n';
                        }
                    } catch (error) {
                        console.error('获取世界书内容失败:', error);
                    }
                }
                
                // 随机选择状态类型：活动或心情
                const statusType = Math.random() < 0.5 ? 'activity' : 'mood';
                
                let prompt;
                if (statusType === 'activity') {
                    // 生成活动状态
                    prompt = `你是${character.name}，人设如下：${character.bio}

${worldBookContext}${chatContext}请根据你的人设、当前剧情和聊天记录，生成一个符合你当前状况的活动状态。要求：
1. 10-20字内，简洁明了
2. 符合你的性格和身份设定
3. 基于最近的聊天内容或剧情发展
4. 格式：在[地点][做什么]
5. 要真实反映角色当下可能在做的事情
6. 如果没有具体聊天记录，则根据人设推测合理的日常活动

示例格式：在图书馆整理资料、在训练场练习剑术、在房间里沉思、在花园中散步等

请生成一个活动状态：`;
                } else {
                    // 生成心情状态
                    prompt = `你是${character.name}，人设如下：${character.bio}

${worldBookContext}${chatContext}请根据你的人设、当前剧情和聊天记录，生成一个符合你当前心情的状态。要求：
1. 10-20字内，简洁明了，禁止超过20个字
2. 符合你的性格特点
3. 基于最近的对话内容或情感变化
4. 表达你当下的真实情感状态
5. 要有角色的个性色彩
6. 如果没有具体聊天记录，则根据人设推测基本心情

示例格式：心情愉悦、略感困惑、正在专注思考、感到有些疲惫、对未来充满期待等

请生成一个心情状态：`;
                }
                
                // 使用AI生成状态
                const statusText = await generateAIResponse(prompt, character);
                
                if (statusText && statusText.trim()) {
                    const cleanStatus = statusText.trim().replace(/^["""''「」『』【】]|["""''「」『』【】]$/g, '');
                    await updateCharacterStatus(characterId, 'online', cleanStatus);
                    console.log(`为${character.name}生成${statusType === 'activity' ? '活动' : '心情'}状态: ${cleanStatus}`);
                } else {
                    // 如果AI生成失败，使用基于人设的默认状态
                    const fallbackStatus = generateFallbackStatus(character, statusType);
                    await updateCharacterStatus(characterId, 'online', fallbackStatus);
                    console.log(`为${character.name}使用默认${statusType === 'activity' ? '活动' : '心情'}状态: ${fallbackStatus}`);
                }
                
            } catch (error) {
                console.error('生成角色状态失败:', error);
                // 错误时使用简单的默认状态
                const fallbackStatus = generateFallbackStatus(character, 'activity');
                await updateCharacterStatus(characterId, 'online', fallbackStatus);
            }
        }
        
        // 生成基于人设的备用状态
        function generateFallbackStatus(character, statusType) {
            const bio = (character.bio || '').toLowerCase();
            
            if (statusType === 'activity') {
                // 基于人设关键词的活动状态
                if (bio.includes('学者') || bio.includes('研究') || bio.includes('书')) {
                    return '在书房研读典籍';
                } else if (bio.includes('战士') || bio.includes('剑') || bio.includes('战斗')) {
                    return '在训练场练习';
                } else if (bio.includes('医生') || bio.includes('治疗')) {
                    return '在诊所整理药品';
                } else if (bio.includes('商人') || bio.includes('买卖')) {
                    return '在店铺忙碌';
                } else if (bio.includes('艺术') || bio.includes('画') || bio.includes('音乐')) {
                    return '在工作室创作';
                } else if (bio.includes('厨') || bio.includes('料理')) {
                    return '在厨房准备食材';
                } else {
                    return '在房间里休息';
                }
            } else {
                // 基于人设关键词的心情状态
                if (bio.includes('开朗') || bio.includes('活泼') || bio.includes('乐观')) {
                    return '心情愉悦';
                } else if (bio.includes('冷静') || bio.includes('理性') || bio.includes('沉着')) {
                    return '内心平静';
                } else if (bio.includes('严肃') || bio.includes('认真')) {
                    return '专注思考中';
                } else if (bio.includes('温柔') || bio.includes('善良')) {
                    return '心境温和';
                } else if (bio.includes('神秘') || bio.includes('深沉')) {
                    return '若有所思';
                } else {
                    return '状态良好';
                }
            }
        }

        // 🔥【修复】状态更新定时器管理
        let characterStatusTimer = null;
        
        // 获取状态更新间隔时间（毫秒）
        function getStatusUpdateInterval() {
            // 🔥【修复】从localStorage获取全局状态更新频率设置
            let frequency = 'medium'; // 默认中频

            try {
                // 尝试从localStorage获取全局设置
                const globalSettings = localStorage.getItem('globalStatusUpdateFrequency');
                if (globalSettings) {
                    frequency = globalSettings;
                } else {
                    // 如果没有全局设置，尝试从当前角色设置中获取
                    if (currentChatCharacter) {
                        const chatSettings = getCurrentChatSettings();
                        frequency = chatSettings.statusUpdateFrequency || 'medium';
                        // 保存为全局设置
                        localStorage.setItem('globalStatusUpdateFrequency', frequency);
                    }
                }
            } catch (error) {
                console.warn('获取状态更新频率设置失败，使用默认值:', error);
            }

            // 🔥【修复】将频率转换为毫秒间隔 - 修正高频为30秒
            const intervals = {
                'high': 30000,      // 30秒（目前频率）
                'medium-high': 60000, // 1分钟
                'medium': 180000,   // 3分钟
                'medium-low': 300000, // 5分钟
                'low': 600000       // 10分钟
            };

            return intervals[frequency] || intervals['medium'];
        }
        
        // 清除状态更新定时器
        function clearCharacterStatusTimer() {
            if (characterStatusTimer) {
                clearInterval(characterStatusTimer);
                characterStatusTimer = null;
                console.log('角色状态更新定时器已清除');
            }
        }
        
        // 启动状态更新定时器
        async function startCharacterStatusTimer() {
            clearCharacterStatusTimer(); // 先清除现有定时器

            // 🔥【优化】首先检查是否有任何角色启用了状态显示
            let hasStatusEnabled = false;
            for (const character of characters) {
                if (contacts.includes(character.id)) {
                    const chatSettings = await getAsyncChatSettings(character.id);
                    if (chatSettings.characterStatusEnabled) {
                        hasStatusEnabled = true;
                        break;
                    }
                }
            }

            // 如果没有任何角色启用状态显示，不启动定时器
            if (!hasStatusEnabled) {
                console.log('没有角色启用状态显示，跳过启动状态更新定时器');
                return;
            }

            const interval = getStatusUpdateInterval();
            console.log('启动角色状态更新定时器，间隔:', interval / 1000, '秒');

            characterStatusTimer = setInterval(async () => {
                // 检查是否有任何角色启用了状态显示
                let hasStatusEnabled = false;

                for (const character of characters) {
                    if (contacts.includes(character.id)) {
                        // 检查该角色的聊天设置中是否启用了状态显示
                        const chatSettings = await getAsyncChatSettings(character.id);
                        if (chatSettings.characterStatusEnabled) {
                            hasStatusEnabled = true;

                            // 检查是否需要更新状态
                            const shouldUpdate = await shouldUpdateCharacterStatus(character.id);
                            if (shouldUpdate) {
                                await generateCharacterStatus(character.id);
                            }
                        }
                    }
                }

                // 如果没有任何角色启用状态显示，停止定时器
                if (!hasStatusEnabled) {
                    console.log('没有角色启用状态显示，停止状态更新定时器');
                    clearCharacterStatusTimer();
                    return;
                }
                
                // 刷新当前显示的状态（仅当当前角色启用了状态显示时）
                if (currentChatCharacter) {
                    const currentChatSettings = getCurrentChatSettings();
                    if (currentChatSettings.characterStatusEnabled) {
                        const headerContainer = document.querySelector('#api-chat-screen .header');
                        if (headerContainer) {
                            renderCharacterStatus(currentChatCharacter.id, headerContainer);
                        }
                    }
                }
            }, interval);
        }
        
        // 重启状态更新定时器
        function restartCharacterStatusTimer() {
            console.log('重启角色状态更新定时器');
            startCharacterStatusTimer();
        }
        
        // 向后兼容的函数名
        function startStatusUpdateTimer() {
            startCharacterStatusTimer();
        }

        // ================== 全局记忆系统 ==================

        // 全局记忆数据库结构
        let globalMemoryDB = null;

        // 初始化全局记忆数据库
        async function initGlobalMemoryDB() {
            try {
                // 扩展现有数据库，添加记忆相关表
                if (!db.memorySummaries) {
                    // 情景记忆表 - 存储AI生成的日记摘要
                    db.memorySummaries = db.table('memorySummaries', '++id, characterId, date, summary, context, importance, timestamp');
                }

                if (!db.coreMemories) {
                    // 核心记忆表 - 存储永久重要信息
                    db.coreMemories = db.table('coreMemories', '++id, characterId, fact, category, importance, timestamp, lastAccessed');
                }

                if (!db.memoryEvents) {
                    // 统一事件表 - 记录所有跨场景事件
                    db.memoryEvents = db.table('memoryEvents', '++id, timestamp, characterIds, context, eventType, eventData, importance');
                }

                console.log('✅ 全局记忆数据库初始化完成');
            } catch (error) {
                console.error('❌ 全局记忆数据库初始化失败:', error);
            }
        }

        // 记录统一事件
        async function recordMemoryEvent(characterIds, context, eventType, eventData, importance = 0.5) {
            try {
                // 🔥【修复】确保所有参数都是有效的
                if (!characterIds || !eventType || !eventData) {
                    console.warn('❌ recordMemoryEvent: 缺少必需参数', { characterIds, eventType, eventData });
                    return;
                }

                const event = {
                    id: `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, // 🔥【修复】提供唯一ID
                    timestamp: Date.now(),
                    characterIds: Array.isArray(characterIds) ? characterIds : [characterIds],
                    context: context || { type: 'unknown', id: 'unknown' }, // 🔥【修复】提供默认context
                    eventType: eventType, // 'message', 'activity_start', 'group_create' 等
                    eventData: eventData,
                    importance: importance || 0.5
                };

                // 🔥【修复】确保eventData是可序列化的对象
                if (typeof event.eventData === 'object' && event.eventData !== null) {
                    try {
                        JSON.stringify(event.eventData);
                    } catch (e) {
                        console.warn('❌ eventData不可序列化，转换为字符串:', event.eventData);
                        event.eventData = String(event.eventData);
                    }
                }

                await db.memoryEvents.add(event);
                console.log('📝 记录事件:', eventType, characterIds);
            } catch (error) {
                console.error('❌ 记录事件失败:', error);
                console.error('❌ 事件数据:', { characterIds, context, eventType, eventData, importance });
            }
        }

        // 添加核心记忆
        async function addCoreMemory(characterId, fact, category = 'general', importance = 0.8) {
            try {
                const coreMemory = {
                    characterId: characterId,
                    fact: fact,
                    category: category, // 'personality', 'relationship', 'preference', 'general'
                    importance: importance,
                    timestamp: Date.now(),
                    lastAccessed: Date.now()
                };

                await db.coreMemories.add(coreMemory);
                console.log('🧠 添加核心记忆:', fact);
            } catch (error) {
                console.error('❌ 添加核心记忆失败:', error);
            }
        }

        // 生成情景记忆摘要
        async function generateMemorySummary(characterId, startTime, endTime, context) {
            try {
                // 🔥【修复】获取时间段内的跨应用时间线事件（包括聊天记录）
                const timelineEvents = await db.crossAppTimeline
                    .where('characterId')
                    .equals(characterId)
                    .and(event => event.timestamp >= startTime && event.timestamp < endTime)
                    .toArray();

                // 🔥【修复】同时获取聊天消息
                const characterMessages = chatMessages[characterId] || [];
                const todayMessages = characterMessages.filter(msg =>
                    msg.timestamp >= startTime && msg.timestamp < endTime
                );

                if (timelineEvents.length === 0 && todayMessages.length === 0) {
                    console.log('今天暂无活动记录');
                    return null;
                }

                // 🔥【修复】构建更全面的活动记录
                let eventsText = '';

                // 添加聊天记录
                if (todayMessages.length > 0) {
                    eventsText += '聊天记录：\n';
                    todayMessages.forEach(msg => {
                        const timeStr = new Date(msg.timestamp).toLocaleTimeString();
                        const role = msg.role === 'user' ? '用户' : character.name;
                        eventsText += `[${timeStr}] ${role}: ${msg.content}\n`;
                    });
                }

                // 添加跨应用事件
                if (timelineEvents.length > 0) {
                    eventsText += '\n其他活动：\n';
                    timelineEvents.forEach(event => {
                        const timeStr = new Date(event.timestamp).toLocaleTimeString();
                        const actionDesc = getActionDescription(event.action, event.context);
                        eventsText += `[${timeStr}] ${actionDesc}\n`;
                    });
                }

                const character = characters.find(c => c.id === characterId);
                const summaryPrompt = `请为${character.name}今天的活动写一份简短的记忆摘要（50-100字）：

时间段：${new Date(startTime).toLocaleString()} - ${new Date(endTime).toLocaleString()}
今日活动：
${eventsText}

请用第三人称写一份简洁的记忆摘要，重点记录重要的事件和感受。使用"用户"指代用户，使用"${character.name}"指代角色，不要使用"我"、"你"等第一、第二人称：`;

                // 调用AI生成摘要
                const response = await callChatAPI(summaryPrompt, character);

                if (response && response.trim()) {
                    const summary = {
                        characterId: characterId,
                        date: new Date(startTime).toISOString().split('T')[0],
                        summary: response.trim(),
                        context: context,
                        importance: calculateSummaryImportance(timelineEvents.concat(todayMessages)),
                        timestamp: Date.now()
                    };

                    await db.memorySummaries.add(summary);
                    console.log('📖 生成记忆摘要:', summary.summary);
                    return summary;
                }
            } catch (error) {
                console.error('❌ 生成记忆摘要失败:', error);
            }
            return null;
        }

        // 🔥【新增】获取动作描述的辅助函数
        function getActionDescription(action, context) {
            const actionMap = {
                'user_message': '收到用户消息',
                'ai_reply': '回复了消息',
                'moment_publish': '发布了动态',
                'moment_comment': '评论了动态',
                'game_start': '开始游戏',
                'game_end': '结束游戏'
            };

            const baseDesc = actionMap[action] || action;
            if (context && context.content) {
                return `${baseDesc}: ${context.content.substring(0, 30)}...`;
            }
            return baseDesc;
        }

        // 计算摘要重要性
        function calculateSummaryImportance(events) {
            if (!events || events.length === 0) return 0.3;

            // 🔥【修复】适配不同类型的事件数据
            let totalImportance = 0;
            let validEvents = 0;

            events.forEach(event => {
                if (event.importance !== undefined) {
                    totalImportance += event.importance;
                    validEvents++;
                } else {
                    // 对于聊天消息，给予基础重要性
                    totalImportance += 0.6;
                    validEvents++;
                }
            });

            const avgImportance = validEvents > 0 ? totalImportance / validEvents : 0.5;
            const eventCount = events.length;

            // 事件数量和平均重要性的综合评分
            return Math.min(0.9, avgImportance + (eventCount * 0.02));
        }

        // 智能记忆检索系统
        async function buildGlobalMemoryContext(characterId, currentContext, memoryDays = 7) {
            try {
                let memoryContext = '';

                // 🔥【修复】检查是否启用记忆共享 - 需要获取角色的单聊设置
                let sharedGroupIds = [];
                let contextIds = [currentContext.id]; // 当前聊天窗口

                // 如果当前在群聊中，需要检查该角色在单聊中是否设置了记忆共享
                if (currentContext.type === 'group_chat') {
                    try {
                        // 获取该角色的单聊设置（角色ID就是单聊ID）
                        const characterChatSettings = await getAsyncChatSettings(characterId);
                        sharedGroupIds = characterChatSettings.memorySharedGroupIds || [];

                        // 🔥【调试】输出详细的记忆共享检查信息
                        console.log(`🔍 记忆共享检查 - 角色: ${characterId}`);
                        console.log(`🔍 当前群聊ID: ${currentContext.id}`);
                        console.log(`🔍 角色设置的共享群聊IDs: ${sharedGroupIds}`);
                        console.log(`🔍 是否匹配: ${sharedGroupIds.includes(currentContext.id)}`);

                        // 如果角色设置了与当前群聊共享记忆，则包含私聊记忆
                        if (sharedGroupIds.includes(currentContext.id)) {
                            contextIds.push(characterId); // 私聊的ID就是角色ID
                            console.log('🔗 在共享群聊中，包含角色私聊记忆:', characterId);
                        } else {
                            console.log('❌ 记忆共享未启用或群聊不匹配，只使用群聊记忆');
                        }
                    } catch (error) {
                        console.warn('获取角色单聊设置失败:', error);
                    }
                } else if (currentContext.type === 'private_chat') {
                    // 如果在私聊中，使用当前聊天设置
                    const chatSettings = getCurrentChatSettings();
                    sharedGroupIds = chatSettings.memorySharedGroupIds || [];

                    // 如果启用了记忆共享，添加所有共享的群聊ID
                    if (sharedGroupIds.length > 0) {
                        contextIds.push(...sharedGroupIds);
                        console.log('🔗 启用记忆共享，包含群聊:', sharedGroupIds);
                    }
                }

                // 1. 检索核心记忆 - 🔥【修复】添加上下文过滤
                let coreMemories = [];
                for (const contextId of contextIds) {
                    const contextCoreMemories = await db.coreMemories
                        .where('characterId')
                        .equals(characterId)
                        .and(memory => {
                            // 🔥【关键修复】按上下文过滤核心记忆
                            if (!memory.contextId) return true; // 兼容旧数据
                            return memory.contextId === contextId;
                        })
                        .toArray();
                    coreMemories = coreMemories.concat(contextCoreMemories);
                }

                // 手动排序并限制数量
                coreMemories.sort((a, b) => (b.importance || 0) - (a.importance || 0));
                const limitedCoreMemories = coreMemories.slice(0, 10);

                if (limitedCoreMemories.length > 0) {
                    memoryContext += '\n# 核心记忆\n';
                    limitedCoreMemories.forEach(memory => {
                        memoryContext += `- ${memory.fact}\n`;
                    });
                }

                // 2. 检索情景记忆（最近N天）- 🔥【修复】添加上下文过滤
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - memoryDays);
                const cutoffTimestamp = cutoffDate.getTime();

                let episodicMemories = [];
                for (const contextId of contextIds) {
                    const contextEpisodicMemories = await db.episodicMemories
                        .where('characterId')
                        .equals(characterId)
                        .and(memory => {
                            if (memory.timestamp < cutoffTimestamp) return false;
                            // 🔥【关键修复】按上下文过滤情景记忆
                            if (!memory.contextId) return true; // 兼容旧数据
                            return memory.contextId === contextId;
                        })
                        .toArray();
                    episodicMemories = episodicMemories.concat(contextEpisodicMemories);
                }

                // 手动排序并限制数量
                episodicMemories.sort((a, b) => b.timestamp - a.timestamp);
                const limitedEpisodicMemories = episodicMemories.slice(0, 15);

                if (limitedEpisodicMemories.length > 0) {
                    memoryContext += '\n# 情景记忆\n';
                    limitedEpisodicMemories.forEach(memory => {
                        const dateObj = new Date(memory.timestamp || Date.now());
                        const date = isNaN(dateObj.getTime()) ? '未知日期' : dateObj.toLocaleDateString();
                        memoryContext += `[${date}] ${memory.fact}\n`;
                    });
                }

                // 3. 检索跨应用时间线记忆（支持记忆共享）
                const timelineCutoff = Date.now() - (memoryDays * 24 * 60 * 60 * 1000);
                let timelineMemories = [];

                for (const contextId of contextIds) {
                    const contextTimeline = await db.crossAppTimeline
                        .where('characterId')
                        .equals(characterId)
                        .and(event => {
                            if (event.timestamp < timelineCutoff) return false;
                            if (!event.context) return false;

                            // 🔥【修复】线下模式剧情总结也应该被包含
                            if (event.appType === 'offline_mode' && event.action === 'storyline_summary') {
                                return true; // 线下模式剧情总结对所有上下文都可见
                            }

                            // 检查上下文ID匹配
                            return event.context.id === contextId ||
                                   (event.context.chatId === contextId) ||
                                   (event.context.groupId === contextId);
                        })
                        .toArray();
                    timelineMemories = timelineMemories.concat(contextTimeline);
                }

                // 去重并排序
                const uniqueTimelineMemories = timelineMemories.filter((memory, index, self) =>
                    index === self.findIndex(m => m.id === memory.id));
                uniqueTimelineMemories.sort((a, b) => b.timestamp - a.timestamp);
                const limitedTimelineMemories = uniqueTimelineMemories.slice(0, 20);

                if (limitedTimelineMemories.length > 0) {
                    memoryContext += '\n# 最近活动时间线\n';
                    limitedTimelineMemories.forEach(memory => {
                        const time = new Date(memory.timestamp).toLocaleString();
                        let contextInfo = '私聊';
                        if (memory.context?.type === 'group_chat') {
                            contextInfo = '群聊';
                        } else if (memory.appType === 'offline_mode') {
                            contextInfo = '线下模式';
                        }

                        // 构建更有意义的事件描述
                        let eventDescription = '';
                        if (memory.action === 'user_message') {
                            if (memory.context?.content) {
                                eventDescription = `用户说: ${memory.context.content.substring(0, 50)}${memory.context.content.length > 50 ? '...' : ''}`;
                            } else {
                                eventDescription = `用户发送了消息`;
                            }
                        } else if (memory.action === 'ai_message' && memory.context?.content) {
                            eventDescription = `AI回复: ${memory.context.content.substring(0, 50)}${memory.context.content.length > 50 ? '...' : ''}`;
                        } else if (memory.action === 'ai_reply' && memory.context?.content) {
                            eventDescription = `AI回复: ${memory.context.content.substring(0, 50)}${memory.context.content.length > 50 ? '...' : ''}`;
                        } else if (memory.action === 'storyline_summary' && memory.appType === 'offline_mode') {
                            // 🔥【新增】线下模式剧情总结的特殊显示
                            if (memory.context?.content) {
                                eventDescription = `${memory.context.content.substring(0, 100)}${memory.context.content.length > 100 ? '...' : ''}`;
                            } else {
                                eventDescription = '线下剧情模式总结';
                            }
                            // 🔥【新增】为剧情总结添加编辑按钮
                            actionButtons = `
                                <button class="memory-action-btn edit-btn" onclick="editStorylineSummary('${memory.id}')" title="编辑剧情总结">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button class="memory-action-btn view-btn" onclick="viewStorylineSummary('${memory.id}')" title="查看完整内容">
                                    <i class="fas fa-eye"></i>
                                </button>
                            `;
                        } else {
                            eventDescription = memory.action || memory.eventType || '未知活动';
                        }



                        memoryContext += `[${time}] 在${contextInfo}中: ${eventDescription}\n`;
                    });
                }

                // 4. 检索记忆摘要（最近N天的摘要）
                const cutoffDateStr = cutoffDate.toISOString().split('T')[0];

                const memorySummaries = await db.memorySummaries
                    .where('characterId')
                    .equals(characterId)
                    .and(summary => summary.date >= cutoffDateStr)
                    .toArray();

                // 手动排序并限制数量
                memorySummaries.sort((a, b) => b.timestamp - a.timestamp);
                const limitedMemorySummaries = memorySummaries.slice(0, 10);

                if (limitedMemorySummaries.length > 0) {
                    memoryContext += '\n# 对话摘要\n';
                    limitedMemorySummaries.forEach(summary => {
                        const dateObj = new Date(summary.timestamp || Date.now());
                        const date = isNaN(dateObj.getTime()) ? '未知日期' : dateObj.toLocaleDateString();
                        memoryContext += `[${date}] ${summary.summary}\n`;
                    });
                }

                // 3. 检索跨场景相关事件（支持记忆共享）
                const recentEvents = await db.memoryEvents
                    .where('timestamp')
                    .above(Date.now() - (24 * 60 * 60 * 1000)) // 最近24小时
                    .and(event => {
                        // 检查事件是否与当前角色相关，且发生在相关的聊天窗口中
                        return event.characterIds.includes(characterId) &&
                               contextIds.includes(event.context.id);
                    })
                    .toArray();

                // 手动排序并限制数量
                recentEvents.sort((a, b) => b.timestamp - a.timestamp);
                const limitedRecentEvents = recentEvents.slice(0, 15);

                if (limitedRecentEvents.length > 0) {
                    memoryContext += '\n# 最近活动\n';
                    limitedRecentEvents.forEach(event => {
                        const time = new Date(event.timestamp).toLocaleTimeString();
                        const contextInfo = event.context.type === 'private_chat' ? '私聊' :
                                          event.context.type === 'group_chat' ? '群聊' :
                                          event.context.type === 'music_app' ? '音乐' : '其他';

                        // 如果是跨场景的事件，标明来源
                        const sourceInfo = event.context.id !== currentContext.id ? ` (来自${contextInfo})` : '';
                        memoryContext += `[${time}] 在${contextInfo}中${sourceInfo}: ${event.eventType}\n`;
                    });
                }

                return memoryContext;
            } catch (error) {
                console.error('❌ 构建全局记忆上下文失败:', error);
                return '';
            }
        }

        // 记忆设置管理
        function showGlobalMemorySettings() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'error');
                return;
            }

            // 创建记忆设置模态框
            const modalHTML = `
                <div id="global-memory-modal" class="modal phone-modal" style="display: block;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 class="modal-title">全局记忆设置</h3>
                            <button class="modal-close" onclick="hideGlobalMemorySettings()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="setting-section">
                                <h4>记忆保留期限</h4>
                                <div class="radio-group">
                                    <label class="radio-option">
                                        <input type="radio" name="memoryDays" value="3">
                                        <span class="radio-custom"></span>
                                        <div class="radio-content">
                                            <div class="radio-title">3天记忆</div>
                                            <div class="radio-desc">保留最近3天的情景记忆</div>
                                        </div>
                                    </label>
                                    <label class="radio-option">
                                        <input type="radio" name="memoryDays" value="7" checked>
                                        <span class="radio-custom"></span>
                                        <div class="radio-content">
                                            <div class="radio-title">7天记忆</div>
                                            <div class="radio-desc">保留最近7天的情景记忆（推荐）</div>
                                        </div>
                                    </label>
                                    <label class="radio-option">
                                        <input type="radio" name="memoryDays" value="15">
                                        <span class="radio-custom"></span>
                                        <div class="radio-content">
                                            <div class="radio-title">15天记忆</div>
                                            <div class="radio-desc">保留最近15天的情景记忆</div>
                                        </div>
                                    </label>
                                    <label class="radio-option">
                                        <input type="radio" name="memoryDays" value="30">
                                        <span class="radio-custom"></span>
                                        <div class="radio-content">
                                            <div class="radio-title">30天记忆</div>
                                            <div class="radio-desc">保留最近30天的情景记忆</div>
                                        </div>
                                    </label>
                                </div>
                            </div>

                            <div class="setting-section">
                                <h4>记忆管理</h4>
                                <div class="memory-management-grid">
                                    <button class="memory-action-btn primary" onclick="viewCoreMemories()">
                                        <div class="btn-icon">🔴</div>
                                        <div class="btn-content">
                                            <div class="btn-title">查看核心记忆</div>
                                            <div class="btn-desc">永久重要信息</div>
                                        </div>
                                    </button>
                                    <button class="memory-action-btn secondary" onclick="viewMemorySummaries()">
                                        <div class="btn-icon">📖</div>
                                        <div class="btn-content">
                                            <div class="btn-title">查看记忆摘要</div>
                                            <div class="btn-desc">对话总结回顾</div>
                                        </div>
                                    </button>
                                    <button class="memory-action-btn accent" onclick="generateDailySummary()">
                                        <div class="btn-icon">✨</div>
                                        <div class="btn-content">
                                            <div class="btn-title">生成今日摘要</div>
                                            <div class="btn-desc">总结今天活动</div>
                                        </div>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="modal-actions">
                            <button class="modal-button modal-secondary" onclick="hideGlobalMemorySettings()">取消</button>
                            <button class="modal-button modal-primary" onclick="saveGlobalMemorySettings()">保存设置</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHTML);

            // 加载当前设置
            const currentSettings = getGlobalMemorySettings();
            const radio = document.querySelector(`input[name="memoryDays"][value="${currentSettings.memoryDays}"]`);
            if (radio) radio.checked = true;
        }

        // 获取全局记忆设置
        function getGlobalMemorySettings() {
            const saved = localStorage.getItem('globalMemorySettings');
            return saved ? JSON.parse(saved) : {
                memoryDays: 7,
                autoSummary: true,
                coreMemoryEnabled: true
            };
        }

        // 保存全局记忆设置
        function saveGlobalMemorySettings() {
            const memoryDays = parseInt(document.querySelector('input[name="memoryDays"]:checked').value);

            const settings = {
                memoryDays: memoryDays,
                autoSummary: true,
                coreMemoryEnabled: true
            };

            localStorage.setItem('globalMemorySettings', JSON.stringify(settings));
            hideGlobalMemorySettings();
            showToast('全局记忆设置已保存', 'success');
        }

        // 隐藏全局记忆设置
        function hideGlobalMemorySettings() {
            const modal = document.getElementById('global-memory-modal');
            if (modal) modal.remove();
        }

        // 🔥【新增】显示记忆模态框
        function showMemoryModal(title, memories, type) {
            // 移除已存在的模态框
            const existingModal = document.getElementById('memory-view-modal');
            if (existingModal) existingModal.remove();

            let content = '';
            if (memories.length === 0) {
                content = `<div class="memory-empty">暂无${title}</div>`;
            } else {
                content = memories.map((memory, index) => {
                    let displayContent = '';
                    let importance = '';
                    let date = '';

                    if (type === 'core') {
                        displayContent = memory.fact || '无内容';
                        const stars = '★'.repeat(Math.floor((memory.importance || 0) * 5));
                        importance = `<div class="memory-importance">${stars}</div>`;
                        const dateObj = new Date(memory.timestamp || Date.now());
                        date = isNaN(dateObj.getTime()) ? '未知日期' : dateObj.toLocaleDateString();
                    } else if (type === 'summary') {
                        displayContent = memory.summary || '无内容';
                        date = memory.date || '未知日期';
                    }

                    return `
                        <div class="memory-modal-item">
                            <div class="memory-modal-header">
                                <span class="memory-modal-index">${index + 1}</span>
                                <span class="memory-modal-date">${date}</span>
                            </div>
                            <div class="memory-modal-content">${displayContent}</div>
                            ${importance}
                        </div>
                    `;
                }).join('');
            }

            const modalHTML = `
                <div id="memory-view-modal" class="modal" style="display: flex;">
                    <div class="modal-content" style="max-width: 600px; max-height: 80vh;">
                        <div class="modal-header">
                            <h3>${currentChatCharacter.name} 的${title}</h3>
                            <button class="modal-close" onclick="hideMemoryModal()">×</button>
                        </div>
                        <div class="modal-body" style="max-height: 60vh; overflow-y: auto;">
                            ${content}
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        // 隐藏记忆模态框
        function hideMemoryModal() {
            const modal = document.getElementById('memory-view-modal');
            if (modal) modal.remove();
        }

        // 查看核心记忆
        async function viewCoreMemories() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'error');
                return;
            }

            // 🔥【修复】自动关闭全局记忆设置模态框
            hideGlobalMemorySettings();

            try {
                const coreMemories = await db.coreMemories
                    .where('characterId')
                    .equals(currentChatCharacter.id)
                    .toArray();

                // 手动排序并限制数量
                coreMemories.sort((a, b) => (b.importance || 0) - (a.importance || 0));
                const limitedMemories = coreMemories.slice(0, 10);

                showMemoryModal('核心记忆', limitedMemories, 'core');
            } catch (error) {
                console.error('查看核心记忆失败:', error);
                showToast('查看核心记忆失败', 'error');
            }
        }

        // 查看记忆摘要
        async function viewMemorySummaries() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'error');
                return;
            }

            // 🔥【修复】自动关闭全局记忆设置模态框
            hideGlobalMemorySettings();

            try {
                const memorySummaries = await db.memorySummaries
                    .where('characterId')
                    .equals(currentChatCharacter.id)
                    .toArray();

                // 手动排序并限制数量
                memorySummaries.sort((a, b) => b.timestamp - a.timestamp);
                const limitedSummaries = memorySummaries.slice(0, 10);

                showMemoryModal('记忆摘要', limitedSummaries, 'summary');
            } catch (error) {
                console.error('查看记忆摘要失败:', error);
                showToast('查看记忆摘要失败', 'error');
            }
        }

        // 生成今日摘要
        async function generateDailySummary() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'error');
                return;
            }

            try {
                const today = new Date();
                const startTime = new Date(today.getFullYear(), today.getMonth(), today.getDate()).getTime();
                const endTime = startTime + 24 * 60 * 60 * 1000;

                const summary = await generateMemorySummary(
                    currentChatCharacter.id,
                    startTime,
                    endTime,
                    {
                        type: currentChatCharacter.isGroup ? 'group_chat' : 'private_chat',
                        id: currentChatCharacter.id
                    }
                );

                if (summary) {
                    showToast('今日摘要生成成功', 'success');
                    alert(`今日摘要已生成：\n\n${summary.summary}`);
                } else {
                    showToast('今天暂无活动可生成摘要', 'warning');
                }
            } catch (error) {
                console.error('生成今日摘要失败:', error);
                showToast('生成今日摘要失败', 'error');
            }
        }

        // 记忆共享设置
        function showMemoryShareSettings() {
            if (!currentChatCharacter || currentChatCharacter.isGroup) {
                showToast('此功能仅适用于单聊', 'error');
                return;
            }

            // 获取当前角色参与的所有群聊
            const characterGroups = groupChats.filter(group =>
                group.members && group.members.some(member => member.id === currentChatCharacter.id)
            );

            if (characterGroups.length === 0) {
                showToast('该角色还没有参与任何群聊', 'warning');
                return;
            }

            const chatSettings = getCurrentChatSettings();
            const currentSharedGroups = chatSettings.memorySharedGroupIds || [];

            const modalHTML = `
                <div id="memory-share-modal" class="modal phone-modal" style="display: block;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 class="modal-title">记忆共享设置</h3>
                            <button class="modal-close" onclick="hideMemoryShareSettings()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="setting-section">
                                <h4>选择要共享记忆的群聊</h4>
                                <div class="checkbox-group">
                                    ${characterGroups.map(group => `
                                        <label class="checkbox-option">
                                            <input type="checkbox" name="sharedGroups" value="${group.id}" ${currentSharedGroups.includes(group.id) ? 'checked' : ''}>
                                            <span class="checkbox-custom"></span>
                                            <div class="checkbox-content">
                                                <div class="checkbox-title">${group.name}</div>
                                                <div class="checkbox-desc">与此群聊共享记忆</div>
                                            </div>
                                        </label>
                                    `).join('')}
                                </div>
                            </div>

                            <div class="setting-section">
                                <h4>功能说明</h4>
                                <div class="info-text">
                                    • 开启后，角色在单聊中能记住群聊的内容<br>
                                    • 角色在群聊中也能记住单聊的内容<br>
                                    • 实现真正的跨场景记忆连贯性<br>
                                    • 可以同时选择多个群聊进行记忆共享
                                </div>
                            </div>
                        </div>
                        <div class="modal-actions">
                            <button class="modal-button modal-secondary" onclick="hideMemoryShareSettings()">取消</button>
                            <button class="modal-button modal-primary" onclick="saveMemoryShareSettings()">保存设置</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        // 保存记忆共享设置
        async function saveMemoryShareSettings() {
            const selectedGroups = Array.from(document.querySelectorAll('input[name="sharedGroups"]:checked'))
                .map(checkbox => checkbox.value);

            const chatSettings = getCurrentChatSettings();
            chatSettings.memorySharedGroupIds = selectedGroups;

            // 🔥【兼容性】保留旧的单选字段，使用第一个选中的群聊
            chatSettings.memorySharedGroupId = selectedGroups.length > 0 ? selectedGroups[0] : '';

            await saveChatSettings();

            // 更新显示状态
            updateMemoryShareStatus();

            hideMemoryShareSettings();

            if (selectedGroups.length > 0) {
                const groupNames = selectedGroups.map(id => {
                    const group = groupChats.find(g => g.id === id);
                    return group ? group.name : '未知群聊';
                }).join('、');
                showToast(`已开启与"${groupNames}"的记忆共享`, 'success');
            } else {
                showToast('已关闭记忆共享', 'success');
            }
        }

        // 隐藏记忆共享设置
        function hideMemoryShareSettings() {
            const modal = document.getElementById('memory-share-modal');
            if (modal) modal.remove();
        }

        // 更新记忆共享状态显示
        function updateMemoryShareStatus() {
            const statusElement = document.getElementById('memory-share-status');
            if (!statusElement) return;

            const chatSettings = getCurrentChatSettings();
            const sharedGroupIds = chatSettings.memorySharedGroupIds || [];

            if (sharedGroupIds.length > 0) {
                if (sharedGroupIds.length === 1) {
                    const group = groupChats.find(g => g.id === sharedGroupIds[0]);
                    statusElement.textContent = group ? `与"${group.name}"共享` : '已开启';
                } else {
                    statusElement.textContent = `与${sharedGroupIds.length}个群聊共享`;
                }
            } else {
                statusElement.textContent = '已关闭';
            }
        }

        // ================== 日记功能系统 ==================

        // 显示日记菜单
        function showDiaryMenu() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'error');
                return;
            }

            // 🔥【修改】群聊中不支持日记功能
            if (currentChatCharacter.isGroup) {
                showToast('群聊中不支持日记功能，请在单聊中使用', 'error');
                return;
            }

            showModal('diary-menu-modal');
        }

        // 隐藏日记菜单
        function hideDiaryMenu() {
            hideModal('diary-menu-modal');
        }

        // 显示今日日记
        async function showTodayDiary() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'error');
                return;
            }

            // 🔥【修改】群聊中不支持日记功能
            if (currentChatCharacter.isGroup) {
                showToast('群聊中不支持日记功能，请在单聊中使用', 'error');
                return;
            }

            hideDiaryMenu();

            const today = new Date().toISOString().split('T')[0];
            const diaryId = `${currentChatCharacter.id}_${today}`;

            let todayDiary = null;
            try {
                // 🔥【修复】从Dexie数据库获取今日日记
                todayDiary = await db.characterDiaries.get(diaryId);

                // 🔥【数据迁移】如果Dexie中没有数据，尝试从localStorage迁移
                if (!todayDiary) {
                    const oldDiaryKey = `diary_${currentChatCharacter.id}_${today}`;
                    const localStorageDiary = localStorage.getItem(oldDiaryKey);

                    if (localStorageDiary) {
                        // 迁移到Dexie
                        const cleanedContent = cleanDiaryContent(localStorageDiary);
                        await db.characterDiaries.add({
                            id: diaryId,
                            characterId: currentChatCharacter.id,
                            date: today,
                            content: cleanedContent,
                            timestamp: new Date().getTime(),
                            weather: '☀️'
                        });
                        todayDiary = { content: cleanedContent };

                        // 清理localStorage数据
                        localStorage.removeItem(oldDiaryKey);
                        console.log('✅ 日记数据已从localStorage迁移到Dexie');
                    }
                }
            } catch (error) {
                console.error('获取今日日记失败:', error);
                showToast('获取日记失败', 'error');
                return;
            }

            const contentDiv = document.getElementById('today-diary-content');
            const generateBtn = document.getElementById('generate-diary-btn');

            // 重置按钮状态
            const editBtn = document.getElementById('edit-diary-btn');
            generateBtn.disabled = false;
            generateBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
            generateBtn.title = '生成日记';

            if (todayDiary && todayDiary.content) {
                // 显示已有的日记，包含头部信息
                const diaryWithHeader = createDiaryWithHeader(todayDiary.content, today);
                contentDiv.innerHTML = diaryWithHeader;
                contentDiv.classList.remove('empty');
                generateBtn.style.display = 'block';
                generateBtn.title = '重新生成日记';
                editBtn.style.display = 'block';
            } else {
                contentDiv.innerHTML = '今天还没有写日记呢...';
                contentDiv.classList.add('empty');
                generateBtn.style.display = 'block';
                generateBtn.title = '生成日记';
                editBtn.style.display = 'none';
            }

            showModal('today-diary-modal');
        }

        // 隐藏今日日记
        function hideTodayDiary() {
            hideModal('today-diary-modal');
        }

        // 生成今日日记
        async function generateTodayDiary() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'error');
                return;
            }

            // 🔥【修改】群聊中不支持日记功能
            if (currentChatCharacter.isGroup) {
                showToast('群聊中不支持日记功能，请在单聊中使用', 'error');
                return;
            }

            const generateBtn = document.getElementById('generate-diary-btn');
            const contentDiv = document.getElementById('today-diary-content');

            // 获取今日日记
            const today = new Date().toISOString().split('T')[0];
            const diaryId = `${currentChatCharacter.id}_${today}`;

            let existingDiary = null;
            try {
                // 🔥【修复】从Dexie数据库获取今日日记
                existingDiary = await db.characterDiaries.get(diaryId);
            } catch (error) {
                console.error('获取今日日记失败:', error);
            }

            // 如果已有日记，提示用户将重新生成
            if (existingDiary && existingDiary.content) {
                const confirmRegenerate = confirm('今天已经有日记了，是否要重新生成？这将覆盖原有的日记。');
                if (!confirmRegenerate) {
                    return;
                }
            }

            generateBtn.disabled = true;
            generateBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            generateBtn.title = 'TA在写呢...';
            contentDiv.innerHTML = '正在写日记...';
            contentDiv.classList.remove('empty');

            try {
                const character = currentChatCharacter;
                const characterId = character.id;

                // 🔥【修复】获取该角色的聊天设置
                const chatSettings = await getAsyncChatSettings(characterId);

                // 获取聊天历史（使用历史消息回合数设置）
                const messages = chatMessages[characterId] || [];
                const historyCount = chatSettings.historyCount || 5;
                const recentMessages = messages.slice(-historyCount);

                // 获取跨窗口记忆数量的最近动态内容
                const crossWindowMemory = chatSettings.crossWindowMemory || 3;
                const recentMoments = await getRecentMoments(crossWindowMemory);

                // 构建聊天历史上下文
                let chatContext = '';
                if (recentMessages.length > 0) {
                    chatContext = '\n\n最近的聊天记录：\n' +
                        recentMessages.map(msg => {
                            if (msg.sender === 'sent') return `用户：${msg.content}`;
                            if (msg.sender === 'received') return `${character.name}：${msg.content}`;
                            return '';
                        }).filter(Boolean).join('\n');
                }

                // 构建动态上下文（包括评论）
                let momentsContext = '';
                if (recentMoments.length > 0) {
                    momentsContext = '\n\n最近的动态内容：\n' +
                        recentMoments.map(moment => {
                            let momentText = `${moment.nickname}: ${moment.text}`;
                            if (moment.comments && moment.comments.length > 0) {
                                const commentTexts = moment.comments.map(comment =>
                                    `  ${comment.nickname}: ${comment.text}`
                                ).join('\n');
                                momentText += '\n评论：\n' + commentTexts;
                            }
                            return momentText;
                        }).join('\n\n');
                }

                // 获取世界书信息
                let worldbookContext = '';
                if (character.worldbook && character.worldbook.length > 0) {
                    worldbookContext = '\n\n世界书信息：\n' +
                        character.worldbook.map(entry => `${entry.key}: ${entry.value}`).join('\n');
                }

                // 构建日记生成prompt
                const currentDate = new Date().toLocaleDateString('zh-CN', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    weekday: 'long'
                });

                const prompt = `你是${character.name}，你的人设如下：${character.bio}${worldbookContext}

现在是${currentDate}，你需要写一篇私人日记。

重要要求：
- 请直接输出日记内容，不要使用JSON格式或任何代码块
- 不要包含日期标题（日期会自动显示在日记纸上）
- 用你的口吻和性格来写
- 记录你今天的想法、感受和经历
- 可以提及对用户的真实感情
- 基于最近的聊天记录，可适当考虑工作记忆和同分组好友的动态内容、角色自己和用户的动态内容
- 保持角色的一致性和真实性
- 内容要自然、真实，像真正的私人日记
- 字数在50-500字之间，根据你的性格和当天的心情自由发挥${chatContext}${momentsContext}

特殊样式说明（可选使用，每种样式在同一篇日记中最多使用2次，该特殊样式并不是一定要使用，可以不用）：
- 如果写到不该说的话或后悔写下的内容，可以用 <strike>内容</strike> 标记划掉
- 如果表达重点或语气激动的内容，可以用 <mark>内容</mark> 标记高亮

请直接写出${character.name}的私人日记内容：`;

                const diaryContent = await generateAIResponse(prompt, character);

                if (diaryContent && diaryContent.trim()) {
                    let finalDiary = diaryContent.trim();

                    // 清理可能的JSON格式包装
                    finalDiary = cleanDiaryContent(finalDiary);

                    // 🔥【修复】保存今日日记到Dexie数据库
                    try {
                        await db.characterDiaries.put({
                            id: diaryId,
                            characterId: characterId,
                            date: today,
                            content: finalDiary,
                            timestamp: Date.now(),
                            weather: '☀️' // 默认天气，后续可以扩展
                        });
                        console.log('✅ 日记已保存到数据库');
                    } catch (saveError) {
                        console.error('保存日记到数据库失败:', saveError);
                        throw new Error('保存日记失败');
                    }

                    // 显示日记内容，包含头部信息
                    const diaryWithHeader = createDiaryWithHeader(finalDiary);
                    contentDiv.innerHTML = diaryWithHeader;
                    contentDiv.classList.remove('empty');
                    generateBtn.disabled = false;
                    generateBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
                    generateBtn.title = '重新生成日记';

                    // 显示编辑按钮
                    const editBtn = document.getElementById('edit-diary-btn');
                    editBtn.style.display = 'block';

                    showToast(existingDiary ? '日记重新生成完成' : '日记生成完成', 'success');
                } else {
                    throw new Error('生成日记失败');
                }
            } catch (error) {
                console.error('生成日记失败:', error);
                contentDiv.innerHTML = '生成日记失败，请稍后重试';
                contentDiv.classList.add('empty');
                generateBtn.disabled = false;
                generateBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
                generateBtn.title = existingDiary ? '重新生成日记' : '生成日记';
                showToast('生成日记失败', 'error');
            }
        }

        // 显示过往日记
        async function showPastDiaries() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'error');
                return;
            }

            // 🔥【修改】群聊中不支持日记功能
            if (currentChatCharacter.isGroup) {
                showToast('群聊中不支持日记功能，请在单聊中使用', 'error');
                return;
            }

            hideDiaryMenu();

            const characterId = currentChatCharacter.id;

            let pastDiaries = [];
            try {
                // 🔥【修复】从Dexie数据库获取过往日记
                pastDiaries = await db.characterDiaries
                    .where('characterId')
                    .equals(characterId)
                    .reverse() // 按时间倒序排列
                    .sortBy('timestamp');

                console.log(`获取到 ${pastDiaries.length} 条日记记录`);
            } catch (error) {
                console.error('获取过往日记失败:', error);
                showToast('获取日记失败', 'error');
                return;
            }

            const listDiv = document.getElementById('past-diaries-list');

            if (pastDiaries.length === 0) {
                listDiv.innerHTML = `
                    <div class="no-diaries">
                        <i class="fas fa-book-open"></i>
                        <div>还没有任何日记记录</div>
                    </div>
                `;
            } else {
                listDiv.innerHTML = pastDiaries.map((diary, index) => {
                    const date = new Date(diary.date).toLocaleDateString('zh-CN', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric',
                        weekday: 'long'
                    });

                    // 移除HTML标记用于预览显示
                    const cleanContent = diary.content.replace(/<[^>]*>/g, '');
                    const preview = cleanContent.length > 100 ?
                        cleanContent.substring(0, 100) + '...' :
                        cleanContent;

                    return `
                        <div class="diary-entry" onclick="toggleDiaryEntry(${index})">
                            <div class="diary-entry-date">${date}</div>
                            <div class="diary-entry-preview">${preview}</div>
                            <div class="diary-paper-container">
                                <div class="diary-entry-full diary-paper">${createDiaryWithHeader(diary.content, diary.date)}</div>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            showModal('past-diaries-modal');
        }

        // 隐藏过往日记
        function hidePastDiaries() {
            hideModal('past-diaries-modal');
        }

        // 切换日记条目的展开/收起状态
        function toggleDiaryEntry(index) {
            const entries = document.querySelectorAll('.diary-entry');
            const entry = entries[index];

            if (entry) {
                entry.classList.toggle('expanded');
            }
        }

        // 创建带头部信息的日记内容
        function createDiaryWithHeader(diaryContent, diaryDate = null) {
            const targetDate = diaryDate ? new Date(diaryDate) : new Date();
            const dateStr = targetDate.toLocaleDateString('zh-CN', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
            const weekdayStr = targetDate.toLocaleDateString('zh-CN', { weekday: 'long' });

            // 简单的天气模拟（可以根据需要改进）
            const weathers = ['晴', '多云', '阴', '小雨', '晴朗', '微风'];
            const weather = weathers[Math.floor(Math.random() * weathers.length)];

            // 确保日记内容经过样式处理
            const processedContent = processDiaryStyles(diaryContent);

            return `<div class="diary-header">
                <span class="diary-date">${dateStr} ${weekdayStr}</span>
                <span class="diary-weather">天气：${weather}</span>
            </div>${processedContent}`;
        }

        // 清理日记内容，移除可能的JSON格式包装
        function cleanDiaryContent(content) {
            // 移除可能的JSON包装
            if (content.startsWith('```json') && content.endsWith('```')) {
                content = content.slice(7, -3).trim();
            }
            if (content.startsWith('```') && content.endsWith('```')) {
                content = content.slice(3, -3).trim();
            }

            // 尝试解析JSON格式的内容
            try {
                const parsed = JSON.parse(content);
                if (typeof parsed === 'string') {
                    content = parsed;
                } else if (parsed.content) {
                    content = parsed.content;
                } else if (parsed.diary) {
                    content = parsed.diary;
                } else if (parsed.text) {
                    content = parsed.text;
                }
            } catch (e) {
                // 不是JSON格式，继续处理
            }

            // 移除可能的引号包装
            if ((content.startsWith('"') && content.endsWith('"')) ||
                (content.startsWith("'") && content.endsWith("'"))) {
                content = content.slice(1, -1);
            }

            // 处理特殊样式标记
            content = processDiaryStyles(content);

            return content;
        }

        // 处理日记特殊样式
        function processDiaryStyles(content) {
            // 限制每种样式最多使用2次
            let strikeCount = 0;
            let highlightCount = 0;

            // 处理划线样式 <strike>内容</strike>
            content = content.replace(/<strike>(.*?)<\/strike>/gi, (match, text) => {
                if (strikeCount < 2) {
                    strikeCount++;
                    return `<span class="diary-strikethrough">${text}</span>`;
                }
                return text; // 超过限制时移除标记但保留文本
            });

            // 处理高亮样式 <mark>内容</mark>
            content = content.replace(/<mark>(.*?)<\/mark>/gi, (match, text) => {
                if (highlightCount < 2) {
                    highlightCount++;
                    return `<span class="diary-highlight">${text}</span>`;
                }
                return text; // 超过限制时移除标记但保留文本
            });

            return content;
        }

        // 🔥【数据迁移】迁移过往日记格式 - 一次性执行
        function migratePastDiariesFormat(characterId, oldDateStr, newDateStr, diaryContent) {
            // 检查是否已经迁移过
            const migrationKey = `diary_migration_${characterId}`;
            if (localStorage.getItem(migrationKey)) {
                return; // 已经迁移过，跳过
            }

            const pastDiariesKey = `past_diaries_${characterId}`;
            let pastDiaries = JSON.parse(localStorage.getItem(pastDiariesKey) || '[]');

            // 检查是否已经有今天的记录（新格式）
            const existingNewIndex = pastDiaries.findIndex(diary => diary.date === newDateStr);

            if (existingNewIndex === -1) {
                // 检查是否有旧格式的记录
                const existingOldIndex = pastDiaries.findIndex(diary => diary.date === oldDateStr);

                if (existingOldIndex !== -1) {
                    // 更新旧记录的日期格式
                    pastDiaries[existingOldIndex].date = newDateStr;
                    pastDiaries[existingOldIndex].content = diaryContent;
                    pastDiaries[existingOldIndex].timestamp = Date.now();
                } else {
                    // 添加新记录
                    pastDiaries.unshift({
                        date: newDateStr,
                        content: diaryContent,
                        timestamp: Date.now()
                    });
                }

                localStorage.setItem(pastDiariesKey, JSON.stringify(pastDiaries));
            }

            // 标记已完成迁移
            localStorage.setItem(migrationKey, 'completed');
        }

        // 编辑今日日记
        async function editTodayDiary() {
            if (!currentChatCharacter) {
                showToast('请先选择角色', 'error');
                return;
            }

            // 🔥【修改】群聊中不支持日记功能
            if (currentChatCharacter.isGroup) {
                showToast('群聊中不支持日记功能，请在单聊中使用', 'error');
                return;
            }

            const characterId = currentChatCharacter.id;

            const today = new Date().toISOString().split('T')[0];
            const diaryId = `${characterId}_${today}`;

            let todayDiary = null;
            try {
                // 🔥【修复】从Dexie数据库获取今日日记
                todayDiary = await db.characterDiaries.get(diaryId);
            } catch (error) {
                console.error('获取今日日记失败:', error);
                showToast('获取日记失败', 'error');
                return;
            }

            if (!todayDiary || !todayDiary.content) {
                showToast('今天还没有日记可以编辑', 'error');
                return;
            }

            // 将HTML格式转换回标记格式用于编辑
            const editableContent = convertHtmlToMarkup(todayDiary.content);

            // 创建编辑模态框
            const editModal = document.createElement('div');
            editModal.className = 'modal';
            editModal.style.display = 'block';
            editModal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h3 class="modal-title">编辑日记</h3>
                        <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="info-text" style="margin-bottom: 15px;">
                            <strong>样式提示：</strong><br>
                            • 用 &lt;strike&gt;内容&lt;/strike&gt; 标记划掉不该说的话<br>
                            • 用 &lt;mark&gt;内容&lt;/mark&gt; 标记重点或激动的内容<br>
                            • 每种样式在同一篇日记中最多使用2次
                        </div>
                        <textarea id="edit-diary-textarea" class="diary-edit-textarea" placeholder="编辑日记内容...">${editableContent}</textarea>
                        <div class="modal-actions">
                            <button class="modal-button modal-secondary" onclick="this.closest('.modal').remove()">取消</button>
                            <button class="modal-button modal-primary" onclick="saveDiaryEdit()">保存</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(editModal);

            // 聚焦到文本框
            const textarea = editModal.querySelector('#edit-diary-textarea');
            textarea.focus();
            textarea.setSelectionRange(textarea.value.length, textarea.value.length);
        }

        // 将HTML格式转换回标记格式用于编辑
        function convertHtmlToMarkup(content) {
            return content
                .replace(/<span class="diary-strikethrough">(.*?)<\/span>/gi, '<strike>$1</strike>')
                .replace(/<span class="diary-highlight">(.*?)<\/span>/gi, '<mark>$1</mark>');
        }

        // 保存日记编辑
        async function saveDiaryEdit() {
            if (!currentChatCharacter) {
                showToast('请先选择角色', 'error');
                return;
            }

            // 🔥【修改】群聊中不支持日记功能
            if (currentChatCharacter.isGroup) {
                showToast('群聊中不支持日记功能，请在单聊中使用', 'error');
                return;
            }

            const characterId = currentChatCharacter.id;
            const today = new Date().toISOString().split('T')[0];
            const diaryId = `${characterId}_${today}`;

            const textarea = document.getElementById('edit-diary-textarea');
            const newContent = textarea.value.trim();

            if (!newContent) {
                showToast('日记内容不能为空', 'error');
                return;
            }

            // 处理特殊样式标记
            const processedContent = processDiaryStyles(newContent);

            try {
                // 🔥【修复】保存到Dexie数据库
                await db.characterDiaries.put({
                    id: diaryId,
                    characterId: characterId,
                    date: today,
                    content: processedContent,
                    timestamp: Date.now(),
                    weather: '☀️' // 保持原有天气或默认值
                });

                // 更新显示
                const contentDiv = document.getElementById('today-diary-content');
                const diaryWithHeader = createDiaryWithHeader(processedContent, today);
                contentDiv.innerHTML = diaryWithHeader;
                contentDiv.classList.remove('empty');

                // 关闭编辑模态框
                document.querySelector('.modal:last-child').remove();

                showToast('日记保存成功', 'success');

            } catch (error) {
                console.error('保存日记失败:', error);
                showToast('保存日记失败', 'error');
            }
        }
        
        // 判断是否应该更新角色状态
        async function shouldUpdateCharacterStatus(characterId) {
            try {
                const currentStatus = getCharacterStatus(characterId);
                const lastUpdate = new Date(currentStatus.lastUpdate);
                const now = new Date();
                const timeDiff = now - lastUpdate;

                // 🔥【修复】获取用户设置的更新频率间隔
                const updateInterval = getStatusUpdateInterval();

                // 如果距离上次更新的时间还没到设定的间隔，不更新
                if (timeDiff < updateInterval) {
                    return false;
                }

                // 如果状态超过设定间隔很久没更新，强制更新
                if (timeDiff > updateInterval * 2) {
                    return true;
                }

                // 🔥【新增】如果最近有聊天活动，在定时器触发时有更高概率更新
                if (currentStatus.lastChatTime) {
                    const lastChatTime = new Date(currentStatus.lastChatTime);
                    const chatTimeDiff = now - lastChatTime;

                    // 如果最近聊天过，且距离上次更新已经超过设定间隔，有较高概率更新
                    if (chatTimeDiff < updateInterval && timeDiff >= updateInterval) {
                        return Math.random() < 0.7; // 70%概率
                    }
                }

                // 默认情况下，如果到了更新时间，有一定概率更新
                return Math.random() < 0.3; // 30%概率

            } catch (error) {
                console.error('判断角色状态更新失败:', error);
                return Math.random() < 0.1; // 10%概率
            }
        }
        
        // 更新角色最后聊天时间
        async function updateCharacterLastChatTime(characterId) {
            try {
                let statusRecord = characterStatusData.find(s => s.characterId === characterId);

                if (!statusRecord) {
                    // 如果没有状态记录，创建一个新的
                    statusRecord = {
                        id: `status_${characterId}`,
                        characterId: characterId,
                        status: 'online',
                        activity: '在线',
                        location: '',
                        lastUpdate: new Date().toISOString(),
                        lastChatTime: Date.now()
                    };
                    characterStatusData.push(statusRecord);
                } else {
                    // 只更新聊天时间，不改变其他状态
                    statusRecord.lastChatTime = Date.now();
                }

                await db.characterStatus.put(statusRecord);

            } catch (error) {
                console.error('更新角色聊天时间失败:', error);
            }
        }

        // 在发送/接收消息后触发状态更新
        async function triggerStatusUpdateAfterMessage(characterId) {
            // 🔥【修复】首先检查是否开启了角色状态显示
            const chatSettings = await getAsyncChatSettings(characterId);
            if (!chatSettings.characterStatusEnabled) {
                console.log(`角色 ${characterId} 未启用状态显示，跳过状态更新`);
                return;
            }

            // 🔥【关键修复】不再在每次聊天后立即触发状态更新
            // 状态更新应该完全由定时器控制，遵循用户设置的频率
            // 这里只是记录最后一次聊天时间，供定时器判断是否需要更新
            await updateCharacterLastChatTime(characterId);

            console.log(`角色 ${characterId} 聊天时间已记录，状态更新将由定时器根据用户设置的频率进行`);
        }

        // 在应用初始化时启动状态更新定时器
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                startStatusUpdateTimer();
            }, 5000); // 延迟5秒启动
        });

        console.log('🚫 拉黑系统核心功能已加载');

        // 🔧【新增】记忆设置界面事件监听器
        document.addEventListener('DOMContentLoaded', function() {
            // 添加阈值滑块事件监听器
            const coreThresholdSlider = document.getElementById('coreMemoryThreshold');
            const episodicThresholdSlider = document.getElementById('episodicMemoryThreshold');

            if (coreThresholdSlider) {
                coreThresholdSlider.addEventListener('input', updateThresholdDisplay);
            }
            if (episodicThresholdSlider) {
                episodicThresholdSlider.addEventListener('input', updateThresholdDisplay);
            }
        });

        // 🔥【新增】记忆管理系统

        // 文本相似度计算函数（简单的Jaccard相似度）
        function calculateTextSimilarity(text1, text2) {
            if (!text1 || !text2) return 0;

            // 转换为小写并分词
            const words1 = new Set(text1.toLowerCase().match(/[\u4e00-\u9fa5\w]+/g) || []);
            const words2 = new Set(text2.toLowerCase().match(/[\u4e00-\u9fa5\w]+/g) || []);

            // 计算交集和并集
            const intersection = new Set([...words1].filter(x => words2.has(x)));
            const union = new Set([...words1, ...words2]);

            // Jaccard相似度
            return union.size === 0 ? 0 : intersection.size / union.size;
        }

        // 记忆系统配置（可由用户设置）
        let MEMORY_CONFIG = {
            // AI记忆提取配置
            AI_EXTRACT_INTERVAL: 60, // 默认每30回合对话（60条消息）进行AI提取

            // 核心记忆配置
            CORE_MEMORY_IMPORTANCE_THRESHOLD: 0.9, // 核心记忆重要性阈值90%
            MAX_CORE_MEMORIES_PER_CHARACTER: 50, // 每个角色最多保留50条核心记忆

            // 情景记忆配置
            EPISODIC_MEMORY_IMPORTANCE_THRESHOLD: 0.6, // 情景记忆重要性阈值60%
            MAX_EPISODIC_MEMORIES_PER_CHARACTER: 100, // 每个角色最多保留100条情景记忆

            // 跨应用记忆配置
            CROSS_APP_TIMELINE_LIMIT: 20, // 跨应用时间线在工作记忆中的最大条数
        };

        // 从用户设置中加载记忆配置
        async function loadMemoryConfig() {
            try {
                const settings = await db.globalSettings.get('memoryConfig');
                if (settings && settings.value) {
                    MEMORY_CONFIG = { ...MEMORY_CONFIG, ...settings.value };
                }
            } catch (error) {
                console.error('加载记忆配置失败:', error);
            }
        }

        // 保存记忆配置到用户设置
        async function saveMemoryConfig() {
            try {
                await db.globalSettings.put({
                    id: 'memoryConfig',
                    value: MEMORY_CONFIG
                });
            } catch (error) {
                console.error('保存记忆配置失败:', error);
            }
        }

        // 自动摘要生成功能
        async function generateConversationSummary(characterId, messages) {
            if (!messages || messages.length === 0) return null;

            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return null;

                // 构建摘要生成的prompt，统一使用第三人称
                const summaryPrompt = `
# 对话摘要任务

你需要为以下对话生成一个简洁的摘要。

## 角色信息
- 角色名称: ${character.name}
- 角色设定: ${character.bio || '无特殊设定'}

## 对话内容
${messages.map(msg => {
    const sender = msg.sender === 'sent' ? '用户' : character.name;
    const content = typeof msg.content === 'string' ? msg.content : '[图片/文件]';
    return `${sender}: ${content}`;
}).join('\n')}

## 摘要要求
请生成一个100-200字的对话摘要，包含：
1. 主要话题和讨论内容
2. 重要的情感变化或关键事件
3. 双方的态度和关系变化
4. 任何重要的决定或约定

## 重要要求：统一使用第三人称
- 用"用户"指代用户，用"${character.name}"指代角色
- 不要使用"我"、"你"等第一、第二人称
- 例如："用户向${character.name}询问..."而不是"你问我..."

请用第三人称客观描述，保持简洁明了。`;

                // 调用AI提取记忆
                const response = await callChatAPI(extractPrompt, character);
                const responseText = Array.isArray(response) ? response[0] : response;

                if (responseText && typeof responseText === 'string') {
                    try {
                        // 提取JSON部分
                        const jsonMatch = responseText.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            const memories = JSON.parse(jsonMatch[0]);

                            // 获取现有记忆，检查重复
                            const existingMemories = await db.coreMemories
                                .where('characterId')
                                .equals(characterId)
                                .toArray();

                            // 保存核心记忆（确保角色隔离）
                            for (const memory of memories.core_memories || []) {
                                if (memory.importance >= MEMORY_CONFIG.CORE_MEMORY_IMPORTANCE_THRESHOLD) {
                                    // 只检查该角色的现有记忆，避免跨角色混淆
                                    const isDuplicate = existingMemories.some(existing => {
                                        const similarity = calculateTextSimilarity(existing.fact, memory.fact);
                                        return similarity > 0.8;
                                    });

                                    if (!isDuplicate) {
                                        const coreMemory = {
                                            id: `core_${characterId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                            characterId: characterId, // 严格绑定角色ID
                                            fact: memory.fact,
                                            importance: memory.importance,
                                            category: memory.category || 'other',
                                            timestamp: Date.now(),
                                            type: 'core',
                                            source: 'single_chat', // 标记来源，区分单聊和群聊
                                            contextId: characterId // 🔥【修复】添加上下文ID用于记忆隔离
                                        };

                                        await db.coreMemories.add(coreMemory);
                                        console.log(`✅ [${character.name}] 核心记忆: ${memory.fact}`);
                                    }
                                }
                            }

                            // 保存情景记忆（确保角色隔离）
                            for (const memory of memories.episodic_memories || []) {
                                if (memory.importance >= MEMORY_CONFIG.EPISODIC_MEMORY_IMPORTANCE_THRESHOLD) {
                                    const episodicMemory = {
                                        id: `episodic_${characterId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                        characterId: characterId, // 严格绑定角色ID
                                        fact: memory.fact,
                                        importance: memory.importance,
                                        category: memory.category || 'other',
                                        timestamp: Date.now(),
                                        source: 'single_chat', // 标记来源
                                        contextId: characterId // 🔥【修复】添加上下文ID用于记忆隔离
                                    };

                                    await db.episodicMemories.add(episodicMemory);
                                    console.log(`✅ [${character.name}] 情景记忆: ${memory.fact}`);
                                }
                            }
                        }
                    } catch (parseError) {
                        console.warn('解析记忆JSON失败:', parseError);
                    }
                }
            } catch (error) {
                console.error('AI记忆提取失败:', error);
            }
        }

        // 检查是否需要生成摘要
        async function checkAndGenerateSummary(characterId) {
            try {
                const messages = chatMessages[characterId] || [];
                if (messages.length === 0) return;

                // 获取最后一次摘要的时间
                const summaries = await db.memorySummaries
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                const lastSummary = summaries.length > 0
                    ? summaries.sort((a, b) => b.timestamp - a.timestamp)[0]
                    : null;

                let shouldGenerate = false;
                let messagesToSummarize = [];

                if (!lastSummary) {
                    // 如果从未生成过摘要，且消息数量达到阈值
                    if (messages.length >= MEMORY_CONFIG.SUMMARY_TRIGGER_MESSAGE_COUNT) {
                        messagesToSummarize = messages.slice(-MEMORY_CONFIG.SUMMARY_TRIGGER_MESSAGE_COUNT);
                        shouldGenerate = true;
                    }
                } else {
                    // 计算自上次摘要后的新消息
                    const lastSummaryTime = lastSummary.context?.endTime || lastSummary.timestamp;
                    const newMessages = messages.filter(msg => msg.timestamp > lastSummaryTime);

                    // 检查消息数量或时间间隔
                    const timeDiff = Date.now() - lastSummary.timestamp;
                    const hoursDiff = timeDiff / (1000 * 60 * 60);

                    if (newMessages.length >= MEMORY_CONFIG.SUMMARY_TRIGGER_MESSAGE_COUNT ||
                        hoursDiff >= MEMORY_CONFIG.SUMMARY_TRIGGER_TIME_HOURS) {
                        messagesToSummarize = newMessages.slice(-MEMORY_CONFIG.SUMMARY_TRIGGER_MESSAGE_COUNT);
                        shouldGenerate = true;
                    }
                }

                if (shouldGenerate && messagesToSummarize.length > 0) {
                    await generateConversationSummary(characterId, messagesToSummarize);
                }
            } catch (error) {
                console.error('检查摘要生成失败:', error);
            }
        }

        // 移除关键词提取功能，简化为纯AI提取

        // AI记忆提取功能（严格的核心记忆）
        async function extractMemoriesWithAI(characterId, messages, contextId = null) {
            if (!messages || messages.length === 0) return;

            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;

                // 🔥【修复】如果没有提供contextId，使用characterId作为默认值（单聊）
                if (!contextId) {
                    contextId = characterId;
                }

                // 构建更严格的记忆提取prompt，统一使用第三人称
                const extractPrompt = `
# 记忆提取任务

你需要从以下对话中提取两类记忆：核心记忆和情景记忆。

## 角色信息
- 角色名称: ${character.name}
- 角色设定: ${character.bio || '无特殊设定'}

## 对话内容
${messages.map(msg => {
    const sender = msg.sender === 'sent' ? '用户' : character.name;
    const content = typeof msg.content === 'string' ? msg.content : '[图片/文件]';
    return `${sender}: ${content}`;
}).join('\n')}

## 提取标准

### 核心记忆（importance >= 0.9）
只有以下类型的信息才能成为核心记忆：
- 用户的基本信息：真实姓名、生日、职业、家庭成员
- 重大情感转变：表白、分手、和好、深度情感交流
- 重要承诺和约定：长期计划、重要约定
- 关键人生事件：毕业、工作变动、搬家、重要纪念日
- 角色与用户关系的重大变化

### 情景记忆（importance 0.6-0.8）
日常但有意义的事件：
- 一起做的活动和体验
- 用户的习惯和偏好
- 有趣的对话和互动
- 日常生活的分享

## 重要要求：记忆描述必须使用第三人称
- 用"用户"指代用户，用"${character.name}"指代角色
- 不要使用"我"、"你"等第一、第二人称
- 例如："用户告诉${character.name}自己的生日是..."而不是"我的生日是..."

请严格按照以下JSON格式返回，不要添加任何其他文字：

{
  "core_memories": [
    {"fact": "简洁的核心事实（使用第三人称）", "importance": 0.9, "category": "类别"}
  ],
  "episodic_memories": [
    {"fact": "情景描述（使用第三人称）", "importance": 0.7, "category": "类别"}
  ]
}

注意：
1. 只返回JSON，不要有任何解释文字
2. 如果没有符合标准的记忆，对应数组为空
3. importance必须是数字，不要用字符串
4. 确保JSON格式完全正确
5. 所有fact字段必须使用第三人称描述`;

                // 调用AI提取核心记忆
                const response = await callChatAPI(extractPrompt, character);
                let memories = [];

                try {
                    // 尝试解析JSON响应
                    const responseText = Array.isArray(response) ? response[0] : response;
                    if (responseText && typeof responseText === 'string') {
                        console.log('🔍 AI记忆提取原始响应:', responseText);

                        // 多种方式尝试提取JSON
                        let jsonText = null;

                        // 方式1: 提取完整的JSON对象
                        const jsonObjectMatch = responseText.match(/\{[\s\S]*\}/);
                        if (jsonObjectMatch) {
                            jsonText = jsonObjectMatch[0];
                        } else {
                            // 方式2: 提取JSON数组
                            const jsonArrayMatch = responseText.match(/\[[\s\S]*\]/);
                            if (jsonArrayMatch) {
                                jsonText = jsonArrayMatch[0];
                            }
                        }

                        if (jsonText) {
                            console.log('🔍 提取的JSON文本:', jsonText);
                            memories = JSON.parse(jsonText);
                        } else {
                            console.warn('⚠️ 未找到有效的JSON格式');
                            return; // 如果没有找到JSON，直接返回
                        }
                    }
                } catch (parseError) {
                    console.warn('解析核心记忆JSON失败:', parseError);
                    console.warn('原始响应:', responseText);
                    return; // 解析失败时直接返回，避免后续错误
                    return;
                }

                // 获取现有的记忆，检查重复
                const [existingCoreMemories, existingEpisodicMemories] = await Promise.all([
                    db.coreMemories.where('characterId').equals(characterId).toArray(),
                    db.episodicMemories.where('characterId').equals(characterId).toArray()
                ]);

                // 🔥【修复】处理核心记忆
                if (memories.core_memories && Array.isArray(memories.core_memories)) {
                    for (const memory of memories.core_memories) {
                        if (memory.importance >= MEMORY_CONFIG.CORE_MEMORY_IMPORTANCE_THRESHOLD) {
                            // 检查是否已存在相似的记忆
                            const isDuplicate = existingCoreMemories.some(existing => {
                                const similarity = calculateTextSimilarity(existing.fact, memory.fact);
                                return similarity > 0.8; // 相似度超过80%认为是重复
                            });

                            if (!isDuplicate) {
                                const coreMemory = {
                                    id: `core_${characterId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                    characterId: characterId,
                                    fact: memory.fact,
                                    importance: memory.importance,
                                    category: memory.category || 'other',
                                    timestamp: Date.now(),
                                    type: 'core',
                                    contextId: contextId // 🔥【修复】添加上下文ID用于记忆隔离
                                };

                                await db.coreMemories.add(coreMemory);
                                console.log(`✅ 为角色 ${character.name} 添加核心记忆: ${memory.fact}`);
                            } else {
                                console.log(`⚠️ 跳过重复核心记忆: ${memory.fact}`);
                            }
                        }
                    }
                }

                // 🔥【新增】处理情景记忆
                if (memories.episodic_memories && Array.isArray(memories.episodic_memories)) {
                    for (const memory of memories.episodic_memories) {
                        if (memory.importance >= MEMORY_CONFIG.EPISODIC_MEMORY_IMPORTANCE_THRESHOLD) {
                            // 检查是否已存在相似的记忆
                            const isDuplicate = existingEpisodicMemories.some(existing => {
                                const similarity = calculateTextSimilarity(existing.fact, memory.fact);
                                return similarity > 0.8; // 相似度超过80%认为是重复
                            });

                            if (!isDuplicate) {
                                const episodicMemory = {
                                    id: `episodic_${characterId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                    characterId: characterId,
                                    fact: memory.fact,
                                    importance: memory.importance,
                                    category: memory.category || 'other',
                                    timestamp: Date.now(),
                                    contextId: contextId // 🔥【修复】添加上下文ID用于记忆隔离
                                };

                                await db.episodicMemories.add(episodicMemory);
                                console.log(`✅ 为角色 ${character.name} 添加情景记忆: ${memory.fact}`);
                            } else {
                                console.log(`⚠️ 跳过重复情景记忆: ${memory.fact}`);
                            }
                        }
                    }
                }

                // 清理过多的记忆
                await cleanupCoreMemories(characterId);
                await cleanupEpisodicMemories(characterId);

            } catch (error) {
                console.error('提取核心记忆失败:', error);
            }
        }

        // 清理过多的核心记忆，保留最重要的
        async function cleanupCoreMemories(characterId) {
            try {
                const allMemories = await db.coreMemories
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                const memories = allMemories.sort((a, b) => b.importance - a.importance);
                const maxCoreMemories = MEMORY_CONFIG.MAX_CORE_MEMORIES_PER_CHARACTER || 50;

                if (memories.length > maxCoreMemories) {
                    const toDelete = memories.slice(maxCoreMemories);
                    for (const memory of toDelete) {
                        await db.coreMemories.delete(memory.id);
                    }
                    console.log(`🧹 清理了 ${toDelete.length} 个低重要性的核心记忆`);
                }
            } catch (error) {
                console.error('清理核心记忆失败:', error);
            }
        }

        // 🔥【新增】清理过多的情景记忆，保留最重要和最新的
        async function cleanupEpisodicMemories(characterId) {
            try {
                const allMemories = await db.episodicMemories
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                // 按重要性和时间排序，保留最重要和最新的记忆
                const memories = allMemories.sort((a, b) => {
                    // 先按重要性排序，再按时间排序
                    if (Math.abs(a.importance - b.importance) > 0.1) {
                        return b.importance - a.importance;
                    }
                    return b.timestamp - a.timestamp;
                });

                const maxEpisodicMemories = MEMORY_CONFIG.MAX_EPISODIC_MEMORIES_PER_CHARACTER || 100;

                if (memories.length > maxEpisodicMemories) {
                    const toDelete = memories.slice(maxEpisodicMemories);
                    for (const memory of toDelete) {
                        await db.episodicMemories.delete(memory.id);
                    }
                    console.log(`🧹 清理了 ${toDelete.length} 个旧的情景记忆`);
                }
            } catch (error) {
                console.error('清理情景记忆失败:', error);
            }
        }

        // 🔥【新增】自动清理过期的时间线记忆和记忆摘要
        async function cleanupExpiredMemories() {
            try {
                const memorySettings = getGlobalMemorySettings();
                const cutoffTimestamp = Date.now() - (memorySettings.memoryDays * 24 * 60 * 60 * 1000);
                const cutoffDateStr = new Date(cutoffTimestamp).toISOString().split('T')[0];

                // 清理过期的时间线记忆
                const expiredTimelineEvents = await db.crossAppTimeline
                    .where('timestamp')
                    .below(cutoffTimestamp)
                    .toArray();

                if (expiredTimelineEvents.length > 0) {
                    await db.crossAppTimeline
                        .where('timestamp')
                        .below(cutoffTimestamp)
                        .delete();
                    console.log(`🧹 清理了 ${expiredTimelineEvents.length} 条过期的时间线记忆`);
                }

                // 清理过期的记忆摘要
                const expiredSummaries = await db.memorySummaries
                    .where('date')
                    .below(cutoffDateStr)
                    .toArray();

                if (expiredSummaries.length > 0) {
                    await db.memorySummaries
                        .where('date')
                        .below(cutoffDateStr)
                        .delete();
                    console.log(`🧹 清理了 ${expiredSummaries.length} 条过期的记忆摘要`);
                }

                // 清理过期的情景记忆
                const expiredEpisodicMemories = await db.episodicMemories
                    .where('timestamp')
                    .below(cutoffTimestamp)
                    .toArray();

                if (expiredEpisodicMemories.length > 0) {
                    await db.episodicMemories
                        .where('timestamp')
                        .below(cutoffTimestamp)
                        .delete();
                    console.log(`🧹 清理了 ${expiredEpisodicMemories.length} 条过期的情景记忆`);
                }

            } catch (error) {
                console.error('清理过期记忆失败:', error);
            }
        }

        // 🔥【新增】定期清理过期记忆（每小时执行一次）
        setInterval(cleanupExpiredMemories, 60 * 60 * 1000); // 1小时

        // 页面加载时执行一次清理
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(cleanupExpiredMemories, 5000); // 延迟5秒执行，避免影响页面加载
        });

        // 获取角色的核心记忆用于对话
        async function getCoreMemoriesForChat(characterId, limit = 10) {
            try {
                const allMemories = await db.coreMemories
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                const memories = allMemories
                    .sort((a, b) => b.importance - a.importance)
                    .slice(0, limit);

                return memories.map(m => m.fact).join('\n');
            } catch (error) {
                console.error('获取核心记忆失败:', error);
                return '';
            }
        }

        // 🔥【新增】检查角色是否应该记录群聊记忆的函数
        async function shouldRecordGroupMemoryForCharacter(characterId, groupId) {
            try {
                // 获取该角色的单聊设置
                const characterChatSettings = await getAsyncChatSettings(characterId);
                const sharedGroupIds = characterChatSettings.memorySharedGroupIds || [];

                // 检查该群聊是否在角色的共享群聊列表中
                const shouldRecord = sharedGroupIds.includes(groupId);

                console.log(`🔍 记忆共享检查 - 角色: ${characterId}, 群聊: ${groupId}, 应记录: ${shouldRecord}`);
                console.log(`🔍 角色的共享群聊列表:`, sharedGroupIds);

                return shouldRecord;
            } catch (error) {
                console.warn('检查记忆共享设置失败:', error);
                // 出错时默认不记录，避免意外的记忆泄露
                return false;
            }
        }

        // 跨应用时间线记录功能
        async function recordCrossAppEvent(characterId, appType, action, context, messageId = null) {
            try {
                // 🔥【修复】验证必需参数
                if (!characterId || !appType || !action) {
                    console.error('❌ 记录事件失败: 缺少必需参数', {
                        characterId,
                        appType,
                        action
                    });
                    return;
                }

                // 🔥【修复】确保context是有效对象
                const validContext = context && typeof context === 'object' ? context : {};

                // 🔥【关键修复】生成更简单可靠的ID
                const timestamp = Date.now();
                const randomSuffix = Math.random().toString(36).substring(2, 8);
                const eventId = `${characterId}_${appType}_${action}_${timestamp}_${randomSuffix}`;

                const timelineEvent = {
                    id: eventId,
                    characterId: String(characterId), // 确保是字符串
                    appType: String(appType),
                    action: String(action),
                    timestamp: timestamp,
                    context: validContext,
                    messageId: messageId ? String(messageId) : null
                };

                // 🔥【修复】验证所有必需字段
                if (!timelineEvent.id || !timelineEvent.characterId || !timelineEvent.appType || !timelineEvent.action) {
                    console.error('❌ 记录事件失败: 必需字段缺失', timelineEvent);
                    return;
                }

                // 🔥【新增】验证数据库连接
                if (!db || !db.crossAppTimeline) {
                    console.error('❌ 记录事件失败: 数据库未初始化');
                    return;
                }

                await db.crossAppTimeline.add(timelineEvent);
                console.log(`📝 记录时间线事件: ${appType}.${action}`, {
                    characterId: timelineEvent.characterId,
                    contextId: validContext.id,
                    contextType: validContext.type,
                    groupId: validContext.groupId || '无',
                    content: validContext.content?.substring(0, 30) + '...'
                });

            } catch (error) {
                console.error('❌ 记录事件失败:', error);
                console.error('事件数据:', {characterId, appType, action, context, messageId});

                // 🔥【新增】详细错误信息
                if (error.name === 'DataError') {
                    console.error('数据库键值错误，可能是ID字段问题');
                } else if (error.name === 'ConstraintError') {
                    console.error('数据库约束错误，可能是重复键值');
                }
            }
        }

        // 获取角色的跨应用时间线（用于构建连续的工作记忆）
        async function getCrossAppTimeline(characterId, limit = 20) {
            try {
                const timeline = await db.crossAppTimeline
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                return timeline
                    .sort((a, b) => b.timestamp - a.timestamp)
                    .slice(0, limit);
            } catch (error) {
                console.error('获取跨应用时间线失败:', error);
                return [];
            }
        }

        // 🔥【新增】按回合计算历史消息
        function calculateMessagesByRounds(messages, maxRounds) {
            if (!messages || messages.length === 0) return [];

            // 从后往前分析消息，按回合分组
            const rounds = [];
            let currentRound = [];
            let lastSender = null;

            // 从最新消息开始往前分析
            for (let i = messages.length - 1; i >= 0; i--) {
                const msg = messages[i];
                const currentSender = msg.sender;

                // 如果发送者改变，或者是系统消息，开始新回合
                if (currentSender !== lastSender || currentSender === 'system') {
                    if (currentRound.length > 0) {
                        rounds.unshift(currentRound); // 添加到开头
                        currentRound = [];
                    }
                }

                currentRound.unshift(msg); // 添加到当前回合的开头
                lastSender = currentSender;

                // 如果已经收集了足够的回合，停止
                if (rounds.length >= maxRounds) {
                    break;
                }
            }

            // 添加最后一个回合
            if (currentRound.length > 0 && rounds.length < maxRounds) {
                rounds.unshift(currentRound);
            }

            // 只保留指定数量的回合
            const selectedRounds = rounds.slice(-maxRounds);

            // 将回合展平为消息列表
            return selectedRounds.flat();
        }

        // 🔥【新增】计算实际回合数
        function countActualRounds(messages) {
            if (!messages || messages.length === 0) return 0;

            let rounds = 0;
            let lastSender = null;

            for (const msg of messages) {
                const currentSender = msg.sender;

                // 如果发送者改变，或者是系统消息，计为新回合
                if (currentSender !== lastSender || currentSender === 'system') {
                    rounds++;
                }

                lastSender = currentSender;
            }

            return rounds;
        }

        // 🔥【新增】查看线下剧情总结的完整内容
        async function viewStorylineSummary(memoryId) {
            try {
                const memory = await db.crossAppTimeline.get(memoryId);
                if (!memory || memory.action !== 'storyline_summary') {
                    showToast('找不到该剧情总结', 'error');
                    return;
                }

                // 使用完整内容而不是预览内容
                const content = memory.context?.content || memory.fullContent || '无内容';
                const date = memory.context?.date || '未知日期';
                const messageCount = memory.context?.messageCount || 0;

                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 600px; max-height: 80vh; overflow-y: auto;">
                        <div class="modal-header">
                            <h3>线下剧情总结</h3>
                            <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">×</button>
                        </div>
                        <div class="modal-body">
                            <div style="margin-bottom: 15px; color: #666; font-size: 14px;">
                                <div>日期: ${date}</div>
                                <div>消息数: ${messageCount}条</div>
                            </div>
                            <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; line-height: 1.6; white-space: pre-wrap;">${content}</div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-primary" onclick="editStorylineSummary('${memoryId}'); this.closest('.modal-overlay').remove();">编辑</button>
                            <button class="btn btn-secondary" onclick="this.closest('.modal-overlay').remove()">关闭</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);
            } catch (error) {
                console.error('查看剧情总结失败:', error);
                showToast('查看剧情总结失败', 'error');
            }
        }

        // 🔥【新增】编辑线下剧情总结
        async function editStorylineSummary(memoryId) {
            try {
                const memory = await db.crossAppTimeline.get(memoryId);
                if (!memory || memory.action !== 'storyline_summary') {
                    showToast('找不到该剧情总结', 'error');
                    return;
                }

                // 使用完整内容而不是预览内容
                const content = memory.context?.content || memory.fullContent || '';
                const date = memory.context?.date || '未知日期';
                const messageCount = memory.context?.messageCount || 0;

                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 700px; max-height: 80vh;">
                        <div class="modal-header">
                            <h3>编辑线下剧情总结</h3>
                            <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">×</button>
                        </div>
                        <div class="modal-body">
                            <div style="margin-bottom: 15px; color: #666; font-size: 14px;">
                                <div>日期: ${date}</div>
                                <div>消息数: ${messageCount}条</div>
                                <div style="color: #999; font-size: 12px; margin-top: 5px;">提示: 修改后的内容将同步到AI的工作记忆中</div>
                            </div>
                            <textarea id="storyline-summary-editor" style="width: 100%; height: 300px; padding: 15px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px; line-height: 1.6; resize: vertical;" placeholder="请输入剧情总结...">${content}</textarea>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-primary" onclick="saveStorylineSummary('${memoryId}')">保存修改</button>
                            <button class="btn btn-secondary" onclick="this.closest('.modal-overlay').remove()">取消</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);

                // 聚焦到文本框但不选中内容
                setTimeout(() => {
                    const textarea = document.getElementById('storyline-summary-editor');
                    if (textarea) {
                        textarea.focus();
                        // 🔥【修复】将光标移到末尾，不选中任何内容
                        textarea.setSelectionRange(textarea.value.length, textarea.value.length);
                    }
                }, 100);
            } catch (error) {
                console.error('编辑剧情总结失败:', error);
                showToast('编辑剧情总结失败', 'error');
            }
        }

        // 🔥【新增】保存编辑后的线下剧情总结
        async function saveStorylineSummary(memoryId) {
            try {
                const textarea = document.getElementById('storyline-summary-editor');
                if (!textarea) {
                    showToast('找不到编辑器', 'error');
                    return;
                }

                const newContent = textarea.value.trim();
                if (!newContent) {
                    showToast('剧情总结不能为空', 'warning');
                    return;
                }

                // 更新数据库中的记忆
                const memory = await db.crossAppTimeline.get(memoryId);
                if (!memory) {
                    showToast('找不到该剧情总结', 'error');
                    return;
                }

                // 更新内容
                memory.context.content = newContent;
                memory.timestamp = Date.now(); // 更新时间戳，让它在工作记忆中更新

                await db.crossAppTimeline.put(memory);

                // 关闭模态框
                const modal = textarea.closest('.modal-overlay');
                if (modal) {
                    modal.remove();
                }

                // 刷新记忆查看器
                if (currentMemoryCharacter) {
                    await loadCharacterMemories();
                }

                showToast('剧情总结已保存，AI工作记忆已同步更新', 'success');
                console.log('✅ 线下剧情总结已更新:', memory);
            } catch (error) {
                console.error('保存剧情总结失败:', error);
                showToast('保存剧情总结失败', 'error');
            }
        }

        // 构建连续的工作记忆（包含跨应用事件，按时间滚动）
        async function buildContinuousWorkingMemory(characterId, chatMessages, userSetLimit = 50) {
            try {
                // 🔥【安全检查】确保chatMessages是数组
                if (!Array.isArray(chatMessages)) {
                    console.warn('buildContinuousWorkingMemory: chatMessages不是数组，使用空数组');
                    chatMessages = [];
                }

                // 获取聊天消息
                const messages = chatMessages.map(msg => ({
                    type: 'chat',
                    timestamp: msg.timestamp,
                    content: msg,
                    appType: 'chat',
                    characterId: characterId // 确保角色隔离
                }));

                // 获取该角色的跨应用时间线（只获取与该角色相关的）
                const timeline = await db.crossAppTimeline
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                // 🔥【修复】正确区分聊天事件和跨应用事件
                const timelineEvents = timeline
                    .filter(event => event.appType !== 'chat') // 排除聊天事件，避免重复
                    .map(event => ({
                        type: 'cross_app',
                        timestamp: event.timestamp,
                        content: event,
                        appType: event.appType,
                        characterId: characterId
                    }));

                // 合并所有事件并按时间排序
                const allEvents = [...messages, ...timelineEvents]
                    .sort((a, b) => a.timestamp - b.timestamp);

                // 🔥【修复】按回合数而不是消息条数来限制工作记忆
                // 先提取聊天消息，按回合计算
                const chatEvents = allEvents.filter(event => event.type === 'chat');
                const extractedChatMessages = chatEvents.map(event => event.content);

                // 按回合计算聊天消息
                const recentChatMessages = calculateMessagesByRounds(extractedChatMessages, userSetLimit);

                // 重新包装为事件格式
                const recentChatEvents = recentChatMessages.map(msg => ({
                    type: 'chat',
                    timestamp: msg.timestamp,
                    content: msg,
                    appType: 'chat',
                    characterId: characterId
                }));

                // 跨应用事件按时间范围过滤（与聊天消息的时间范围一致）
                const earliestChatTime = recentChatEvents.length > 0 ? recentChatEvents[0].timestamp : 0;
                const recentTimelineEvents = timelineEvents.filter(event => event.timestamp >= earliestChatTime);

                // 合并并重新排序
                const recentEvents = [...recentChatEvents, ...recentTimelineEvents]
                    .sort((a, b) => a.timestamp - b.timestamp);

                return recentEvents;
            } catch (error) {
                console.error('构建连续工作记忆失败:', error);
                return chatMessages.map(msg => ({
                    type: 'chat',
                    timestamp: msg.timestamp,
                    content: msg,
                    appType: 'chat',
                    characterId: characterId
                }));
            }
        }

        // 为角色生成跨应用记忆描述
        async function generateCrossAppMemoryDescription(characterId, memoryEvent) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;

                let memoryDescription = '';
                const context = memoryEvent.context;

                switch (memoryEvent.eventType) {
                    case 'music_interaction':
                        if (context.action === 'listen_together') {
                            memoryDescription = `和用户一起听了《${context.songTitle}》，${context.duration || ''}`;
                        } else if (context.action === 'song_comment') {
                            memoryDescription = `对歌曲《${context.songTitle}》发表了看法：${context.comment}`;
                        }
                        break;

                    case 'game_interaction':
                        if (context.action === 'play_together') {
                            memoryDescription = `和用户一起玩了${context.gameName}，${context.result || ''}`;
                        } else if (context.action === 'game_comment') {
                            memoryDescription = `对游戏${context.gameName}发表了看法：${context.comment}`;
                        }
                        break;

                    case 'forum_interaction':
                        if (context.action === 'post_comment') {
                            memoryDescription = `在论坛发表了评论：${context.comment}`;
                        } else if (context.action === 'topic_discussion') {
                            memoryDescription = `参与了关于"${context.topic}"的讨论`;
                        }
                        break;
                }

                if (memoryDescription) {
                    // 将跨应用记忆作为核心记忆保存
                    const coreMemory = {
                        id: `cross_${characterId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                        characterId: characterId,
                        fact: memoryDescription,
                        importance: 0.6, // 跨应用记忆的默认重要性
                        category: 'cross_app',
                        timestamp: Date.now(),
                        sourceEvent: memoryEvent.id
                    };

                    await db.coreMemories.add(coreMemory);
                    console.log(`✅ 为角色 ${character.name} 添加跨应用记忆: ${memoryDescription}`);
                }

            } catch (error) {
                console.error('生成跨应用记忆描述失败:', error);
            }
        }

        // 获取角色的跨应用记忆
        async function getCrossAppMemories(characterId, limit = 5) {
            try {
                const allMemories = await db.coreMemories
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                const crossAppMemories = allMemories
                    .filter(memory => memory.category === 'cross_app')
                    .sort((a, b) => b.timestamp - a.timestamp)
                    .slice(0, limit);

                return crossAppMemories.map(m => m.fact);
            } catch (error) {
                console.error('获取跨应用记忆失败:', error);
                return [];
            }
        }

        // 清理重复记忆的功能
        async function cleanupDuplicateMemories(characterId) {
            try {
                const memories = await db.coreMemories
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                const duplicates = [];

                for (let i = 0; i < memories.length; i++) {
                    for (let j = i + 1; j < memories.length; j++) {
                        const similarity = calculateTextSimilarity(memories[i].fact, memories[j].fact);
                        if (similarity > 0.8) {
                            // 保留重要性更高的，删除重要性较低的
                            const toDelete = memories[i].importance >= memories[j].importance ? memories[j] : memories[i];
                            if (!duplicates.find(d => d.id === toDelete.id)) {
                                duplicates.push(toDelete);
                            }
                        }
                    }
                }

                for (const duplicate of duplicates) {
                    await db.coreMemories.delete(duplicate.id);
                    console.log(`🧹 删除重复记忆: ${duplicate.fact}`);
                }

                if (duplicates.length > 0) {
                    console.log(`✅ 清理了 ${duplicates.length} 条重复记忆`);
                }
            } catch (error) {
                console.error('清理重复记忆失败:', error);
            }
        }

        // 🔥【新增】清理错误的跨应用时间线记录
        async function cleanupIncorrectTimelineRecords() {
            try {
                console.log('🧹 开始清理错误的跨应用时间线记录...');

                // 删除所有 appType 为 'chat' 的记录（这些应该只存在于聊天记录中）
                const chatRecords = await db.crossAppTimeline
                    .where('appType')
                    .equals('chat')
                    .toArray();

                for (const record of chatRecords) {
                    await db.crossAppTimeline.delete(record.id);
                }

                console.log(`✅ 清理完成，删除了 ${chatRecords.length} 条错误的聊天记录`);
                return chatRecords.length;

            } catch (error) {
                console.error('清理错误记录失败:', error);
                return 0;
            }
        }

        // 🔍【新增】记忆使用情况统计函数
        async function logMemoryUsageStats(character, scenario) {
            try {
                const characterId = character.isGroup ? 'group' : character.id;
                const memorySettings = getGlobalMemorySettings();

                console.log(`\n📊 ===== 记忆使用统计 (${scenario}) =====`);
                console.log(`🎭 角色: ${character.name} (${character.isGroup ? '群聊' : '单聊'})`);
                console.log(`⏰ 记忆天数设置: ${memorySettings.memoryDays}天`);

                if (character.isGroup) {
                    // 群聊：统计每个成员的记忆
                    for (const member of character.members) {
                        await logSingleCharacterMemoryStats(member.id, member.name, memorySettings.memoryDays);
                    }
                } else {
                    // 单聊：统计单个角色的记忆
                    await logSingleCharacterMemoryStats(character.id, character.name, memorySettings.memoryDays);
                }

                console.log(`📊 ===== 记忆统计结束 =====\n`);

            } catch (error) {
                console.error('记忆统计失败:', error);
            }
        }

        // 🔍【新增】单个角色的记忆统计
        async function logSingleCharacterMemoryStats(characterId, characterName, memoryDays) {
            try {
                // 1. 核心记忆统计
                const coreMemories = await db.coreMemories
                    .where('characterId')
                    .equals(characterId)
                    .toArray();
                const limitedCoreMemories = coreMemories.slice(0, 10);

                // 2. 情景记忆统计
                const cutoffTimestamp = Date.now() - (memoryDays * 24 * 60 * 60 * 1000);
                const episodicMemories = await db.episodicMemories
                    .where('characterId')
                    .equals(characterId)
                    .and(memory => memory.timestamp >= cutoffTimestamp)
                    .toArray();
                const limitedEpisodicMemories = episodicMemories.slice(0, 15);

                // 3. 时间线记忆统计
                const timelineMemories = await db.crossAppTimeline
                    .where('characterId')
                    .equals(characterId)
                    .and(event => event.timestamp >= cutoffTimestamp)
                    .toArray();
                const limitedTimelineMemories = timelineMemories.slice(0, 20);

                // 4. 对话摘要统计
                const cutoffDateStr = new Date(cutoffTimestamp).toISOString().split('T')[0];
                const memorySummaries = await db.memorySummaries
                    .where('characterId')
                    .equals(characterId)
                    .and(summary => summary.date >= cutoffDateStr)
                    .toArray();
                const limitedMemorySummaries = memorySummaries.slice(0, 10);

                // 5. 计算总token估算（按每个中文字符1.5token计算）
                const coreMemoryTokens = limitedCoreMemories.reduce((sum, m) => sum + (m.fact?.length || 0), 0) * 1.5;
                const episodicMemoryTokens = limitedEpisodicMemories.reduce((sum, m) => sum + (m.fact?.length || 0), 0) * 1.5;
                const timelineMemoryTokens = limitedTimelineMemories.reduce((sum, m) => sum + (m.context?.content?.length || 0), 0) * 1.5;
                const summaryMemoryTokens = limitedMemorySummaries.reduce((sum, m) => sum + (m.summary?.length || 0), 0) * 1.5;
                const totalMemoryTokens = coreMemoryTokens + episodicMemoryTokens + timelineMemoryTokens + summaryMemoryTokens;

                console.log(`\n👤 ${characterName} (ID: ${characterId}):`);
                console.log(`  🔴 核心记忆: ${limitedCoreMemories.length}条 (总库存: ${coreMemories.length}条) ~${Math.round(coreMemoryTokens)}tokens`);
                console.log(`  🟠 情景记忆: ${limitedEpisodicMemories.length}条 (总库存: ${episodicMemories.length}条) ~${Math.round(episodicMemoryTokens)}tokens`);
                console.log(`  🟣 时间线记忆: ${limitedTimelineMemories.length}条 (总库存: ${timelineMemories.length}条) ~${Math.round(timelineMemoryTokens)}tokens`);
                console.log(`  🔵 对话摘要: ${limitedMemorySummaries.length}条 (总库存: ${memorySummaries.length}条) ~${Math.round(summaryMemoryTokens)}tokens`);
                console.log(`  💰 记忆总消耗: ~${Math.round(totalMemoryTokens)}tokens`);

                // 6. 检查是否算在工作记忆中
                // 7. 检查跨应用工作记忆集成
                const userHistoryLimit = getCurrentChatSettings().historyCount || 5;
                const crossAppInWorkingMemory = Math.floor(userHistoryLimit * 0.3);
                const chatInWorkingMemory = userHistoryLimit - crossAppInWorkingMemory;

                console.log(`  ⚠️  注意: 这些记忆是额外添加的，不占用用户设置的"附带历史消息数"配额`);
                console.log(`  📝 工作记忆构成:`);
                console.log(`    - 聊天历史: ${chatInWorkingMemory}条 (用户设置: ${userHistoryLimit}条)`);
                console.log(`    - 跨应用事件: ${crossAppInWorkingMemory}条 (自动集成)`);
                console.log(`    - 总工作记忆: ${userHistoryLimit}条 (按时间顺序滚动)`);

            } catch (error) {
                console.error(`统计角色 ${characterName} 记忆失败:`, error);
            }
        }

        // 🔥【新增】删除与消息相关的时间线记录
        async function deleteRelatedTimelineEvents(messageToDelete) {
            try {
                const characterId = currentChatCharacter.id;
                const messageContent = messageToDelete.content;
                const messageTimestamp = messageToDelete.timestamp;

                // 查找相关的时间线记录（基于内容和时间戳匹配）
                const relatedEvents = await db.crossAppTimeline
                    .where('characterId')
                    .equals(characterId)
                    .and(event => {
                        // 检查时间戳是否接近（允许5分钟误差）
                        const timeDiff = Math.abs(event.timestamp - messageTimestamp);
                        const isTimeMatch = timeDiff < 5 * 60 * 1000; // 5分钟

                        // 检查内容是否匹配
                        const isContentMatch = event.context &&
                                             event.context.content &&
                                             event.context.content.includes(messageContent.substring(0, 30));

                        return isTimeMatch && isContentMatch;
                    })
                    .toArray();

                // 删除匹配的时间线记录
                for (const event of relatedEvents) {
                    await db.crossAppTimeline.delete(event.id);
                    console.log(`🗑️ 删除相关时间线记录: ${event.action} - ${event.context?.content?.substring(0, 50)}...`);
                }

                console.log(`✅ 删除了 ${relatedEvents.length} 条相关时间线记录`);

            } catch (error) {
                console.error('删除相关时间线记录失败:', error);
            }
        }

        // 🔥【新增】清理低质量旧版本记忆的函数
        async function cleanupLowQualityMemories(characterId) {
            try {
                console.log(`🧹 开始清理角色 ${characterId} 的低质量旧版本记忆...`);

                const currentThreshold = MEMORY_CONFIG.CORE_MEMORY_IMPORTANCE_THRESHOLD;

                // 清理重要性低于当前阈值的核心记忆
                const lowQualityCoreMemories = await db.coreMemories
                    .where('characterId')
                    .equals(characterId)
                    .and(memory => (memory.importance || 0) < currentThreshold)
                    .toArray();

                for (const memory of lowQualityCoreMemories) {
                    await db.coreMemories.delete(memory.id);
                    console.log(`🗑️ 删除低质量核心记忆 (重要性: ${memory.importance}): ${memory.fact}`);
                }

                console.log(`✅ 清理完成，删除了 ${lowQualityCoreMemories.length} 条低质量核心记忆`);
                return lowQualityCoreMemories.length;

            } catch (error) {
                console.error('清理低质量记忆失败:', error);
                return 0;
            }
        }

        // 记忆查看器功能
        let currentMemoryFilter = 'all';
        let currentMemoryCharacter = null;
        let allMemories = [];

        // 初始化记忆查看器
        async function initMemoryViewer() {
            await loadCharacterSelectOptions();
        }

        // 加载角色选择选项
        async function loadCharacterSelectOptions() {
            const select = document.getElementById('memory-character-select');
            if (!select) return;

            // 清空现有选项
            select.innerHTML = '<option value="">请选择角色</option>';

            // 添加角色选项
            characters.forEach(character => {
                const option = document.createElement('option');
                option.value = character.id;
                option.textContent = character.name;
                select.appendChild(option);
            });
        }

        // 加载角色记忆
        async function loadCharacterMemories() {
            const select = document.getElementById('memory-character-select');
            const characterId = select.value;

            if (!characterId) {
                currentMemoryCharacter = null;
                allMemories = [];
                renderMemoryList();
                return;
            }

            currentMemoryCharacter = characterId;

            try {
                // 获取所有类型的记忆
                const [coreMemories, episodicMemories, timeline] = await Promise.all([
                    db.coreMemories.where('characterId').equals(characterId).toArray(),
                    db.episodicMemories.where('characterId').equals(characterId).toArray(),
                    db.crossAppTimeline.where('characterId').equals(characterId).toArray()
                ]);

                // 🔥【调试】输出时间线记录信息
                console.log(`📊 角色 ${characterId} 的时间线记录:`, timeline.length, '条');
                timeline.forEach((event, index) => {
                    if (index < 5) { // 只显示前5条
                        console.log(`  ${index + 1}. ${event.appType}.${event.action} - contextId: ${event.context?.id}, type: ${event.context?.type}, groupId: ${event.context?.groupId || '无'}`);
                    }
                });

                // 🔥【新增】获取线下剧情总结
                const storylineSummaries = await db.crossAppTimeline
                    .where('characterId')
                    .equals(characterId)
                    .and(item => item.action === 'storyline_summary' && item.appType === 'offline_mode')
                    .toArray();

                console.log(`📖 线下剧情总结: ${storylineSummaries.length}条`);

                // 合并所有记忆并添加类型标识
                allMemories = [
                    ...coreMemories.filter(m => m.type === 'core').map(m => ({...m, memoryType: 'core'})),
                    ...episodicMemories.map(m => ({...m, memoryType: 'episodic'})),
                    ...timeline.map(m => ({
                        ...m,
                        memoryType: 'timeline',
                        fact: formatTimelineEvent(m)
                    })),
                    // 🔥【新增】添加线下剧情总结
                    ...storylineSummaries.map(m => {
                        const fullContent = m.context?.content || '线下剧情总结';
                        // 只显示前三行作为预览
                        const lines = fullContent.split('\n');
                        const preview = lines.slice(0, 3).join('\n') + (lines.length > 3 ? '\n...' : '');

                        return {
                            ...m,
                            memoryType: 'storyline',
                            fact: preview,
                            summary: preview,
                            fullContent: fullContent // 保存完整内容用于编辑
                        };
                    })
                ];

                // 按时间戳排序（最新的在前）
                allMemories.sort((a, b) => b.timestamp - a.timestamp);

                renderMemoryList();
            } catch (error) {
                console.error('加载角色记忆失败:', error);
                showToast('加载记忆失败', 'error');
            }
        }

        // 切换记忆过滤器
        function switchMemoryFilter(type) {
            currentMemoryFilter = type;

            // 更新标签样式
            document.querySelectorAll('.memory-filter-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`[data-type="${type}"]`).classList.add('active');

            renderMemoryList();
        }

        // 过滤记忆
        function filterMemories() {
            renderMemoryList();
        }

        // 渲染记忆列表
        function renderMemoryList() {
            const container = document.getElementById('memory-list');
            if (!container) return;

            if (!currentMemoryCharacter || allMemories.length === 0) {
                container.innerHTML = `
                    <div class="memory-empty-state">
                        <i class="fas fa-brain"></i>
                        <p>${currentMemoryCharacter ? '该角色暂无记忆数据' : '请选择角色查看记忆'}</p>
                    </div>
                `;
                return;
            }

            // 获取搜索关键词
            const searchTerm = document.getElementById('memory-search-input').value.toLowerCase();

            // 过滤记忆
            let filteredMemories = allMemories;

            // 按类型过滤
            if (currentMemoryFilter !== 'all') {
                filteredMemories = filteredMemories.filter(memory => memory.memoryType === currentMemoryFilter);
            }

            // 按搜索词过滤
            if (searchTerm) {
                filteredMemories = filteredMemories.filter(memory => {
                    const content = memory.fact || memory.summary || '';
                    return content.toLowerCase().includes(searchTerm);
                });
            }

            if (filteredMemories.length === 0) {
                container.innerHTML = `
                    <div class="memory-empty-state">
                        <i class="fas fa-search"></i>
                        <p>没有找到匹配的记忆</p>
                    </div>
                `;
                return;
            }

            // 渲染记忆项
            const html = filteredMemories.map(memory => renderMemoryItem(memory)).join('');
            container.innerHTML = html;
        }

        // 渲染单个记忆项
        function renderMemoryItem(memory) {
            const dateObj = new Date(memory.timestamp || Date.now());
            const date = isNaN(dateObj.getTime()) ? '未知日期' : dateObj.toLocaleDateString('zh-CN');
            const content = memory.fact || memory.summary || '';
            const importance = memory.importance || 0;
            const stars = '★'.repeat(Math.round(importance * 5));

            const typeLabels = {
                'core': '核心记忆',
                'episodic': '情景记忆',
                'storyline': '剧情总结',
                'timeline': '时间线'
            };

            return `
                <div class="memory-item" data-memory-id="${memory.id}">
                    <div class="memory-item-header">
                        <span class="memory-item-type ${memory.memoryType}">
                            <i class="fas fa-${getMemoryTypeIcon(memory.memoryType)}"></i>
                            ${typeLabels[memory.memoryType]}
                        </span>
                        <span class="memory-item-date">${date}</span>
                    </div>
                    <div class="memory-item-content">${content}</div>
                    ${memory.memoryType === 'core' || memory.memoryType === 'episodic' ? `
                        <div class="memory-item-importance">
                            <span>重要性:</span>
                            <span class="importance-stars">${stars}</span>
                            <span>(${(importance * 100).toFixed(0)}%)</span>
                        </div>
                    ` : ''}
                    <div class="memory-item-actions">
                        ${memory.memoryType === 'storyline' ? `
                            <button class="memory-action-btn view-btn" onclick="viewStorylineSummary('${memory.id}')" title="查看完整内容">
                                <i class="fas fa-eye"></i> 查看
                            </button>
                            <button class="memory-action-btn edit-btn" onclick="editStorylineSummary('${memory.id}')" title="编辑剧情总结">
                                <i class="fas fa-edit"></i> 编辑
                            </button>
                        ` : `
                            <button class="memory-action-btn" onclick="editMemory('${memory.id}', '${memory.memoryType}')">
                                <i class="fas fa-edit"></i> 编辑
                            </button>
                        `}
                        <button class="memory-action-btn delete" onclick="deleteMemory('${memory.id}', '${memory.memoryType}')">
                            <i class="fas fa-trash"></i> 删除
                        </button>
                    </div>
                </div>
            `;
        }

        // 获取记忆类型图标
        function getMemoryTypeIcon(type) {
            const icons = {
                'core': 'star',
                'episodic': 'calendar-day',
                'storyline': 'book',
                'timeline': 'clock'
            };
            return icons[type] || 'circle';
        }

        // 🔥【重新设计】格式化时间线事件显示 - 简化版本，避免显示不完整内容
        function formatTimelineEvent(event) {
            const appNames = {
                'chat': '聊天',
                'music': '音乐',
                'moments': '动态',
                'diary': '日记'
            };

            const appName = appNames[event.appType] || event.appType;
            let description = '';

            try {
                const context = typeof event.context === 'string' ? JSON.parse(event.context) : event.context;

                switch (event.appType) {
                    case 'chat':
                        const chatType = context?.type === 'group_chat' ? '群聊' : '单聊';
                        const groupName = context?.groupName ? `(${context.groupName})` : '';

                        if (event.action === 'ai_reply') {
                            description = `在${chatType}${groupName}中回复了消息`;
                        } else if (event.action === 'user_message') {
                            description = `在${chatType}${groupName}中收到用户消息`;
                        } else {
                            description = `在${chatType}${groupName}中进行了聊天互动`;
                        }
                        break;
                    case 'music':
                        if (context.action === 'listen_together') {
                            description = `与用户一起听歌：${context.songTitle || context.song || ''}`;
                        } else if (context.action === 'song_comment') {
                            description = `对音乐发表了评论`;
                        } else {
                            description = `进行了音乐互动`;
                        }
                        break;
                    case 'moments':
                        if (event.action === 'ai_to_ai_reply') {
                            description = `在动态中回复了其他角色`;
                        } else if (event.action === 'reply_to_user') {
                            description = `在动态中回复了用户`;
                        } else {
                            description = `进行了动态互动`;
                        }
                        break;
                    case 'diary':
                        description = `写了日记`;
                        break;
                    default:
                        description = `进行了${event.action || '未知'}活动`;
                }
            } catch (e) {
                description = `进行了${event.action || '未知'}活动`;
            }

            return `【${appName}】${description}`;
        }

        // 刷新记忆数据
        async function refreshMemoryData() {
            if (currentMemoryCharacter) {
                await loadCharacterMemories();
                showToast('记忆数据已刷新', 'success');
            }
        }



        // 🔥【新增】清理错误的记录
        async function cleanupIncorrectRecords() {
            if (!confirm('确定要清理错误的记录吗？这将删除跨应用时间线中错误的聊天记录。')) {
                return;
            }

            try {
                const deletedCount = await cleanupIncorrectTimelineRecords();
                await loadCharacterMemories();
                showToast(`错误记录清理完成，删除了${deletedCount}条错误记录`, 'success');
            } catch (error) {
                console.error('清理错误记录失败:', error);
                showToast('清理失败', 'error');
            }
        }

        // 🔥【新增】清理重复的时间线事件
        async function cleanupDuplicateTimelineEvents(characterId) {
            try {
                console.log(`🧹 开始清理角色 ${characterId} 的重复时间线记录...`);

                const timelineEvents = await db.crossAppTimeline
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                const duplicates = [];
                const seenContents = new Map(); // 内容 -> 第一个事件

                for (const event of timelineEvents) {
                    const content = event.context?.content;
                    if (content) {
                        const normalizedContent = content.toLowerCase().trim();
                        if (seenContents.has(normalizedContent)) {
                            // 发现重复，保留时间戳较早的
                            const existingEvent = seenContents.get(normalizedContent);
                            if (event.timestamp > existingEvent.timestamp) {
                                duplicates.push(event);
                            } else {
                                duplicates.push(existingEvent);
                                seenContents.set(normalizedContent, event);
                            }
                        } else {
                            seenContents.set(normalizedContent, event);
                        }
                    }
                }

                // 删除重复的时间线记录
                for (const duplicate of duplicates) {
                    await db.crossAppTimeline.delete(duplicate.id);
                    console.log(`🗑️ 删除重复时间线记录: ${duplicate.action} - ${duplicate.context?.content?.substring(0, 50)}...`);
                }

                console.log(`✅ 清理完成，删除了 ${duplicates.length} 条重复时间线记录`);
                return duplicates.length;

            } catch (error) {
                console.error('清理重复时间线记录失败:', error);
                return 0;
            }
        }

        // 显示记忆设置
        function showMemorySettings() {
            // 加载当前设置
            document.getElementById('aiExtractInterval').value = MEMORY_CONFIG.AI_EXTRACT_INTERVAL / 2; // 转换为回合数
            document.getElementById('coreMemoryThreshold').value = MEMORY_CONFIG.CORE_MEMORY_IMPORTANCE_THRESHOLD;
            document.getElementById('episodicMemoryThreshold').value = MEMORY_CONFIG.EPISODIC_MEMORY_IMPORTANCE_THRESHOLD;

            // 更新显示值
            updateThresholdDisplay();

            // 显示模态框
            document.getElementById('memorySettingsModal').style.display = 'flex';
        }

        // 关闭记忆设置
        function closeMemorySettings() {
            document.getElementById('memorySettingsModal').style.display = 'none';
        }

        // 更新阈值显示
        function updateThresholdDisplay() {
            const coreThreshold = document.getElementById('coreMemoryThreshold').value;
            const episodicThreshold = document.getElementById('episodicMemoryThreshold').value;

            document.getElementById('coreThresholdValue').textContent = Math.round(coreThreshold * 100) + '%';
            document.getElementById('episodicThresholdValue').textContent = Math.round(episodicThreshold * 100) + '%';
        }

        // 保存记忆设置
        async function saveMemorySettings() {
            try {
                const aiInterval = parseInt(document.getElementById('aiExtractInterval').value);
                const coreThreshold = parseFloat(document.getElementById('coreMemoryThreshold').value);
                const episodicThreshold = parseFloat(document.getElementById('episodicMemoryThreshold').value);

                // 更新配置
                MEMORY_CONFIG.AI_EXTRACT_INTERVAL = aiInterval * 2; // 转换为消息数
                MEMORY_CONFIG.CORE_MEMORY_IMPORTANCE_THRESHOLD = coreThreshold;
                MEMORY_CONFIG.EPISODIC_MEMORY_IMPORTANCE_THRESHOLD = episodicThreshold;

                // 保存到数据库
                await saveMemoryConfig();

                closeMemorySettings();
                showToast('记忆设置已保存', 'success');
            } catch (error) {
                console.error('保存记忆设置失败:', error);
                showToast('保存失败', 'error');
            }
        }

        // 编辑记忆
        async function editMemory(memoryId, memoryType) {
            try {
                // 🔥【修复】时间线记忆不允许编辑
                if (memoryType === 'timeline') {
                    showToast('时间线记忆是自动记录的活动日志，不支持编辑', 'warning');
                    return;
                }

                let memory;
                if (memoryType === 'summary') {
                    memory = await db.memorySummaries.get(memoryId);
                } else if (memoryType === 'core') {
                    memory = await db.coreMemories.get(memoryId);
                } else {
                    showToast('不支持的记忆类型', 'error');
                    return;
                }

                if (!memory) {
                    showToast('记忆不存在', 'error');
                    return;
                }

                const content = memory.fact || memory.summary || '';
                const newContent = await showCustomPrompt('编辑记忆', '请输入新的记忆内容', content);

                if (newContent && newContent.trim() && newContent !== content) {
                    if (memoryType === 'summary') {
                        memory.summary = newContent.trim();
                        await db.memorySummaries.put(memory);
                    } else {
                        memory.fact = newContent.trim();
                        await db.coreMemories.put(memory);
                    }

                    await loadCharacterMemories();
                    showToast('记忆已更新', 'success');
                }
            } catch (error) {
                console.error('编辑记忆失败:', error);
                showToast('编辑记忆失败', 'error');
            }
        }

        // 删除记忆
        async function deleteMemory(memoryId, memoryType) {
            // 🔥【修复】时间线记忆删除确认
            let confirmMessage = '确定要删除这条记忆吗？此操作不可撤销。';
            if (memoryType === 'timeline') {
                confirmMessage = '确定要删除这条时间线记录吗？这是自动记录的活动日志，删除后无法恢复。';
            }

            if (!confirm(confirmMessage)) {
                return;
            }

            try {
                if (memoryType === 'summary') {
                    await db.memorySummaries.delete(memoryId);
                } else if (memoryType === 'core') {
                    await db.coreMemories.delete(memoryId);
                } else if (memoryType === 'episodic') {
                    await db.episodicMemories.delete(memoryId);
                } else if (memoryType === 'timeline') {
                    await db.crossAppTimeline.delete(memoryId);
                } else {
                    showToast('不支持的记忆类型', 'error');
                    return;
                }

                await loadCharacterMemories();
                showToast('记忆已删除', 'success');
            } catch (error) {
                console.error('删除记忆失败:', error);
                showToast('删除记忆失败', 'error');
            }
        }

        // AI心率管理功能
        let heartrateInterval = null;
        let currentHeartrate = 72; // 基础心率

        function updateAiHeartrate() {
            const heartrateDisplay = document.getElementById('ai-heartrate-display');
            if (!heartrateDisplay) return;
            
            const chatSettings = getCurrentChatSettings();
            
            // 检查是否启用心率监测且不是群聊
            if (!chatSettings.aiHeartrateEnabled || (currentChatCharacter && currentChatCharacter.isGroup)) {
                hideAiHeartrate();
                return;
            }
            
            // 显示心率
            heartrateDisplay.style.display = 'block';
            
            // 计算基础心率（基于角色人设）
            const persona = (currentChatCharacter.bio || '').toLowerCase();
            const name = (currentChatCharacter.name || '').toLowerCase();
            let baseHeartrate = 72;
            
            // 根据角色特征调整基础心率
            if (persona.includes('紧张') || persona.includes('害羞') || persona.includes('敏感') || 
                persona.includes('羞涩') || persona.includes('容易脸红') || persona.includes('内向')) {
                baseHeartrate = 85; // 容易紧张的角色心率更高
            } else if (persona.includes('冷静') || persona.includes('理性') || persona.includes('成熟') || 
                       persona.includes('沉稳') || persona.includes('内敛') || persona.includes('严肃')) {
                baseHeartrate = 65; // 冷静的角色心率更低
            } else if (persona.includes('活泼') || persona.includes('兴奋') || persona.includes('热情') || 
                       persona.includes('开朗') || persona.includes('外向') || persona.includes('爱笑')) {
                baseHeartrate = 82; // 活泼的角色心率偏高
            } else if (persona.includes('运动') || persona.includes('健身') || persona.includes('体育') || 
                       persona.includes('运动员') || persona.includes('活跃')) {
                baseHeartrate = 58; // 运动型角色心率最低
            } else if (persona.includes('温柔') || persona.includes('甜美') || persona.includes('可爱') || 
                       persona.includes('软萌') || persona.includes('小鸟依人') || persona.includes('乖巧')) {
                baseHeartrate = 75; // 温柔型角色心率适中偏高
            } else if (persona.includes('冷酷') || persona.includes('高冷') || persona.includes('傲娇') || 
                       persona.includes('女王') || persona.includes('强势') || persona.includes('霸道')) {
                baseHeartrate = 68; // 高冷型角色心率偏低
            } else if (persona.includes('热血') || persona.includes('冲动') || persona.includes('急性子') || 
                       persona.includes('火爆') || persona.includes('暴躁') || persona.includes('易怒')) {
                baseHeartrate = 88; // 热血型角色心率很高
            } else if (persona.includes('神秘') || persona.includes('深沉') || persona.includes('安静') || 
                       persona.includes('文静') || persona.includes('内向')) {
                baseHeartrate = 70; // 神秘型角色心率正常偏低
            }
            
            // 根据角色名字进一步微调
            if (name.includes('小') || name.includes('萌') || name.includes('可爱')) {
                baseHeartrate += 3; // 可爱名字的角色心率稍高
            } else if (name.includes('冰') || name.includes('雪') || name.includes('静') || 
                       name.includes('冷') || name.includes('凉')) {
                baseHeartrate -= 5; // 冷系名字的角色心率更低
            } else if (name.includes('火') || name.includes('热') || name.includes('烈')) {
                baseHeartrate += 5; // 火系名字的角色心率更高
            }
            
            // 根据最近对话内容调整心率
            const recentMessages = (chatMessages[currentChatCharacter.id] || []).slice(-8); // 分析最近8条消息
            let emotionAdjustment = 0;
            
            recentMessages.forEach(msg => {
                // 安全地处理消息内容
                let content = '';
                if (typeof msg.content === 'string') {
                    content = msg.content.toLowerCase();
                } else if (Array.isArray(msg.content)) {
                    content = '';
                } else {
                    content = '';
                }
                
                // 高度亲密词汇 - 大幅提高心率
                if (content.includes('爱你') || content.includes('我爱你') || content.includes('love you') || 
                    content.includes('喜欢你') || content.includes('想你') || content.includes('想抱你') ||
                    content.includes('想吻你') || content.includes('亲亲') || content.includes('抱抱') ||
                    content.includes('宝贝') || content.includes('darling') || content.includes('honey') ||
                    content.includes('亲爱的') || content.includes('想要你') || content.includes('需要你') ||
                    content.includes('离不开你') || content.includes('想和你') || content.includes('想见你')) {
                    emotionAdjustment += 15;
                }
                
                // 表白和甜蜜词汇
                if (content.includes('表白') || content.includes('喜欢') || content.includes('心动') || 
                    content.includes('心跳') || content.includes('脸红') || content.includes('害羞') ||
                    content.includes('可爱') || content.includes('甜') || content.includes('温柔') ||
                    content.includes('美丽') || content.includes('漂亮') || content.includes('迷人') ||
                    content.includes('魅力') || content.includes('吸引') || content.includes('心仪')) {
                    emotionAdjustment += 10;
                }
                
                // 撒娇和亲昵词汇
                if (content.includes('撒娇') || content.includes('嘤嘤') || content.includes('哼') ||
                    content.includes('人家') || content.includes('讨厌') || content.includes('不要') ||
                    content.includes('好不好') || content.includes('求你') || content.includes('拜托') ||
                    content.includes('陪我') || content.includes('陪陪') || content.includes('一起')) {
                    emotionAdjustment += 8;
                }
                
                // 兴奋和开心词汇
                if (content.includes('开心') || content.includes('高兴') || content.includes('快乐') || 
                    content.includes('兴奋') || content.includes('激动') || content.includes('好棒') || 
                    content.includes('厉害') || content.includes('哇') || content.includes('太好了') ||
                    content.includes('amazing') || content.includes('wonderful') || content.includes('great')) {
                    emotionAdjustment += 6;
                }
                
                // 负面情绪词汇 - 同样会让心率加快
                if (content.includes('难过') || content.includes('生气') || content.includes('担心') || 
                    content.includes('害怕') || content.includes('紧张') || content.includes('焦虑') ||
                    content.includes('不开心') || content.includes('郁闷') || content.includes('烦') ||
                    content.includes('压力') || content.includes('累') || content.includes('疲惫')) {
                    emotionAdjustment += 8;
                }
            });
            
            // 计算最终心率
            currentHeartrate = Math.max(50, Math.min(140, baseHeartrate + emotionAdjustment));
            
            // 启动心率更新
            if (heartrateInterval) clearInterval(heartrateInterval);
            heartrateInterval = setInterval(() => {
                // 添加自然的心率波动（±4 bpm）
                const fluctuation = Math.floor(Math.random() * 9) - 4;
                const displayHeartrate = Math.max(50, Math.min(140, currentHeartrate + fluctuation));
                
                // 根据心率高低添加视觉效果
                heartrateDisplay.className = '';
                if (displayHeartrate >= 110) {
                    heartrateDisplay.classList.add('very-high-heartrate');
                } else if (displayHeartrate >= 95) {
                    heartrateDisplay.classList.add('high-heartrate');
                }
                
                heartrateDisplay.innerHTML = `♥️ <span class="heartrate-number">${displayHeartrate}</span> <span class="heartrate-unit">bpm</span>`;
            }, 1500 + Math.random() * 1000); // 1.5-2.5秒更新一次
            
            // 立即显示初始心率
            heartrateDisplay.innerHTML = `♥️ <span class="heartrate-number">${currentHeartrate}</span> <span class="heartrate-unit">bpm</span>`;
        }

        function hideAiHeartrate() {
            const heartrateDisplay = document.getElementById('ai-heartrate-display');
            if (heartrateDisplay) {
                heartrateDisplay.style.display = 'none';
            }
            
            if (heartrateInterval) {
                clearInterval(heartrateInterval);
                heartrateInterval = null;
            }
        }

        // 当发送消息时更新心率
        function adjustHeartrateForMessage(content, isUserMessage = false) {
            if (!heartrateInterval) return; // 心率监测未启用
            
            let adjustment = 0;
            let lowerContent = '';
            let recoveryTime = 3000; // 默认恢复时间
            
            // 安全地处理内容
            if (typeof content === 'string') {
                lowerContent = content.toLowerCase();
            } else if (Array.isArray(content)) {
                lowerContent = '';
            } else {
                lowerContent = '';
            }
            
            if (isUserMessage) {
                // 用户发送消息时，AI的心率会有相应反应
                
                // 高度亲密词汇 - 强烈心跳加速
                if (lowerContent.includes('爱你') || lowerContent.includes('我爱你') || lowerContent.includes('love you') || 
                    lowerContent.includes('喜欢你') || lowerContent.includes('想你') || lowerContent.includes('想抱你') ||
                    lowerContent.includes('想吻你') || lowerContent.includes('亲亲') || lowerContent.includes('抱抱') ||
                    lowerContent.includes('宝贝') || lowerContent.includes('darling') || lowerContent.includes('honey') ||
                    lowerContent.includes('亲爱的') || lowerContent.includes('想要你') || lowerContent.includes('需要你') ||
                    lowerContent.includes('离不开你') || lowerContent.includes('想和你') || lowerContent.includes('想见你')) {
                    adjustment = 20; // 大幅增加
                    recoveryTime = 8000; // 更长的恢复时间
                }
                // 表白和甜蜜词汇
                else if (lowerContent.includes('表白') || lowerContent.includes('喜欢') || lowerContent.includes('心动') || 
                    lowerContent.includes('心跳') || lowerContent.includes('脸红') || lowerContent.includes('害羞') ||
                    lowerContent.includes('可爱') || lowerContent.includes('甜') || lowerContent.includes('温柔') ||
                    lowerContent.includes('美丽') || lowerContent.includes('漂亮') || lowerContent.includes('迷人') ||
                    lowerContent.includes('魅力') || lowerContent.includes('吸引') || lowerContent.includes('心仪')) {
                    adjustment = 15;
                    recoveryTime = 6000;
                }
                // 撒娇和亲昵词汇
                else if (lowerContent.includes('撒娇') || lowerContent.includes('嘤嘤') || lowerContent.includes('哼') ||
                    lowerContent.includes('人家') || lowerContent.includes('讨厌') || lowerContent.includes('不要') ||
                    lowerContent.includes('好不好') || lowerContent.includes('求你') || lowerContent.includes('拜托') ||
                    lowerContent.includes('陪我') || lowerContent.includes('陪陪') || lowerContent.includes('一起')) {
                    adjustment = 12;
                    recoveryTime = 5000;
                }
                // 兴奋和开心词汇
                else if (lowerContent.includes('开心') || lowerContent.includes('高兴') || lowerContent.includes('快乐') || 
                    lowerContent.includes('兴奋') || lowerContent.includes('激动') || lowerContent.includes('好棒') || 
                    lowerContent.includes('厉害') || lowerContent.includes('哇') || lowerContent.includes('太好了')) {
                    adjustment = 8;
                    recoveryTime = 4000;
                }
                // 负面情绪词汇 - 紧张导致心率加快
                else if (lowerContent.includes('生气') || lowerContent.includes('不开心') || lowerContent.includes('难过') ||
                    lowerContent.includes('担心') || lowerContent.includes('害怕') || lowerContent.includes('紧张') ||
                    lowerContent.includes('焦虑') || lowerContent.includes('郁闷') || lowerContent.includes('烦')) {
                    adjustment = 10;
                    recoveryTime = 6000;
                }
                // 普通问候
                else if (lowerContent.includes('你好') || lowerContent.includes('hi') || lowerContent.includes('hello') ||
                    lowerContent.includes('早上好') || lowerContent.includes('晚安')) {
                    adjustment = 5;
                    recoveryTime = 3000;
                }
                
            } else {
                // AI自己发送消息后的心率变化
                if (lowerContent.includes('害羞') || lowerContent.includes('脸红') || lowerContent.includes('不好意思')) {
                    adjustment = 10;
                    recoveryTime = 5000;
                } else if (lowerContent.includes('兴奋') || lowerContent.includes('开心') || lowerContent.includes('激动')) {
                    adjustment = 8;
                    recoveryTime = 4000;
                } else if (lowerContent.includes('紧张') || lowerContent.includes('担心') || lowerContent.includes('焦虑')) {
                    adjustment = 12;
                    recoveryTime = 6000;
                } else if (lowerContent.includes('爱') || lowerContent.includes('喜欢') || lowerContent.includes('想')) {
                    adjustment = 15;
                    recoveryTime = 7000;
                }
            }
            
            // 应用调整
            currentHeartrate = Math.max(55, Math.min(130, currentHeartrate + adjustment));
            
            // 更自然的恢复机制
            setTimeout(() => {
                const recoveryRate = Math.floor(adjustment * 0.6); // 恢复60%
                currentHeartrate = Math.max(65, currentHeartrate - recoveryRate);
                
                // 继续缓慢恢复
                setTimeout(() => {
                    const finalRecovery = Math.floor(adjustment * 0.3); // 再恢复30%
                    currentHeartrate = Math.max(65, currentHeartrate - finalRecovery);
                }, recoveryTime * 0.5);
                
            }, recoveryTime);
        }

        /**
 * 🔥【新增】处理AI对好友申请的回应
 * @param {string} characterId - AI角色的ID
 * @param {string} requestMessage - 用户发送的申请理由
 */
async function processAIFriendRequestResponse(characterId, requestMessage) {
    const character = characters.find(c => c.id === characterId);
    if (!character) return;

    // 构建一个专门用于决策的Prompt
    const decisionPrompt = `
# 指令：好友申请决策
你是 ${character.name}，之前因为某种原因拉黑了用户。现在用户主动向你发来好友申请，希望重新建立联系。

## 角色信息:
- 你的身份: ${character.name}
- 你的设定: ${character.bio}

## 当前情况:
- 用户的申请理由: "${requestMessage || '对方没有填写理由。'}"
- 用户主动道歉并请求重新做朋友

## 你的任务:
根据你的角色性格、用户的申请理由，以及你对这种情况的态度，决定是否同意重新添加用户为好友。

考虑因素：
1. 你的性格是否容易原谅别人？
2. 用户的道歉是否真诚？
3. 你是否愿意给对方第二次机会？
4. 你当初拉黑的原因是否严重？

你的回答必须非常简洁，只能是以下两个词之一：
- "同意" (如果你愿意原谅并重新开始)
- "拒绝" (如果你还不想原谅或重新联系)

请现在做出你的决定：
`;

    try {
        // 使用通用的API调用函数
        const response = await callChatAPI(decisionPrompt, character);
        // AI的回复通常是 `["同意"]` 或 `["拒绝"]`，我们只需要第一个元素
        const decision = Array.isArray(response) ? response[0].toLowerCase() : response.toLowerCase();

        console.log(`🤖 AI对好友申请的决策: ${decision}`);

        if (decision.includes('同意')) {
            // AI同意了
            await aiUnblockUser(characterId);
            
            // 🔥【美化】使用新的好友添加成功系统提示样式
            const systemMsg = {
                id: 'system_' + Date.now(),
                sender: 'system',
                content: `你们已成功添加为好友，现在可以开始聊天了！`,
                timestamp: Date.now(),
                isFriendAddedMessage: true // 标记为好友添加成功消息
            };
            addMessageToChat(systemMsg);
            
            showToast(`✅ ${character.name} 同意了你的好友申请`, 'success');
            
        } else {
            // AI拒绝了
            const systemMsg = {
                id: 'system_' + Date.now(),
                sender: 'system',
                content: `${character.name} 拒绝了你的好友申请。`,
                timestamp: Date.now()
            };
            addMessageToChat(systemMsg);
            
            showToast(`❌ ${character.name} 拒绝了你的好友申请`, 'warning');
        }

    } catch (error) {
        console.error('处理AI好友申请回应失败:', error);
        showToast('对方没有回应，请稍后再试', 'error');
    }
}


/**
 * 🔥【新增】AI解除对用户的拉黑
 * @param {string} characterId - AI角色的ID（拉黑者）
 */
async function aiUnblockUser(characterId) {
    try {
        const blockRecord = blacklistData.find(r => 
            r.blockerId === characterId && 
            r.blockedId === 'user' && 
            !r.unblocked
        );

        if (!blockRecord) {
            console.warn('未找到该角色的拉黑记录');
            return;
        }

        blockRecord.unblocked = true;
        blockRecord.unblockTimestamp = new Date().toISOString();
        
        await db.blacklist.put(blockRecord);
        console.log(`✅ ${characterId} 已解除对用户的拉黑`);

        // 刷新聊天界面的拉黑状态
        if (currentChatCharacter && currentChatCharacter.id === characterId) {
            updateChatBlockedStatus();
        }
        
        // 刷新联系人列表和消息列表的UI状态
        renderContactList();
        renderMessageList();

    } catch (error) {
        console.error('AI解除拉黑失败:', error);
    }
}
        console.log('📱 角色状态显示功能已加载');

        // 🔥【新增】通知角色被拉黑
        async function notifyCharacterBlocked(characterId, reason = '') {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;

                // 构建被拉黑通知的prompt
                const blockNotificationPrompt = `[系统消息：用户将你拉黑了${reason ? `，理由：${reason}` : '，未说明理由'}]

你是${character.name}，人设如下：${character.bio}

用户刚刚将你拉黑了。请根据你的性格做出反应。你可以：
1. 表达你的感受（困惑、伤心、愤怒、无所谓等）
2. 思考可能的原因
3. 决定是否要道歉或反省
4. 或者表现出符合你性格的其他反应

请用1-2句话表达你的反应，要符合你的性格设定：`;

                // 调用AI生成反应
                const response = await callChatAPI(blockNotificationPrompt, character);
                const reactions = parseAiResponse(response);

                // 添加角色的反应消息到聊天记录
                for (let i = 0; i < reactions.length; i++) {
                    const reactionData = reactions[i];
                    
                    // 跳过拉黑指令对象
                    if (typeof reactionData === 'object' && reactionData !== null && reactionData.type === 'block_user') {
                        continue;
                    }

                    let reactionMessage;
                    if (typeof reactionData === 'string') {
                        reactionMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: reactionData,
                            timestamp: Date.now() + i * 100,
                            isBlockReaction: true // 标记为拉黑反应消息
                        };
                    } else if (typeof reactionData === 'object' && reactionData !== null) {
                        // 处理其他类型的消息对象
                        const content = reactionData.content || reactionData.message || reactionData.text || '[角色反应]';
                        reactionMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: content,
                            timestamp: Date.now() + i * 100,
                            isBlockReaction: true
                        };
                    }

                    if (reactionMessage) {
                        // 添加到聊天记录
                        if (!chatMessages[characterId]) {
                            chatMessages[characterId] = [];
                        }
                        chatMessages[characterId].push(reactionMessage);
                        
                        // 如果当前正在与该角色聊天，显示消息
                        if (currentChatCharacter && currentChatCharacter.id === characterId) {
                            addMessageWithAnimation(reactionMessage, characterId);
                        }
                    }
                }

                await saveChatMessages();
                console.log(`✅ ${character.name} 对被拉黑做出了反应`);

            } catch (error) {
                console.error('通知角色被拉黑失败:', error);
            }
        }

        // 🔥【新增】通知角色被解除拉黑
        async function notifyCharacterUnblocked(characterId) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;

                // 构建解除拉黑通知的prompt
                const unblockNotificationPrompt = `[系统消息：用户将你从黑名单中移除了]

你是${character.name}，人设如下：${character.bio}

用户刚刚将你从黑名单中移除，现在你们可以正常聊天了。请根据你的性格做出反应。你可以：
1. 表达高兴或解脱的心情
2. 询问为什么之前被拉黑
3. 道歉或表示会改正
4. 表现出符合你性格的态度（可能还在生气，也可能很开心等）
5. 主动开启新的话题

请用1-2句话表达你的反应，要符合你的性格设定：`;

                // 调用AI生成反应
                const response = await callChatAPI(unblockNotificationPrompt, character);
                const reactions = parseAiResponse(response);

                // 添加角色的反应消息到聊天记录
                for (let i = 0; i < reactions.length; i++) {
                    const reactionData = reactions[i];
                    
                    // 跳过拉黑指令对象
                    if (typeof reactionData === 'object' && reactionData !== null && reactionData.type === 'block_user') {
                        continue;
                    }

                    let reactionMessage;
                    if (typeof reactionData === 'string') {
                        reactionMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: reactionData,
                            timestamp: Date.now() + i * 100,
                            isUnblockReaction: true // 标记为解除拉黑反应消息
                        };
                    } else if (typeof reactionData === 'object' && reactionData !== null) {
                        // 处理其他类型的消息对象
                        const content = reactionData.content || reactionData.message || reactionData.text || '[角色反应]';
                        reactionMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: content,
                            timestamp: Date.now() + i * 100,
                            isUnblockReaction: true
                        };
                    }

                    if (reactionMessage) {
                        // 添加到聊天记录
                        if (!chatMessages[characterId]) {
                            chatMessages[characterId] = [];
                        }
                        chatMessages[characterId].push(reactionMessage);
                        
                        // 如果当前正在与该角色聊天，显示消息
                        if (currentChatCharacter && currentChatCharacter.id === characterId) {
                            addMessageWithAnimation(reactionMessage, characterId);
                        }
                    }
                }

                await saveChatMessages();
                console.log(`✅ ${character.name} 对被解除拉黑做出了反应`);

            } catch (error) {
                console.error('通知角色被解除拉黑失败:', error);
            }
        }

        console.log('🚫 角色拉黑/解除拉黑通知功能已加载');

        // 🔥【新增】心声功能
        // 显示心声模态框
        async function showInnerThoughtsModal(messageId) {
            if (!messageId) return;

            const modal = document.getElementById('inner-thoughts-modal');
            const content = document.getElementById('inner-thoughts-content');

            // 显示模态框
            modal.style.display = 'flex';

            try {
                // 检查数据库中是否有缓存的心声
                const cachedThought = await db.innerThoughts.get(messageId);

                if (cachedThought) {
                    console.log('🔄 使用数据库缓存的心声内容');
                    displayInnerThoughts(cachedThought.content, messageId);
                } else {
                    console.log('🆕 生成新的心声内容');
                    // 显示加载状态
                    content.innerHTML = `
                        <div class="inner-thoughts-loading">
                            <div class="loading-spinner"></div>
                            <p>正在读取角色的内心想法...</p>
                        </div>
                    `;

                    // 生成心声
                    await generateInnerThoughts(messageId);
                }
            } catch (error) {
                console.error('加载心声失败:', error);
                displayInnerThoughtsError('加载心声数据失败');
            }
        }

        // 隐藏心声模态框
        function hideInnerThoughtsModal() {
            const modal = document.getElementById('inner-thoughts-modal');
            modal.style.display = 'none';
        }

        // 生成角色心声
        async function generateInnerThoughts(messageId, forceRegenerate = false) {
            try {
                const messages = chatMessages[currentChatCharacter.id] || [];
                const targetMessage = messages.find(msg => msg.id === messageId);

                if (!targetMessage || targetMessage.sender !== 'received') {
                    throw new Error('无法找到对应的AI消息');
                }

                const character = currentChatCharacter;
                if (!character) {
                    throw new Error('当前角色信息不存在');
                }

                // 如果不是强制重新生成，检查数据库缓存
                if (!forceRegenerate) {
                    const cachedThought = await db.innerThoughts.get(messageId);
                    if (cachedThought) {
                        displayInnerThoughts(cachedThought.content, messageId);
                        return;
                    }
                }

                // 构建心声生成的prompt
                const prompt = buildInnerThoughtsPrompt(targetMessage, character, messages);

                // 调用AI生成心声
                const response = await generateAIResponse(prompt, character);

                if (response && response.trim()) {
                    const thoughts = response.trim();

                    // 保存到数据库
                    await db.innerThoughts.put({
                        id: messageId,
                        messageId: messageId,
                        characterId: character.id,
                        content: thoughts,
                        timestamp: Date.now()
                    });

                    console.log('💾 心声已保存到数据库');
                    displayInnerThoughts(thoughts, messageId);
                } else {
                    throw new Error('AI未能生成心声内容');
                }

            } catch (error) {
                console.error('生成心声失败:', error);
                displayInnerThoughtsError(error.message);
            }
        }

        // 构建心声生成的prompt
        function buildInnerThoughtsPrompt(targetMessage, character, allMessages) {
            // 获取目标消息前后的上下文
            const messageIndex = allMessages.findIndex(msg => msg.id === targetMessage.id);
            const contextStart = Math.max(0, messageIndex - 3);
            const contextEnd = Math.min(allMessages.length, messageIndex + 1);
            const contextMessages = allMessages.slice(contextStart, contextEnd);

            // 构建对话上下文
            const conversationContext = contextMessages.map(msg => {
                if (msg.sender === 'sent') {
                    return `用户：${msg.content}`;
                } else if (msg.sender === 'received') {
                    return `${character.name}：${msg.content}`;
                }
                return '';
            }).filter(Boolean).join('\n');

            const prompt = `# 角色心声分析任务

你是 ${character.name}，以下是你的基本信息：
${character.bio || '暂无详细信息'}

## 对话上下文：
${conversationContext}

## 任务要求：
请分析你在说出"${targetMessage.content}"这句话时的内心想法。

## 输出要求：
1. 以第一人称视角描述内心想法
2. 内容应该真实反映角色的性格和当时的心理状态
3. 可以包含：对用户话语的真实感受、内心的小纠结、未说出口的想法、情感波动等
4. 字数控制在50-150字之间
5. 语气要符合角色性格，自然真实
6. 直接输出心声内容，不要加任何格式标记

请开始分析：`;

            return prompt;
        }

        // 显示心声内容
        function displayInnerThoughts(thoughts, messageId) {
            const content = document.getElementById('inner-thoughts-content');
            content.innerHTML = `
                <div class="inner-thoughts-text">${thoughts}</div>
            `;

            // 更新刷新按钮的onclick事件
            const refreshBtn = document.querySelector('.inner-thoughts-refresh-btn');
            if (refreshBtn) {
                refreshBtn.onclick = () => refreshInnerThoughts(messageId);
            }
        }

        // 刷新心声内容
        async function refreshInnerThoughts(messageId) {
            if (!messageId) return;

            const content = document.getElementById('inner-thoughts-content');

            // 显示刷新加载状态
            content.innerHTML = `
                <div class="inner-thoughts-loading">
                    <div class="loading-spinner"></div>
                    <p>正在重新生成心声...</p>
                </div>
            `;

            try {
                // 删除数据库中的旧心声
                await db.innerThoughts.delete(messageId);
                console.log('🗑️ 已删除旧心声缓存');

                // 强制重新生成心声
                await generateInnerThoughts(messageId, true);
            } catch (error) {
                console.error('刷新心声失败:', error);
                displayInnerThoughtsError('刷新心声失败');
            }
        }

        // 显示心声生成错误
        function displayInnerThoughtsError(errorMessage) {
            const content = document.getElementById('inner-thoughts-content');
            content.innerHTML = `
                <div style="text-align: center; color: #ff3b30; padding: 20px;">
                    <i class="fas fa-exclamation-triangle" style="font-size: 24px; margin-bottom: 10px;"></i>
                    <p>生成心声失败</p>
                    <p style="font-size: 12px; color: #666; margin-top: 10px;">${errorMessage}</p>
                </div>
            `;
        }
        
        // 🔥【修复脚本】解决数据导入失败和引用消息刷新后消失的问题
        console.log('🔧 正在应用系统修复...');
        
        // 修复数据导入问题
        (function fixImportIssues() {
            const originalImport = window.importDataFromFile;
            window.importDataFromFile = function() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = async function(e) {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    try {
                        showToast('🔍 验证文件格式...', 'info');
                        const text = await file.text();
                        
                        let data;
                        try {
                            data = JSON.parse(text);
                        } catch (parseError) {
                            throw new Error(`JSON格式错误: ${parseError.message}\n请确保文件是有效的备份文件`);
                        }
                        
                        if (!data || typeof data !== 'object') {
                            throw new Error('无效的备份文件格式');
                        }
                        
                        const items = [];
                        if (data.characters?.length) items.push(`角色: ${data.characters.length}个`);
                        if (data.chatMessages?.length) items.push(`消息: ${data.chatMessages.length}条`);
                        if (data.chatSettings?.length) items.push(`设置: ${data.chatSettings.length}个`);
                        if (data.coreMemories?.length) items.push(`核心记忆: ${data.coreMemories.length}条`);
                        if (data.episodicMemories?.length) items.push(`情节记忆: ${data.episodicMemories.length}条`);
                        if (data.crossAppTimeline?.length) items.push(`时间线: ${data.crossAppTimeline.length}条`);
                        if (data.customEmojis?.length) items.push(`表情包: ${data.customEmojis.length}个`);
                        if (data.characterDiaries?.length) items.push(`角色日记: ${data.characterDiaries.length}条`);
                        
                        const msg = items.length ? `准备导入:\n${items.join('\n')}\n\n确定继续？` : '文件无有效数据，继续？';
                        if (!confirm(msg)) return;
                        
                        showToast('⚡ 导入中...', 'info');
                        let success = 0;
                        let errors = [];
                        
                        // 修复角色导入
                        if (data.characters?.length) {
                            try {
                                await db.characters.clear();
                                const chars = data.characters.filter(c => c?.name).map(c => ({
                                    ...c,
                                    id: c.id || `char_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                    groupId: c.groupId || 'my_friends'
                                }));
                                await db.characters.bulkPut(chars);
                                success++;
                            } catch (e) {
                                errors.push(`角色: ${e.message}`);
                            }
                        }
                        
                        // 🔥【修复】消息导入（处理格式转换和引用消息）
                        if (data.chatMessages?.length) {
                            try {
                                console.log('🔄 修复脚本：开始导入聊天消息');

                                // 🔥【格式检测和转换】
                                let processedMessages = [];
                                const isNewFormat = data.chatMessages.some(msg => msg.messageData);

                                if (isNewFormat) {
                                    // 新格式：直接使用
                                    processedMessages = data.chatMessages.map(msg => ({
                                        ...msg,
                                        id: msg.id || `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                    }));
                                } else {
                                    // 旧格式：转换为新格式
                                    const tempChatMessages = {};
                                    for (const msg of data.chatMessages) {
                                        if (!msg?.content) continue; // 跳过无效消息

                                        const characterId = msg.characterId || 'unknown';
                                        if (!tempChatMessages[characterId]) {
                                            tempChatMessages[characterId] = [];
                                        }

                                        // 修复引用消息
                                        const fixedMsg = { ...msg };
                                        if (msg.replyTo) {
                                            fixedMsg.replyTo = {
                                                id: msg.replyTo.id || 'unknown',
                                                content: msg.replyTo.content || '[已删除]',
                                                sender: msg.replyTo.sender || 'unknown',
                                                senderName: msg.replyTo.senderName || '未知',
                                                timestamp: msg.replyTo.timestamp || Date.now(),
                                                _fixed: true
                                            };
                                        }

                                        tempChatMessages[characterId].push(fixedMsg);
                                    }

                                    // 转换为新格式
                                    let globalSequentialId = 0;
                                    for (const [characterId, messages] of Object.entries(tempChatMessages)) {
                                        for (let i = 0; i < messages.length; i++) {
                                            const message = messages[i];
                                            processedMessages.push({
                                                id: `${characterId}_${globalSequentialId++}`,
                                                characterId: characterId,
                                                timestamp: message.timestamp,
                                                messageOrder: i,
                                                originalMessageId: message.id,
                                                messageData: message
                                            });
                                        }
                                    }
                                }

                                await db.chatMessages.clear();
                                await db.chatMessages.bulkPut(processedMessages);
                                success++;
                                console.log(`✅ 修复脚本：成功导入 ${processedMessages.length} 条消息`);
                            } catch (e) {
                                console.error('❌ 修复脚本：消息导入失败:', e);
                                errors.push(`消息: ${e.message}`);
                            }
                        }
                        
                        // 导入设置
                        if (data.chatSettings?.length) {
                            try {
                                await db.chatSettings.clear();
                                const settings = data.chatSettings.map(s => ({
                                    ...s,
                                    id: s.id || `set_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.chatSettings.bulkPut(settings);
                                success++;
                            } catch (e) {
                                errors.push(`设置: ${e.message}`);
                            }
                        }

                        // 🔥【新增】导入全局记忆系统数据
                        if (data.coreMemories?.length) {
                            try {
                                await db.coreMemories.clear();
                                const memories = data.coreMemories.map(m => ({
                                    ...m,
                                    id: m.id || `core_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.coreMemories.bulkPut(memories);
                                success++;
                            } catch (e) {
                                errors.push(`核心记忆: ${e.message}`);
                            }
                        }

                        if (data.episodicMemories?.length) {
                            try {
                                await db.episodicMemories.clear();
                                const memories = data.episodicMemories.map(m => ({
                                    ...m,
                                    id: m.id || `episodic_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.episodicMemories.bulkPut(memories);
                                success++;
                            } catch (e) {
                                errors.push(`情节记忆: ${e.message}`);
                            }
                        }

                        if (data.crossAppTimeline?.length) {
                            try {
                                await db.crossAppTimeline.clear();
                                const timeline = data.crossAppTimeline.map(t => ({
                                    ...t,
                                    id: t.id || `timeline_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.crossAppTimeline.bulkPut(timeline);
                                success++;
                            } catch (e) {
                                errors.push(`时间线: ${e.message}`);
                            }
                        }

                        if (data.customEmojis?.length) {
                            try {
                                await db.customEmojis.clear();
                                const emojis = data.customEmojis.map(e => ({
                                    ...e,
                                    id: e.id || `emoji_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.customEmojis.bulkPut(emojis);
                                success++;
                            } catch (e) {
                                errors.push(`表情包: ${e.message}`);
                            }
                        }

                        // 🔥【新增】导入用户面具数据
                        if (data.personas?.length) {
                            try {
                                await db.personas.clear();
                                const personas = data.personas.map(p => ({
                                    ...p,
                                    id: p.id || `persona_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.personas.bulkPut(personas);
                                success++;
                            } catch (e) {
                                errors.push(`用户面具: ${e.message}`);
                            }
                        }

                        // 🔥【新增】导入动态数据
                        if (data.moments?.length) {
                            try {
                                await db.moments.clear();
                                const moments = data.moments.map(m => ({
                                    ...m,
                                    id: m.id || `moment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.moments.bulkPut(moments);
                                success++;
                            } catch (e) {
                                errors.push(`动态: ${e.message}`);
                            }
                        }

                        // 🔥【新增】导入动态评论数据
                        if (data.momentComments?.length) {
                            try {
                                await db.momentComments.clear();
                                const comments = data.momentComments.map(c => ({
                                    ...c,
                                    id: c.id || `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.momentComments.bulkPut(comments);
                                success++;
                            } catch (e) {
                                errors.push(`动态评论: ${e.message}`);
                            }
                        }

                        // 🔥【新增】导入角色日记数据
                        if (data.characterDiaries?.length) {
                            try {
                                await db.characterDiaries.clear();
                                const diaries = data.characterDiaries.map(d => ({
                                    ...d,
                                    id: d.id || `${d.characterId}_${d.date}`,
                                    timestamp: d.timestamp || new Date(d.date).getTime(),
                                    weather: d.weather || '☀️'
                                }));
                                await db.characterDiaries.bulkPut(diaries);
                                success++;
                            } catch (e) {
                                errors.push(`角色日记: ${e.message}`);
                            }
                        }

                        // 重新加载
                        await loadCharacters();
                        await loadChatMessages();
                        await loadChatSettings();
                        renderCharacterList();
                        renderMessageList();
                        
                        const result = success > 0 
                            ? `🎉 导入成功 ${success} 项${errors.length ? `\n⚠️ ${errors.length} 项失败` : ''}`
                            : `❌ 导入失败\n${errors.join('\n')}`;
                        showToast(result, success > 0 ? 'success' : 'error');
                        
                    } catch (error) {
                        showToast(`❌ 导入失败: ${error.message}`, 'error');
                        if (error.message.includes('JSON')) {
                            setTimeout(() => alert('文件格式错误！请确保是从"导出所有数据"生成的备份文件'), 1000);
                        }
                    }
                };
                input.click();
            };
        })();
        
        // 修复引用消息问题
        (function fixReplyIssues() {
            const originalGenerate = window.generateReplyHTML;
            window.generateReplyHTML = function(replyTo) {
                if (!replyTo) return '';
                
                let safe = {
                    id: replyTo.id || 'unknown',
                    senderName: replyTo.senderName || '未知',
                    content: replyTo.content || '[已删除]'
                };
                
                // 尝试恢复引用内容
                if (replyTo.id !== 'unknown' && currentChatCharacter) {
                    const msgs = chatMessages[currentChatCharacter.id] || [];
                    const original = msgs.find(m => m.id === replyTo.id);
                    if (original) {
                        safe.content = original.content || '[图片]';
                        safe.senderName = getSenderDisplayName(original);
                    }
                }
                
                const display = truncateText(safe.content, 20);
                return `
                    <div class="reply-reference" data-reply-id="${safe.id}">
                        <div class="reply-reference-line"></div>
                        <div class="reply-reference-content">
                            <div class="reply-reference-sender">${safe.senderName}</div>
                            <div class="reply-reference-message">${display}</div>
                        </div>
                    </div>
                `;
            };
        })();
        

        // 🔥【移除】自动清理函数已移至数据库版本7的升级逻辑中

        // 🔥【新增】数据库状态诊断函数
        async function diagnoseDatabaseIssue() {
            try {
                console.log('🔍 开始数据库状态诊断...');

                // 检查数据库是否存在
                if (!db) {
                    console.error('❌ 数据库对象不存在');
                    return;
                }

                // 检查表是否存在
                const tables = ['crossAppTimeline', 'memoryEvents', 'characterStatus'];
                for (const tableName of tables) {
                    if (db[tableName]) {
                        console.log(`✅ 表 ${tableName} 存在`);

                        // 尝试查询表结构
                        try {
                            const count = await db[tableName].count();
                            console.log(`📊 表 ${tableName} 记录数: ${count}`);
                        } catch (error) {
                            console.error(`❌ 查询表 ${tableName} 失败:`, error);
                        }
                    } else {
                        console.error(`❌ 表 ${tableName} 不存在`);
                    }
                }

                // 测试添加一条记录
                const testEvent = {
                    id: `test_${Date.now()}`,
                    characterId: 'test_character',
                    appType: 'test',
                    action: 'test_action',
                    timestamp: Date.now(),
                    context: { test: true },
                    messageId: null
                };

                try {
                    await db.crossAppTimeline.add(testEvent);
                    console.log('✅ 测试记录添加成功');

                    // 删除测试记录
                    await db.crossAppTimeline.delete(testEvent.id);
                    console.log('✅ 测试记录删除成功');
                } catch (error) {
                    console.error('❌ 测试记录添加失败:', error);
                }

            } catch (error) {
                console.error('❌ 数据库诊断失败:', error);
            }
        }

        // 延迟执行诊断
        setTimeout(() => {
            diagnoseDatabaseIssue();
        }, 5000);

        // 🔥【新增】紧急数据恢复功能
        async function emergencyDataRecovery() {
            console.log('=== 紧急数据恢复开始 ===');

            try {
                // 1. 检查IndexedDB中的数据
                const dbCharacters = await db.characters.toArray();
                const dbChatMessages = await db.chatMessages.toArray();
                const dbContacts = await db.contacts.toArray();

                console.log('IndexedDB角色数据:', dbCharacters);
                console.log('IndexedDB聊天记录:', dbChatMessages);
                console.log('IndexedDB联系人:', dbContacts);

                // 2. 检查localStorage备份
                const localCharacters = localStorage.getItem('characters');
                const localChatMessages = localStorage.getItem('chatMessages');
                const localContacts = localStorage.getItem('contacts');

                console.log('localStorage角色备份:', localCharacters ? JSON.parse(localCharacters) : null);
                console.log('localStorage聊天备份:', localChatMessages ? JSON.parse(localChatMessages) : null);
                console.log('localStorage联系人备份:', localContacts ? JSON.parse(localContacts) : null);

                return {
                    indexedDB: { characters: dbCharacters, chatMessages: dbChatMessages, contacts: dbContacts },
                    localStorage: {
                        characters: localCharacters ? JSON.parse(localCharacters) : null,
                        chatMessages: localChatMessages ? JSON.parse(localChatMessages) : null,
                        contacts: localContacts ? JSON.parse(localContacts) : null
                    }
                };

            } catch (error) {
                console.error('数据恢复检查失败:', error);
                return null;
            }
        }

        // 🔥【新增】从导出数据恢复角色
        async function recoverFromExportData(exportData) {
            try {
                console.log('开始从导出数据恢复...');

                if (exportData.characters && exportData.characters.length > 0) {
                    // 过滤掉张三李四
                    const validCharacters = exportData.characters.filter(char =>
                        char.name !== '张三' && char.name !== '李四'
                    );

                    console.log('有效角色数据:', validCharacters);

                    // 🔥【安全修复】恢复角色数据
                    await safeDataSave('characters', validCharacters);
                    characters = validCharacters;

                    // 恢复联系人列表
                    const validContactIds = validCharacters.map(char => char.id);
                    contacts = validContactIds;
                    await saveContacts();

                    console.log('角色数据恢复完成');
                }

                if (exportData.chatMessages) {
                    // 恢复聊天记录
                    await db.chatMessages.clear();
                    for (const [characterId, messages] of Object.entries(exportData.chatMessages)) {
                        if (messages && messages.length > 0) {
                            for (const message of messages) {
                                await db.chatMessages.add({
                                    characterId: characterId,
                                    ...message
                                });
                            }
                        }
                    }
                    chatMessages = exportData.chatMessages;
                    console.log('聊天记录恢复完成');
                }

                // 刷新界面
                renderCharacterList();
                renderContactList();
                renderMessageList();

                showToast('数据恢复成功！', 'success');
                return true;

            } catch (error) {
                console.error('数据恢复失败:', error);
                showToast('数据恢复失败: ' + error.message, 'error');
                return false;
            }
        }

        // 🚨【紧急恢复功能】
        function addRecoveryLog(message) {
            const logDiv = document.getElementById('recovery-log');
            const logContent = document.getElementById('recovery-log-content');

            if (logDiv && logContent) {
                logDiv.style.display = 'block';
                const timestamp = new Date().toLocaleTimeString();
                logContent.innerHTML += `[${timestamp}] ${message}\n`;
                logContent.scrollTop = logContent.scrollHeight;
            }
        }

        async function checkDataStatus() {
            addRecoveryLog('开始检查数据状态...');

            try {
                // 检查IndexedDB数据
                const dbCharacters = await db.characters.toArray();
                const dbChatMessages = await db.chatMessages.toArray();
                const dbContacts = await db.contacts.toArray();

                // 检查localStorage备份
                const localCharacters = localStorage.getItem('characters');
                const localChatMessages = localStorage.getItem('chatMessages');
                const localContacts = localStorage.getItem('contacts');

                const statusText = `
=== 数据状态检查结果 ===

📊 IndexedDB 数据：
- 角色数量: ${dbCharacters.length}
- 聊天记录: ${dbChatMessages.length} 条
- 联系人: ${dbContacts.length} 个

📦 localStorage 备份：
- 角色备份: ${localCharacters ? JSON.parse(localCharacters).length : 0} 个
- 聊天备份: ${localChatMessages ? Object.keys(JSON.parse(localChatMessages)).length : 0} 个对话
- 联系人备份: ${localContacts ? JSON.parse(localContacts).length : 0} 个

🔍 当前内存状态：
- 角色列表: ${characters.length} 个
- 联系人列表: ${contacts.length} 个
- 聊天记录: ${Object.keys(chatMessages).length} 个对话

⚠️ 异常角色检测：
${dbCharacters.filter(c => c.name === '张三' || c.name === '李四').map(c => `- ${c.name} (ID: ${c.id})`).join('\n') || '未发现异常角色'}
                `;

                document.getElementById('data-status-result').style.display = 'block';
                document.getElementById('data-status-text').textContent = statusText;

                addRecoveryLog('数据状态检查完成');

            } catch (error) {
                addRecoveryLog('数据检查失败: ' + error.message);
            }
        }

        // 🔍 深度数据搜索
        async function deepDataSearch() {
            addRecoveryLog('开始深度搜索残留数据...');

            try {
                const foundData = [];

                // 1. 搜索所有localStorage键
                addRecoveryLog('搜索localStorage...');
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && (key.includes('character') || key.includes('chat'))) {
                        const value = localStorage.getItem(key);
                        if (value && value.length > 100) { // 只关注较大的数据
                            foundData.push(`localStorage[${key}]: ${value.length} 字符`);
                        }
                    }
                }

                // 2. 搜索IndexedDB中的所有表
                addRecoveryLog('搜索IndexedDB所有表...');
                const allTables = ['characters', 'chatMessages', 'contacts', 'chatSettings', 'customEmojis', 'worldbooks', 'moments', 'personas', 'groupChats'];

                for (const tableName of allTables) {
                    try {
                        const data = await db[tableName].toArray();
                        if (data.length > 0) {
                            foundData.push(`IndexedDB[${tableName}]: ${data.length} 条记录`);

                            // 特别检查角色相关数据
                            if (tableName === 'characters') {
                                data.forEach(char => {
                                    if (char.name !== '张三' && char.name !== '李四') {
                                        foundData.push(`  发现角色: ${char.name} (ID: ${char.id})`);
                                    }
                                });
                            }
                        }
                    } catch (e) {
                        // 表不存在或无法访问
                    }
                }

                // 3. 检查聊天记录中的角色信息
                addRecoveryLog('分析聊天记录...');
                const chatData = await db.chatMessages.toArray();
                const characterIds = new Set();
                chatData.forEach(msg => {
                    if (msg.characterId && msg.characterId !== 'user') {
                        characterIds.add(msg.characterId);
                    }
                });

                if (characterIds.size > 0) {
                    foundData.push(`聊天记录中发现 ${characterIds.size} 个角色ID:`);
                    characterIds.forEach(id => {
                        foundData.push(`  角色ID: ${id}`);
                    });
                }

                const resultText = foundData.length > 0 ? foundData.join('\n') : '未发现额外的角色数据';

                document.getElementById('deep-search-result').style.display = 'block';
                document.getElementById('deep-search-text').textContent = resultText;

                addRecoveryLog(`深度搜索完成，发现 ${foundData.length} 条线索`);

            } catch (error) {
                addRecoveryLog('深度搜索失败: ' + error.message);
            }
        }

        // 💬 从聊天记录推断角色
        async function searchChatHistory() {
            addRecoveryLog('开始分析聊天记录...');

            try {
                const chatData = await db.chatMessages.toArray();
                const characterInfo = new Map();

                // 分析聊天记录，尝试重建角色信息
                chatData.forEach(msg => {
                    if (msg.characterId && msg.characterId !== 'user') {
                        if (!characterInfo.has(msg.characterId)) {
                            characterInfo.set(msg.characterId, {
                                id: msg.characterId,
                                messageCount: 0,
                                lastMessage: null,
                                firstMessage: null
                            });
                        }

                        const info = characterInfo.get(msg.characterId);
                        info.messageCount++;

                        if (!info.firstMessage || msg.timestamp < info.firstMessage.timestamp) {
                            info.firstMessage = msg;
                        }

                        if (!info.lastMessage || msg.timestamp > info.lastMessage.timestamp) {
                            info.lastMessage = msg;
                        }
                    }
                });

                let resultText = '=== 聊天记录分析结果 ===\n\n';

                if (characterInfo.size === 0) {
                    resultText += '未发现任何角色的聊天记录';
                } else {
                    resultText += `发现 ${characterInfo.size} 个角色的聊天记录:\n\n`;

                    characterInfo.forEach((info, characterId) => {
                        resultText += `角色ID: ${characterId}\n`;
                        resultText += `消息数量: ${info.messageCount} 条\n`;
                        resultText += `最早消息: ${new Date(info.firstMessage.timestamp).toLocaleString()}\n`;
                        resultText += `最新消息: ${new Date(info.lastMessage.timestamp).toLocaleString()}\n`;
                        resultText += `最新内容: ${info.lastMessage.content?.substring(0, 50)}...\n\n`;
                    });

                    resultText += '\n💡 建议: 如果这些ID对应您丢失的角色，可以尝试手动重建角色卡';
                }

                document.getElementById('deep-search-result').style.display = 'block';
                document.getElementById('deep-search-text').textContent = resultText;

                addRecoveryLog('聊天记录分析完成');

            } catch (error) {
                addRecoveryLog('聊天记录分析失败: ' + error.message);
            }
        }

        // 🔧 从聊天记录重建角色
        async function rebuildCharactersFromChat() {
            addRecoveryLog('开始从聊天记录重建角色...');

            try {
                const chatData = await db.chatMessages.toArray();
                const characterInfo = new Map();

                // 分析聊天记录
                chatData.forEach(msg => {
                    if (msg.characterId && msg.characterId !== 'user') {
                        if (!characterInfo.has(msg.characterId)) {
                            characterInfo.set(msg.characterId, {
                                id: msg.characterId,
                                messages: [],
                                firstMessage: null,
                                lastMessage: null
                            });
                        }

                        const info = characterInfo.get(msg.characterId);
                        info.messages.push(msg);

                        if (!info.firstMessage || msg.timestamp < info.firstMessage.timestamp) {
                            info.firstMessage = msg;
                        }

                        if (!info.lastMessage || msg.timestamp > info.lastMessage.timestamp) {
                            info.lastMessage = msg;
                        }
                    }
                });

                addRecoveryLog(`发现 ${characterInfo.size} 个角色的聊天记录`);

                // 重建角色卡
                const rebuiltCharacters = [];
                let rebuiltCount = 0;

                for (const [characterId, info] of characterInfo) {
                    // 跳过张三李四
                    if (characterId === '张三' || characterId === '李四') continue;

                    // 尝试从聊天内容推断角色名字
                    let characterName = `角色_${characterId.slice(-4)}`;

                    // 查找可能的角色名字（从用户消息和角色消息中寻找）
                    const allMessages = info.messages.slice(0, 20); // 检查前20条消息

                    // 方法1: 从用户消息中寻找称呼
                    const userMessages = allMessages.filter(msg => msg.sender === 'sent');
                    for (const msg of userMessages) {
                        const content = msg.content || '';
                        // 寻找常见的称呼模式
                        const patterns = [
                            /(?:你好|嗨|hi|hello)[，,\s]*([^\s，,。！？]{1,8})/i,
                            /([^\s，,。！？]{1,8})[，,\s]*(?:你好|在吗|在不在)/i,
                            /^([^\s，,。！？]{1,8})[，,\s]/,
                            /叫你([^\s，,。！？]{1,8})/i
                        ];

                        for (const pattern of patterns) {
                            const nameMatch = content.match(pattern);
                            if (nameMatch && nameMatch[1] && nameMatch[1].length <= 8 && nameMatch[1].length >= 2) {
                                characterName = nameMatch[1];
                                break;
                            }
                        }
                        if (characterName !== `角色_${characterId.slice(-4)}`) break;
                    }

                    // 方法2: 从角色的自我介绍中寻找
                    if (characterName === `角色_${characterId.slice(-4)}`) {
                        const characterMessages = allMessages.filter(msg => msg.sender === 'character');
                        for (const msg of characterMessages.slice(0, 5)) {
                            const content = msg.content || '';
                            const patterns = [
                                /我是([^\s，,。！？]{1,8})/i,
                                /我叫([^\s，,。！？]{1,8})/i,
                                /叫我([^\s，,。！？]{1,8})/i,
                                /^([^\s，,。！？]{1,8})(?:在这里|来了|回来了)/i
                            ];

                            for (const pattern of patterns) {
                                const nameMatch = content.match(pattern);
                                if (nameMatch && nameMatch[1] && nameMatch[1].length <= 8 && nameMatch[1].length >= 2) {
                                    characterName = nameMatch[1];
                                    break;
                                }
                            }
                            if (characterName !== `角色_${characterId.slice(-4)}`) break;
                        }
                    }

                    // 创建基础角色卡
                    const character = {
                        id: characterId,
                        name: characterName,
                        description: `从聊天记录恢复的角色，共有 ${info.messages.length} 条对话记录`,
                        personality: '温和友善，善于交流',
                        scenario: '日常聊天场景',
                        firstMessage: info.firstMessage?.content || '你好！',
                        avatar: '',
                        createdAt: info.firstMessage?.timestamp || Date.now(),
                        updatedAt: info.lastMessage?.timestamp || Date.now(),
                        tags: ['恢复角色'],
                        isPublic: false,
                        messageCount: info.messages.length
                    };

                    rebuiltCharacters.push(character);
                    rebuiltCount++;

                    addRecoveryLog(`重建角色: ${characterName} (ID: ${characterId.slice(-6)}...)`);
                }

                if (rebuiltCharacters.length === 0) {
                    throw new Error('没有找到可重建的角色');
                }

                // 🔥【安全修复】清除现有的异常角色，添加重建的角色
                await safeDataSave('characters', rebuiltCharacters);
                characters = rebuiltCharacters;

                // 更新联系人列表
                contacts = rebuiltCharacters.map(char => char.id);
                await saveContacts();

                // 强制刷新所有相关数据
                await loadCharacters();
                await loadContacts();
                await loadChatMessages();

                // 刷新界面
                renderCharacterList();
                renderContactList();
                renderMessageList();

                // 如果当前在聊天界面，刷新聊天界面
                if (currentCharacterId) {
                    const character = characters.find(c => c.id === currentCharacterId);
                    if (character) {
                        renderChatHeader();
                    }
                }

                addRecoveryLog(`✅ 成功重建 ${rebuiltCount} 个角色！`);
                addRecoveryLog(`角色列表: ${rebuiltCharacters.map(c => c.name).join(', ')}`);
                alert(`角色重建完成！成功恢复 ${rebuiltCount} 个角色，聊天记录已保留。\n\n恢复的角色: ${rebuiltCharacters.map(c => c.name).join(', ')}`);

            } catch (error) {
                addRecoveryLog('❌ 角色重建失败: ' + error.message);
                alert('角色重建失败: ' + error.message);
            }
        }

        // ✏️ 显示手动重建界面
        async function showManualRebuild() {
            try {
                const chatData = await db.chatMessages.toArray();
                const characterInfo = new Map();

                // 分析聊天记录
                chatData.forEach(msg => {
                    if (msg.characterId && msg.characterId !== 'user' && msg.characterId !== '张三' && msg.characterId !== '李四') {
                        if (!characterInfo.has(msg.characterId)) {
                            characterInfo.set(msg.characterId, {
                                id: msg.characterId,
                                messageCount: 0,
                                lastMessage: null
                            });
                        }

                        const info = characterInfo.get(msg.characterId);
                        info.messageCount++;

                        if (!info.lastMessage || msg.timestamp > info.lastMessage.timestamp) {
                            info.lastMessage = msg;
                        }
                    }
                });

                if (characterInfo.size === 0) {
                    alert('没有发现可重建的角色');
                    return;
                }

                // 创建手动重建界面
                let html = '<div style="max-height: 400px; overflow-y: auto;">';
                html += '<h4>选择要重建的角色：</h4>';

                characterInfo.forEach((info, characterId) => {
                    const shortId = characterId.slice(-6);
                    const lastContent = info.lastMessage?.content?.substring(0, 30) || '';

                    html += `
                        <div style="border: 1px solid #ddd; border-radius: 8px; padding: 10px; margin-bottom: 10px;">
                            <div style="font-weight: bold;">角色ID: ${shortId}...</div>
                            <div style="font-size: 12px; color: #666;">消息数: ${info.messageCount} 条</div>
                            <div style="font-size: 12px; color: #666;">最新消息: ${lastContent}...</div>
                            <input type="text" id="name_${characterId}" placeholder="输入角色名字" style="width: 100%; margin: 5px 0; padding: 5px; border: 1px solid #ccc; border-radius: 4px;">
                            <label><input type="checkbox" id="rebuild_${characterId}" checked> 重建此角色</label>
                        </div>
                    `;
                });

                html += '</div>';
                html += '<button onclick="executeManualRebuild()" style="background: #32D74B; color: white; border: none; padding: 10px 20px; border-radius: 8px; width: 100%; margin-top: 10px;">确认重建选中的角色</button>';

                document.getElementById('deep-search-result').style.display = 'block';
                document.getElementById('deep-search-text').innerHTML = html;

                // 存储角色信息供后续使用
                window.manualRebuildInfo = characterInfo;

            } catch (error) {
                alert('获取角色信息失败: ' + error.message);
            }
        }

        // 🔍 调试当前状态
        async function debugCurrentState() {
            addRecoveryLog('开始检查当前数据状态...');

            try {
                // 检查内存中的数据
                addRecoveryLog(`内存中角色数量: ${characters.length}`);
                addRecoveryLog(`内存中联系人数量: ${contacts.length}`);

                if (characters.length > 0) {
                    addRecoveryLog('内存中的角色:');
                    characters.forEach(char => {
                        addRecoveryLog(`  - ${char.name} (ID: ${char.id.slice(-6)}...)`);
                    });
                }

                // 检查数据库中的数据
                const dbCharacters = await db.characters.toArray();
                const dbContacts = await db.contacts.toArray();
                const dbMessages = await db.chatMessages.toArray();

                addRecoveryLog(`数据库中角色数量: ${dbCharacters.length}`);
                addRecoveryLog(`数据库中联系人数量: ${dbContacts.length}`);
                addRecoveryLog(`数据库中消息数量: ${dbMessages.length}`);

                if (dbCharacters.length > 0) {
                    addRecoveryLog('数据库中的角色:');
                    dbCharacters.forEach(char => {
                        addRecoveryLog(`  - ${char.name} (ID: ${char.id.slice(-6)}...)`);
                    });
                }

                // 检查界面元素
                const characterListElement = document.getElementById('character-list');
                const contactListElement = document.getElementById('contact-list');

                addRecoveryLog(`角色列表元素存在: ${!!characterListElement}`);
                addRecoveryLog(`联系人列表元素存在: ${!!contactListElement}`);

                if (characterListElement) {
                    addRecoveryLog(`角色列表子元素数量: ${characterListElement.children.length}`);
                }

                if (contactListElement) {
                    addRecoveryLog(`联系人列表子元素数量: ${contactListElement.children.length}`);
                }

                // 检查当前页面状态
                addRecoveryLog(`当前页面: ${currentPage}`);
                addRecoveryLog(`当前角色ID: ${currentCharacterId || '无'}`);

                addRecoveryLog('状态检查完成');

            } catch (error) {
                addRecoveryLog('状态检查失败: ' + error.message);
            }
        }

        // 🔄 强制刷新所有界面
        async function forceRefreshAll() {
            addRecoveryLog('开始强制刷新所有界面...');

            try {
                // 重新加载所有数据
                await loadCharacters();
                await loadContacts();
                await loadChatMessages();

                addRecoveryLog(`重新加载后角色数量: ${characters.length}`);
                addRecoveryLog(`重新加载后联系人数量: ${contacts.length}`);

                // 强制刷新所有界面
                renderCharacterList();
                renderContactList();
                renderMessageList();

                // 如果在聊天页面，刷新聊天界面
                if (currentPage === 'chat' && currentCharacterId) {
                    const character = characters.find(c => c.id === currentCharacterId);
                    if (character) {
                        renderChatHeader();
                        renderChatMessages();
                    } else {
                        // 如果当前角色不存在，返回主页
                        hideApp('api-chat-screen');
                    }
                }

                // 如果在角色管理页面，刷新角色管理界面
                if (currentPage === 'characters') {
                    renderCharacterList();
                }

                addRecoveryLog('✅ 界面刷新完成');
                alert('界面刷新完成！请检查角色列表是否正常显示。');

            } catch (error) {
                addRecoveryLog('界面刷新失败: ' + error.message);
                alert('界面刷新失败: ' + error.message);
            }
        }

        // 执行手动重建
        async function executeManualRebuild() {
            try {
                const rebuiltCharacters = [];

                for (const [characterId, info] of window.manualRebuildInfo) {
                    const checkbox = document.getElementById(`rebuild_${characterId}`);
                    const nameInput = document.getElementById(`name_${characterId}`);

                    if (checkbox && checkbox.checked) {
                        const characterName = nameInput.value.trim() || `角色_${characterId.slice(-4)}`;

                        const character = {
                            id: characterId,
                            name: characterName,
                            description: `手动重建的角色，共有 ${info.messageCount} 条对话记录`,
                            personality: '请根据聊天记录调整性格设定',
                            scenario: '日常聊天场景',
                            firstMessage: info.lastMessage?.content || '你好！',
                            avatar: '',
                            createdAt: Date.now() - 86400000, // 1天前
                            updatedAt: Date.now(),
                            tags: ['手动恢复'],
                            isPublic: false,
                            messageCount: info.messageCount
                        };

                        rebuiltCharacters.push(character);
                    }
                }

                if (rebuiltCharacters.length === 0) {
                    alert('请至少选择一个角色进行重建');
                    return;
                }

                // 🔥【安全修复】清除现有角色，添加重建的角色
                await safeDataSave('characters', rebuiltCharacters);
                characters = rebuiltCharacters;

                // 更新联系人列表
                contacts = rebuiltCharacters.map(char => char.id);
                await saveContacts();

                // 刷新界面
                renderCharacterList();
                renderContactList();

                addRecoveryLog(`✅ 手动重建完成！恢复了 ${rebuiltCharacters.length} 个角色`);
                alert(`手动重建完成！成功恢复 ${rebuiltCharacters.length} 个角色。`);

                // 隐藏重建界面
                document.getElementById('deep-search-result').style.display = 'none';

            } catch (error) {
                alert('手动重建失败: ' + error.message);
            }
        }

        // 📁 从文件恢复
        async function recoverFromFile() {
            const fileInput = document.getElementById('recovery-file-input');
            const file = fileInput.files[0];

            if (!file) {
                alert('请先选择一个备份文件');
                return;
            }

            try {
                addRecoveryLog(`开始读取文件: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`);

                const text = await file.text();
                const exportData = JSON.parse(text);

                if (!exportData.characters || !Array.isArray(exportData.characters)) {
                    throw new Error('文件格式不正确，缺少角色信息');
                }

                addRecoveryLog(`文件中发现 ${exportData.characters.length} 个角色`);

                // 过滤掉张三李四
                const validCharacters = exportData.characters.filter(char =>
                    char.name !== '张三' && char.name !== '李四'
                );

                addRecoveryLog(`过滤后有效角色: ${validCharacters.length} 个`);

                if (validCharacters.length === 0) {
                    throw new Error('文件中没有找到有效的角色数据');
                }

                // 🔥【安全修复】恢复角色数据
                await safeDataSave('characters', validCharacters);
                characters = validCharacters;

                // 恢复联系人列表
                const validContactIds = validCharacters.map(char => char.id);
                contacts = validContactIds;
                await saveContacts();

                addRecoveryLog('角色数据恢复完成');

                // 恢复聊天记录
                if (exportData.chatMessages) {
                    await db.chatMessages.clear();
                    let messageCount = 0;

                    for (const [characterId, messages] of Object.entries(exportData.chatMessages)) {
                        if (messages && messages.length > 0) {
                            for (const message of messages) {
                                await db.chatMessages.add({
                                    characterId: characterId,
                                    ...message
                                });
                                messageCount++;
                            }
                        }
                    }
                    chatMessages = exportData.chatMessages;
                    addRecoveryLog(`聊天记录恢复完成: ${messageCount} 条消息`);
                }

                // 刷新界面
                renderCharacterList();
                renderContactList();
                renderMessageList();

                addRecoveryLog('✅ 文件恢复成功！');
                alert('数据恢复成功！您的角色和聊天记录已恢复。');

            } catch (error) {
                addRecoveryLog('❌ 文件恢复失败: ' + error.message);
                alert('文件恢复失败: ' + error.message);
            }
        }

        async function cleanupBadData() {
            try {
                addRecoveryLog('开始清理异常数据...');

                // 清除张三李四
                const deletedCount = await db.characters.where('name').anyOf(['张三', '李四']).delete();
                addRecoveryLog(`删除了 ${deletedCount} 个异常角色`);

                // 更新内存数据
                characters = characters.filter(char => char.name !== '张三' && char.name !== '李四');
                contacts = contacts.filter(id => {
                    const char = characters.find(c => c.id === id);
                    return char && char.name !== '张三' && char.name !== '李四';
                });

                await saveContacts();

                // 刷新界面
                renderCharacterList();
                renderContactList();
                renderMessageList();

                addRecoveryLog('✅ 异常数据清理完成');
                alert('异常数据清理完成');

            } catch (error) {
                addRecoveryLog('❌ 清理失败: ' + error.message);
                alert('清理失败: ' + error.message);
            }
        }

        async function forceReload() {
            try {
                addRecoveryLog('开始强制重新加载数据...');

                // 重新加载所有数据
                await loadCharacterGroups();
                await loadCharacters();
                await loadContacts();
                await loadChatMessages();
                await loadChatSettings();
                await loadPersonas();
                await loadGroupChats();

                // 刷新界面
                renderCharacterList();
                renderContactList();
                renderMessageList();

                addRecoveryLog('✅ 数据重新加载完成');
                alert('数据重新加载完成');

            } catch (error) {
                addRecoveryLog('❌ 重新加载失败: ' + error.message);
                alert('重新加载失败: ' + error.message);
            }
        }

        // 🔥【新增】线下剧情模式功能
        let isOfflineMode = false;
        let offlinePresets = [];
        let currentOfflinePreset = null;
        let offlineMessages = [];

        // 🔥【新增】窗口唯一标识符，确保不同窗口的线下模式数据完全隔离
        let windowId = null;

        // 初始化窗口ID
        function initializeWindowId() {
            // 尝试从sessionStorage获取现有的窗口ID
            windowId = sessionStorage.getItem('windowId');

            if (!windowId) {
                // 生成新的窗口ID
                windowId = `window_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                sessionStorage.setItem('windowId', windowId);
            }

            console.log('🪟 窗口ID已初始化:', windowId);

            // 🔥【修复】移除beforeunload监听器，以防止刷新时清除数据
            // window.addEventListener('beforeunload', cleanupWindowOfflineData);
        }

        // 🔥【修复】删除cleanupWindowOfflineData函数，以防止刷新时清除数据
        /*
        function cleanupWindowOfflineData() {
            if (!windowId) return;

            try {
                // 清理localStorage中的线下消息数据
                const keys = Object.keys(localStorage);
                keys.forEach(key => {
                    if (key.includes(`_${windowId}`)) {
                        localStorage.removeItem(key);
                        console.log(`🧹 清理窗口数据: ${key}`);
                    }
                });

                console.log(`🪟 窗口${windowId}的线下模式数据已清理`);
            } catch (error) {
                console.error('清理窗口线下模式数据失败:', error);
            }
        }
        */

        // 🔥【已废弃】迁移功能已移至数据库版本13中自动处理

        // 切换线下模式
        function toggleOfflineMode() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'warning');
                return;
            }

            // 🔥【修复】在切换模式前，强制清空旧的聊天记录数组
            // 这将确保每次都为当前角色加载正确的聊天记录
            offlineMessages = [];

            isOfflineMode = !isOfflineMode;
            const overlay = document.getElementById('offline-mode-overlay');
            const icon = document.getElementById('offline-mode-icon');
            const chatScreen = document.getElementById('api-chat-screen');
            const offlineTitle = document.getElementById('offline-mode-title');

            if (isOfflineMode) {
                // 进入线下模式
                overlay.style.display = 'flex';
                icon.className = 'fas fa-door-closed';
                chatScreen.classList.add('offline-mode-active');

                // 更新标题为当前角色名字
                if (offlineTitle && currentChatCharacter) {
                    offlineTitle.textContent = currentChatCharacter.name;
                }

                // 🔥【新增】暂停当前角色的主动发消息计时器
                pauseProactiveChatTimer(currentChatCharacter.id);

                // 加载线下模式的消息
                loadOfflineMessages();

                // 🔥【新增】加载并应用界面设置
                loadAndApplyOfflineUISettings();

                showToast('已进入线下剧情模式', 'success');
            } else {
                // 退出线下模式
                exitOfflineMode();
            }
        }

        // 退出线下模式
        function exitOfflineMode() {
            // 检查是否有线下模式的聊天记录
            if (offlineMessages.length > 0) {
                showOfflineExitModal();
            } else {
                // 没有聊天记录，直接退出
                doExitOfflineMode();
            }
        }

        // 显示线下模式退出选项模态框
        function showOfflineExitModal() {
            const modal = document.createElement('div');
            modal.className = 'modal offline-exit-modal'; // 添加特定类名
            modal.style.display = 'flex';
            modal.style.zIndex = '10001';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 400px;">
                    <div class="modal-header">
                        <h3>退出线下模式</h3>
                        <button class="modal-close" onclick="this.closest('.modal').remove()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="modal-body">
                        <p>请选择退出方式：</p>
                        <div style="margin-top: 15px;">
                            <button class="btn btn-primary" onclick="exitWithoutSummary()">
                                <i class="fas fa-check"></i> 结束且不总结（推荐）
                            </button>
                            <button class="btn btn-secondary" onclick="exitTemporarily()">
                                <i class="fas fa-pause"></i> 暂时离开
                            </button>
                            <button class="btn" onclick="exitWithSummary()" id="summary-btn" style="background: #f8f9fa !important; color: #000000 !important; border: 1px solid #000000 !important; font-weight: bold !important;">
                                <i class="fas fa-book"></i> 结束并总结
                            </button>
                        </div>
                        <p style="font-size: 12px; color: #666; margin-top: 10px;">
                            • <strong>结束且不总结</strong>：结束剧情，对话记录保存到线下模式聊天记录中<br>
                            • <strong>暂时离开</strong>：保留当前对话状态，可以稍后继续剧情<br>
                            • <strong>结束并总结</strong>：生成AI剧情摘要并保存到记忆系统和聊天记录中
                        </p>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        // 🔥【修改】生成剧情总结并退出
        async function exitWithSummary() {
            try {
                // 🔥【新增】显示加载状态
                const summaryButton = document.querySelector('#summary-btn');
                const originalHTML = summaryButton.innerHTML;
                summaryButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> AI正在总结中...';
                summaryButton.disabled = true;

                // 禁用其他按钮防止重复点击
                const otherButtons = document.querySelectorAll('.offline-exit-modal .btn:not(#summary-btn)');
                otherButtons.forEach(btn => btn.disabled = true);

                showToast('正在生成剧情总结...', 'info');
                await generateOfflineStorylineSummary();

                // 🔥【修复】确保模态框关闭
                const modal = document.querySelector('.offline-exit-modal');
                if (modal) modal.remove();

                doExitOfflineMode();
                showToast('已生成剧情总结并退出线下模式', 'success');
            } catch (error) {
                console.error('生成剧情总结失败:', error);

                // 🔥【修复】恢复按钮状态
                const summaryButton = document.querySelector('#summary-btn');
                if (summaryButton) {
                    summaryButton.innerHTML = '<i class="fas fa-book"></i> 结束并生成剧情总结';
                    summaryButton.disabled = false;
                }

                // 恢复其他按钮状态
                const otherButtons = document.querySelectorAll('.offline-exit-modal .btn:not(#summary-btn)');
                otherButtons.forEach(btn => btn.disabled = false);

                // 🔥【修复】确保模态框关闭
                const modal = document.querySelector('.offline-exit-modal');
                if (modal) modal.remove();

                doExitOfflineMode();
                showToast('生成剧情总结失败，但已退出线下模式', 'warning');
            }
        }

        // 暂时离开（不生成摘要）
        function exitTemporarily() {
            // 🔥【修复】使用精确的选择器找到退出模态框
            const modal = document.querySelector('.offline-exit-modal');
            if (modal) {
                modal.remove();
                console.log('✅ 暂时离开：模态框已关闭');
            } else {
                console.log('❌ 暂时离开：找不到模态框');
            }

            // 🔥【修复】暂时离开时不清空消息，保持线下模式状态
            console.log(`📝 暂时离开线下模式，保留${offlineMessages.length}条消息`);

            doExitOfflineMode();
            showToast('已暂时离开线下模式', 'info');
        }

        // 结束且不总结（推荐选项）
        async function exitWithoutSummary() {
            const modal = document.querySelector('.offline-exit-modal');
            if (modal) {
                modal.remove();
                console.log('✅ 结束且不总结：模态框已关闭');
            } else {
                console.log('❌ 结束且不总结：找不到模态框');
            }

            // 🔥【修复】如果有聊天记录，保存到线下模式聊天记录中
            if (offlineMessages.length > 0) {
                console.log(`📝 保存线下模式对话到聊天记录中，共${offlineMessages.length}条消息`);

                // 生成简单的对话摘要
                const summary = `线下模式对话记录 - ${new Date().toLocaleString()} (${offlineMessages.length}条消息)`;

                // 保存到线下模式聊天记录
                await saveOfflineHistoryRecord(summary, offlineMessages.slice());

                // 🔥【关键修复】确保线下模式消息已经保存到主聊天记录中
                // 检查主聊天记录中是否包含所有线下消息
                const characterId = currentChatCharacter.id;
                if (chatMessages[characterId]) {
                    const offlineMessagesInMain = chatMessages[characterId].filter(msg => msg.isOfflineMode);
                    console.log(`📊 主聊天记录中的线下消息: ${offlineMessagesInMain.length}条`);
                    console.log(`📊 当前线下消息数组: ${offlineMessages.length}条`);

                    // 确保主聊天记录已保存
                    await saveChatMessages(characterId);
                    console.log('✅ 已确保线下模式消息保存到主聊天记录中');
                } else {
                    console.warn('⚠️ 主聊天记录为空，这可能导致记忆连接问题');
                }

                // 清空线下消息记录
                offlineMessages = [];
                saveOfflineMessages(); // 保存清空状态到localStorage

                showToast('已结束线下模式，对话已保存到聊天记录', 'success');
            } else {
                console.log('📝 没有线下模式对话需要保存');
                showToast('已结束线下模式', 'success');
            }

            doExitOfflineMode();
        }

        // 实际执行退出线下模式
        function doExitOfflineMode() {
            isOfflineMode = false;
            const overlay = document.getElementById('offline-mode-overlay');
            const icon = document.getElementById('offline-mode-icon');
            const chatScreen = document.getElementById('api-chat-screen');

            overlay.style.display = 'none';
            icon.className = 'fas fa-door-open';
            chatScreen.classList.remove('offline-mode-active');

            // 🔥【新增】恢复当前角色的主动发消息计时器
            if (currentChatCharacter) {
                resumeProactiveChatTimer(currentChatCharacter.id);
            }

            // 🔥【修复】清空线下模式界面内容
            const offlineMessagesContainer = document.getElementById('offline-chat-messages');
            if (offlineMessagesContainer) {
                offlineMessagesContainer.innerHTML = '';
                console.log('✅ 已清空线下模式界面内容');
            }
        }

        // 🔥【新增】生成线下模式剧情总结
        async function generateOfflineStorylineSummary() {
            if (!currentChatCharacter || offlineMessages.length === 0) {
                return;
            }

            console.log('📖 开始生成线下模式剧情总结...');

            try {
                // 构建对话历史
                let conversationHistory = '';
                offlineMessages.forEach((msg, index) => {
                    const role = msg.sender === 'user' ? '用户' : currentChatCharacter.name;
                    conversationHistory += `${role}：${msg.content}\n`;
                });

                // 🔥【修改】构建剧情总结生成prompt，统一使用第三人称
                const summaryPrompt = `请为以下线下剧情模式的对话生成一个简洁客观的剧情总结，要求：
1. 使用客观的上帝视角，加入合理的文学性描写
2. 避免过多的修辞和形容词
3. 简明扼要地描述事件发生的顺序和关键情节与细节
4. 不要添加任何不在原文中的情感描写
5. 使用清晰的时间和因果关系
6. 统一使用第三人称叙述：用"用户"指代用户，用"${currentChatCharacter.name}"指代角色
7. 不要使用"我"、"你"等第一、第二人称

角色信息：
${currentChatCharacter.name}

对话历史：
${conversationHistory}

请生成一个200-800字的客观剧情总结，要求：
1. 按时间顺序记录发生的主要事件
2. 客观描述角色的行为和对话要点，使用"用户"和"${currentChatCharacter.name}"来指代双方
3. 记录重要的情节转折和结果
4. 避免过度的主观情感描述和过度修饰
5. 使用简洁明了的语言
6. 重点记录关键细节和对后续剧情有影响的关键信息
7. 严格使用第三人称：用户做了什么，${currentChatCharacter.name}如何回应

请以客观记录的方式总结这段剧情：`;

                console.log('📖 剧情总结生成prompt:', summaryPrompt);

                // 调用API生成摘要
                const summary = await callOfflineChatAPI(summaryPrompt, currentChatCharacter);

                // 🔥【新增】显示完整的总结内容
                console.log('📖 生成的完整剧情总结:', summary);

                if (summary && summary.trim()) {
                    // 🔥【修复】保存到跨应用时间线数据库，使用正确的表名和字段结构
                    const timelineMemory = {
                        id: `offline_summary_${currentChatCharacter.id}_${Date.now()}`, // 🔥【修复】添加必需的主键
                        characterId: currentChatCharacter.id,
                        appType: 'offline_mode',
                        action: 'storyline_summary',
                        timestamp: Date.now(),
                        context: {
                            type: 'offline_storyline',
                            content: `[剧情模式] ${summary.trim()}`,
                            date: new Date().toISOString().split('T')[0],
                            messageCount: offlineMessages.length,
                            importance: 0.9 // 剧情总结重要性很高
                        },
                        messageId: `offline_summary_${Date.now()}`
                    };

                    await db.crossAppTimeline.add(timelineMemory);
                    console.log('📖 线下模式剧情总结已保存到跨应用时间线:', timelineMemory);

                    // 🔥【新增】保存聊天记录到历史记录
                    saveOfflineHistoryRecord(summary.trim(), offlineMessages.slice());

                    // 🔥【关键修复】确保线下模式消息已经保存到主聊天记录中
                    // 检查主聊天记录中是否包含所有线下消息
                    const characterId = currentChatCharacter.id;
                    if (chatMessages[characterId]) {
                        const offlineMessagesInMain = chatMessages[characterId].filter(msg => msg.isOfflineMode);
                        console.log(`📊 主聊天记录中的线下消息: ${offlineMessagesInMain.length}条`);
                        console.log(`📊 当前线下消息数组: ${offlineMessages.length}条`);

                        // 确保主聊天记录已保存
                        await saveChatMessages(characterId);
                        console.log('✅ 已确保线下模式消息保存到主聊天记录中');
                    } else {
                        console.warn('⚠️ 主聊天记录为空，这可能导致记忆连接问题');
                    }

                    // 🔥【修复】清空线下模式消息
                    offlineMessages = [];
                    saveOfflineMessages();
                } else {
                    throw new Error('生成的剧情总结为空');
                }

            } catch (error) {
                console.error('生成线下模式剧情总结失败:', error);
                throw error;
            }
        }

        // 显示线下预设设置
        function showOfflinePresetSettings() {
            document.getElementById('offline-preset-modal').style.display = 'flex';

            // 加载并显示已保存的预设
            loadAndDisplayPresets();

            // 清空表单
            clearPresetForm();
        }

        // 关闭线下预设设置
        function closeOfflinePresetSettings() {
            document.getElementById('offline-preset-modal').style.display = 'none';
            // 清理编辑状态
            delete window.editingPresetId;
        }

        // 清空预设表单
        function clearPresetForm() {
            document.getElementById('offline-preset-name').value = '';
            document.getElementById('offline-preset-content').value = '';
        }

        // 加载并显示已保存的预设
        async function loadAndDisplayPresets() {
            try {
                // 🔥【修复】从Dexie数据库加载预设，避免isGlobal字段的索引问题
                const allPresets = await db.offlinePresets.toArray();
                const presets = allPresets.filter(preset => preset.isGlobal === true);
                const container = document.getElementById('saved-presets-list');

                container.innerHTML = '';

                if (presets.length === 0) {
                    return; // CSS会显示"暂无保存的预设"
                }

                // 按时间戳排序，最新的在前
                presets.sort((a, b) => b.timestamp - a.timestamp);

                presets.forEach(preset => {
                    const presetDiv = document.createElement('div');
                    presetDiv.className = 'preset-item';
                    if (currentOfflinePreset && currentOfflinePreset.id === preset.id) {
                        presetDiv.classList.add('active');
                    }

                    const presetInfo = document.createElement('div');
                    presetInfo.className = 'preset-info';

                    const presetName = document.createElement('div');
                    presetName.className = 'preset-name';
                    presetName.textContent = preset.name;

                    const presetPreview = document.createElement('div');
                    presetPreview.className = 'preset-preview';
                    presetPreview.textContent = preset.content.substring(0, 50) + (preset.content.length > 50 ? '...' : '');

                    presetInfo.appendChild(presetName);
                    presetInfo.appendChild(presetPreview);

                    const presetActions = document.createElement('div');
                    presetActions.className = 'preset-actions';

                    // 使用按钮
                    const useBtn = document.createElement('button');
                    useBtn.className = 'preset-action-btn use-btn';
                    useBtn.innerHTML = '<i class="fas fa-check"></i>';
                    useBtn.title = '使用此预设';
                    useBtn.onclick = () => usePreset(preset);

                    // 编辑按钮
                    const editBtn = document.createElement('button');
                    editBtn.className = 'preset-action-btn edit-btn';
                    editBtn.innerHTML = '<i class="fas fa-edit"></i>';
                    editBtn.title = '编辑预设';
                    editBtn.onclick = () => editPreset(preset);

                    // 删除按钮
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'preset-action-btn delete-btn';
                    deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                    deleteBtn.title = '删除预设';
                    deleteBtn.onclick = () => deletePreset(preset.id);

                    presetActions.appendChild(useBtn);
                    presetActions.appendChild(editBtn);
                    presetActions.appendChild(deleteBtn);

                    presetDiv.appendChild(presetInfo);
                    presetDiv.appendChild(presetActions);

                    container.appendChild(presetDiv);
                });

                console.log(`✅ 加载了 ${presets.length} 个线下模式预设`);
            } catch (error) {
                console.error('❌ 加载线下模式预设失败:', error);
                showToast('加载预设失败', 'error');
            }
        }

        // 使用预设
        function usePreset(preset) {
            currentOfflinePreset = preset;
            loadAndDisplayPresets(); // 刷新列表显示
            showToast(`已启用预设"${preset.name}"`, 'success');
        }

        // 编辑预设
        function editPreset(preset) {
            document.getElementById('offline-preset-name').value = preset.name;
            document.getElementById('offline-preset-content').value = preset.content;

            // 临时存储正在编辑的预设ID
            window.editingPresetId = preset.id;
        }

        // 删除预设
        async function deletePreset(presetId) {
            if (!confirm('确定要删除这个预设吗？')) {
                return;
            }

            try {
                // 🔥【修改】从Dexie数据库删除预设
                const preset = await db.offlinePresets.get(presetId);
                if (!preset) {
                    showToast('预设不存在', 'warning');
                    return;
                }

                await db.offlinePresets.delete(presetId);

                // 如果删除的是当前使用的预设，清空当前预设
                if (currentOfflinePreset && currentOfflinePreset.id === presetId) {
                    currentOfflinePreset = null;
                }

                await loadAndDisplayPresets(); // 刷新列表
                showToast(`预设"${preset.name}"已删除`, 'info');
                console.log(`✅ 删除预设: ${preset.name} (${presetId})`);
            } catch (error) {
                console.error('❌ 删除预设失败:', error);
                showToast('删除预设失败', 'error');
            }
        }

        // 保存线下预设
        async function saveOfflinePreset() {
            const name = document.getElementById('offline-preset-name').value.trim();
            const content = document.getElementById('offline-preset-content').value.trim();

            if (!name) {
                showToast('请输入预设名称', 'warning');
                return;
            }

            if (!content) {
                showToast('请输入预设内容', 'warning');
                return;
            }

            try {
                // 检查是否是编辑现有预设
                if (window.editingPresetId) {
                    // 🔥【修改】更新Dexie数据库中的预设
                    const existingPreset = await db.offlinePresets.get(window.editingPresetId);
                    if (existingPreset) {
                        // 更新现有预设
                        existingPreset.name = name;
                        existingPreset.content = content;
                        existingPreset.timestamp = Date.now(); // 更新时间戳

                        await db.offlinePresets.put(existingPreset);

                        // 如果正在编辑的是当前使用的预设，更新当前预设
                        if (currentOfflinePreset && currentOfflinePreset.id === window.editingPresetId) {
                            currentOfflinePreset = existingPreset;
                        }

                        delete window.editingPresetId;

                        await loadAndDisplayPresets(); // 刷新列表
                        clearPresetForm();
                        showToast(`预设"${name}"已更新`, 'success');
                        console.log(`✅ 更新预设: ${name} (${existingPreset.id})`);
                        return;
                    }
                    delete window.editingPresetId;
                }

                // 🔥【修改】创建新预设并保存到Dexie数据库
                const preset = {
                    id: `preset_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    name: name,
                    content: content,
                    timestamp: Date.now(),
                    isGlobal: true
                };

                await db.offlinePresets.add(preset);

                // 设置为当前预设
                currentOfflinePreset = preset;

                await loadAndDisplayPresets(); // 刷新列表
                clearPresetForm();
                showToast(`预设"${name}"已保存并启用`, 'success');
                console.log(`✅ 保存新预设: ${name} (${preset.id})`);
            } catch (error) {
                console.error('❌ 保存预设失败:', error);
                showToast('保存预设失败', 'error');
            }
        }

        // 加载线下消息
        function loadOfflineMessages() {
            if (!currentChatCharacter || !windowId) return;

            // 🔥【修复】只有当offlineMessages为空时才从localStorage加载
            // 这样可以避免在退出后重新进入时重新加载已清空的数据
            if (!offlineMessages || offlineMessages.length === 0) {
                // 🔥【修复】加入窗口ID，确保不同窗口的线下消息完全隔离
                const key = `offlineMessages_${currentChatCharacter.id}_${windowId}`;
                offlineMessages = JSON.parse(localStorage.getItem(key) || '[]');
                console.log(`📱 从localStorage加载线下消息 (窗口${windowId}): ${offlineMessages.length}条`);
            } else {
                console.log(`📱 使用内存中的线下消息 (窗口${windowId}): ${offlineMessages.length}条`);
            }

            // 🔥【修改】加载全局预设从Dexie数据库
            loadLatestOfflinePreset();

            renderOfflineMessages();
        }

        // 🔥【新增】加载最新的线下模式预设
        async function loadLatestOfflinePreset() {
            try {
                // 🔥【修复】避免isGlobal字段的索引问题
                const allPresets = await db.offlinePresets.toArray();
                const presets = allPresets.filter(preset => preset.isGlobal === true);

                if (presets.length > 0) {
                    // 按时间戳排序，使用最新的预设
                    presets.sort((a, b) => b.timestamp - a.timestamp);
                    currentOfflinePreset = presets[0];
                    console.log(`✅ 加载最新预设: ${currentOfflinePreset.name}`);
                } else {
                    currentOfflinePreset = null;
                    console.log('📝 没有可用的线下模式预设');
                }
            } catch (error) {
                console.error('❌ 加载线下模式预设失败:', error);
                currentOfflinePreset = null;
            }
        }

        // 渲染线下消息
        function renderOfflineMessages() {
            const container = document.getElementById('offline-chat-messages');
            container.innerHTML = '';

            offlineMessages.forEach(message => {
                const messageDiv = document.createElement('div');
                messageDiv.className = `offline-message ${message.sender}`;
                messageDiv.dataset.messageId = message.id;

                // 添加头像
                const avatarDiv = document.createElement('div');
                avatarDiv.className = `offline-avatar ${message.sender === 'user' ? 'user-avatar' : 'ai-avatar'}`;

                if (message.sender === 'user') {
                    // 🔥【修复】正确获取用户身份面具卡头像
                    let userAvatar = null;
                    let userName = '用户';

                    // 获取当前聊天设置
                    const chatSettings = getCurrentChatSettings();

                    // 优先级1：聊天专属头像设置
                    if (chatSettings.myChatAvatar) {
                        userAvatar = chatSettings.myChatAvatar;
                    }

                    // 优先级2：身份面具卡头像
                    if (!userAvatar && chatSettings.selectedIdentityId) {
                        const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                        if (selectedPersona) {
                            userAvatar = selectedPersona.avatarUrl;
                            userName = selectedPersona.name;
                        }
                    }

                    // 优先级3：全局用户头像
                    if (!userAvatar && window.userAvatar) {
                        userAvatar = window.userAvatar;
                    }

                    if (userAvatar && userAvatar.trim()) {
                        avatarDiv.style.backgroundImage = `url(${userAvatar})`;
                        avatarDiv.style.backgroundSize = 'cover';
                        avatarDiv.style.backgroundPosition = 'center';
                        avatarDiv.textContent = '';
                    } else {
                        // 使用默认头像生成函数
                        const defaultAvatar = createDefaultAvatar(userName);
                        avatarDiv.style.backgroundImage = `url(${defaultAvatar})`;
                        avatarDiv.style.backgroundSize = 'cover';
                        avatarDiv.style.backgroundPosition = 'center';
                        avatarDiv.textContent = '';
                    }
                } else {
                    // 🔥【修复】正确获取角色头像
                    let aiAvatar = null;

                    if (currentChatCharacter) {
                        // 获取当前聊天设置
                        const chatSettings = getCurrentChatSettings();

                        // 优先级1：动态头像
                        if (chatSettings.aiDynamicAvatar) {
                            aiAvatar = chatSettings.aiDynamicAvatar;
                        }
                        // 优先级2：聊天专属头像
                        else if (chatSettings.aiChatAvatar) {
                            aiAvatar = chatSettings.aiChatAvatar;
                        }
                        // 优先级3：角色卡原始头像
                        else if (currentChatCharacter.avatarUrl) {
                            aiAvatar = currentChatCharacter.avatarUrl;
                        }
                        // 优先级4：角色卡avatar字段（兼容性）
                        else if (currentChatCharacter.avatar) {
                            aiAvatar = currentChatCharacter.avatar;
                        }
                    }

                    if (aiAvatar && aiAvatar.trim()) {
                        avatarDiv.style.backgroundImage = `url(${aiAvatar})`;
                        avatarDiv.style.backgroundSize = 'cover';
                        avatarDiv.style.backgroundPosition = 'center';
                        avatarDiv.textContent = '';
                    } else {
                        // 使用默认头像生成函数
                        const characterName = currentChatCharacter?.name || 'AI';
                        const defaultAvatar = createDefaultAvatar(characterName);
                        avatarDiv.style.backgroundImage = `url(${defaultAvatar})`;
                        avatarDiv.style.backgroundSize = 'cover';
                        avatarDiv.style.backgroundPosition = 'center';
                        avatarDiv.textContent = '';
                    }
                }

                const contentDiv = document.createElement('div');
                contentDiv.className = 'offline-message-content';
                // 🔥【修改】使用新的格式化函数处理文本
                contentDiv.innerHTML = formatOfflineText(message.content);

                messageDiv.appendChild(avatarDiv);
                messageDiv.appendChild(contentDiv);

                // 🔥【修复】为所有消息（用户和AI）添加长按功能
                addOfflineMessageLongPressListener(messageDiv, message.id);

                container.appendChild(messageDiv);
            });

            // 滚动到底部
            container.scrollTop = container.scrollHeight;

            // 🔥【新增】应用界面设置到新渲染的消息
            applyOfflineUISettings();
        }

        // 发送线下消息
        async function sendOfflineMessage() {
            const input = document.getElementById('offline-input');
            const content = input.value.trim();

            if (!content) return;
            if (!currentChatCharacter) return;

            // 🔥【修复】将线下模式消息直接存储到主聊天记录中，保证时间线连贯性
            const characterId = currentChatCharacter.id;

            if (!chatMessages[characterId]) {
                chatMessages[characterId] = [];
            }

            const userChatMessage = {
                id: Date.now(),
                sender: 'sent', // 使用标准的sender格式
                content: content,
                timestamp: Date.now(),
                type: 'text',
                isOfflineMode: true // 标记为线下模式消息
            };

            chatMessages[characterId].push(userChatMessage);

            // 保存到主聊天记录中
            await saveChatMessages(characterId);

            // 添加用户消息到线下模式显示
            const userMessage = {
                id: Date.now().toString(),
                sender: 'user',
                content: content,
                timestamp: new Date().toISOString()
            };

            offlineMessages.push(userMessage);
            input.value = '';
            renderOfflineMessages();

            // 保存线下消息
            saveOfflineMessages();

            // 🔥【新增】显示AI回复加载动画
            showOfflineLoadingMessage();

            // 生成AI回复
            try {
                const aiResponse = await generateOfflineResponse(content);

                // 🔥【修复】将AI回复添加到主聊天记录中，保证时间线连贯性
                const aiChatMessage = {
                    id: Date.now() + 1,
                    sender: 'received', // 使用标准的sender格式
                    content: aiResponse,
                    timestamp: Date.now() + 1,
                    type: 'text',
                    isOfflineMode: true // 标记为线下模式消息
                };

                chatMessages[characterId].push(aiChatMessage);
                await saveChatMessages(characterId);

                const aiMessage = {
                    id: (Date.now() + 1).toString(),
                    sender: 'ai',
                    content: aiResponse,
                    timestamp: new Date().toISOString()
                };

                offlineMessages.push(aiMessage);

                // 🔥【新增】移除加载动画并渲染消息
                hideOfflineLoadingMessage();
                renderOfflineMessages();
                saveOfflineMessages();

            } catch (error) {
                console.error('生成线下回复失败:', error);
                // 🔥【新增】出错时也要移除加载动画
                hideOfflineLoadingMessage();
                showToast('生成回复失败', 'error');
            }
        }

        // 线下模式专用的API调用函数
        async function callOfflineChatAPI(prompt, character) {
            if (!apiSettings.key) {
                throw new Error('请先设置API密钥');
            }

            // 使用与线上模式相同的API设置
            const isGemini = apiSettings.base.includes('generativelanguage.googleapis.com');

            if (isGemini) {
                // Gemini API 格式
                const apiUrl = `${apiSettings.base}/models/${apiSettings.model}:generateContent?key=${apiSettings.key}`;

                const requestBody = {
                    contents: [
                        {
                            role: "user",
                            parts: [
                                {
                                    text: `你是${character.name}，${character.prompt}。现在处于线下剧情模式，请以纯文本形式回复，专注于情景描写和剧情发展。\n\n${prompt}`
                                }
                            ]
                        }
                    ],
                    generationConfig: {
                        temperature: apiSettings.temperature || 0.8
                        // 移除maxOutputTokens，Gemini不支持这个参数
                    }
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    throw new Error(`API请求失败: ${response.status}`);
                }

                const data = await response.json();
                console.log('🔥 线下模式Gemini API完整响应:', JSON.stringify(data, null, 2));

                // 完全按照线上模式的逻辑处理
                const content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!content) {
                    console.log('🔥 Gemini API 响应数据:', data);
                    console.log('🔥 candidates[0]:', data.candidates?.[0]);
                    if (data.candidates?.[0]?.content) {
                        console.log('🔥 content:', data.candidates[0].content);
                    }
                    if (data.candidates?.[0]?.content?.parts) {
                        console.log('🔥 parts:', data.candidates[0].content.parts);
                    }
                    return '抱歉，我现在无法回复。'; // 不要抛出错误，直接返回默认回复
                }

                return content;

            } else {
                // OpenAI 格式
                let baseUrl = apiSettings.base;
                let apiUrl;
                if (baseUrl.endsWith('/v1')) {
                    apiUrl = `${baseUrl}/chat/completions`;
                } else {
                    apiUrl = `${baseUrl}/v1/chat/completions`;
                }

                const requestBody = {
                    model: apiSettings.model,
                    messages: [
                        {
                            role: "system",
                            content: `你是${character.name}，${character.prompt}。现在处于线下剧情模式，请以纯文本形式回复，专注于情景描写和剧情发展。`
                        },
                        {
                            role: "user",
                            content: prompt
                        }
                    ],
                    temperature: apiSettings.temperature || 0.8,
                    max_tokens: 1000
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiSettings.key}`
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    throw new Error(`API请求失败: ${response.status}`);
                }

                const data = await response.json();
                console.log('线下模式OpenAI API响应数据:', data);

                const content = data.choices?.[0]?.message?.content;
                if (!content) {
                    console.error('OpenAI API返回了空内容或格式异常:', data);
                    throw new Error('OpenAI API返回了空内容');
                }

                return content;
            }
        }

        // 生成线下模式的AI回复
        async function generateOfflineResponse(userInput) {
            const character = currentChatCharacter;

            console.log('🎭 ===== 线下模式AI回复生成开始 =====');
            console.log('🎭 当前角色:', character.name);
            console.log('🎭 用户输入:', userInput);

            // 🔥【新增】使用与线上模式相同的记忆系统构建prompt
            let prompt = `你现在处于线下剧情模式，需要以纯文本形式回复，不要使用JSON格式。

【重要提示】用户消息中的括号()内容是环境描写、动作描写或心理活动，你可以观察到这些信息作为背景，但不能表现得像是"听到"了用户的内心想法。你只能对括号外的实际话语进行回应，可以通过观察用户的可见行为（如犹豫、停顿等）来推测情况，但不能直接回应用户的内心想法。

`;

            // 🔥【新增】获取聊天设置和记忆数据
            const chatSettings = getCurrentChatSettings();
            console.log('⚙️ 聊天设置:', chatSettings);

            // 获取动态记忆数据
            let dynamicMemoryContent = '';
            const enableDynamicMemory = chatSettings.enableDynamicMemory !== false; // 默认为true
            console.log('📱 动态记忆开关:', enableDynamicMemory);
            if (enableDynamicMemory) {
                try {
                    const recentMoments = await getVisibleMomentsForCharacter(character.id, 5);
                    console.log('📱 获取到的动态数量:', recentMoments.length);
                    if (recentMoments.length > 0) {
                        dynamicMemoryContent = '\n\n【最新动态记忆】以下是最近的动态内容，你可以在对话中自然地提及：\n';
                        recentMoments.forEach((moment, index) => {
                            const authorName = moment.authorId === 'user' ? '用户' : moment.nickname;
                            dynamicMemoryContent += `${index + 1}. ${authorName}: ${moment.text}\n`;
                            console.log(`📱 动态 ${index + 1}: ${authorName} - ${moment.text}`);
                        });
                    } else {
                        console.log('📱 没有可用的动态记忆');
                    }
                } catch (error) {
                    console.error('获取动态记忆失败:', error);
                }
            }

            // 获取全局记忆数据
            let globalMemoryContent = '';
            try {
                const memorySettings = getGlobalMemorySettings();
                console.log('🧠 记忆设置:', memorySettings);

                const currentContext = {
                    type: 'private_chat',
                    id: character.id
                };
                console.log('🧠 当前上下文:', currentContext);

                // 🔥【修复】线下模式强制启用全局记忆读取，但不存储
                console.log('🧠 线下模式：强制启用全局记忆读取...');
                globalMemoryContent = await buildGlobalMemoryContext(character.id, currentContext, memorySettings.memoryDays);
                console.log('🧠 获取到的全局记忆内容:', globalMemoryContent);
                if (globalMemoryContent && globalMemoryContent.trim()) {
                    console.log('🧠 线下模式已获取全局记忆上下文，总长度:', globalMemoryContent.length);
                    console.log('🧠 线下模式全局记忆内容预览:', globalMemoryContent.substring(0, 200) + '...');
                } else {
                    console.log('🧠 全局记忆内容为空');
                }
            } catch (error) {
                console.error('获取全局记忆失败:', error);
            }

            // 添加角色信息
            const characterPrompt = character.prompt || character.bio || `你是${character.name}。`;
            console.log('👤 角色人设:', characterPrompt);
            console.log('👤 角色完整信息:', character);
            prompt += `角色信息：\n${characterPrompt}\n\n`;

            // 🔥【新增】添加世界书信息
            let worldbookContent = '';
            try {
                const localBookIds = chatSettings.selectedWorldbooks || [];
                const globalBooks = window.activeGlobalWorldbooks || [];
                const allBookIds = [...new Set([...globalBooks, ...localBookIds])]; // 合并并去重

                console.log('📚 世界书ID列表:', allBookIds);
                console.log('📚 全局世界书:', globalBooks);
                console.log('📚 局部世界书:', localBookIds);
                console.log('📚 所有世界书数据:', worldbooks);

                if (allBookIds.length > 0) {
                    worldbookContent = '\n【世界书信息】以下是相关的世界设定：\n';
                    allBookIds.forEach((bookId, index) => {
                        const worldbook = worldbooks.find(w => w.id === bookId);
                        if (worldbook) {
                            console.log(`📚 找到世界书 ${index + 1}: ${worldbook.name || worldbook.title}`);
                            worldbookContent += `${index + 1}. ${worldbook.name || worldbook.title}: ${worldbook.content}\n`;
                        } else {
                            console.log(`📚 未找到世界书ID: ${bookId}`);
                        }
                    });
                    prompt += worldbookContent + '\n';
                    console.log('📚 世界书内容已添加到prompt，长度:', worldbookContent.length);
                } else {
                    console.log('📚 没有可用的世界书');
                }
            } catch (error) {
                console.error('获取世界书失败:', error);
            }

            // 添加记忆内容
            if (globalMemoryContent && globalMemoryContent.trim()) {
                prompt += '\n\n【角色记忆】以下是相关的记忆内容：\n' + globalMemoryContent + '\n';
            }
            if (dynamicMemoryContent) {
                prompt += dynamicMemoryContent + '\n';
            }

            // 添加用户自定义预设（高权重）
            if (currentOfflinePreset) {
                prompt += `【重要】用户自定义剧情预设（请严格遵循）：\n${currentOfflinePreset.content}\n\n`;
            } else {
                prompt += `默认剧情模式要求：\n- 以第三人称视角进行情景描写\n- 包含环境描写、动作描写、心理描写\n- 每次回复150-300字\n- 营造沉浸式的剧情体验\n- **重要**：用户消息中的括号()内容是环境描写、动作描写或心理活动，你可以观察到这些信息作为背景，但不能表现得像是"听到"了用户的内心想法。你只能对括号外的实际话语进行回应，可以通过观察用户的可见行为（如犹豫、停顿等）来推测情况，但不能直接回应用户的内心想法\n\n`;
            }

            // 🔥【修复】读取用户设置的历史消息数，直接从主聊天记录获取完整时间线
            const historyCount = chatSettings.historyCount || 5;

            // 获取主聊天记录（包含线上和线下模式的所有消息，按时间顺序）
            const allMessages = chatMessages[character.id] || [];

            // 根据用户设置的历史消息数获取最近的消息
            const recentChatMessages = allMessages.slice(-historyCount);

            // 统计消息类型
            const onlineCount = recentChatMessages.filter(msg => !msg.isOfflineMode).length;
            const offlineCount = recentChatMessages.filter(msg => msg.isOfflineMode).length;

            console.log('💬 线下模式完整前文记忆:', recentChatMessages);
            console.log(`📊 历史消息统计: 线上${onlineCount}条, 线下${offlineCount}条, 总计使用${recentChatMessages.length}条 (用户设置: ${historyCount}条)`);

            if (recentChatMessages.length > 0) {
                prompt += `最近的对话历史：\n`;
                recentChatMessages.forEach(msg => {
                    // 根据sender字段确定角色
                    const role = (msg.sender === 'sent' || msg.sender === 'user') ? '用户' : character.name;
                    // 标记消息来源（线上/线下）
                    const modeTag = msg.isOfflineMode ? '[线下]' : '[线上]';
                    prompt += `${role}${modeTag}：${msg.content}\n`;
                });
                prompt += `\n`;
            }

            prompt += `用户刚才说：${userInput}\n\n请直接以纯文本形式回复，不要使用JSON数组格式，注重情景描写和氛围营造。`;

            console.log('📝 ===== 完整的Prompt内容 =====');
            console.log(prompt);
            console.log('📝 ===== Prompt结束 =====');

            try {
                // 使用专门的线下模式API调用
                const response = await callOfflineChatAPI(prompt, character);

                // 直接返回响应内容，不进行JSON解析
                return response || '抱歉，我现在无法回复。';
            } catch (error) {
                console.error('线下模式API调用失败:', error);
                throw error;
            }
        }

        // 保存线下消息
        function saveOfflineMessages() {
            if (!currentChatCharacter || !windowId) return;

            // 🔥【修复】加入窗口ID，确保不同窗口的线下消息完全隔离
            const key = `offlineMessages_${currentChatCharacter.id}_${windowId}`;
            localStorage.setItem(key, JSON.stringify(offlineMessages));
            console.log(`💾 保存线下消息到localStorage (窗口${windowId}): ${offlineMessages.length}条`);
        }

        // 重新生成线下模式的最后一条AI回复
        async function regenerateLastOfflineMessage() {
            if (!currentChatCharacter) return;
            if (offlineMessages.length === 0) return;

            // 找到最后一条AI消息
            let lastAiMessageIndex = -1;
            for (let i = offlineMessages.length - 1; i >= 0; i--) {
                if (offlineMessages[i].sender === 'ai') {
                    lastAiMessageIndex = i;
                    break;
                }
            }

            if (lastAiMessageIndex === -1) {
                showToast('没有找到可重新生成的AI消息', 'warning');
                return;
            }

            // 找到对应的用户消息
            let userMessageIndex = -1;
            for (let i = lastAiMessageIndex - 1; i >= 0; i--) {
                if (offlineMessages[i].sender === 'user') {
                    userMessageIndex = i;
                    break;
                }
            }

            if (userMessageIndex === -1) {
                showToast('没有找到对应的用户消息', 'warning');
                return;
            }

            // 删除最后一条AI消息
            offlineMessages.splice(lastAiMessageIndex, 1);
            renderOfflineMessages();
            saveOfflineMessages();

            // 🔥【新增】显示加载动画
            showOfflineLoadingMessage();

            // 重新生成AI回复
            try {
                const userMessage = offlineMessages[userMessageIndex];
                const aiResponse = await generateOfflineResponse(userMessage.content);

                const aiMessage = {
                    id: Date.now().toString(),
                    sender: 'ai',
                    content: aiResponse,
                    timestamp: new Date().toISOString()
                };

                offlineMessages.push(aiMessage);

                // 🔥【新增】移除加载动画并渲染消息
                hideOfflineLoadingMessage();
                renderOfflineMessages();
                saveOfflineMessages();

                showToast('AI回复已重新生成', 'success');

            } catch (error) {
                console.error('重新生成AI回复失败:', error);
                // 🔥【新增】出错时也要移除加载动画
                hideOfflineLoadingMessage();
                showToast('重新生成失败', 'error');
            }
        }

        // 线下模式消息长按监听器
        function addOfflineMessageLongPressListener(messageContainer, messageId) {
            let pressTimer = null;
            let isLongPress = false;

            // 🔥【优化】更准确的移动设备检测
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                             'ontouchstart' in window ||
                             navigator.maxTouchPoints > 0 ||
                             window.innerWidth <= 768;

            const startLongPress = (e) => {
                isLongPress = false;
                // 🔥【优化】移动端和桌面端使用不同的延迟时间
                const delay = isMobile ? 600 : 1000; // 移动端600ms，桌面端1000ms
                pressTimer = setTimeout(() => {
                    isLongPress = true;
                    // 🔥【优化】添加触觉反馈（如果支持）
                    if (navigator.vibrate && isMobile) {
                        navigator.vibrate(50);
                    }
                    showOfflineMessageMenu(messageId, e);
                    e.preventDefault();
                }, delay);
            };

            const cancelLongPress = () => {
                if (pressTimer) {
                    clearTimeout(pressTimer);
                    pressTimer = null;
                }
                setTimeout(() => {
                    isLongPress = false;
                }, 50);
            };

            const handleClick = (e) => {
                if (isLongPress) {
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
            };

            // 触摸事件
            messageContainer.addEventListener('touchstart', startLongPress, { passive: false });
            messageContainer.addEventListener('touchend', cancelLongPress);
            messageContainer.addEventListener('touchmove', cancelLongPress);

            // 鼠标事件（用于桌面端）
            messageContainer.addEventListener('mousedown', startLongPress);
            messageContainer.addEventListener('mouseup', cancelLongPress);
            messageContainer.addEventListener('mouseleave', cancelLongPress);

            // 右键菜单（桌面端）
            messageContainer.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showOfflineMessageMenu(messageId, e);
            });

            // 点击事件
            messageContainer.addEventListener('click', handleClick, true);
        }

        // 显示线下模式消息菜单
        function showOfflineMessageMenu(messageId, event) {
            const message = offlineMessages.find(m => m.id === messageId);
            if (!message) return;

            // 创建菜单
            const menu = document.createElement('div');
            menu.className = 'offline-message-menu';

            // 根据消息类型显示不同的菜单项
            if (message.sender === 'user') {
                menu.innerHTML = `
                    <div class="menu-item" onclick="editOfflineMessage('${messageId}')">
                        <i class="fas fa-edit"></i>
                        <span>修改消息</span>
                    </div>
                    <div class="menu-item delete" onclick="deleteOfflineMessage('${messageId}')">
                        <i class="fas fa-trash"></i>
                        <span>删除消息</span>
                    </div>
                `;
            } else {
                // 🔥【修改】AI消息可以编辑、删除和重新生成
                menu.innerHTML = `
                    <div class="menu-item" onclick="editOfflineMessage('${messageId}')">
                        <i class="fas fa-edit"></i>
                        <span>修改消息</span>
                    </div>
                    <div class="menu-item delete" onclick="deleteOfflineMessage('${messageId}')">
                        <i class="fas fa-trash"></i>
                        <span>删除消息</span>
                    </div>
                    <div class="menu-item" onclick="regenerateOfflineMessage('${messageId}')">
                        <i class="fas fa-redo"></i>
                        <span>重新生成</span>
                    </div>
                `;
            }

            // 移除现有菜单
            const existingMenu = document.querySelector('.offline-message-menu');
            if (existingMenu) {
                existingMenu.remove();
            }

            // 🔥【修复】添加到线下模式容器内，而不是document.body
            const offlineContainer = document.getElementById('offline-mode-overlay');
            if (offlineContainer) {
                offlineContainer.appendChild(menu);
            } else {
                document.body.appendChild(menu);
            }

            // 🔥【修复】定位菜单 - 相对于线下模式容器定位
            const rect = event.target.getBoundingClientRect();
            const containerRect = offlineContainer ? offlineContainer.getBoundingClientRect() : { left: 0, top: 0 };

            // 计算相对于容器的位置
            const relativeLeft = rect.left - containerRect.left;
            const relativeTop = rect.top - containerRect.top;

            // 设置菜单样式
            menu.style.position = 'absolute';
            menu.style.zIndex = '10001';

            // 先添加到DOM以获取菜单尺寸
            setTimeout(() => {
                const menuWidth = menu.offsetWidth || 140;
                const menuHeight = menu.offsetHeight || 100;
                const containerWidth = offlineContainer?.offsetWidth || 400;
                const containerHeight = offlineContainer?.offsetHeight || 600;

                // 计算最佳位置，确保菜单在容器内
                let left = Math.min(relativeLeft, containerWidth - menuWidth - 10);
                let top = relativeTop - menuHeight - 5;

                // 如果上方空间不够，显示在下方
                if (top < 10) {
                    top = relativeTop + 30;
                }

                // 确保不超出容器边界
                left = Math.max(10, left);
                top = Math.max(10, Math.min(top, containerHeight - menuHeight - 10));

                menu.style.left = left + 'px';
                menu.style.top = top + 'px';
            }, 0);

            // 点击其他地方关闭菜单
            const closeMenu = (e) => {
                if (!menu.contains(e.target)) {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                }
            };
            setTimeout(() => {
                document.addEventListener('click', closeMenu);
            }, 100);
        }

        // 编辑线下模式消息
        function editOfflineMessage(messageId) {
            const message = offlineMessages.find(m => m.id === messageId);
            if (!message) return;

            // 创建编辑模态框
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'flex';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 500px;">
                    <div class="modal-header">
                        <h3>${message.sender === 'user' ? '编辑用户消息' : '编辑AI回复'}</h3>
                        <button class="modal-close" onclick="this.closest('.modal').remove()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="modal-body">
                        <textarea id="edit-offline-message-content" placeholder="请输入消息内容..." rows="4" style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px; resize: vertical;">${message.content}</textarea>
                        ${message.sender === 'ai' ? '<p style="color: #666; font-size: 12px; margin-top: 8px;">💡 提示：支持 &lt;span color="颜色"&gt;文本&lt;/span&gt; 和 *斜体* 格式</p>' : ''}
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">取消</button>
                        <button class="btn btn-primary" onclick="saveEditedOfflineMessage('${messageId}')">保存</button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // 🔥【修复】聚焦到文本框但不选中文本，光标移到末尾
            const textarea = modal.querySelector('#edit-offline-message-content');
            textarea.focus();
            textarea.setSelectionRange(textarea.value.length, textarea.value.length);

            // 移除菜单
            const menu = document.querySelector('.offline-message-menu');
            if (menu) menu.remove();
        }

        // 保存编辑的线下消息
        async function saveEditedOfflineMessage(messageId) {
            const textarea = document.getElementById('edit-offline-message-content');
            const newContent = textarea.value.trim();

            if (!newContent) {
                showToast('消息内容不能为空', 'warning');
                return;
            }

            const message = offlineMessages.find(m => m.id === messageId);
            if (message) {
                console.log('✏️ 编辑线下模式消息:', messageId, '新内容:', newContent);

                // 🔥【修复】同时更新主聊天记录中对应的记忆数据
                const characterId = currentChatCharacter.id;
                if (chatMessages[characterId]) {
                    const messageTimestamp = new Date(message.timestamp).getTime();

                    // 🔥【修改】查找并更新对应的消息（支持用户和AI消息）
                    chatMessages[characterId].forEach(msg => {
                        if (msg.isOfflineMode &&
                            ((msg.sender === 'sent' && message.sender === 'user') ||
                             (msg.sender === 'received' && message.sender === 'ai')) &&
                            Math.abs(msg.timestamp - messageTimestamp) < 5000) {
                            console.log('✏️ 更新记忆数据:', msg.content, '->', newContent);
                            msg.content = newContent;
                        }
                    });

                    // 保存更新后的聊天记录
                    await saveChatMessages(characterId);
                }

                // 更新线下模式显示的消息
                message.content = newContent;
                saveOfflineMessages();
                renderOfflineMessages();
                showToast('消息和记忆数据已更新', 'success');
            }

            // 关闭模态框
            const modal = document.querySelector('.modal');
            if (modal) modal.remove();
        }

        // 重新生成AI回复
        async function regenerateOfflineMessage(messageId) {
            const messageIndex = offlineMessages.findIndex(m => m.id === messageId);
            if (messageIndex === -1) return;

            const aiMessage = offlineMessages[messageIndex];
            if (aiMessage.sender !== 'ai') return;

            // 找到对应的用户消息
            let userMessageIndex = messageIndex - 1;
            while (userMessageIndex >= 0 && offlineMessages[userMessageIndex].sender !== 'user') {
                userMessageIndex--;
            }

            if (userMessageIndex < 0) {
                showToast('找不到对应的用户消息', 'error');
                return;
            }

            if (confirm('确定要重新生成这条AI回复吗？')) {
                console.log('🔄 重新生成AI回复:', messageId);

                // 删除当前AI回复
                await deleteOfflineMessage(messageId);

                // 🔥【新增】显示加载动画
                showOfflineLoadingMessage();

                // 重新生成AI回复
                try {
                    const userMessage = offlineMessages[userMessageIndex];
                    const aiResponse = await generateOfflineResponse(userMessage.content);

                    // 🔥【修复】将AI回复添加到主聊天记录中，保证时间线连贯性
                    const aiChatMessage = {
                        id: Date.now() + 1,
                        sender: 'received', // 使用标准的sender格式
                        content: aiResponse,
                        timestamp: Date.now() + 1,
                        type: 'text',
                        isOfflineMode: true // 标记为线下模式消息
                    };

                    const characterId = currentChatCharacter.id;
                    if (!chatMessages[characterId]) {
                        chatMessages[characterId] = [];
                    }
                    chatMessages[characterId].push(aiChatMessage);
                    await saveChatMessages(characterId);

                    const newAiMessage = {
                        id: Date.now().toString(),
                        sender: 'ai',
                        content: aiResponse,
                        timestamp: new Date().toISOString()
                    };

                    offlineMessages.push(newAiMessage);

                    // 🔥【新增】移除加载动画并渲染消息
                    hideOfflineLoadingMessage();
                    renderOfflineMessages();
                    saveOfflineMessages();

                    showToast('AI回复已重新生成', 'success');

                } catch (error) {
                    console.error('重新生成AI回复失败:', error);
                    // 🔥【新增】出错时也要移除加载动画
                    hideOfflineLoadingMessage();
                    showToast('重新生成失败', 'error');
                }
            }
        }

        // 删除线下模式消息
        async function deleteOfflineMessage(messageId) {
            const messageIndex = offlineMessages.findIndex(m => m.id === messageId);
            if (messageIndex === -1) return;

            const message = offlineMessages[messageIndex];

            // 确认删除
            const confirmMessage = message.sender === 'user'
                ? '确定要删除这条消息吗？这将同时删除存储的记忆数据。'
                : '确定要删除这条AI回复吗？这将同时删除存储的记忆数据。';

            if (confirm(confirmMessage)) {
                console.log('🗑️ 开始删除线下模式消息:', messageId, '类型:', message.sender);

                // 🔥【修复】同时删除主聊天记录中对应的记忆数据
                const characterId = currentChatCharacter.id;
                if (chatMessages[characterId]) {
                    const offlineMessage = offlineMessages[messageIndex];
                    const messageTimestamp = new Date(offlineMessage.timestamp).getTime();

                    // 删除对应的记忆数据
                    const messagesToDelete = [];
                    chatMessages[characterId].forEach((msg, index) => {
                        if (msg.isOfflineMode && Math.abs(msg.timestamp - messageTimestamp) < 5000) {
                            messagesToDelete.push(index);
                        }
                    });

                    // 从后往前删除，避免索引变化
                    messagesToDelete.reverse().forEach(index => {
                        console.log('🗑️ 删除记忆数据:', chatMessages[characterId][index]);
                        chatMessages[characterId].splice(index, 1);
                    });

                    // 保存更新后的聊天记录
                    await saveChatMessages(characterId);
                }

                // 🔥【修复】删除线下模式显示的消息
                if (message.sender === 'user') {
                    // 删除用户消息
                    offlineMessages.splice(messageIndex, 1);

                    // 如果下一条是AI回复，也删除
                    if (messageIndex < offlineMessages.length &&
                        offlineMessages[messageIndex].sender === 'ai') {

                        // 同时删除AI回复的记忆数据
                        const aiMessage = offlineMessages[messageIndex];
                        const aiTimestamp = new Date(aiMessage.timestamp).getTime();
                        const aiMessagesToDelete = [];
                        chatMessages[characterId].forEach((msg, index) => {
                            if (msg.isOfflineMode && msg.sender === 'received' &&
                                Math.abs(msg.timestamp - aiTimestamp) < 5000) {
                                aiMessagesToDelete.push(index);
                            }
                        });

                        aiMessagesToDelete.reverse().forEach(index => {
                            console.log('🗑️ 删除AI回复记忆数据:', chatMessages[characterId][index]);
                            chatMessages[characterId].splice(index, 1);
                        });

                        offlineMessages.splice(messageIndex, 1);
                        await saveChatMessages(characterId);
                    }
                } else {
                    // 删除AI消息
                    offlineMessages.splice(messageIndex, 1);
                }

                saveOfflineMessages();
                renderOfflineMessages();
                showToast('消息和记忆数据已删除', 'success');
            }

            // 移除菜单
            const menu = document.querySelector('.offline-message-menu');
            if (menu) menu.remove();
        }

        // 🔥【新增】显示线下模式AI回复加载动画
        function showOfflineLoadingMessage() {
            const container = document.getElementById('offline-chat-messages');

            // 移除已存在的加载动画（防止重复）
            const existingLoading = container.querySelector('.offline-loading-message');
            if (existingLoading) {
                existingLoading.remove();
            }

            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'offline-loading-message';
            loadingDiv.id = 'offline-loading-indicator';

            const contentDiv = document.createElement('div');
            contentDiv.className = 'offline-loading-content';

            const dotsDiv = document.createElement('div');
            dotsDiv.className = 'offline-loading-dots';

            // 创建三个加载点
            for (let i = 0; i < 3; i++) {
                const dot = document.createElement('div');
                dot.className = 'offline-loading-dot';
                dotsDiv.appendChild(dot);
            }

            contentDiv.appendChild(dotsDiv);
            loadingDiv.appendChild(contentDiv);
            container.appendChild(loadingDiv);

            // 滚动到底部
            container.scrollTop = container.scrollHeight;
        }

        // 🔥【新增】隐藏线下模式AI回复加载动画
        function hideOfflineLoadingMessage() {
            const loadingIndicator = document.getElementById('offline-loading-indicator');
            if (loadingIndicator) {
                loadingIndicator.remove();
            }
        }

        // 🔥【新增】线下模式文本格式化函数
        function formatOfflineText(text) {
            if (!text) return '';

            // 移除所有HTML标签，保留纯文本内容
            let formattedText = text
                .replace(/<p>/gi, '')
                .replace(/<\/p>/gi, '\n\n')
                .replace(/<br\s*\/?>/gi, '\n')
                .replace(/<[^>]*>/g, ''); // 移除所有其他HTML标签

            // 处理**号包裹的加粗：**文本**
            formattedText = formattedText.replace(
                /\*\*([^*]+)\*\*/g,
                '<strong>$1</strong>'
            );

            // 处理*号包裹的斜体：*文本*
            formattedText = formattedText.replace(
                /\*([^*]+)\*/g,
                '<em>$1</em>'
            );

            // 处理换行
            formattedText = formattedText.replace(/\n/g, '<br>');

            // 清理多余的换行
            formattedText = formattedText.replace(/(<br>\s*){3,}/g, '<br><br>');

            return formattedText;
        }

        // 监听输入框回车事件
        document.addEventListener('DOMContentLoaded', function() {
            const offlineInput = document.getElementById('offline-input');
            if (offlineInput) {
                offlineInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendOfflineMessage();
                    }
                });
            }
        });

        // 🔥【新增】线下模式聊天记录管理功能

        // 保存聊天记录到历史记录
        async function saveOfflineHistoryRecord(summary, messages) {
            if (!currentChatCharacter || !messages || messages.length === 0) return;

            try {
                const historyRecord = {
                    id: `offline_history_${currentChatCharacter.id}_${Date.now()}`,
                    characterId: currentChatCharacter.id,
                    timestamp: Date.now(),
                    summary: summary,
                    messages: messages,
                    messageCount: messages.length
                };

                // 保存到 Dexie 数据库
                await db.offlineHistoryRecords.add(historyRecord);

                // 🔥【新增】清理超过20条的旧记录
                const allRecords = await db.offlineHistoryRecords
                    .where('characterId')
                    .equals(currentChatCharacter.id)
                    .reverse()
                    .sortBy('timestamp');

                if (allRecords.length > 20) {
                    const recordsToDelete = allRecords.slice(20);
                    for (const record of recordsToDelete) {
                        await db.offlineHistoryRecords.delete(record.id);
                    }
                }

                console.log('📚 线下模式聊天记录已保存到数据库:', historyRecord);
            } catch (error) {
                console.error('保存线下模式聊天记录失败:', error);
            }
        }

        // 显示线下模式聊天记录模态框
        function showOfflineHistoryModal() {
            if (!currentChatCharacter) return;

            document.getElementById('offline-history-modal').style.display = 'flex';
            loadOfflineHistoryList();
        }

        // 关闭线下模式聊天记录模态框
        function closeOfflineHistoryModal() {
            document.getElementById('offline-history-modal').style.display = 'none';
        }

        // 加载并显示聊天记录列表
        async function loadOfflineHistoryList() {
            if (!currentChatCharacter) return;

            try {
                const historyRecords = await db.offlineHistoryRecords
                    .where('characterId')
                    .equals(currentChatCharacter.id)
                    .reverse()
                    .sortBy('timestamp');

                const container = document.getElementById('offline-history-list');
                container.innerHTML = '';

                if (historyRecords.length === 0) {
                    container.innerHTML = `
                        <div class="empty-history">
                            <i class="fas fa-history" style="font-size: 48px; color: #ccc; margin-bottom: 15px;"></i>
                            <p>还没有线下模式聊天记录</p>
                            <p style="font-size: 12px; color: #999;">完成线下剧情对话后，选择"结束且不总结"或"结束并总结"，聊天记录会保存在这里</p>
                        </div>
                    `;
                    return;
                }

                historyRecords.forEach((record, index) => {
                    const recordElement = document.createElement('div');
                    recordElement.className = 'history-record-item';
                    const date = new Date(record.timestamp).toLocaleDateString();
                    recordElement.innerHTML = `
                        <div class="history-record-header">
                            <div class="history-record-info">
                                <div class="history-record-title">剧情记录 #${historyRecords.length - index}</div>
                                <div class="history-record-meta">${date} • ${record.messageCount}条消息</div>
                            </div>
                            <div class="history-record-actions">
                                <button class="history-action-btn" onclick="viewOfflineHistory('${record.id}')" title="查看详情">
                                    <i class="fas fa-eye"></i>
                                </button>
                                <button class="history-action-btn delete" onclick="deleteOfflineHistory('${record.id}')" title="删除记录">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </div>
                        <div class="history-record-summary">${record.summary.substring(0, 100)}${record.summary.length > 100 ? '...' : ''}</div>
                    `;
                    container.appendChild(recordElement);
                });
            } catch (error) {
                console.error('加载线下模式聊天记录失败:', error);
            }
        }

        // 查看具体的聊天记录
        async function viewOfflineHistory(recordId) {
            if (!currentChatCharacter) return;

            try {
                const record = await db.offlineHistoryRecords.get(recordId);

                if (!record) {
                    showToast('找不到该聊天记录', 'error');
                    return;
                }

            // 创建查看详情的模态框
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'flex';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 600px; max-height: 80vh;">
                    <div class="modal-header">
                        <h3>剧情记录详情</h3>
                        <button class="modal-close" onclick="this.closest('.modal').remove()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="modal-body" style="overflow-y: auto;">
                        <div class="history-detail-info">
                            <p><strong>日期：</strong>${record.date}</p>
                            <p><strong>消息数：</strong>${record.messageCount}条</p>
                            <p><strong>剧情总结：</strong></p>
                            <div class="history-summary-text">${record.summary}</div>
                        </div>
                        <hr style="margin: 20px 0;">
                        <div class="history-messages">
                            <h4>对话记录：</h4>
                            <div class="history-messages-container">
                                ${record.messages.map(msg => `
                                    <div class="history-message ${msg.sender}">
                                        <div class="message-sender">${msg.sender === 'user' ? '用户' : currentChatCharacter.name}</div>
                                        <div class="message-content">${msg.content}</div>
                                        <div class="message-time">${new Date(msg.timestamp).toLocaleTimeString()}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">关闭</button>
                    </div>
                </div>
            `;

                document.body.appendChild(modal);
            } catch (error) {
                console.error('查看线下模式聊天记录失败:', error);
                showToast('查看聊天记录失败', 'error');
            }
        }

        // 删除单个聊天记录
        async function deleteOfflineHistory(recordId) {
            if (!confirm('确定要删除这条聊天记录吗？此操作不可撤销。')) return;
            if (!currentChatCharacter) return;

            try {
                await db.offlineHistoryRecords.delete(recordId);
                loadOfflineHistoryList(); // 重新加载列表
                showToast('聊天记录已删除', 'success');
            } catch (error) {
                console.error('删除线下模式聊天记录失败:', error);
                showToast('删除聊天记录失败', 'error');
            }
        }

        // 清空所有聊天记录
        async function clearAllOfflineHistory() {
            if (!confirm('确定要清空所有线下模式聊天记录吗？此操作不可撤销。')) return;
            if (!currentChatCharacter) return;

            try {
                await db.offlineHistoryRecords
                    .where('characterId')
                    .equals(currentChatCharacter.id)
                    .delete();
                loadOfflineHistoryList(); // 重新加载列表
                showToast('所有聊天记录已清空', 'success');
            } catch (error) {
                console.error('清空线下模式聊天记录失败:', error);
                showToast('清空聊天记录失败', 'error');
            }
        }

        // 🔥【新增】线下模式界面设置功能
        let offlineUISettings = {};

        // 显示线下模式界面设置
        function showOfflineUISettings() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'warning');
                return;
            }

            document.getElementById('offline-ui-settings-modal').style.display = 'flex';
            loadOfflineUISettings();
        }

        // 关闭线下模式界面设置
        function closeOfflineUISettings() {
            document.getElementById('offline-ui-settings-modal').style.display = 'none';
        }

        // 加载线下模式界面设置
        async function loadOfflineUISettings() {
            if (!currentChatCharacter) return;

            const characterId = currentChatCharacter.id;

            try {
                // 🔥【修复】保持窗口隔离的同时增强手机浏览器兼容性
                let settingsRecord = null;
                let loadedFromDB = false;

                // 首先尝试从数据库加载带窗口ID的设置（保持隔离）
                if (windowId) {
                    try {
                        settingsRecord = await db.offlineUISettings.get(`${characterId}_${windowId}_ui_settings`);
                        if (settingsRecord && settingsRecord.settings) {
                            loadedFromDB = true;
                            console.log(`✅ 从数据库加载窗口隔离设置成功 (窗口${windowId})`);
                        }
                    } catch (dbError) {
                        console.warn('数据库加载窗口隔离设置失败:', dbError);
                    }
                }

                // 如果窗口隔离设置加载失败，尝试通用格式（兼容性回退）
                if (!loadedFromDB) {
                    try {
                        settingsRecord = await db.offlineUISettings.get(`${characterId}_ui_settings`);
                        if (settingsRecord && settingsRecord.settings) {
                            loadedFromDB = true;
                            console.log(`✅ 从数据库加载通用格式设置成功（回退模式）`);
                        }
                    } catch (dbError) {
                        console.warn('数据库加载通用格式设置也失败:', dbError);
                    }
                }

                // 如果数据库加载失败，立即尝试localStorage
                if (!loadedFromDB) {
                    try {
                        let savedSettings = null;
                        let storageKey = null;

                        // 优先尝试带窗口ID的设置（保持隔离）
                        if (windowId) {
                            storageKey = `offlineUISettings_${characterId}_${windowId}`;
                            savedSettings = localStorage.getItem(storageKey);
                        }

                        // 如果窗口隔离设置不存在，尝试通用格式（兼容性回退）
                        if (!savedSettings) {
                            storageKey = `offlineUISettings_${characterId}`;
                            savedSettings = localStorage.getItem(storageKey);
                        }

                        if (savedSettings) {
                            const parsedSettings = JSON.parse(savedSettings);
                            settingsRecord = { settings: parsedSettings };
                            console.log(`✅ 从localStorage加载设置成功 (${storageKey})`);

                            // 🔥【增强】异步迁移到数据库，优先保存为窗口隔离格式
                            setTimeout(async () => {
                                try {
                                    const dbKey = windowId ? `${characterId}_${windowId}_ui_settings` : `${characterId}_ui_settings`;
                                    await db.offlineUISettings.put({
                                        id: dbKey,
                                        characterId: characterId,
                                        windowId: windowId || null,
                                        settings: parsedSettings,
                                        timestamp: Date.now()
                                    });
                                    console.log(`✅ 设置已异步迁移到数据库 (${dbKey})`);
                                } catch (migrateError) {
                                    console.warn('异步迁移失败，但不影响当前使用:', migrateError);
                                }
                            }, 100);
                        }
                    } catch (localStorageError) {
                        console.warn('localStorage加载也失败:', localStorageError);
                    }
                }

                if (settingsRecord && settingsRecord.settings) {
                    offlineUISettings = settingsRecord.settings;
                    console.log(`✅ 线下模式界面设置加载成功`);
                } else {
                    console.log(`📝 未找到设置，使用默认设置`);
                    // 默认设置
                    offlineUISettings = {
                        myBubbleColor: '#007AFF',
                        aiBubbleColor: '#f0f0f0',
                        bubbleOpacity: 0.9,
                        fontSize: 15,
                        wallpaperData: '',
                        fontFamily: '',
                        fontUrl: '',
                        userNormalTextColor: '#ffffff',
                        userItalicTextColor: '#f0f0f0',
                        userBoldTextColor: '#ffffff',
                        aiNormalTextColor: '#000000',
                        aiItalicTextColor: '#666666',
                        aiBoldTextColor: '#333333',
                        showUserAvatar: true,
                        showAiAvatar: true,
                        avatarPosition: 'side',
                        bubbleWidth: 'default',
                        bubbleStyle: 'default',
                        customCSS: '',
                        savedColors: {
                            userNormal: [],
                            userItalic: [],
                            userBold: [],
                            aiNormal: [],
                            aiItalic: [],
                            aiBold: []
                        }
                    };
                }

                // 更新界面
                updateOfflineUISettingsForm();
                updateOfflinePreview();

            } catch (error) {
                console.error('加载线下模式界面设置完全失败:', error);
                // 🔥【增强】即使完全失败也要确保有默认设置
                offlineUISettings = {
                    myBubbleColor: '#007AFF',
                    aiBubbleColor: '#f0f0f0',
                    bubbleOpacity: 0.9,
                    fontSize: 15,
                    wallpaperData: '',
                    fontFamily: '',
                    fontUrl: '',
                    userNormalTextColor: '#ffffff',
                    userItalicTextColor: '#f0f0f0',
                    userBoldTextColor: '#ffffff',
                    aiNormalTextColor: '#000000',
                    aiItalicTextColor: '#666666',
                    aiBoldTextColor: '#333333',
                    showUserAvatar: true,
                    showAiAvatar: true,
                    avatarPosition: 'side',
                    bubbleWidth: 'default',
                    bubbleStyle: 'default',
                    customCSS: '',
                    savedColors: {
                        userNormal: [],
                        userItalic: [],
                        userBold: [],
                        aiNormal: [],
                        aiItalic: [],
                        aiBold: []
                    }
                };
                updateOfflineUISettingsForm();
                updateOfflinePreview();
            }
        }

        // 更新设置表单
        function updateOfflineUISettingsForm() {
            document.getElementById('offline-my-bubble-color').value = offlineUISettings.myBubbleColor;
            document.getElementById('offline-ai-bubble-color').value = offlineUISettings.aiBubbleColor;
            document.getElementById('offline-bubble-opacity').value = offlineUISettings.bubbleOpacity;
            document.getElementById('offline-opacity-value').textContent = Math.round(offlineUISettings.bubbleOpacity * 100) + '%';

            // 🔥【新增】设置字体大小
            document.getElementById('offline-font-size').value = offlineUISettings.fontSize || 15;
            document.getElementById('offline-font-size-value').textContent = (offlineUISettings.fontSize || 15) + 'px';

            // 设置字体选择
            document.getElementById('offline-font-select').value = offlineUISettings.fontFamily || '';
            if (offlineUISettings.fontFamily === 'custom') {
                document.getElementById('custom-font-input').style.display = 'block';
                document.getElementById('offline-font-url').value = offlineUISettings.fontUrl || '';
            } else {
                document.getElementById('custom-font-input').style.display = 'none';
            }

            // 设置文字颜色（确保有默认值）
            document.getElementById('offline-user-normal-text-color').value = offlineUISettings.userNormalTextColor || '#ffffff';
            document.getElementById('offline-user-italic-text-color').value = offlineUISettings.userItalicTextColor || '#f0f0f0';
            document.getElementById('offline-user-bold-text-color').value = offlineUISettings.userBoldTextColor || '#ffffff';
            document.getElementById('offline-ai-normal-text-color').value = offlineUISettings.aiNormalTextColor || '#000000';
            document.getElementById('offline-ai-italic-text-color').value = offlineUISettings.aiItalicTextColor || '#666666';
            document.getElementById('offline-ai-bold-text-color').value = offlineUISettings.aiBoldTextColor || '#333333';

            // 设置头像和样式选项
            document.getElementById('offline-show-user-avatar').checked = offlineUISettings.showUserAvatar !== false;
            document.getElementById('offline-show-ai-avatar').checked = offlineUISettings.showAiAvatar !== false;

            // 设置单选按钮
            const avatarPosition = offlineUISettings.avatarPosition || 'side';
            document.querySelector(`input[name="offline-avatar-position"][value="${avatarPosition}"]`).checked = true;

            const bubbleWidth = offlineUISettings.bubbleWidth || 'default';
            document.querySelector(`input[name="offline-bubble-width"][value="${bubbleWidth}"]`).checked = true;

            const bubbleStyle = offlineUISettings.bubbleStyle || 'default';
            document.querySelector(`input[name="offline-bubble-style"][value="${bubbleStyle}"]`).checked = true;

            // 设置自定义CSS
            document.getElementById('offline-custom-css').value = offlineUISettings.customCSS || '';

            // 更新预存颜色
            updateSavedColorsDisplay();

            // 监听透明度滑块变化
            const opacitySlider = document.getElementById('offline-bubble-opacity');
            opacitySlider.oninput = function() {
                const value = Math.round(this.value * 100);
                document.getElementById('offline-opacity-value').textContent = value + '%';
                updateOfflinePreview();
            };

            // 🔥【新增】监听字体大小滑块变化
            const fontSizeSlider = document.getElementById('offline-font-size');
            fontSizeSlider.oninput = function() {
                const value = this.value;
                document.getElementById('offline-font-size-value').textContent = value + 'px';
                updateOfflinePreview();
            };

            // 监听颜色输入变化
            ['offline-my-bubble-color', 'offline-ai-bubble-color',
             'offline-user-normal-text-color', 'offline-user-italic-text-color', 'offline-user-bold-text-color',
             'offline-ai-normal-text-color', 'offline-ai-italic-text-color', 'offline-ai-bold-text-color'].forEach(id => {
                document.getElementById(id).oninput = updateOfflinePreview;
            });

            // 监听头像和样式设置变化
            document.getElementById('offline-show-user-avatar').onchange = updateOfflinePreview;
            document.getElementById('offline-show-ai-avatar').onchange = updateOfflinePreview;

            document.querySelectorAll('input[name="offline-avatar-position"]').forEach(radio => {
                radio.onchange = updateOfflinePreview;
            });

            document.querySelectorAll('input[name="offline-bubble-width"]').forEach(radio => {
                radio.onchange = updateOfflinePreview;
            });

            document.querySelectorAll('input[name="offline-bubble-style"]').forEach(radio => {
                radio.onchange = updateOfflinePreview;
            });

            // 监听单选按钮变化，控制相关功能
            document.querySelectorAll('input[name="offline-avatar-position"]').forEach(radio => {
                radio.onchange = function() {
                    if (this.value === 'custom') {
                        showToast('请在下方CSS代码区域自定义头像位置', 'info');
                    }
                };
            });

            document.querySelectorAll('input[name="offline-bubble-width"]').forEach(radio => {
                radio.onchange = function() {
                    if (this.value === 'custom') {
                        showToast('请在下方CSS代码区域自定义气泡宽度', 'info');
                    } else {
                        // 应用默认80%宽度
                        applyDefaultBubbleWidth();
                    }
                };
            });

            document.querySelectorAll('input[name="offline-bubble-style"]').forEach(radio => {
                radio.onchange = function() {
                    if (this.value === 'custom') {
                        showToast('请在下方CSS代码区域自定义气泡样式', 'info');
                    } else {
                        // 应用默认样式
                        applyDefaultBubbleStyle();
                    }
                };
            });
        }

        // 应用默认气泡宽度
        function applyDefaultBubbleWidth() {
            // 移除自定义宽度样式，恢复CSS规则控制
            const existingStyle = document.getElementById('offline-custom-width-style');
            if (existingStyle) {
                existingStyle.remove();
            }

            showToast('已恢复默认气泡宽度（根据头像显示状态自动调整）', 'success');
        }

        // 应用默认气泡样式
        function applyDefaultBubbleStyle() {
            // 移除自定义样式
            const existingStyle = document.getElementById('offline-custom-style-style');
            if (existingStyle) {
                existingStyle.remove();
            }

            // 应用默认样式（这里可以根据需要添加默认样式）
            showToast('已应用默认气泡样式', 'success');
        }

        // 更新预存颜色显示
        function updateSavedColorsDisplay() {
            const types = ['userNormal', 'userItalic', 'userBold', 'aiNormal', 'aiItalic', 'aiBold'];
            const typeMapping = {
                'userNormal': 'offline-user-normal',
                'userItalic': 'offline-user-italic',
                'userBold': 'offline-user-bold',
                'aiNormal': 'offline-ai-normal',
                'aiItalic': 'offline-ai-italic',
                'aiBold': 'offline-ai-bold'
            };

            types.forEach(type => {
                const container = document.getElementById(`${typeMapping[type]}-saved-colors`);
                if (container) {
                    container.innerHTML = '';

                    if (offlineUISettings.savedColors[type]) {
                        offlineUISettings.savedColors[type].forEach(color => {
                            const colorItem = document.createElement('div');
                            colorItem.className = 'saved-color-item';
                            colorItem.style.backgroundColor = color;
                            colorItem.title = color;
                            colorItem.onclick = () => {
                                document.getElementById(`${typeMapping[type]}-text-color`).value = color;
                                updateOfflinePreview();
                            };
                            container.appendChild(colorItem);
                        });
                    }
                }
            });
        }

        // 更新预览效果
        function updateOfflinePreview() {
            const myBubbleColor = document.getElementById('offline-my-bubble-color').value;
            const aiBubbleColor = document.getElementById('offline-ai-bubble-color').value;
            const bubbleOpacity = document.getElementById('offline-bubble-opacity').value;

            const userNormalTextColor = document.getElementById('offline-user-normal-text-color').value;
            const userItalicTextColor = document.getElementById('offline-user-italic-text-color').value;
            const userBoldTextColor = document.getElementById('offline-user-bold-text-color').value;

            const aiNormalTextColor = document.getElementById('offline-ai-normal-text-color').value;
            const aiItalicTextColor = document.getElementById('offline-ai-italic-text-color').value;
            const aiBoldTextColor = document.getElementById('offline-ai-bold-text-color').value;

            // 更新CSS变量
            const root = document.documentElement;
            root.style.setProperty('--offline-my-bubble-color', myBubbleColor);
            root.style.setProperty('--offline-ai-bubble-color', aiBubbleColor);
            root.style.setProperty('--offline-user-normal-text-color', userNormalTextColor);
            root.style.setProperty('--offline-user-italic-text-color', userItalicTextColor);
            root.style.setProperty('--offline-user-bold-text-color', userBoldTextColor);
            root.style.setProperty('--offline-ai-normal-text-color', aiNormalTextColor);
            root.style.setProperty('--offline-ai-italic-text-color', aiItalicTextColor);
            root.style.setProperty('--offline-ai-bold-text-color', aiBoldTextColor);

            // 更新预览区域
            const userBubble = document.querySelector('.offline-preview-message.user .offline-preview-content');
            const aiBubble = document.querySelector('.offline-preview-message.ai .offline-preview-content');

            if (userBubble) {
                // 使用rgba背景色，只让背景透明，文字保持不透明
                const userBgColor = convertColorWithOpacity(myBubbleColor, bubbleOpacity);
                userBubble.style.backgroundColor = userBgColor;
                userBubble.style.opacity = 1; // 确保整个元素不透明
                userBubble.style.color = userNormalTextColor;

                // 更新用户消息的斜体和加粗文字颜色
                const userItalicText = userBubble.querySelector('em');
                const userBoldText = userBubble.querySelector('strong');
                if (userItalicText) userItalicText.style.color = userItalicTextColor;
                if (userBoldText) userBoldText.style.color = userBoldTextColor;
            }

            if (aiBubble) {
                // 使用rgba背景色，只让背景透明，文字保持不透明
                const aiBgColor = convertColorWithOpacity(aiBubbleColor, bubbleOpacity);
                aiBubble.style.backgroundColor = aiBgColor;
                aiBubble.style.opacity = 1; // 确保整个元素不透明
                aiBubble.style.color = aiNormalTextColor;

                // 更新AI消息的斜体和加粗文字颜色
                const aiItalicText = aiBubble.querySelector('em');
                const aiBoldText = aiBubble.querySelector('strong');
                if (aiItalicText) aiItalicText.style.color = aiItalicTextColor;
                if (aiBoldText) aiBoldText.style.color = aiBoldTextColor;
            }

            // 更新头像显示
            const showUserAvatar = document.getElementById('offline-show-user-avatar').checked;
            const showAiAvatar = document.getElementById('offline-show-ai-avatar').checked;
            const userAvatar = document.getElementById('preview-user-avatar');
            const aiAvatar = document.getElementById('preview-ai-avatar');

            // 获取预览消息容器
            const allPreviewMessages = document.querySelectorAll('.offline-preview-message');

            // 清除所有相关的类
            allPreviewMessages.forEach(container => {
                container.classList.remove('no-user-avatar', 'no-ai-avatar');
            });

            if (userAvatar) {
                userAvatar.style.display = showUserAvatar ? 'flex' : 'none';
            }
            if (aiAvatar) {
                aiAvatar.style.display = showAiAvatar ? 'flex' : 'none';
            }

            // 🔥【修正】根据头像显示状态添加对应的类
            allPreviewMessages.forEach(container => {
                if (!showUserAvatar) {
                    container.classList.add('no-user-avatar');
                }
                if (!showAiAvatar) {
                    container.classList.add('no-ai-avatar');
                }
            });

            // 更新气泡宽度
            const bubbleWidth = document.querySelector('input[name="offline-bubble-width"]:checked').value;
            const avatarPosition = document.querySelector('input[name="offline-avatar-position"]:checked').value;
            const bubbleStyle = document.querySelector('input[name="offline-bubble-style"]:checked').value;

            const previewContents = document.querySelectorAll('.offline-preview-content');
            const previewMessages = document.querySelectorAll('.offline-preview-message');

            // 应用气泡宽度
            previewContents.forEach(content => {
                if (bubbleWidth === 'default') {
                    // 清除内联样式，让CSS规则自动处理宽度（根据头像显示状态）
                    content.style.maxWidth = '';
                } else {
                    // 自定义CSS控制时，如果有CSS代码则应用，否则保持当前样式
                    const customCSS = document.getElementById('offline-custom-css').value.trim();
                    if (customCSS) {
                        // CSS代码会通过预览功能应用
                    }
                }
            });

            // 应用头像位置
            previewMessages.forEach(message => {
                if (avatarPosition === 'side') {
                    // 恢复默认侧边布局
                    if (message.classList.contains('user')) {
                        message.style.flexDirection = 'row-reverse';
                    } else {
                        message.style.flexDirection = 'row';
                    }
                } else {
                    // 自定义CSS控制时，移除内联样式让CSS代码生效
                    message.style.flexDirection = '';
                }
            });
        }

        // 处理壁纸上传
        function handleOfflineWallpaperUpload(input) {
            const file = input.files[0];
            if (!file) return;

            // 检查文件类型
            if (!file.type.startsWith('image/')) {
                showToast('请选择图片文件', 'warning');
                input.value = '';
                return;
            }

            // 检查文件大小（限制为5MB）
            if (file.size > 5 * 1024 * 1024) {
                showToast('图片文件不能超过5MB', 'warning');
                input.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const imageData = e.target.result;

                // 预览壁纸
                const previewArea = document.getElementById('offline-preview-area');
                previewArea.style.backgroundImage = `url(${imageData})`;
                previewArea.style.backgroundSize = 'cover';
                previewArea.style.backgroundPosition = 'center';

                // 保存到设置中
                offlineUISettings.wallpaperData = imageData;

                showToast('壁纸已上传并预览', 'success');
            };
            reader.readAsDataURL(file);
        }

        // 清除壁纸
        function clearOfflineWallpaper() {
            document.getElementById('offline-wallpaper-file').value = '';
            const previewArea = document.getElementById('offline-preview-area');
            previewArea.style.backgroundImage = '';
            offlineUISettings.wallpaperData = '';
            showToast('壁纸已清除', 'success');
        }

        // 处理字体选择变化
        function handleOfflineFontChange() {
            const fontSelect = document.getElementById('offline-font-select');
            const customInput = document.getElementById('custom-font-input');

            if (fontSelect.value === 'custom') {
                customInput.style.display = 'block';
            } else {
                customInput.style.display = 'none';
                // 应用内置字体
                applyBuiltinFont(fontSelect.value);
            }
        }

        // 应用内置字体
        function applyBuiltinFont(fontName) {
            // 清除自定义字体样式，恢复默认字体
            const existingStyle = document.getElementById('offline-custom-font-style');
            if (existingStyle) {
                existingStyle.remove();
            }

            if (fontName) {
                showToast(`已恢复系统默认字体`, 'success');
            }
        }

        // 预览自定义CSS
        function previewOfflineCSS() {
            const cssCode = document.getElementById('offline-custom-css').value.trim();

            // 移除之前的预览样式
            const existingStyle = document.getElementById('offline-custom-css-preview');
            if (existingStyle) {
                existingStyle.remove();
            }

            if (!cssCode) {
                showToast('请输入CSS代码', 'warning');
                return;
            }

            try {
                // 创建样式元素
                const style = document.createElement('style');
                style.id = 'offline-custom-css-preview';

                // 为CSS代码添加作用域，只影响预览区域
                const scopedCSS = cssCode.replace(/\.offline-/g, '.offline-preview-area .offline-');
                style.textContent = scopedCSS;

                document.head.appendChild(style);
                showToast('CSS预览已应用', 'success');

            } catch (error) {
                console.error('CSS预览失败:', error);
                showToast('CSS代码有误，请检查语法', 'error');
            }
        }

        // 清除自定义CSS
        function clearOfflineCSS() {
            document.getElementById('offline-custom-css').value = '';

            // 移除预览样式
            const existingStyle = document.getElementById('offline-custom-css-preview');
            if (existingStyle) {
                existingStyle.remove();
            }

            showToast('CSS代码已清除', 'success');
        }

        // 预览字体
        function previewOfflineFont() {
            const url = document.getElementById('offline-font-url').value.trim();
            if (!url) {
                showToast('请输入字体URL', 'warning');
                return;
            }

            // 清除之前的字体样式
            const existingStyle = document.getElementById('offline-custom-font-style');
            if (existingStyle) {
                existingStyle.remove();
            }
            const existingLink = document.getElementById('offline-custom-font-link');
            if (existingLink) {
                existingLink.remove();
            }

            // 判断是CSS链接还是直接字体文件
            if (url.includes('fonts.googleapis.com') || url.includes('fonts.google.com') || url.endsWith('.css') || url.includes('fontsapi') || url.includes('css')) {
                // Google Fonts或其他CSS链接
                console.log('🎨 开始加载字体CSS:', url);
                const link = document.createElement('link');
                link.id = 'offline-custom-font-link';
                link.rel = 'stylesheet';
                link.href = url;
                link.crossOrigin = 'anonymous'; // 🔥【新增】添加跨域支持
                link.onload = function() {
                    // 🔥【修复】尝试从CSS中提取字体名称，或使用通用名称
                    let fontFamily = extractFontFamilyFromGoogleFonts(url) || 'CustomFont';
                    console.log('🎨 字体CSS加载成功，提取的字体名称:', fontFamily);
                    console.log('🎨 字体URL:', url);

                    // 🔥【新增】尝试从加载的CSS中提取真正的字体名称
                    try {
                        const sheets = document.styleSheets;
                        for (let i = sheets.length - 1; i >= 0; i--) {
                            const sheet = sheets[i];
                            if (sheet.href === url) {
                                try {
                                    const rules = sheet.cssRules || sheet.rules;
                                    for (let j = 0; j < rules.length; j++) {
                                        const rule = rules[j];
                                        if (rule.type === CSSRule.FONT_FACE_RULE && rule.style.fontFamily) {
                                            fontFamily = rule.style.fontFamily.replace(/['"]/g, '');
                                            console.log('🎨 从CSS中提取到真实字体名称:', fontFamily);
                                            break;
                                        }
                                    }
                                } catch (e) {
                                    console.log('🎨 无法读取CSS规则，使用提取的名称');
                                }
                                break;
                            }
                        }
                    } catch (e) {
                        console.log('🎨 CSS解析失败，使用提取的名称');
                    }

                    const style = document.createElement('style');
                    style.id = 'offline-custom-font-style';
                    style.textContent = `
                        .offline-preview-content,
                        #offline-mode-overlay .offline-message-content {
                            font-family: '${fontFamily}', sans-serif !important;
                        }
                    `;
                    document.head.appendChild(style);
                    console.log('🎨 字体样式已应用到页面，最终字体名称:', fontFamily);

                    // 🔥【新增】保存真实的字体名称到全局变量，供保存设置时使用
                    window.previewedFontName = fontFamily;

                    // 🔥【新增】验证字体是否真的被应用
                    setTimeout(() => {
                        const testElement = document.querySelector('#offline-mode-overlay .offline-message-content');
                        if (testElement) {
                            const computedStyle = window.getComputedStyle(testElement);
                            console.log('🎨 实际应用的字体:', computedStyle.fontFamily);
                        }
                    }, 1000);

                    showToast(`字体CSS已加载，字体名称: ${fontFamily}`, 'success');
                };
                link.onerror = function() {
                    console.error('🎨 字体CSS加载失败:', url);
                    showToast('字体CSS加载失败，请检查URL', 'error');
                };
                document.head.appendChild(link);
            } else {
                // 直接字体文件
                const fontName = 'OfflineCustomFont';
                const style = document.createElement('style');
                style.id = 'offline-custom-font-style';
                style.textContent = `
                    @font-face {
                        font-family: '${fontName}';
                        src: url('${url}');
                    }
                    .offline-preview-content,
                    #offline-mode-overlay .offline-message-content {
                        font-family: '${fontName}', sans-serif !important;
                    }
                `;
                document.head.appendChild(style);
                showToast('字体文件预览已应用', 'success');
            }
        }

        // 从Google Fonts URL中提取字体名称
        function extractFontFamilyFromGoogleFonts(url) {
            try {
                // Google Fonts: 匹配 family= 参数
                const match = url.match(/family=([^&:]+)/);
                if (match) {
                    let fontName = decodeURIComponent(match[1]);
                    // 替换 + 为空格，移除权重信息（如 :300,400,700）
                    fontName = fontName.replace(/\+/g, ' ').replace(/:.*$/, '');
                    return fontName;
                }

                // 如果是新版Google Fonts API格式，尝试其他匹配方式
                const match2 = url.match(/family=([^&]+)/);
                if (match2) {
                    let fontName = decodeURIComponent(match2[1]);
                    fontName = fontName.replace(/\+/g, ' ').split(':')[0];
                    return fontName;
                }

                // 🔥【新增】其他字体服务：尝试从URL路径中提取
                const pathMatch = url.match(/\/([^\/]+)\.css/);
                if (pathMatch) {
                    return pathMatch[1].replace(/[-_]/g, ' ');
                }

                // 🔥【新增】尝试从URL中提取数字ID或名称
                const idMatch = url.match(/\/(\d+)\//);
                if (idMatch) {
                    return `CustomFont-${idMatch[1]}`;
                }

                // 🔥【新增】从域名提取服务名称
                const domainMatch = url.match(/\/\/([^.]+)/);
                if (domainMatch) {
                    return `${domainMatch[1]}-Font`;
                }
            } catch (e) {
                console.warn('无法提取字体名称:', e);
            }
            return 'CustomFont'; // 默认字体名称
        }

        // 清除字体
        function clearOfflineFont() {
            document.getElementById('offline-font-url').value = '';
            const existingStyle = document.getElementById('offline-custom-font-style');
            if (existingStyle) {
                existingStyle.remove();
            }
            showToast('字体已清除', 'success');
        }

        // 保存当前颜色到预存
        function saveCurrentOfflineColors() {
            const userNormalColor = document.getElementById('offline-user-normal-text-color').value;
            const userItalicColor = document.getElementById('offline-user-italic-text-color').value;
            const userBoldColor = document.getElementById('offline-user-bold-text-color').value;
            const aiNormalColor = document.getElementById('offline-ai-normal-text-color').value;
            const aiItalicColor = document.getElementById('offline-ai-italic-text-color').value;
            const aiBoldColor = document.getElementById('offline-ai-bold-text-color').value;

            // 添加到预存颜色（避免重复）
            const colorTypes = [
                { type: 'userNormal', color: userNormalColor },
                { type: 'userItalic', color: userItalicColor },
                { type: 'userBold', color: userBoldColor },
                { type: 'aiNormal', color: aiNormalColor },
                { type: 'aiItalic', color: aiItalicColor },
                { type: 'aiBold', color: aiBoldColor }
            ];

            colorTypes.forEach(({ type, color }) => {
                // 确保savedColors[type]存在
                if (!offlineUISettings.savedColors[type]) {
                    offlineUISettings.savedColors[type] = [];
                }

                if (!offlineUISettings.savedColors[type].includes(color)) {
                    offlineUISettings.savedColors[type].push(color);
                }

                // 限制预存颜色数量（最多10个）
                if (offlineUISettings.savedColors[type].length > 10) {
                    offlineUISettings.savedColors[type] = offlineUISettings.savedColors[type].slice(-10);
                }
            });

            updateSavedColorsDisplay();
            showToast('颜色已保存到预存', 'success');
        }

        // 重置为默认颜色
        function resetOfflineColors() {
            document.getElementById('offline-my-bubble-color').value = '#007AFF';
            document.getElementById('offline-ai-bubble-color').value = '#f0f0f0';
            document.getElementById('offline-bubble-opacity').value = 0.9;
            document.getElementById('offline-opacity-value').textContent = '90%'; // 更新透明度显示
            document.getElementById('offline-font-size').value = 15; // 🔥【新增】重置字体大小
            document.getElementById('offline-font-size-value').textContent = '15px'; // 更新字体大小显示
            document.getElementById('offline-user-normal-text-color').value = '#ffffff';
            document.getElementById('offline-user-italic-text-color').value = '#f0f0f0';
            document.getElementById('offline-user-bold-text-color').value = '#ffffff';
            document.getElementById('offline-ai-normal-text-color').value = '#000000';
            document.getElementById('offline-ai-italic-text-color').value = '#666666';
            document.getElementById('offline-ai-bold-text-color').value = '#333333';

            updateOfflinePreview();
            showToast('颜色已重置为默认', 'success');
        }

        // 保存线下模式界面设置
        async function saveOfflineUISettings() {
            const characterId = currentChatCharacter.id;

            try {
                // 收集设置数据
                offlineUISettings = {
                    myBubbleColor: document.getElementById('offline-my-bubble-color').value,
                    aiBubbleColor: document.getElementById('offline-ai-bubble-color').value,
                    bubbleOpacity: parseFloat(document.getElementById('offline-bubble-opacity').value),
                    fontSize: parseInt(document.getElementById('offline-font-size').value), // 🔥【新增】保存字体大小
                    wallpaperData: offlineUISettings.wallpaperData || '',
                    fontFamily: document.getElementById('offline-font-select').value,
                    fontUrl: document.getElementById('offline-font-url').value.trim(),
                    realFontName: window.previewedFontName || '', // 🔥【新增】保存预览时确定的真实字体名称
                    userNormalTextColor: document.getElementById('offline-user-normal-text-color').value,
                    userItalicTextColor: document.getElementById('offline-user-italic-text-color').value,
                    userBoldTextColor: document.getElementById('offline-user-bold-text-color').value,
                    aiNormalTextColor: document.getElementById('offline-ai-normal-text-color').value,
                    aiItalicTextColor: document.getElementById('offline-ai-italic-text-color').value,
                    aiBoldTextColor: document.getElementById('offline-ai-bold-text-color').value,
                    showUserAvatar: document.getElementById('offline-show-user-avatar').checked,
                    showAiAvatar: document.getElementById('offline-show-ai-avatar').checked,
                    avatarPosition: document.querySelector('input[name="offline-avatar-position"]:checked').value,
                    bubbleWidth: document.querySelector('input[name="offline-bubble-width"]:checked').value,
                    bubbleStyle: document.querySelector('input[name="offline-bubble-style"]:checked').value,
                    customCSS: document.getElementById('offline-custom-css').value.trim(),
                    savedColors: offlineUISettings.savedColors || {
                        userNormal: [], userItalic: [], userBold: [],
                        aiNormal: [], aiItalic: [], aiBold: []
                    }
                };

                // 🔥【修改】保存到Dexie数据库（每个角色独立）
                await saveOfflineUISettingsToDB();

                // 应用设置到线下模式界面
                applyOfflineUISettings();

                closeOfflineUISettings();
                showToast('界面设置已保存', 'success');

            } catch (error) {
                console.error('保存线下模式界面设置失败:', error);
                showToast('保存界面设置失败', 'error');
            }
        }

        // 🔥【新增】保存设置到Dexie数据库
        async function saveOfflineUISettingsToDB() {
            if (!currentChatCharacter || !offlineUISettings) return;

            const characterId = currentChatCharacter.id;

            // 🔥【增强】双重保存策略，优先保持窗口隔离
            let dbSaveSuccess = false;
            let localStorageSaveSuccess = false;

            // 首先尝试保存到数据库（优先窗口隔离格式）
            try {
                const dbKey = windowId ? `${characterId}_${windowId}_ui_settings` : `${characterId}_ui_settings`;
                await db.offlineUISettings.put({
                    id: dbKey,
                    characterId: characterId,
                    windowId: windowId || null,
                    settings: offlineUISettings,
                    timestamp: Date.now()
                });
                dbSaveSuccess = true;
                console.log(`✅ 线下模式界面设置已保存到数据库 (${dbKey})`);
            } catch (dbError) {
                console.warn('❌ 保存到数据库失败:', dbError);
            }

            // 同时保存到localStorage作为备份（也优先窗口隔离格式）
            try {
                const storageKey = windowId ? `offlineUISettings_${characterId}_${windowId}` : `offlineUISettings_${characterId}`;
                localStorage.setItem(storageKey, JSON.stringify(offlineUISettings));
                localStorageSaveSuccess = true;
                console.log(`✅ 线下模式界面设置已保存到localStorage (${storageKey})`);
            } catch (localStorageError) {
                console.warn('❌ 保存到localStorage失败:', localStorageError);
            }

            // 如果两种方式都失败，抛出错误
            if (!dbSaveSuccess && !localStorageSaveSuccess) {
                throw new Error('所有保存方式都失败了');
            }
        }

        // 应用线下模式界面设置
        function applyOfflineUISettings() {
            if (!offlineUISettings || !currentChatCharacter) return;

            const offlineOverlay = document.getElementById('offline-mode-overlay');
            if (!offlineOverlay) return;

            // 🔥【修复】获取聊天消息容器并重置背景
            const chatMessages = offlineOverlay.querySelector('.offline-chat-messages');
            if (chatMessages) {
                // 先清除旧背景
                chatMessages.style.backgroundImage = '';
                chatMessages.style.backgroundColor = ''; // 同样重置背景色
            }

            // 确保设置有默认值
            const myBubbleColor = offlineUISettings.myBubbleColor || '#007AFF';
            const aiBubbleColor = offlineUISettings.aiBubbleColor || '#f0f0f0';
            const bubbleOpacity = offlineUISettings.bubbleOpacity !== undefined ? offlineUISettings.bubbleOpacity : 0.9;
            const userNormalTextColor = offlineUISettings.userNormalTextColor || '#ffffff';
            const userItalicTextColor = offlineUISettings.userItalicTextColor || '#f0f0f0';
            const userBoldTextColor = offlineUISettings.userBoldTextColor || '#ffffff';
            const aiNormalTextColor = offlineUISettings.aiNormalTextColor || '#000000';
            const aiItalicTextColor = offlineUISettings.aiItalicTextColor || '#666666';
            const aiBoldTextColor = offlineUISettings.aiBoldTextColor || '#333333';

            // 应用气泡颜色和透明度
            const userBubbles = offlineOverlay.querySelectorAll('.offline-message.user .offline-message-content');
            const aiBubbles = offlineOverlay.querySelectorAll('.offline-message.ai .offline-message-content');

            userBubbles.forEach(bubble => {
                // 使用rgba背景色，只让背景透明，文字保持不透明
                const userBgColor = convertColorWithOpacity(myBubbleColor, bubbleOpacity);
                bubble.style.backgroundColor = userBgColor;
                bubble.style.opacity = 1; // 确保整个元素不透明
                bubble.style.color = userNormalTextColor;

                // 应用用户消息文字颜色
                const italicTexts = bubble.querySelectorAll('em');
                const boldTexts = bubble.querySelectorAll('strong');
                italicTexts.forEach(text => text.style.color = userItalicTextColor);
                boldTexts.forEach(text => text.style.color = userBoldTextColor);
            });

            aiBubbles.forEach(bubble => {
                // 使用rgba背景色，只让背景透明，文字保持不透明
                const aiBgColor = convertColorWithOpacity(aiBubbleColor, bubbleOpacity);
                bubble.style.backgroundColor = aiBgColor;
                bubble.style.opacity = 1; // 确保整个元素不透明
                bubble.style.color = aiNormalTextColor;

                // 应用AI消息文字颜色
                const italicTexts = bubble.querySelectorAll('em');
                const boldTexts = bubble.querySelectorAll('strong');
                italicTexts.forEach(text => text.style.color = aiItalicTextColor);
                boldTexts.forEach(text => text.style.color = aiBoldTextColor);
            });

            // 应用背景壁纸
            if (chatMessages && offlineUISettings.wallpaperData) {
                chatMessages.style.backgroundImage = `url(${offlineUISettings.wallpaperData})`;
                chatMessages.style.backgroundSize = 'cover';
                chatMessages.style.backgroundPosition = 'center';
                chatMessages.style.backgroundAttachment = 'fixed';
            }

            // 应用字体设置
            const fontName = `OfflineFont_${currentChatCharacter.id}`;
            const existingStyle = document.getElementById(`offline-font-${currentChatCharacter.id}`);
            if (existingStyle) {
                existingStyle.remove();
            }
            const existingLink = document.getElementById(`offline-font-link-${currentChatCharacter.id}`);
            if (existingLink) {
                existingLink.remove();
            }

            if (offlineUISettings.fontFamily === 'custom' && offlineUISettings.fontUrl) {
                const url = offlineUISettings.fontUrl;

                // 判断是CSS链接还是直接字体文件
                if (url.includes('fonts.googleapis.com') || url.includes('fonts.google.com') || url.endsWith('.css') || url.includes('fontsapi') || url.includes('css')) {
                    // Google Fonts或其他CSS链接
                    const link = document.createElement('link');
                    link.id = `offline-font-link-${currentChatCharacter.id}`;
                    link.rel = 'stylesheet';
                    link.href = url;
                    link.onload = function() {
                        // 🔥【修复】优先使用保存的真实字体名称
                        let fontFamily = offlineUISettings.realFontName || extractFontFamilyFromGoogleFonts(url) || 'CustomFont';

                        // 🔥【新增】如果没有保存的真实字体名称，尝试从CSS中提取
                        if (!offlineUISettings.realFontName) {
                            try {
                                const sheets = document.styleSheets;
                                for (let i = sheets.length - 1; i >= 0; i--) {
                                    const sheet = sheets[i];
                                    if (sheet.href === url) {
                                        try {
                                            const rules = sheet.cssRules || sheet.rules;
                                            for (let j = 0; j < rules.length; j++) {
                                                const rule = rules[j];
                                                if (rule.type === CSSRule.FONT_FACE_RULE && rule.style.fontFamily) {
                                                    fontFamily = rule.style.fontFamily.replace(/['"]/g, '');
                                                    console.log('🎨 应用设置时从CSS中提取到真实字体名称:', fontFamily);
                                                    break;
                                                }
                                            }
                                        } catch (e) {
                                            console.log('🎨 应用设置时无法读取CSS规则，使用提取的名称');
                                        }
                                        break;
                                    }
                                }
                            } catch (e) {
                                console.log('🎨 应用设置时CSS解析失败，使用提取的名称');
                            }
                        } else {
                            console.log('🎨 使用保存的真实字体名称:', fontFamily);
                        }

                        const style = document.createElement('style');
                        style.id = `offline-font-${currentChatCharacter.id}`;
                        style.textContent = `
                            #offline-mode-overlay .offline-message-content {
                                font-family: '${fontFamily}', sans-serif !important;
                            }
                        `;
                        document.head.appendChild(style);
                        console.log('✅ 线下模式字体已应用:', fontFamily);
                    };
                    document.head.appendChild(link);
                } else {
                    // 直接字体文件
                    const style = document.createElement('style');
                    style.id = `offline-font-${currentChatCharacter.id}`;
                    style.textContent = `
                        @font-face {
                            font-family: '${fontName}';
                            src: url('${url}');
                        }
                        #offline-mode-overlay .offline-message-content {
                            font-family: '${fontName}', sans-serif !important;
                        }
                    `;
                    document.head.appendChild(style);
                }
            }

            // 应用头像显示设置
            const allMessages = offlineOverlay.querySelectorAll('.offline-message');

            allMessages.forEach(messageContainer => {
                const userAvatar = messageContainer.querySelector('.offline-avatar.user-avatar');
                const aiAvatar = messageContainer.querySelector('.offline-avatar.ai-avatar');

                // 清除所有相关的类
                messageContainer.classList.remove('no-user-avatar', 'no-ai-avatar');

                // 处理用户头像显示
                if (userAvatar) {
                    userAvatar.style.display = offlineUISettings.showUserAvatar ? 'flex' : 'none';
                }

                // 处理AI头像显示
                if (aiAvatar) {
                    aiAvatar.style.display = offlineUISettings.showAiAvatar ? 'flex' : 'none';
                }

                // 🔥【修正】根据头像显示状态添加对应的类
                if (!offlineUISettings.showUserAvatar) {
                    messageContainer.classList.add('no-user-avatar');
                }
                if (!offlineUISettings.showAiAvatar) {
                    messageContainer.classList.add('no-ai-avatar');
                }
            });

            // 应用气泡宽度设置
            if (offlineUISettings.bubbleWidth === 'default') {
                // 清除可能存在的自定义宽度样式，让CSS规则自动处理宽度
                const widthStyleId = `offline-width-${currentChatCharacter.id}`;
                const existingWidthStyle = document.getElementById(widthStyleId);
                if (existingWidthStyle) {
                    existingWidthStyle.remove();
                }
                // 不再强制设置80%，让CSS中的头像显示/隐藏规则来控制宽度
            }

            // 应用头像位置设置
            if (offlineUISettings.avatarPosition === 'side') {
                // 应用默认侧边位置
                const avatarStyleId = `offline-avatar-${currentChatCharacter.id}`;
                const existingAvatarStyle = document.getElementById(avatarStyleId);
                if (existingAvatarStyle) {
                    existingAvatarStyle.remove();
                }

                const avatarStyle = document.createElement('style');
                avatarStyle.id = avatarStyleId;
                avatarStyle.textContent = `
                    #offline-mode-overlay .offline-message.user {
                        flex-direction: row; /* 🔥【修正】用户：头像左，气泡右 */
                    }
                    #offline-mode-overlay .offline-message.ai {
                        flex-direction: row-reverse; /* 🔥【修正】AI：头像右，气泡左 */
                    }
                    #offline-mode-overlay .offline-avatar {
                        position: relative;
                        margin: 0;
                    }
                `;
                document.head.appendChild(avatarStyle);
            }

            // 应用自定义CSS（优先级最高）
            if (offlineUISettings.customCSS &&
                (offlineUISettings.avatarPosition === 'custom' ||
                 offlineUISettings.bubbleWidth === 'custom' ||
                 offlineUISettings.bubbleStyle === 'custom')) {

                const customStyleId = `offline-custom-${currentChatCharacter.id}`;
                const existingCustomStyle = document.getElementById(customStyleId);
                if (existingCustomStyle) {
                    existingCustomStyle.remove();
                }

                const customStyle = document.createElement('style');
                customStyle.id = customStyleId;

                // 为CSS代码添加作用域，只影响当前线下模式
                const scopedCSS = offlineUISettings.customCSS.replace(/\.offline-/g, '#offline-mode-overlay .offline-');
                customStyle.textContent = scopedCSS;

                document.head.appendChild(customStyle);
            }

            // 🔥【新增】应用字体大小设置
            if (offlineUISettings.fontSize !== undefined) {
                const messageContents = offlineOverlay.querySelectorAll('.offline-message-content');
                messageContents.forEach(content => {
                    content.style.fontSize = `${offlineUISettings.fontSize}px`;
                });
            }
        }

        // 重置线下模式界面设置
        async function resetOfflineUISettings() {
            if (confirm('确定要重置所有界面设置为默认值吗？')) {
                // 重置为默认设置
                offlineUISettings = {
                    myBubbleColor: '#007AFF',
                    aiBubbleColor: '#f0f0f0',
                    bubbleOpacity: 0.9,
                    fontSize: 15, // 🔥【新增】重置字体大小为默认值
                    wallpaperData: '',
                    fontFamily: '',
                    fontUrl: '',
                    userNormalTextColor: '#ffffff',
                    userItalicTextColor: '#f0f0f0',
                    userBoldTextColor: '#ffffff',
                    aiNormalTextColor: '#000000',
                    aiItalicTextColor: '#666666',
                    aiBoldTextColor: '#333333',
                    showUserAvatar: true,
                    showAiAvatar: true,
                    avatarPosition: 'side',
                    bubbleWidth: 'default',
                    bubbleStyle: 'default',
                    customCSS: '',
                    savedColors: {
                        userNormal: [], userItalic: [], userBold: [],
                        aiNormal: [], aiItalic: [], aiBold: []
                    }
                };

                // 清除文件输入
                document.getElementById('offline-wallpaper-file').value = '';

                // 🔥【新增】清除数据库中的设置
                if (currentChatCharacter) {
                    try {
                        await db.offlineUISettings.delete(`${currentChatCharacter.id}_ui_settings`);
                        console.log('✅ 数据库中的设置已清除');
                    } catch (error) {
                        console.error('清除数据库设置失败:', error);
                    }
                }

                updateOfflineUISettingsForm();
                updateOfflinePreview();
                showToast('界面设置已重置', 'success');
            }
        }

        // 在进入线下模式时加载并应用界面设置
        async function loadAndApplyOfflineUISettings() {
            if (!currentChatCharacter) return;

            const characterId = currentChatCharacter.id;

            try {
                // 🔥【修复】保持窗口隔离的同时增强手机浏览器兼容性
                let settingsLoaded = false;

                // 首先尝试从localStorage加载（更稳定），优先窗口隔离格式
                try {
                    let savedSettings = null;
                    let storageKey = null;

                    // 优先尝试带窗口ID的设置（保持隔离）
                    if (windowId) {
                        storageKey = `offlineUISettings_${characterId}_${windowId}`;
                        savedSettings = localStorage.getItem(storageKey);
                    }

                    // 如果窗口隔离设置不存在，尝试通用格式（兼容性回退）
                    if (!savedSettings) {
                        storageKey = `offlineUISettings_${characterId}`;
                        savedSettings = localStorage.getItem(storageKey);
                    }

                    if (savedSettings) {
                        offlineUISettings = JSON.parse(savedSettings);
                        settingsLoaded = true;
                        console.log(`✅ 从localStorage加载线下模式界面设置成功 (${storageKey})`);
                    }
                } catch (localStorageError) {
                    console.warn('从localStorage加载失败:', localStorageError);
                }

                // 如果localStorage加载失败，尝试从数据库加载
                if (!settingsLoaded) {
                    try {
                        let settingsRecord = null;

                        // 优先尝试带窗口ID的设置（保持隔离）
                        if (windowId) {
                            settingsRecord = await db.offlineUISettings.get(`${characterId}_${windowId}_ui_settings`);
                        }

                        // 如果窗口隔离设置不存在，尝试通用格式（兼容性回退）
                        if (!settingsRecord) {
                            settingsRecord = await db.offlineUISettings.get(`${characterId}_ui_settings`);
                        }

                        if (settingsRecord && settingsRecord.settings) {
                            offlineUISettings = settingsRecord.settings;
                            settingsLoaded = true;
                            console.log(`✅ 从数据库加载线下模式界面设置成功`);
                        }
                    } catch (dbError) {
                        console.warn('从数据库加载失败:', dbError);
                    }
                }

                // 如果成功加载设置，应用它们
                if (settingsLoaded) {
                    applyOfflineUISettings();
                    console.log(`✅ 线下模式界面设置已应用`);
                }
            } catch (error) {
                console.error('加载线下模式界面设置失败:', error);
            }
        }

        // 🔥【新增】选择函数
        function selectAvatarPosition(value, element) {
            // 移除所有选中状态
            const siblings = element.parentNode.querySelectorAll('.radio-option-button');
            siblings.forEach(btn => btn.classList.remove('selected'));

            // 添加选中状态
            element.classList.add('selected');

            // 更新隐藏的radio按钮
            const radios = element.parentNode.querySelectorAll('input[name="offline-avatar-position"]');
            radios.forEach(radio => {
                radio.checked = radio.value === value;
            });
        }

        function selectBubbleWidth(value, element) {
            // 移除所有选中状态
            const siblings = element.parentNode.querySelectorAll('.radio-option-button');
            siblings.forEach(btn => btn.classList.remove('selected'));

            // 添加选中状态
            element.classList.add('selected');

            // 更新隐藏的radio按钮
            const radios = element.parentNode.querySelectorAll('input[name="offline-bubble-width"]');
            radios.forEach(radio => {
                radio.checked = radio.value === value;
            });
        }

        function selectBubbleStyle(value, element) {
            // 移除所有选中状态
            const siblings = element.parentNode.querySelectorAll('.radio-option-button');
            siblings.forEach(btn => btn.classList.remove('selected'));

            // 添加选中状态
            element.classList.add('selected');

            // 更新隐藏的radio按钮
            const radios = element.parentNode.querySelectorAll('input[name="offline-bubble-style"]');
            radios.forEach(radio => {
                radio.checked = radio.value === value;
            });
        }

document.addEventListener('visibilitychange', function() {
    const phoneScreen = document.getElementById('phone-screen');
    if (!phoneScreen) return;

    if (document.visibilityState === 'visible') {
        // 页面变为可见状态
        console.log("✅ 页面恢复可见，正在恢复动画和定时器...");
        
        // 1. 恢复所有 CSS 动画
        phoneScreen.style.animationPlayState = 'running';
        const animatedElements = document.querySelectorAll('[style*="animation"]');
        animatedElements.forEach(el => el.style.animationPlayState = 'running');

        // 2. 强制浏览器进行一次重绘，清除残留的线条
        // 这是一个常用的小技巧，通过快速改变一个不影响布局的属性来触发重绘
        phoneScreen.style.opacity = '0.99';
        setTimeout(() => {
            phoneScreen.style.opacity = '1';
        }, 16); // 16ms 约等于一帧的时间

        // 3. 如果您有通过 setInterval 启动的复杂JS动画，可以在这里重新启动它们
        // 例如：重新启动时钟（虽然时钟通常影响不大，但作为示例）
        if (typeof updateTime === 'function') {
           // 如果之前有清除定时器，在这里重新设置
           // setInterval(updateTime, 1000);
        }

    } else {
        // 页面变为隐藏状态
        console.log("💤 页面已隐藏，暂停动画以节省资源...");

        // 1. 暂停所有 CSS 动画
        phoneScreen.style.animationPlayState = 'paused';
        const animatedElements = document.querySelectorAll('[style*="animation"]');
        animatedElements.forEach(el => el.style.animationPlayState = 'paused');

        // 2. 如果有复杂的JS动画定时器，可以在这里清除它们
        // clearInterval(yourAnimationTimer);
    }
});

// 添加音乐播放器文件选择事件监听器
document.addEventListener('DOMContentLoaded', function() {
    // 本地音乐文件选择
    const localMusicInput = document.getElementById('local-music-input');
    if (localMusicInput) {
        localMusicInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const urlInput = document.getElementById('song-url-input');
                const titleInput = document.getElementById('song-title-input');

                urlInput.placeholder = `已选择: ${file.name}`;
                urlInput.style.color = '#007AFF';
                urlInput.value = ''; // 清空URL输入

                // 自动填充歌曲标题
                if (!titleInput.value.trim()) {
                    titleInput.value = file.name.replace(/\.[^/.]+$/, "");
                }
            }
        });
    }

    // 歌词文件选择
    const lyricsFileInput = document.getElementById('lyrics-file-input');
    if (lyricsFileInput) {
        lyricsFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const lyricsInput = document.getElementById('song-lyrics-input');
                const fileName = file.name.toLowerCase();
                let fileType = '歌词文件';

                if (fileName.endsWith('.lrc')) {
                    fileType = 'LRC歌词';
                } else if (fileName.endsWith('.bin')) {
                    fileType = 'bin歌词';
                } else if (fileName.endsWith('.txt')) {
                    fileType = 'TXT歌词';
                } else {
                    // 对于其他文件类型，给出提示但仍然允许选择
                    fileType = '文件';
                    console.log('选择的文件可能不是标准歌词格式，但仍会尝试处理:', file.name);
                }

                lyricsInput.placeholder = `已选择${fileType}: ${file.name}`;
                lyricsInput.style.color = '#007AFF';
                lyricsInput.value = ''; // 清空手动输入的歌词
            }
        });
    }
});
    </script>
</body>
</html>