<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>EVE Chat</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ’¬</text></svg>">
    <script src="https://cdn.jsdelivr.net/npm/dexie/dist/dexie.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@400;500;600;700&family=Comic+Neue:wght@400;700&family=Fredoka+One&family=Nunito:wght@400;500;600;700&family=Montserrat:wght@400;500;600&family=Inter:wght@400;500;600&family=Roboto:wght@400;500&family=Raleway:wght@400;500;600&family=Lato:wght@400;700&family=Poppins:wght@400;500;600&family=Quicksand:wght@400;500;600&family=Varela+Round&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css?v=20250721-fix-bubble-width">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <!-- ğŸ”¥ã€æ–°å¢ã€‘çŠ¶æ€æŒ‡ç¤ºå™¨æ ·å¼ -->
    <style>
        /* è§’è‰²åˆ—è¡¨çŠ¶æ€æŒ‡ç¤ºå™¨ */
        .contact-status-indicator {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            z-index: 10;
        }

        /* å·²æ‹‰é»‘çŠ¶æ€ - çº¢è‰² */
        .contact-status-indicator.blocked {
            background-color: #ff4444;
            color: white;
        }

        /* è¢«æ‹‰é»‘çŠ¶æ€ - æ·±æ©™è‰² */
        .contact-status-indicator.blocked-by {
            background-color: #ff8800;
            color: white;
        }

        /* å·²å±è”½ç¾¤èŠçŠ¶æ€ - æ©™è‰² */
        .contact-status-indicator.muted {
            background-color: #ff9500;
            color: white;
        }

        /* ç¡®ä¿è§’è‰²é¡¹æœ‰ç›¸å¯¹å®šä½ */
        .contact-item {
            position: relative;
        }

        /* ğŸ”¥ã€æ–°å¢ã€‘æ¶ˆæ¯åˆ—è¡¨çŠ¶æ€æŒ‡ç¤ºå™¨æ ·å¼ */
        .message-avatar-container {
            position: relative;
            display: inline-block;
        }

        .message-status-indicator {
            position: absolute;
            right: 2px;
            bottom: 1px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            z-index: 10;
        }

        /* å·²æ‹‰é»‘çŠ¶æ€ - çº¢è‰² */
        .message-status-indicator.blocked {
            background-color: #ff4444;
            color: white;
        }

        /* è¢«æ‹‰é»‘çŠ¶æ€ - æ·±æ©™è‰² */
        .message-status-indicator.blocked-by {
            background-color: #ff8800;
            color: white;
        }

        /* å·²å±è”½ç¾¤èŠçŠ¶æ€ - æ©™è‰² */
        .message-status-indicator.muted {
            background-color: #ff9500;
            color: white;
        }

        /* ğŸ”¥ã€æ–°å¢ã€‘æœªè¯»æ¶ˆæ¯æç¤ºæ ·å¼ */
        .unread-badge {
            position: absolute;
            right: -2px;
            top: -2px;
            min-width: 16px;
            height: 16px;
            border-radius: 50%;
            background-color: #ff4444;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            z-index: 15;
            padding: 0 4px;
            box-sizing: border-box;
        }

        /* å½“æ•°å­—è¶…è¿‡99æ—¶ï¼Œæ˜¾ç¤º99+ */
        .unread-badge.large-count {
            font-size: 8px;
            min-width: 20px;
            border-radius: 10px;
        }

        /* ğŸ”¥ã€é‡æ–°è®¾è®¡ã€‘æ¶ˆæ¯åˆ—è¡¨å¤šé€‰æ¨¡å¼æŒ‰é’® - æ”¾åœ¨app-headerä¸­ */
        .chat-header-multiselect-actions {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .multiselect-btn {
            padding: 4px 8px;
            border: none;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
            min-width: 50px;
            width: 50px;
            height: 24px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            white-space: nowrap;
            flex-shrink: 0;
            color: white;
        }

        .multiselect-btn i {
            font-size: 10px;
        }

        .multiselect-btn.pin-btn {
            background: rgba(243, 156, 18, 0.85);
        }

        .multiselect-btn.delete-btn {
            background: rgba(231, 76, 60, 0.85);
        }

        .multiselect-btn.cancel-btn {
            background: rgba(52, 152, 219, 0.85);
        }

        /* ğŸ”¥ã€é‡æ–°è®¾è®¡ã€‘ç½®é¡¶å¯¹è¯çš„è§†è§‰æ ‡è¯† - ä¸»é¢˜åŒ–é¢œè‰² */
        .message-item.pinned {
            background: rgba(74, 132, 193, 0.08);
            border-left: 3px solid rgba(74, 132, 193, 0.3);
        }

        /* å¯çˆ±ä¸»é¢˜ä¸‹çš„ç½®é¡¶å¯¹è¯æ ·å¼ */
        body[data-theme="cute"] .message-item.pinned {
            background: rgba(255, 182, 193, 0.08);
            border-left: 3px solid rgba(255, 182, 193, 0.3);
        }

        .pin-indicator {
            position: absolute;
            top: 5px;
            right: 5px;
            color: #ffd700;
            font-size: 12px;
            z-index: 5;
        }
    </style>

</head>
<body>
        <!-- æ¨é€é€šçŸ¥å®¹å™¨ -->
        <div id="notification-container"></div>
    <div id="phone-frame">
    <div id="phone-screen">
        <div class="wallpaper" id="wallpaper-element">
            <!-- ä¸»å±å¹•çŠ¶æ€æ  -->
            <div id="status-bar">
                <span id="status-bar-time">14:25</span>
                <div id="status-bar-battery" class="battery-container">
                    <span class="battery-text">á°”á©š</span>
                    <div class="battery-icon">
                        <div class="battery-level"></div>
                    </div>
                </div>
            </div>

            <!-- éŸ³ä¹æ˜¾ç¤ºåŒºåŸŸï¼ˆç±»ä¼¼çµåŠ¨å²›ï¼‰ - ç‹¬ç«‹äºçŠ¶æ€æ  -->
            <div id="music-status-display" class="music-status-display" style="display: none;" onclick="openMusicModal()">
                <i class="fas fa-headphones music-icon"></i>
                <div class="music-lyrics-scroll">
                    <span id="current-lyric">â™ª ç‚¹å‡»å¼€å§‹å¬æ­Œ</span>
                </div>
            </div>
            
            <!-- æ—¶é’Ÿå®¹å™¨ -->
            <div id="clock-container">
                <div id="main-time">14:25</div>
                <div id="main-date">12æœˆ18æ—¥ æ˜ŸæœŸä¸€</div>
            </div>
            
            <div id="worldbook-screen" class="app-screen">
                <div class="app-status-bar">
                    <div class="app-status-time"></div>
                    <div class="app-battery-container">
                        <span class="battery-text">á°”á©š</span>
                        <div class="app-battery-icon">
                            <div class="app-battery-level"></div>
                        </div>
                    </div>
                </div>
                <div class="app-header">
                    <button class="back-button" onclick="hideApp('worldbook-screen')">â€¹</button>
                    <div class="app-title">ä¸–ç•Œä¹¦</div>
                    <div class="add-worldbook-btn worldbook-add-btn" onclick="onWorldbookAddClick()">
                        <i class="fas fa-plus"></i>
                    </div>
                </div>

                <div class="app-content">
                    <div id="global-worldbooks-content" class="worldbook-content-pane">
                        </div>
                    <div id="local-worldbooks-content" class="worldbook-content-pane" style="display: none;">
                        </div>
                    <div id="character-worldbooks-content" class="worldbook-content-pane" style="display: none;">
                        </div>
                </div>

                <!-- ä¸–ç•Œä¹¦åˆ†ç±»é€‰æ‹©å™¨ -->
                <div class="worldbook-category-selector" id="worldbook-category-selector" style="display: none;">
                    <div class="category-selector-content">
                        <div class="category-selector-title">é€‰æ‹©è§’è‰²åˆ†ç±»</div>
                        <div class="category-options" id="category-options">
                            <!-- åŠ¨æ€ç”Ÿæˆè§’è‰²åˆ†ç±» -->
                        </div>
                        <div class="category-selector-actions">
                            <button class="category-cancel-btn" onclick="hideCategorySelector()">å–æ¶ˆ</button>
                        </div>
                    </div>
                </div>

                <div class="worldbook-tabs">
                    <div class="worldbook-tab active" onclick="switchWorldbookTab('global')">
                        <i class="fas fa-globe-asia"></i>
                        <span>å…¨å±€è®¾å®š</span>
                    </div>
                    <div class="worldbook-tab" onclick="switchWorldbookTab('local')">
                        <i class="fas fa-comment-dots"></i>
                        <span>å±€éƒ¨è®¾å®š</span>
                    </div>
                    <div class="worldbook-tab" onclick="switchWorldbookTab('character')">
                        <i class="fas fa-users"></i>
                        <span id="character-tab-text">è§’è‰²è®¾å®š</span>
                    </div>
                </div>
            </div>
                
                <!-- ä¸»å±å¹•å››å—å¸ƒå±€ -->
                <div id="home-grid">
                    <!-- å·¦ä¸Šè§’ï¼šå›¾ç‰‡å°ç»„ä»¶ -->
                    <div class="home-section top-left">
                        <div class="widget photo-widget" onclick="showPhotoWidgetOptions()">
                            <div class="photo-widget-content" id="photo-widget-content">
                                <div class="photo-placeholder" id="photo-placeholder">
                                    <i class="fas fa-image"></i>
                                    <span>ç‚¹å‡»æ·»åŠ å›¾ç‰‡</span>
                                </div>
                                <img class="photo-widget-image" id="photo-widget-image" style="display: none;">
                            </div>
                        </div>
                    </div>

                    <!-- å³ä¸Šè§’ï¼šä¸¤ä¸ªåº”ç”¨ -->
                    <div class="home-section top-right">
                        <div class="apps-grid-2">
                            <a href="#" class="mini-app" onclick="showApp('chat-screen')">
                                <div class="mini-app-icon">
                                    <img src="https://i.postimg.cc/dVSd9QBz/IMG-3063.jpg" alt="Chat" class="app-icon-img">
                                </div>
                                <span>Chat</span>
                            </a>
                            <a href="#" class="mini-app" onclick="showApp('worldbook-screen'); switchWorldbookTab('global');">
                                <div class="mini-app-icon">
                                    <img src="https://i.postimg.cc/Xqz3zPz7/IMG-3080.jpg" alt="ä¸–ç•Œä¹¦" class="app-icon-img">
                                </div>
                                <span>ä¸–ç•Œä¹¦</span>
                            </a>
                        </div>
                    </div>

                    <!-- å·¦ä¸‹è§’ï¼šä¸¤ä¸ªåº”ç”¨ -->
                    <div class="home-section bottom-left">
                        <div class="apps-grid-2">
                            <a href="#" class="mini-app" onclick="showApp('game-screen')">
                                <div class="mini-app-icon">
                                    <i class="fas fa-gamepad"></i>
                                </div>
                                <span>æ¸¸æˆ</span>
                            </a>
                            <a href="#" class="mini-app" onclick="showApp('forum-screen')">
                                <div class="mini-app-icon">
                                    <i class="fas fa-comments"></i>
                                </div>
                                <span>è®ºå›</span>
                            </a>
                        </div>
                    </div>

                    <!-- å³ä¸‹è§’ï¼šçºªå¿µæ—¥å°ç»„ä»¶ -->
                    <div class="home-section bottom-right">
                        <div class="widget anniversary-widget" onclick="showApp('anniversary-screen')" style="cursor: pointer;">
                            <div class="anniversary-widget-content" id="anniversary-widget-content">
                                <div class="anniversary-placeholder" id="anniversary-placeholder">
                                    <i class="fas fa-heart"></i>
                                    <span>æš‚æ— çºªå¿µæ—¥</span>
                                </div>
                                <div class="anniversary-display" id="anniversary-display" style="display: none;">
                                    <div class="anniversary-name" id="widget-anniversary-name"></div>
                                    <div class="anniversary-countdown" id="widget-anniversary-countdown"></div>
                                    <div class="anniversary-date" id="widget-anniversary-date"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- iPhoneé£æ ¼Dockæ  -->
                <div id="dock-bar">
                    <div class="dock-container">
                        <a href="#" class="dock-app" onclick="showApp('messages-screen')">
                            <div class="dock-app-icon">
                                <i class="fas fa-comment-dots"></i>
                            </div>
                            <span>çŸ­ä¿¡</span>
                        </a>
                        <a href="#" class="dock-app" onclick="showApp('settings-screen')">
                            <div class="dock-app-icon">
                                <img src="https://i.postimg.cc/764L3jpF/IMG-3079.jpg" alt="è®¾ç½®" class="app-icon-img">
                            </div>
                            <span>è®¾ç½®</span>
                        </a>
                        <a href="#" class="dock-app" onclick="showApp('memory-viewer-screen')">
                            <div class="dock-app-icon">
                                <i class="fas fa-brain"></i>
                            </div>
                            <span>è®°å¿†</span>
                        </a>
                    </div>
                </div>

                
                <!-- çºªå¿µæ—¥ç•Œé¢ -->
                <div id="anniversary-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('anniversary-screen')">â€¹</button>
                        <div class="app-title">çºªå¿µæ—¥</div>
                        <div class="add-anniversary-btn" onclick="showAnniversaryForm()">
                            <i class="fas fa-plus"></i>
                        </div>
                    </div>
                    <div class="app-content">
                        <div id="anniversary-list" class="anniversary-list">
                            <!-- çºªå¿µæ—¥åˆ—è¡¨å°†é€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
                            <div class="anniversary-empty-state">
                                <i class="fas fa-heart"></i>
                                <p>è¿˜æ²¡æœ‰çºªå¿µæ—¥</p>
                                <p>ç‚¹å‡»å³ä¸Šè§’ + æ·»åŠ é‡è¦çš„æ—¥å­</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- çŸ­ä¿¡ç•Œé¢ -->
                <div id="messages-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('messages-screen')">â€¹</button>
                        <div class="app-title">çŸ­ä¿¡</div>
                        <div class="add-message-btn" onclick="showNewMessageForm()">
                            <i class="fas fa-edit"></i>
                        </div>
                    </div>
                    <div class="app-content">
                        <div id="messages-list" class="messages-list">
                            <!-- çŸ­ä¿¡åˆ—è¡¨å°†é€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
                            <div class="messages-empty-state">
                                <i class="fas fa-comment-dots"></i>
                                <p>æš‚æ— çŸ­ä¿¡</p>
                                <p>è¿™æ˜¯ä¸€ä¸ªé¢„ç•™åŠŸèƒ½</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- èŠå¤©ç•Œé¢ -->
                <div id="chat-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('chat-screen')">â€¹</button>
                        <div class="app-title">ğŸ’¬</div>
                        <div class="chat-header-actions">
                            <div id="group-manage-btn" class="header-action-btn" onclick="enterGroupManageMode()" title="ç®¡ç†åˆ†ç»„">
                                <i class="fas fa-cog"></i>
                            </div>
                            <div id="add-contact-btn" class="add-btn" onclick="showCharacterForm()">
                                <i class="fas fa-plus"></i>
                            </div>
                            <div id="add-chat-btn" class="add-btn" onclick="showChatOptions()">
                                <i class="fas fa-plus"></i>
                            </div>
                        </div>
                    </div>
                    
                    <div class="app-content" id="chat-content">
                        <!-- é»˜è®¤æ˜¾ç¤ºæ¶ˆæ¯åˆ—è¡¨ -->
                        <div class="message-list" id="message-list">
                            <!-- æ¶ˆæ¯åˆ—è¡¨å°†é€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
                        </div>
                        
                        <!-- é€šè®¯å½• -->
                        <div class="contact-list hide" id="contact-list">
                            <div class="contact-section">
        
                                <!-- è§’è‰²åˆ—è¡¨å°†é€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
                            </div>

                        </div>
                        
                        <!-- åŠ¨æ€é¡µé¢ -->
                        <div class="moments-page hide moments-page-no-padding" id="moments-page">
                            <div class="moments-header">
                                <div class="moments-cover" onclick="changeCoverImage()">
                                    <div class="cover-image-placeholder" id="cover-placeholder">
                                        <div class="cover-placeholder-text">ç‚¹å‡»æ›´æ¢å°é¢</div>
                                        </div>
                                    <img class="cover-image hide" id="cover-image" src="">
                                    </div>
                                
                                <!-- ç”¨æˆ·åï¼Œç‹¬ç«‹æ”¾ç½®åœ¨å¤´åƒå·¦ä¸Šè§’ -->
                                <div class="moments-username" onclick="changeUsername(event)" id="moments-username">ç”¨æˆ·</div>
                                
                                <!-- ç‹¬ç«‹çš„å¤´åƒï¼Œè·¨è¶ŠèƒŒæ™¯å’ŒåŠ¨æ€åˆ—è¡¨åŒºåŸŸï¼Œæ”¾åœ¨headerå¤–é¢ -->
                                <div class="moments-avatar" onclick="changeAvatarImage(event)" id="moments-avatar">
                                    <i class="fas fa-user moments-avatar-icon"></i>
                                </div>
                            </div>
                            
                            <div class="moments-list" id="moments-list">
                                <!-- åŠ¨æ€åˆ—è¡¨å°†é€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
                            </div>
                            

                        </div>

                        
                        <!-- é¢å…·åŒºåŸŸ -->
                        <div class="profile-page hide" id="profile-page">
                            <div class="persona-header">
                                <div class="persona-title">
                                    <h2>æˆ‘çš„é¢å…·</h2>
                                    <p>ç®¡ç†ä½ çš„å¤šé‡èº«ä»½è®¾å®š</p>
                                </div>
                                <div class="add-persona-btn persona-add-btn" onclick="showPersonaForm()">
                                    <i class="fas fa-plus"></i>
                                </div>
                            </div>
                            
                            <div class="persona-list" id="persona-list">
                                <!-- é¢å…·åˆ—è¡¨å°†é€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
                            </div>
                            

                        </div>
                    </div>
                    
                    <div class="chat-tabs">
                        <div class="chat-tab active" onclick="switchChatTab('message-list')" id="message-tab">
                            <i class="fas fa-comments"></i>
                            <span>æ¶ˆæ¯</span>
                        </div>
                        <div class="chat-tab" onclick="switchChatTab('contact-list')">
                            <i class="fas fa-user-friends"></i>
                            <span>è§’è‰²</span>
                        </div>
                        <div class="chat-tab" onclick="switchChatTab('moments-page')">
                            <i class="fas fa-globe-americas"></i>
                            <span>åŠ¨æ€</span>
                        </div>
                        <div class="chat-tab" onclick="switchChatTab('profile-page')">
                            <i class="fas fa-user-circle"></i>
                            <span>æˆ‘</span>
                        </div>
                    </div>
                </div>
                
                <!-- å‘å¸ƒåŠ¨æ€ç•Œé¢ -->
                <div id="publish-moment-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hidePublishMoment()">â€¹</button>
                        <div class="app-title">å‘è¡¨åŠ¨æ€</div>
                        <button class="publish-btn" onclick="publishMoment()">å‘è¡¨</button>
                    </div>
                    <div class="app-content">
                        <div class="publish-moment-form">
                            <!-- æ–‡å­—è¾“å…¥åŒºåŸŸ -->
                            <div class="moment-text-input">
                                <textarea 
                                    id="moment-text" 
                                    placeholder="åˆ†äº«æ–°é²œäº‹..." 
                                    class="moment-textarea"
                                    maxlength="500"
                                    oninput="updateTextCount()"></textarea>
                                <div class="text-count" id="text-count">0/500</div>
                            </div>
                            
                            <!-- å›¾ç‰‡ä¸Šä¼ åŒºåŸŸ -->
                            <div class="moment-images-section">
                                <div class="moment-images-grid" id="moment-images-grid">
                                    <!-- åŠ¨æ€æ·»åŠ çš„å›¾ç‰‡é¢„è§ˆ -->
                                </div>
                                <div class="add-image-btn" onclick="addMomentImage()">
                                    <i class="fas fa-plus"></i>
                                    <span>æ·»åŠ å›¾ç‰‡</span>
                                </div>
                            </div>
                            
                            <!-- å‘å¸ƒé€‰é¡¹ -->
                            <div class="publish-options">
                                <div class="option-item">
                                    <i class="fas fa-map-marker-alt"></i>
                                    <span>æ‰€åœ¨ä½ç½®</span>
                                    <i class="fas fa-chevron-right"></i>
                                </div>
                                <div class="option-item">
                                    <i class="fas fa-users"></i>
                                    <span>æé†’è°çœ‹</span>
                                    <i class="fas fa-chevron-right"></i>
                                </div>
                                <div class="option-item">
                                    <i class="fas fa-eye"></i>
                                    <span>è°å¯ä»¥çœ‹</span>
                                    <span class="option-value">å…¬å¼€</span>
                                    <i class="fas fa-chevron-right"></i>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- è®ºå›ç•Œé¢ -->
                <div id="forum-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon"><div class="app-battery-level"></div></div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('forum-screen')">â€¹</button>
                        <div class="app-title">è®ºå›</div>
                        <div class="add-forum-btn" onclick="showCreateForumScreen()">
                            <i class="fas fa-plus"></i>
                        </div>
                    </div>
                    <div class="app-content">
                        <div id="forum-archive-list" class="forum-archive-list">
                            <div class="forum-empty-state">
                                <i class="fas fa-comments"></i>
                                <p>è¿˜æ²¡æœ‰åˆ›å»ºä»»ä½•è®ºå›</p>
                                <p>ç‚¹å‡»å³ä¸Šè§’ + åˆ›å»ºä½ çš„ç¬¬ä¸€ä¸ªè®ºå›</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- åˆ›å»ºè®ºå›ç•Œé¢ -->
                <div id="create-forum-screen" class="app-screen">
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('create-forum-screen')">â€¹</button>
                        <div class="app-title">åˆ›å»ºæ–°è®ºå›</div>
                    </div>
                    <div class="app-content">
                        <div class="form-group">
                            <label class="form-label">è®ºå›åç§°</label>
                            <input type="text" id="forum-name-input" class="form-input" placeholder="ç»™è¿™ä¸ªä¸–ç•Œçº¿èµ·ä¸ªåå­—å§">
                        </div>
                        <div class="form-group">
                            <label class="form-label">é€‰æ‹©è§’è‰² (å¯å¤šé€‰)</label>
                            <div id="forum-character-selection" class="selection-grid"></div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">é€‰æ‹©ä½ çš„èº«ä»½</label>
                            <div id="forum-persona-selection" class="selection-grid single-selection"></div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">è¡¥å……ä¸–ç•Œè§‚ (å¯é€‰)</label>
                            <textarea id="forum-worldview-input" class="form-textarea" rows="4" placeholder="è¡¥å……ä¸€äº›èƒŒæ™¯æ•…äº‹æˆ–è®¾å®š..."></textarea>
                        </div>
                        <button class="form-submit" onclick="createForum()">è¿›å…¥è®ºå›</button>
                    </div>
                </div>

                <!-- å¸–å­åˆ—è¡¨ç•Œé¢ -->
                <div id="forum-view-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon"><div class="app-battery-level"></div></div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToForumArchives()">â€¹</button>
                        <div class="app-title" id="forum-view-title">è®ºå›</div>
                        <div class="header-actions">
                            <span class="action-btn" onclick="refreshPosts()" title="åˆ·æ–°å¸–å­">
                                <i class="fas fa-redo"></i>
                            </span>
                            <span class="action-btn" onclick="showForumProfile()" title="ä¸ªäººä¸»é¡µ">
                                <i class="fas fa-user"></i>
                            </span>  </div>
                    </div>
                    <div class="app-content">
                        <div id="forum-posts-list" class="post-list">
                        </div>
                    </div>
                </div>

                <!-- å¸–å­è¯¦æƒ…å’Œå›å¤ç•Œé¢ -->
                <div id="post-view-screen" class="app-screen">
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('post-view-screen')">â€¹ è¿”å›</button>
                        <div class="app-title">å¸–å­è¯¦æƒ…</div>
                        <button id="favorite-btn" class="header-action-btn" onclick="toggleFavoritePost()" title="æ”¶è—"><i class="far fa-star"></i></button>
                    </div>
                    <div class="app-content" id="post-view-content">
                    </div>
                    <div class="reply-input-area">
                        <input type="text" id="reply-input" placeholder="è¾“å…¥ä½ çš„å›å¤...">
                        <button onclick="sendReply()">å‘é€</button>
                    </div>
                </div>

                <!-- è®ºå›ä¸ªäººä¸»é¡µ/æ”¶è—å¤¹ -->
                <div id="forum-profile-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon"><div class="app-battery-level"></div></div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToCurrentForum()">â€¹</button>
                        <div class="app-title">ä¸ªäººä¸»é¡µ</div>
                    </div>
                    <div class="app-content">
                        <div id="favorite-posts-list" class="post-list">
                        </div>
                    </div>
                </div>

                <!-- è®°å¿†è®¾ç½®æ¨¡æ€æ¡† -->
                <div id="memorySettingsModal" class="modal" style="display: none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>è®°å¿†ç³»ç»Ÿè®¾ç½®</h3>
                            <button class="modal-close" onclick="closeMemorySettings()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div class="setting-group">
                                <label for="aiExtractInterval">AIè®°å¿†æå–é—´éš”ï¼ˆå›åˆæ•°ï¼‰</label>
                                <input type="number" id="aiExtractInterval" min="10" max="200" step="10" value="30">
                                <small>æ¯å¤šå°‘å›åˆå¯¹è¯è¿›è¡Œä¸€æ¬¡AIè®°å¿†æå–ï¼ˆå»ºè®®20-50å›åˆï¼‰</small>
                            </div>

                            <div class="setting-group">
                                <label for="coreMemoryThreshold">æ ¸å¿ƒè®°å¿†é‡è¦æ€§é˜ˆå€¼</label>
                                <input type="range" id="coreMemoryThreshold" min="0.7" max="1.0" step="0.05" value="0.9">
                                <span id="coreThresholdValue">90%</span>
                                <small>åªæœ‰é‡è¦æ€§è¶…è¿‡æ­¤é˜ˆå€¼çš„è®°å¿†æ‰ä¼šæˆä¸ºæ ¸å¿ƒè®°å¿†</small>
                            </div>

                            <div class="setting-group">
                                <label for="episodicMemoryThreshold">æƒ…æ™¯è®°å¿†é‡è¦æ€§é˜ˆå€¼</label>
                                <input type="range" id="episodicMemoryThreshold" min="0.4" max="0.8" step="0.05" value="0.6">
                                <span id="episodicThresholdValue">60%</span>
                                <small>é‡è¦æ€§åœ¨æ­¤èŒƒå›´å†…çš„è®°å¿†ä¼šæˆä¸ºæƒ…æ™¯è®°å¿†</small>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="closeMemorySettings()">å–æ¶ˆ</button>
                            <button class="btn btn-primary" onclick="saveMemorySettings()">ä¿å­˜è®¾ç½®</button>
                        </div>
                    </div>
                </div>

                <!-- çº¿ä¸‹é¢„è®¾è®¾ç½®æ¨¡æ€æ¡† -->
                <div id="offline-preset-modal" class="modal" style="display: none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>çº¿ä¸‹å‰§æƒ…é¢„è®¾</h3>
                            <button class="modal-close" onclick="closeOfflinePresetSettings()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <!-- å·²ä¿å­˜çš„é¢„è®¾åˆ—è¡¨ -->
                            <div class="form-group">
                                <label>å·²ä¿å­˜çš„é¢„è®¾</label>
                                <div id="saved-presets-list" class="saved-presets-list">
                                    <!-- é¢„è®¾åˆ—è¡¨å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                                </div>
                            </div>

                            <!-- æ–°å»º/ç¼–è¾‘é¢„è®¾è¡¨å• -->
                            <div class="form-group">
                                <label for="offline-preset-name">é¢„è®¾åç§°</label>
                                <input type="text" id="offline-preset-name" placeholder="ä¸ºè¿™ä¸ªé¢„è®¾èµ·ä¸ªåå­—..." maxlength="50">
                            </div>
                            <div class="form-group">
                                <label for="offline-preset-content">å‰§æƒ…é¢„è®¾å†…å®¹</label>
                                <textarea id="offline-preset-content" rows="6" placeholder="è¯·è¾“å…¥çº¿ä¸‹å‰§æƒ…æ¨¡å¼çš„é¢„è®¾å†…å®¹ï¼Œè¿™å°†å†³å®šAIçš„æ–‡é£ã€å­—æ•°ã€è§†è§’ç­‰...&#10;&#10;ä¾‹å¦‚ï¼š&#10;- ä»¥ç¬¬ä¸‰äººç§°è§†è§’æè¿°&#10;- æ¯æ¬¡å›å¤200-400å­—&#10;- æ³¨é‡ç¯å¢ƒæå†™å’Œå¿ƒç†æ´»åŠ¨&#10;- è¥é€ æµªæ¼«/æ‚¬ç–‘/å†’é™©ç­‰æ°›å›´"></textarea>
                            </div>
                            <div class="form-group">
                                <label>é¢„è®¾è¯´æ˜</label>
                                <div class="preset-help-text">
                                    <p>â€¢ é¢„è®¾å†…å®¹å°†ä½œä¸ºAIå›å¤çš„é‡è¦æŒ‡å¯¼</p>
                                    <p>â€¢ å¯ä»¥æŒ‡å®šæ–‡é£ã€å­—æ•°ã€è§†è§’ã€æ°›å›´ç­‰</p>
                                    <p>â€¢ æ”¯æŒæƒ…æ™¯æå†™ã€åŠ¨ä½œæå†™ã€å¿ƒç†æå†™</p>
                                    <p>â€¢ é¢„è®¾æƒé‡å¾ˆé«˜ï¼Œä¼šæ˜¾è‘—å½±å“AIçš„å›å¤é£æ ¼</p>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="closeOfflinePresetSettings()">å–æ¶ˆ</button>
                            <button class="btn btn-secondary" onclick="clearPresetForm()">æ¸…ç©ºè¡¨å•</button>
                            <button class="btn btn-primary" onclick="saveOfflinePreset()">ä¿å­˜é¢„è®¾</button>
                        </div>
                    </div>
                </div>

                <!-- çº¿ä¸‹æ¨¡å¼èŠå¤©è®°å½•æ¨¡æ€æ¡† -->
                <div id="offline-history-modal" class="modal" style="display: none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>çº¿ä¸‹æ¨¡å¼èŠå¤©è®°å½•</h3>
                            <button class="modal-close" onclick="closeOfflineHistoryModal()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div id="offline-history-list" class="offline-history-list">
                                <!-- èŠå¤©è®°å½•åˆ—è¡¨å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="closeOfflineHistoryModal()">å…³é—­</button>
                            <button class="btn btn-danger" onclick="clearAllOfflineHistory()">æ¸…ç©ºæ‰€æœ‰è®°å½•</button>
                        </div>
                    </div>
                </div>

                <!-- çºªå¿µæ—¥è¡¨å•æ¨¡æ€æ¡† -->
                <div id="anniversary-form-modal" class="modal" style="display: none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 id="anniversary-form-title">æ·»åŠ çºªå¿µæ—¥</h3>
                            <button class="modal-close" onclick="closeAnniversaryForm()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label for="anniversary-name">çºªå¿µæ—¥åç§°</label>
                                <input type="text" id="anniversary-name" placeholder="ä¾‹å¦‚ï¼šç”Ÿæ—¥ã€ç»“å©šçºªå¿µæ—¥..." maxlength="50">
                            </div>
                            <div class="form-group">
                                <label for="anniversary-date">æ—¥æœŸ</label>
                                <input type="date" id="anniversary-date">
                            </div>
                            <div class="form-group">
                                <label for="anniversary-type">ç±»å‹</label>
                                <select id="anniversary-type">
                                    <option value="birthday">ç”Ÿæ—¥</option>
                                    <option value="anniversary">çºªå¿µæ—¥</option>
                                    <option value="holiday">èŠ‚æ—¥</option>
                                    <option value="other">å…¶ä»–</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="anniversary-description">æè¿°ï¼ˆå¯é€‰ï¼‰</label>
                                <textarea id="anniversary-description" rows="3" placeholder="æ·»åŠ ä¸€äº›å¤‡æ³¨..." maxlength="200"></textarea>
                            </div>
                            <div class="form-group">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="anniversary-yearly" checked>
                                    æ¯å¹´é‡å¤
                                </label>
                            </div>
                            <div class="form-group">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="anniversary-notify">
                                    æå‰æé†’
                                </label>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="closeAnniversaryForm()">å–æ¶ˆ</button>
                            <button class="btn btn-primary" onclick="saveAnniversary()">ä¿å­˜</button>
                        </div>
                    </div>
                </div>

                <!-- å›¾ç‰‡å°ç»„ä»¶è®¾ç½®æ¨¡æ€æ¡† -->
                <div id="photo-widget-modal" class="modal" style="display: none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>å›¾ç‰‡å°ç»„ä»¶</h3>
                            <button class="modal-close" onclick="closePhotoWidgetModal()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label for="widget-photo-upload">é€‰æ‹©å›¾ç‰‡</label>
                                <input type="file" id="widget-photo-upload" accept="image/*" onchange="handlePhotoWidgetUpload(this)">
                            </div>
                            <div class="form-group">
                                <button class="btn btn-secondary" onclick="clearPhotoWidget()">æ¸…é™¤å›¾ç‰‡</button>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="closePhotoWidgetModal()">å…³é—­</button>
                        </div>
                    </div>
                </div>

                <!-- çºªå¿µæ—¥å°ç»„ä»¶è®¾ç½®æ¨¡æ€æ¡† -->
                <div id="anniversary-widget-modal" class="modal" style="display: none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>çºªå¿µæ—¥å°ç»„ä»¶</h3>
                            <button class="modal-close" onclick="closeAnniversaryWidgetModal()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label for="widget-anniversary-select">é€‰æ‹©è¦æ˜¾ç¤ºçš„çºªå¿µæ—¥</label>
                                <select id="widget-anniversary-select" onchange="updateAnniversaryWidget()">
                                    <option value="">è¯·é€‰æ‹©çºªå¿µæ—¥</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <button class="btn btn-secondary" onclick="clearAnniversaryWidget()">æ¸…é™¤æ˜¾ç¤º</button>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="closeAnniversaryWidgetModal()">å…³é—­</button>
                        </div>
                    </div>
                </div>

                <!-- çº¿ä¸‹æ¨¡å¼ç•Œé¢è®¾ç½®æ¨¡æ€æ¡† -->
                <div id="offline-ui-settings-modal" class="modal" style="display: none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>çº¿ä¸‹æ¨¡å¼ç•Œé¢è®¾ç½®</h3>
                            <button class="modal-close" onclick="closeOfflineUISettings()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <!-- æ°”æ³¡é¢œè‰²è®¾ç½® -->
                            <div class="form-group">
                                <label>æ°”æ³¡é¢œè‰²è®¾ç½®</label>
                                <div class="color-setting-group">
                                    <div class="color-picker-container">
                                        <div class="flex-gap-15">
                                            <div class="flex-1">
                                                <label class="label-small">æˆ‘çš„æ°”æ³¡</label>
                                                <input type="color" id="offline-my-bubble-color" class="color-input" value="#007AFF">
                                            </div>
                                            <div class="flex-1">
                                                <label class="label-small">è§’è‰²æ°”æ³¡</label>
                                                <input type="color" id="offline-ai-bubble-color" class="color-input" value="#f0f0f0">
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- é€æ˜åº¦è®¾ç½® -->
                            <div class="form-group">
                                <label>æ°”æ³¡é€æ˜åº¦</label>
                                <div class="opacity-setting">
                                    <input type="range" id="offline-bubble-opacity" class="theme-range" min="0" max="1" step="0.01" value="0.9">
                                    <span id="offline-opacity-value">90%</span>
                                </div>
                            </div>



                            <!-- ğŸ”¥ã€æ–°å¢ã€‘å­—ä½“å¤§å°è®¾ç½® -->
                            <div class="form-group">
                                <label>å­—ä½“å¤§å°</label>
                                <div class="opacity-setting">
                                    <input type="range" id="offline-font-size" class="theme-range" min="12" max="24" step="1" value="15">
                                    <span id="offline-font-size-value">15px</span>
                                </div>
                            </div>

                            <!-- å£çº¸è®¾ç½® -->
                            <div class="form-group">
                                <label>èƒŒæ™¯å£çº¸</label>
                                <div class="wallpaper-setting">
                                    <input type="file" id="offline-wallpaper-file" accept="image/*" class="form-input" onchange="handleOfflineWallpaperUpload(this)">
                                    <button type="button" class="theme-button theme-button-secondary" onclick="clearOfflineWallpaper()">æ¸…é™¤</button>
                                </div>
                            </div>

                            <!-- å­—ä½“è®¾ç½® -->
                            <div class="form-group">
                                <label>å­—ä½“è®¾ç½®</label>
                                <div class="font-setting">
                                    <select id="offline-font-select" class="form-input" onchange="handleOfflineFontChange()">
                                        <option value="">ç³»ç»Ÿé»˜è®¤å­—ä½“</option>
                                        <option value="custom">è‡ªå®šä¹‰å­—ä½“URL...</option>
                                    </select>
                                    <div id="custom-font-input" style="display: none; margin-top: 10px;">
                                        <input type="url" id="offline-font-url" placeholder="ä¾‹å¦‚ï¼šhttps://fonts.googleapis.com/css2?family=Noto+Sans+SC æˆ–ç›´æ¥å­—ä½“æ–‡ä»¶URL" class="form-input">
                                        <button type="button" class="theme-button theme-button-secondary" onclick="previewOfflineFont()">é¢„è§ˆ</button>
                                    </div>
                                </div>
                            </div>

                            <!-- æ–‡å­—é¢œè‰²è®¾ç½® -->
                            <div class="form-group">
                                <label>æ–‡å­—é¢œè‰²è®¾ç½®</label>
                                <div class="text-color-setting">
                                    <!-- ç”¨æˆ·æ¶ˆæ¯æ–‡å­—é¢œè‰² -->
                                    <div class="color-section">
                                        <label class="section-label">ç”¨æˆ·æ¶ˆæ¯æ–‡å­—é¢œè‰²</label>
                                        <div class="color-picker-container">
                                            <div class="flex-gap-15">
                                                <div class="flex-1">
                                                    <label class="label-small">æ™®é€šæ–‡å­—</label>
                                                    <input type="color" id="offline-user-normal-text-color" class="color-input" value="#ffffff">
                                                    <div class="saved-colors" id="offline-user-normal-saved-colors"></div>
                                                </div>
                                                <div class="flex-1">
                                                    <label class="label-small">æ–œä½“æ–‡å­—</label>
                                                    <input type="color" id="offline-user-italic-text-color" class="color-input" value="#f0f0f0">
                                                    <div class="saved-colors" id="offline-user-italic-saved-colors"></div>
                                                </div>
                                                <div class="flex-1">
                                                    <label class="label-small">åŠ ç²—æ–‡å­—</label>
                                                    <input type="color" id="offline-user-bold-text-color" class="color-input" value="#ffffff">
                                                    <div class="saved-colors" id="offline-user-bold-saved-colors"></div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- è§’è‰²æ¶ˆæ¯æ–‡å­—é¢œè‰² -->
                                    <div class="color-section">
                                        <label class="section-label">è§’è‰²æ¶ˆæ¯æ–‡å­—é¢œè‰²</label>
                                        <div class="color-picker-container">
                                            <div class="flex-gap-15">
                                                <div class="flex-1">
                                                    <label class="label-small">æ™®é€šæ–‡å­—</label>
                                                    <input type="color" id="offline-ai-normal-text-color" class="color-input" value="#000000">
                                                    <div class="saved-colors" id="offline-ai-normal-saved-colors"></div>
                                                </div>
                                                <div class="flex-1">
                                                    <label class="label-small">æ–œä½“æ–‡å­—</label>
                                                    <input type="color" id="offline-ai-italic-text-color" class="color-input" value="#666666">
                                                    <div class="saved-colors" id="offline-ai-italic-saved-colors"></div>
                                                </div>
                                                <div class="flex-1">
                                                    <label class="label-small">åŠ ç²—æ–‡å­—</label>
                                                    <input type="color" id="offline-ai-bold-text-color" class="color-input" value="#333333">
                                                    <div class="saved-colors" id="offline-ai-bold-saved-colors"></div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- é¢„å­˜é¢œè‰²åŠŸèƒ½ -->
                            <div class="form-group">
                                <label>é¢œè‰²ç®¡ç†</label>
                                <div class="color-management">
                                    <button type="button" class="theme-button theme-button-secondary" onclick="saveCurrentOfflineColors()">ä¿å­˜å½“å‰é¢œè‰²</button>
                                    <button type="button" class="theme-button theme-button-secondary" onclick="resetOfflineColors()">é‡ç½®ä¸ºé»˜è®¤</button>
                                </div>
                            </div>

                            <!-- å¤´åƒè®¾ç½® -->
                            <div class="form-group">
                                <label>å¤´åƒè®¾ç½®</label>
                                <div class="avatar-setting">
                                    <div class="setting-row">
                                        <label class="checkbox-label">
                                            <input type="checkbox" id="offline-show-user-avatar" checked>
                                            æ˜¾ç¤ºç”¨æˆ·å¤´åƒ
                                        </label>
                                        <label class="checkbox-label">
                                            <input type="checkbox" id="offline-show-ai-avatar" checked>
                                            æ˜¾ç¤ºè§’è‰²å¤´åƒ
                                        </label>
                                    </div>
                                    <div class="setting-row">
                                        <label class="radio-label">å¤´åƒä½ç½®ï¼š</label>
                                        <div class="radio-options">
                                            <div class="radio-option-button selected" onclick="selectAvatarPosition('side', this)">
                                                <div class="radio-indicator"></div>
                                                ä¾§è¾¹æ˜¾ç¤º
                                            </div>
                                            <div class="radio-option-button" onclick="selectAvatarPosition('custom', this)">
                                                <div class="radio-indicator"></div>
                                                è‡ªå®šä¹‰CSSæ§åˆ¶
                                            </div>
                                            <input type="radio" name="offline-avatar-position" value="side" checked style="display: none;">
                                            <input type="radio" name="offline-avatar-position" value="custom" style="display: none;">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- æ°”æ³¡æ ·å¼è®¾ç½® -->
                            <div class="form-group">
                                <label>æ°”æ³¡æ ·å¼è®¾ç½®</label>
                                <div class="bubble-style-setting">
                                    <div class="setting-row">
                                        <label class="radio-label">æ°”æ³¡å®½åº¦ï¼š</label>
                                        <div class="radio-options">
                                            <div class="radio-option-button selected" onclick="selectBubbleWidth('default', this)">
                                                <div class="radio-indicator"></div>
                                                æ™ºèƒ½å®½åº¦
                                            </div>
                                            <div class="radio-option-button" onclick="selectBubbleWidth('custom', this)">
                                                <div class="radio-indicator"></div>
                                                è‡ªå®šä¹‰CSSæ§åˆ¶
                                            </div>
                                            <input type="radio" name="offline-bubble-width" value="default" checked style="display: none;">
                                            <input type="radio" name="offline-bubble-width" value="custom" style="display: none;">
                                        </div>
                                    </div>
                                    <div class="setting-row">
                                        <label class="radio-label">æ°”æ³¡æ ·å¼ï¼š</label>
                                        <div class="radio-options">
                                            <div class="radio-option-button selected" onclick="selectBubbleStyle('default', this)">
                                                <div class="radio-indicator"></div>
                                                é»˜è®¤æ ·å¼
                                            </div>
                                            <div class="radio-option-button" onclick="selectBubbleStyle('custom', this)">
                                                <div class="radio-indicator"></div>
                                                è‡ªå®šä¹‰CSSæ§åˆ¶
                                            </div>
                                            <input type="radio" name="offline-bubble-style" value="default" checked style="display: none;">
                                            <input type="radio" name="offline-bubble-style" value="custom" style="display: none;">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- è‡ªå®šä¹‰CSSè®¾ç½® -->
                            <div class="form-group">
                                <label>è‡ªå®šä¹‰CSSä»£ç </label>
                                <div class="custom-css-setting">
                                    <textarea id="offline-custom-css" rows="8" class="form-input" placeholder="åœ¨è¿™é‡Œè¾“å…¥è‡ªå®šä¹‰CSSä»£ç æ¥æ§åˆ¶å¤´åƒä½ç½®ã€æ°”æ³¡æ ·å¼ã€æ°”æ³¡å¤§å°ç­‰...&#10;&#10;ç¤ºä¾‹ï¼š&#10;/* è°ƒæ•´æ°”æ³¡å®½åº¦ */&#10;.offline-message-content {&#10;    max-width: 70% !important;&#10;}&#10;&#10;/* è°ƒæ•´å¤´åƒä½ç½® */&#10;.offline-avatar {&#10;    position: absolute;&#10;    top: -10px;&#10;    right: -10px;&#10;}"></textarea>
                                    <div class="css-buttons">
                                        <button type="button" class="theme-button theme-button-secondary" onclick="previewOfflineCSS()">é¢„è§ˆCSS</button>
                                        <button type="button" class="theme-button theme-button-secondary" onclick="clearOfflineCSS()">æ¸…é™¤CSS</button>
                                    </div>
                                </div>
                            </div>

                            <!-- é¢„è§ˆåŒºåŸŸ -->
                            <div class="form-group">
                                <label>æ•ˆæœé¢„è§ˆ</label>
                                <div class="offline-preview-area" id="offline-preview-area">
                                    <div class="offline-preview-message user">
                                        <div class="offline-avatar user-avatar" id="preview-user-avatar">ğŸ‘¤</div>
                                        <div class="offline-preview-content">
                                            è¿™æ˜¯ç”¨æˆ·æ¶ˆæ¯çš„é¢„è§ˆæ•ˆæœï¼ŒåŒ…å«<em>æ–œä½“æ–‡å­—</em>å’Œ<strong>åŠ ç²—æ–‡å­—</strong>
                                        </div>
                                    </div>
                                    <div class="offline-preview-message ai">
                                        <div class="offline-avatar ai-avatar" id="preview-ai-avatar">ğŸ¤–</div>
                                        <div class="offline-preview-content">
                                            è¿™æ˜¯è§’è‰²å›å¤çš„é¢„è§ˆæ•ˆæœï¼ŒåŒ…å«<em>æ–œä½“æ–‡å­—</em>å’Œ<strong>åŠ ç²—æ–‡å­—</strong>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="closeOfflineUISettings()">å–æ¶ˆ</button>
                            <button class="btn btn-secondary" onclick="resetOfflineUISettings()">é‡ç½®</button>
                            <button class="btn btn-primary" onclick="saveOfflineUISettings()">ä¿å­˜è®¾ç½®</button>
                        </div>
                    </div>
                </div>

                <!-- è®°å¿†æŸ¥çœ‹å™¨ç•Œé¢ -->
                <div id="memory-viewer-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('memory-viewer-screen')">â€¹</button>

                        <div class="app-title">è®°å¿†æŸ¥çœ‹å™¨</div>
                        <div class="header-actions">
                            <!-- å³ä¾§æ”¾3ä¸ªæŒ‰é’®ï¼šè®¾ç½®ã€åˆ·æ–°ã€æ¸…ç†é”™è¯¯è®°å½• -->
                            <button class="header-action-btn" onclick="showMemorySettings()" title="è®°å¿†è®¾ç½®">
                                <i class="fas fa-cog"></i>
                            </button>
                            <button class="header-action-btn" onclick="refreshMemoryData()" title="åˆ·æ–°">
                                <i class="fas fa-sync-alt"></i>
                            </button>
                            <button class="header-action-btn" onclick="cleanupIncorrectRecords()" title="æ¸…ç†é”™è¯¯è®°å½•">
                                <i class="fas fa-tools"></i>
                            </button>
                        </div>
                    </div>
                    <div class="app-content">
                        <!-- è§’è‰²é€‰æ‹©å™¨ -->
                        <div class="memory-character-selector">
                            <label for="memory-character-select">é€‰æ‹©è§’è‰²ï¼š</label>
                            <select id="memory-character-select" onchange="loadCharacterMemories()">
                                <option value="">è¯·é€‰æ‹©è§’è‰²</option>
                            </select>
                        </div>

                        <!-- æœç´¢å’Œè¿‡æ»¤ -->
                        <div class="memory-search-section">
                            <div class="memory-search-bar">
                                <input type="text" id="memory-search-input" placeholder="æœç´¢è®°å¿†å†…å®¹..." oninput="filterMemories()">
                                <button class="search-btn" onclick="filterMemories()">
                                    <i class="fas fa-search"></i>
                                </button>
                            </div>
                            <div class="memory-filter-tabs">
                                <button class="memory-filter-tab active" data-type="all" onclick="switchMemoryFilter('all')">å…¨éƒ¨</button>
                                <button class="memory-filter-tab" data-type="core" onclick="switchMemoryFilter('core')">æ ¸å¿ƒè®°å¿†</button>
                                <button class="memory-filter-tab" data-type="episodic" onclick="switchMemoryFilter('episodic')">æƒ…æ™¯è®°å¿†</button>
                                <button class="memory-filter-tab" data-type="storyline" onclick="switchMemoryFilter('storyline')">å‰§æƒ…æ€»ç»“</button>
                                <button class="memory-filter-tab" data-type="timeline" onclick="switchMemoryFilter('timeline')">æ—¶é—´çº¿</button>
                            </div>
                        </div>

                        <!-- è®°å¿†å†…å®¹æ˜¾ç¤ºåŒºåŸŸ -->
                        <div class="memory-content-area">
                            <div id="memory-list" class="memory-list">
                                <div class="memory-empty-state">
                                    <i class="fas fa-brain"></i>
                                    <p>è¯·é€‰æ‹©è§’è‰²æŸ¥çœ‹è®°å¿†</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- ä¸–ç•Œä¹¦ç¼–è¾‘è¡¨å• -->
                <div id="worldbook-form-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideWorldbookForm()">â€¹</button>
                        <div class="app-title" id="worldbook-form-title">æ–°å»ºä¸–ç•Œä¹¦</div>
                        <button class="save-worldbook-btn save-btn-absolute" onclick="saveWorldbook()">ä¿å­˜</button>
                    </div>
                    <div class="app-content">
                        <div class="worldbook-form">
                            <div class="form-group">
                                <label class="form-label">æ ‡é¢˜</label>
                                <input type="text" id="worldbook-title" class="form-input" placeholder="è¯·è¾“å…¥ä¸–ç•Œä¹¦æ ‡é¢˜">
                            </div>
                            <div class="form-group">
                                <label class="form-label">å†…å®¹</label>
                                <textarea id="worldbook-content" class="form-textarea textarea-large" placeholder="è¯·è¾“å…¥ä¸–ç•Œä¹¦å†…å®¹ï¼Œè¿™é‡Œå¯ä»¥æè¿°è§’è‰²èƒŒæ™¯ã€ä¸–ç•Œè§‚è®¾å®šç­‰..."></textarea>
                            </div>
                        </div>
                    </div>
                </div>
                

                
                <!-- èŠå¤©è®¾ç½®ç•Œé¢ -->
                <div id="api-chat-settings-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideChatSettings()">â€¹</button>
                        <div class="app-title">èŠå¤©è®¾ç½®</div>
                    </div>
                    <div class="app-content padding-none-flex overflow-auto">
                        <div class="settings-container">
                            
                            <!-- ç¾¤èŠä¸“ç”¨è®¾ç½® - ä»¿QQ/å¾®ä¿¡ç¾¤èŠç•Œé¢ -->
                            <div class="settings-section" id="group-chat-settings" style="display: none;">
                                <!-- ç¾¤èŠä¿¡æ¯å¡ç‰‡ -->
                                <div class="group-info-card">
                                    <div class="group-avatar-section" onclick="changeGroupAvatar()">
                                        <img id="group-avatar-preview" src="" class="group-avatar-large" alt="ç¾¤å¤´åƒ">
                                        <div class="group-avatar-edit-hint">ç‚¹å‡»ä¿®æ”¹</div>
                                    </div>
                                    <div class="group-basic-info">
                                        <div class="group-name" onclick="changeGroupName()" id="group-name-display">ç¾¤èŠåç§°</div>
                                        <div class="group-member-count" id="group-member-count-display">0åæˆå‘˜</div>
                                        <div class="group-description" onclick="editGroupDescription()" id="group-description-display">ç¾¤å…¬å‘Šï¼šç‚¹å‡»è®¾ç½®ç¾¤å…¬å‘Š</div>
                                    </div>
                                </div>

                                <!-- ç¾¤æˆå‘˜å±•ç¤ºåŒºåŸŸ -->
                                <div class="group-members-section">
                                    <div class="section-title">ç¾¤æˆå‘˜</div>
                                    <div class="group-members-grid" id="group-members-grid">
                                        <!-- ç¾¤æˆå‘˜å¤´åƒå°†åŠ¨æ€ç”Ÿæˆ -->
                                        <div class="member-item add-member" onclick="addGroupMember()">
                                            <div class="member-avatar">
                                                <i class="fas fa-plus"></i>
                                            </div>
                                            <div class="member-name">é‚€è¯·</div>
                                        </div>
                                        <div class="member-item remove-member" onclick="removeGroupMember()">
                                            <div class="member-avatar">
                                                <i class="fas fa-minus"></i>
                                            </div>
                                            <div class="member-name">ç§»é™¤</div>
                                        </div>
                                    </div>
                                </div>

                                <!-- ç¾¤åŠŸèƒ½è®¾ç½® -->
                                <div class="setting-card">
                                    <div class="setting-item" onclick="changeMyGroupNickname()">
                                        <div class="setting-left">
                                            <div class="setting-label">æˆ‘åœ¨æœ¬ç¾¤çš„æ˜µç§°</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="current-my-group-nickname">æœªé€‰æ‹©</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showGroupNotice()">
                                        <div class="setting-left">
                                            <div class="setting-label">ç¾¤å…¬å‘Š</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value">æŸ¥çœ‹è¯¦æƒ…</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>

                                </div>

                                <!-- ç¾¤åº”ç”¨ä¸­å¿ƒ -->
                                <div class="group-apps-section">
                                    <div class="section-title">ç¾¤åº”ç”¨</div>
                                    <div class="group-apps-grid">
                                        <div class="app-item" onclick="showGroupVote()">
                                            <i class="fas fa-vote-yea app-icon"></i>
                                            <span class="app-name">æŠ•ç¥¨</span>
                                        </div>
                                        <div class="app-item" onclick="showGroupActivity()">
                                            <i class="fas fa-calendar-alt app-icon"></i>
                                            <span class="app-name">ç¾¤æ´»åŠ¨</span>
                                        </div>
                                        <div class="app-item" onclick="showGroupTask()">
                                            <i class="fas fa-tasks app-icon"></i>
                                            <span class="app-name">ç¾¤ä»»åŠ¡</span>
                                        </div>
                                        <div class="app-item" onclick="showMoreApps()">
                                            <i class="fas fa-ellipsis-h app-icon"></i>
                                            <span class="app-name">æ›´å¤š</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- èŠå¤©çª—å£è®¾ç½® -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-user-edit section-icon"></i>
                                    <span class="section-title">èŠå¤©çª—å£è®¾ç½®</span>
                                </div>
                                <div class="setting-card">
                                    <!-- èº«ä»½é€‰æ‹©åŠŸèƒ½å·²ç§»é™¤ï¼Œèº«ä»½åœ¨åˆ›å»ºå¯¹è¯æ—¶é€‰æ‹© -->
                                    <!-- å•èŠæ—¶æ˜¾ç¤ºåŒæ–¹è®¾ç½®ï¼Œç¾¤èŠæ—¶éšè— -->
                                    <div class="setting-item single-chat-only" onclick="showAvatarSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">åŒæ–¹å¤´åƒè®¾ç½®</div>
                                            <div class="setting-desc">è®¾ç½®åœ¨æ­¤èŠå¤©çª—å£ä¸­æ˜¾ç¤ºçš„å¤´åƒ</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item single-chat-only" onclick="showNicknameSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">åŒæ–¹å¤‡æ³¨è®¾ç½®</div>
                                            <div class="setting-desc">è®¾ç½®åœ¨æ­¤èŠå¤©çª—å£ä¸­æ˜¾ç¤ºçš„æ˜µç§°</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showBackgroundSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">èŠå¤©èƒŒæ™¯è®¾ç½®</div>
                                            <div class="setting-desc">è‡ªå®šä¹‰èŠå¤©ç•Œé¢çš„èƒŒæ™¯å›¾ç‰‡</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showBubbleStyleSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">æ°”æ³¡æ ·å¼è®¾ç½®</div>
                                            <div class="setting-desc">é€‰æ‹©æ°”æ³¡å¤–è§‚æ ·å¼å’Œé¢œè‰²</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="current-bubble-style">é»˜è®¤æ ·å¼</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item single-chat-only">
                                        <div class="setting-left">
                                            <div class="setting-label">æ˜¾ç¤ºè§’è‰²çŠ¶æ€</div>
                                            <div class="setting-desc">åœ¨èŠå¤©ç•Œé¢æ˜¾ç¤ºè§’è‰²çš„åœ¨çº¿çŠ¶æ€å’Œæ´»åŠ¨</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="character-status-enabled">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                    
                                    <!-- ğŸ”¥ã€æ–°å¢ã€‘çŠ¶æ€æ›´æ–°é¢‘ç‡è®¾ç½® -->
                                    <div class="setting-item single-chat-only" id="status-frequency-setting" style="display: none;">
                                        <div class="setting-left">
                                            <div class="setting-label">çŠ¶æ€æ›´æ–°é¢‘ç‡</div>
                                            <div class="setting-desc">æ§åˆ¶è§’è‰²çŠ¶æ€çš„æ£€æŸ¥å’Œæ›´æ–°é¢‘ç‡</div>
                                        </div>
                                        <div class="setting-right">
                                            <select class="setting-select" id="status-update-frequency">
                                                <option value="high">é«˜é¢‘ (30ç§’)</option>
                                                <option value="medium-high">ä¸­é«˜é¢‘ (1åˆ†é’Ÿ)</option>
                                                <option value="medium">ä¸­é¢‘ (3åˆ†é’Ÿ)</option>
                                                <option value="medium-low">ä¸­ä½é¢‘ (5åˆ†é’Ÿ)</option>
                                                <option value="low">ä½é¢‘ (10åˆ†é’Ÿ)</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- æˆ³ä¸€æˆ³åŠŸèƒ½è®¾ç½® - å•èŠç‰¹æœ‰ -->
                            <div class="settings-section" id="poke-settings-section">
                                <div class="section-header">
                                    <i class="fas fa-hand-paper section-icon"></i>
                                    <span class="section-title">æˆ³ä¸€æˆ³åŠŸèƒ½</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">å¯ç”¨æˆ³ä¸€æˆ³</div>
                                            <div class="setting-desc">å…è®¸å‘é€æˆ³ä¸€æˆ³æ¶ˆæ¯ï¼ŒåŒæ–¹å¯è‡ªå®šä¹‰æˆ³ä¸€æˆ³åç¼€</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="poke-enabled" checked>
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                    <div class="setting-item poke-settings poke-settings-visible" id="poke-suffix-settings" onclick="showPokeSuffixSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">æˆ³ä¸€æˆ³åç¼€è®¾ç½®</div>
                                            <div class="setting-desc">è‡ªå®šä¹‰åŒæ–¹çš„æˆ³ä¸€æˆ³åŠ¨ä½œåç¼€</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-explanation">
                                        <div class="explanation-text">
                                            <strong>åŠŸèƒ½è¯´æ˜ï¼š</strong><br>
                                            â€¢ ç‚¹å‡»å¯¹æ–¹å¤´åƒå³å¯å‘é€æˆ³ä¸€æˆ³<br>
                                            â€¢ ä½ å¯ä»¥è‡ªå®šä¹‰æˆ³ä¸€æˆ³åç¼€ï¼Œå¦‚"çš„å°è„¸è›‹"ã€"çš„å°æ‰‹"ç­‰<br>
                                            â€¢ è§’è‰²ä¹Ÿä¼šæ ¹æ®å¿ƒæƒ…å’ŒèŠå¤©å†…å®¹è‡ªä¸»ä¿®æ”¹è‡ªå·±çš„æˆ³ä¸€æˆ³åç¼€
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- è®°å¿†è®¾ç½® -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-brain section-icon"></i>
                                    <span class="section-title">è®°å¿†è®¾ç½®</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item" onclick="showHistorySettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">é™„å¸¦å†å²æ¶ˆæ¯æ•°</div>
                                            <div class="setting-desc">è‡ªå®šä¹‰è§’è‰²å›å¤æ—¶å‚è€ƒçš„å†å²å¯¹è¯æ•°é‡</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="current-history-count">5å›åˆ</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>

                                    <div class="setting-item" onclick="showGlobalMemorySettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">å…¨å±€è®°å¿†ç³»ç»Ÿ</div>
                                            <div class="setting-desc">è·¨åœºæ™¯è¿ç»­è®°å¿†ï¼Œè®©è§’è‰²è®°ä½æ‰€æœ‰äº’åŠ¨</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="global-memory-status">7å¤©è®°å¿†</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item single-chat-only" onclick="showMemoryShareSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">ä¸ç¾¤èŠå…±äº«è®°å¿†</div>
                                            <div class="setting-desc">è®©è§’è‰²åœ¨å•èŠä¸­è®°ä½ç¾¤èŠçš„å†…å®¹</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="memory-share-status">å·²å…³é—­</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showWorldbookMountSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">æŒ‚è½½ä¸–ç•Œä¹¦</div>
                                            <div class="setting-desc">è®©è§’è‰²å‚è€ƒé€‰å®šçš„ä¸–ç•Œä¹¦å†…å®¹ä½œä¸ºèƒŒæ™¯çŸ¥è¯†</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="current-worldbook-mount">æœªæŒ‚è½½</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- æ—¶é—´æ„ŸçŸ¥è®¾ç½® -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-clock section-icon"></i>
                                    <span class="section-title">æ—¶é—´æ„ŸçŸ¥</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">æ—¶é—´æ„ŸçŸ¥å¼€å…³</div>
                                            <div class="setting-desc">è§’è‰²ä¼šæ„ŸçŸ¥å½“å‰æ—¶é—´å¹¶è°ƒæ•´å›å¤</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="time-awareness-enabled">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- é€šè¯è®¾ç½® -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-phone section-icon"></i>
                                    <span class="section-title">é€šè¯è®¾ç½®</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">è§’è‰²ä¸»åŠ¨æ‹¨æ‰“ç”µè¯</div>
                                            <div class="setting-desc">å…è®¸è§’è‰²æ ¹æ®å¯¹è¯å†…å®¹ä¸»åŠ¨å‘èµ·é€šè¯</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="ai-call-enabled" class="ai-call-enabled-checkbox">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                    <div class="setting-explanation">
                                        <div class="explanation-text">
                                            <strong>åŠŸèƒ½è¯´æ˜ï¼š</strong><br>
                                            â€¢ <strong>å¼€å¯æ—¶ï¼š</strong>å½“æœ¬å›åˆèŠå¤©ä¸­æåˆ°é€šè¯ç›¸å…³å†…å®¹æ—¶ï¼Œè§’è‰²æœ‰20%æ¦‚ç‡ä¸»åŠ¨ç»™ä½ æ‰“ç”µè¯<br>
                                            â€¢ <strong>å…³é—­æ—¶ï¼š</strong>è§’è‰²ä¸ä¼šä¸»åŠ¨æ‹¨æ‰“ç”µè¯ï¼Œåªèƒ½ç”±ç”¨æˆ·ä¸»åŠ¨å‘èµ·é€šè¯<br>
                                            â€¢ <strong>é€šè¯å…³é”®è¯ï¼š</strong>é€šè¯ã€ç”µè¯ã€è§†é¢‘ã€è¯­éŸ³ã€æ‰“ç»™ä½ ã€æƒ³å¬ã€æƒ³çœ‹ç­‰
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- AIå¿ƒç‡ç›‘æµ‹ -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-heartbeat section-icon"></i>
                                    <span class="section-title">è§’è‰²å¿ƒç‡ç›‘æµ‹</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">å¿ƒç‡ç›‘æµ‹æ˜¾ç¤º</div>
                                            <div class="setting-desc">åœ¨çŠ¶æ€æ æ˜¾ç¤ºè§’è‰²çš„æƒ…æ„Ÿå¿ƒç‡</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="ai-heartrate-enabled">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>





                            <!-- åå°äº’åŠ¨è®¾ç½® -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-robot section-icon"></i>
                                    <span class="section-title">åå°äº’åŠ¨</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">åå°äº’åŠ¨å¼€å…³</div>
                                            <div class="setting-desc">è§’è‰²å¯åœ¨åå°ä¸»åŠ¨æ´»åŠ¨å¹¶å‘é€æ¨é€</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="background-interaction-enabled">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                    <div class="background-interaction-details hide" id="background-interaction-settings">
                                        <div class="setting-item">
                                        <div class="setting-left">
                                                <div class="setting-label">ä¸»åŠ¨èŠå¤©</div>
                                                <div class="setting-desc">è§’è‰²åœ¨ä½ 10åˆ†é’Ÿæœªå›å¤æ—¶ä¸»åŠ¨å‘æ¶ˆæ¯</div>
                                        </div>
                                        <div class="setting-right">
                                                <label class="toggle-switch">
                                                    <input type="checkbox" id="background-chat-enabled">
                                                    <span class="toggle-slider"></span>
                                                </label>
                                        </div>
                                    </div>
                                        
                                        <div class="setting-item" id="chat-frequency-setting" style="display: none;">
                                        <div class="setting-left">
                                                <div class="setting-label">ä¸»åŠ¨èŠå¤©é¢‘ç‡</div>
                                                <div class="setting-desc">è§’è‰²ä¸»åŠ¨å‘èµ·å¯¹è¯çš„é¢‘ç‡</div>
                                        </div>
                                        <div class="setting-right">
                                                <select id="background-chat-frequency" class="setting-select">
                                                    <option value="low">ä½ (1-2å°æ—¶/æ¬¡)</option>
                                                    <option value="medium">ä¸­ (30-60åˆ†é’Ÿ/æ¬¡)</option>
                                                    <option value="high">é«˜ (10-30åˆ†é’Ÿ/æ¬¡)</option>
                                                </select>
                                </div>
                            </div>

                                    <div class="setting-item">
                                        <div class="setting-left">
                                                <div class="setting-label">ä¸»åŠ¨å‘åŠ¨æ€</div>
                                                <div class="setting-desc">è§’è‰²æ ¹æ®äººè®¾ä¸»åŠ¨å‘å¸ƒåŠ¨æ€</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                    <input type="checkbox" id="background-moments-enabled">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>

                                        <div class="setting-item" id="moments-frequency-setting" style="display: none; justify-content: space-between !important; align-items: center !important;">
                                            <div class="setting-left" style="flex: 1 !important;">
                                                <div class="setting-label">ä¸»åŠ¨å‘åŠ¨æ€é¢‘ç‡</div>
                                                <div class="setting-desc">è§’è‰²ä¸»åŠ¨å‘å¸ƒç¤¾äº¤åŠ¨æ€çš„é¢‘ç‡</div>
                                            </div>
                                            <div class="setting-right" style="display: flex !important; align-items: center !important; flex-shrink: 0 !important;">
                                                <select id="background-moments-frequency" class="setting-select">
                                                    <option value="low">ä½ (4-8å°æ—¶/æ¬¡)</option>
                                                    <option value="medium">ä¸­ (2-4å°æ—¶/æ¬¡)</option>
                                                    <option value="high">é«˜ (1-2å°æ—¶/æ¬¡)</option>
                                                </select>
                                            </div>
                                        </div>
                                        
                                        <div class="setting-item" id="scheduled-moments-setting" style="display: none; justify-content: space-between !important; align-items: flex-start !important;">
                                            <div class="setting-left" style="flex: 1 !important;">
                                                <div class="setting-label">å®šæ—¶å‘å¸ƒåŠ¨æ€</div>
                                                <div class="setting-desc">è®¾ç½®å›ºå®šæ—¶é—´ç‚¹è‡ªåŠ¨å‘å¸ƒåŠ¨æ€</div>
                                            </div>
                                            <div class="setting-right" style="display: flex !important; flex-direction: column !important; align-items: flex-end !important; gap: 8px !important; flex-shrink: 0 !important;">
                                                <label class="toggle-switch">
                                                    <input type="checkbox" id="scheduled-moments-enabled">
                                                    <span class="toggle-slider"></span>
                                                </label>
                                                <button onclick="showScheduleTimesModal()" style="background-color: #4a84c1; color: white; border: none; padding: 6px 12px; border-radius: 15px; font-size: 12px;">
                                                    <span id="schedule-times-display">æœªè®¾ç½®</span>
                                                </button>
                                            </div>
                                        </div>
                                        
                                        <div class="setting-item" id="test-publish-setting" style="display: none; justify-content: space-between !important; align-items: center !important;">
                                            <div class="setting-left" style="flex: 1 !important;">
                                                <div class="setting-label">æµ‹è¯•å‘å¸ƒ</div>
                                                <div class="setting-desc">è®©è§’è‰²ç«‹å³å‘å¸ƒä¸€æ¡æµ‹è¯•åŠ¨æ€</div>
                                            </div>
                                            <div class="setting-right" style="display: flex !important; align-items: center !important; flex-shrink: 0 !important; gap: 8px;">
                                                <button onclick="testPublishMoment()" style="background-color: #4a84c1; color: white; border: none; padding: 6px 12px; border-radius: 15px; font-size: 12px;">
                                                    å‘å¸ƒ
                                                </button>
                                                <button onclick="fixAvatarData()" style="background-color: #ff6b6b; color: white; border: none; padding: 6px 12px; border-radius: 15px; font-size: 12px;">
                                                    ä¿®å¤å¤´åƒ
                                                </button>
                                            </div>
                                        </div>

                                    </div>
                                </div>
                            </div>

                            <!-- å…¶ä»–è®¾ç½® -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-cog section-icon"></i>
                                    <span class="section-title">å…¶ä»–è®¾ç½®</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">æ˜¾ç¤ºæ—¶é—´æˆ³</div>
                                            <div class="setting-desc">åœ¨èŠå¤©æ¶ˆæ¯ä¸­æ˜¾ç¤ºæ—¶é—´ä¿¡æ¯</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="timestamp-enabled" checked>
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showTimestampSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">æ—¶é—´æˆ³è®¾ç½®</div>
                                            <div class="setting-desc">è®¾ç½®æ—¶é—´æˆ³æ˜¾ç¤ºä½ç½®å’Œæ ¼å¼</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="searchChatContent()">
                                        <div class="setting-left">
                                            <div class="setting-label">æŸ¥æ‰¾èŠå¤©å†…å®¹</div>
                                            <div class="setting-desc">æœç´¢å†å²æ¶ˆæ¯ä¸­çš„å…³é”®è¯</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="exportChatHistory()">
                                        <div class="setting-left">
                                            <div class="setting-label">å¯¼å‡ºèŠå¤©è®°å½•</div>
                                            <div class="setting-desc">å¯¼å‡ºå½“å‰å¯¹è¯çš„æ‰€æœ‰æ¶ˆæ¯</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>

                                </div>
                            </div>

                            <!-- å±é™©æ“ä½œ -->
                            <div class="settings-section">
                                <div class="section-header">
                                                    <i class="fas fa-exclamation-triangle section-icon danger-section-icon"></i>
                <span class="section-title danger-section-title">å±é™©æ“ä½œ</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item" onclick="showBlacklistSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label" id="block-manage-label">æ‹‰é»‘ç®¡ç†</div>
                                            <div class="setting-desc" id="block-manage-desc">æ‹‰é»‘/è§£é™¤æ‹‰é»‘ç®¡ç†</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item danger-item" onclick="clearChatHistory()">
                                        <div class="setting-left">
                                            <div class="setting-label danger-color">æ¸…ç©ºèŠå¤©è®°å½•</div>
                                            <div class="setting-desc">åˆ é™¤æ‰€æœ‰å†å²æ¶ˆæ¯ï¼Œä¸å¯æ¢å¤</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right danger-color"></i>
                                        </div>
                                    </div>
                                </div>
                            </div>

                        </div>
                    </div>
                </div>
                
                <!-- äººç‰©ç¼–è¾‘è¡¨å• -->
                <div id="character-form-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideCharacterForm()">â€¹</button>
                        <div class="app-title" id="character-form-title">æ–°å»ºäººç‰©</div>
                        <button class="import-character-btn" id="import-character-btn" onclick="importCharacterCard()" title="å¯¼å…¥è§’è‰²å¡">
                            <i class="fas fa-upload"></i>
                        </button>
                        <button class="export-character-btn" id="export-character-btn" onclick="exportCharacterCard()" title="å¯¼å‡ºè§’è‰²å¡" style="display: none;">
                            <i class="fas fa-download"></i>
                        </button>
                    </div>
                    <div class="app-content">
                        <div class="character-form">
                            <div class="form-group avatar-upload">
                                <label class="form-label">å¤´åƒ</label>
                                <div class="avatar-preview" id="avatar-preview">
                                    <div class="avatar-preview-text" id="avatar-preview-text">A</div>
                                </div>
                                <input type="file" id="avatar-upload" accept="image/*" class="file-input-hidden">
                            <input type="file" id="character-card-upload" accept=".png,.json" class="file-input-hidden">
                                <button class="upload-button" onclick="handleAvatarUploadClick()">ä¸Šä¼ å¤´åƒ</button>
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">å§“å</label>
                                <input type="text" class="form-input" id="character-name" placeholder="è¾“å…¥å§“å">
                            </div>
                            <div class="form-group">
                                <label class="form-label">äººè®¾</label>
                                <textarea class="form-textarea" id="character-bio" placeholder="è¾“å…¥äººç‰©è®¾å®š"></textarea>
                            </div>
                            <div class="form-actions form-actions-flex">
                                <button class="form-submit form-submit-flex">ä¿å­˜</button>
                                <button class="form-delete form-delete-red" id="character-delete-btn" onclick="deleteCurrentCharacter()">åˆ é™¤</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- é¢å…·åˆ›å»ºè¡¨å• -->
                <div id="persona-form-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hidePersonaForm()">â€¹</button>
                        <div class="app-title" id="persona-form-title">æ–°å»ºé¢å…·</div>
                    </div>
                    <div class="app-content">
                        <div class="character-form">
                            <div class="form-group avatar-upload">
                                <label class="form-label">å¤´åƒ</label>
                                <div class="avatar-preview" id="persona-avatar-preview">
                                    <div class="avatar-preview-text" id="persona-avatar-preview-text">æˆ‘</div>
                                </div>
                                <input type="file" id="persona-avatar-upload" accept="image/*" class="file-input-hidden">
                                <button class="upload-button" onclick="handlePersonaAvatarUploadClick()">ä¸Šä¼ å¤´åƒ</button>
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">æˆ‘çš„åç§°</label>
                                <input type="text" class="form-input" id="persona-name" placeholder="ä¾‹å¦‚ï¼šuserå°æ˜ã€userå­¦ç”Ÿã€userå·¥ä½œè€…">
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">æˆ‘çš„æè¿°</label>
                                <textarea class="form-textarea" id="persona-description" placeholder="æè¿°è¿™ä¸ªèº«ä»½çš„ç‰¹ç‚¹ï¼ŒåŒ…æ‹¬æ€§æ ¼ã€è¯´è¯é£æ ¼ã€ä½¿ç”¨åœºåˆç­‰..."></textarea>
                            </div>
                            
                            <button class="form-submit" onclick="savePersona()">ä¿å­˜é¢å…·</button>
                        </div>
                    </div>
                </div>
                
                <!-- APIèŠå¤©ç•Œé¢ -->
                <div id="api-chat-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div id="ai-heartrate-display" style="display: none;">â™¥ï¸ 72 bpm</div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="header">
                        <div class="default-controls">
                            <button class="back-btn" onclick="backToChatApp()">â€¹</button>
                            <span class="header-title" id="api-chat-title">è§’è‰²èŠå¤©</span>
                            <div class="header-actions">
                                <span class="action-btn" onclick="toggleOfflineMode()" id="offline-mode-btn" title="åˆ‡æ¢çº¿ä¸‹å‰§æƒ…æ¨¡å¼">
                                    <i class="fas fa-door-open" id="offline-mode-icon"></i>
                                </span>
                                <span class="action-btn" onclick="showChatSettings()">
                                <i class="fas fa-ellipsis-v"></i>
                                </span>
                            </div>
                        </div>
                        <div class="selection-controls">
                            <span id="selection-cancel-btn">å–æ¶ˆ</span>
                            <span id="selection-count"></span>
                            <span id="selection-delete-btn">åˆ é™¤</span>
                        </div>
                    </div>
                    <div class="app-content padding-none-flex">

                        <div class="chat-dialog">
                            <div class="chat-messages" id="api-chat-messages">
                                <!-- èŠå¤©æ¶ˆæ¯å°†é€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
                            </div>
                            
                            <!-- æ‚¬æµ®æŒ‰é’®ç»„ -->
                            <div class="floating-actions" id="floating-actions">
                                <button class="floating-btn" id="regenerate-btn" onclick="regenerateLastResponse()" title="é‡æ–°ç”Ÿæˆå›ç­”">
                                    <i class="fas fa-redo-alt"></i>
                                </button>
                            </div>
                            
                            <div class="chat-input-area">
                                <!-- å±•å¼€çš„å·¥å…·é¢æ¿ -->
                                <div class="tools-panel" id="tools-panel" style="display: none;">
                                    <div class="tools-grid">
                                        <div class="tool-item" onclick="handleVoiceRecording(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-microphone"></i>
                                            </div>
                                            <span class="tool-label">è¯­éŸ³</span>
                                        </div>
                                        <div class="tool-item" onclick="showCustomEmojiPanel(); hideToolsPanel();">
                                            <div class="tool-icon">
                                                <i class="fas fa-smile"></i>
                                            </div>
                                            <span class="tool-label">è¡¨æƒ…</span>
                                        </div>
                                        <div class="tool-item" onclick="openCamera(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-camera"></i>
                                            </div>
                                            <span class="tool-label">æ‹ç…§</span>
                                        </div>
                                        <div class="tool-item" onclick="uploadImage(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-image"></i>
                                            </div>
                                            <span class="tool-label">å›¾ç‰‡</span>
                                        </div>
                                        <div class="tool-item" onclick="openTransfer(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-exchange-alt"></i>
                                            </div>
                                            <span class="tool-label">è½¬è´¦</span>
                                        </div>
                                        <div class="tool-item" onclick="makeCall(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-phone"></i>
                                            </div>
                                            <span class="tool-label">ç”µè¯</span>
                                        </div>
                                        <div class="tool-item" onclick="openVideoCall(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-video"></i>
                                            </div>
                                            <span class="tool-label">è§†é¢‘</span>
                                        </div>
                                        <div class="tool-item" onclick="shareLocation(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-map-marker-alt"></i>
                                            </div>
                                            <span class="tool-label">ä½ç½®</span>
                                        </div>
                                        <div class="tool-item diary-tool" onclick="showDiaryMenu(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-book"></i>
                                            </div>
                                            <span class="tool-label">æ—¥è®°</span>
                                        </div>
                                        <div class="tool-item" onclick="openMusicPlayer(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-headphones"></i>
                                            </div>
                                            <span class="tool-label">å¬æ­Œ</span>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- è¾“å…¥åŒºåŸŸ -->
                                <div class="input-controls">
                                <button class="chat-action-btn toggle-tools-btn" onclick="toggleToolsPanel()" title="åŠŸèƒ½èœå•" id="toggle-tools-btn">
                                    <i class="fas fa-plus"></i>
                                </button>
                                <div style="position: relative; flex: 1; min-width: 0;">
                                    <textarea class="chat-input" id="api-chat-input" rows="1" placeholder="è¾“å…¥æ¶ˆæ¯..."></textarea>
                                    <!-- @ç¾¤æˆå‘˜ä¸‹æ‹‰é€‰æ‹©æ¡† -->
                                    <div class="mention-dropdown" id="mention-dropdown">
                                        <!-- åŠ¨æ€ç”Ÿæˆç¾¤æˆå‘˜åˆ—è¡¨ -->
                                    </div>
                                </div>
                                    <button class="chat-action-btn" onclick="triggerSmartReply()" title="è·å–AIå›å¤">
                                        <i class="fas fa-comment-dots"></i>
                                </button>
                                <button class="send-button" onclick="sendApiMessage()">
                                    å‘é€
                                </button>
                                </div>
                                <input type="file" id="image-upload" accept="image/*" class="file-input-hidden">
                                <input type="file" id="emoji-upload" accept="image/*" class="file-input-hidden" multiple>
                            </div>
                        </div>
                        
                        <!-- è‡ªå®šä¹‰è¡¨æƒ…åŒ…é¢æ¿ -->
                        <div class="custom-emoji-panel" id="custom-emoji-panel">
                            <div class="emoji-tabs">
                                <div class="emoji-tab active" data-tab="recent">æœ€è¿‘</div>
                                <div class="emoji-tab" data-tab="custom">å…¨éƒ¨</div>
                            </div>
                            <div class="emoji-content">
                                <div class="emoji-grid" id="emoji-grid">
                                    <!-- è¡¨æƒ…åŒ…ç½‘æ ¼å°†é€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- çº¿ä¸‹å‰§æƒ…æ¨¡å¼è¦†ç›–å±‚ -->
                    <div id="offline-mode-overlay" class="offline-mode-overlay" style="display: none;">
                        <div class="offline-mode-header">
                            <button class="back-btn" onclick="exitOfflineMode()">â€¹</button>
                            <span class="header-title" id="offline-mode-title">çº¿ä¸‹å‰§æƒ…æ¨¡å¼</span>
                            <div class="header-actions">
                                <span class="action-btn" onclick="showOfflineHistoryModal()" title="æŸ¥çœ‹èŠå¤©è®°å½•">
                                    <i class="fas fa-history"></i>
                                </span>
                                <span class="action-btn" onclick="showOfflineUISettings()" title="ç•Œé¢è®¾ç½®">
                                    <i class="fas fa-cog"></i>
                                </span>
                                <span class="action-btn" onclick="showOfflinePresetSettings()" title="æ·»åŠ é¢„è®¾">
                                    <i class="fas fa-plus"></i>
                                </span>
                            </div>
                        </div>

                        <div class="offline-mode-content">
                            <div class="offline-chat-messages" id="offline-chat-messages">
                                <!-- çº¿ä¸‹æ¨¡å¼çš„èŠå¤©æ¶ˆæ¯ -->
                            </div>

                            <div class="offline-input-area">
                                <div class="offline-input-container">
                                    <textarea id="offline-input" placeholder="åœ¨çº¿ä¸‹å‰§æƒ…æ¨¡å¼ä¸­è¾“å…¥..." rows="3"></textarea>
                                    <div class="offline-button-group">
                                        <button class="offline-regenerate-btn" onclick="regenerateLastOfflineMessage()" title="é‡æ–°ç”ŸæˆAIå›å¤">
                                            <i class="fas fa-redo-alt"></i>
                                        </button>
                                        <button class="offline-send-btn" onclick="sendOfflineMessage()">
                                            <i class="fas fa-paper-plane"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- æµè§ˆå™¨ç•Œé¢ -->
                <div id="browser-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('browser-screen')">â€¹</button>
                        <div class="app-title">æµè§ˆå™¨</div>
                    </div>
                    <div class="app-content padding-none-flex">
                        <div class="browser-toolbar">
                            <input type="text" class="browser-url-bar" id="browser-url" placeholder="è¾“å…¥ç½‘å€">
                            <button onclick="loadUrl()">å‰å¾€</button>
                        </div>
                        <iframe class="browser-content" id="browser-frame"></iframe>
                    </div>
                </div>
                

                
                <!-- æ¸¸æˆç•Œé¢ -->
                <div id="game-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('game-screen')">â€¹</button>
                        <div class="app-title">æ¸¸æˆä¸­å¿ƒ</div>
                    </div>
                    <div class="app-content">
                        <div class="game-list">
                            <div class="game-item" onclick="startGame('witchPotion')">
                                <div class="game-icon">
                                    <i class="fas fa-flask"></i>
                        </div>
                                <div class="game-info">
                                    <div class="game-name">å¥³å·«çš„è§£è¯</div>
                                    <div class="game-desc">ä¸AIè§’è‰²ä¸€èµ·è°ƒåˆ¶ç¥ç§˜è¯æ°´</div>
                                </div>
                                <div class="game-badge">NEW</div>
                            </div>
                            <div class="game-item coming-soon">
                                <div class="game-icon">
                                    <i class="fas fa-dice"></i>
                                </div>
                                <div class="game-info">
                                    <div class="game-name">è§’è‰²çŒœè°œ</div>
                                    <div class="game-desc">å³å°†æ¨å‡º</div>
                                </div>
                            </div>
                            <div class="game-item coming-soon">
                                <div class="game-icon">
                                    <i class="fas fa-book"></i>
                                </div>
                                <div class="game-info">
                                    <div class="game-name">äº’åŠ¨æ•…äº‹</div>
                                    <div class="game-desc">å³å°†æ¨å‡º</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                

                

                
                <!-- è®¾ç½®åº”ç”¨ -->
                <div id="settings-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('settings-screen')">â€¹</button>
                        <div class="app-title">è®¾ç½®</div>
                    </div>
                    <div class="app-content">
                        <div class="settings-item" onclick="showApp('api-settings-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon wifi">
                                    <i class="fas fa-wifi"></i>
                                </div>
                                <div>APIè®¾ç½®</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('theme-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon settings-icon-custom">
                                    <i class="fas fa-palette"></i>
                                </div>
                                <div>ä¸»é¢˜è®¾ç½®</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('display-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon display">
                                    <i class="fas fa-font"></i>
                                </div>
                                <div>å­—å·å¤§å°</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('appearance-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon display">
                                    <i class="fas fa-mobile-alt"></i>
                                </div>
                                <div>å¤–è§‚è®¾ç½®</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('wallpaper-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon wallpaper">
                                    <i class="fas fa-image"></i>
                                </div>
                                <div>å£çº¸</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('datetime-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon datetime">
                                    <i class="fas fa-clock"></i>
                                </div>
                                <div>æ—¥æœŸä¸æ—¶é—´</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div class="settings-icon notification">
                                    <i class="fas fa-bell"></i>
                                </div>
                                <div>é€šçŸ¥</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('data-management-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon data-management">
                                    <i class="fas fa-database"></i>
                                </div>
                                <div>æ•°æ®ç®¡ç†</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('emergency-recovery-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon" style="background: #ff4444; color: white;">
                                    <i class="fas fa-life-ring"></i>
                                </div>
                                <div>ç´§æ€¥æ¢å¤</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('about-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon about">
                                    <i class="fas fa-info-circle"></i>
                                </div>
                                <div>å…³äºæˆ‘ä»¬</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                    </div>
                </div>
                
                <!-- æ—¥æœŸä¸æ—¶é—´è®¾ç½® -->
                <div id="datetime-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('datetime-screen')">â€¹</button>
                        <div class="app-title">æ—¥æœŸä¸æ—¶é—´</div>
                    </div>
                    <div class="app-content">
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>è‡ªåŠ¨è®¾ç½®</div>
                            </div>
                            <label class="settings-toggle">
                                <input type="checkbox" checked>
                                <span class="settings-slider"></span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <!-- æ•°æ®ç®¡ç† -->
                <div id="data-management-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('data-management-screen')">â€¹</button>
                        <div class="app-title">æ•°æ®ç®¡ç†</div>
                    </div>
                    <div class="app-content">
                        <!-- å­˜å‚¨ç©ºé—´ä½¿ç”¨æƒ…å†µ -->
                        <div class="data-section">
                            <div class="data-section-title">å­˜å‚¨ç©ºé—´ä½¿ç”¨æƒ…å†µ</div>
                            <div class="storage-usage" id="storage-usage">
                                <div class="storage-item">
                                    <div class="storage-label">èŠå¤©è®°å½•</div>
                                    <div class="storage-size" id="chat-storage-size">è®¡ç®—ä¸­...</div>
                                </div>
                                <div class="storage-item">
                                    <div class="storage-label">è§’è‰²æ•°æ®</div>
                                    <div class="storage-size" id="character-storage-size">è®¡ç®—ä¸­...</div>
                                </div>
                                <div class="storage-item">
                                    <div class="storage-label">èŠå¤©è®¾ç½®</div>
                                    <div class="storage-size" id="settings-storage-size">è®¡ç®—ä¸­...</div>
                                </div>
                                <div class="storage-item">
                                    <div class="storage-label">è¡¨æƒ…åŒ…</div>
                                    <div class="storage-size" id="emoji-storage-size">è®¡ç®—ä¸­...</div>
                                </div>
                                <div class="storage-total">
                                    <div class="storage-label">æ€»è®¡</div>
                                    <div class="storage-size" id="total-storage-size">è®¡ç®—ä¸­...</div>
                                </div>
                            </div>
                        </div>

                        <!-- æ•°æ®å¯¼å…¥å¯¼å‡º -->
                        <div class="data-section">
                            <div class="data-section-title">æ•°æ®å¤‡ä»½ä¸æ¢å¤</div>
                            <div class="settings-item" onclick="exportAllData()">
                                <div class="settings-item-left">
                                    <div class="settings-icon export">
                                        <i class="fas fa-download"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">å¯¼å‡ºæ‰€æœ‰æ•°æ®</div>
                                        <div class="setting-desc">å°†æ‰€æœ‰èŠå¤©è®°å½•å’Œè®¾ç½®å¯¼å‡ºä¸ºJSONæ–‡ä»¶</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="settings-item" onclick="importDataFromFile()">
                                <div class="settings-item-left">
                                    <div class="settings-icon import">
                                        <i class="fas fa-upload"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">å¯¼å…¥æ•°æ®</div>
                                        <div class="setting-desc">ä»JSONæ–‡ä»¶æ¢å¤èŠå¤©è®°å½•å’Œè®¾ç½®</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>

                        <!-- æ•°æ®æ£€æŸ¥ä¸ä¿®å¤ -->
                        <div class="data-section">
                            <div class="data-section-title">æ•°æ®æ£€æŸ¥ä¸ä¿®å¤</div>
                            <div class="settings-item" onclick="checkAndFixChatHistory()">
                                <div class="settings-item-left">
                                    <div class="settings-icon import">
                                        <i class="fas fa-search"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">æ£€æŸ¥èŠå¤©å†å²</div>
                                        <div class="setting-desc">æ£€æŸ¥å¹¶ä¿®å¤èŠå¤©è®°å½•æ•°æ®ï¼Œæ¢å¤ä¸¢å¤±çš„æ¶ˆæ¯</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="settings-item" onclick="cleanupOldChatSettingsFromLocalStorage()">
                                <div class="settings-item-left">
                                    <div class="settings-icon cleanup">
                                        <i class="fas fa-broom"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">æ¸…ç†æ—§è®¾ç½®æ•°æ®</div>
                                        <div class="setting-desc">æ¸…ç†localStorageä¸­çš„æ—§èŠå¤©è®¾ç½®ï¼Œé‡Šæ”¾å­˜å‚¨ç©ºé—´</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="settings-item" onclick="debugChatMessagesFormat()">
                                <div class="settings-item-left">
                                    <div class="settings-icon debug">
                                        <i class="fas fa-bug"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">è°ƒè¯•èŠå¤©è®°å½•æ ¼å¼</div>
                                        <div class="setting-desc">åˆ†æèŠå¤©è®°å½•çš„æ•°æ®æ ¼å¼ï¼Œå¸®åŠ©è¯Šæ–­å¯¼å…¥é—®é¢˜</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                        
                        <!-- é€‰æ‹©æ€§æ¸…ç† -->
                        <div class="data-section">
                            <div class="data-section-title">å­˜å‚¨æ¸…ç†</div>
                            <div class="settings-item" onclick="cleanupOrphanedContacts()">
                                <div class="settings-item-left">
                                    <div class="settings-icon cleanup">
                                        <i class="fas fa-user-slash"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">æ¸…ç†å­¤ç«‹æ•°æ®</div>
                                        <div class="setting-desc">æ¸…ç†ä¸å­˜åœ¨çš„è§’è‰²æ•°æ®å’Œç›¸å…³è®°å½•</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>

                            <div class="settings-item" onclick="showCleanupOptions()">
                                <div class="settings-item-left">
                                    <div class="settings-icon cleanup">
                                        <i class="fas fa-broom"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">é€‰æ‹©æ€§æ¸…ç†</div>
                                        <div class="setting-desc">æ¸…ç†ç‰¹å®šç±»å‹çš„æ•°æ®ä»¥é‡Šæ”¾ç©ºé—´</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="settings-item" onclick="compressAllImages()">
                                <div class="settings-item-left">
                                    <div class="settings-icon compress">
                                        <i class="fas fa-compress-arrows-alt"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">å‹ç¼©å›¾ç‰‡</div>
                                        <div class="setting-desc">å‹ç¼©æ‰€æœ‰å¤´åƒå’ŒèƒŒæ™¯å›¾ç‰‡ä»¥èŠ‚çœç©ºé—´</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>

                        <!-- å±é™©æ“ä½œ -->
                        <div class="data-section danger-section">
                            <div class="data-section-title">å±é™©æ“ä½œ</div>
                            <div class="settings-item danger-item" onclick="clearAllData()">
                                <div class="settings-item-left">
                                    <div class="settings-icon danger">
                                        <i class="fas fa-trash-alt"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">æ¸…ç©ºæ‰€æœ‰æ•°æ®</div>
                                        <div class="setting-desc">åˆ é™¤æ‰€æœ‰èŠå¤©è®°å½•ã€è§’è‰²å’Œè®¾ç½®ï¼ˆä¸å¯æ¢å¤ï¼‰</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- ğŸš¨ ç´§æ€¥æ¢å¤ç•Œé¢ -->
                <div class="app-screen" id="emergency-recovery-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('emergency-recovery-screen')">â€¹</button>
                        <div class="app-title" style="color: #ff4444;">ğŸš¨ ç´§æ€¥æ¢å¤</div>
                    </div>
                    <div class="app-content">
                        <div style="padding: 20px; color: #333;">
                            <!-- è­¦å‘Šå¡ç‰‡ - æ¯›ç»ç’ƒé£æ ¼ -->
                            <div style="background: linear-gradient(135deg, rgba(255, 68, 68, 0.15) 0%, rgba(255, 68, 68, 0.08) 100%); border: 2px solid rgba(255, 68, 68, 0.3); border-radius: 16px; padding: 20px; margin-bottom: 25px; backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); box-shadow: 0 8px 32px rgba(255, 68, 68, 0.1);">
                                <h3 style="color: #ff4444; margin: 0 0 12px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>âš ï¸</span> æ•°æ®ä¸¢å¤±æ£€æµ‹
                                </h3>
                                <p style="margin: 0; font-size: 15px; color: #666; line-height: 1.5;">å¦‚æœæ‚¨çš„è§’è‰²çªç„¶æ¶ˆå¤±ï¼Œè¯·ä½¿ç”¨ä»¥ä¸‹åŠŸèƒ½æ¢å¤æ•°æ®ã€‚</p>
                            </div>

                            <!-- ç¬¬ä¸€æ­¥ -->
                            <div class="recovery-section" style="background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 25px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08); border: 1px solid rgba(255, 255, 255, 0.2);">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>ğŸ”</span> ç¬¬ä¸€æ­¥ï¼šæ£€æŸ¥æ•°æ®çŠ¶æ€
                                </h4>
                                <button onclick="checkDataStatus()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-bg, rgba(74, 132, 193, 0.9)); color: var(--theme-button-color, white); border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: var(--theme-button-shadow, 0 4px 15px rgba(74, 132, 193, 0.3)); transition: all 0.3s ease; margin-bottom: 15px;">
                                    æ£€æŸ¥å½“å‰æ•°æ®çŠ¶æ€
                                </button>
                                <div id="data-status-result" style="background: rgba(248, 249, 250, 0.9); border-radius: 12px; padding: 15px; margin-bottom: 20px; display: none; backdrop-filter: blur(10px); border: 1px solid rgba(0,0,0,0.05);">
                                    <pre id="data-status-text" style="font-size: 12px; margin: 0; white-space: pre-wrap; color: #333; font-family: 'SF Mono', Monaco, monospace;"></pre>
                                </div>
                            </div>

                            <!-- ç¬¬äºŒæ­¥ -->
                            <div class="recovery-section" style="background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 25px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08); border: 1px solid rgba(255, 255, 255, 0.2);">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>ğŸ”</span> ç¬¬äºŒæ­¥ï¼šæ·±åº¦æ•°æ®æŒ–æ˜
                                </h4>
                                <p style="font-size: 14px; color: #666; margin-bottom: 15px; line-height: 1.5;">æœç´¢æµè§ˆå™¨ä¸­å¯èƒ½æ®‹ç•™çš„è§’è‰²æ•°æ®ï¼š</p>
                                <div style="display: flex; flex-direction: column; gap: 12px;">
                                    <button onclick="deepDataSearch()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-bg, rgba(74, 132, 193, 0.9)); color: var(--theme-button-color, white); border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: var(--theme-button-shadow, 0 4px 15px rgba(74, 132, 193, 0.3)); transition: all 0.3s ease;">
                                        ğŸ” æ·±åº¦æœç´¢æ®‹ç•™æ•°æ®
                                    </button>
                                    <button onclick="searchChatHistory()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-secondary-bg, rgba(255, 255, 255, 0.8)); color: var(--theme-button-secondary-color, #666); border: 2px solid var(--theme-button-secondary-border, rgba(0, 0, 0, 0.1)); border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); transition: all 0.3s ease;">
                                        ğŸ’¬ ä»èŠå¤©è®°å½•æ¨æ–­è§’è‰²
                                    </button>
                                </div>
                                <div id="deep-search-result" style="background: rgba(248, 249, 250, 0.9); border-radius: 12px; padding: 15px; margin-top: 15px; display: none; backdrop-filter: blur(10px); border: 1px solid rgba(0,0,0,0.05);">
                                    <pre id="deep-search-text" style="font-size: 12px; margin: 0; white-space: pre-wrap; color: #333; font-family: 'SF Mono', Monaco, monospace;"></pre>
                                </div>
                            </div>

                            <!-- ç¬¬ä¸‰æ­¥ -->
                            <div class="recovery-section" style="background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 25px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08); border: 1px solid rgba(255, 255, 255, 0.2);">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>ğŸ“¥</span> ç¬¬ä¸‰æ­¥ï¼šæ–‡ä»¶å¯¼å…¥æ¢å¤
                                </h4>
                                <p style="font-size: 14px; color: #666; margin-bottom: 15px; line-height: 1.5;">å¦‚æœæ‚¨æœ‰å¤‡ä»½æ–‡ä»¶ï¼š</p>
                                <input type="file" id="recovery-file-input" accept=".json" style="width: 100%; padding: 12px 15px; border: 2px solid rgba(0, 0, 0, 0.08); border-radius: 12px; font-size: 16px; background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(10px); transition: all 0.3s ease; color: #333; box-sizing: border-box; margin-bottom: 15px;">
                                <button onclick="recoverFromFile()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-bg, rgba(74, 132, 193, 0.9)); color: var(--theme-button-color, white); border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: var(--theme-button-shadow, 0 4px 15px rgba(74, 132, 193, 0.3)); transition: all 0.3s ease;">
                                    ä»æ–‡ä»¶æ¢å¤æ•°æ®
                                </button>
                            </div>

                            <!-- ç¬¬å››æ­¥ -->
                            <div class="recovery-section" style="background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 25px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08); border: 1px solid rgba(255, 255, 255, 0.2);">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>ğŸ”§</span> ç¬¬å››æ­¥ï¼šé‡å»ºè§’è‰²å¡
                                </h4>
                                <p style="font-size: 14px; color: #666; margin-bottom: 15px; line-height: 1.5;">ä»èŠå¤©è®°å½•é‡å»ºä¸¢å¤±çš„è§’è‰²ï¼š</p>
                                <div style="display: flex; flex-direction: column; gap: 12px;">
                                    <button onclick="rebuildCharactersFromChat()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-bg, rgba(74, 132, 193, 0.9)); color: var(--theme-button-color, white); border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: var(--theme-button-shadow, 0 4px 15px rgba(74, 132, 193, 0.3)); transition: all 0.3s ease;">
                                        ğŸ”§ è‡ªåŠ¨é‡å»ºæ‰€æœ‰è§’è‰²
                                    </button>
                                    <button onclick="showManualRebuild()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-secondary-bg, rgba(255, 255, 255, 0.8)); color: var(--theme-button-secondary-color, #666); border: 2px solid var(--theme-button-secondary-border, rgba(0, 0, 0, 0.1)); border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); transition: all 0.3s ease;">
                                        âœï¸ æ‰‹åŠ¨é‡å»ºè§’è‰²
                                    </button>
                                </div>
                            </div>

                            <!-- è°ƒè¯•å·¥å…· -->
                            <div class="recovery-section" style="background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 25px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08); border: 1px solid rgba(255, 255, 255, 0.2);">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>ğŸ”</span> è°ƒè¯•ï¼šæ£€æŸ¥å½“å‰çŠ¶æ€
                                </h4>
                                <div style="display: flex; flex-direction: column; gap: 12px;">
                                    <button onclick="debugCurrentState()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-secondary-bg, rgba(255, 255, 255, 0.8)); color: var(--theme-button-secondary-color, #666); border: 2px solid var(--theme-button-secondary-border, rgba(0, 0, 0, 0.1)); border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); transition: all 0.3s ease;">
                                        ğŸ” æ£€æŸ¥å½“å‰æ•°æ®çŠ¶æ€
                                    </button>
                                    <button onclick="forceRefreshAll()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-bg, rgba(74, 132, 193, 0.9)); color: var(--theme-button-color, white); border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: var(--theme-button-shadow, 0 4px 15px rgba(74, 132, 193, 0.3)); transition: all 0.3s ease;">
                                        ğŸ”„ å¼ºåˆ¶åˆ·æ–°æ‰€æœ‰ç•Œé¢
                                    </button>
                                </div>
                            </div>

                            <!-- ç¬¬äº”æ­¥ -->
                            <div class="recovery-section" style="background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 25px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08); border: 1px solid rgba(255, 255, 255, 0.2);">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>ğŸ§¹</span> ç¬¬äº”æ­¥ï¼šæ¸…ç†å¼‚å¸¸æ•°æ®
                                </h4>
                                <div style="display: flex; flex-direction: column; gap: 12px;">
                                    <button onclick="cleanupBadData()" style="width: 100%; padding: 14px 20px; background: var(--theme-button-secondary-bg, rgba(255, 255, 255, 0.8)); color: var(--theme-button-secondary-color, #666); border: 2px solid var(--theme-button-secondary-border, rgba(0, 0, 0, 0.1)); border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); transition: all 0.3s ease;">
                                        æ¸…é™¤å¼ ä¸‰æå››ç­‰å¼‚å¸¸è§’è‰²
                                    </button>
                                    <button onclick="forceReload()" style="width: 100%; padding: 14px 20px; background: #FF3B30; color: white; border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: 0 4px 15px rgba(255, 59, 48, 0.3); transition: all 0.3s ease;">
                                        å¼ºåˆ¶é‡æ–°åŠ è½½æ•°æ®
                                    </button>
                                </div>
                            </div>

                            <!-- æ¢å¤æ—¥å¿— -->
                            <div id="recovery-log" style="background: rgba(248, 249, 250, 0.9); border-radius: 16px; padding: 20px; margin-top: 20px; max-height: 200px; overflow-y: auto; display: none; backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border: 1px solid rgba(0,0,0,0.05); box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);">
                                <h5 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>ğŸ“‹</span> æ¢å¤æ—¥å¿—ï¼š
                                </h5>
                                <div id="recovery-log-content" style="font-size: 13px; font-family: 'SF Mono', Monaco, monospace; color: #555; line-height: 1.4;"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- å…³äºæˆ‘ä»¬ -->
                <div id="about-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('about-screen')">â€¹</button>
                        <div class="app-title">å…³äºæˆ‘ä»¬</div>
                    </div>
                    <div class="app-content">
                        <div class="about-content">
                            <div class="about-title">iPhone æ¨¡æ‹Ÿå™¨</div>
                            <div class="about-version">ç‰ˆæœ¬ 1.0.0</div>
                            <div class="about-author">ä½œè€…@EVE</div>
                        </div>
                    </div>
                </div>
                
                <!-- ç”µè¯é€šè¯ç•Œé¢ -->
                <div id="phone-call-screen" class="app-screen">
                    <div class="call-background"></div>
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="call-content">
                        <div class="call-header">
                            <div class="call-avatar">
                                <img id="call-avatar-img" src="" alt="é€šè¯å¤´åƒ">
                            </div>
                            <div class="call-name" id="call-name">è§’è‰²åç§°</div>
                            <div class="call-status" id="call-status">æ­£åœ¨é€šè¯ä¸­...</div>
                            <div class="call-time" id="call-timer">00:00</div>
                        </div>
                        
                        <div class="call-message-container" id="call-message-container">
                            <!-- é€šè¯ä¸­çš„æ¶ˆæ¯å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
                        </div>
                        
                        <div class="call-input-area">
                            <input type="text" id="call-input" placeholder="è¾“å…¥æ¶ˆæ¯..." class="call-text-input" onkeypress="if(event.key === 'Enter') { event.preventDefault(); sendCallMessage(); }">
                            <button class="call-send-btn" onclick="sendCallMessage()">
                                <i class="fas fa-paper-plane"></i>
                            </button>
                        </div>
                        
                        <div class="call-controls">
                                                    <button class="call-control-btn end-call-btn" onclick="endCall()"></button>
                        </div>
                    </div>
                </div>
                
                <!-- æ¥ç”µæ˜¾ç¤ºç•Œé¢ -->
                <div id="incoming-call-screen" class="app-screen">
                    <div class="call-background incoming"></div>
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="incoming-call-content">
                        <div class="call-header">
                            <div class="call-avatar large-avatar">
                                <img id="incoming-call-avatar" src="" alt="æ¥ç”µå¤´åƒ">
                            </div>
                            <div class="call-name" id="incoming-call-name">è§’è‰²åç§°</div>
                            <div class="call-status">æ¥ç”µ</div>
                            <div class="call-text" id="incoming-call-text">æƒ³å’Œä½ é€šè¯...</div>
                        </div>
                        
                        <div class="incoming-call-controls">
                            <button class="incoming-call-btn reject-btn" onclick="rejectCall()">
                                <div class="call-btn-icon">
                                    <i class="fas fa-phone-slash"></i>
                                </div>
                                <div class="call-btn-text">æ‹’ç»</div>
                            </button>
                            <button class="incoming-call-btn accept-btn" onclick="acceptCall()">
                                <div class="call-btn-icon">
                                    <i class="fas fa-phone"></i>
                                </div>
                                <div class="call-btn-text">æ¥å¬</div>
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- å­—å·å¤§å°è®¾ç½® -->
                <div id="display-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('display-screen')">â€¹</button>
                        <div class="app-title">å­—å·å¤§å°</div>
                    </div>
                    <div class="app-content">
                        <div class="font-size-preview">
                            <div class="font-size-preview-text" id="font-size-preview">
                                è¿™æ˜¯ä¸€æ®µç¤ºä¾‹æ–‡å­—ï¼Œç”¨äºé¢„è§ˆå­—ä½“å¤§å°æ•ˆæœã€‚è°ƒèŠ‚ä¸‹æ–¹æ»‘å—å¯ä»¥æ”¹å˜å­—ä½“å¤§å°ã€‚
                            </div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">å­—å·å¤§å°</div>
                                    <div class="setting-desc">è°ƒèŠ‚èŠå¤©æ¶ˆæ¯å’Œç¤¾äº¤åŠ¨æ€çš„å­—ä½“å¤§å°</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="font-size-slider-container">
                            <div class="font-size-labels">
                                <span>å°</span>
                                <span>æ ‡å‡†</span>
                                <span>å¤§</span>
                            </div>
                            <input type="range" class="font-size-slider" id="font-size-slider" 
                                   min="12" max="20" step="1" value="15" 
                                   onchange="changeFontSize(this.value)">
                            <div class="font-size-value">
                                å½“å‰å­—å·ï¼š<span id="font-size-value">15px</span>
                            </div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">å­—è·è®¾ç½®</div>
                                    <div class="setting-desc">è°ƒèŠ‚æ–‡å­—ä¹‹é—´çš„é—´è·</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="font-size-slider-container">
                            <div class="font-size-labels">
                                <span>ç´§å‡‘</span>
                                <span>æ ‡å‡†</span>
                                <span>å®½æ¾</span>
                            </div>
                            <input type="range" class="font-size-slider" id="letter-spacing-slider" 
                                   min="-0.5" max="2" step="0.1" value="0" 
                                   onchange="changeLetterSpacing(this.value)">
                            <div class="font-size-value">
                                å½“å‰å­—è·ï¼š<span id="letter-spacing-value">æ ‡å‡†</span>
                            </div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">è‡ªåŠ¨ç¼©æ”¾</div>
                                    <div class="setting-desc">æ ¹æ®å±å¹•å°ºå¯¸è‡ªåŠ¨è°ƒæ•´å­—ä½“å¤§å°</div>
                                </div>
                            </div>
                            <label class="settings-toggle">
                                <input type="checkbox" id="auto-scale-toggle" onchange="toggleAutoScale()">
                                <span class="settings-slider"></span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <!-- å±å¹•å°ºå¯¸è®¾ç½® -->
                <div id="screen-size-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('screen-size-screen')">â€¹</button>
                        <div class="app-title">å±å¹•å°ºå¯¸</div>
                    </div>
                    <div class="app-content">
                        <div class="size-option" onclick="changeScreenSize(350, 740, 'é€‚ä¸­å°ºå¯¸')" id="size-350-740">
                            <div class="size-option-left">
                                <div class="size-name">é€‚ä¸­å°ºå¯¸</div>
                                <div class="size-desc">350Ã—740 (æ¨è)</div>
                            </div>
                            <div class="size-preview">
                                <div class="size-preview-rect size-preview-rect-s"></div>
                            </div>
                            <i class="fas fa-check check-icon"></i>
                        </div>

                        <div class="size-option" onclick="changeScreenSize(425, 860, 'iPhone 15')">
                            <div class="size-option-left">
                                <div class="size-name">iPhone 15</div>
                                <div class="size-desc">425Ã—860 (é€‚é…æ‰‹æœº)</div>
                            </div>
                            <div class="size-preview">
                                <div class="size-preview-rect size-preview-rect-l"></div>
                            </div>
                        </div>

                        <div class="size-option" onclick="changeScreenSize(450, 950, 'iPhone 15 Plus')">
                            <div class="size-option-left">
                                <div class="size-name">iPhone 15 Plus</div>
                                <div class="size-desc">450Ã—950 (å¤§å±)</div>
                            </div>
                            <div class="size-preview">
                                <div class="size-preview-rect size-preview-rect-xl"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- å¤–è§‚è®¾ç½® -->
                <div id="appearance-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('appearance-screen')">â€¹</button>
                        <div class="app-title">å¤–è§‚è®¾ç½®</div>
                    </div>
                    <div class="app-content">
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">æ˜¾ç¤ºæ‰‹æœºè¾¹æ¡†</div>
                                    <div class="setting-desc">æ˜¾ç¤ºåœ†è§’è¾¹æ¡†å’Œé˜´å½±æ•ˆæœ</div>
                                </div>
                            </div>
                            <label class="settings-toggle">
                                <input type="checkbox" id="phone-border-toggle" checked onchange="togglePhoneBorder()">
                                <span class="settings-slider"></span>
                            </label>
                        </div>
                        <div class="settings-item" onclick="showScreenSizeOptions()">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">å±å¹•å°ºå¯¸</div>
                                    <div class="setting-desc" id="current-screen-size">å½“å‰ï¼š350Ã—740 (é€‚ä¸­å°ºå¯¸)</div>
                                </div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">çŠ¶æ€æ å›¾æ ‡</div>
                                    <div class="setting-desc">è‡ªå®šä¹‰æ—¶é—´å³ä¾§æ˜¾ç¤ºçš„å›¾æ ‡æˆ–æ–‡å­—</div>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <input type="text" id="status-icon-input" placeholder="ğŸ¾" maxlength="5"
                                       style="width: 50px; padding: 6px 8px; border: 1px solid var(--theme-input-border, rgba(0, 0, 0, 0.08));
                                              border-radius: var(--theme-input-radius, 15px); background: var(--theme-form-bg, rgba(255, 255, 255, 0.8));
                                              font-size: 14px; text-align: center;"
                                       onchange="updateStatusIcon()">
                                <button onclick="resetStatusIcon()"
                                        style="padding: 6px 10px; background: var(--theme-button-secondary-bg, rgba(255, 255, 255, 0.8));
                                               border: 1px solid var(--theme-button-secondary-border, rgba(0, 0, 0, 0.1));
                                               border-radius: var(--theme-input-radius, 15px); color: var(--theme-button-secondary-color, #555);
                                               font-size: 12px; cursor: pointer; flex-shrink: 0;">
                                    é‡ç½®
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- ä¸»é¢˜è®¾ç½®ç•Œé¢ -->
                <div id="theme-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('theme-screen')">â€¹</button>
                        <div class="app-title">ä¸»é¢˜è®¾ç½®</div>
                    </div>
                    <div class="app-content">
                        <div class="theme-option" onclick="changeTheme('default')">
                            <div class="theme-preview theme-preview-simple">
                                <div class="theme-preview-header"></div>
                                <div class="theme-preview-content"></div>
                            </div>
                            <div class="theme-info">
                                <div class="theme-name">ç®€çº¦é£æ ¼</div>
                                <div class="theme-description">æ¸…æ–°ç®€æ´çš„é»˜è®¤ä¸»é¢˜</div>
                            </div>
                        </div>
                        
                        <div class="theme-option" onclick="changeTheme('cute')">
                            <div class="theme-preview theme-preview-cute">
                                <div class="theme-preview-header"></div>
                                <div class="theme-preview-content"></div>
                            </div>
                            <div class="theme-info">
                                <div class="theme-name">å¯çˆ±é£æ ¼</div>
                                <div class="theme-description">æ¸©é¦¨å¯çˆ±çš„ç²‰è‰²ä¸»é¢˜</div>
                            </div>
                        </div>
                        </div>
                    </div>
                </div>
                
                <!-- å£çº¸è®¾ç½® -->
                <div id="wallpaper-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('wallpaper-screen')">â€¹</button>
                        <div class="app-title">å£çº¸</div>
                    </div>
                    <div class="app-content">
                        <div class="settings-item" onclick="showWallpaperPicker()">
                            <div class="settings-item-left">
                                <div>é€‰æ‹©æ–°å£çº¸</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showIconPicker()">
                            <div class="settings-item-left">
                                <div>æ›´æ”¹åº”ç”¨å›¾æ ‡</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                    </div>
                </div>
                
                <!-- æ— çº¿å±€åŸŸç½‘è®¾ç½® -->
                <div id="wifi-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('wifi-screen')">â€¹</button>
                        <div class="app-title">æ— çº¿å±€åŸŸç½‘</div>
                    </div>
                    <div class="app-content">
                        <div class="wifi-settings">
                            <div class="settings-item">
                                <div class="settings-item-left">
                                    <div>æ— çº¿å±€åŸŸç½‘</div>
                                </div>
                                <label class="settings-toggle">
                                    <input type="checkbox" checked>
                                    <span class="settings-slider"></span>
                                </label>
                            </div>
                            
                            <div class="wifi-network">
                                <div class="wifi-network-left">
                                    <div class="wifi-icon">
                                        <i class="fas fa-lock"></i>
                                    </div>
                                    <div>
                                        <div>HomeWiFi</div>
                                        <div class="wifi-strength">
                                            <div class="wifi-strength-bar active"></div>
                                            <div class="wifi-strength-bar active"></div>
                                            <div class="wifi-strength-bar active"></div>
                                            <div class="wifi-strength-bar active"></div>
                                        </div>
                                    </div>
                                </div>
                                <i class="fas fa-check check-icon"></i>
                            </div>
                            
                            <div class="settings-item settings-item-margin" onclick="showApp('api-settings-screen')">
                                <div class="settings-item-left">
                                    <div>APIè®¾ç½®</div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- APIè®¾ç½®ç•Œé¢ -->
                <div id="api-settings-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">á°”á©š</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('api-settings-screen')">â€¹</button>
                        <div class="app-title">APIè®¾ç½®</div>
                    </div>
                    <div class="app-content">
                        <div class="form-container" style="color: #000000;">
                            

                            
                            <!-- å¿«é€Ÿè®¾ç½®å¡ç‰‡ -->
                            <div class="form-group" style="margin-bottom: 30px;">
                                <label style="color: #333; margin-bottom: 15px; display: block; font-size: 16px; font-weight: 600;">ğŸš€ å¿«é€Ÿè®¾ç½®</label>
                                
                                <!-- Geminiç›´è¿å¡ç‰‡ -->
                                <div style="margin-bottom: 12px; padding: 18px; background: linear-gradient(135deg, rgba(74, 132, 193, 0.1) 0%, rgba(74, 132, 193, 0.05) 100%); border: 2px solid rgba(74, 132, 193, 0.2); border-radius: 16px; color: #333; cursor: pointer; transition: all 0.3s ease; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);" onclick="setGeminiDirect()">
                                    <div style="display: flex; align-items: center; justify-content: space-between;">
                                        <div>
                                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 4px; color: var(--theme-button-bg, #4a84c1);">ğŸŒŸ Gemini ç›´è¿</div>
                                            <div style="font-size: 13px; color: #666;">è‡ªåŠ¨é…ç½®Googleå®˜æ–¹APIï¼Œæ”¯æŒæœ€æ–°æ¨¡å‹</div>
                                        </div>
                                        <div style="background: var(--theme-button-bg, rgba(74, 132, 193, 0.9)); color: white; padding: 8px 14px; border-radius: 20px; font-size: 13px; font-weight: 500; box-shadow: 0 2px 8px rgba(74, 132, 193, 0.3);">ç‚¹å‡»é…ç½®</div>
                                    </div>
                            </div>
                            
                                <!-- HuggingFaceåä»£å¡ç‰‡ -->
                                <div style="margin-bottom: 15px; padding: 18px; background: linear-gradient(135deg, rgba(255, 193, 7, 0.1) 0%, rgba(255, 193, 7, 0.05) 100%); border: 2px solid rgba(255, 193, 7, 0.2); border-radius: 16px; color: #333; cursor: pointer; transition: all 0.3s ease; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);" onclick="setHuggingFaceProxy()">
                                    <div style="display: flex; align-items: center; justify-content: space-between;">
                                        <div>
                                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 4px; color: #f39c12;">ğŸ¤— HuggingFace åä»£</div>
                                            <div style="font-size: 13px; color: #666;">å…è´¹ä½¿ç”¨å¤šç§å¤§æ¨¡å‹ï¼Œæ”¯æŒClaudeç­‰</div>
                                        </div>
                                        <div style="background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%); color: white; padding: 8px 14px; border-radius: 20px; font-size: 13px; font-weight: 500; box-shadow: 0 2px 8px rgba(243, 156, 18, 0.3);">ç‚¹å‡»é…ç½®</div>
                                    </div>
                            </div>
                            
                                <div style="font-size: 12px; color: #666; text-align: center; margin-top: 10px;">
                                    âš ï¸ ä½¿ç”¨å‰è¯·ç¡®ä¿æœ‰å¯¹åº”çš„APIå¯†é’¥
                                </div>
                            </div>
                            
                            <!-- APIé…ç½®è¡¨å• - ç¾åŒ–ç‰ˆ -->
                            <div style="background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 25px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1); border: 1px solid rgba(255, 255, 255, 0.2);">
                                
                                <!-- APIåœ°å€ -->
                                <div style="margin-bottom: 20px;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: var(--theme-text-primary, #333); font-size: 15px;">APIåœ°å€</label>
                                    <input type="text" id="api-base" placeholder="ä¾‹å¦‚: https://api.openai.com æˆ– @https://xxx-xxx.hf.space/v1" style="width: 100%; padding: 12px 15px; border: 2px solid var(--theme-input-border, rgba(0, 0, 0, 0.08)); border-radius: 12px; font-size: 16px; background: var(--theme-form-bg, rgba(255, 255, 255, 0.9)); backdrop-filter: blur(10px); transition: all 0.3s ease; color: var(--theme-text-primary, #333); box-sizing: border-box;">
                                    <div style="font-size: 12px; color: #666; margin-top: 5px;">æ”¯æŒæ ‡å‡†APIå’ŒHuggingFaceåä»£ï¼ˆæ ¼å¼ï¼š@https://xxx.hf.space/v1ï¼‰</div>
                            </div>
                            
                                <!-- APIå¯†é’¥ -->
                                <div style="margin-bottom: 20px;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: var(--theme-text-primary, #333); font-size: 15px;">APIå¯†é’¥</label>
                                    <input type="password" id="api-key" placeholder="sk-... æˆ– Google AI Studio API Key" style="width: 100%; padding: 12px 15px; border: 2px solid var(--theme-input-border, rgba(0, 0, 0, 0.08)); border-radius: 12px; font-size: 16px; background: var(--theme-form-bg, rgba(255, 255, 255, 0.9)); backdrop-filter: blur(10px); transition: all 0.3s ease; color: var(--theme-text-primary, #333); box-sizing: border-box;">
                                </div>
                                
                                <!-- æ¨¡å‹é€‰æ‹© -->
                                <div style="margin-bottom: 20px;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: var(--theme-text-primary, #333); font-size: 15px;">æ¨¡å‹</label>
                                    <div style="display: flex; gap: 10px; align-items: center; width: 100%; overflow: hidden;">
                                        <select id="model-select" style="flex: 1; min-width: 0; padding: 12px 15px; border: 2px solid var(--theme-input-border, rgba(0, 0, 0, 0.08)); border-radius: 12px; font-size: 16px; background: var(--theme-form-bg, rgba(255, 255, 255, 0.9)); backdrop-filter: blur(10px); transition: all 0.3s ease; color: var(--theme-text-primary, #333); max-height: 200px; overflow-y: auto;">
                                            <!-- æ¨¡å‹é€‰é¡¹å°†é€šè¿‡JSåŠ¨æ€å¡«å…… -->
                                    </select>
                                        <button id="fetch-models-btn" onclick="fetchModels()" style="padding: 10px 16px; background: var(--theme-button-secondary-bg, rgba(255, 255, 255, 0.8)); color: var(--theme-button-secondary-color, #666); border: 2px solid var(--theme-button-secondary-border, rgba(0, 0, 0, 0.1)); border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: 500; backdrop-filter: blur(10px); transition: all 0.3s ease; white-space: nowrap;">æ‹‰å–æ¨¡å‹</button>
                                </div>
                            </div>
                            
                                <!-- æ¸©åº¦å‚æ•° -->
                                <div style="margin-bottom: 25px;">
                                    <label style="display: block; margin-bottom: 12px; font-weight: 600; color: var(--theme-text-primary, #333); font-size: 15px;">æ¸©åº¦å‚æ•° (<span id="temperature-value" style="color: var(--theme-button-bg, #4a84c1); font-weight: 700;">0.75</span>)</label>
                                    <div style="background: rgba(255, 255, 255, 0.8); padding: 15px; border-radius: 12px; border: 2px solid var(--theme-input-border, rgba(0, 0, 0, 0.08));">
                                        <input type="range" id="temperature-slider" min="0" max="2" step="0.05" value="0.75" oninput="document.getElementById('temperature-value').textContent = parseFloat(this.value).toFixed(2);" style="width: 100%; height: 6px; border-radius: 3px; background: linear-gradient(to right, rgba(74, 132, 193, 0.2) 0%, rgba(74, 132, 193, 0.4) 100%); outline: none; -webkit-appearance: none; appearance: none;">
                                        <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 12px; color: #666;">
                                            <span>0.00 (ä¿å®ˆ)</span>
                                            <span>1.00 (å¹³è¡¡)</span>
                                            <span>2.00 (åˆ›æ–°)</span>
                                        </div>
                                        <div style="font-size: 12px; color: #666; margin-top: 8px; text-align: center;">æ¸©åº¦è¶Šä½ï¼Œå›ç­”è¶Šä¿å®ˆç¨³å®šï¼›æ¸©åº¦è¶Šé«˜ï¼Œå›ç­”è¶Šæœ‰åˆ›æ„å¤šæ ·</div>
                                    </div>
                            </div>
                            
                                <!-- æ“ä½œæŒ‰é’® -->
                                <div style="display: flex; gap: 12px; margin-top: 25px;">
                                    <button id="test-api-connection-btn" onclick="testApiConnection()" style="flex: 1; padding: 14px 20px; background: linear-gradient(135deg, #34c759 0%, #30d158 100%); color: white; border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: 0 4px 15px rgba(52, 199, 89, 0.3); transition: all 0.3s ease;">æµ‹è¯•è¿æ¥</button>
                                    <button id="save-api-settings-btn" onclick="saveApiSettings()" style="flex: 1; padding: 14px 20px; background: var(--theme-button-bg, rgba(74, 132, 193, 0.9)); color: var(--theme-button-color, white); border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: var(--theme-button-shadow, 0 4px 15px rgba(74, 132, 193, 0.3)); transition: all 0.3s ease;">ä¿å­˜è®¾ç½®</button>
                                </div>
                            </div>

                            <!-- APIé…ç½®ç®¡ç† -->
                            <hr style="margin: 30px 0; border: none; border-top: 1px solid #eaeaea;">
                            <div class="api-config-manager" style="background: rgba(248, 249, 250, 0.8); border-radius: 16px; padding: 20px; margin: 15px 0; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(0,0,0,0.05);">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>ğŸ’¾</span> APIé…ç½®ç®¡ç†
                                </h4>
                                <p style="font-size: 13px; color: #666; margin: 0 0 15px 0; line-height: 1.5;">ä¿å­˜å½“å‰é…ç½®ä¸ºé¢„è®¾ï¼Œæ–¹ä¾¿å¿«é€Ÿåˆ‡æ¢ä¸åŒçš„APIæœåŠ¡</p>
                                
                                <div class="save-config-section" style="margin-bottom: 20px; padding: 15px; background: rgba(255,255,255,0.6); border-radius: 12px; border: 1px solid rgba(0,0,0,0.05);">
                                    <div style="display: flex; gap: 10px; margin-bottom: 12px;">
                                        <input type="text" id="config-name-input" placeholder="è¾“å…¥é…ç½®åç§° (å¦‚: OpenAIã€Geminiã€Claudeç­‰)" style="flex: 1; padding: 10px 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px; background: rgba(255,255,255,0.9);">
                                        <button id="save-current-config-btn" onclick="saveCurrentConfig()" style="padding: 10px 16px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);">ğŸ’¾ ä¿å­˜é…ç½®</button>
                        </div>
                                    <div style="font-size: 12px; color: #888;">å½“å‰é…ç½®å°†ä¿å­˜ä¸º: <span style="color: #333; font-weight: 500;">URL + æ¨¡å‹ + æ¸©åº¦è®¾ç½®</span></div>
                                </div>
                                
                                <div class="saved-configs-section">
                                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                                        <label style="font-size: 14px; font-weight: 500; color: #333;">å·²ä¿å­˜çš„é…ç½®</label>
                                        <button id="clear-all-configs-btn" onclick="clearAllConfigs()" style="padding: 6px 12px; background: rgba(255, 107, 107, 0.1); color: #ff6b6b; border: 1px solid rgba(255, 107, 107, 0.3); border-radius: 6px; font-size: 12px; cursor: pointer; transition: all 0.2s ease;">ğŸ—‘ï¸ æ¸…ç©ºå…¨éƒ¨</button>
                                    </div>
                                    <div id="saved-configs-container" style="display: grid; gap: 10px; max-height: 300px; overflow-y: auto;">
                                        <!-- ä¿å­˜çš„é…ç½®å¡ç‰‡å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                                    </div>
                                    <div id="no-configs-message" style="text-align: center; color: #999; padding: 30px 20px; font-size: 14px; display: none;">
                                        <div style="font-size: 24px; margin-bottom: 8px;">ğŸ“</div>
                                        <div>è¿˜æ²¡æœ‰ä¿å­˜ä»»ä½•é…ç½®</div>
                                        <div style="font-size: 12px; margin-top: 4px;">åœ¨ä¸Šæ–¹è¾“å…¥é…ç½®åç§°å¹¶ç‚¹å‡»"ä¿å­˜é…ç½®"</div>
                                    </div>
                                </div>
                            </div>



                        </div>
                    </div>
                </div>
                
                <!-- é¢œè‰²é€‰æ‹©å™¨æ¨¡æ€æ¡† -->
                <div class="modal" id="color-picker-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title" id="color-picker-title">é€‰æ‹©é¢œè‰²</div>
                            <button class="modal-close" onclick="hideModal('color-picker-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="color-picker" id="color-picker">
                                <div class="color-option color-red" onclick="selectColor('#FF3B30')"></div>
                                <div class="color-option color-orange" onclick="selectColor('#FF9500')"></div>
                                <div class="color-option color-yellow" onclick="selectColor('#FFCC00')"></div>
                                <div class="color-option color-green" onclick="selectColor('#34C759')"></div>
                                <div class="color-option color-light-blue" onclick="selectColor('#5AC8FA')"></div>
                                <div class="color-option color-blue" onclick="selectColor('#007AFF')"></div>
                                <div class="color-option color-purple" onclick="selectColor('#5856D6')"></div>
                                <div class="color-option color-pink" onclick="selectColor('#AF52DE')"></div>
                                <div class="color-option color-red-alt" onclick="selectColor('#FF2D55')"></div>
                            </div>
                            <div class="form-group">
                                <label class="form-label">é€æ˜åº¦</label>
                                <input type="range" class="opacity-slider" id="opacity-slider" min="0" max="1" step="0.1" value="1">
                                <span id="opacity-value">100%</span>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('color-picker-modal')">å–æ¶ˆ</button>
                            <button class="modal-button modal-primary" onclick="applyColorSelection()">åº”ç”¨</button>
                        </div>
                    </div>
                </div>
                
                <!-- å£çº¸é€‰æ‹©å™¨æ¨¡æ€æ¡† -->
                <div class="modal" id="wallpaper-picker-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">é€‰æ‹©å£çº¸</div>
                            <button class="modal-close" onclick="hideModal('wallpaper-picker-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="wallpaper-preview-container" id="wallpaper-preview-container">
                                <div class="wallpaper-preview-placeholder">
                                    <i class="fas fa-image"></i>
                                    <div>é€‰æ‹©æœ¬åœ°å›¾ç‰‡åå¯åœ¨æ­¤é¢„è§ˆ</div>
                                </div>
                            </div>
                            <div class="settings-item upload-custom-item" onclick="uploadCustomWallpaper()">
                                <div class="settings-item-left">
                                    <div>ä»ç›¸å†Œé€‰æ‹©</div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <input type="file" id="custom-wallpaper-upload" accept="image/*" class="file-input-hidden">
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('wallpaper-picker-modal')">å–æ¶ˆ</button>
                            <button class="modal-button modal-primary" onclick="applyWallpaperSelection()">åº”ç”¨</button>
                        </div>
                    </div>
                </div>
                
                <!-- å›¾æ ‡é€‰æ‹©å™¨æ¨¡æ€æ¡† -->
                <div class="modal" id="icon-picker-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">æ›´æ”¹åº”ç”¨å›¾æ ‡</div>
                            <button class="modal-close" onclick="hideModal('icon-picker-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <!-- åº”ç”¨åˆ—è¡¨ -->
                            <div class="app-list-section">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px;">é€‰æ‹©è¦ä¿®æ”¹çš„åº”ç”¨</h4>
                                <div id="app-list-container" class="app-list-grid">
                                    <!-- åŠ¨æ€ç”Ÿæˆåº”ç”¨åˆ—è¡¨ -->
                                </div>
                            </div>

                            <!-- å›¾æ ‡ä¸Šä¼ åŒºåŸŸ -->
                            <div class="icon-upload-section" id="icon-upload-section" style="display: none;">
                                <h4 style="margin: 20px 0 15px 0; color: #333; font-size: 16px;">ä¸Šä¼ æ–°å›¾æ ‡</h4>
                                <div class="upload-area" onclick="triggerIconUpload()">
                                    <div class="upload-placeholder" id="upload-placeholder">
                                        <i class="fas fa-cloud-upload-alt" style="font-size: 32px; color: #999; margin-bottom: 10px;"></i>
                                        <div style="color: #666;">ç‚¹å‡»é€‰æ‹©å›¾ç‰‡</div>
                                        <div style="color: #999; font-size: 12px; margin-top: 5px;">æ”¯æŒ JPGã€PNG æ ¼å¼</div>
                                    </div>
                                    <img id="icon-preview-img" class="icon-preview-img" style="display: none;">
                                </div>
                                <input type="file" id="custom-icon-upload" accept="image/*" class="file-input-hidden">
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('icon-picker-modal')">å–æ¶ˆ</button>
                            <button class="modal-button modal-primary" id="apply-icon-btn" onclick="applyIconChange()" style="display: none;">åº”ç”¨</button>
                        </div>
                    </div>
                </div>
                
                <!-- ç…§ç‰‡æ‹æ‘„æ¨¡æ€æ¡† -->

                

                

                
                <!-- èŠå¤©é€‰é¡¹æ¨¡æ€æ¡† -->
                <div class="modal" id="chat-options-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">é€‰æ‹©èŠå¤©ç±»å‹</div>
                            <button class="modal-close" onclick="hideModal('chat-options-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="chat-option-item" onclick="showSingleChatSelector()">
                                <div class="chat-option-icon">
                                    <i class="fas fa-user icon-user-blue"></i>
                                </div>
                                <div class="chat-option-text">
                                    <div class="chat-option-title">å•èŠ</div>
                                    <div class="chat-option-desc">ä¸å•ä¸ªè§’è‰²è¿›è¡Œå¯¹è¯</div>
                                </div>
                            </div>
                            <div class="chat-option-item" onclick="showGroupChatSelector()">
                                <div class="chat-option-icon">
                                    <i class="fas fa-users icon-users-green"></i>
                                </div>
                                <div class="chat-option-text">
                                    <div class="chat-option-title">ç¾¤èŠ</div>
                                    <div class="chat-option-desc">ä¸å¤šä¸ªè§’è‰²åŒæ—¶èŠå¤©</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- å•èŠè§’è‰²é€‰æ‹©æ¨¡æ€æ¡† -->
                <div class="modal" id="single-chat-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">é€‰æ‹©èŠå¤©è§’è‰²</div>
                            <button class="modal-close" onclick="hideModal('single-chat-modal')">&times;</button>
                        </div>
                        <div class="modal-body" id="single-chat-body">
                            <!-- è§’è‰²åˆ—è¡¨å°†é€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
                        </div>
                    </div>
                </div>
                
                <!-- ç¾¤èŠè§’è‰²é€‰æ‹©æ¨¡æ€æ¡† -->
                <div class="modal" id="group-chat-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">åˆ›å»ºç¾¤èŠ</div>
                            <button class="modal-close" onclick="hideModal('group-chat-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">ç¾¤èŠåç§°</label>
                                <input type="text" class="form-input" id="group-chat-name" placeholder="ä¾‹å¦‚ï¼šåŠ¨æ€åˆ†äº«ã€å·¥ä½œç¾¤">
                            </div>
                            <div class="form-group">
                                <label class="form-label">é€‰æ‹©æˆå‘˜ (è‡³å°‘2äººï¼Œæœ€å¤š20äºº)</label>
                                <div id="group-chat-members">
                                    <!-- ç¾¤èŠæˆå‘˜é€‰æ‹©å°†é€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('group-chat-modal')">å–æ¶ˆ</button>
                            <button class="modal-button modal-primary" onclick="createGroupChat()">åˆ›å»ºç¾¤èŠ</button>
                        </div>
                    </div>
                </div>
                
                <!-- å†å²æ¶ˆæ¯è®¾ç½®æ¨¡æ€æ¡† -->
                <div class="modal" id="history-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">å†å²æ¶ˆæ¯è®¾ç½®</div>
                            <button class="modal-close" onclick="hideModal('history-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body" style="padding: 20px;">
                            <div class="setting-card" style="margin-bottom: 20px;">
                                <div class="setting-item" style="margin-bottom: 15px;">
                                    <div class="setting-left">
                                        <div class="setting-label" style="font-size: 16px; margin-bottom: 8px;">é™„å¸¦å†å²æ¶ˆæ¯æ•° (å›åˆæ•°)</div>
                                        <div class="setting-desc" style="font-size: 14px; line-height: 1.4;">AIå›å¤æ—¶å‚è€ƒçš„å†å²å¯¹è¯å›åˆæ•°</div>
                                    </div>
                                    <div class="setting-right">
                                        <span class="setting-value" id="history-count-display" style="font-size: 16px; font-weight: 600;">5å›åˆ</span>
                                    </div>
                                </div>
                                <div class="setting-range-container" style="margin-bottom: 15px;">
                                    <input type="range" class="theme-range" id="history-messages-count" min="0" max="100" step="1" value="5">
                                    <div class="range-labels">
                                        <span>0å›åˆ</span>
                                        <span>100å›åˆ</span>
                                    </div>
                                </div>
                                <div class="custom-input-container" style="margin-bottom: 15px;">
                                    <span class="input-label">è‡ªå®šä¹‰æ•°å€¼ï¼š</span>
                                    <input type="number" class="theme-input" id="custom-history-count" min="0" max="500" value="5" style="width: 80px; margin: 0 8px;">
                                    <span class="input-unit">å›åˆ (æœ€å¤§500)</span>
                                </div>
                                <div class="setting-explanation">
                                    <div class="explanation-text">
                                        <strong>è¯´æ˜ï¼š</strong><br>
                                        â€¢ ä¸€å›åˆ = ä½ çš„ä¸€æ¡æ¶ˆæ¯ + AIçš„ä¸€æ¡å›å¤<br>
                                        â€¢ è®¾ç½®ä¸º5è¡¨ç¤ºAIå›å¤æ—¶ä¼šå‚è€ƒæœ€è¿‘5å›åˆå¯¹è¯<br>
                                        â€¢ æ³¨æ„ï¼šæ•°å€¼è¿‡å¤§å¯èƒ½å½±å“APIå“åº”é€Ÿåº¦
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer" style="display: flex; justify-content: space-between; padding: 20px; gap: 0;">
                            <button class="theme-button theme-button-secondary" onclick="hideModal('history-settings-modal')" style="margin: 0; padding: 12px 20px;">å–æ¶ˆ</button>
                            <button class="theme-button theme-button-primary" onclick="saveHistorySettings()" style="margin: 0; padding: 12px 20px;">ä¿å­˜</button>
                        </div>
                    </div>
                </div>
                
                <!-- è®°å¿†æŒ‚è½½è®¾ç½®æ¨¡æ€æ¡† -->
                <div class="modal" id="memory-mount-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">è®°å¿†æŒ‚è½½è®¾ç½®</div>
                            <button class="modal-close" onclick="hideModal('memory-mount-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">
                                    <input type="checkbox" id="memory-mount-enabled" class="checkbox-with-margin">
                                    å¯ç”¨è®°å¿†æŒ‚è½½
                                </label>
                                <p class="small-text margin-top-5">
                                    å¼€å¯åï¼ŒAIä¼šå‚è€ƒå…¶ä»–èŠå¤©çª—å£çš„å¯¹è¯å†…å®¹ä½œä¸ºèƒŒæ™¯è®°å¿†
                                </p>
                            </div>
                            <div class="form-group hide" id="memory-mount-details">
                                <label class="form-label">æ¯ä¸ªèŠå¤©æŒ‚è½½æ¡æ•°</label>
                                <input type="range" class="api-form-range" id="memory-mount-count" min="1" max="20" step="1" value="3">
                                <div class="flex-space-between">
                                    <span>1æ¡</span>
                                    <span id="memory-mount-display">3æ¡</span>
                                    <span>20æ¡</span>
                                </div>
                            </div>
                            <div class="form-group hide" id="memory-mount-chats">
                                <label class="form-label">é€‰æ‹©è¦æŒ‚è½½çš„èŠå¤©</label>
                                <div id="memory-mount-list" class="max-height-200-auto">
                                    <!-- èŠå¤©åˆ—è¡¨å°†é€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
                                </div>
                                <p class="small-text margin-top-8">
                                    é€‰æ‹©çš„èŠå¤©è®°å½•ä¼šä½œä¸ºèƒŒæ™¯ä¿¡æ¯æä¾›ç»™AIå‚è€ƒ
                                </p>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('memory-mount-modal')">å–æ¶ˆ</button>
                            <button class="modal-button modal-primary" onclick="saveMemoryMountSettings()">ä¿å­˜</button>
                        </div>
                    </div>
                </div>
                
                <!-- å¤´åƒè®¾ç½®æ¨¡æ€æ¡† -->
                <div class="modal" id="avatar-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">åŒæ–¹å¤´åƒè®¾ç½®</div>
                            <button class="modal-close" onclick="hideModal('avatar-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="avatar-setting-group">
                                <label class="form-label">æˆ‘çš„å¤´åƒ (ä»…åœ¨æ­¤èŠå¤©çª—å£ç”Ÿæ•ˆ)</label>
                                <div class="avatar-preview-container">
                                    <div class="avatar-preview" id="my-chat-avatar-preview">
                                        <i class="fas fa-user"></i>
                                    </div>
                                    <input type="file" id="my-chat-avatar-upload" accept="image/*" class="file-input-hidden">
                                    <button class="upload-button" onclick="document.getElementById('my-chat-avatar-upload').click()">ä¸Šä¼ å¤´åƒ</button>
                                </div>
                            </div>
                            <div class="avatar-setting-group">
                                <label class="form-label">å¯¹æ–¹å¤´åƒ (ä»…åœ¨æ­¤èŠå¤©çª—å£ç”Ÿæ•ˆ)</label>
                                <div class="avatar-preview-container">
                                    <div class="avatar-preview" id="ai-chat-avatar-preview">
                                        <i class="fas fa-robot"></i>
                                    </div>
                                    <input type="file" id="ai-chat-avatar-upload" accept="image/*" class="file-input-hidden">
                                    <button class="upload-button" onclick="document.getElementById('ai-chat-avatar-upload').click()">ä¸Šä¼ å¤´åƒ</button>
                                    <button class="upload-button clear-avatar-btn" onclick="clearAiDynamicAvatar()">æ¸…é™¤åŠ¨æ€å¤´åƒ</button>
                                </div>
                                <p class="small-text margin-top-5">
                                    æ³¨æ„ï¼šå¦‚æœè§’è‰²åœ¨èŠå¤©ä¸­æ›´æ¢äº†å¤´åƒï¼ŒåŠ¨æ€å¤´åƒä¼šè¦†ç›–æ­¤è®¾ç½®ï¼Œç‚¹å‡»"æ¸…é™¤åŠ¨æ€å¤´åƒ"å¯é‡ç½®
                                </p>
                            </div>
                            <div class="form-group margin-top-20">
                                <label class="form-label">
                                    <input type="checkbox" id="hide-avatars" class="checkbox-with-margin">
                                    éšè—åŒæ–¹å¤´åƒ
                                </label>
                                <p class="small-text margin-top-5">
                                    å¼€å¯åï¼ŒèŠå¤©ç•Œé¢å°†ä¸æ˜¾ç¤ºä»»ä½•å¤´åƒ
                                </p>
                            </div>
                            <p class="small-text margin-top-15">
                                æ³¨æ„ï¼šæ­¤è®¾ç½®ä»…å½±å“å½“å‰èŠå¤©çª—å£æ˜¾ç¤ºï¼Œä¸ä¼šåŒæ­¥ä¿®æ”¹è§’è‰²å¡æˆ–é¢å…·è®¾ç½®
                            </p>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('avatar-settings-modal')">å–æ¶ˆ</button>
                            <button class="modal-button modal-primary" onclick="saveChatAvatarSettings()">ä¿å­˜</button>
                        </div>
                    </div>
                </div>
                
                <!-- æ˜µç§°è®¾ç½®æ¨¡æ€æ¡† -->
                <div class="modal" id="nickname-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">åŒæ–¹å¤‡æ³¨è®¾ç½®</div>
                            <button class="modal-close" onclick="hideModal('nickname-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">æˆ‘çš„æ˜µç§° (ä»…åœ¨æ­¤èŠå¤©ä¸­æ˜¾ç¤º)</label>
                                <input type="text" class="form-input" id="my-chat-nickname" placeholder="è¾“å…¥ä½ åœ¨æ­¤èŠå¤©ä¸­çš„æ˜µç§°">
                            </div>
                            <div class="form-group">
                                <label class="form-label">å¯¹æ–¹æ˜µç§° (ä»…åœ¨æ­¤èŠå¤©ä¸­æ˜¾ç¤º)</label>
                                <input type="text" class="form-input" id="ai-chat-nickname" placeholder="è¾“å…¥å¯¹æ–¹åœ¨æ­¤èŠå¤©ä¸­çš„æ˜µç§°">
                            </div>
                            <p class="small-text margin-top-10">
                                æ³¨æ„ï¼šæ­¤è®¾ç½®ä»…å½±å“å½“å‰èŠå¤©çª—å£æ˜¾ç¤ºï¼Œä¸ä¼šåŒæ­¥ä¿®æ”¹è§’è‰²å¡æˆ–é¢å…·è®¾ç½®ã€‚è§’è‰²ä¹Ÿå¯èƒ½æ ¹æ®å¿ƒæƒ…å’ŒèŠå¤©å†…å®¹è‡ªä¸»ä¿®æ”¹è‡ªå·±çš„æ˜µç§°ã€‚
                            </p>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('nickname-settings-modal')">å–æ¶ˆ</button>
                            <button class="modal-button modal-primary" onclick="saveChatNicknameSettings()">ä¿å­˜</button>
                        </div>
                    </div>
                </div>
                
                <!-- æˆ³ä¸€æˆ³åç¼€è®¾ç½®æ¨¡æ€æ¡† -->
                <div class="modal" id="poke-suffix-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">æˆ³ä¸€æˆ³åç¼€è®¾ç½®</div>
                            <button class="modal-close" onclick="hideModal('poke-suffix-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">æˆ‘çš„æˆ³ä¸€æˆ³åç¼€</label>
                                <input type="text" class="form-input" id="my-poke-suffix" placeholder="ç•™ç©ºä¸ºæ— åç¼€ï¼ˆä¾‹å¦‚ï¼šçš„å°è„¸è›‹ï¼‰">
                                <p class="tiny-text margin-top-5">æ˜¾ç¤ºä¸ºï¼šä½ æˆ³äº†æˆ³[è§’è‰²å][åç¼€]ï¼Œç•™ç©ºåˆ™æ˜¾ç¤ºï¼šä½ æˆ³äº†æˆ³[è§’è‰²å]</p>
                            </div>
                            <div class="form-group">
                                <label class="form-label">å¯¹æ–¹æˆ³ä¸€æˆ³åç¼€</label>
                                <input type="text" class="form-input" id="ai-poke-suffix" placeholder="ç•™ç©ºä¸ºæ— åç¼€ï¼ˆä¾‹å¦‚ï¼šçš„å°æ‰‹ï¼‰">
                                <p class="tiny-text margin-top-5">æ˜¾ç¤ºä¸ºï¼š[è§’è‰²å]æˆ³äº†æˆ³ä½ [åç¼€]ï¼Œç•™ç©ºåˆ™æ˜¾ç¤ºï¼š[è§’è‰²å]æˆ³äº†æˆ³ä½ ã€‚è§’è‰²å¯èƒ½æ ¹æ®å¿ƒæƒ…è‡ªä¸»ä¿®æ”¹æ­¤åç¼€ã€‚</p>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('poke-suffix-modal')">å–æ¶ˆ</button>
                            <button class="modal-button modal-primary" onclick="savePokeSuffixSettings()">ä¿å­˜</button>
                        </div>
                    </div>
                </div>
                
                <!-- èŠå¤©èƒŒæ™¯è®¾ç½®æ¨¡æ€æ¡† -->
                <div class="modal" id="background-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">èŠå¤©èƒŒæ™¯è®¾ç½®</div>
                            <button class="modal-close" onclick="hideModal('background-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="background-preview-container">
                                <div class="background-preview" id="chat-background-preview">
                                    <div class="preview-text">èƒŒæ™¯é¢„è§ˆ</div>
                                </div>
                            </div>
                            <div class="form-group">
                                <input type="file" id="background-upload" accept="image/*" class="file-input-hidden">
                                <button class="form-button" onclick="document.getElementById('background-upload').click()">é€‰æ‹©èƒŒæ™¯å›¾ç‰‡</button>
                                <button class="form-button form-button-secondary" onclick="removeBackground()">ç§»é™¤èƒŒæ™¯</button>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('background-settings-modal')">å–æ¶ˆ</button>
                            <button class="modal-button modal-primary" onclick="saveChatBackgroundSettings()">ä¿å­˜</button>
                        </div>
                    </div>
                </div>
                
                <!-- ğŸ”¥ã€æ–°å¢ã€‘ç¾¤æˆå‘˜æ°”æ³¡é¢œè‰²è®¾ç½®æ¨¡æ€æ¡† -->
                <div class="modal" id="group-member-colors-modal" style="z-index: 10001;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">ç¾¤æˆå‘˜æ°”æ³¡é¢œè‰²è®¾ç½®</div>
                            <button class="modal-close" onclick="hideModal('group-member-colors-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="setting-explanation">
                                <div class="explanation-text">ä¸ºæ¯ä¸ªç¾¤æˆå‘˜è®¾ç½®ç‹¬ç‰¹çš„æ°”æ³¡é¢œè‰²ï¼Œè®©ç¾¤èŠæ›´åŠ ç”ŸåŠ¨æœ‰è¶£ã€‚</div>
                            </div>
                            <div id="group-member-colors-list">
                                <!-- åŠ¨æ€ç”Ÿæˆç¾¤æˆå‘˜é¢œè‰²è®¾ç½®é¡¹ -->
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('group-member-colors-modal')">å–æ¶ˆ</button>
                            <button class="modal-button modal-primary" onclick="saveGroupMemberColors()">ä¿å­˜</button>
                        </div>
                    </div>
                </div>
                
                <!-- æ°”æ³¡æ ·å¼è®¾ç½®æ¨¡æ€æ¡† -->
                <div class="modal" id="bubble-style-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">æ°”æ³¡æ ·å¼è®¾ç½®</div>
                            <button class="modal-close" onclick="hideModal('bubble-style-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="bubble-style-section">
                                <label class="form-label">é€‰æ‹©æ°”æ³¡æ ·å¼</label>
                                <div class="bubble-style-grid">
                                    <div class="bubble-style-option" data-style="default">
                                        <div class="style-preview">
                                            <div class="preview-bubble sent-preview">é»˜è®¤æ ·å¼</div>
                                            <div class="preview-bubble received-preview">ç»å…¸åœ†è§’</div>
                                        </div>
                                        <div class="style-name">é»˜è®¤æ ·å¼</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="glass">
                                        <div class="style-preview bubble-style-glass">
                                            <div class="preview-bubble sent-preview">æ¯›ç»ç’ƒ</div>
                                            <div class="preview-bubble received-preview">åŠé€æ˜</div>
                                        </div>
                                        <div class="style-name">æ¯›ç»ç’ƒ</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="shadow">
                                        <div class="style-preview bubble-style-shadow">
                                            <div class="preview-bubble sent-preview">ç»å…¸é˜´å½±</div>
                                            <div class="preview-bubble received-preview">ç«‹ä½“æ„Ÿ</div>
                                        </div>
                                        <div class="style-name">ç»å…¸é˜´å½±</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="tail">
                                        <div class="style-preview bubble-style-tail">
                                            <div class="preview-bubble sent-preview">å¸¦å°–è§’</div>
                                            <div class="preview-bubble received-preview">æ°”æ³¡æˆ³</div>
                                        </div>
                                        <div class="style-name">ç»å…¸æ°”æ³¡</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="gradient">
                                        <div class="style-preview bubble-style-gradient">
                                            <div class="preview-bubble sent-preview">æ¸å˜è‰²</div>
                                            <div class="preview-bubble received-preview">ç¾è§‚</div>
                                        </div>
                                        <div class="style-name">æ¸å˜æ ·å¼</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="minimal">
                                        <div class="style-preview bubble-style-minimal">
                                            <div class="preview-bubble sent-preview">æç®€çº¿æ¡</div>
                                            <div class="preview-bubble received-preview">ç®€çº¦</div>
                                        </div>
                                        <div class="style-name">æç®€æ ·å¼</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="neon">
                                        <div class="style-preview bubble-style-neon">
                                            <div class="preview-bubble sent-preview">éœ“è™¹å‘å…‰</div>
                                            <div class="preview-bubble received-preview">ç§‘æŠ€æ„Ÿ</div>
                                        </div>
                                        <div class="style-name">éœ“è™¹æ ·å¼</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="paper">
                                        <div class="style-preview bubble-style-paper">
                                            <div class="preview-bubble sent-preview">çº¸å¼ å¡ç‰‡</div>
                                            <div class="preview-bubble received-preview">è´¨æ„Ÿ</div>
                                        </div>
                                        <div class="style-name">çº¸å¼ æ ·å¼</div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="color-setting-group">
                                <label class="form-label">è‡ªå®šä¹‰é¢œè‰²</label>
                                <div class="color-picker-container">
                                    <div class="flex-gap-15">
                                        <div class="flex-1">
                                            <label class="label-small">æˆ‘çš„æ°”æ³¡</label>
                                            <input type="color" id="my-bubble-color" class="color-input" value="#007AFF">
                                        </div>
                                        <div class="flex-1">
                                            <label class="label-small">å¯¹æ–¹æ°”æ³¡</label>
                                            <input type="color" id="ai-bubble-color" class="color-input" value="#f0f0f0">
                                            <!-- ğŸ”¥ã€æ–°å¢ã€‘ç¾¤èŠè§’è‰²å•ç‹¬è®¾ç½®æŒ‰é’® -->
                                            <div id="group-member-colors-btn" style="display: none; margin-top: 8px;">
                                                <button type="button" class="theme-button theme-button-secondary" style="font-size: 12px; padding: 6px 12px;" onclick="showGroupMemberColorSettings()">
                                                    ä¸ºç¾¤æˆå‘˜å•ç‹¬è®¾ç½®
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="opacity-setting">
                                    <div class="flex-gap-15-mb-15">
                                        <div class="flex-1">
                                            <label class="label-small">æˆ‘çš„æ°”æ³¡é€æ˜åº¦ï¼š<span id="my-bubble-opacity-value">100%</span></label>
                                            <input type="range" id="my-bubble-opacity" min="0.1" max="1" step="0.1" value="1" class="width-100">
                                        </div>
                                        <div class="flex-1">
                                            <label class="label-small">å¯¹æ–¹æ°”æ³¡é€æ˜åº¦ï¼š<span id="ai-bubble-opacity-value">100%</span></label>
                                            <input type="range" id="ai-bubble-opacity" min="0.1" max="1" step="0.1" value="1" class="width-100">
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="padding-setting">
                                    <label class="form-label">æ°”æ³¡å¤§å°è°ƒèŠ‚</label>
                                    <div class="flex-gap-15-mb-10">
                                        <div class="flex-1">
                                            <label class="label-small">å†…è¾¹è·ï¼š<span id="bubble-padding-value">ä¸­ç­‰</span></label>
                                            <input type="range" id="bubble-padding" min="4" max="16" step="2" value="12" class="width-100">
                                        </div>
                                    </div>
                                    <p class="tiny-text-gray margin-top-5">
                                        è°ƒæ•´æ°”æ³¡å†…æ–‡å­—ä¸è¾¹ç¼˜çš„è·ç¦»ï¼Œæ•°å€¼è¶Šå¤§æ°”æ³¡è¶Šå¤§
                                    </p>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('bubble-style-modal')">å–æ¶ˆ</button>
                            <button class="modal-button modal-primary" onclick="saveBubbleStyleSettings()">ä¿å­˜</button>
                        </div>
                    </div>
                </div>
                
                <!-- å®šæ—¶å‘å¸ƒè®¾ç½®æ¨¡æ€æ¡† -->
                <div class="modal" id="schedule-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">å®šæ—¶å‘å¸ƒè®¾ç½®</div>
                            <button class="modal-close" onclick="hideModal('schedule-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">
                                    <input type="checkbox" id="schedule-enabled" class="checkbox-with-margin">
                                    å¯ç”¨å®šæ—¶å‘å¸ƒ
                                </label>
                                <p class="small-text margin-top-5">
                                    å¼€å¯åï¼Œè§’è‰²ä¼šåœ¨æŒ‡å®šæ—¶é—´ç‚¹è‡ªåŠ¨å‘å¸ƒç¤¾äº¤åŠ¨æ€
                                </p>
                            </div>
                            <div class="form-group hide" id="schedule-times-group">
                                <label class="form-label">å‘å¸ƒæ—¶é—´ç‚¹</label>
                                <div id="schedule-times-container">
                                    <!-- æ—¶é—´ç‚¹å°†é€šè¿‡JSåŠ¨æ€æ·»åŠ  -->
                                </div>
                                <button type="button" class="form-button form-button-secondary" onclick="addScheduleTime()">+ æ·»åŠ æ—¶é—´ç‚¹</button>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('schedule-settings-modal')">å–æ¶ˆ</button>
                            <button class="modal-button modal-primary" onclick="saveScheduleSettings()">ä¿å­˜</button>
                        </div>
                    </div>
                </div>
                
                <!-- èº«ä»½é€‰æ‹©å™¨æ¨¡æ€æ¡† -->
                <!-- èº«ä»½é€‰æ‹©æ¨¡æ€æ¡†å·²ç§»é™¤ï¼Œèº«ä»½åœ¨åˆ›å»ºå¯¹è¯æ—¶é€‰æ‹© -->
                
                <!-- ä¸–ç•Œä¹¦æŒ‚è½½è®¾ç½®æ¨¡æ€æ¡† -->
                <div class="modal" id="worldbook-mount-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">ä¸–ç•Œä¹¦æŒ‚è½½è®¾ç½®</div>
                            <button class="modal-close" onclick="hideModal('worldbook-mount-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">
                                    <input type="checkbox" id="worldbook-mount-enabled" class="checkbox-with-margin">
                                    å¯ç”¨ä¸–ç•Œä¹¦æŒ‚è½½
                                </label>
                                <p class="small-text margin-top-5">
                                    å¼€å¯åï¼ŒAIä¼šå‚è€ƒé€‰å®šçš„ä¸–ç•Œä¹¦å†…å®¹ä½œä¸ºèƒŒæ™¯çŸ¥è¯†è¿›è¡Œå¯¹è¯
                                </p>
                            </div>
                            <div class="form-group hide" id="worldbook-mount-details">
                                <label class="form-label">é€‰æ‹©è¦æŒ‚è½½çš„ä¸–ç•Œä¹¦</label>
                                <div id="worldbook-mount-list" class="max-height-300-auto">
                                    <!-- ä¸–ç•Œä¹¦åˆ—è¡¨å°†é€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
                                </div>
                                <p class="small-text margin-top-8">
                                    é€‰æ‹©çš„ä¸–ç•Œä¹¦å†…å®¹ä¼šä½œä¸ºèƒŒæ™¯çŸ¥è¯†æä¾›ç»™AIå‚è€ƒï¼Œå¸®åŠ©AIæ›´å¥½åœ°ç†è§£å¯¹è¯ä¸Šä¸‹æ–‡
                                </p>
                            </div>
                            <div class="setting-explanation">
                                <div class="explanation-text">
                                    <strong>åŠŸèƒ½è¯´æ˜ï¼š</strong><br>
                                    â€¢ <strong>ä¸–ç•Œä¹¦æŒ‚è½½ï¼š</strong>å°†é€‰å®šçš„ä¸–ç•Œä¹¦å†…å®¹ä½œä¸ºAIçš„èƒŒæ™¯çŸ¥è¯†<br>
                                    â€¢ <strong>å¤šé€‰æ”¯æŒï¼š</strong>å¯ä»¥åŒæ—¶æŒ‚è½½å¤šä¸ªä¸–ç•Œä¹¦ï¼Œå†…å®¹ä¼šåˆå¹¶ä½¿ç”¨<br>
                                    â€¢ <strong>æ™ºèƒ½åº”ç”¨ï¼š</strong>AIä¼šæ ¹æ®å¯¹è¯å†…å®¹æ™ºèƒ½å¼•ç”¨ç›¸å…³çš„ä¸–ç•Œä¹¦çŸ¥è¯†<br>
                                    â€¢ <strong>ä¼˜å…ˆçº§ï¼š</strong>ä¸–ç•Œä¹¦çŸ¥è¯†ä¼˜å…ˆçº§ä½äºè§’è‰²è®¾å®šå’Œå†å²å¯¹è¯
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer" style="display: flex; justify-content: space-between; padding: 20px; gap: 0;">
                            <button class="modal-button modal-secondary" onclick="hideModal('worldbook-mount-modal')" style="margin: 0; padding: 12px 20px;">å–æ¶ˆ</button>
                            <button class="modal-button modal-primary" onclick="saveWorldbookMountSettings()" style="margin: 0; padding: 12px 20px;">ä¿å­˜</button>
                        </div>
                    </div>
                </div>

                <!-- æ—¶é—´æˆ³è®¾ç½®æ¨¡æ€æ¡† -->
                <div class="modal" id="timestamp-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">æ—¶é—´æˆ³è®¾ç½®</div>
                            <button class="modal-close" onclick="hideModal('timestamp-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">
                                    <input type="checkbox" id="timestamp-modal-enabled" class="checkbox-with-margin" checked>
                                    æ˜¾ç¤ºæ—¶é—´æˆ³
                                </label>
                                <p class="small-text margin-top-5">
                                    åœ¨èŠå¤©æ¶ˆæ¯ä¸­æ˜¾ç¤ºæ—¶é—´ä¿¡æ¯
                                </p>
                            </div>
                            
                            <div class="form-group" id="timestamp-options-group">
                                <label class="form-label">æ—¶é—´æˆ³ä½ç½®</label>
                                <div class="timestamp-position-options">
                                    <label class="radio-option">
                                        <input type="radio" name="timestamp-position" value="center" checked>
                                        <span class="radio-custom"></span>
                                        <div class="option-content">
                                            <div class="option-label">å±…ä¸­æ˜¾ç¤º</div>
                                            <div class="option-desc">æ—¶é—´æˆ³æ˜¾ç¤ºåœ¨èŠå¤©ä¸­é—´ï¼Œæ¯5åˆ†é’Ÿå‡ºç°ä¸€æ¬¡</div>
                                        </div>
                                    </label>
                                    
                                    <label class="radio-option">
                                        <input type="radio" name="timestamp-position" value="bubble">
                                        <span class="radio-custom"></span>
                                        <div class="option-content">
                                            <div class="option-label">æ°”æ³¡å¤–ä¾§</div>
                                            <div class="option-desc">æ—¶é—´æˆ³æ˜¾ç¤ºåœ¨æ¯æ¡æ¶ˆæ¯æ°”æ³¡çš„å¤–ä¾§</div>
                                        </div>
                                    </label>
                                    
                                    <label class="radio-option">
                                        <input type="radio" name="timestamp-position" value="avatar">
                                        <span class="radio-custom"></span>
                                        <div class="option-content">
                                            <div class="option-label">å¤´åƒä¸‹æ–¹</div>
                                            <div class="option-desc">æ—¶é—´æˆ³æ˜¾ç¤ºåœ¨å¤´åƒæ­£ä¸‹æ–¹ä½ç½®</div>
                                        </div>
                                    </label>
                                    
                                    <label class="radio-option">
                                        <input type="radio" name="timestamp-position" value="inside">
                                        <span class="radio-custom"></span>
                                        <div class="option-content">
                                            <div class="option-label">æ°”æ³¡å†…</div>
                                            <div class="option-desc">æ—¶é—´æˆ³æ˜¾ç¤ºåœ¨æ°”æ³¡å†…å³ä¸‹è§’ï¼Œä¸æ–‡å­—é½å¹³</div>
                                        </div>
                                    </label>
                                </div>
                            </div>
                            
                            <div class="setting-explanation">
                                <div class="explanation-text">
                                    <strong>ä½ç½®è¯´æ˜ï¼š</strong><br>
                                    â€¢ <strong>å±…ä¸­æ˜¾ç¤ºï¼š</strong>æ—¶é—´æˆ³æ°´å¹³å±…ä¸­ï¼Œä»…åœ¨è¶…è¿‡5åˆ†é’Ÿé—´éš”æ—¶æ˜¾ç¤º<br>
                                    â€¢ <strong>æ°”æ³¡å¤–ä¾§ï¼š</strong>æ¯æ¡æ¶ˆæ¯éƒ½æ˜¾ç¤ºæ—¶é—´ï¼Œç”¨æˆ·æ¶ˆæ¯åœ¨å·¦ä¸‹è§’ï¼Œè§’è‰²æ¶ˆæ¯åœ¨å³ä¸‹è§’<br>
                                    â€¢ <strong>å¤´åƒä¸‹æ–¹ï¼š</strong>æ—¶é—´æˆ³æ˜¾ç¤ºåœ¨å¯¹åº”å¤´åƒçš„æ­£ä¸‹æ–¹ä½ç½®<br>
                                    â€¢ æ‰€æœ‰æ—¶é—´æˆ³å‡ä½¿ç”¨ç°è‰²å°å­—æ˜¾ç¤ºï¼Œä¸å½±å“èŠå¤©ä½“éªŒ
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('timestamp-settings-modal')">å–æ¶ˆ</button>
                            <button class="modal-button modal-primary" onclick="saveTimestampSettings()">ä¿å­˜</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    <!-- è½¬è´¦åŠŸèƒ½ç›¸å…³æ¨¡æ€æ¡† -->
    <div id="transfer-modal">
        <div class="transfer-content">
                            <div class="transfer-header">å‘èµ·è½¬è´¦</div>
            <div class="transfer-input-group">
                <label for="transfer-amount">è½¬è´¦é‡‘é¢</label>
                                    <input type="number" id="transfer-amount" placeholder="0.00" min="0" max="1000000000" step="0.01">
            </div>
            <div class="transfer-input-group">
                <label for="transfer-note">å¤‡æ³¨ (å¯é€‰)</label>
                                    <input type="text" id="transfer-note" placeholder="è¯´ç‚¹ä»€ä¹ˆå§..." maxlength="20">
            </div>
            <div class="transfer-actions">
                <button id="transfer-cancel-btn">å–æ¶ˆ</button>
                <button id="transfer-confirm-btn">ç¡®è®¤è½¬è´¦</button>
            </div>
        </div>
    </div>
    
    <div id="transfer-confirm-modal">
        <div class="transfer-confirm-content">
            <div class="transfer-confirm-title">æ”¶åˆ°ä¸€ç¬”è½¬è´¦</div>
            <div class="transfer-confirm-info">
                <div class="transfer-confirm-amount">Â¥ 0.00</div>
                <div class="transfer-confirm-note">å¤‡æ³¨ï¼š</div>
            </div>
            <div class="transfer-confirm-actions">
                <button id="transfer-reject-btn">é€€å›</button>
                <button id="transfer-accept-btn">ç¡®è®¤æ”¶æ¬¾</button>
                </div>
            </div>
        </div>



    <!-- æ’­æ”¾åˆ—è¡¨æ¨¡æ€æ¡† -->
    <div id="playlist-modal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 500px; max-height: 80vh; overflow-y: auto;">
            <div class="modal-header">
                <h3>æ’­æ”¾åˆ—è¡¨</h3>
                <button class="close-btn" onclick="closePlaylistModal()">&times;</button>
            </div>

            <div class="playlist-content">
                <!-- æ·»åŠ æ­Œæ›²åŒºåŸŸ -->
                <div class="add-song-section">
                    <h4>æ·»åŠ æ–°æ­Œæ›²</h4>
                    <div class="input-row">
                        <input type="text" id="song-title-input" placeholder="æ­Œæ›²æ ‡é¢˜" class="song-input half-width">
                        <input type="text" id="song-artist-input" placeholder="è‰ºæœ¯å®¶" class="song-input half-width">
                    </div>
                    <div class="input-row">
                        <input type="text" id="song-url-input" placeholder="æ­Œæ›²URLæˆ–é€‰æ‹©æœ¬åœ°æ–‡ä»¶" class="song-input half-width">
                        <div class="file-input-wrapper half-width">
                            <button onclick="document.getElementById('local-music-input').click()" class="upload-btn" style="width: 100%; padding: 8px;">
                                <i class="fas fa-file-audio"></i> æœ¬åœ°éŸ³ä¹
                            </button>
                        </div>
                    </div>
                    <div class="input-row">
                        <div class="file-input-wrapper half-width">
                            <input type="file" id="song-cover-input" accept="image/*,.jpg,.jpeg,.png,.gif,.webp" class="file-input" title="é€‰æ‹©å°é¢å›¾ç‰‡">
                            <span class="file-input-text">æœªé€‰å°é¢</span>
                        </div>
                        <div class="file-input-wrapper half-width">
                            <button onclick="document.getElementById('lyrics-file-input').click()" class="upload-btn" style="width: 100%; padding: 8px;">
                                <i class="fas fa-file-text"></i> æ­Œè¯æ–‡ä»¶
                            </button>
                        </div>
                    </div>
                    <div class="lyrics-input-section">
                        <textarea id="song-lyrics-input" placeholder="æ­Œè¯ï¼ˆæ¯è¡Œä¸€å¥ï¼Œå¯é€‰ï¼‰æˆ–ä¸Šä¼ æ­Œè¯æ–‡ä»¶" class="lyrics-textarea"></textarea>
                        <div style="display: flex; gap: 8px; margin-top: 8px; font-size: 11px; color: #666;">
                            <span>æ”¯æŒæ ¼å¼ï¼šLRCã€TXTã€binç­‰æ­Œè¯æ–‡ä»¶ï¼ˆiPhoneç”¨æˆ·å¯é€‰æ‹©ä»»æ„æ–‡ä»¶ï¼‰</span>
                        </div>
                    </div>
                    <!-- éšè—çš„æ–‡ä»¶è¾“å…¥ -->
                    <input type="file" id="local-music-input" accept="audio/*,.mp3,.m4a,.wav,.aac,.ogg,.flac" style="display: none;">
                    <input type="file" id="lyrics-file-input" style="display: none;">
                    <button onclick="addCustomSong()" class="add-song-btn">
                        æ·»åŠ æ­Œæ›²
                    </button>
                </div>

                <!-- å½“å‰æ’­æ”¾åˆ—è¡¨ -->
                <div class="current-playlist">
                    <h4>å½“å‰æ’­æ”¾åˆ—è¡¨</h4>
                    <div id="playlist-items" class="playlist-items">
                        <!-- æ’­æ”¾åˆ—è¡¨é¡¹å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- éŸ³ä¹æ’­æ”¾æ¨¡æ€æ¡† -->
    <div id="music-modal" class="music-modal" style="display: none;">
        <div class="music-modal-content">
            <div class="music-modal-header">
                <button class="music-modal-close" onclick="closeMusicModal()">
                    <i class="fas fa-times"></i>
                </button>
                <div class="music-header-title">æ­£åœ¨æ’­æ”¾</div>
                <button class="music-view-toggle" onclick="toggleMusicView()" id="view-toggle-btn">
                    <i class="fas fa-list"></i>
                </button>
            </div>

            <div class="music-modal-body">
                <!-- å”±ç‰‡æœºæ¨¡å¼ -->
                <div id="vinyl-mode" class="music-view-mode">
                    <div class="vinyl-player">
                        <div class="vinyl-container">
                            <div class="vinyl-disc" id="vinyl-disc">
                                <div class="vinyl-grooves"></div>
                                <div class="vinyl-center"></div>
                                <div class="vinyl-label" onclick="triggerAlbumUpload()">
                                    <img id="album-cover" class="album-cover-upload" style="display: none;" />
                                    <div class="upload-overlay">
                                        <i class="fas fa-camera"></i><br>ä¸Šä¼ å°é¢
                                    </div>
                                    <!-- ç§»é™¤æ­Œæ›²ä¿¡æ¯æ˜¾ç¤ºï¼Œä¿æŒç©ºç™½ -->
                                </div>
                            </div>
                            <div class="tonearm" id="tonearm"></div>
                        </div>

                        <div class="song-info">
                            <div class="song-title" id="vinyl-song-title">é€‰æ‹©æ­Œæ›²</div>
                            <div class="song-artist" id="vinyl-artist-name">æœªçŸ¥è‰ºæœ¯å®¶</div>
                        </div>

                        <div class="vinyl-lyrics">
                            <div class="lyrics-container">
                                <div class="lyric-line active" id="lyric-current">ç‚¹å‡»æ’­æ”¾å¼€å§‹å¬æ­Œ</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- éšè—çš„æ–‡ä»¶ä¸Šä¼ è¾“å…¥ -->
                <input type="file" id="album-cover-input" accept="image/*,.jpg,.jpeg,.png,.gif,.webp" style="display: none;" onchange="handleAlbumUpload(event)">

                <!-- å®Œæ•´æ­Œè¯æ¨¡å¼ -->
                <div id="lyrics-mode" class="music-view-mode" style="display: none;">
                    <div class="lyrics-mode">
                        <div class="lyrics-header">
                            <div class="song-title" id="lyrics-song-title">é€‰æ‹©æ­Œæ›²</div>
                            <div class="song-artist" id="lyrics-artist-name">æœªçŸ¥è‰ºæœ¯å®¶</div>
                        </div>
                        <div class="full-lyrics-container">
                            <div class="full-lyrics" id="full-lyrics-display">
                                <div class="lyric-line active">â™ª ç‚¹å‡»æ’­æ”¾å¼€å§‹å¬æ­Œ</div>
                                <div class="lyric-line">é€‰æ‹©ä½ å–œæ¬¢çš„æ­Œæ›²</div>
                                <div class="lyric-line">å’Œè§’è‰²ä¸€èµ·äº«å—éŸ³ä¹æ—¶å…‰</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="music-modal-controls">
                <!-- å½“å‰æ­Œè¯æ˜¾ç¤º -->
                <div class="current-lyric-display">
                    <div class="current-lyric-text" id="current-lyric-text">â™ª ç‚¹å‡»æ’­æ”¾å¼€å§‹å¬æ­Œ</div>
                </div>

                <div class="music-progress">
                    <div class="progress-bar">
                        <div class="progress-fill" id="modal-progress"></div>
                    </div>
                    <div class="time-display">
                        <span id="modal-current-time">0:00</span>
                        <span id="modal-total-time">0:00</span>
                    </div>
                </div>

                <div class="music-control-buttons">
                    <button class="control-btn shuffle" id="play-mode-btn" onclick="togglePlayMode()" title="é¡ºåºæ’­æ”¾">
                        <i class="fas fa-list-ol"></i>
                    </button>
                    <button class="control-btn" onclick="previousTrack()" title="ä¸Šä¸€é¦–">
                        <i class="fas fa-step-backward"></i>
                    </button>
                    <button class="control-btn play-pause-btn" id="modal-play-btn" onclick="togglePlayback()" title="æ’­æ”¾/æš‚åœ">
                        <i class="fas fa-play"></i>
                    </button>
                    <button class="control-btn" onclick="nextTrack()" title="ä¸‹ä¸€é¦–">
                        <i class="fas fa-step-forward"></i>
                    </button>
                    <button class="control-btn playlist" id="playlist-btn" onclick="openPlaylistModal()" title="æ’­æ”¾åˆ—è¡¨">
                        <i class="fas fa-music"></i>
                    </button>
                </div>

                <div class="listening-time">
                    <i class="fas fa-clock"></i>
                    <span id="listening-duration">å·²ä¸€èµ·å¬ 0 åˆ†é’Ÿ</span>
                </div>
            </div>

            <!-- å…³é—­æŒ‰é’® - å…³æœºæŒ‰é’®æ ·å¼ -->
            <button class="music-close-btn" onclick="closeMusicPlayer()" title="ç»“æŸå¬æ­Œ">
                <i class="fas fa-power-off"></i>
            </button>


        </div>
    </div>



    <script>
        // ğŸ”¥ã€æ–°å¢ä¿®å¤ã€‘å®šä¹‰ä¸€ä¸ªPromiseæ¥ç¡®ä¿æ•°æ®å®Œå…¨åŠ è½½åå†æ‰§è¡Œåç»­æ“ä½œ
        let dataLoadedPromise;
        let resolveDataLoaded;

        function initializeDataLoadPromise() {
            dataLoadedPromise = new Promise(resolve => {
                resolveDataLoaded = resolve;
            });
        }

        // ğŸ”¥ã€å®Œå…¨ä¿®å¤ã€‘åˆå§‹åŒ–Dexieæ•°æ®åº“ - è§£å†³ç‰ˆæœ¬å‡çº§æ­»å¾ªç¯é—®é¢˜
        const db = new Dexie('PhoneChatDB');
        window.activeGlobalWorldbooks = []; // ç”¨äºå­˜å‚¨å½“å‰æ¿€æ´»çš„å…¨å±€ä¸–ç•Œä¹¦ID

        // ğŸ”¥ã€æ–°å¢ã€‘æ•°æ®åº“é‡ç½®åŠŸèƒ½
        async function resetDatabase() {
            try {
                console.log('ğŸ”„ å¼€å§‹é‡ç½®æ•°æ®åº“...');

                // å…³é—­æ•°æ®åº“è¿æ¥
                if (db.isOpen()) {
                    db.close();
                }

                // åˆ é™¤æ•°æ®åº“
                await db.delete();
                console.log('âœ… æ•°æ®åº“å·²åˆ é™¤');

                // é‡æ–°æ‰“å¼€æ•°æ®åº“ï¼ˆä¼šè‡ªåŠ¨åˆ›å»ºæ–°çš„ï¼‰
                await db.open();
                console.log('âœ… æ•°æ®åº“å·²é‡æ–°åˆ›å»º');

                return true;
            } catch (error) {
                console.error('âŒ é‡ç½®æ•°æ®åº“å¤±è´¥:', error);
                return false;
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ£€æŸ¥æ•°æ®åº“å¥åº·çŠ¶æ€
        async function checkDatabaseHealth() {
            try {
                await db.open();

                // æµ‹è¯•åŸºæœ¬è¡¨è®¿é—®
                const testTables = ['characters', 'chatMessages', 'apiSettings'];
                for (const tableName of testTables) {
                    await db[tableName].count();
                }

                console.log('âœ… æ•°æ®åº“å¥åº·æ£€æŸ¥é€šè¿‡');
                return true;
            } catch (error) {
                console.error('âŒ æ•°æ®åº“å¥åº·æ£€æŸ¥å¤±è´¥:', error);
                return false;
            }
        }


        // ğŸ”¥ã€æœ€ç»ˆç‰ˆæœ¬19ã€‘ç»Ÿä¸€çš„æ•°æ®åº“ç»“æ„å®šä¹‰ - åŒ…å«å¿ƒå£°å’Œè®ºå›ç³»ç»Ÿ
        db.version(19).stores({
            // --- ä¿ç•™æ‰€æœ‰æ—§çš„è¡¨ç»“æ„ ---
            // åŸºç¡€æ•°æ®è¡¨
            characters: '&id, name, groupId',
            contacts: '++id, characterId',
            chatMessages: '&id, characterId, timestamp',

            // ç”¨æˆ·é¢å…·ç³»ç»Ÿ
            personas: '&id, name',

            // è¡¨æƒ…åŒ…ç³»ç»Ÿ
            customEmojis: '&id, name, category',
            recentEmojis: '&id, lastUsed',

            // ä¸–ç•Œä¹¦ç³»ç»Ÿ
            worldbooks: '&id, name, isGlobal',
            worldbookEntries: '&id, worldbookId, keyword',

            // ç¾¤èŠç³»ç»Ÿ
            characterGroups: '&id, name, order',
            groupChats: '&id, name',
            groupChatMessages: '&id, groupId, timestamp',
            groupChatMembers: '&id, groupId, characterId',

            // åŠ¨æ€ç³»ç»Ÿ
            moments: '&id, authorId, timestamp',
            momentLikes: '[momentId+authorId], momentId, authorId',
            momentComments: '&id, momentId, authorId, timestamp',

            // è®°å¿†ç³»ç»Ÿ
            workingMemory: '&id, characterId, timestamp, content, context',
            episodicMemory: '&id, characterId, date, summary, timestamp, context',
            episodicMemories: '&id, characterId, fact, importance, timestamp, category',
            memorySummaries: '&id, characterId, date, summary, timestamp, context',
            memoryEvents: '&id, characterIds, eventType, timestamp, context, eventData, importance',
            coreMemory: '&id, characterId, category, content, timestamp',
            coreMemories: '&id, characterId, fact, importance, timestamp, type, category',
            crossAppTimeline: '&id, characterId, appType, action, timestamp, context, messageId',

            // æ‹‰é»‘å’Œå¥½å‹ç³»ç»Ÿ
            blacklist: '&id, blockerId, blockedId, timestamp, reason',
            blockedCharacters: '&id, characterId, blockedBy, timestamp',
            friendRequests: '&id, fromId, toId, timestamp, status, type, message',
            characterStatus: '&id, characterId, status, activity, location, lastUpdate',

            // æ—¥è®°ç³»ç»Ÿ
            characterDiaries: '&id, characterId, date, content, timestamp, weather',

            // çº¿ä¸‹æ¨¡å¼ç³»ç»Ÿ
            offlineHistoryRecords: '&id, characterId, timestamp, summary, messages',
            offlineUISettings: '&id, characterId, settings, timestamp',
            offlinePresets: '&id, name, content, timestamp',

            // éŸ³ä¹æ’­æ”¾å™¨ç³»ç»Ÿ
            musicPlaylist: '&id, title, artist, album, duration, url, coverImage, lyrics, addedTime',
            musicCovers: '&id, songId, imageData, timestamp',

            // è®¾ç½®å’Œé…ç½®
            apiSettings: '&id',
            globalSettings: '&id',
            wallpapers: '&id, name',
            appIcons: '&id, appId',
            chatSettings: '&id, chatId',

            // çºªå¿µæ—¥ç³»ç»Ÿ
            anniversaries: '&id, name, date, type, yearly',

            // å¿ƒå£°ç³»ç»Ÿ
            innerThoughts: '&id, messageId, characterId, content, timestamp',

            // --- ğŸ”¥ã€æ–°å¢ã€‘è®ºå›åŠŸèƒ½ç›¸å…³è¡¨ ---
            forums: '++id, name', // è®ºå›å­˜æ¡£è¡¨ï¼Œnameä¸è®¾ä¸ºå”¯ä¸€ç´¢å¼•ï¼Œåœ¨åº”ç”¨å±‚é¢å¤„ç†é‡å¤æ£€æŸ¥
            forumPosts: '++id, forumId, timestamp', // å¸–å­è¡¨
            forumReplies: '++id, postId, timestamp', // å›å¤è¡¨
            forumFavorites: '++id, [userId+postId]' // æ”¶è—å¤¹ï¼Œç¡®ä¿ç”¨æˆ·å¯¹ä¸€ä¸ªå¸–å­åªèƒ½æ”¶è—ä¸€æ¬¡
        }).upgrade(async tx => {
            console.log('ğŸ”§ å‡çº§åˆ°ç‰ˆæœ¬19ï¼šæ·»åŠ å¿ƒå£°å’Œè®ºå›ç³»ç»Ÿ');

            // ğŸ”¥ã€å®‰å…¨è¿ç§»ã€‘æ£€æŸ¥å¹¶ä¿æŠ¤ç°æœ‰ç”¨æˆ·æ•°æ®
            try {
                // æ£€æŸ¥æ˜¯å¦æœ‰ç°æœ‰æ•°æ®éœ€è¦ä¿æŠ¤
                const existingCharacters = await tx.characters.count();
                const existingMessages = await tx.chatMessages.count();

                if (existingCharacters > 0 || existingMessages > 0) {
                    console.log(`âœ… æ£€æµ‹åˆ°ç°æœ‰ç”¨æˆ·æ•°æ®ï¼š${existingCharacters}ä¸ªè§’è‰²ï¼Œ${existingMessages}æ¡æ¶ˆæ¯`);
                    console.log('âœ… å¿ƒå£°å’Œè®ºå›ç³»ç»Ÿè¡¨å·²å®‰å…¨æ·»åŠ ï¼Œç°æœ‰æ•°æ®å®Œå…¨ä¿ç•™');
                } else {
                    console.log('âœ… æ–°ç”¨æˆ·å®‰è£…ï¼Œå¿ƒå£°å’Œè®ºå›ç³»ç»Ÿè¡¨å·²åˆ›å»º');
                }

                // æ–°è¡¨ä¼šè‡ªåŠ¨åˆ›å»ºï¼šinnerThoughts, forums, forumPosts, forumReplies, forumFavorites

            } catch (error) {
                console.error('âš ï¸ æ•°æ®è¿ç§»æ£€æŸ¥å¤±è´¥ï¼Œä½†ä¸å½±å“åŠŸèƒ½:', error);
            }
        });

        // å…¨å±€å˜é‡
        let characters = [];
        let contacts = [];
        let currentChatCharacter = null;
        let chatMessages = {};
        let selectedMessageId = null;
        let pinnedConversations = []; // ğŸ”¥ã€æ–°å¢ã€‘ç½®é¡¶å¯¹è¯åˆ—è¡¨
        let personas = []; // ç”¨æˆ·é¢å…·åˆ—è¡¨
        let currentPersona = null; // å½“å‰ä½¿ç”¨çš„é¢å…·
        let editingPersona = null; // æ­£åœ¨ç¼–è¾‘çš„é¢å…·
        let isMultiSelectMode = false; // å¤šé€‰æ¨¡å¼çŠ¶æ€
        let selectedCharacters = []; // é€‰ä¸­çš„è§’è‰²IDåˆ—è¡¨
        let currentEditingCharacterId = null; // å½“å‰æ­£åœ¨ç¼–è¾‘çš„è§’è‰²ID
        let groupChats = []; // ç¾¤èŠåˆ—è¡¨
        let selectedGroupMembers = []; // ç¾¤èŠæˆå‘˜é€‰æ‹©
        let currentWorldbookTab = 'global';
        let currentCharacterCategory = null; // è·Ÿè¸ªå½“å‰é€‰æ‹©çš„è§’è‰²åˆ†ç±»
        
        // è§’è‰²åˆ†ç»„ç›¸å…³å˜é‡
        let characterGroups = []; // è§’è‰²åˆ†ç»„åˆ—è¡¨
        let isGroupManageMode = false; // åˆ†ç»„ç®¡ç†æ¨¡å¼
        let selectedGroupId = null; // å½“å‰é€‰ä¸­çš„åˆ†ç»„ID
        
        // è‡ªå®šä¹‰è¡¨æƒ…åŒ…ç›¸å…³å˜é‡
        let customEmojis = []; // ç”¨æˆ·ä¸Šä¼ çš„è¡¨æƒ…åŒ…
        let recentEmojis = []; // æœ€è¿‘ä½¿ç”¨çš„è¡¨æƒ…åŒ…
        let currentEmojiTab = 'recent'; // å½“å‰è¡¨æƒ…åŒ…æ ‡ç­¾é¡µ
        
        // æ¶ˆæ¯å¤šé€‰åˆ é™¤ç›¸å…³å˜é‡
        let isMessageSelectionMode = false; // æ¶ˆæ¯é€‰æ‹©æ¨¡å¼
        let selectedMessages = new Set(); // é€‰ä¸­çš„æ¶ˆæ¯IDé›†åˆ
        
        // æ¶ˆæ¯åˆ—è¡¨å¤šé€‰ç›¸å…³å˜é‡
        let isMessageListMultiSelectMode = false; // æ¶ˆæ¯åˆ—è¡¨å¤šé€‰æ¨¡å¼çŠ¶æ€
        let selectedConversations = []; // é€‰ä¸­çš„å¯¹è¯æ¡†IDåˆ—è¡¨
        
        // åŠ¨æ€è¯„è®ºå¯¹è¯å›åˆæ¬¡è¿½è¸ª
        let commentConversationRounds = new Map(); // æ ¼å¼: "momentId-characterId" => å›åˆæ¬¡æ•°
        
        // ğŸ”¥ã€æ–°å¢ã€‘æ‹‰é»‘ç³»ç»Ÿç›¸å…³å˜é‡å·²åœ¨åé¢å£°æ˜
        
        let apiSettings = {
            type: 'openai',
            base: 'https://api.openai.com/v1',
            endpoint: '/chat/completions',
            key: '',
            model: 'gpt-3.5-turbo',
            temperature: 0.70
        };
        
        // æ³¨æ„ï¼šè®°å¿†è®¾ç½®ç°åœ¨å·²æ”¹ä¸ºæ¯ä¸ªèŠå¤©çª—å£ç‹¬ç«‹çš„è®¾ç½®ï¼Œå­˜å‚¨åœ¨å„è‡ªçš„èŠå¤©è®¾ç½®ä¸­
        
        let chatSettings = {
            themeColor: '#007AFF',
            theirBubbleColor: '#f0f0f0',
            myBubbleColor: '#007AFF',
            bubbleOpacity: 1,
            timestampEnabled: true,
            timestampPosition: 'center'
        };
        

        let selectedAppIcon = null;
        let selectedWallpaper = null;
        let colorPickerContext = null;
        let customIconImage = null;
        
        // åŠ è½½å…¨å±€ä¸–ç•Œä¹¦è®¾ç½®
        async function loadGlobalWorldbookSettings() {
            try {
                const globalSettings = await db.globalSettings.get('main');
                if (globalSettings && globalSettings.activeGlobalWorldbooks) {
                    // ç¡®ä¿ä½¿ç”¨window.activeGlobalWorldbooksä»¥åœ¨å…¨å±€èŒƒå›´å†…å¯ç”¨
                    window.activeGlobalWorldbooks = globalSettings.activeGlobalWorldbooks;
                } else {
                    window.activeGlobalWorldbooks = [];
                    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°è®¾ç½®ï¼Œåˆ›å»ºä¸€ä¸ªåˆå§‹è®¾ç½®
                    await db.globalSettings.put({
                        id: 'main',
                        activeGlobalWorldbooks: []
                    });
                }
            } catch (error) {
                console.error('åŠ è½½å…¨å±€ä¸–ç•Œä¹¦è®¾ç½®å¤±è´¥:', error);
                window.activeGlobalWorldbooks = [];
            }
        }

        // åˆå§‹åŒ–åº”ç”¨
        document.addEventListener('DOMContentLoaded', async function() {
            initializeDataLoadPromise(); // ğŸ”¥ã€æ–°å¢ä¿®å¤ã€‘åˆå§‹åŒ–æ•°æ®åŠ è½½Promise
            updateTime();

            // ğŸ”¥ã€æ–°å¢ã€‘å¢å¼ºSafarié•¿æŒ‰ç¦ç”¨
            if (navigator.userAgent.includes('Safari') && navigator.userAgent.includes('Mobile')) {
                // ç¦ç”¨Safariçš„é•¿æŒ‰ä¸Šä¸‹æ–‡èœå•
                document.addEventListener('contextmenu', function(e) {
                    // åªåœ¨æ¶ˆæ¯æ°”æ³¡å’Œç›¸å…³å…ƒç´ ä¸Šç¦ç”¨
                    if (e.target.closest('.message-bubble, .offline-message-content, .message-item, .contact-item')) {
                        e.preventDefault();
                        return false;
                    }
                }, { passive: false });

                // ç¦ç”¨Safariçš„é€‰æ‹©èœå•
                document.addEventListener('selectstart', function(e) {
                    if (e.target.closest('.message-bubble, .offline-message-content, .message-item, .contact-item')) {
                        e.preventDefault();
                        return false;
                    }
                }, { passive: false });

                // ç¦ç”¨Safariçš„æ‹–æ‹½
                document.addEventListener('dragstart', function(e) {
                    if (e.target.closest('.message-bubble, .offline-message-content, .message-item, .contact-item')) {
                        e.preventDefault();
                        return false;
                    }
                }, { passive: false });

                console.log('âœ… Safarié•¿æŒ‰ç¦ç”¨å·²å¯ç”¨');
            }

            try {

            // ğŸ”¥ã€æ–°å¢ã€‘åˆå§‹åŒ–çª—å£IDï¼Œç¡®ä¿çº¿ä¸‹æ¨¡å¼æ•°æ®éš”ç¦»
            initializeWindowId();

            // ğŸ”¥ã€æ–°å¢ã€‘æ•°æ®åº“å¥åº·æ£€æŸ¥
            console.log('ğŸ” å¼€å§‹æ•°æ®åº“å¥åº·æ£€æŸ¥...');
            const isHealthy = await checkDatabaseHealth();
            if (!isHealthy) {
                console.warn('âš ï¸ æ•°æ®åº“å¥åº·æ£€æŸ¥å¤±è´¥ï¼Œå°è¯•é‡ç½®...');
                const resetSuccess = await resetDatabase();
                if (!resetSuccess) {
                    throw new Error('æ•°æ®åº“é‡ç½®å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨æ¸…é™¤æµè§ˆå™¨æ•°æ®');
                }
                console.log('âœ… æ•°æ®åº“å·²é‡ç½®ï¼Œç»§ç»­åˆå§‹åŒ–...');
            } else {
                console.log('âœ… æ•°æ®åº“å¥åº·æ£€æŸ¥é€šè¿‡');
            }

            // ğŸ”¥ã€å·²ç§»é™¤ã€‘è¿ç§»æ—§çš„çº¿ä¸‹é¢„è®¾æ•°æ® - ç°åœ¨ç”±æ•°æ®åº“ç‰ˆæœ¬15è‡ªåŠ¨å¤„ç†

            // ğŸ”¥ã€æ¶æ„ä¿®å¤ã€‘æŒ‰æ­£ç¡®é¡ºåºåŠ è½½æ•°æ®
            console.log('ğŸ”„ å¼€å§‹æŒ‰é¡ºåºåŠ è½½æ•°æ®...');

            // ç¬¬ä¸€æ­¥ï¼šåŠ è½½åŸºç¡€æ•°æ®
            await Promise.all([
                loadCharacterGroups(), // å…ˆåŠ è½½åˆ†ç»„
                loadCharacters(), // åŠ è½½è§’è‰²
                loadChatMessages(),
                loadMemoryConfig(), // åŠ è½½è®°å¿†é…ç½®
                loadChatSettings(),
                loadApiSettings(),
                loadCustomEmojis(),
                loadGlobalWorldbookSettings(), // ç¡®ä¿åŠ è½½å…¨å±€ä¸–ç•Œä¹¦è®¾ç½®
                initGlobalMemoryDB(), // ğŸ”¥ã€æ–°å¢ã€‘åˆå§‹åŒ–å…¨å±€è®°å¿†æ•°æ®åº“
                loadCustomAppIcons() // åŠ è½½è‡ªå®šä¹‰åº”ç”¨å›¾æ ‡
            ]);

            // ğŸ”¥ã€æ–°å¢ã€‘æ¸…ç†å·²ä¿å­˜çš„æ‹‰é»‘ç³»ç»Ÿæ¶ˆæ¯
            console.log('ğŸ§¹ æ¸…ç†æ‹‰é»‘ç³»ç»Ÿæ¶ˆæ¯...');
            cleanupBlockedSystemMessages();

            // ç¬¬äºŒæ­¥ï¼šä»è§’è‰²åˆ—è¡¨ç”Ÿæˆè”ç³»äººï¼ˆå¿…é¡»åœ¨è§’è‰²åŠ è½½å®Œæˆåï¼‰
            console.log('ğŸ”„ ä»è§’è‰²åˆ—è¡¨ç”Ÿæˆè”ç³»äºº...');
            await loadContacts();

            // ğŸ”¥ã€æ–°å¢ã€‘åŠ è½½ç½®é¡¶æ•°æ®
            loadPinnedConversations();
            
            // åŠ è½½å¤–è§‚è®¾ç½®
            loadPhoneBorderSetting();
            loadScreenSize();
            loadFontSizeSettings();
            loadStatusIconSetting();
            
            // åŠ è½½åŠ¨æ€å›¾ç‰‡è®¾ç½®
            await loadMomentsImages();
            
            // åŠ è½½å…¶ä»–è®¾ç½®ï¼ˆåŒ…æ‹¬éœ€è¦æ•°æ®åº“çš„å£çº¸è®¾ç½®ï¼‰
            await loadWallpaper();
            await loadAppIcons();
            loadSavedTheme();
            await loadWorldbooks();

            await loadPersonas();
            await loadGroupChats();

            // ğŸ”¥ã€æ–°å¢ã€‘æ£€æŸ¥localStorageä½¿ç”¨æƒ…å†µ
            checkLocalStorageUsage();

            // åˆå§‹åŒ–è®°å¿†æŸ¥çœ‹å™¨
            await initMemoryViewer();

            // åˆå§‹åŒ–çºªå¿µæ—¥ç³»ç»Ÿ
            await loadAnniversaryList();

            // åˆå§‹åŒ–å°ç»„ä»¶
            initializeWidgets();

            // ğŸ”¥ã€æ–°å¢ã€‘åˆå§‹åŒ–è®ºå›åº”ç”¨
            initializeForumApp();
            
            // æ¸²æŸ“ç•Œé¢ - æ·»åŠ æ•°æ®éªŒè¯
            try {
                if (characters && contacts && chatMessages) {
            renderMessageList();
            renderContactList();
            renderCharacterList();
            renderPersonaList();
                } else {
                    console.warn('æ•°æ®æœªå®Œå…¨åŠ è½½ï¼Œæ¨è¿Ÿç•Œé¢æ¸²æŸ“');
                    // å»¶è¿Ÿé‡è¯•æ¸²æŸ“
                    setTimeout(() => {
                        renderMessageList();
                        renderContactList();
                        renderCharacterList();
                        renderPersonaList();
                    }, 500);
                }
            } catch (renderError) {
                console.error('ç•Œé¢æ¸²æŸ“å¤±è´¥:', renderError);
                // å°è¯•é‡æ–°åˆå§‹åŒ–ç©ºæ•°æ®
                if (!chatMessages) chatMessages = {};
                if (!contacts) contacts = [];
                if (!characters) characters = [];
                renderMessageList();
                renderContactList();
                renderCharacterList();
            }
            
            // åˆå§‹åŒ–æ—¶è®¾ç½®æ­£ç¡®çš„æŒ‰é’®æ˜¾ç¤ºçŠ¶æ€ - å»¶è¿Ÿæ‰§è¡Œç¡®ä¿DOMåŠ è½½å®Œæˆ
            setTimeout(async () => {
                switchChatTab('message-list');
                // ç¡®ä¿appæ ‡é¢˜æœ‰chat-modeç±»å’Œæ­£ç¡®å†…å®¹
                const appTitle = document.querySelector('#chat-screen .app-title');
                if (appTitle) {
                    appTitle.classList.add('chat-mode');
                    appTitle.textContent = 'ğŸ’¬';
                }

                // åˆå§‹åŒ–UIäº‹ä»¶ä¸ä¾èµ–äºcurrentChatCharacter
                initChatSettingsUIEvents();

                // ğŸ”¥ã€ä¿®å¤ã€‘å¼ºåˆ¶åº”ç”¨æ°”æ³¡æ ·å¼ï¼Œå³ä½¿æ²¡æœ‰å½“å‰èŠå¤©è§’è‰²
                applyBubbleStyle();

                // å¦‚æœå·²ç»æœ‰èŠå¤©è§’è‰²ï¼Œæ‰åˆå§‹åŒ–è®¾ç½®å’Œä¸–ç•Œä¹¦
                if (currentChatCharacter) {
                initializeChatSettings(); // åˆå§‹åŒ–èŠå¤©è®¾ç½®ç•Œé¢
                updateWorldbookMountDisplay(); // æ›´æ–°ä¸–ç•Œä¹¦æŒ‚è½½æ˜¾ç¤º
                } else {
                    // åº”ç”¨åˆå§‹åŒ–å®Œæˆï¼Œç­‰å¾…é€‰æ‹©èŠå¤©è§’è‰²
                }

                // ğŸ”¥ã€ä¿®å¤ã€‘åœ¨åº”ç”¨åˆå§‹åŒ–æ—¶å¯åŠ¨å…¨å±€åå°äº’åŠ¨ç³»ç»Ÿ
                await initGlobalBackgroundInteractionSystem();
            }, 100);
            
            // æ¸©åº¦æ»‘å—æ˜¾ç¤º
            const temperatureSlider = document.getElementById('temperature-slider');
            if (temperatureSlider) {
                temperatureSlider.addEventListener('input', function() {
                document.getElementById('temperature-value').textContent = parseFloat(this.value).toFixed(2);
            });
            }
            
            // åˆå§‹åŒ–APIè®¾ç½®ç•Œé¢
            initializeApiSettings();

            // é€æ˜åº¦æ»‘å—æ˜¾ç¤º
            document.getElementById('opacity-slider').addEventListener('input', function() {
                document.getElementById('opacity-value').textContent = Math.round(this.value * 100) + '%';
            });

            // æ–‡ä»¶é€‰æ‹©æ¡†äº‹ä»¶ç›‘å¬
            const songCoverInput = document.getElementById('song-cover-input');
            const fileInputText = document.querySelector('.file-input-text');
            if (songCoverInput && fileInputText) {
                songCoverInput.addEventListener('change', function(e) {
                    if (e.target.files && e.target.files[0]) {
                        fileInputText.textContent = e.target.files[0].name;
                    } else {
                        fileInputText.textContent = 'æœªé€‰å°é¢';
                    }
                });
            }
            
            // æŒ‰Enteré”®å‘é€æ¶ˆæ¯
            document.getElementById('api-chat-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault(); // é˜²æ­¢æ¢è¡Œ
                    sendApiMessage();
                }
            });

            // @ç¾¤æˆå‘˜åŠŸèƒ½ç›¸å…³å˜é‡
            let mentionDropdownVisible = false;
            let mentionStartPos = -1;
            let selectedMentionIndex = -1;
            let currentMentionQuery = '';

            // ç›‘å¬è¾“å…¥æ¡†å†…å®¹å˜åŒ–ï¼Œå¤„ç†@ç¾¤æˆå‘˜åŠŸèƒ½
            document.getElementById('api-chat-input').addEventListener('input', function(e) {
                handleMentionInput(e);
            });

            // ç›‘å¬é”®ç›˜äº‹ä»¶ï¼Œå¤„ç†@ç¾¤æˆå‘˜é€‰æ‹©
            document.getElementById('api-chat-input').addEventListener('keydown', function(e) {
                if (mentionDropdownVisible) {
                    handleMentionKeydown(e);
                }
            });

            // ç‚¹å‡»å…¶ä»–åœ°æ–¹æ—¶éšè—@ç¾¤æˆå‘˜ä¸‹æ‹‰æ¡†
            document.addEventListener('click', function(e) {
                const dropdown = document.getElementById('mention-dropdown');
                const input = document.getElementById('api-chat-input');
                if (mentionDropdownVisible && !dropdown.contains(e.target) && e.target !== input) {
                    hideMentionDropdown();
                }
            });
            

            
            // åˆå§‹åŒ–å¤´åƒä¸Šä¼ åŠŸèƒ½
            initializeAvatarUpload();

            // åˆå§‹åŒ–è¡¨æƒ…åŒ…ä¸Šä¼ åŠŸèƒ½
            initializeEmojiUpload();

            // åˆå§‹åŒ–åº”ç”¨å›¾æ ‡ä¸Šä¼ åŠŸèƒ½
            initializeIconUpload();
            
            // ç¡®ä¿å·¥å…·é¢æ¿åˆå§‹éšè—
            const toolsPanel = document.getElementById('tools-panel');
            if (toolsPanel) {
                toolsPanel.style.display = 'none';
            }
            
            // åˆå§‹åŒ–æ¶ˆæ¯é€‰æ‹©æ¨¡å¼çŠ¶æ€
            isMessageSelectionMode = false;
            selectedMessages.clear();
            
            // å›¾ç‰‡ä¸Šä¼ 
            document.getElementById('image-upload').addEventListener('change', function(e) {
                if (e.target.files && e.target.files[0]) {
                    const file = e.target.files[0];
                    
                    // æ£€æŸ¥æ–‡ä»¶ç±»å‹ï¼ŒGIFæ ¼å¼ä¸è¢«Gemini APIæ”¯æŒ
                    if (file.type === 'image/gif') {
                        alert('æŠ±æ­‰ï¼ŒGemini API ä¸æ”¯æŒ GIF æ ¼å¼çš„å›¾ç‰‡ã€‚\n\nè¯·é€‰æ‹©å…¶ä»–æ ¼å¼çš„å›¾ç‰‡ï¼Œå¦‚ï¼š\nâ€¢ JPEG\nâ€¢ PNG\nâ€¢ WEBP');
                        // æ¸…ç©ºæ–‡ä»¶é€‰æ‹©å™¨
                        e.target.value = '';
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        // ğŸ”¥ã€ä¿®å¤ã€‘ç›´æ¥å‘é€å›¾ç‰‡æ¶ˆæ¯ï¼Œå°±åƒæ­£å¸¸çš„å›¾ç‰‡å‘é€ä¸€æ ·
                        sendImageMessage(event.target.result);
                    };
                    reader.readAsDataURL(file);
                }
                
                // æ¸…ç©ºæ–‡ä»¶é€‰æ‹©å™¨ï¼Œå…è®¸é‡å¤é€‰æ‹©åŒä¸€æ–‡ä»¶
                e.target.value = '';
            });
            
            // è‡ªå®šä¹‰å£çº¸ä¸Šä¼ 
            document.getElementById('custom-wallpaper-upload').addEventListener('change', function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        selectedWallpaper = event.target.result;
                        
                        // æ›´æ–°é¢„è§ˆå®¹å™¨
                        const previewContainer = document.getElementById('wallpaper-preview-container');
                        if (previewContainer) {
                            previewContainer.innerHTML = `<img src="${selectedWallpaper}" class="wallpaper-preview-image" alt="å£çº¸é¢„è§ˆ">`;
                        }
                        
                        // ä¸åœ¨è¿™é‡Œç«‹å³åº”ç”¨åˆ°ä¸»ç•Œé¢ï¼Œç­‰ç”¨æˆ·ç‚¹å‡»åº”ç”¨æ—¶å†åº”ç”¨
                    };
                    reader.readAsDataURL(e.target.files[0]);
                }
            });
            
            // è‡ªå®šä¹‰å›¾æ ‡ä¸Šä¼ 
            document.getElementById('custom-icon-upload').addEventListener('change', function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        customIconImage = event.target.result;
                        // æ›´æ–°é¢„è§ˆ
                        const previews = document.querySelectorAll('.icon-preview');
                        previews.forEach(preview => {
                            preview.style.backgroundImage = `url(${customIconImage})`;
                            preview.innerHTML = ''; // ç§»é™¤å›¾æ ‡
                        });
                    };
                    reader.readAsDataURL(e.target.files[0]);
                }
            });
            
            setInterval(updateTime, 1000);
            initBatteryManager();
            
            // ğŸ”¥ã€æ–°å¢ä¿®å¤ã€‘åœ¨æ‰€æœ‰æ•°æ®åŠ è½½å®Œæˆåï¼Œå‘é€"ç»¿ç¯"ä¿¡å·
            resolveDataLoaded();
            console.log('âœ… æ‰€æœ‰åˆå§‹æ•°æ®åŠ è½½å®Œæˆï¼Œä¿¡å·å·²å‘é€ã€‚');

            // ğŸ”¥ã€æ–°å¢ã€‘åˆå§‹åŒ–å…¨å±€åŠ¨æ€å‘å¸ƒç³»ç»Ÿ
            setTimeout(async () => {
                try {
                    await initGlobalMomentsSystem();
                    console.log('âœ… å…¨å±€åŠ¨æ€å‘å¸ƒç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ');
                } catch (error) {
                    console.error('âŒ å…¨å±€åŠ¨æ€å‘å¸ƒç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥:', error);
                }
            }, 3000); // å»¶è¿Ÿ3ç§’ç¡®ä¿æ•°æ®å®Œå…¨åŠ è½½

            // ğŸ”¥ã€æ–°å¢ä¿®å¤ã€‘åœ¨æ‰€æœ‰æ•°æ®åŠ è½½åï¼Œå°è¯•æ¢å¤ä¸Šæ¬¡æ‰“å¼€çš„èŠå¤©
            const lastChatId = sessionStorage.getItem('currentChatCharacterId');
            if (lastChatId) {
                console.log('ğŸ”„ æ­£åœ¨æ¢å¤ä¸Šæ¬¡æ‰“å¼€çš„èŠå¤©:', lastChatId);
                // ç­‰å¾…æ•°æ®åŠ è½½çš„"ç»¿ç¯"ä¿¡å·
                dataLoadedPromise.then(() => {
                    const character = characters.find(c => c.id === lastChatId);
                    const group = groupChats.find(g => g.id === lastChatId);
                    const chatEntity = character || group;

                    if (chatEntity) {
                        // ä½¿ç”¨å¾®å°çš„å»¶è¿Ÿç¡®ä¿UIæ¸²æŸ“å®Œæˆ
                        setTimeout(() => {
                            startChat(chatEntity);
                        }, 100);
                    } else {
                        console.warn('æ— æ³•æ‰¾åˆ°ä¸Šæ¬¡èŠå¤©çš„è§’è‰²/ç¾¤ç»„:', lastChatId);
                        sessionStorage.removeItem('currentChatCharacterId');
                    }
                });
            }

            } catch (error) {
                console.error('åº”ç”¨åˆå§‹åŒ–å¤±è´¥:', error);
                console.error('é”™è¯¯è¯¦æƒ…:', error.stack);

                // æ˜¾ç¤ºè¯¦ç»†é”™è¯¯ä¿¡æ¯
                const errorMsg = `åº”ç”¨åˆå§‹åŒ–å¤±è´¥: ${error.message}\n\nå¯èƒ½çš„è§£å†³æ–¹æ¡ˆï¼š\n1. åˆ·æ–°é¡µé¢é‡è¯•\n2. æ¸…é™¤æµè§ˆå™¨ç¼“å­˜\n3. è¿›å…¥è®¾ç½®â†’ç´§æ€¥æ¢å¤\n\né”™è¯¯ç±»å‹: ${error.name}`;

                // å¦‚æœæ˜¯æ•°æ®åº“é”™è¯¯ï¼Œå°è¯•é‡ç½®
                if (error.name === 'DataError' || error.name === 'InvalidStateError' || error.name === 'DexieError') {
                    console.log('æ£€æµ‹åˆ°æ•°æ®åº“é”™è¯¯ï¼Œå°è¯•é‡ç½®æ•°æ®åº“...');
                    if (confirm('æ£€æµ‹åˆ°æ•°æ®åº“é”™è¯¯ï¼Œæ˜¯å¦é‡ç½®æ•°æ®åº“ï¼Ÿ\næ³¨æ„ï¼šè¿™å°†æ¸…é™¤æ‰€æœ‰æœ¬åœ°æ•°æ®ã€‚')) {
                        try {
                            await resetDatabase();
                            location.reload(); // é‡ç½®ååˆ·æ–°é¡µé¢
                        } catch (resetError) {
                            console.error('é‡ç½®æ•°æ®åº“å¤±è´¥:', resetError);
                            alert('é‡ç½®æ•°æ®åº“å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨æ¸…é™¤æµè§ˆå™¨æ•°æ®åé‡è¯•ã€‚');
                        }
                    }
                } else {
                    alert(errorMsg);

                    // å°è¯•æ˜¾ç¤ºç´§æ€¥æ¢å¤ç•Œé¢
                    try {
                        // ç¡®ä¿åŸºæœ¬çš„DOMç»“æ„å­˜åœ¨
                        if (!characters) characters = [];
                        if (!contacts) contacts = [];
                        if (!chatMessages) chatMessages = {};

                        // å°è¯•æ˜¾ç¤ºè®¾ç½®é¡µé¢
                        showApp('settings-screen');

                        // å»¶è¿Ÿæ˜¾ç¤ºæ¢å¤æ¨¡æ€æ¡†
                        setTimeout(() => {
                            try {
                                const recoveryBtn = document.querySelector('[onclick="showRecoveryModal()"]');
                                if (recoveryBtn) {
                                    recoveryBtn.click();
                                }
                            } catch (e) {
                                console.error('æ— æ³•è‡ªåŠ¨æ‰“å¼€æ¢å¤ç•Œé¢:', e);
                            }
                        }, 1000);
                    } catch (e) {
                        console.error('æ— æ³•æ˜¾ç¤ºç´§æ€¥æ¢å¤ç•Œé¢:', e);
                    }
                }
            }
        });
        
        // æ˜¾ç¤º/éšè—åº”ç”¨
        function showApp(appId) {
            if (event) event.preventDefault();
            
            // éšè—æ‰€æœ‰appç•Œé¢
            const allApps = document.querySelectorAll('.app-screen');
            allApps.forEach(app => {
                app.style.display = 'none';
            });
            
            // éšè—ä¸»å±å¹•ç»„ä»¶
            const clockContainer = document.getElementById('clock-container');
            const homeGrid = document.getElementById('home-grid');
            const dockBar = document.getElementById('dock-bar');
            if (clockContainer) clockContainer.style.display = 'none';
            if (homeGrid) homeGrid.style.display = 'none';
            if (dockBar) dockBar.style.display = 'none';
            
            // æ˜¾ç¤ºç›®æ ‡ç•Œé¢
            document.getElementById(appId).style.display = 'flex';
            
            // å¦‚æœæ˜¯èŠå¤©ç•Œé¢ï¼Œåˆ·æ–°æ¶ˆæ¯åˆ—è¡¨
            if (appId === 'chat-screen') {
                renderMessageList();
            }

            // å¦‚æœæ˜¯çºªå¿µæ—¥ç•Œé¢ï¼ŒåŠ è½½çºªå¿µæ—¥åˆ—è¡¨
            if (appId === 'anniversary-screen') {
                loadAnniversaryList();
            }

            // å¦‚æœæ˜¯APIè®¾ç½®ç•Œé¢ï¼Œåˆå§‹åŒ–è®¾ç½®
            if (appId === 'api-settings-screen') {
                // å»¶è¿Ÿä¸€ç‚¹æ—¶é—´ç¡®ä¿DOMå·²æ¸²æŸ“
                setTimeout(() => {
                    initializeApiSettings();
                }, 100);
            }
        }
        

        
        // éšè—è§’è‰²åˆ›å»ºè¡¨å•ï¼Œè¿”å›åˆ°chatç•Œé¢çš„é€šè®¯å½•
        function hideCharacterForm() {
            // åœ¨éšè—è¡¨å•æ—¶æ¸…ç©ºè¡¨å•æ•°æ®
            clearCharacterForm();
            
            hideApp('character-form-screen');
            showApp('chat-screen');
            switchChatTab('contact-list');
            // æ‰‹åŠ¨è§¦å‘æ ‡ç­¾åˆ‡æ¢çš„æ ·å¼
            const chatTabs = document.querySelectorAll('.chat-tab');
            chatTabs.forEach(tab => {
                if (tab && tab.classList) {
                    tab.classList.remove('active');
                }
            });
            // å®‰å…¨åœ°æ·»åŠ activeç±»åˆ°ç¬¬äºŒä¸ªæ ‡ç­¾ï¼ˆé€šè®¯å½•ï¼‰
            if (chatTabs.length > 1 && chatTabs[1] && chatTabs[1].classList) {
                chatTabs[1].classList.add('active');
            }
        }
        
        function hideApp(appId) {
            document.getElementById(appId).style.display = 'none';
            
            // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰åº”ç”¨éƒ½å·²éšè—ï¼Œå¦‚æœæ˜¯ï¼Œæ˜¾ç¤ºä¸»å±å¹•ç»„ä»¶
            const allApps = document.querySelectorAll('.app-screen');
            const hasVisibleApp = Array.from(allApps).some(app => 
                app.style.display === 'flex' || app.style.display === 'block'
            );
            
            if (!hasVisibleApp) {
                // æ˜¾ç¤ºä¸»å±å¹•ç»„ä»¶
                const clockContainer = document.getElementById('clock-container');
                const homeGrid = document.getElementById('home-grid');
                const dockBar = document.getElementById('dock-bar');
                if (clockContainer) clockContainer.style.display = 'block';
                if (homeGrid) homeGrid.style.display = 'grid';
                if (dockBar) dockBar.style.display = 'block';
            }
        }
        
        // æ˜¾ç¤º/éšè—æ¨¡æ€æ¡†
        function showModal(modalId) {
            document.getElementById(modalId).style.display = 'flex';
            

        }
        
        function hideModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // çºªå¿µæ—¥åŠŸèƒ½
        let anniversaries = [];
        let editingAnniversaryId = null;

        // æ˜¾ç¤ºçºªå¿µæ—¥è¡¨å•
        function showAnniversaryForm(anniversaryId = null) {
            editingAnniversaryId = anniversaryId;
            const modal = document.getElementById('anniversary-form-modal');
            const title = document.getElementById('anniversary-form-title');

            if (anniversaryId) {
                // ç¼–è¾‘æ¨¡å¼
                title.textContent = 'ç¼–è¾‘çºªå¿µæ—¥';
                const anniversary = anniversaries.find(a => a.id === anniversaryId);
                if (anniversary) {
                    document.getElementById('anniversary-name').value = anniversary.name;
                    document.getElementById('anniversary-date').value = anniversary.date;
                    document.getElementById('anniversary-type').value = anniversary.type;
                    document.getElementById('anniversary-description').value = anniversary.description || '';
                    document.getElementById('anniversary-yearly').checked = anniversary.yearly;
                    document.getElementById('anniversary-notify').checked = anniversary.notify;
                }
            } else {
                // æ–°å»ºæ¨¡å¼
                title.textContent = 'æ·»åŠ çºªå¿µæ—¥';
                clearAnniversaryForm();
            }

            modal.style.display = 'flex';
        }

        // å…³é—­çºªå¿µæ—¥è¡¨å•
        function closeAnniversaryForm() {
            document.getElementById('anniversary-form-modal').style.display = 'none';
            clearAnniversaryForm();
            editingAnniversaryId = null;
        }

        // æ¸…ç©ºçºªå¿µæ—¥è¡¨å•
        function clearAnniversaryForm() {
            document.getElementById('anniversary-name').value = '';
            document.getElementById('anniversary-date').value = '';
            document.getElementById('anniversary-type').value = 'birthday';
            document.getElementById('anniversary-description').value = '';
            document.getElementById('anniversary-yearly').checked = true;
            document.getElementById('anniversary-notify').checked = false;
        }

        // ä¿å­˜çºªå¿µæ—¥
        async function saveAnniversary() {
            const name = document.getElementById('anniversary-name').value.trim();
            const date = document.getElementById('anniversary-date').value;
            const type = document.getElementById('anniversary-type').value;
            const description = document.getElementById('anniversary-description').value.trim();
            const yearly = document.getElementById('anniversary-yearly').checked;
            const notify = document.getElementById('anniversary-notify').checked;

            if (!name || !date) {
                showToast('è¯·å¡«å†™çºªå¿µæ—¥åç§°å’Œæ—¥æœŸ', 'error');
                return;
            }

            const anniversaryData = {
                id: editingAnniversaryId || Date.now().toString(),
                name,
                date,
                type,
                description,
                yearly,
                notify,
                createdAt: editingAnniversaryId ? anniversaries.find(a => a.id === editingAnniversaryId).createdAt : new Date().toISOString()
            };

            try {
                if (editingAnniversaryId) {
                    // æ›´æ–°ç°æœ‰çºªå¿µæ—¥
                    await db.anniversaries.put(anniversaryData);
                    const index = anniversaries.findIndex(a => a.id === editingAnniversaryId);
                    if (index !== -1) {
                        anniversaries[index] = anniversaryData;
                    }
                    showToast('çºªå¿µæ—¥å·²æ›´æ–°', 'success');
                } else {
                    // æ·»åŠ æ–°çºªå¿µæ—¥
                    await db.anniversaries.add(anniversaryData);
                    anniversaries.push(anniversaryData);
                    showToast('çºªå¿µæ—¥å·²æ·»åŠ ', 'success');
                }

                closeAnniversaryForm();
                loadAnniversaryList();
            } catch (error) {
                console.error('ä¿å­˜çºªå¿µæ—¥å¤±è´¥:', error);
                showToast('ä¿å­˜å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
            }
        }

        // åŠ è½½çºªå¿µæ—¥åˆ—è¡¨
        async function loadAnniversaryList() {
            try {
                // ç¡®ä¿æ•°æ®åº“å·²åˆå§‹åŒ–
                if (!db || !db.anniversaries) {
                    console.warn('æ•°æ®åº“æœªåˆå§‹åŒ–ï¼Œè·³è¿‡çºªå¿µæ—¥åŠ è½½');
                    anniversaries = [];
                    renderAnniversaryList();
                    return;
                }

                anniversaries = await db.anniversaries.orderBy('date').toArray();
                renderAnniversaryList();
            } catch (error) {
                console.error('åŠ è½½çºªå¿µæ—¥åˆ—è¡¨å¤±è´¥:', error);
                // ä¸æ˜¾ç¤ºé”™è¯¯æç¤ºï¼Œé¿å…åˆå§‹åŒ–æ—¶çš„å¹²æ‰°
                anniversaries = [];
                renderAnniversaryList();
            }
        }

        // æ¸²æŸ“çºªå¿µæ—¥åˆ—è¡¨
        function renderAnniversaryList() {
            const container = document.getElementById('anniversary-list');

            if (anniversaries.length === 0) {
                container.innerHTML = `
                    <div class="anniversary-empty-state">
                        <i class="fas fa-heart"></i>
                        <p>è¿˜æ²¡æœ‰çºªå¿µæ—¥</p>
                        <p>ç‚¹å‡»å³ä¸Šè§’ + æ·»åŠ é‡è¦çš„æ—¥å­</p>
                    </div>
                `;
                return;
            }

            const now = new Date();
            const currentYear = now.getFullYear();

            container.innerHTML = anniversaries.map(anniversary => {
                const anniversaryDate = new Date(anniversary.date);
                let nextDate = new Date(currentYear, anniversaryDate.getMonth(), anniversaryDate.getDate());

                // å¦‚æœä»Šå¹´çš„æ—¥æœŸå·²è¿‡ï¼Œè®¡ç®—æ˜å¹´çš„æ—¥æœŸ
                if (nextDate < now) {
                    nextDate.setFullYear(currentYear + 1);
                }

                const daysUntil = Math.ceil((nextDate - now) / (1000 * 60 * 60 * 24));
                const countdownText = daysUntil === 0 ? 'ä»Šå¤©ï¼' :
                                    daysUntil === 1 ? 'æ˜å¤©' :
                                    `è¿˜æœ‰ ${daysUntil} å¤©`;

                return `
                    <div class="anniversary-item" onclick="showAnniversaryForm('${anniversary.id}')">
                        <div class="anniversary-item-header">
                            <div>
                                <div class="anniversary-item-name">${anniversary.name}</div>
                                <div class="anniversary-item-date">${formatDate(anniversary.date)}</div>
                            </div>
                            <div class="anniversary-item-type ${anniversary.type}">${getTypeText(anniversary.type)}</div>
                        </div>
                        <div class="anniversary-item-countdown">${countdownText}</div>
                        ${anniversary.description ? `<div class="anniversary-item-description">${anniversary.description}</div>` : ''}
                        <div class="anniversary-item-actions" onclick="event.stopPropagation()">
                            <button class="anniversary-action-btn anniversary-edit-btn" onclick="showAnniversaryForm('${anniversary.id}')">
                                ç¼–è¾‘
                            </button>
                            <button class="anniversary-action-btn anniversary-delete-btn" onclick="deleteAnniversary('${anniversary.id}')">
                                åˆ é™¤
                            </button>
                        </div>
                    </div>
                `;
            }).join('');

            // æ›´æ–°çºªå¿µæ—¥å°ç»„ä»¶
            const savedAnniversary = localStorage.getItem('anniversaryWidgetSelection');
            if (savedAnniversary) {
                const anniversary = anniversaries.find(a => a.id === savedAnniversary);
                if (anniversary) {
                    displayAnniversaryWidget(anniversary);
                } else {
                    // å¦‚æœé€‰ä¸­çš„çºªå¿µæ—¥è¢«åˆ é™¤äº†ï¼Œæ¸…é™¤å°ç»„ä»¶
                    clearAnniversaryWidget();
                }
            }
        }

        // åˆ é™¤çºªå¿µæ—¥
        async function deleteAnniversary(anniversaryId) {
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªçºªå¿µæ—¥å—ï¼Ÿ')) {
                try {
                    await db.anniversaries.delete(anniversaryId);
                    anniversaries = anniversaries.filter(a => a.id !== anniversaryId);
                    renderAnniversaryList();
                    showToast('çºªå¿µæ—¥å·²åˆ é™¤', 'success');
                } catch (error) {
                    console.error('åˆ é™¤çºªå¿µæ—¥å¤±è´¥:', error);
                    showToast('åˆ é™¤å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
                }
            }
        }

        // æ ¼å¼åŒ–æ—¥æœŸ
        function formatDate(dateString) {
            const date = new Date(dateString);
            return `${date.getMonth() + 1}æœˆ${date.getDate()}æ—¥`;
        }

        // è·å–ç±»å‹æ–‡æœ¬
        function getTypeText(type) {
            const typeMap = {
                birthday: 'ç”Ÿæ—¥',
                anniversary: 'çºªå¿µæ—¥',
                holiday: 'èŠ‚æ—¥',
                other: 'å…¶ä»–'
            };
            return typeMap[type] || 'å…¶ä»–';
        }

        // æ˜¾ç¤ºæ–°çŸ­ä¿¡è¡¨å•ï¼ˆé¢„ç•™åŠŸèƒ½ï¼‰
        function showNewMessageForm() {
            showToast('çŸ­ä¿¡åŠŸèƒ½æ­£åœ¨å¼€å‘ä¸­', 'info');
        }

        // å›¾ç‰‡å°ç»„ä»¶åŠŸèƒ½
        function showPhotoWidgetOptions() {
            document.getElementById('photo-widget-modal').style.display = 'flex';
        }

        function closePhotoWidgetModal() {
            document.getElementById('photo-widget-modal').style.display = 'none';
        }

        function handlePhotoWidgetUpload(input) {
            if (input.files && input.files[0]) {
                const file = input.files[0];
                const reader = new FileReader();

                reader.onload = function(e) {
                    const imageData = e.target.result;

                    // ä¿å­˜åˆ°localStorage
                    localStorage.setItem('photoWidgetImage', imageData);

                    // æ›´æ–°æ˜¾ç¤º
                    updatePhotoWidget(imageData);

                    showToast('å›¾ç‰‡å·²è®¾ç½®', 'success');
                    closePhotoWidgetModal();
                };

                reader.readAsDataURL(file);
            }
        }

        function updatePhotoWidget(imageData) {
            const placeholder = document.getElementById('photo-placeholder');
            const image = document.getElementById('photo-widget-image');

            if (imageData) {
                placeholder.style.display = 'none';
                image.src = imageData;
                image.style.display = 'block';

                // ç¡®ä¿å›¾ç‰‡æ­£ç¡®ç¼©æ”¾
                image.onload = function() {
                    // å›¾ç‰‡å·²åŠ è½½ï¼ŒCSSä¼šè‡ªåŠ¨å¤„ç†ç¼©æ”¾
                };
            } else {
                placeholder.style.display = 'block';
                image.style.display = 'none';
            }
        }

        function clearPhotoWidget() {
            localStorage.removeItem('photoWidgetImage');
            updatePhotoWidget(null);
            showToast('å›¾ç‰‡å·²æ¸…é™¤', 'success');
            closePhotoWidgetModal();
        }

        // çºªå¿µæ—¥å°ç»„ä»¶åŠŸèƒ½
        function showAnniversaryWidgetOptions() {
            // æ›´æ–°é€‰æ‹©åˆ—è¡¨
            updateAnniversaryWidgetSelect();
            document.getElementById('anniversary-widget-modal').style.display = 'flex';
        }

        function closeAnniversaryWidgetModal() {
            document.getElementById('anniversary-widget-modal').style.display = 'none';
        }

        function updateAnniversaryWidgetSelect() {
            const select = document.getElementById('widget-anniversary-select');
            const currentSelection = localStorage.getItem('anniversaryWidgetSelection');

            // æ¸…ç©ºé€‰é¡¹
            select.innerHTML = '<option value="">è¯·é€‰æ‹©çºªå¿µæ—¥</option>';

            // æ·»åŠ çºªå¿µæ—¥é€‰é¡¹
            anniversaries.forEach(anniversary => {
                const option = document.createElement('option');
                option.value = anniversary.id;
                option.textContent = anniversary.name;
                if (anniversary.id === currentSelection) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
        }

        function updateAnniversaryWidget() {
            const select = document.getElementById('widget-anniversary-select');
            const selectedId = select.value;

            if (selectedId) {
                const anniversary = anniversaries.find(a => a.id === selectedId);
                if (anniversary) {
                    localStorage.setItem('anniversaryWidgetSelection', selectedId);
                    displayAnniversaryWidget(anniversary);
                    showToast('çºªå¿µæ—¥å°ç»„ä»¶å·²æ›´æ–°', 'success');
                }
            } else {
                clearAnniversaryWidget();
            }
        }

        function displayAnniversaryWidget(anniversary) {
            const placeholder = document.getElementById('anniversary-placeholder');
            const display = document.getElementById('anniversary-display');
            const nameEl = document.getElementById('widget-anniversary-name');
            const countdownEl = document.getElementById('widget-anniversary-countdown');
            const dateEl = document.getElementById('widget-anniversary-date');

            // è®¡ç®—å€’è®¡æ—¶
            const now = new Date();
            const currentYear = now.getFullYear();
            const anniversaryDate = new Date(anniversary.date);
            let nextDate = new Date(currentYear, anniversaryDate.getMonth(), anniversaryDate.getDate());

            if (nextDate < now) {
                nextDate.setFullYear(currentYear + 1);
            }

            const daysUntil = Math.ceil((nextDate - now) / (1000 * 60 * 60 * 24));
            const countdownText = daysUntil === 0 ? 'ä»Šå¤©ï¼' :
                                daysUntil === 1 ? 'æ˜å¤©' :
                                `${daysUntil}å¤©`;

            // æ›´æ–°æ˜¾ç¤º
            nameEl.textContent = anniversary.name;
            countdownEl.textContent = countdownText;
            dateEl.textContent = formatDate(anniversary.date);

            placeholder.style.display = 'none';
            display.style.display = 'block';
        }

        function clearAnniversaryWidget() {
            localStorage.removeItem('anniversaryWidgetSelection');
            const placeholder = document.getElementById('anniversary-placeholder');
            const display = document.getElementById('anniversary-display');

            placeholder.style.display = 'block';
            display.style.display = 'none';

            showToast('çºªå¿µæ—¥å°ç»„ä»¶å·²æ¸…é™¤', 'success');
        }

        // åˆå§‹åŒ–å°ç»„ä»¶
        function initializeWidgets() {
            try {
                // åˆå§‹åŒ–å›¾ç‰‡å°ç»„ä»¶
                const savedImage = localStorage.getItem('photoWidgetImage');
                if (savedImage) {
                    updatePhotoWidget(savedImage);
                }

                // åˆå§‹åŒ–çºªå¿µæ—¥å°ç»„ä»¶
                const savedAnniversary = localStorage.getItem('anniversaryWidgetSelection');
                if (savedAnniversary && anniversaries && anniversaries.length > 0) {
                    const anniversary = anniversaries.find(a => a.id === savedAnniversary);
                    if (anniversary) {
                        displayAnniversaryWidget(anniversary);
                    }
                }
            } catch (error) {
                console.error('åˆå§‹åŒ–å°ç»„ä»¶å¤±è´¥:', error);
            }
        }

        // åˆ‡æ¢ç…§ç‰‡æ–‡å­—æ˜¾ç¤º
        function togglePhotoText(container, description) {
            const overlay = container.querySelector('.photo-text-overlay');
            const sparkles = container.querySelector('.sparkle-container');
            const badge = container.querySelector('.photo-badge');
            
            if (overlay.style.display === 'none') {
                // æ˜¾ç¤ºæ–‡å­—ï¼Œéšè—æ˜Ÿæ˜Ÿå’Œæ ‡å¿—
                overlay.style.display = 'flex';
                sparkles.style.opacity = '0';
                badge.style.opacity = '0.3';
            } else {
                // éšè—æ–‡å­—ï¼Œæ˜¾ç¤ºæ˜Ÿæ˜Ÿå’Œæ ‡å¿—
                overlay.style.display = 'none';
                sparkles.style.opacity = '1';
                badge.style.opacity = '1';
            }
        }

        // æ˜¾ç¤ºç”¨æˆ·ç…§ç‰‡æè¿°
        function showUserPhotoDescription(description) {
            const modalHtml = `
                <div id="photo-description-modal" class="modal" style="display: flex; z-index: 10000; background: rgba(0, 0, 0, 0.8);">
                    <div class="magical-photo-modal">
                        <div class="photo-modal-bg"></div>
                        <div class="photo-modal-content">
                            <div class="photo-modal-header">
                                <i class="fas fa-camera photo-modal-icon"></i>
                                <div class="photo-modal-title">ç…§ç‰‡å†…å®¹</div>
                            </div>
                            <div class="photo-modal-body">
                                <div class="photo-description-text">${description}</div>
                            </div>
                            <div class="photo-modal-footer">
                                <button class="photo-modal-btn" id="photo-description-close">ç¡®å®š</button>
                            </div>
                        </div>
                        <div class="modal-sparkles">
                            <div class="modal-sparkle modal-sparkle-1">âœ¨</div>
                            <div class="modal-sparkle modal-sparkle-2">â­</div>
                            <div class="modal-sparkle modal-sparkle-3">âœ¨</div>
                            <div class="modal-sparkle modal-sparkle-4">â­</div>
                            <div class="modal-sparkle modal-sparkle-5">ğŸ’«</div>
                            <div class="modal-sparkle modal-sparkle-6">âœ¨</div>
                            <div class="modal-sparkle modal-sparkle-7">â­</div>
                            <div class="modal-sparkle modal-sparkle-8">ğŸ’«</div>
                        </div>
                    </div>
                </div>
            `;
            
            // æ·»åŠ åˆ°é¡µé¢
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            
            const modal = document.getElementById('photo-description-modal');
            const closeBtn = document.getElementById('photo-description-close');
            
            // å…³é—­æŒ‰é’®äº‹ä»¶
            closeBtn.onclick = () => {
                modal.remove();
            };
            
            // ç‚¹å‡»èƒŒæ™¯å…³é—­
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            };
        }

        // è‡ªå®šä¹‰è¾“å…¥æç¤ºæ¡†
        function showCustomPrompt(title, placeholder, initialValue = '', type = 'text') {
            return new Promise(resolve => {
                // åˆ›å»ºæ¨¡æ€æ¡†HTML
                const modalHtml = `
                    <div id="custom-prompt-modal" class="modal" style="display: flex; z-index: 10000;">
                        <div class="modal-content" style="max-width: 400px;">
                            <div class="modal-header">
                                <div class="modal-title">${title}</div>
                            </div>
                            <div class="modal-body">
                                <input type="${type}" id="custom-prompt-input" class="form-input" 
                                       placeholder="${placeholder}" value="${initialValue}"
                                       style="width: 100%; margin-top: 10px;">
                            </div>
                            <div class="modal-footer">
                                <button class="modal-button modal-secondary" id="custom-prompt-cancel">å–æ¶ˆ</button>
                                <button class="modal-button modal-primary" id="custom-prompt-confirm">ç¡®å®š</button>
                            </div>
                        </div>
                    </div>
                `;
                
                // æ·»åŠ åˆ°é¡µé¢
                document.body.insertAdjacentHTML('beforeend', modalHtml);
                
                const modal = document.getElementById('custom-prompt-modal');
                const input = document.getElementById('custom-prompt-input');
                const confirmBtn = document.getElementById('custom-prompt-confirm');
                const cancelBtn = document.getElementById('custom-prompt-cancel');
                
                // ç¡®å®šæŒ‰é’®äº‹ä»¶
                confirmBtn.onclick = () => {
                    const value = input.value;
                    modal.remove();
                    resolve(value);
                };
                
                // å–æ¶ˆæŒ‰é’®äº‹ä»¶
                cancelBtn.onclick = () => {
                    modal.remove();
                    resolve(null);
                };
                
                // å›è½¦é”®ç¡®è®¤
                input.onkeydown = (e) => {
                    if (e.key === 'Enter') {
                        confirmBtn.click();
                    }
                };
                
                // èšç„¦è¾“å…¥æ¡†
                setTimeout(() => input.focus(), 100);
            });
        }
        
        // åˆ‡æ¢èŠå¤©æ ‡ç­¾
        function switchChatTab(tabId) {
            // ç§»é™¤æ‰€æœ‰æ ‡ç­¾çš„activeç±»
            document.querySelectorAll('.chat-tab').forEach(tab => {
                if (tab && tab.classList) {
                    tab.classList.remove('active');
                }
            });
            
            // æ·»åŠ å½“å‰æ ‡ç­¾çš„activeç±»
            if (event && event.currentTarget && event.currentTarget.classList) {
                event.currentTarget.classList.add('active');
            } else {
                // å¦‚æœæ²¡æœ‰eventå¯¹è±¡ï¼Œæ ¹æ®tabIdè®¾ç½®active
                if (tabId === 'message-list') {
                    const messageTab = document.getElementById('message-tab');
                    if (messageTab && messageTab.classList) {
                        messageTab.classList.add('active');
                    }
                } else if (tabId === 'contact-list') {
                    const tabs = document.querySelectorAll('.chat-tab');
                    if (tabs.length > 1 && tabs[1] && tabs[1].classList) {
                        tabs[1].classList.add('active');
                    }
                } else if (tabId === 'moments-page') {
                    const tabs = document.querySelectorAll('.chat-tab');
                    if (tabs.length > 2 && tabs[2] && tabs[2].classList) {
                        tabs[2].classList.add('active');
                    }
                } else if (tabId === 'profile-page') {
                    const tabs = document.querySelectorAll('.chat-tab');
                    if (tabs.length > 3 && tabs[3] && tabs[3].classList) {
                        tabs[3].classList.add('active');
                    }
                }
            }
            
            // éšè—æ‰€æœ‰å†…å®¹
            const messageListEl = document.getElementById('message-list');
            const contactListEl = document.getElementById('contact-list');
            const profilePageEl = document.getElementById('profile-page');
            const momentsPageEl = document.getElementById('moments-page');
            const targetEl = document.getElementById(tabId);
            
            if (messageListEl) messageListEl.style.display = 'none';
            if (contactListEl) contactListEl.style.display = 'none';
            if (profilePageEl) profilePageEl.style.display = 'none';
            if (momentsPageEl) momentsPageEl.style.display = 'none';
            
            // æ˜¾ç¤ºé€‰ä¸­çš„å†…å®¹
            if (targetEl) targetEl.style.display = 'block';
            
            // æ§åˆ¶appæ ‡é¢˜çš„æ¸å˜æ•ˆæœå’Œå†…å®¹
            const appTitle = document.querySelector('#chat-screen .app-title');
            if (appTitle) {
                if (tabId === 'message-list') {
                    appTitle.classList.add('chat-mode');
                    appTitle.textContent = 'ğŸ’¬';
                } else if (tabId === 'contact-list') {
                    appTitle.classList.remove('chat-mode');
                    appTitle.textContent = 'è§’è‰²';
                } else if (tabId === 'moments-page') {
                    appTitle.classList.remove('chat-mode');
                                            appTitle.textContent = 'åŠ¨æ€';
                    // ğŸ”¥ã€æ–°å¢ã€‘åˆ‡æ¢åˆ°åŠ¨æ€é¡µé¢æ—¶åŠ è½½ç”¨æˆ·è®¾ç½®
                    loadMomentsImages();
                } else if (tabId === 'profile-page') {
                    appTitle.classList.remove('chat-mode');
                    appTitle.textContent = 'æˆ‘';
                }
            }
            
            // æ§åˆ¶æŒ‰é’®æ˜¾ç¤º
            const addContactBtn = document.getElementById('add-contact-btn');
            const addChatBtn = document.getElementById('add-chat-btn');
            const groupManageBtn = document.getElementById('group-manage-btn');
            
            if (addContactBtn && addChatBtn && groupManageBtn) {
                if (tabId === 'contact-list') {
                    addContactBtn.style.display = 'flex';
                    addChatBtn.style.display = 'none';
                    groupManageBtn.style.display = isGroupManageMode ? 'none' : 'flex';
                    // ä¿®æ”¹åŠ å·æŒ‰é’®çš„ç‚¹å‡»äº‹ä»¶ä¸ºåˆ›å»ºè§’è‰²
                    addContactBtn.onclick = () => showCharacterForm();
                } else if (tabId === 'message-list') {
                    addContactBtn.style.display = 'none';
                    addChatBtn.style.display = 'flex';
                    groupManageBtn.style.display = 'none';
                } else if (tabId === 'moments-page') {
                                            // åŠ¨æ€é¡µé¢æ˜¾ç¤ºå‘å¸ƒæŒ‰é’®
                    addContactBtn.style.display = 'flex';
                    addChatBtn.style.display = 'none';
                    groupManageBtn.style.display = 'none';
                    // ä¿®æ”¹åŠ å·æŒ‰é’®çš„ç‚¹å‡»äº‹ä»¶ä¸ºå‘å¸ƒåŠ¨æ€
                    addContactBtn.onclick = () => showPublishMoment();
                } else {
                    addContactBtn.style.display = 'none';
                    addChatBtn.style.display = 'none';
                    groupManageBtn.style.display = 'none';
                }
            }
            
            // å¦‚æœæ˜¯åŠ¨æ€é¡µé¢ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦åŠ è½½åŠ¨æ€å†…å®¹
            if (tabId === 'moments-page') {
                // åªåœ¨åŠ¨æ€åˆ—è¡¨ä¸ºç©ºæ—¶åŠ è½½ï¼Œé¿å…é‡å¤æ˜¾ç¤º
                const momentsList = document.getElementById('moments-list');
                if (momentsList && momentsList.children.length === 0) {
                loadMoments();
                }
                                        // ç§»é™¤åŠ¨æ€é¡µé¢çš„paddingï¼Œå®ç°å…¨å±æ•ˆæœ
                const chatContent = document.getElementById('chat-content');
                if (chatContent) {
                    chatContent.style.padding = '0';
                }
            } else {
                // å…¶ä»–é¡µé¢æ¢å¤æ­£å¸¸padding
                const chatContent = document.getElementById('chat-content');
                if (chatContent) {
                    chatContent.style.padding = '15px';
                }
                
                // åœæ­¢æ—¶é—´æ›´æ–°å™¨ï¼ˆèŠ‚çœèµ„æºï¼‰
                stopTimeUpdater();
            }
        }
        
        // æ›´æ–°æ—¶é—´
        function updateTime() {
            const now = new Date();
            const hours = now.getHours().toString().padStart(2, '0');
            const minutes = now.getMinutes().toString().padStart(2, '0');
            const timeString = `${hours}:${minutes}`;
            
            // æ›´æ–°çŠ¶æ€æ æ—¶é—´
            const statusTime = document.getElementById('status-bar-time');
            if (statusTime) {
                statusTime.textContent = timeString;
            }
            
            // æ›´æ–°åº”ç”¨å†…çŠ¶æ€æ æ—¶é—´
            const appStatusTimes = document.querySelectorAll('.app-status-time');
            appStatusTimes.forEach(element => {
                element.textContent = timeString;
            });
            
            // æ›´æ–°ä¸»æ—¶é’Ÿ
            const mainTime = document.getElementById('main-time');
            if (mainTime) {
                mainTime.textContent = timeString;
            }
            
            // æ›´æ–°æ—¥æœŸ
            const mainDate = document.getElementById('main-date');
            if (mainDate) {
                const date = now.toLocaleDateString('zh-CN', { 
                    month: 'long', 
                    day: 'numeric',
                    weekday: 'long'
                });
                mainDate.textContent = date;
            }
        }
        
        // åŠ è½½è§’è‰²åˆ†ç»„æ•°æ®
        async function loadCharacterGroups() {
            try {
                const savedGroups = await db.characterGroups.orderBy('order').toArray();
                
                if (savedGroups.length === 0) {
                    // å¦‚æœæ²¡æœ‰åˆ†ç»„ï¼Œåˆ›å»ºé»˜è®¤åˆ†ç»„
                    const defaultGroups = [
                        { id: 'my_friends', name: 'æˆ‘çš„å¥½å‹', order: 999, isDefault: true, canInteract: false },
                        { id: 'special_care', name: 'ç‰¹åˆ«å…³å¿ƒ', order: 1, isDefault: false, canInteract: true },
                        { id: 'close_friends', name: 'äº²å¯†æœ‹å‹', order: 2, isDefault: false, canInteract: true },
                        { id: 'family', name: 'å®¶äºº', order: 3, isDefault: false, canInteract: true },
                        { id: 'classmates', name: 'åŒå­¦', order: 4, isDefault: false, canInteract: true },
                        { id: 'colleagues', name: 'åŒäº‹', order: 5, isDefault: false, canInteract: true }
                    ];
                    
                    await db.characterGroups.bulkAdd(defaultGroups);
                    characterGroups = defaultGroups;
                } else {
                    characterGroups = savedGroups;
                }
            } catch (error) {
                console.error('åŠ è½½è§’è‰²åˆ†ç»„å¤±è´¥:', error);
                // åˆ›å»ºåŸºæœ¬çš„é»˜è®¤åˆ†ç»„
                characterGroups = [
                    { id: 'my_friends', name: 'æˆ‘çš„å¥½å‹', order: 999, isDefault: true, canInteract: false }
                ];
            }
        }

        // ä¿å­˜è§’è‰²åˆ†ç»„æ•°æ®
        async function saveCharacterGroups() {
            try {
                await db.characterGroups.clear();
                await db.characterGroups.bulkAdd(characterGroups);
            } catch (error) {
                console.error('ä¿å­˜è§’è‰²åˆ†ç»„å¤±è´¥:', error);
            }
        }

        // åŠ è½½è§’è‰²æ•°æ® - ä½¿ç”¨IndexedDBï¼ˆåŒ…å«æ•°æ®è¿ç§»ï¼‰
        async function loadCharacters() {
            try {
                // å…ˆæ£€æŸ¥IndexedDBä¸­æ˜¯å¦æœ‰æ•°æ®
                const savedCharacters = await db.characters.toArray();
                
                if (savedCharacters.length === 0) {
                    // IndexedDBä¸­æ²¡æœ‰æ•°æ®ï¼Œå°è¯•ä»localStorageè¿ç§»
                    const localStorageData = localStorage.getItem('characters');
                    if (localStorageData) {
                        const localCharacters = JSON.parse(localStorageData);
                        
                        if (localCharacters.length > 0) {
                            // ä¸ºæ—§è§’è‰²æ•°æ®æ·»åŠ é»˜è®¤åˆ†ç»„
                            localCharacters.forEach(character => {
                                if (!character.groupId) {
                                    character.groupId = 'my_friends'; // é»˜è®¤åˆ†ç»„
                                }
                            });
                            
                            // è¿ç§»æ•°æ®åˆ°IndexedDB
                            await db.characters.bulkAdd(localCharacters);
                            characters = localCharacters;
                            // å¯é€‰ï¼šæ¸…é™¤localStorageä¸­çš„æ—§æ•°æ®
                            // localStorage.removeItem('characters');
                        } else {
                            characters = [];
                        }
                    } else {
                        characters = [];
                    }
                } else {
                    // ç¡®ä¿æ‰€æœ‰è§’è‰²éƒ½æœ‰åˆ†ç»„ID
                    savedCharacters.forEach(character => {
                        if (!character.groupId) {
                            character.groupId = 'my_friends';
                        }
                    });
                    characters = savedCharacters;
                }
            } catch (error) {
                console.error('åŠ è½½è§’è‰²æ•°æ®å¤±è´¥:', error);
                // å¦‚æœIndexedDBå¤±è´¥ï¼Œå°è¯•ä»localStorageåŠ è½½
                const localStorageData = localStorage.getItem('characters');
                if (localStorageData) {
                    characters = JSON.parse(localStorageData);
                    // ä¸ºè§’è‰²æ·»åŠ é»˜è®¤åˆ†ç»„
                    characters.forEach(character => {
                        if (!character.groupId) {
                            character.groupId = 'my_friends';
                        }
                    });

                } else {
                    characters = [];
                }
            }
        }
        
        // ä¿å­˜è§’è‰²æ•°æ® - ä½¿ç”¨IndexedDB
        async function saveCharacters() {
            try {

                
                // æ£€æŸ¥é‡å¤ID
                const uniqueIds = new Set();
                const uniqueCharacters = [];
                
                for (const character of characters) {
                    if (!character.id) {
                        console.warn('å‘ç°æ²¡æœ‰IDçš„è§’è‰²ï¼Œè·³è¿‡ä¿å­˜:', character);
                        continue;
                    }
                    
                    if (!uniqueIds.has(character.id)) {
                        uniqueIds.add(character.id);
                        uniqueCharacters.push(character);
                    } else {
                        console.warn(`å‘ç°é‡å¤IDçš„è§’è‰² (${character.id})ï¼Œè·³è¿‡é‡å¤é¡¹:`, character);
                    }
                }
                
                // ğŸ”¥ã€å®‰å…¨ä¿®å¤ã€‘ä½¿ç”¨äº‹åŠ¡ç¡®ä¿åŸå­æ“ä½œï¼Œé˜²æ­¢æ•°æ®ä¸¢å¤±
                if (uniqueCharacters.length === 0) {
                    console.warn('âš ï¸ æ‹’ç»ä¿å­˜ç©ºè§’è‰²æ•°æ®ï¼Œå¯èƒ½å­˜åœ¨æ•°æ®ä¸¢å¤±é£é™©');
                    return;
                }

                // ä½¿ç”¨äº‹åŠ¡è¿›è¡ŒåŸå­æ“ä½œ
                await db.transaction('rw', db.characters, async () => {
                    await db.characters.clear();
                    await db.characters.bulkPut(uniqueCharacters);
                });

                console.log(`âœ… å®‰å…¨ä¿å­˜äº† ${uniqueCharacters.length} ä¸ªè§’è‰²åˆ°æ•°æ®åº“`);
                

            } catch (error) {
                console.error('ä¿å­˜è§’è‰²æ—¶å‘ç”Ÿé”™è¯¯:', error);
                alert('ä¿å­˜è§’è‰²æ—¶å‘ç”Ÿé”™è¯¯: ' + error.message);
                throw error;
            }
        }
        
        // æ˜¾ç¤ºå­˜å‚¨ä½¿ç”¨æƒ…å†µ
        function showStorageUsage() {
            const usage = [];
            
            // è®¡ç®—å„ç§æ•°æ®çš„å¤§å°
            const characters = localStorage.getItem('characters') || '[]';
            const chatMessages = localStorage.getItem('chatMessages') || '{}';
            const customEmojis = localStorage.getItem('customEmojis') || '[]';
            
            usage.push(`è§’è‰²æ•°æ®: ${(characters.length / 1024).toFixed(1)} KB`);
            usage.push(`èŠå¤©è®°å½•: ${(chatMessages.length / 1024).toFixed(1)} KB`);
            usage.push(`è¡¨æƒ…åŒ…: ${(customEmojis.length / 1024).toFixed(1)} KB`);
            
            const total = characters.length + chatMessages.length + customEmojis.length;
            usage.push(`æ€»è®¡: ${(total / 1024).toFixed(1)} KB`);
            

            alert('å­˜å‚¨ä½¿ç”¨æƒ…å†µ:\n' + usage.join('\n'));
        }
        
        // ğŸ”¥ã€æ¶æ„ä¿®å¤ã€‘åŠ è½½è”ç³»äººæ•°æ® - ä»è§’è‰²åˆ—è¡¨è‡ªåŠ¨ç”Ÿæˆ
        async function loadContacts() {
            try {
                // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘ä¸å†ä¾èµ–ç‹¬ç«‹çš„contactsè¡¨ï¼Œç›´æ¥ä»charactersç”Ÿæˆ
                console.log('ğŸ”„ ä»è§’è‰²åˆ—è¡¨ç”Ÿæˆè”ç³»äººåˆ—è¡¨...');

                // ç¡®ä¿characterså·²ç»åŠ è½½
                if (!characters || characters.length === 0) {
                    console.log('âš ï¸ è§’è‰²åˆ—è¡¨ä¸ºç©ºï¼Œå°è¯•é‡æ–°åŠ è½½è§’è‰²æ•°æ®');
                    await loadCharacters();
                }

                // ä»è§’è‰²åˆ—è¡¨ç”Ÿæˆè”ç³»äººIDåˆ—è¡¨
                contacts = characters
                    .filter(char => char && char.id) // åªä¿ç•™æœ‰æ•ˆçš„è§’è‰²
                    .map(char => char.id); // æå–è§’è‰²ID

                console.log(`âœ… ä» ${characters.length} ä¸ªè§’è‰²ç”Ÿæˆäº† ${contacts.length} ä¸ªè”ç³»äºº`);

                // ğŸ”¥ã€æ–°å¢ã€‘è‡ªåŠ¨ä¿å­˜åˆ°æ•°æ®åº“ä»¥ä¿æŒå…¼å®¹æ€§
                await saveContacts();

            } catch (error) {
                console.error('âŒ ç”Ÿæˆè”ç³»äººåˆ—è¡¨å¤±è´¥:', error);
                contacts = []; // å¦‚æœå‡ºé”™ï¼Œç¡®ä¿è”ç³»äººåˆ—è¡¨ä¸ºç©ºï¼Œé˜²æ­¢ç¨‹åºå´©æºƒ
            }
        }
        
        // ä¿å­˜è”ç³»äººæ•°æ® - ä½¿ç”¨IndexedDB
        async function saveContacts() {
            try {
        // è¿‡æ»¤æ‰ä»»ä½•å¯èƒ½å­˜åœ¨çš„æ— æ•ˆID
        const validContacts = contacts.filter(id => id); 
        // å°†è”ç³»äººIDåˆ—è¡¨è½¬æ¢ä¸ºæ•°æ®åº“éœ€è¦çš„å¯¹è±¡æ•°ç»„æ ¼å¼
        const contactArray = validContacts.map(id => ({ characterId: id }));

        await db.transaction('rw', db.contacts, async () => {
            // å…ˆæ¸…ç©ºæ—§è¡¨ï¼Œå†æ‰¹é‡å†™å…¥æ–°æ•°æ®
                await db.contacts.clear();
                if (contactArray.length > 0) {
                    await db.contacts.bulkAdd(contactArray);
                }
        });
            } catch (error) {
                console.error('ä¿å­˜è”ç³»äººå¤±è´¥:', error);
            }
        }
        
        // åŠ è½½èŠå¤©æ¶ˆæ¯ - ä½¿ç”¨IndexedDBï¼ˆåŒ…å«æ•°æ®è¿ç§»ï¼‰
        async function loadChatMessages() {
            try {
                const savedMessages = await db.chatMessages.toArray();
                chatMessages = {};

                if (savedMessages.length === 0) {
                    // IndexedDBä¸­æ²¡æœ‰æ•°æ®ï¼Œå°è¯•ä»localStorageè¿ç§»
                    const localStorageData = localStorage.getItem('chatMessages');
                    if (localStorageData) {

                        const localMessages = JSON.parse(localStorageData);
                        
                        // å°†å¯¹è±¡æ ¼å¼è½¬æ¢ä¸ºæ•°ç»„æ ¼å¼å­˜å‚¨åˆ°IndexedDB
                        const messageArray = [];
                        for (const [characterId, messages] of Object.entries(localMessages)) {
                            for (const message of messages) {
                                messageArray.push({
                                    id: `${characterId}_${message.id || message.timestamp}`,
                                    characterId: characterId,
                                    timestamp: message.timestamp,
                                    messageData: message
                                });
                            }
                        }
                        
                        if (messageArray.length > 0) {
                            await db.chatMessages.bulkAdd(messageArray);
                        }
                        
                        chatMessages = localMessages;

                    }
                } else {
                    // å°†æ•°ç»„æ ¼å¼è½¬æ¢å›å¯¹è±¡æ ¼å¼
                    for (const msgRecord of savedMessages) {
                        const characterId = msgRecord.characterId;
                        if (!chatMessages[characterId]) {
                            chatMessages[characterId] = [];
                        }
                        // ğŸ”¥ã€æ–°å¢ã€‘æ£€æŸ¥æ¶ˆæ¯æ•°æ®æ˜¯å¦æœ‰æ•ˆï¼Œè¿‡æ»¤ç©ºå€¼
                        if (msgRecord.messageData && typeof msgRecord.messageData === 'object') {
                        chatMessages[characterId].push(msgRecord.messageData);
                        }
                    }
                    
                    // æŒ‰æ—¶é—´æˆ³æ’åºå¹¶æ¸…ç†ç©ºå€¼
                    for (const characterId in chatMessages) {
                        // ğŸ”¥ã€æ–°å¢ã€‘è¿‡æ»¤æ‰nullã€undefinedæˆ–æ— æ•ˆçš„æ¶ˆæ¯ï¼Œä»¥åŠæ‹‰é»‘ç³»ç»Ÿæ¶ˆæ¯
                        chatMessages[characterId] = chatMessages[characterId]
                            .filter(msg => {
                                // åŸºæœ¬æœ‰æ•ˆæ€§æ£€æŸ¥
                                if (!msg || typeof msg !== 'object' || !msg.timestamp) {
                                    return false;
                                }
                                // ä¿ç•™æ‹‰é»‘ç³»ç»Ÿæ¶ˆæ¯ï¼Œå®ƒä»¬ç°åœ¨ä¼šæ­£ç¡®æ˜¾ç¤º
                                return true;
                            })
                            .sort((a, b) => a.timestamp - b.timestamp);
                    }

                    // ğŸ”¥ã€ä¿®å¤ã€‘æ¸…ç†æ•°æ®åº“ä¸­çš„æ‹‰é»‘ç³»ç»Ÿæ¶ˆæ¯
                    await cleanupBlockedSystemMessages();
                }
            } catch (error) {
                console.error('åŠ è½½èŠå¤©æ¶ˆæ¯å¤±è´¥:', error);
                // å¦‚æœIndexedDBå¤±è´¥ï¼Œå°è¯•ä»localStorageåŠ è½½
                const localStorageData = localStorage.getItem('chatMessages');
                if (localStorageData) {
                    chatMessages = JSON.parse(localStorageData);
                } else {
                    chatMessages = {};
                }
            }
        }

        // ğŸ”¥ã€ä¿®å¤ã€‘æ¸…ç†æ•°æ®åº“ä¸­é‡å¤çš„æ‹‰é»‘ç³»ç»Ÿæ¶ˆæ¯
        async function cleanupBlockedSystemMessages() {
            try {
                // è·å–æ‰€æœ‰èŠå¤©æ¶ˆæ¯è®°å½•
                const allMessages = await db.chatMessages.toArray();
                const messagesToDelete = [];

                // ğŸ”¥ã€ä¿®å¤ã€‘æ¸…ç†é‡å¤çš„æ‹‰é»‘ç³»ç»Ÿæ¶ˆæ¯
                const blockedMessagesByCharacter = {};

                for (const msgRecord of allMessages) {
                    if (msgRecord.messageData &&
                        msgRecord.messageData.sender === 'system' &&
                        msgRecord.messageData.isBlockedMessage) {

                        const characterId = msgRecord.characterId;
                        if (!blockedMessagesByCharacter[characterId]) {
                            blockedMessagesByCharacter[characterId] = [];
                        }
                        blockedMessagesByCharacter[characterId].push(msgRecord);
                    }
                }

                // å¯¹æ¯ä¸ªè§’è‰²ï¼Œåªä¿ç•™æœ€æ–°çš„æ‹‰é»‘ç³»ç»Ÿæ¶ˆæ¯ï¼Œåˆ é™¤é‡å¤çš„
                for (const characterId in blockedMessagesByCharacter) {
                    const messages = blockedMessagesByCharacter[characterId];
                    if (messages.length > 1) {
                        // æŒ‰æ—¶é—´æˆ³æ’åºï¼Œä¿ç•™æœ€æ–°çš„ï¼Œåˆ é™¤å…¶ä»–çš„
                        messages.sort((a, b) => (b.messageData.timestamp || 0) - (a.messageData.timestamp || 0));
                        const toDelete = messages.slice(1); // åˆ é™¤é™¤ç¬¬ä¸€ä¸ªï¼ˆæœ€æ–°ï¼‰ä¹‹å¤–çš„æ‰€æœ‰æ¶ˆæ¯
                        messagesToDelete.push(...toDelete.map(msg => msg.id));
                    }
                }

                if (messagesToDelete.length > 0) {
                    await db.chatMessages.bulkDelete(messagesToDelete);
                    console.log(`å·²æ¸…ç† ${messagesToDelete.length} æ¡é‡å¤çš„æ‹‰é»‘ç³»ç»Ÿæ¶ˆæ¯`);
                }
            } catch (error) {
                console.error('æ¸…ç†æ‹‰é»‘ç³»ç»Ÿæ¶ˆæ¯å¤±è´¥:', error);
            }
        }

        // é˜²æŠ–ä¿å­˜è®¡æ—¶å™¨
        let saveMessagesTimer = null;
        let isSaving = false; // é˜²æ­¢å¹¶å‘ä¿å­˜
        
        // é˜²æŠ–ç‰ˆæœ¬çš„ä¿å­˜å‡½æ•°
        function saveChatMessages() {
            // æ¸…é™¤ä¹‹å‰çš„è®¡æ—¶å™¨
            if (saveMessagesTimer) {
                clearTimeout(saveMessagesTimer);
            }
            
            // è®¾ç½®æ–°çš„è®¡æ—¶å™¨ï¼Œ500msåæ‰§è¡Œä¿å­˜
            saveMessagesTimer = setTimeout(async () => {
                if (isSaving) {
                    return;
                }
                await saveChatMessagesImmediate();
            }, 500);
        }
        
        // ç«‹å³ä¿å­˜èŠå¤©æ¶ˆæ¯ - ä½¿ç”¨IndexedDB
        async function saveChatMessagesImmediate() {
            if (isSaving) {
                return;
            }
            
            isSaving = true;
            
            try {

                
                // å°†chatMessageså¯¹è±¡è½¬æ¢ä¸ºæ•°ç»„æ ¼å¼å­˜å‚¨
                const messageArray = [];
                let globalSequentialId = 0; // å…¨å±€é¡ºåºIDç¡®ä¿å”¯ä¸€æ€§
                const usedIds = new Set(); // ç”¨äºæ£€æµ‹IDé‡å¤
                
                for (const [characterId, messages] of Object.entries(chatMessages)) {
                    for (let i = 0; i < messages.length; i++) {
                        const message = messages[i];
                        
                        // ç”Ÿæˆå”¯ä¸€çš„ä¸»é”®
                        let uniqueId = `${characterId}_${globalSequentialId++}`;
                        
                        // ç¡®ä¿IDç»å¯¹å”¯ä¸€
                        while (usedIds.has(uniqueId)) {
                            uniqueId = `${characterId}_${globalSequentialId++}`;
                        }
                        usedIds.add(uniqueId);
                        
                        messageArray.push({
                            id: uniqueId,
                            characterId: characterId,
                            timestamp: message.timestamp,
                            messageOrder: i,
                            originalMessageId: message.id, // ä¿ç•™åŸå§‹æ¶ˆæ¯IDä½œä¸ºæ•°æ®
                            messageData: message
                        });
                    }
                }
                
                // ğŸ”¥ã€ä¿®å¤åˆ é™¤é—®é¢˜ã€‘ä½¿ç”¨äº‹åŠ¡ç¡®ä¿åŸå­æ“ä½œï¼Œæ”¯æŒæ¶ˆæ¯åˆ é™¤
                if (messageArray.length === 0) {
                    console.warn('âš ï¸ æ¶ˆæ¯æ•°æ®ä¸ºç©ºï¼Œæ¸…ç©ºæ•°æ®åº“');
                    // å¦‚æœæ²¡æœ‰æ¶ˆæ¯ï¼Œæ¸…ç©ºæ•°æ®åº“
                    await db.transaction('rw', db.chatMessages, async () => {
                        await db.chatMessages.clear();
                    });
                    return;
                }

                // ğŸ”¥ã€ä¿®å¤åˆ é™¤é—®é¢˜ã€‘ä½¿ç”¨äº‹åŠ¡çš„clear+bulkAddï¼Œç¡®ä¿åˆ é™¤çš„æ¶ˆæ¯è¢«æ­£ç¡®ç§»é™¤
                await db.transaction('rw', db.chatMessages, async () => {
                    await db.chatMessages.clear();
                    await db.chatMessages.bulkAdd(messageArray);
                });

                console.log(`âœ… å®‰å…¨ä¿å­˜äº† ${messageArray.length} æ¡æ¶ˆæ¯åˆ°IndexedDBï¼ˆæ”¯æŒåˆ é™¤ï¼‰`);
                

            } catch (error) {
                console.error('ä¿å­˜èŠå¤©æ¶ˆæ¯å¤±è´¥:', error);
                
                // å¦‚æœæ‰¹é‡ä¿å­˜å¤±è´¥ï¼Œä½¿ç”¨ç®€åŒ–çš„é‡è¯•æœºåˆ¶
                try {

                    // ğŸ”¥ã€å®‰å…¨ä¿®å¤ã€‘ä½¿ç”¨äº‹åŠ¡è¿›è¡Œé‡è¯•ä¿å­˜
                    const messageArray = [];
                    let globalSequentialId = 0;
                    let totalMessages = 0;
                    
                    // å…ˆè®¡ç®—æ€»æ¶ˆæ¯æ•°
                    for (const messages of Object.values(chatMessages)) {
                        totalMessages += messages.length;
                    }
                    
                    const maxMessages = 1000;
                    const skipCount = Math.max(0, totalMessages - maxMessages);
                    let currentSkip = 0;
                    
                    for (const [characterId, messages] of Object.entries(chatMessages)) {
                        for (let i = 0; i < messages.length; i++) {
                            if (currentSkip < skipCount) {
                                currentSkip++;
                                continue;
                            }
                            
                            const message = messages[i];
                            messageArray.push({
                                id: `${characterId}_${globalSequentialId++}`,
                                characterId: characterId,
                                timestamp: message.timestamp,
                                messageOrder: i,
                                originalMessageId: message.id,
                                messageData: message
                            });
                        }
                    }
                    
                    // ğŸ”¥ã€ä¿®å¤ã€‘é‡è¯•æ—¶ä¹Ÿä½¿ç”¨äº‹åŠ¡ç¡®ä¿åˆ é™¤æ­£ç¡®å¤„ç†
                    await db.transaction('rw', db.chatMessages, async () => {
                        await db.chatMessages.clear();
                        if (messageArray.length > 0) {
                            await db.chatMessages.bulkAdd(messageArray);
                        }
                    });
                    

                } catch (fallbackError) {
                    console.error('ç®€åŒ–ä¿å­˜ä¹Ÿå¤±è´¥:', fallbackError);
                }
            } finally {
                isSaving = false;
            }
        }
        

        
        // ğŸ”¥ã€é‡æ„ã€‘åŠ è½½èŠå¤©è®¾ç½® - ä¼˜å…ˆä½¿ç”¨IndexedDBï¼Œå‡å°‘localStorageä¾èµ–
        async function loadChatSettings() {
            try {
                // ä¼˜å…ˆä»IndexedDBåŠ è½½
                const savedChatSettings = await db.chatSettings.toArray();

                if (savedChatSettings.length > 0) {
                    // IndexedDBä¸­æœ‰æ•°æ®ï¼Œç›´æ¥ä½¿ç”¨
                    console.log(`âœ… ä»IndexedDBåŠ è½½äº† ${savedChatSettings.length} ä¸ªèŠå¤©è®¾ç½®`);
                    chatSettings = {};
                    savedChatSettings.forEach(item => {
                        chatSettings[item.chatId] = item.settings;
                    });
                    return;
                }

                // IndexedDBä¸­æ²¡æœ‰æ•°æ®ï¼Œå°è¯•ä»localStorageè¿ç§»ï¼ˆä¸€æ¬¡æ€§è¿ç§»ï¼‰
                console.log('ğŸ”„ IndexedDBä¸­æ— æ•°æ®ï¼Œå°è¯•ä»localStorageè¿ç§»...');

                // æ£€æŸ¥æ–°æ ¼å¼çš„localStorageæ•°æ®
                const localStorageData = localStorage.getItem('chatSettings');
                if (localStorageData) {
                    const localSettings = JSON.parse(localStorageData);
                    await migrateChatSettingsToIndexedDB(localSettings);
                    return;
                }

                // æ£€æŸ¥æ—§æ ¼å¼çš„localStorageæ•°æ®ï¼ˆå•ä¸ªè§’è‰²å­˜å‚¨ï¼‰
                const migratedSettings = {};
                let foundOldData = false;

                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('chatSettings_') && !key.includes('emergency')) {
                        try {
                            const chatId = key.replace('chatSettings_', '');
                            const settingData = localStorage.getItem(key);
                            if (settingData) {
                                migratedSettings[chatId] = JSON.parse(settingData);
                                foundOldData = true;
                            }
                        } catch (e) {
                            console.warn(`è·³è¿‡æ— æ•ˆçš„localStorageé”®: ${key}`, e);
                        }
                    }
                }

                if (foundOldData) {
                    console.log('ğŸ”„ å‘ç°æ—§æ ¼å¼æ•°æ®ï¼Œæ­£åœ¨è¿ç§»...');
                    await migrateChatSettingsToIndexedDB(migratedSettings);
                    return;
                }

                // æ²¡æœ‰ä»»ä½•æ•°æ®ï¼Œåˆå§‹åŒ–ä¸ºç©º
                chatSettings = {};
                console.log('ğŸ“ åˆå§‹åŒ–ç©ºçš„èŠå¤©è®¾ç½®');

            } catch (error) {
                console.error('ğŸš¨ åŠ è½½èŠå¤©è®¾ç½®å¤±è´¥:', error);

                // å°è¯•ä»ç´§æ€¥å¤‡ä»½æ¢å¤
                try {
                    const emergencyBackup = localStorage.getItem('chatSettings_emergency_backup');
                    if (emergencyBackup) {
                        chatSettings = JSON.parse(emergencyBackup);
                        console.log('ğŸ†˜ ä»ç´§æ€¥å¤‡ä»½æ¢å¤èŠå¤©è®¾ç½®');
                        showToast('âš ï¸ ä»ç´§æ€¥å¤‡ä»½æ¢å¤è®¾ç½®', 'warning');
                        return;
                    }
                } catch (backupError) {
                    console.error('ç´§æ€¥å¤‡ä»½ä¹Ÿæ— æ³•åŠ è½½:', backupError);
                }

                // æœ€åçš„å›é€€
                chatSettings = {};
                showToast('âŒ è®¾ç½®åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤è®¾ç½®', 'error');
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘è¿ç§»chatSettingsåˆ°IndexedDBçš„è¾…åŠ©å‡½æ•°
        async function migrateChatSettingsToIndexedDB(localSettings) {
            try {
                const settingsArray = Object.keys(localSettings).map(chatId => ({
                    id: chatId,
                    chatId: chatId,
                    settings: localSettings[chatId]
                }));

                if (settingsArray.length > 0) {
                    await db.chatSettings.bulkPut(settingsArray);
                    console.log(`âœ… æˆåŠŸè¿ç§» ${settingsArray.length} ä¸ªèŠå¤©è®¾ç½®åˆ°IndexedDB`);

                    // è¿ç§»æˆåŠŸåæ›´æ–°å†…å­˜
                    chatSettings = localSettings;

                    // å¯é€‰ï¼šæ¸…ç†æ—§çš„localStorageæ•°æ®ï¼ˆè°¨æ…æ“ä½œï¼‰
                    // localStorage.removeItem('chatSettings');
                }
            } catch (error) {
                console.error('ğŸš¨ è¿ç§»èŠå¤©è®¾ç½®åˆ°IndexedDBå¤±è´¥:', error);
                // è¿ç§»å¤±è´¥æ—¶ä»ç„¶ä½¿ç”¨localStorageæ•°æ®
                chatSettings = localSettings;
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘è‡ªåŠ¨ä¿å­˜æœºåˆ¶ - é˜²æ­¢æµè§ˆå™¨å¡é¡¿å¯¼è‡´æ•°æ®ä¸¢å¤±
        let autoSaveTimer = null;
        let pendingSettingsChanges = new Set();

        function scheduleAutoSave(chatId) {
            if (chatId) {
                pendingSettingsChanges.add(chatId);
            }

            // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
            if (autoSaveTimer) {
                clearTimeout(autoSaveTimer);
            }

            // è®¾ç½®æ–°çš„å®šæ—¶å™¨ï¼Œ5ç§’åè‡ªåŠ¨ä¿å­˜
            autoSaveTimer = setTimeout(async () => {
                if (pendingSettingsChanges.size > 0) {
                    console.log(`ğŸ”„ è‡ªåŠ¨ä¿å­˜ ${pendingSettingsChanges.size} ä¸ªèŠå¤©è®¾ç½®...`);
                    try {
                        await saveChatSettings();
                        console.log('âœ… è‡ªåŠ¨ä¿å­˜å®Œæˆ');
                        pendingSettingsChanges.clear();
                    } catch (error) {
                        console.error('ğŸš¨ è‡ªåŠ¨ä¿å­˜å¤±è´¥:', error);
                        // ä¿ç•™å¾…ä¿å­˜çš„è®¾ç½®ï¼Œä¸‹æ¬¡å†è¯•
                    }
                }
                autoSaveTimer = null;
            }, 5000); // 5ç§’å»¶è¿Ÿ
        }

        // ğŸ”¥ã€æ–°å¢ã€‘é¡µé¢å¸è½½å‰å¼ºåˆ¶ä¿å­˜
        window.addEventListener('beforeunload', async (event) => {
            if (pendingSettingsChanges.size > 0) {
                console.log('ğŸ”„ é¡µé¢å¸è½½å‰å¼ºåˆ¶ä¿å­˜è®¾ç½®...');
                try {
                    // åŒæ­¥ä¿å­˜ï¼Œç¡®ä¿åœ¨é¡µé¢å…³é—­å‰å®Œæˆ
                    await saveChatSettings();
                    console.log('âœ… é¡µé¢å¸è½½å‰ä¿å­˜å®Œæˆ');
                } catch (error) {
                    console.error('ğŸš¨ é¡µé¢å¸è½½å‰ä¿å­˜å¤±è´¥:', error);
                }
            }
        });

        // ğŸ”¥ã€æ–°å¢ã€‘é¡µé¢å¯è§æ€§å˜åŒ–æ—¶ä¿å­˜
        document.addEventListener('visibilitychange', async () => {
            if (document.hidden && pendingSettingsChanges.size > 0) {
                console.log('ğŸ”„ é¡µé¢éšè—æ—¶ä¿å­˜è®¾ç½®...');
                try {
                    await saveChatSettings();
                    console.log('âœ… é¡µé¢éšè—æ—¶ä¿å­˜å®Œæˆ');
                    pendingSettingsChanges.clear();
                } catch (error) {
                    console.error('ğŸš¨ é¡µé¢éšè—æ—¶ä¿å­˜å¤±è´¥:', error);
                }
            }
        });

        // ğŸ”¥ã€æ–°å¢ã€‘è°ƒè¯•èŠå¤©è®°å½•æ ¼å¼çš„å·¥å…·å‡½æ•°
        async function debugChatMessagesFormat() {
            try {
                // æ£€æŸ¥å½“å‰æ•°æ®åº“ä¸­çš„èŠå¤©è®°å½•æ ¼å¼
                const dbMessages = await db.chatMessages.toArray();
                console.log('ğŸ“Š æ•°æ®åº“ä¸­çš„èŠå¤©è®°å½•æ ¼å¼åˆ†æ:');
                console.log(`æ€»æ•°: ${dbMessages.length} æ¡`);

                if (dbMessages.length > 0) {
                    const sample = dbMessages[0];
                    console.log('æ ·æœ¬è®°å½•ç»“æ„:', Object.keys(sample));
                    console.log('æ ·æœ¬è®°å½•:', sample);

                    const hasMessageData = dbMessages.some(msg => msg.messageData);
                    const hasDirectContent = dbMessages.some(msg => msg.content);

                    console.log(`åŒ…å«messageDataå­—æ®µ: ${hasMessageData}`);
                    console.log(`åŒ…å«ç›´æ¥contentå­—æ®µ: ${hasDirectContent}`);
                }

                // æ£€æŸ¥å†…å­˜ä¸­çš„èŠå¤©è®°å½•æ ¼å¼
                console.log('ğŸ“Š å†…å­˜ä¸­çš„èŠå¤©è®°å½•æ ¼å¼åˆ†æ:');
                const memoryMessageCount = Object.values(chatMessages).reduce((total, msgs) => total + msgs.length, 0);
                console.log(`æ€»æ•°: ${memoryMessageCount} æ¡`);

                if (memoryMessageCount > 0) {
                    const firstCharacter = Object.keys(chatMessages)[0];
                    const firstMessage = chatMessages[firstCharacter]?.[0];
                    if (firstMessage) {
                        console.log('å†…å­˜æ ·æœ¬è®°å½•ç»“æ„:', Object.keys(firstMessage));
                        console.log('å†…å­˜æ ·æœ¬è®°å½•:', firstMessage);
                    }
                }

                showToast('ğŸ“Š èŠå¤©è®°å½•æ ¼å¼åˆ†æå®Œæˆï¼Œè¯·æŸ¥çœ‹æ§åˆ¶å°', 'info');
            } catch (error) {
                console.error('è°ƒè¯•èŠå¤©è®°å½•æ ¼å¼å¤±è´¥:', error);
                showToast('è°ƒè¯•å¤±è´¥: ' + error.message, 'error');
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ¸…ç†localStorageä¸­çš„æ—§chatSettingsæ•°æ®
        async function cleanupOldChatSettingsFromLocalStorage() {
            try {
                let cleanedCount = 0;
                const keysToRemove = [];

                // æ”¶é›†æ‰€æœ‰chatSettingsç›¸å…³çš„localStorageé”®
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && (key === 'chatSettings' || key.startsWith('chatSettings_')) && !key.includes('emergency')) {
                        keysToRemove.push(key);
                    }
                }

                // ç¡®è®¤IndexedDBä¸­æœ‰æ•°æ®åå†æ¸…ç†
                const indexedDBSettings = await db.chatSettings.toArray();
                if (indexedDBSettings.length > 0 && keysToRemove.length > 0) {
                    const confirmCleanup = confirm(
                        `æ£€æµ‹åˆ° ${keysToRemove.length} ä¸ªæ—§çš„localStorageèŠå¤©è®¾ç½®æ•°æ®ã€‚\n\n` +
                        `IndexedDBä¸­å·²æœ‰ ${indexedDBSettings.length} ä¸ªè®¾ç½®ï¼Œå¯ä»¥å®‰å…¨æ¸…ç†localStorageæ•°æ®ã€‚\n\n` +
                        `æ˜¯å¦æ¸…ç†ä»¥é‡Šæ”¾å­˜å‚¨ç©ºé—´ï¼Ÿ`
                    );

                    if (confirmCleanup) {
                        keysToRemove.forEach(key => {
                            localStorage.removeItem(key);
                            cleanedCount++;
                        });

                        console.log(`âœ… å·²æ¸…ç† ${cleanedCount} ä¸ªæ—§çš„localStorageèŠå¤©è®¾ç½®`);
                        showToast(`ğŸ§¹ å·²æ¸…ç† ${cleanedCount} ä¸ªæ—§è®¾ç½®æ•°æ®`, 'success');
                    }
                }
            } catch (error) {
                console.error('æ¸…ç†æ—§chatSettingsæ•°æ®å¤±è´¥:', error);
            }
        }
        
        // ğŸ”¥ã€é‡æ„ã€‘ä¿å­˜èŠå¤©è®¾ç½® - å®Œå…¨ä¾èµ–IndexedDBï¼Œé¿å…æ•°æ®ä¸¢å¤±
        async function saveChatSettings() {
            try {
                // å°†chatSettingså¯¹è±¡è½¬æ¢ä¸ºæ•°ç»„æ ¼å¼å­˜å‚¨åˆ°IndexedDB
                const chatSettingsArray = Object.keys(chatSettings).map(chatId => ({
                    id: chatId,
                    chatId: chatId,
                    settings: chatSettings[chatId]
                }));

                if (chatSettingsArray.length === 0) {
                    console.warn('âš ï¸ èŠå¤©è®¾ç½®æ•°æ®ä¸ºç©ºï¼Œè·³è¿‡ä¿å­˜æ“ä½œ');
                    return;
                }

                // ğŸ”¥ã€å®‰å…¨ä¿®å¤ã€‘ä½¿ç”¨bulkPutä»£æ›¿clear+bulkAddï¼Œé¿å…æ•°æ®ä¸¢å¤±
                await db.chatSettings.bulkPut(chatSettingsArray);

                console.log(`âœ… å®‰å…¨ä¿å­˜äº† ${chatSettingsArray.length} ä¸ªèŠå¤©è®¾ç½®åˆ°IndexedDB`);

            } catch (error) {
                console.error('ğŸš¨ ä¿å­˜èŠå¤©è®¾ç½®åˆ°IndexedDBå¤±è´¥:', error);

                // ğŸ”¥ã€ç´§æ€¥å¤‡ä»½ã€‘åªåœ¨IndexedDBå®Œå…¨å¤±è´¥æ—¶æ‰ä½¿ç”¨localStorage
                try {
                    console.warn('âš ï¸ æ­£åœ¨è¿›è¡Œç´§æ€¥å¤‡ä»½åˆ°localStorage...');
                    const emergencyBackup = {};
                    Object.keys(chatSettings).forEach(chatId => {
                        // åªä¿å­˜æœ€å…³é”®çš„è®¾ç½®ï¼Œé¿å…localStorageå®¹é‡é—®é¢˜
                        emergencyBackup[chatId] = {
                            bubbleStyle: chatSettings[chatId].bubbleStyle,
                            aiChatAvatar: chatSettings[chatId].aiChatAvatar,
                            myChatAvatar: chatSettings[chatId].myChatAvatar,
                            aiChatNickname: chatSettings[chatId].aiChatNickname,
                            myChatNickname: chatSettings[chatId].myChatNickname,
                            hideAvatars: chatSettings[chatId].hideAvatars,
                            selectedIdentityId: chatSettings[chatId].selectedIdentityId,
                            timestampEnabled: chatSettings[chatId].timestampEnabled,
                            timestampPosition: chatSettings[chatId].timestampPosition
                        };
                    });

                    localStorage.setItem('chatSettings_emergency_backup', JSON.stringify(emergencyBackup));
                    console.log('âœ… ç´§æ€¥å¤‡ä»½å·²ä¿å­˜åˆ°localStorage');

                    // æ˜¾ç¤ºç”¨æˆ·å‹å¥½çš„é”™è¯¯æç¤º
                    showToast('âš ï¸ æ•°æ®åº“ä¿å­˜å¤±è´¥ï¼Œå·²å¯ç”¨ç´§æ€¥å¤‡ä»½æ¨¡å¼', 'warning');

                } catch (localStorageError) {
                    console.error('ğŸš¨ ç´§æ€¥å¤‡ä»½ä¹Ÿå¤±è´¥äº†:', localStorageError);
                    showToast('âŒ è®¾ç½®ä¿å­˜å¤±è´¥ï¼è¯·æ£€æŸ¥å­˜å‚¨ç©ºé—´', 'error');
                    throw localStorageError;
                }
            }
        }
        
        // === åå°äº’åŠ¨ç³»ç»Ÿ ===
        let backgroundTimers = {};

        // ğŸ”¥ã€æ–°å¢ã€‘å…¨å±€åå°äº’åŠ¨ç³»ç»Ÿåˆå§‹åŒ– - ä¸ºæ‰€æœ‰è§’è‰²è®¾ç½®å®šæ—¶å™¨
        async function initGlobalBackgroundInteractionSystem() {
            console.log('ğŸš€ å¯åŠ¨å…¨å±€åå°äº’åŠ¨ç³»ç»Ÿ...');

            // ğŸ”¥ã€ä¿®å¤ã€‘ä¸è¦æ¸…é™¤ç°æœ‰å®šæ—¶å™¨ï¼Œé¿å…ä¸å…¨å±€åŠ¨æ€å‘å¸ƒç³»ç»Ÿå†²çª
            // clearAllBackgroundTimers();

            // ä¸ºæ¯ä¸ªè§’è‰²è®¾ç½®åå°äº’åŠ¨å®šæ—¶å™¨
            for (const character of characters) {
                try {
                    const chatSettings = await getChatSettings(character.id);

                    // ğŸ”¥ã€ä¿®å¤ã€‘æ­£ç¡®æ£€æŸ¥åå°äº’åŠ¨å¼€å…³çŠ¶æ€
                    const backgroundInteractionEnabled = chatSettings.backgroundInteractionEnabled === true;
                    const backgroundChatEnabled = chatSettings.backgroundChatEnabled === true;
                    const backgroundMomentsEnabled = chatSettings.backgroundMomentsEnabled === true;

                    if (!backgroundInteractionEnabled) {
                        console.log(`è§’è‰² ${character.name} çš„åå°äº’åŠ¨å·²ç¦ç”¨ï¼Œè·³è¿‡`);
                        continue;
                    }

                    console.log(`ä¸ºè§’è‰² ${character.name} è®¾ç½®åå°äº’åŠ¨å®šæ—¶å™¨`);

                    // è®¾ç½®ä¸»åŠ¨èŠå¤©å®šæ—¶å™¨ - éœ€è¦åŒæ—¶æ£€æŸ¥æ€»å¼€å…³å’Œå­å¼€å…³
                    if (backgroundInteractionEnabled && backgroundChatEnabled) {
                        // ğŸ”¥ã€ä¿®å¤ã€‘æ£€æŸ¥æ˜¯å¦æœ‰èŠå¤©è®°å½•ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä¸è®¾ç½®å®šæ—¶å™¨
                        const messages = chatMessages[character.id] || [];
                        const hasUserMessages = messages.some(msg => msg.sender === 'sent');

                        if (hasUserMessages) {
                            scheduleProactiveChatForCharacter(character.id);
                            console.log(`${character.name} åŠ¨æ€ä¸»åŠ¨èŠå¤©å®šæ—¶å™¨å·²è®¾ç½®`);
                        } else {
                            console.log(`${character.name} æ²¡æœ‰ç”¨æˆ·æ¶ˆæ¯è®°å½•ï¼Œæš‚ä¸è®¾ç½®ä¸»åŠ¨èŠå¤©å®šæ—¶å™¨`);
                        }
                    }

                    // è®¾ç½®ä¸»åŠ¨å‘åŠ¨æ€å®šæ—¶å™¨ - éœ€è¦åŒæ—¶æ£€æŸ¥æ€»å¼€å…³å’Œå­å¼€å…³
                    if (backgroundInteractionEnabled && backgroundMomentsEnabled) {
                        const momentsInterval = getBackgroundMomentsInterval(chatSettings.backgroundMomentsFrequency || 'low');
                        backgroundTimers[character.id + '_moments'] = setInterval(() => {
                            triggerBackgroundMoments(character.id);
                        }, momentsInterval);
                        console.log(`${character.name} ä¸»åŠ¨å‘åŠ¨æ€å®šæ—¶å™¨å·²è®¾ç½®ï¼Œé—´éš”: ${momentsInterval}ms`);
                    }
                } catch (error) {
                    console.error(`ä¸ºè§’è‰² ${character.name} è®¾ç½®åå°äº’åŠ¨å®šæ—¶å™¨å¤±è´¥:`, error);
                }
            }
        }

        // åˆå§‹åŒ–åå°äº’åŠ¨ç³»ç»Ÿï¼ˆå•ä¸ªè§’è‰²ï¼‰
        function initBackgroundInteractionSystem() {
            if (!currentChatCharacter) return;

            // ğŸ”¥ã€ä¿®å¤ã€‘åªæ¸…é™¤å½“å‰è§’è‰²çš„å®šæ—¶å™¨ï¼Œä¸å½±å“å…¶ä»–è§’è‰²
            const characterId = currentChatCharacter.id;
            if (backgroundTimers[characterId + '_chat']) {
                clearInterval(backgroundTimers[characterId + '_chat']);
                delete backgroundTimers[characterId + '_chat'];
            }
            if (backgroundTimers[characterId + '_moments']) {
                clearInterval(backgroundTimers[characterId + '_moments']);
                delete backgroundTimers[characterId + '_moments'];
            }

            const chatSettings = getCurrentChatSettings();

            // ğŸ”¥ã€ä¿®å¤ã€‘æ­£ç¡®æ£€æŸ¥åå°äº’åŠ¨å¼€å…³çŠ¶æ€
            const backgroundInteractionEnabled = chatSettings.backgroundInteractionEnabled === true;
            const backgroundChatEnabled = chatSettings.backgroundChatEnabled === true;
            const backgroundMomentsEnabled = chatSettings.backgroundMomentsEnabled === true;

            if (!backgroundInteractionEnabled) {
                console.log(`è§’è‰² ${currentChatCharacter.name} çš„åå°äº’åŠ¨å·²ç¦ç”¨`);
                return;
            }

            // è®¾ç½®ä¸»åŠ¨èŠå¤©å®šæ—¶å™¨ - éœ€è¦åŒæ—¶æ£€æŸ¥æ€»å¼€å…³å’Œå­å¼€å…³
            if (backgroundInteractionEnabled && backgroundChatEnabled) {
                // ğŸ”¥ã€ä¿®å¤ã€‘æ£€æŸ¥æ˜¯å¦æœ‰èŠå¤©è®°å½•ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä¸è®¾ç½®å®šæ—¶å™¨
                const messages = chatMessages[characterId] || [];
                const hasUserMessages = messages.some(msg => msg.sender === 'sent');

                if (hasUserMessages) {
                    scheduleProactiveChatForCharacter(characterId);
                    console.log(`${currentChatCharacter.name} åŠ¨æ€ä¸»åŠ¨èŠå¤©å®šæ—¶å™¨å·²è®¾ç½®`);
                } else {
                    console.log(`${currentChatCharacter.name} æ²¡æœ‰ç”¨æˆ·æ¶ˆæ¯è®°å½•ï¼Œæš‚ä¸è®¾ç½®ä¸»åŠ¨èŠå¤©å®šæ—¶å™¨`);
                }
            }

            // è®¾ç½®ä¸»åŠ¨å‘åŠ¨æ€å®šæ—¶å™¨ - éœ€è¦åŒæ—¶æ£€æŸ¥æ€»å¼€å…³å’Œå­å¼€å…³
            if (backgroundInteractionEnabled && backgroundMomentsEnabled) {
                const momentsInterval = getBackgroundMomentsInterval(chatSettings.backgroundMomentsFrequency || 'low');
                backgroundTimers[characterId + '_moments'] = setInterval(() => {
                    triggerBackgroundMoments(characterId);
                }, momentsInterval);
                console.log(`${currentChatCharacter.name} ä¸»åŠ¨å‘åŠ¨æ€å®šæ—¶å™¨å·²è®¾ç½®ï¼Œé—´éš”: ${momentsInterval}ms`);
            }
        }

        // æ¸…é™¤æ‰€æœ‰åå°å®šæ—¶å™¨
        function clearAllBackgroundTimers() {
            Object.values(backgroundTimers).forEach(timer => {
                if (timer) clearInterval(timer);
            });
            backgroundTimers = {};
        }

        // å…¨å±€å®šæ—¶å‘å¸ƒç³»ç»Ÿ
        let globalMomentsTimers = {};
        let globalMomentsCheckInterval = null;

        // åˆå§‹åŒ–å…¨å±€åŠ¨æ€å‘å¸ƒç³»ç»Ÿ
        async function initGlobalMomentsSystem() {
            console.log('ğŸš€ åˆå§‹åŒ–å…¨å±€åŠ¨æ€å‘å¸ƒç³»ç»Ÿ');
            
            // æ¸…é™¤ç°æœ‰çš„å®šæ—¶å™¨
            clearGlobalMomentsTimers();
            
            // ä¸ºæ‰€æœ‰è§’è‰²è®¾ç½®åå°å‘å¸ƒå®šæ—¶å™¨
            let activeCount = 0;
            if (characters && characters.length > 0) {
                for (const character of characters) {
                    const chatSettings = await getChatSettings(character.id);
                    
                    // ğŸ”¥ã€ä¿®å¤ã€‘æ£€æŸ¥æ˜¯å¦å¯ç”¨äº†åå°å‘åŠ¨æ€ï¼Œéœ€è¦åŒæ—¶æ£€æŸ¥æ€»å¼€å…³å’Œå­å¼€å…³
                    if (chatSettings.backgroundInteractionEnabled === true && chatSettings.backgroundMomentsEnabled === true) {
                        const frequency = chatSettings.backgroundMomentsFrequency || 'low';
                        const interval = getBackgroundMomentsInterval(frequency);
                        
                        globalMomentsTimers[character.id] = setInterval(async () => {
                            console.log(`â° å®šæ—¶å™¨è§¦å‘ï¼š${character.name} å‡†å¤‡å‘å¸ƒåŠ¨æ€`);
                            await triggerBackgroundMoments(character.id);
                        }, interval);
                        
                        activeCount++;
                        console.log(`âœ… ä¸ºè§’è‰² ${character.name} è®¾ç½®äº†åå°å‘åŠ¨æ€å®šæ—¶å™¨ï¼Œé—´éš”: ${Math.round(interval/1000/60)}åˆ†é’Ÿ`);
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰å®šæ—¶å‘å¸ƒæ—¶é—´ç‚¹
                    if (chatSettings.scheduledMomentsEnabled && chatSettings.scheduledMomentsTimes && chatSettings.scheduledMomentsTimes.length > 0) {
                        console.log(`â° è§’è‰² ${character.name} å¯ç”¨äº†å®šæ—¶å‘å¸ƒï¼Œæ—¶é—´ç‚¹:`, chatSettings.scheduledMomentsTimes);
                    }
                }
            }
            
            // å¯åŠ¨å®šæ—¶æ£€æŸ¥å™¨ï¼ˆæ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡æ˜¯å¦åˆ°äº†å‘å¸ƒæ—¶é—´ï¼‰
            if (!globalMomentsCheckInterval) {
                globalMomentsCheckInterval = setInterval(async () => {
                    await checkScheduledMomentsTime();
                }, 60000); // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
                
                console.log('â° å¯åŠ¨äº†å®šæ—¶å‘å¸ƒæ—¶é—´æ£€æŸ¥å™¨');
            }
            
            console.log(`ğŸ‰ å…¨å±€åŠ¨æ€å‘å¸ƒç³»ç»Ÿåˆå§‹åŒ–å®Œæˆï¼Œæ¿€æ´»äº† ${activeCount} ä¸ªè§’è‰²çš„åå°å‘å¸ƒ`);
        }

        // æ£€æŸ¥å®šæ—¶å‘å¸ƒæ—¶é—´
        async function checkScheduledMomentsTime() {
            const now = new Date();
            const currentTime = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
            
            if (characters && characters.length > 0) {
                for (const character of characters) {
                    const chatSettings = await getChatSettings(character.id);
                    
                    if (chatSettings.scheduledMomentsEnabled && 
                        chatSettings.scheduledMomentsTimes && 
                        chatSettings.scheduledMomentsTimes.includes(currentTime)) {
                        
                        console.log(`â° å®šæ—¶å‘å¸ƒæ—¶é—´åˆ°ï¼š${character.name} åœ¨ ${currentTime} å‘å¸ƒåŠ¨æ€`);
                        await triggerBackgroundMoments(character.id, true); // è·³è¿‡å†·å´æ—¶é—´
                    }
                }
            }
        }

        // æ¸…é™¤å…¨å±€åŠ¨æ€å®šæ—¶å™¨
        function clearGlobalMomentsTimers() {
            Object.values(globalMomentsTimers).forEach(timer => {
                if (timer) clearInterval(timer);
            });
            globalMomentsTimers = {};
            
            if (globalMomentsCheckInterval) {
                clearInterval(globalMomentsCheckInterval);
                globalMomentsCheckInterval = null;
            }
        }

        // ğŸ”¥ã€ä¿®å¤ã€‘è·å–åå°èŠå¤©é—´éš”æ—¶é—´ - æ”¹ä¸ºéšæœºé—´éš”ï¼Œç¬¦åˆç”¨æˆ·éœ€æ±‚
        function getBackgroundInterval(frequency) {
            switch (frequency) {
                case 'low':
                    // 1-2å°æ—¶éšæœºé—´éš”
                    return Math.random() * 60 * 60 * 1000 + 60 * 60 * 1000;
                case 'medium':
                    // 30-60åˆ†é’Ÿéšæœºé—´éš”
                    return Math.random() * 30 * 60 * 1000 + 30 * 60 * 1000;
                case 'high':
                    // 10-30åˆ†é’Ÿéšæœºé—´éš”
                    return Math.random() * 20 * 60 * 1000 + 10 * 60 * 1000;
                default:
                    // é»˜è®¤1-2å°æ—¶
                    return Math.random() * 60 * 60 * 1000 + 60 * 60 * 1000;
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘ä¸ºè§’è‰²è®¾ç½®åŠ¨æ€ä¸»åŠ¨èŠå¤©å®šæ—¶å™¨
        function scheduleProactiveChatForCharacter(characterId) {
            // æ¸…é™¤ç°æœ‰å®šæ—¶å™¨
            if (backgroundTimers[characterId + '_chat']) {
                clearTimeout(backgroundTimers[characterId + '_chat']);
                delete backgroundTimers[characterId + '_chat'];
            }

            // æ£€æŸ¥ç”¨æˆ·æœ€åå›å¤æ—¶é—´
            const messages = chatMessages[characterId] || [];
            const lastUserMessage = messages.slice().reverse().find(msg => msg.sender === 'sent');

            if (!lastUserMessage) return; // æ²¡æœ‰ç”¨æˆ·æ¶ˆæ¯ï¼Œä¸è®¾ç½®å®šæ—¶å™¨

            const timeSinceLastUserMessage = Date.now() - lastUserMessage.timestamp;
            const tenMinutes = 10 * 60 * 1000; // 10åˆ†é’Ÿ

            let delay;
            if (timeSinceLastUserMessage < tenMinutes) {
                // ç”¨æˆ·æœ€è¿‘æœ‰å›å¤ï¼Œç­‰å¾…10åˆ†é’Ÿåå†å¼€å§‹è®¡æ—¶
                delay = tenMinutes - timeSinceLastUserMessage;
                console.log(`${characters.find(c => c.id === characterId)?.name} å°†åœ¨${Math.round(delay / 60000)}åˆ†é’Ÿåå¼€å§‹ä¸»åŠ¨èŠå¤©è®¡æ—¶`);
            } else {
                // ç”¨æˆ·å·²ç»è¶…è¿‡10åˆ†é’Ÿæ²¡å›å¤ï¼Œç«‹å³å¼€å§‹éšæœºè®¡æ—¶
                delay = 0;
                console.log(`${characters.find(c => c.id === characterId)?.name} ç«‹å³å¼€å§‹ä¸»åŠ¨èŠå¤©è®¡æ—¶`);
            }

            // è®¾ç½®å®šæ—¶å™¨
            backgroundTimers[characterId + '_chat'] = setTimeout(async () => {
                // 10åˆ†é’Ÿç­‰å¾…æœŸç»“æŸï¼Œç°åœ¨å¼€å§‹éšæœºé—´éš”è®¡æ—¶
                const character = characters.find(c => c.id === characterId);
                if (!character) return;

                const chatSettings = await getAsyncChatSettings(characterId);
                const randomInterval = getBackgroundInterval(chatSettings.backgroundChatFrequency || 'low');

                console.log(`${character.name} å°†åœ¨${Math.round(randomInterval / 60000)}åˆ†é’Ÿåå‘é€ä¸»åŠ¨æ¶ˆæ¯`);

                // è®¾ç½®å®é™…çš„ä¸»åŠ¨èŠå¤©å®šæ—¶å™¨
                backgroundTimers[characterId + '_chat'] = setTimeout(() => {
                    triggerBackgroundChat(characterId);
                    // å‘é€å®Œæ¶ˆæ¯åï¼Œé‡æ–°å®‰æ’ä¸‹æ¬¡çš„ä¸»åŠ¨èŠå¤©
                    scheduleProactiveChatForCharacter(characterId);
                }, randomInterval);
            }, delay);
        }

        // ğŸ”¥ã€æ–°å¢ã€‘å½“ç”¨æˆ·å‘é€æ¶ˆæ¯æ—¶ï¼Œé‡æ–°å®‰æ’ä¸»åŠ¨èŠå¤©å®šæ—¶å™¨
        function onUserMessageSent(characterId) {
            const character = characters.find(c => c.id === characterId);
            console.log(`ç”¨æˆ·å‘ ${character?.name} å‘é€äº†æ¶ˆæ¯ï¼Œé‡æ–°å®‰æ’ä¸»åŠ¨èŠå¤©å®šæ—¶å™¨`);
            // é‡æ–°å®‰æ’è¯¥è§’è‰²çš„ä¸»åŠ¨èŠå¤©å®šæ—¶å™¨
            scheduleProactiveChatForCharacter(characterId);
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ‰‹åŠ¨é‡æ–°åˆå§‹åŒ–æ‰€æœ‰è§’è‰²çš„ä¸»åŠ¨èŠå¤©å®šæ—¶å™¨
        async function reinitializeProactiveChatTimers() {
            console.log('ğŸ”„ é‡æ–°åˆå§‹åŒ–æ‰€æœ‰è§’è‰²çš„ä¸»åŠ¨èŠå¤©å®šæ—¶å™¨...');

            for (const character of characters) {
                try {
                    const chatSettings = await getChatSettings(character.id);
                    const backgroundInteractionEnabled = chatSettings.backgroundInteractionEnabled === true;
                    const backgroundChatEnabled = chatSettings.backgroundChatEnabled === true;

                    if (backgroundInteractionEnabled && backgroundChatEnabled) {
                        const messages = chatMessages[character.id] || [];
                        const hasUserMessages = messages.some(msg => msg.sender === 'sent');

                        if (hasUserMessages) {
                            scheduleProactiveChatForCharacter(character.id);
                            console.log(`âœ… ${character.name} ä¸»åŠ¨èŠå¤©å®šæ—¶å™¨å·²é‡æ–°è®¾ç½®`);
                        } else {
                            console.log(`â¸ï¸ ${character.name} æ²¡æœ‰ç”¨æˆ·æ¶ˆæ¯è®°å½•ï¼Œè·³è¿‡å®šæ—¶å™¨è®¾ç½®`);
                        }
                    } else {
                        console.log(`ğŸš« ${character.name} ä¸»åŠ¨èŠå¤©åŠŸèƒ½å·²ç¦ç”¨`);
                    }
                } catch (error) {
                    console.error(`âŒ ä¸º ${character.name} è®¾ç½®ä¸»åŠ¨èŠå¤©å®šæ—¶å™¨å¤±è´¥:`, error);
                }
            }

            console.log('ğŸ‰ ä¸»åŠ¨èŠå¤©å®šæ—¶å™¨é‡æ–°åˆå§‹åŒ–å®Œæˆ');
        }

        // è·å–åå°åŠ¨æ€é—´éš”æ—¶é—´
        function getBackgroundMomentsInterval(frequency) {
            switch (frequency) {
                case 'low':
                    return Math.random() * 4 * 60 * 60 * 1000 + 4 * 60 * 60 * 1000; // 4-8å°æ—¶
                case 'medium':
                    return Math.random() * 2 * 60 * 60 * 1000 + 2 * 60 * 60 * 1000; // 2-4å°æ—¶
                case 'high':
                    return Math.random() * 60 * 60 * 1000 + 60 * 60 * 1000; // 1-2å°æ—¶
                default:
                    return Math.random() * 4 * 60 * 60 * 1000 + 4 * 60 * 60 * 1000; // é»˜è®¤4-8å°æ—¶
            }
        }

        // è§¦å‘åå°èŠå¤©
        async function triggerBackgroundChat(characterId, skipTimeCheck = false) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;

                // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦è‡³å°‘10åˆ†é’Ÿæ²¡æœ‰å›å¤ï¼ˆæµ‹è¯•æ—¶å¯è·³è¿‡ï¼‰
                if (!skipTimeCheck) {
                    const messages = chatMessages[characterId] || [];
                    const lastUserMessage = messages.slice().reverse().find(msg => msg.sender === 'sent');

                    if (lastUserMessage) {
                        const timeSinceLastUserMessage = Date.now() - lastUserMessage.timestamp;
                        const tenMinutes = 10 * 60 * 1000; // 10åˆ†é’Ÿ
                        if (timeSinceLastUserMessage < tenMinutes) {
                            console.log(`${character.name} è·³è¿‡ä¸»åŠ¨èŠå¤©ï¼šç”¨æˆ·æœ€è¿‘${Math.round(timeSinceLastUserMessage / 60000)}åˆ†é’Ÿå‰æœ‰å›å¤`);
                            return; // ç”¨æˆ·æœ€è¿‘æœ‰æ´»åŠ¨ï¼Œä¸å‘é€è‡ªåŠ¨æ¶ˆæ¯
                        }

                        // ğŸ”¥ã€æ–°å¢ã€‘æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨ç­‰å¾…æœŸå†…å‘é€è¿‡ä¸»åŠ¨æ¶ˆæ¯
                        const lastAIMessage = messages.slice().reverse().find(msg => msg.sender === 'received');
                        if (lastAIMessage && lastAIMessage.isProactive) {
                            // å¦‚æœæœ€åä¸€æ¡AIæ¶ˆæ¯æ˜¯ä¸»åŠ¨æ¶ˆæ¯ï¼Œæ£€æŸ¥æ˜¯å¦åœ¨åˆç†çš„æ—¶é—´é—´éš”å†…
                            const timeSinceLastProactive = Date.now() - lastAIMessage.timestamp;
                            const chatSettings = await getAsyncChatSettings(characterId);
                            const minInterval = getBackgroundInterval(chatSettings.backgroundChatFrequency || 'low');

                            if (timeSinceLastProactive < minInterval) {
                                console.log(`${character.name} è·³è¿‡ä¸»åŠ¨èŠå¤©ï¼šè·ç¦»ä¸Šæ¬¡ä¸»åŠ¨æ¶ˆæ¯ä»…${Math.round(timeSinceLastProactive / 60000)}åˆ†é’Ÿ`);
                                return;
                            }
                        }
                    }
                } else {
                    console.log(`${character.name} æµ‹è¯•æ¨¡å¼ï¼šè·³è¿‡10åˆ†é’Ÿæ—¶é—´æ£€æŸ¥`);
                }
                
                // ğŸ”¥ã€ä¿®å¤ã€‘è·å–è¯¥è§’è‰²çš„èŠå¤©è®¾ç½®ï¼Œè€Œä¸æ˜¯å½“å‰èŠå¤©è®¾ç½®
                const chatSettings = await getAsyncChatSettings(characterId);

                // ğŸ”¥ã€ä¿®å¤ã€‘ä½¿ç”¨ç”¨æˆ·è®¾ç½®çš„å†å²æ¶ˆæ¯å›åˆæ•°å’Œè·¨çª—å£è®°å¿†æ•°
                const historyCount = chatSettings.historyCount || 5;
                const crossWindowMemory = chatSettings.crossWindowMemory || 3;

                // ğŸ”¥ã€ä¿®å¤ã€‘è·å–èŠå¤©æ¶ˆæ¯ï¼ˆæˆ‘ä¹‹å‰ä¸å°å¿ƒåˆ é™¤äº†è¿™è¡Œï¼‰
                const messages = chatMessages[characterId] || [];

                // è·å–æœ€è¿‘çš„èŠå¤©å†å²ï¼ˆä½¿ç”¨å†å²æ¶ˆæ¯å›åˆæ•°è®¾ç½®ï¼‰
                const recentMessages = messages.slice(-historyCount);

                // ğŸ”¥ã€ä¿®å¤ã€‘è·å–è·¨çª—å£è®°å¿†æ•°é‡çš„æœ€è¿‘åŠ¨æ€å†…å®¹
                const recentMoments = await getRecentMoments(crossWindowMemory);
                let momentsContext = '';
                if (recentMoments.length > 0) {
                    momentsContext = '\n\næœ€è¿‘çš„åŠ¨æ€å†…å®¹ï¼š\n' +
                        recentMoments.map(moment => `${moment.nickname}: ${moment.text}`).join('\n');
                }
                
                // æ„å»ºèŠå¤©å†å²ä¸Šä¸‹æ–‡
                let chatContext = '';
                if (recentMessages.length > 0) {
                    chatContext = '\n\næœ€è¿‘çš„èŠå¤©è®°å½•ï¼š\n' +
                        recentMessages.map(msg => {
                            if (msg.sender === 'sent') return `ç”¨æˆ·ï¼š${msg.content}`;
                            if (msg.sender === 'received') return `${character.name}ï¼š${msg.content}`;
                            return '';
                        }).filter(Boolean).join('\n');
                }
                
                // ğŸ”¥ã€ä¿®å¤ã€‘è·å–ä¸–ç•Œä¹¦ä¿¡æ¯
                let worldbookContext = '';
                if (character.worldbook && character.worldbook.length > 0) {
                    worldbookContext = '\n\nä¸–ç•Œä¹¦ä¿¡æ¯ï¼š\n' +
                        character.worldbook.map(entry => `${entry.key}: ${entry.value}`).join('\n');
                }

                // ğŸ”¥ã€ä¿®å¤ã€‘ç”Ÿæˆæ›´å®Œæ•´çš„ä¸»åŠ¨èŠå¤©å†…å®¹ï¼ŒåŒ…å«äººè®¾ã€ä¸–ç•Œä¹¦ã€å†å²æ¶ˆæ¯ã€åŠ¨æ€ç­‰
                const prompt = `ä½ æ˜¯${character.name}ï¼Œä½ çš„äººè®¾å¦‚ä¸‹ï¼š${character.bio}${worldbookContext}

ç°åœ¨ä½ è¦ä¸»åŠ¨ç»™ç”¨æˆ·å‘é€ä¸€æ¡æ¶ˆæ¯ã€‚è¿™æ¡æ¶ˆæ¯åº”è¯¥æ˜¯ï¼š
1. ä¸¥æ ¼ç¬¦åˆä½ çš„äººè®¾å’Œæ€§æ ¼ç‰¹ç‚¹
2. è‡ªç„¶ã€æœ‰è¶£ã€æœ‰äº’åŠ¨æ€§
3. å¯ä»¥æ˜¯é—®å€™ã€åˆ†äº«ã€è¯¢é—®ã€å…³å¿ƒç­‰
4. ä¸è¦è¿‡äºæ­£å¼ï¼Œè¦åƒæœ‹å‹é—´çš„æ—¥å¸¸èŠå¤©
5. å¦‚æœæœ‰èŠå¤©å†å²ï¼Œè¦åŸºäºå†å²å†…å®¹è¿›è¡Œè‡ªç„¶çš„å»¶ç»­æˆ–å›åº”
6. å¯ä»¥é€‚å½“æåŠæœ€è¿‘çš„åŠ¨æ€å†…å®¹ï¼Œè®©å¯¹è¯æ›´è‡ªç„¶
7. è€ƒè™‘å½“å‰æ—¶é—´å’Œæƒ…å¢ƒï¼Œè®©æ¶ˆæ¯æ›´è´´åˆå®é™…
8. ä¿æŒè§’è‰²çš„ä¸€è‡´æ€§å’Œè¿è´¯æ€§${chatContext}${momentsContext}

è¯·ç”Ÿæˆä¸»åŠ¨èŠå¤©çš„æ¶ˆæ¯ï¼ˆå¯ä»¥æ˜¯1-12æ¡ï¼‰ï¼Œä»¥JSONæ•°ç»„æ ¼å¼è¿”å›ï¼š`;

                const response = await generateAIResponse(prompt, character);
                if (response && response.trim()) {
                    // ğŸ”¥ã€ä¿®å¤ã€‘ä½¿ç”¨ä¸æ­£å¸¸AIå›å¤ç›¸åŒçš„å¤„ç†é€»è¾‘
                    const aiMessages = parseAiResponse(response);

                    if (!chatMessages[characterId]) {
                        chatMessages[characterId] = [];
                    }

                    // ğŸ”¥ã€ä¿®å¤ã€‘ä½¿ç”¨ä¸processAIReplyç›¸åŒçš„æ¶ˆæ¯å¤„ç†é€»è¾‘
                    for (let i = 0; i < aiMessages.length; i++) {
                        const msgData = aiMessages[i];
                        let aiMessage;

                        // ğŸ”¥ã€ä¿®å¤ã€‘è·³è¿‡æ‹‰é»‘æŒ‡ä»¤å¯¹è±¡
                        if (typeof msgData === 'object' && msgData !== null && msgData.type === 'block_user') {
                            console.log('ğŸš« è·³è¿‡æ‹‰é»‘æŒ‡ä»¤å¯¹è±¡ï¼Œä¸æ˜¾ç¤ºä¸ºæ¶ˆæ¯:', msgData);
                            continue;
                        }

                        if (typeof msgData === 'object' && msgData !== null) {
                            if (msgData.type === 'voice_message') {
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    type: 'voice_message',
                                    content: msgData.content,
                                    timestamp: Date.now() + i * 100
                                };
                            } else if (msgData.type === 'ai_image') {
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    type: 'ai_image',
                                    content: msgData.description || 'AIæè¿°çš„å›¾ç‰‡',
                                    imageDescription: msgData.description,
                                    timestamp: Date.now() + i * 100
                                };
                            } else if (msgData.type === 'transfer') {
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    type: 'transfer',
                                    amount: msgData.amount,
                                    note: msgData.note,
                                    timestamp: Date.now() + i * 100
                                };
                            } else if (msgData.type === 'emoji') {
                                const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.description);
                                if (matchingEmoji) {
                                    aiMessage = {
                                        id: (Date.now() + i).toString(),
                                        sender: 'received',
                                        content: '',
                                        image: matchingEmoji.url,
                                        isEmoji: true,
                                        emojiDescription: matchingEmoji.description,
                                        timestamp: Date.now() + i * 100
                                    };

                                    // ğŸ”¥ã€ä¿®å¤ã€‘å¦‚æœæ˜¯ç¾¤èŠæ¶ˆæ¯ï¼Œæ·»åŠ å‘é€è€…ä¿¡æ¯
                                    if (msgData.name) {
                                        aiMessage.name = msgData.name;
                                        // æŸ¥æ‰¾å¯¹åº”çš„ç¾¤æˆå‘˜ID
                                        const group = groupChats.find(g => g.id === characterId);
                                        if (group && group.members) {
                                            const member = group.members.find(m => m.name === msgData.name);
                                            if (member) {
                                                aiMessage.senderId = member.id;
                                            }
                                        }
                                    }

                                    addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                                } else {
                                    aiMessage = {
                                        id: (Date.now() + i).toString(),
                                        sender: 'received',
                                        content: `[è¡¨æƒ…åŒ…"${msgData.description}"ä¸å­˜åœ¨]`,
                                        timestamp: Date.now() + i * 100
                                    };
                                }
                            } else if (msgData.content) {
                                // æ™®é€šå¯¹è±¡æ¶ˆæ¯
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    content: msgData.content,
                                    timestamp: Date.now() + i * 100
                                };
                            } else {
                                console.log('ğŸ”¥ [ä¸»åŠ¨èŠå¤©] ä¸æ”¯æŒçš„æ¶ˆæ¯æ ¼å¼:', msgData);
                                continue;
                            }
                        } else if (typeof msgData === 'string') {
                            // æ™®é€šæ–‡æœ¬æ¶ˆæ¯
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                content: msgData,
                                timestamp: Date.now() + i * 100
                            };
                        } else {
                            console.log('ğŸ”¥ [ä¸»åŠ¨èŠå¤©] æ— æ•ˆçš„æ¶ˆæ¯æ•°æ®:', msgData);
                            continue;
                        }

                        if (aiMessage) {
                            // ğŸ”¥ã€æ–°å¢ã€‘æ ‡è®°ä¸ºä¸»åŠ¨æ¶ˆæ¯
                            aiMessage.isProactive = true;
                            chatMessages[characterId].push(aiMessage);
                        }
                    }

                    saveChatMessages();
                    console.log(`ğŸ”¥ [ä¸»åŠ¨èŠå¤©] ${character.name} å‘é€äº† ${aiMessages.length} æ¡æ¶ˆæ¯`);

                    // ğŸ”¥ã€æ–°å¢ã€‘è®°å½•ä¸»åŠ¨èŠå¤©æ¶ˆæ¯åˆ°æ—¶é—´çº¿è®°å¿†
                    setTimeout(async () => {
                        try {
                            for (let i = 0; i < aiMessages.length; i++) {
                                const msgData = aiMessages[i];
                                let eventContent = '';

                                if (typeof msgData === 'string') {
                                    eventContent = msgData;
                                } else if (typeof msgData === 'object' && msgData.content) {
                                    eventContent = msgData.content;
                                } else if (typeof msgData === 'object' && msgData.type === 'voice_message') {
                                    eventContent = msgData.content;
                                } else if (typeof msgData === 'object' && msgData.type === 'transfer') {
                                    eventContent = `è½¬è´¦ Â¥${msgData.amount}${msgData.note ? ` - ${msgData.note}` : ''}`;
                                } else if (typeof msgData === 'object' && msgData.type === 'emoji') {
                                    eventContent = `å‘é€è¡¨æƒ…åŒ…ï¼š${msgData.description}`;
                                }

                                if (eventContent) {
                                    await recordCrossAppEvent(
                                        characterId,
                                        'chat',
                                        'ai_message',
                                        {
                                            id: characterId,
                                            type: 'private_chat',
                                            sender: 'ai',
                                            content: eventContent,
                                            chatType: 'single',
                                            isProactive: true // æ ‡è®°ä¸ºä¸»åŠ¨æ¶ˆæ¯
                                        }
                                    );
                                    console.log(`ğŸ”¥ [ä¸»åŠ¨èŠå¤©] å·²è®°å½•æ—¶é—´çº¿äº‹ä»¶ - è§’è‰²: ${character.name}, å†…å®¹: ${eventContent.substring(0, 50)}...`);
                                }
                            }
                        } catch (error) {
                            console.error('ğŸ”¥ [ä¸»åŠ¨èŠå¤©] è®°å½•æ—¶é—´çº¿äº‹ä»¶å¤±è´¥:', error);
                        }
                    }, 1000); // å»¶è¿Ÿ1ç§’æ‰§è¡Œ

                    // å¦‚æœå½“å‰æ­£åœ¨å’Œè¿™ä¸ªè§’è‰²èŠå¤©ï¼Œç«‹å³æ˜¾ç¤ºæ¶ˆæ¯
                    if (currentChatCharacter && currentChatCharacter.id === characterId) {
                        renderChatMessages(characterId);
                    }

                    // æ›´æ–°æ¶ˆæ¯åˆ—è¡¨
                    renderMessageList();
                    
                    // ç§»é™¤äº†ä¸»åŠ¨å‘é€æ¶ˆæ¯æ—¥å¿—
                }
            } catch (error) {
                console.error('åå°èŠå¤©å¤±è´¥:', error);
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æµ‹è¯•ä¸»åŠ¨èŠå¤©åŠŸèƒ½
        async function testActiveChat() {
            if (!currentChatCharacter) {
                showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠå¤©è§’è‰²', 'error');
                return;
            }

            console.log(`ğŸ§ª æµ‹è¯•ä¸»åŠ¨èŠå¤©åŠŸèƒ½ - è§’è‰²: ${currentChatCharacter.name}`);
            showToast(`æ­£åœ¨æµ‹è¯• ${currentChatCharacter.name} çš„ä¸»åŠ¨èŠå¤©åŠŸèƒ½...`, 'info');

            try {
                // ğŸ”¥ã€æ–°å¢ã€‘æ˜¾ç¤ºæµ‹è¯•å‰çš„æ¶ˆæ¯æ•°é‡
                const beforeCount = (chatMessages[currentChatCharacter.id] || []).length;
                console.log(`æµ‹è¯•å‰æ¶ˆæ¯æ•°é‡: ${beforeCount}`);

                await triggerBackgroundChat(currentChatCharacter.id, true); // è·³è¿‡æ—¶é—´æ£€æŸ¥

                // ğŸ”¥ã€æ–°å¢ã€‘æ˜¾ç¤ºæµ‹è¯•åçš„æ¶ˆæ¯æ•°é‡
                const afterCount = (chatMessages[currentChatCharacter.id] || []).length;
                console.log(`æµ‹è¯•åæ¶ˆæ¯æ•°é‡: ${afterCount}`);

                if (afterCount > beforeCount) {
                    showToast('ä¸»åŠ¨èŠå¤©æµ‹è¯•æˆåŠŸï¼å·²ç”Ÿæˆæ–°æ¶ˆæ¯', 'success');
                } else {
                    showToast('ä¸»åŠ¨èŠå¤©æµ‹è¯•å®Œæˆï¼Œä½†æœªç”Ÿæˆæ–°æ¶ˆæ¯ï¼ˆå¯èƒ½è¢«æ¡ä»¶é™åˆ¶ï¼‰', 'warning');
                }
            } catch (error) {
                console.error('ä¸»åŠ¨èŠå¤©æµ‹è¯•å¤±è´¥:', error);
                showToast(`ä¸»åŠ¨èŠå¤©æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æµ‹è¯•ä¸»åŠ¨å‘åŠ¨æ€åŠŸèƒ½
        async function testActiveMoments() {
            if (!currentChatCharacter) {
                showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠå¤©è§’è‰²', 'error');
                return;
            }

            console.log(`ğŸ§ª æµ‹è¯•ä¸»åŠ¨å‘åŠ¨æ€åŠŸèƒ½ - è§’è‰²: ${currentChatCharacter.name}`);
            showToast(`æ­£åœ¨æµ‹è¯• ${currentChatCharacter.name} çš„ä¸»åŠ¨å‘åŠ¨æ€åŠŸèƒ½...`, 'info');

            try {
                // ğŸ”¥ã€æ–°å¢ã€‘è·å–æµ‹è¯•å‰çš„åŠ¨æ€æ•°é‡
                const beforeMoments = await getRecentMoments(50);
                const beforeCount = beforeMoments.length;
                console.log(`æµ‹è¯•å‰åŠ¨æ€æ•°é‡: ${beforeCount}`);

                await triggerBackgroundMoments(currentChatCharacter.id, true); // è·³è¿‡å†·å´æ—¶é—´

                // ğŸ”¥ã€æ–°å¢ã€‘è·å–æµ‹è¯•åçš„åŠ¨æ€æ•°é‡
                const afterMoments = await getRecentMoments(50);
                const afterCount = afterMoments.length;
                console.log(`æµ‹è¯•ååŠ¨æ€æ•°é‡: ${afterCount}`);

                if (afterCount > beforeCount) {
                    showToast('ä¸»åŠ¨å‘åŠ¨æ€æµ‹è¯•æˆåŠŸï¼å·²å‘å¸ƒæ–°åŠ¨æ€', 'success');
                } else {
                    showToast('ä¸»åŠ¨å‘åŠ¨æ€æµ‹è¯•å®Œæˆï¼Œä½†æœªå‘å¸ƒæ–°åŠ¨æ€', 'warning');
                }
            } catch (error) {
                console.error('ä¸»åŠ¨å‘åŠ¨æ€æµ‹è¯•å¤±è´¥:', error);
                showToast(`ä¸»åŠ¨å‘åŠ¨æ€æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æŸ¥çœ‹å½“å‰åå°å®šæ—¶å™¨çŠ¶æ€
        function checkBackgroundTimers() {
            console.log('ğŸ” å½“å‰åå°å®šæ—¶å™¨çŠ¶æ€:');
            console.log('backgroundTimers:', backgroundTimers);

            const activeTimers = Object.keys(backgroundTimers).length;
            console.log(`æ´»è·ƒå®šæ—¶å™¨æ•°é‡: ${activeTimers}`);

            if (activeTimers === 0) {
                console.log('âš ï¸ æ²¡æœ‰æ´»è·ƒçš„åå°å®šæ—¶å™¨');
                console.log('ğŸ’¡ å¯ä»¥è¿è¡Œ reinitializeProactiveChatTimers() æ¥é‡æ–°åˆå§‹åŒ–å®šæ—¶å™¨');
            } else {
                for (const [key, timer] of Object.entries(backgroundTimers)) {
                    console.log(`- ${key}: ${timer ? 'è¿è¡Œä¸­' : 'å·²åœæ­¢'}`);
                }
            }

            showToast(`å½“å‰æœ‰ ${activeTimers} ä¸ªæ´»è·ƒçš„åå°å®šæ—¶å™¨`, 'info');
        }

        // ğŸ”¥ã€æ–°å¢ã€‘é‡æ–°å¯åŠ¨åå°ç³»ç»Ÿï¼ˆç”¨äºæµ‹è¯•ï¼‰
        async function restartBackgroundSystem() {
            console.log('ğŸ”„ é‡æ–°å¯åŠ¨åå°äº’åŠ¨ç³»ç»Ÿ...');
            await initGlobalBackgroundInteractionSystem();
            checkBackgroundTimers();
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æš‚åœæŒ‡å®šè§’è‰²çš„ä¸»åŠ¨å‘æ¶ˆæ¯è®¡æ—¶å™¨ï¼ˆç”¨äºçº¿ä¸‹æ¨¡å¼ï¼‰
        function pauseProactiveChatTimer(characterId) {
            const timerKey = characterId + '_chat';
            if (backgroundTimers[timerKey]) {
                clearTimeout(backgroundTimers[timerKey]);
                // ä¿å­˜è®¡æ—¶å™¨çŠ¶æ€ï¼Œä»¥ä¾¿æ¢å¤æ—¶ä½¿ç”¨
                backgroundTimers[timerKey + '_paused'] = true;
                delete backgroundTimers[timerKey];
                console.log(`â¸ï¸ å·²æš‚åœè§’è‰² ${characters.find(c => c.id === characterId)?.name} çš„ä¸»åŠ¨å‘æ¶ˆæ¯è®¡æ—¶å™¨`);
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ¢å¤æŒ‡å®šè§’è‰²çš„ä¸»åŠ¨å‘æ¶ˆæ¯è®¡æ—¶å™¨ï¼ˆé€€å‡ºçº¿ä¸‹æ¨¡å¼æ—¶ï¼‰
        function resumeProactiveChatTimer(characterId) {
            const pausedKey = characterId + '_chat_paused';
            if (backgroundTimers[pausedKey]) {
                // åˆ é™¤æš‚åœæ ‡è®°
                delete backgroundTimers[pausedKey];
                // é‡æ–°å®‰æ’ä¸»åŠ¨èŠå¤©å®šæ—¶å™¨
                scheduleProactiveChatForCharacter(characterId);
                console.log(`â–¶ï¸ å·²æ¢å¤è§’è‰² ${characters.find(c => c.id === characterId)?.name} çš„ä¸»åŠ¨å‘æ¶ˆæ¯è®¡æ—¶å™¨`);
            }
        }

        // ğŸ”§ã€è°ƒè¯•ã€‘å°†é‡æ–°åˆå§‹åŒ–å‡½æ•°æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸï¼Œæ–¹ä¾¿æ§åˆ¶å°è°ƒç”¨
        window.reinitializeProactiveChatTimers = reinitializeProactiveChatTimers;

        // ğŸ”¥ã€æš´éœ²æµ‹è¯•å‡½æ•°åˆ°å…¨å±€ä½œç”¨åŸŸã€‘
        window.testActiveChat = testActiveChat;
        window.testActiveMoments = testActiveMoments;
        window.checkBackgroundTimers = checkBackgroundTimers;
        window.initGlobalBackgroundInteractionSystem = initGlobalBackgroundInteractionSystem;
        window.restartBackgroundSystem = restartBackgroundSystem;
        window.triggerPublisherReplyToComments = triggerPublisherReplyToComments;

        // ğŸ”¥ã€æ–°å¢ã€‘æµ‹è¯•å‘å¸ƒè€…å›å¤åŠŸèƒ½
        window.testPublisherReply = async function(momentId) {
            try {
                console.log('ğŸ§ª å¼€å§‹æµ‹è¯•å‘å¸ƒè€…å›å¤åŠŸèƒ½...');

                // ğŸ”¥ã€ä¿®å¤ã€‘ç¡®ä¿momentIdæ˜¯æ­£ç¡®çš„æ•°å­—ç±»å‹
                const numericMomentId = typeof momentId === 'string' ? parseInt(momentId) : momentId;
                console.log(`ğŸ” æŸ¥æ‰¾åŠ¨æ€ID: ${numericMomentId} (åŸå§‹è¾“å…¥: ${momentId})`);

                // è·å–åŠ¨æ€ä¿¡æ¯
                const moment = await db.moments.get(numericMomentId);
                if (!moment) {
                    console.error('âŒ æœªæ‰¾åˆ°åŠ¨æ€:', numericMomentId);
                    // ğŸ”¥ã€è°ƒè¯•ã€‘åˆ—å‡ºæ‰€æœ‰åŠ¨æ€ID
                    const allMoments = await db.moments.toArray();
                    console.log('ğŸ“‹ æ•°æ®åº“ä¸­çš„æ‰€æœ‰åŠ¨æ€ID:', allMoments.map(m => `${m.id} (${typeof m.id})`));
                    return;
                }

                // è·å–å‘å¸ƒè€…è§’è‰²
                const publisherCharacter = characters.find(c => c.id === moment.characterId);
                if (!publisherCharacter) {
                    console.error('âŒ æœªæ‰¾åˆ°å‘å¸ƒè€…è§’è‰²:', moment.characterId);
                    console.log('ğŸ“‹ å¯ç”¨è§’è‰²:', characters.map(c => `${c.name} (ID: ${c.id})`));
                    return;
                }

                console.log(`ğŸ“ æµ‹è¯•åŠ¨æ€: ${moment.text}`);
                console.log(`ğŸ‘¤ å‘å¸ƒè€…: ${publisherCharacter.name} (ID: ${publisherCharacter.id})`);

                // ç›´æ¥è°ƒç”¨å‘å¸ƒè€…å›å¤å‡½æ•°
                await triggerPublisherReplyToComments(numericMomentId, publisherCharacter);

                console.log('âœ… æµ‹è¯•å®Œæˆ');
            } catch (error) {
                console.error('âŒ æµ‹è¯•å¤±è´¥:', error);
            }
        };

        // ğŸ”¥ã€æ–°å¢ã€‘åˆ—å‡ºæœ€è¿‘çš„åŠ¨æ€IDï¼Œæ–¹ä¾¿æµ‹è¯•
        window.listRecentMoments = async function() {
            try {
                const moments = await db.moments.orderBy('timestamp').reverse().limit(10).toArray();
                console.log('ğŸ“‹ æœ€è¿‘10æ¡åŠ¨æ€:');
                moments.forEach((moment, index) => {
                    console.log(`${index + 1}. ID: ${moment.id} | å‘å¸ƒè€…: ${moment.nickname} | å†…å®¹: ${moment.text.substring(0, 30)}...`);
                });
                console.log('ğŸ’¡ ä½¿ç”¨ testPublisherReply(åŠ¨æ€ID) æ¥æµ‹è¯•å‘å¸ƒè€…å›å¤åŠŸèƒ½');
                console.log('ğŸ’¡ ä½¿ç”¨ forcePublisherReply(åŠ¨æ€ID) æ¥å¼ºåˆ¶å‘å¸ƒè€…å›å¤');
            } catch (error) {
                console.error('âŒ è·å–åŠ¨æ€åˆ—è¡¨å¤±è´¥:', error);
            }
        };

        // ğŸ”¥ã€æ–°å¢ã€‘å¼ºåˆ¶å‘å¸ƒè€…å›å¤åŠŸèƒ½ï¼ˆå¿½ç•¥æ¦‚ç‡æ£€æŸ¥ï¼‰
        window.forcePublisherReply = async function(momentId) {
            try {
                console.log('ğŸ§ª å¼ºåˆ¶å‘å¸ƒè€…å›å¤æµ‹è¯•...');

                const numericMomentId = typeof momentId === 'string' ? parseInt(momentId) : momentId;
                const moment = await db.moments.get(numericMomentId);
                if (!moment) {
                    console.error('âŒ æœªæ‰¾åˆ°åŠ¨æ€:', numericMomentId);
                    return;
                }

                const publisherCharacter = characters.find(c => c.id === moment.characterId);
                if (!publisherCharacter) {
                    console.error('âŒ æœªæ‰¾åˆ°å‘å¸ƒè€…è§’è‰²:', moment.characterId);
                    return;
                }

                // è·å–è¯„è®º
                const comments = await db.momentComments.where('momentId').equals(numericMomentId).toArray();
                const otherCharacterComments = comments.filter(comment =>
                    comment.authorId !== publisherCharacter.id &&
                    comment.authorId !== 'user' &&
                    comment.authorId
                );

                if (otherCharacterComments.length === 0) {
                    console.log('âŒ æ²¡æœ‰å…¶ä»–è§’è‰²çš„è¯„è®ºå¯å›å¤');
                    return;
                }

                // å¼ºåˆ¶é€‰æ‹©ä¸€æ¡è¯„è®ºå›å¤
                const randomComment = otherCharacterComments[Math.floor(Math.random() * otherCharacterComments.length)];
                console.log(`ğŸ¯ å¼ºåˆ¶ ${publisherCharacter.name} å›å¤ ${randomComment.nickname} çš„è¯„è®º`);

                const replyText = await generatePublisherReply(publisherCharacter, randomComment, numericMomentId);
                if (replyText) {
                    const reply = {
                        id: Date.now() + Math.random(),
                        nickname: publisherCharacter.name,
                        avatar: publisherCharacter.avatarUrl,
                        text: replyText,
                        time: formatTime(new Date()),
                        timestamp: Date.now(),
                        characterId: publisherCharacter.id,
                        replyTo: randomComment.nickname
                    };

                    await saveCommentToMoment(numericMomentId, reply);
                    await updateMomentCommentCount(numericMomentId);
                    displayCommentUnderMoment(numericMomentId, reply);

                    console.log(`âœ… å¼ºåˆ¶å›å¤æˆåŠŸ: "${replyText}"`);
                } else {
                    console.log('âŒ ç”Ÿæˆå›å¤å¤±è´¥');
                }
            } catch (error) {
                console.error('âŒ å¼ºåˆ¶å›å¤æµ‹è¯•å¤±è´¥:', error);
            }
        };

        // è§¦å‘åå°å‘åŠ¨æ€ï¼ˆæµ‹è¯•ç‰ˆæœ¬ï¼Œè·³è¿‡å†·å´æ—¶é—´ï¼‰
        async function triggerBackgroundMomentsTest(characterId) {
            // ç§»é™¤äº†æµ‹è¯•å‘å¸ƒæ—¥å¿—
            // ç›´æ¥è°ƒç”¨æ­£å¸¸å‘å¸ƒå‡½æ•°ï¼Œä½†è·³è¿‡å†·å´æ—¶é—´æ£€æŸ¥
            await triggerBackgroundMoments(characterId, true);
        }

        // è§¦å‘åå°å‘åŠ¨æ€
        async function triggerBackgroundMoments(characterId, skipCooldown = false) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;
                
                // æ£€æŸ¥å†·å´æ—¶é—´ï¼ˆé¿å…çŸ­æ—¶é—´å†…é‡å¤å‘å¸ƒï¼‰
                if (!skipCooldown) {
                    const lastMomentTime = character.lastMomentTime || 0;
                    const cooldownTime = 30 * 60 * 1000; // 30åˆ†é’Ÿå†·å´æ—¶é—´
                    if (Date.now() - lastMomentTime < cooldownTime) {
                        // ç§»é™¤äº†å†·å´æ—¶é—´æ—¥å¿—
                        return;
                    }
                } else {
                    // ç§»é™¤äº†æµ‹è¯•å‘å¸ƒæ—¥å¿—
                }
                
                const chatSettings = getCurrentChatSettings();
                
                // è·å–æœ€è¿‘çš„èŠå¤©è®°å½•
                const messages = chatMessages[characterId] || [];
                const maxMemory = chatSettings.historyCount || 5;
                const recentMessages = messages.slice(-maxMemory);
                
                // è·å–æœ€è¿‘çš„åŠ¨æ€å†…å®¹
                const recentMoments = await getRecentMoments(5);
                
                // æ„å»ºä¸Šä¸‹æ–‡
                let chatContext = '';
                if (recentMessages.length > 0) {
                    chatContext = '\n\næœ€è¿‘çš„èŠå¤©è®°å½•ï¼š\n' +
                        recentMessages.map(msg => {
                            if (msg.sender === 'sent') return `ç”¨æˆ·ï¼š${msg.content}`;
                            if (msg.sender === 'received') return `${character.name}ï¼š${msg.content}`;
                            return '';
                        }).filter(Boolean).join('\n');
                }
                
                let momentsContext = '';
                if (recentMoments.length > 0) {
                    momentsContext = '\n\næœ€è¿‘çš„åŠ¨æ€å†…å®¹ï¼š\n' + 
                        recentMoments.map(moment => `${moment.nickname}: ${moment.text}`).join('\n');
                }
                
                // ç”ŸæˆåŠ¨æ€å†…å®¹
                const prompt = `ä½ æ˜¯${character.name}ï¼Œä½ çš„äººè®¾å¦‚ä¸‹ï¼š${character.bio}ã€‚

ç°åœ¨ä½ è¦å‘å¸ƒä¸€æ¡åŠ¨æ€ã€‚è¿™æ¡åŠ¨æ€åº”è¯¥æ˜¯ï¼š
1. ç¬¦åˆä½ çš„äººè®¾å’Œæ€§æ ¼
2. ç”Ÿæ´»åŒ–ã€æœ‰è¶£ã€æœ‰ä¸ªæ€§
3. 50-200å­—å·¦å³
4. å¯ä»¥æ˜¯å¿ƒæƒ…ã€æ„Ÿæ‚Ÿã€æ—¥å¸¸ã€åˆ†äº«ç­‰
5. å¯ä»¥ç»“åˆæœ€è¿‘çš„èŠå¤©æˆ–åŠ¨æ€å†…å®¹ä½œä¸ºçµæ„Ÿ
6. è¦æœ‰ä½ ç‹¬ç‰¹çš„é£æ ¼ï¼Œä¸èƒ½å’Œå…¶ä»–è§’è‰²æ··æ·†
7. æ”¯æŒæ¢è¡Œæ˜¾ç¤ºï¼Œå¯ä»¥é€‚å½“åˆ†æ®µè®©å†…å®¹æ›´æ˜“è¯»
8. å¯ä»¥é€‰æ‹©æ€§åœ°é…å›¾ï¼Œå¦‚æœæƒ³è¦é…å›¾ï¼Œè¯·ç›´æ¥æ¢è¡Œï¼Œç„¶åç”¨æ–œä½“æ ¼å¼å†™ï¼š*[é…å›¾ï¼šè¯¦ç»†çš„å›¾ç‰‡æè¿°]*

## é…å›¾è§„åˆ™ï¼ˆéµå¾ªï¼‰ï¼š
- ä¸éœ€è¦æ¯æ¡åŠ¨æ€éƒ½é…å›¾ï¼Œåªæœ‰å½“å†…å®¹çœŸçš„é€‚åˆé…å›¾æ—¶æ‰æ·»åŠ é…å›¾æè¿°
- å›¾ç‰‡æè¿°è¦ç”ŸåŠ¨ã€å…·ä½“ï¼Œè®©äººèƒ½é€šè¿‡æ–‡å­—æƒ³è±¡å‡ºç”»é¢
- ä»¥ç¬¬ä¸‰äººç§°è§†è§’æè¿°ï¼Œä¾‹å¦‚ï¼š*[é…å›¾ï¼šç…§ç‰‡é‡Œä¸€åªæ©˜çŒ«æ­£æ‡’æ´‹æ´‹åœ°è¶´åœ¨çª—å°ä¸Šæ™’å¤ªé˜³ï¼Œé˜³å…‰æŠŠå®ƒé‡‘è‰²çš„æ¯›ç…§å¾—å‘äº®ï¼ŒèƒŒæ™¯æ˜¯è”šè“çš„å¤©ç©ºå’Œå‡ æœµç™½äº‘ã€‚]*
- å›¾ç‰‡æè¿°è¦ç¬¦åˆä½ çš„æ€§æ ¼å’Œå½“å‰æƒ…å¢ƒ

${chatContext}${momentsContext}

## é‡è¦æ ¼å¼è¦æ±‚ï¼š
- ç›´æ¥è¿”å›åŠ¨æ€æ–‡æœ¬å†…å®¹ï¼Œä¸è¦ä½¿ç”¨JSONæ ¼å¼
- ä¸è¦æ·»åŠ ä»»ä½•ä»£ç å—æ ‡è®°
- ä¸è¦æ·»åŠ "åŠ¨æ€å†…å®¹ï¼š"ç­‰å‰ç¼€
- ç›´æ¥ä»¥åŠ¨æ€æ­£æ–‡å¼€å§‹

è¯·ç”Ÿæˆä¸€æ¡ç¬¦åˆä½ äººè®¾çš„åŠ¨æ€å†…å®¹ï¼š`;

                const response = await generateAIResponse(prompt, character);
                if (response && response.trim()) {
                    // ğŸ”¥ã€ä¿®å¤ã€‘åŠ¨æ€å†…å®¹åº”è¯¥æ˜¯çº¯æ–‡æœ¬ï¼Œå¼ºåŒ–æ ¼å¼å¤„ç†
                    let content = response.trim();

                    // ğŸ”¥ã€å¢å¼ºã€‘æ›´å¼ºçš„JSONæ ¼å¼æ£€æµ‹å’Œå¤„ç†
                    if (content.startsWith('[') || content.startsWith('{')) {
                        try {
                            const parsed = JSON.parse(content);
                            console.log(character.name + ' å‘åŠ¨æ€æ—¶AIè¿”å›äº†JSONæ ¼å¼ï¼Œæ­£åœ¨æå–æ–‡æœ¬:', parsed);

                            if (Array.isArray(parsed) && parsed.length > 0) {
                                // å¦‚æœæ˜¯æ•°ç»„ï¼Œåˆå¹¶æ‰€æœ‰æ–‡æœ¬å†…å®¹
                                content = parsed.map(item => {
                                    if (typeof item === 'string') {
                                        return item.trim();
                                    } else if (typeof item === 'object' && item.content) {
                                        return item.content.trim();
                                    } else if (typeof item === 'object' && item.text) {
                                        return item.text.trim();
                                    }
                                    return '';
                                }).filter(text => text).join('\n');
                            } else if (typeof parsed === 'object') {
                                // å¦‚æœæ˜¯å¯¹è±¡ï¼Œå°è¯•æå–æ–‡æœ¬å­—æ®µ
                                content = parsed.content || parsed.text || parsed.message || JSON.stringify(parsed);
                            }

                            console.log(character.name + ' æå–åçš„åŠ¨æ€å†…å®¹:', content);
                        } catch (parseError) {
                            // å¦‚æœä¸æ˜¯æœ‰æ•ˆJSONï¼Œç›´æ¥ä½¿ç”¨åŸå§‹æ–‡æœ¬
                            console.log(character.name + ' åŠ¨æ€å†…å®¹ä¸æ˜¯æœ‰æ•ˆJSONï¼Œä½¿ç”¨åŸå§‹æ–‡æœ¬');
                            content = response.trim();
                        }
                    }

                    // ğŸ”¥ã€æ–°å¢ã€‘æ¸…ç†å¯èƒ½çš„æ ¼å¼æ ‡è®°
                    content = content
                        .replace(/^```[\s\S]*?\n/, '') // ç§»é™¤å¼€å¤´çš„ä»£ç å—æ ‡è®°
                        .replace(/\n```$/, '') // ç§»é™¤ç»“å°¾çš„ä»£ç å—æ ‡è®°
                        .replace(/^\*\*åŠ¨æ€å†…å®¹\*\*:?\s*/i, '') // ç§»é™¤å¯èƒ½çš„æ ‡é¢˜
                        .replace(/^åŠ¨æ€å†…å®¹:?\s*/i, '') // ç§»é™¤å¯èƒ½çš„æ ‡é¢˜
                        .trim();
                    
                    if (content) {
                        // è·å–å¤´åƒï¼Œç¡®ä¿å®‰å…¨
                        const avatar = getCharacterAvatar(character);
                        // ç§»é™¤äº†å‘å¸ƒåŠ¨æ€å¤´åƒæ—¥å¿—
                        
                        // å‘å¸ƒåŠ¨æ€
                        const moment = {
                            id: Date.now(),  // ä½¿ç”¨æ•°å­—IDè€Œä¸æ˜¯å­—ç¬¦ä¸²
                            authorId: characterId,
                            nickname: character.name,
                            avatar: avatar, // è§’è‰²å¤´åƒ
                            text: content,
                            time: formatTime(new Date()),
                            timestamp: Date.now(),
                            characterId: characterId
                        };
                    
                                                                    // ä¿å­˜åˆ°æ•°æ®åº“
                        await db.moments.add(moment);
                        
                        // ğŸ”¥ã€æ–°å¢ã€‘ä¸ºè§’è‰²å‘å¸ƒåŠ¨æ€åˆ›å»ºæ¨é€é€šçŸ¥
                        createPushNotification(character, `å‘å¸ƒäº†æ–°åŠ¨æ€ï¼š${content.length > 15 ? content.substring(0, 15) + '...' : content}`, 500);
                        
                        // è®°å½•å‘å¸ƒæ—¶é—´
                        character.lastMomentTime = Date.now();
                        saveCharacters();
                        
                        // å¼ºåˆ¶åˆ·æ–°åŠ¨æ€æ˜¾ç¤ºï¼ˆæ— è®ºå½“å‰åœ¨å“ªä¸ªé¡µé¢ï¼‰
                        setTimeout(() => {
                            loadMoments();
                        }, 100);
                        
                        // è§¦å‘åŒåˆ†ç»„è§’è‰²çš„è‡ªå‘äº’åŠ¨ï¼ˆä¿æŒæ¦‚ç‡è®¾ç½®ï¼‰
                        setTimeout(() => {
                            triggerAIInteractions(moment.id, 'like');
                        }, 2000 + Math.random() * 3000); // 2-5ç§’åå¼€å§‹ç‚¹èµ
                        
                        setTimeout(() => {
                            triggerAIInteractions(moment.id, 'comment');
                        }, 5000 + Math.random() * 5000); // 5-10ç§’åå¼€å§‹è¯„è®º
                        
                        // ç§»é™¤äº†å‘å¸ƒåŠ¨æ€æ—¥å¿—
                    }
                }
            } catch (error) {
                console.error('åå°å‘åŠ¨æ€å¤±è´¥:', error);
            }
        }

        // è·å–æœ€è¿‘çš„åŠ¨æ€
        async function getRecentMoments(count = 5) {
            try {
                // ä»æ•°æ®åº“è·å–æœ€æ–°çš„åŠ¨æ€æ•°æ®
                const momentsData = await db.moments.orderBy('timestamp').reverse().limit(count).toArray();
                return momentsData || [];
            } catch (error) {
                console.error('è·å–æœ€è¿‘åŠ¨æ€å¤±è´¥:', error);
                return [];
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘è·å–è§’è‰²å¯è§çš„åŠ¨æ€ï¼ˆç”¨äºèŠå¤©è®°å¿†é›†æˆï¼‰
        async function getVisibleMomentsForCharacter(characterId, count = 5) {
            try {
                // è·å–æ‰€æœ‰æœ€æ–°åŠ¨æ€
                const allMoments = await db.moments.orderBy('timestamp').reverse().limit(count * 2).toArray();
                
                // ç­›é€‰è§’è‰²å¯è§çš„åŠ¨æ€ï¼š
                // 1. ç”¨æˆ·å‘çš„åŠ¨æ€ï¼ˆæ‰€æœ‰è§’è‰²éƒ½èƒ½çœ‹åˆ°ï¼‰
                // 2. è§’è‰²è‡ªå·±å‘çš„åŠ¨æ€
                // 3. åŒä¸€ä¸ªå¥½å‹åˆ†ç»„çš„å…¶ä»–è§’è‰²å‘çš„åŠ¨æ€
                
                const visibleMoments = [];
                const character = characters.find(c => c.id === characterId);
                
                for (const moment of allMoments) {
                    if (visibleMoments.length >= count) break;
                    
                    // ç”¨æˆ·å‘çš„åŠ¨æ€ï¼Œæ‰€æœ‰è§’è‰²éƒ½èƒ½çœ‹åˆ°
                    if (moment.authorId === 'user') {
                        visibleMoments.push(moment);
                        continue;
                    }
                    
                    // è§’è‰²è‡ªå·±å‘çš„åŠ¨æ€
                    if (moment.authorId === characterId) {
                        visibleMoments.push(moment);
                        continue;
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯åŒä¸€ä¸ªå¥½å‹åˆ†ç»„çš„è§’è‰²å‘çš„åŠ¨æ€
                    if (character && moment.characterId) {
                        const momentAuthor = characters.find(c => c.id === moment.characterId);
                        if (momentAuthor && areCharactersInSameGroup(character, momentAuthor)) {
                            visibleMoments.push(moment);
                            continue;
                        }
                    }
                }
                
                return visibleMoments;
            } catch (error) {
                console.error('è·å–è§’è‰²å¯è§åŠ¨æ€å¤±è´¥:', error);
                return [];
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ£€æŸ¥ä¸¤ä¸ªè§’è‰²æ˜¯å¦åœ¨åŒä¸€ä¸ªå¥½å‹åˆ†ç»„
        function areCharactersInSameGroup(char1, char2) {
            // å¦‚æœæ²¡æœ‰åˆ†ç»„ç³»ç»Ÿï¼Œé»˜è®¤æ‰€æœ‰è§’è‰²éƒ½åœ¨åŒä¸€ç»„ï¼ˆéƒ½æ˜¯å¥½å‹ï¼‰
            // è¿™é‡Œå¯ä»¥æ ¹æ®å®é™…çš„åˆ†ç»„é€»è¾‘è¿›è¡Œè°ƒæ•´
            return contacts.includes(char1.id) && contacts.includes(char2.id);
        }

        // ç”ŸæˆAIå“åº”çš„åŒ…è£…å‡½æ•°ï¼Œç”¨äºåå°äº’åŠ¨
        async function generateAIResponse(prompt, character) {
            try {
                // ä½¿ç”¨ç°æœ‰çš„ callChatAPI å‡½æ•°
                const response = await callChatAPI(prompt, character);
                return response;
            } catch (error) {
                console.error('AIå“åº”ç”Ÿæˆå¤±è´¥:', error);
                return null;
            }
        }

        // éªŒè¯å¤´åƒURLæ˜¯å¦æœ‰æ•ˆ
        function isValidAvatarUrl(url) {
            if (!url || typeof url !== 'string') return false;
            
            // æ£€æŸ¥base64æ ¼å¼
            if (url.startsWith('data:image/')) {
                // æ›´å®½æ¾çš„base64éªŒè¯ï¼Œåªæ£€æŸ¥åŸºæœ¬ç»“æ„
                const parts = url.split(',');
                if (parts.length !== 2) {
                    console.warn('base64å¤´åƒURLæ ¼å¼é”™è¯¯ï¼ˆç¼ºå°‘é€—å·åˆ†éš”ï¼‰:', url.substring(0, 50) + '...');
                    return false;
                }
                
                const header = parts[0];
                const data = parts[1];
                
                // æ£€æŸ¥headeræ˜¯å¦åŒ…å«å¿…è¦ä¿¡æ¯
                if (!header.includes('data:image/') || !header.includes('base64')) {
                    console.warn('base64å¤´åƒURLå¤´éƒ¨æ ¼å¼é”™è¯¯:', header);
                    return false;
                }
                
                // æ£€æŸ¥base64æ•°æ®æ˜¯å¦ä¸ºç©ºæˆ–è¿‡é•¿
                if (!data || data.length < 50) {
                    console.warn('base64å¤´åƒæ•°æ®ä¸ºç©ºæˆ–è¿‡çŸ­:', data.length);
                    return false;
                }
                
                if (data.length > 2000000) { // 2MBé™åˆ¶ï¼Œæ›´å®½æ¾
                    console.warn('base64å¤´åƒæ•°æ®è¿‡å¤§:', data.length, 'å»ºè®®å‹ç¼©åé‡æ–°ä¸Šä¼ ä»¥æé«˜æ€§èƒ½');
                    // ä¸å†ç›´æ¥æ‹’ç»ï¼Œåªæ˜¯è­¦å‘Š
                }
                
                // ç®€å•æ£€æŸ¥base64å­—ç¬¦æ˜¯å¦åˆæ³•
                const base64Chars = /^[A-Za-z0-9+/]*={0,2}$/;
                if (!base64Chars.test(data)) {
                    console.warn('base64å¤´åƒæ•°æ®åŒ…å«éæ³•å­—ç¬¦');
                    return false;
                }
                
                return true;
            }
            
            // æ£€æŸ¥HTTP(S) URLæ ¼å¼
            if (url.startsWith('http://') || url.startsWith('https://')) {
                try {
                    new URL(url);
                    return true;
                } catch (error) {
                    console.warn('æ— æ•ˆçš„HTTPå¤´åƒURL:', url);
                    return false;
                }
            }
            
            // å¦‚æœä¸æ˜¯data:imageæˆ–http(s)å¼€å¤´ï¼Œè€ƒè™‘å¯èƒ½æ˜¯å…¶ä»–æœ‰æ•ˆæ ¼å¼
            console.warn('æœªçŸ¥çš„å¤´åƒURLæ ¼å¼:', url.substring(0, 50) + '...');
            return false;
        }

        // è·å–è§’è‰²çš„å¤´åƒï¼ˆç”¨äºåŠ¨æ€å‘å¸ƒï¼‰
        function getCharacterAvatar(character) {
            // ä½¿ç”¨åŒæ­¥ç‰ˆæœ¬çš„è®¾ç½®è·å–ï¼Œé¿å…Promiseé—®é¢˜
            const chatSettings = getChatSettingsSync(character.id);
            
            // ä¼˜å…ˆçº§1ï¼šå¦‚æœè§’è‰²æœ‰èŠå¤©çª—å£çš„åŠ¨æ€å¤´åƒè®¾ç½®ï¼Œä½¿ç”¨é‚£ä¸ª
            if (chatSettings.aiDynamicAvatar && chatSettings.aiDynamicAvatar.trim()) {
                const avatar = chatSettings.aiDynamicAvatar;
                if (isValidAvatarUrl(avatar)) {
                    return avatar;
                } else {
                    console.warn(`è§’è‰²${character.name}çš„åŠ¨æ€å¤´åƒæ— æ•ˆï¼Œå°è¯•ä½¿ç”¨å…¶ä»–å¤´åƒ`);
                }
            }
            
            // ä¼˜å…ˆçº§2ï¼šå¦‚æœè§’è‰²æœ‰èŠå¤©çª—å£çš„å¤´åƒè®¾ç½®ï¼Œä½¿ç”¨é‚£ä¸ª
            if (chatSettings.aiChatAvatar && chatSettings.aiChatAvatar.trim()) {
                const avatar = chatSettings.aiChatAvatar;
                if (isValidAvatarUrl(avatar)) {
                    return avatar;
                } else {
                    console.warn(`è§’è‰²${character.name}çš„èŠå¤©å¤´åƒæ— æ•ˆï¼Œå°è¯•ä½¿ç”¨è§’è‰²å¡å¤´åƒ`);
                }
            }
            
            // ä¼˜å…ˆçº§3ï¼šä½¿ç”¨è§’è‰²å¡é‡Œçš„å¤´åƒ
            if (character.avatarUrl && character.avatarUrl.trim()) {
                const avatar = character.avatarUrl;
                if (isValidAvatarUrl(avatar)) {
                    return avatar;
                } else {
                    console.warn(`è§’è‰²${character.name}çš„è§’è‰²å¡å¤´åƒæ— æ•ˆï¼Œå¤§å°æˆ–æ ¼å¼é—®é¢˜`);
                }
            }
            
            console.log(`è§’è‰²${character.name}æ²¡æœ‰å¯ç”¨çš„å¤´åƒ`);
            return null;
        }

        // è·å–æŒ‡å®šè§’è‰²çš„èŠå¤©è®¾ç½® - ä½¿ç”¨IndexedDB
        async function getChatSettings(characterId) {
            try {
                const chatSettingsRecord = await db.chatSettings.get(characterId);
                if (chatSettingsRecord) {
                    return chatSettingsRecord.settings;
                }
                
                // å¦‚æœIndexedDBä¸­æ²¡æœ‰ï¼Œå°è¯•ä»localStorageè¿ç§»
                const savedSettings = localStorage.getItem(`chatSettings_${characterId}`);
                if (savedSettings) {
                    console.log(`è¿ç§»è§’è‰² ${characterId} çš„èŠå¤©è®¾ç½®åˆ°IndexedDB`);
                    const settings = JSON.parse(savedSettings);
                    
                    // ä¿å­˜åˆ°IndexedDB
                    await db.chatSettings.put({
                        id: characterId,
                        chatId: characterId,
                        settings: settings
                    });
                    
                    return settings;
                }
                
                return {};
            } catch (error) {
                console.error('è·å–èŠå¤©è®¾ç½®å¤±è´¥:', error);
                // å›é€€åˆ°localStorage
                const savedSettings = localStorage.getItem(`chatSettings_${characterId}`);
                return savedSettings ? JSON.parse(savedSettings) : {};
            }
        }
        
        // åŒæ­¥ç‰ˆæœ¬çš„getChatSettingsï¼ˆç”¨äºä¸æ”¯æŒasyncçš„åœ°æ–¹ï¼‰
        function getChatSettingsSync(characterId) {
            const savedSettings = localStorage.getItem(`chatSettings_${characterId}`);
            return savedSettings ? JSON.parse(savedSettings) : {};
        }

        // æ ¼å¼åŒ–åŠ¨æ€æ–‡å­—ï¼Œæ”¯æŒåˆ†è¡Œå’Œé…å›¾æè¿°
        function formatMomentText(text) {
            if (!text) return '';
            
            // æ›¿æ¢æ¢è¡Œç¬¦ä¸º<br>æ ‡ç­¾ï¼Œæ”¯æŒåˆ†è¡Œæ˜¾ç¤º
            let formattedText = text.replace(/\n/g, '<br>');
            
            // å¤„ç†é…å›¾æè¿°ï¼šåŒ¹é…*[é…å›¾ï¼šæè¿°]*æ ¼å¼
            formattedText = formattedText.replace(/\*\[é…å›¾ï¼š([^\]]+)\]\*/g, function(match, description) {
                return `<span style="font-style: italic; color: #999; font-size: 13px; line-height: 1.4;">[é…å›¾ï¼š${description}]</span>`;
            });
            
            return formattedText;
        }

        // è°ƒè¯•è§’è‰²åŠ¨æ€å¤´åƒ
        function debugMomentAvatar(momentId) {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) {
                console.log('æ‰¾ä¸åˆ°åŠ¨æ€å…ƒç´ ');
                return;
            }
            
            // ä»IndexedDBè·å–åŠ¨æ€æ•°æ®
            db.moments.get(parseInt(momentId)).then(moment => {
                console.log('=== åŠ¨æ€å¤´åƒè°ƒè¯• ===');
                console.log('åŠ¨æ€ID:', momentId);
                console.log('è§’è‰²ID:', moment.characterId);
                console.log('ä¿å­˜çš„å¤´åƒ:', moment.avatar ? moment.avatar.substring(0, 50) + '...' : 'null');
                
                if (moment.characterId && moment.characterId !== 'user') {
                    const character = characters.find(c => c.id === moment.characterId);
                    if (character) {
                        console.log('æ‰¾åˆ°è§’è‰²:', character.name);
                        console.log('è§’è‰²å¡å¤´åƒ:', character.avatarUrl ? character.avatarUrl.substring(0, 50) + '...' : 'null');
                    } else {
                        console.log('æ‰¾ä¸åˆ°è§’è‰²æ•°æ®');
                    }
                }
                
                const avatarImg = momentElement.querySelector('.moment-avatar img');
                if (avatarImg) {
                    console.log('å½“å‰æ˜¾ç¤ºçš„å¤´åƒURL:', avatarImg.src ? avatarImg.src.substring(0, 50) + '...' : 'null');
                }
            });
        }
        
        // ç®€å•çš„å¤´åƒæ•°æ®ä¿®å¤
        async function fixAvatarData() {
            console.log('å¼€å§‹ä¿®å¤å¤´åƒæ•°æ®...');
            let fixedCount = 0;
            
            try {
                // æ¸…ç†è§’è‰²è®¾ç½®ä¸­çš„æˆªæ–­å¤´åƒ
                for (const character of characters) {
                    const chatSettings = await getChatSettings(character.id);
                    let needSave = false;
                    
                    if (chatSettings.aiDynamicAvatar) {
                        const avatar = chatSettings.aiDynamicAvatar;
                        if (avatar.startsWith('data:image/') && !avatar.includes('=') && avatar.split(',').length === 2) {
                            console.log(`æ¸…ç†${character.name}çš„åŠ¨æ€å¤´åƒè®¾ç½®`);
                            delete chatSettings.aiDynamicAvatar;
                            needSave = true;
                            fixedCount++;
                        }
                    }
                    
                    if (chatSettings.aiChatAvatar) {
                        const avatar = chatSettings.aiChatAvatar;
                        if (avatar.startsWith('data:image/') && !avatar.includes('=') && avatar.split(',').length === 2) {
                            console.log(`æ¸…ç†${character.name}çš„èŠå¤©å¤´åƒè®¾ç½®`);
                            delete chatSettings.aiChatAvatar;
                            needSave = true;
                            fixedCount++;
                        }
                    }
                    
                    if (needSave) {
                        // ä¿å­˜åˆ°IndexedDBè€Œä¸æ˜¯localStorage
                        await db.chatSettings.put({
                            id: character.id,
                            chatId: character.id,
                            settings: chatSettings
                        });
                    }
                }
                
                // æ¸…ç†åŠ¨æ€æ•°æ®åº“ä¸­çš„æˆªæ–­å¤´åƒ
                const allMoments = await db.moments.toArray();
                let momentFixedCount = 0;
                
                for (const moment of allMoments) {
                    if (moment.avatar && moment.avatar.startsWith('data:image/')) {
                        // æ£€æŸ¥æ˜¯å¦æ˜¯æˆªæ–­çš„å¤´åƒï¼ˆä»¥VNEKhsVJikç»“å°¾çš„æ˜¯æˆªæ–­çš„ï¼‰
                        if (moment.avatar.endsWith('VNEKhsVJik') || moment.avatar.endsWith('VNEKhsVJik:1') || 
                            (!moment.avatar.includes('=') && moment.avatar.split(',').length === 2)) {
                            console.log(`æ¸…ç†åŠ¨æ€ ${moment.id} çš„æˆªæ–­å¤´åƒ`);
                            await db.moments.update(moment.id, { avatar: null });
                            momentFixedCount++;
                        }
                    }
                }
                
                const totalFixed = fixedCount + momentFixedCount;
                console.log(`ä¿®å¤å®Œæˆ: æ¸…ç†äº†${fixedCount}ä¸ªè®¾ç½®å¤´åƒ, ${momentFixedCount}ä¸ªåŠ¨æ€å¤´åƒ`);
                
                alert(`ä¿®å¤å®Œæˆï¼\næ¸…ç†äº† ${fixedCount} ä¸ªè®¾ç½®ä¸­çš„æˆªæ–­å¤´åƒ\næ¸…ç†äº† ${momentFixedCount} ä¸ªåŠ¨æ€ä¸­çš„æˆªæ–­å¤´åƒ\n\nè¯·é‡æ–°ä¸ºè§’è‰²è®¾ç½®å¤´åƒ`);
                
                if (totalFixed > 0) {
                    loadMoments();
                }
            } catch (error) {
                console.error('ä¿®å¤å¤±è´¥:', error);
                alert('ä¿®å¤å¤±è´¥: ' + error.message);
            }
        }

        // é¡µé¢å¸è½½æ—¶æ¸…ç†åå°å®šæ—¶å™¨
        window.addEventListener('beforeunload', function() {
            clearAllBackgroundTimers();
            clearGlobalMomentsTimers();
        });
        
        // ğŸ”¥ã€è°ƒè¯•åŠŸèƒ½ã€‘æµ‹è¯•åŠ¨æ€ç³»ç»Ÿæ˜¯å¦æ­£å¸¸å·¥ä½œ
        function debugMomentsSystem() {
            console.log('=== åŠ¨æ€ç³»ç»Ÿè°ƒè¯•ä¿¡æ¯ ===');
            console.log('è§’è‰²æ•°é‡:', characters ? characters.length : 0);
            console.log('å…¨å±€å®šæ—¶å™¨:', Object.keys(globalMomentsTimers));
            console.log('å®šæ—¶æ£€æŸ¥å™¨çŠ¶æ€:', globalMomentsCheckInterval ? 'è¿è¡Œä¸­' : 'æœªè¿è¡Œ');
            
            if (characters && characters.length > 0) {
                console.log('å„è§’è‰²è®¾ç½®:');
                characters.forEach(async (character, index) => {
                    const settings = await getChatSettings(character.id);
                    console.log(`${index + 1}. ${character.name}:`, {
                        backgroundMomentsEnabled: settings.backgroundMomentsEnabled,
                        backgroundMomentsFrequency: settings.backgroundMomentsFrequency,
                        scheduledMomentsEnabled: settings.scheduledMomentsEnabled,
                        scheduledMomentsTimes: settings.scheduledMomentsTimes
                    });
                });
            }
            
            console.log('=========================');
        }
        
        // æš´éœ²è°ƒè¯•å‡½æ•°åˆ°å…¨å±€
        window.debugMomentsSystem = debugMomentsSystem;


        // åŠ è½½å£çº¸ - ä½¿ç”¨IndexedDBï¼ˆåŒ…å«æ•°æ®è¿ç§»ï¼‰
        async function loadWallpaper() {
            try {
                // å…ˆä»IndexedDBåŠ è½½
                const savedWallpaper = await db.wallpapers.get('main');
            
            if (savedWallpaper) {
                    selectedWallpaper = savedWallpaper.data;
                
                    if (savedWallpaper.type === 'image' && savedWallpaper.data.startsWith('data:image')) {
                    // åŠ è½½ä¸Šä¼ çš„å›¾ç‰‡
                        document.querySelector('.wallpaper').style.backgroundImage = `url(${savedWallpaper.data})`;
                    } else if (savedWallpaper.type === 'gradient' || savedWallpaper.data.startsWith('linear-gradient')) {
                    // åŠ è½½æ¸å˜èƒŒæ™¯
                        document.querySelector('.wallpaper').style.backgroundImage = savedWallpaper.data;
                } else {
                    // åŠ è½½çº¯è‰²èƒŒæ™¯
                        document.querySelector('.wallpaper').style.backgroundColor = savedWallpaper.data;
                    document.querySelector('.wallpaper').style.backgroundImage = 'none';
                }
                
                document.querySelector('.wallpaper').style.backgroundSize = '100% 100%';
                document.querySelector('.wallpaper').style.backgroundPosition = 'center';
                } else {
                    // IndexedDBä¸­æ²¡æœ‰æ•°æ®ï¼Œå°è¯•ä»localStorageè¿ç§»
                    const localWallpaper = localStorage.getItem('wallpaper');
                    const wallpaperType = localStorage.getItem('wallpaperType');
                    
                    if (localWallpaper) {
                        console.log('æ£€æµ‹åˆ°localStorageä¸­çš„å£çº¸æ•°æ®ï¼Œå¼€å§‹è¿ç§»...');
                        selectedWallpaper = localWallpaper;
                        
                        // è¿ç§»åˆ°IndexedDB
                        await db.wallpapers.add({
                            id: 'main',
                            type: wallpaperType || 'gradient',
                            data: localWallpaper
                        });
                        
                        if (wallpaperType === 'image' && localWallpaper.startsWith('data:image')) {
                            document.querySelector('.wallpaper').style.backgroundImage = `url(${localWallpaper})`;
                        } else if (wallpaperType === 'gradient' || localWallpaper.startsWith('linear-gradient')) {
                            document.querySelector('.wallpaper').style.backgroundImage = localWallpaper;
                        } else {
                            document.querySelector('.wallpaper').style.backgroundColor = localWallpaper;
                            document.querySelector('.wallpaper').style.backgroundImage = 'none';
                        }
                        
                        document.querySelector('.wallpaper').style.backgroundSize = '100% 100%';
                        document.querySelector('.wallpaper').style.backgroundPosition = 'center';
                        
                        console.log('å£çº¸æ•°æ®è¿ç§»å®Œæˆ');
                    }
                }
            } catch (error) {
                console.error('åŠ è½½å£çº¸å¤±è´¥:', error);
                // å¦‚æœIndexedDBå¤±è´¥ï¼Œå›é€€åˆ°localStorage
                const localWallpaper = localStorage.getItem('wallpaper');
                const wallpaperType = localStorage.getItem('wallpaperType');
                
                if (localWallpaper) {
                    selectedWallpaper = localWallpaper;
                    
                    if (wallpaperType === 'image' && localWallpaper.startsWith('data:image')) {
                        document.querySelector('.wallpaper').style.backgroundImage = `url(${localWallpaper})`;
                    } else if (wallpaperType === 'gradient' || localWallpaper.startsWith('linear-gradient')) {
                        document.querySelector('.wallpaper').style.backgroundImage = localWallpaper;
                    } else {
                        document.querySelector('.wallpaper').style.backgroundColor = localWallpaper;
                        document.querySelector('.wallpaper').style.backgroundImage = 'none';
                    }
                    
                    document.querySelector('.wallpaper').style.backgroundSize = '100% 100%';
                    document.querySelector('.wallpaper').style.backgroundPosition = 'center';
                }
            }
        }
        
        // åŠ è½½åº”ç”¨å›¾æ ‡ - ä½¿ç”¨IndexedDBï¼ˆåŒ…å«æ•°æ®è¿ç§»ï¼‰
        async function loadAppIcons() {
            try {
                // å…ˆä»IndexedDBåŠ è½½
                const savedIcons = await db.appIcons.toArray();
                
                if (savedIcons.length === 0) {
                    // IndexedDBä¸­æ²¡æœ‰æ•°æ®ï¼Œå°è¯•ä»localStorageè¿ç§»
                    const localStorageData = localStorage.getItem('appIcons');
                    if (localStorageData) {
                        console.log('æ£€æµ‹åˆ°localStorageä¸­çš„åº”ç”¨å›¾æ ‡æ•°æ®ï¼Œå¼€å§‹è¿ç§»...');
                        const localIcons = JSON.parse(localStorageData);
                        
                        // è½¬æ¢ä¸ºæ•°ç»„æ ¼å¼å­˜å‚¨åˆ°IndexedDB
                        const iconArray = Object.keys(localIcons).map(appId => ({
                            id: appId,
                            appId: appId,
                            iconClass: localIcons[appId]
                        }));
                        
                        if (iconArray.length > 0) {
                            await db.appIcons.bulkAdd(iconArray);
                            console.log('åº”ç”¨å›¾æ ‡æ•°æ®è¿ç§»å®Œæˆ:', iconArray);
                        }
                        
                        // åº”ç”¨å›¾æ ‡
                        Object.keys(localIcons).forEach(appId => {
                            const iconElement = document.querySelector(`.app[onclick="showApp('${appId}')"] .app-icon i`);
                            if (iconElement) {
                                iconElement.className = localIcons[appId];
                            }
                        });
                    }
                } else {
                    // IndexedDBä¸­æœ‰æ•°æ®ï¼Œç›´æ¥ä½¿ç”¨
                    console.log('ä»IndexedDBåŠ è½½åº”ç”¨å›¾æ ‡æ•°æ®:', savedIcons);
                    savedIcons.forEach(iconData => {
                        const iconElement = document.querySelector(`.app[onclick="showApp('${iconData.appId}')"] .app-icon i`);
                        if (iconElement) {
                            iconElement.className = iconData.iconClass;
                        }
                    });
                }
            } catch (error) {
                console.error('åŠ è½½åº”ç”¨å›¾æ ‡å¤±è´¥:', error);
                // å¦‚æœIndexedDBå¤±è´¥ï¼Œå›é€€åˆ°localStorage
                const localStorageData = localStorage.getItem('appIcons');
                if (localStorageData) {
                    const icons = JSON.parse(localStorageData);
                Object.keys(icons).forEach(appId => {
                    const iconElement = document.querySelector(`.app[onclick="showApp('${appId}')"] .app-icon i`);
                    if (iconElement) {
                        iconElement.className = icons[appId];
                    }
                });
                }
            }
        }
        
        // åŠ è½½APIè®¾ç½® - ä½¿ç”¨IndexedDB
        async function loadApiSettings() {
            try {
                // å…ˆä»IndexedDBå°è¯•åŠ è½½
                const savedSettings = await db.apiSettings.get('main');
                if (savedSettings) {
                    apiSettings = savedSettings.settings;
                    console.log('ğŸ”§ [åº”ç”¨å¯åŠ¨] ä»IndexedDBåŠ è½½APIè®¾ç½®:', apiSettings);
                } else {
                    // å°è¯•ä»localStorageè¿ç§»
                    const localSettings = localStorage.getItem('apiSettings');
                    if (localSettings) {
                        console.log('ğŸ”§ [åº”ç”¨å¯åŠ¨] è¿ç§»APIè®¾ç½®ä»localStorageåˆ°IndexedDB');
                        apiSettings = JSON.parse(localSettings);

                        // ä¿å­˜åˆ°IndexedDB
                        await db.apiSettings.put({
                            id: 'main',
                            settings: apiSettings
                        });
                        console.log('ğŸ”§ [åº”ç”¨å¯åŠ¨] è¿ç§»å®Œæˆï¼Œå½“å‰APIè®¾ç½®:', apiSettings);
                    } else {
                        // ä½¿ç”¨é»˜è®¤è®¾ç½®
                        console.log('ğŸ”§ [åº”ç”¨å¯åŠ¨] ä½¿ç”¨é»˜è®¤APIè®¾ç½®');
                        apiSettings = {
                            type: 'gemini',
                            base: 'https://generativelanguage.googleapis.com/v1beta',
                            endpoint: '/chat/completions',
                            key: '',
                            model: 'gemini-2.0-flash-exp',
                            temperature: 0.70
                        };
                    }
                }

                // æ—§ç‰ˆæœ¬APIè®¾ç½®è¡¨å•æ›´æ–°ä»£ç å·²æ¸…ç† - ç°åœ¨ä½¿ç”¨æ–°ç‰ˆæœ¬çš„APIè®¾ç½®ç³»ç»Ÿ
            } catch (error) {
                console.error('åŠ è½½APIè®¾ç½®å¤±è´¥:', error);
                // æ—§ç‰ˆæœ¬é»˜è®¤è®¾ç½®ä»£ç å·²æ¸…ç†
            }
        }
        
        // ä¿å­˜åº”ç”¨å›¾æ ‡ - ä½¿ç”¨IndexedDB
        async function saveAppIcons() {
            try {
                console.log('ä¿å­˜åº”ç”¨å›¾æ ‡æ•°æ®åˆ°IndexedDB...');
                
                const defaultIcons = {
                    'chat-screen': 'fas fa-comment-dots',
                    'forum-screen': 'fas fa-comments',
                    'game-screen': 'fas fa-gamepad',
                    'characters-screen': 'fas fa-user-friends',
                    'shop-screen': 'fas fa-shopping-bag',
                    'settings-screen': 'fas fa-cog'
                };
                
                if (selectedAppIcon) {
                    defaultIcons[selectedAppIcon.appId] = selectedAppIcon.iconClass;
                }
                
                // è½¬æ¢ä¸ºæ•°ç»„æ ¼å¼
                const iconArray = Object.keys(defaultIcons).map(appId => ({
                    id: appId,
                    appId: appId,
                    iconClass: defaultIcons[appId]
                }));
                
                // æ¸…ç©ºç°æœ‰æ•°æ®å¹¶æ’å…¥æ–°æ•°æ®
                await db.appIcons.clear();
                await db.appIcons.bulkAdd(iconArray);
                
                console.log('åº”ç”¨å›¾æ ‡æ•°æ®ä¿å­˜æˆåŠŸ');
                
                // åˆ·æ–°å›¾æ ‡æ˜¾ç¤º
                await loadAppIcons();
            } catch (error) {
                console.error('ä¿å­˜åº”ç”¨å›¾æ ‡æ—¶å‘ç”Ÿé”™è¯¯:', error);
                // å¦‚æœIndexedDBå¤±è´¥ï¼Œå›é€€åˆ°localStorage
            const icons = {
                'chat-screen': 'fas fa-comment-dots',
                'weibo-screen': 'fab fa-weibo',
                'album-screen': 'fas fa-images',
                'characters-screen': 'fas fa-user-friends',
                'shop-screen': 'fas fa-shopping-bag',
                'settings-screen': 'fas fa-cog'
            };
            
            if (selectedAppIcon) {
                icons[selectedAppIcon.appId] = selectedAppIcon.iconClass;
            }
            
            localStorage.setItem('appIcons', JSON.stringify(icons));
            loadAppIcons();
            }
        }
        
        // æ¸²æŸ“æ¶ˆæ¯åˆ—è¡¨
        function renderMessageList() {
            const messageList = document.getElementById('message-list');
            messageList.innerHTML = '';

            // ğŸ”¥ã€ä¿®æ”¹ã€‘ä¸ºå¤šé€‰æ¨¡å¼åœ¨app-headerä¸­æ·»åŠ æŒ‰é’®
            const chatHeaderActions = document.querySelector('#chat-screen .chat-header-actions');
            if (isMessageListMultiSelectMode) {
                // éšè—åŸæœ‰çš„headeræŒ‰é’®
                if (chatHeaderActions) {
                    chatHeaderActions.style.display = 'none';
                }

                // ğŸ”¥ã€æ–°å¢ã€‘æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨å¤šé€‰æŒ‰é’®ï¼Œé¿å…é‡å¤æ·»åŠ 
                let existingActions = document.querySelector('.chat-header-multiselect-actions');
                if (!existingActions) {
                    const multiselectActions = document.createElement('div');
                    multiselectActions.className = 'chat-header-multiselect-actions';
                    multiselectActions.innerHTML = `
                        <button class="multiselect-btn pin-btn" data-action="pin">
                            <i class="fas fa-thumbtack"></i>
                            <span>ç½®é¡¶</span>
                        </button>
                        <button class="multiselect-btn delete-btn" data-action="delete">
                            <i class="fas fa-trash"></i>
                            <span>åˆ é™¤</span>
                        </button>
                        <button class="multiselect-btn cancel-btn" data-action="cancel">
                            <i class="fas fa-times"></i>
                            <span>å–æ¶ˆ</span>
                        </button>
                    `;

                    // ğŸ”¥ã€ä¿®å¤ã€‘ä½¿ç”¨äº‹ä»¶å§”æ‰˜ç»‘å®šç‚¹å‡»äº‹ä»¶ï¼Œé¿å…å†…è”onclické—®é¢˜
                    multiselectActions.onclick = function(e) {
                        const action = e.target.closest('[data-action]')?.dataset.action;
                        if (action === 'delete') {
                            deleteSelectedConversations();
                        } else if (action === 'cancel') {
                            exitMessageListMultiSelectMode();
                        } else if (action === 'pin') {
                            pinSelectedConversations();
                        }
                    };

                    // ğŸ”¥ã€ä¿®æ”¹ã€‘å°†æŒ‰é’®æ·»åŠ åˆ°æ¶ˆæ¯åˆ—è¡¨é¡µé¢çš„app-headerä¸­
                    const chatAppHeader = document.querySelector('#chat-screen .app-header');
                    if (chatAppHeader) {
                        chatAppHeader.appendChild(multiselectActions);
                    }
                }
            } else {
                // ğŸ”¥ã€æ–°å¢ã€‘éå¤šé€‰æ¨¡å¼æ—¶æ¢å¤åŸæœ‰æŒ‰é’®ï¼Œç§»é™¤å¤šé€‰æŒ‰é’®
                if (chatHeaderActions) {
                    chatHeaderActions.style.display = 'flex';
                }
                const existingActions = document.querySelector('.chat-header-multiselect-actions');
                if (existingActions) {
                    existingActions.remove();
                }
            }

            // ğŸ”¥ã€ä¿®å¤ã€‘åªæ¸²æŸ“å­˜åœ¨äº contacts åˆ—è¡¨ä¸­çš„å•äººå¯¹è¯
            const singleChats = characters.filter(character => contacts.includes(character.id));

            const sortedSingleChats = singleChats.sort((a, b) => {
                const aPinned = isPinned(a.id);
                const bPinned = isPinned(b.id);
                if (aPinned && !bPinned) return -1;
                if (!aPinned && bPinned) return 1;
                // ä½ å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ æŒ‰æœ€åæ¶ˆæ¯æ—¶é—´çš„æ’åºé€»è¾‘
                return 0;
            });

            sortedSingleChats.forEach(character => {
                // ç›´æ¥ä½¿ç”¨è§’è‰²å¯¹è±¡ï¼Œä¸éœ€è¦å†æŸ¥æ‰¾
                if (character) {
                    // ğŸ”¥ã€ä¿®å¤ã€‘è·å–è¯¥èŠå¤©çš„æ˜µç§°è®¾ç½®
                    const savedSettings = localStorage.getItem(`chatSettings_${character.id}`);
                    const chatSettings = savedSettings ? JSON.parse(savedSettings) : {};
                    const displayName = chatSettings.aiChatNickname || character.name;
                    
                    const messages = chatMessages[character.id] || [];
                let lastMessageRaw = 'æš‚æ— æ¶ˆæ¯';
                
                if (messages.length > 0) {
                    const lastMsg = messages[messages.length - 1];
                    
                    // ğŸ”¥ã€ä¿®å¤ã€‘æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦æœ‰æ•ˆï¼Œé˜²æ­¢undefinedé”™è¯¯
                    if (!lastMsg) {
                        lastMessageRaw = 'æš‚æ— æ¶ˆæ¯';
                    } else if (lastMsg.type === 'user_photo') {
                        lastMessageRaw = '[ç…§ç‰‡]';
                    } else if (lastMsg.type === 'ai_image') {
                        lastMessageRaw = '[å›¾ç‰‡]';
                    } else if (lastMsg.type === 'voice_message') {
                        lastMessageRaw = '[è¯­éŸ³]';
                    } else if (lastMsg.type === 'transfer') {
                        lastMessageRaw = '[è½¬è´¦]';
                    } else if (lastMsg.type === 'recalled_message') {
                        lastMessageRaw = '[æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯]';
                    } else if (lastMsg.type === 'location') {
                        lastMessageRaw = '[ä½ç½®]';
                    } else if (lastMsg.type === 'call_message') {
                        lastMessageRaw = '[é€šè¯æ¶ˆæ¯]';
                    } else if (lastMsg.sender === 'system') {
                        lastMessageRaw = lastMsg.content || '[ç³»ç»Ÿæ¶ˆæ¯]';
                    } else if (lastMsg.isEmoji) {
                        lastMessageRaw = '[è¡¨æƒ…]';
                    } else {
                        lastMessageRaw = lastMsg.content || '';
                    }
                }
                
                const lastMessage = truncateText(String(lastMessageRaw || 'æš‚æ— æ¶ˆæ¯'), 30);
                    const lastTime = messages.length > 0 ? formatTime(messages[messages.length - 1].timestamp) : 'åˆšåˆš';
                    
                    const messageItem = document.createElement('div');
                    const isPinnedConversation = isPinned(character.id);
                    messageItem.className = `message-item ${isPinnedConversation ? 'pinned' : ''} ${isMessageListMultiSelectMode && selectedConversations.includes(character.id) ? 'selected' : ''}`;
                    messageItem.dataset.conversationId = character.id; // æ·»åŠ å¯¹è¯ID
                    
                    // æ ¹æ®æ¨¡å¼è®¾ç½®ä¸åŒçš„ç‚¹å‡»äº‹ä»¶
                    if (isMessageListMultiSelectMode) {
                        messageItem.onclick = () => toggleConversationSelection(character.id);
                    } else {
                        // ä½¿ç”¨å˜é‡æ¥æ§åˆ¶ç‚¹å‡»è¡Œä¸º
                        let isLongPress = false;
                        
                        messageItem.onclick = (e) => {
                            if (!isLongPress) {
                                startChat(character);
                            }
                            isLongPress = false; // é‡ç½®æ ‡å¿—
                        };
                        
                        // æ·»åŠ é•¿æŒ‰äº‹ä»¶ï¼ˆæ”¯æŒç§»åŠ¨ç«¯å’Œæ¡Œé¢ç«¯ï¼‰
                        let pressTimer;
                        
                        // ç§»åŠ¨ç«¯è§¦æ‘¸äº‹ä»¶
                        messageItem.addEventListener('touchstart', (e) => {
                            e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡
                            pressTimer = setTimeout(() => {
                                console.log('è§¦æ‘¸é•¿æŒ‰è§¦å‘ï¼Œè§’è‰²ID:', character.id);
                                isLongPress = true; // è®¾ç½®é•¿æŒ‰æ ‡å¿—
                                enterMessageListMultiSelectMode(character.id);
                                e.preventDefault();
                            }, 800); // 800msé•¿æŒ‰
                        });
                        
                        messageItem.addEventListener('touchend', (e) => {
                            if (pressTimer) {
                                clearTimeout(pressTimer);
                                pressTimer = null;
                            }
                        });
                        
                        messageItem.addEventListener('touchmove', (e) => {
                            if (pressTimer) {
                                clearTimeout(pressTimer);
                                pressTimer = null;
                            }
                        });
                        
                        // æ¡Œé¢ç«¯é¼ æ ‡äº‹ä»¶
                        messageItem.addEventListener('mousedown', (e) => {
                            if (e.button === 0) { // å·¦é”®
                                e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡
                                pressTimer = setTimeout(() => {
                                    console.log('é¼ æ ‡é•¿æŒ‰è§¦å‘ï¼Œè§’è‰²ID:', character.id);
                                    isLongPress = true; // è®¾ç½®é•¿æŒ‰æ ‡å¿—
                                    enterMessageListMultiSelectMode(character.id);
                                    e.preventDefault();
                                }, 800); // 800msé•¿æŒ‰
                            }
                        });
                        
                        messageItem.addEventListener('mouseup', (e) => {
                            if (pressTimer) {
                                clearTimeout(pressTimer);
                                pressTimer = null;
                            }
                        });
                        
                        messageItem.addEventListener('mouseleave', (e) => {
                            if (pressTimer) {
                                clearTimeout(pressTimer);
                                pressTimer = null;
                            }
                        });
                        
                        // å³é”®ç‚¹å‡»è¿›å…¥å¤šé€‰æ¨¡å¼ï¼ˆæ¡Œé¢ç«¯ï¼‰
                        messageItem.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            enterMessageListMultiSelectMode(character.id);
                        });
                    }
                    
                    // ğŸ”¥ã€æ–°å¢ã€‘æ£€æŸ¥æ‹‰é»‘çŠ¶æ€å¹¶ç”ŸæˆçŠ¶æ€æŒ‡ç¤ºå™¨
                    let messageStatusIndicator = '';
                    if (character.isGroup === true) {
                        // ç¾¤èŠæ£€æŸ¥å±è”½çŠ¶æ€
                        const isMuted = isGroupMuted(character.id);
                        if (isMuted) {
                            messageStatusIndicator = '<div class="message-status-indicator muted" title="å·²å±è”½"><i class="fas fa-volume-mute"></i></div>';
                        }
                    } else {
                        // å•èŠæ£€æŸ¥æ‹‰é»‘çŠ¶æ€
                        const isUserBlocked = isBlocked('user', character.id);
                        const isCharacterBlocked = isBlocked(character.id, 'user');

                        if (isUserBlocked) {
                            messageStatusIndicator = '<div class="message-status-indicator blocked" title="å·²æ‹‰é»‘"><i class="fas fa-ban"></i></div>';
                        } else if (isCharacterBlocked) {
                            messageStatusIndicator = '<div class="message-status-indicator blocked-by" title="è¢«å¯¹æ–¹æ‹‰é»‘"><i class="fas fa-exclamation-triangle"></i></div>';
                        }
                    }

                    // ğŸ”¥ã€æ–°å¢ã€‘æ£€æŸ¥æœªè¯»æ¶ˆæ¯æ•°é‡å¹¶ç”Ÿæˆæœªè¯»æç¤º
                    let unreadBadge = '';
                    const unreadCount = getUnreadCount(character.id);
                    if (unreadCount > 0) {
                        const displayCount = unreadCount > 99 ? '99+' : unreadCount.toString();
                        const badgeClass = unreadCount > 99 ? 'unread-badge large-count' : 'unread-badge';
                        unreadBadge = `<div class="${badgeClass}" title="${unreadCount}æ¡æœªè¯»æ¶ˆæ¯">${displayCount}</div>`;
                    }

                    messageItem.innerHTML = `
                        ${isPinnedConversation ? '<div class="pin-indicator"><i class="fas fa-thumbtack"></i></div>' : ''}
                        ${isMessageListMultiSelectMode ? `
                            <div class="selection-checkbox ${selectedConversations.includes(character.id) ? 'selected' : ''}">
                                ${selectedConversations.includes(character.id) ? '<i class="fas fa-check check-icon-white"></i>' : ''}
                            </div>
                        ` : ''}
                        <div class="message-avatar-container">
                            <div class="message-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                                ${character.avatarUrl ? '' : displayName.charAt(0)}
                            </div>
                            ${unreadBadge}
                            ${messageStatusIndicator}
                        </div>
                        <div class="message-content">
                            <div class="message-name">${displayName}</div>
                            <div class="message-preview">${lastMessage}</div>
                        </div>
                        <div class="message-time">${lastTime}</div>
                    `;
                    
                    messageList.appendChild(messageItem);
                }
            });
            
            // ğŸ”¥ã€ä¿®æ”¹ã€‘æ¸²æŸ“ç¾¤èŠ - æ”¯æŒç½®é¡¶æ’åº
            const sortedGroups = [...groupChats].sort((a, b) => {
                const aPinned = isPinned(a.id);
                const bPinned = isPinned(b.id);
                if (aPinned && !bPinned) return -1;
                if (!aPinned && bPinned) return 1;
                return 0;
            });

            sortedGroups.forEach(group => {
                const messages = chatMessages[group.id] || [];
                let lastMessageRaw = 'æš‚æ— æ¶ˆæ¯';
                
                if (messages.length > 0) {
                    const lastMsg = messages[messages.length - 1];
                    
                    // ğŸ”¥ã€ä¿®å¤ã€‘æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦æœ‰æ•ˆï¼Œé˜²æ­¢undefinedé”™è¯¯
                    if (!lastMsg) {
                        lastMessageRaw = 'æš‚æ— æ¶ˆæ¯';
                    } else if (lastMsg.type === 'user_photo') {
                        lastMessageRaw = '[ç…§ç‰‡]';
                    } else if (lastMsg.type === 'ai_image') {
                        lastMessageRaw = '[å›¾ç‰‡]';
                    } else if (lastMsg.type === 'voice_message') {
                        lastMessageRaw = '[è¯­éŸ³]';
                    } else if (lastMsg.type === 'transfer') {
                        lastMessageRaw = '[è½¬è´¦]';
                    } else if (lastMsg.type === 'recalled_message') {
                        lastMessageRaw = '[æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯]';
                    } else if (lastMsg.type === 'location') {
                        lastMessageRaw = '[ä½ç½®]';
                    } else if (lastMsg.type === 'call_message') {
                        lastMessageRaw = '[é€šè¯æ¶ˆæ¯]';
                    } else if (lastMsg.sender === 'system') {
                        lastMessageRaw = lastMsg.content || '[ç³»ç»Ÿæ¶ˆæ¯]';
                    } else if (lastMsg.isEmoji) {
                        lastMessageRaw = '[è¡¨æƒ…]';
                    } else {
                        lastMessageRaw = lastMsg.content || '';
                    }
                }
                
                const lastMessage = truncateText(String(lastMessageRaw || 'æš‚æ— æ¶ˆæ¯'), 30);
                const lastTime = messages.length > 0 ? formatTime(messages[messages.length - 1].timestamp) : 'åˆšåˆš';
                
                const messageItem = document.createElement('div');
                const isGroupPinned = isPinned(group.id);
                messageItem.className = `message-item ${isGroupPinned ? 'pinned' : ''} ${isMessageListMultiSelectMode && selectedConversations.includes(group.id) ? 'selected' : ''}`;
                messageItem.dataset.conversationId = group.id; // æ·»åŠ å¯¹è¯ID
                
                // æ ¹æ®æ¨¡å¼è®¾ç½®ä¸åŒçš„ç‚¹å‡»äº‹ä»¶
                if (isMessageListMultiSelectMode) {
                    messageItem.onclick = () => toggleConversationSelection(group.id);
                } else {
                messageItem.onclick = () => startChat(group);
                    
                    // æ·»åŠ é•¿æŒ‰äº‹ä»¶ï¼ˆæ”¯æŒç§»åŠ¨ç«¯å’Œæ¡Œé¢ç«¯ï¼‰
                    let pressTimer;
                    
                    // ç§»åŠ¨ç«¯è§¦æ‘¸äº‹ä»¶
                    messageItem.addEventListener('touchstart', (e) => {
                        e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡
                        pressTimer = setTimeout(() => {
                            console.log('è§¦æ‘¸é•¿æŒ‰è§¦å‘ï¼Œç¾¤èŠID:', group.id);
                            enterMessageListMultiSelectMode(group.id);
                            e.preventDefault();
                        }, 800); // 800msé•¿æŒ‰
                    });
                    
                    messageItem.addEventListener('touchend', (e) => {
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                        }
                    });
                    
                    messageItem.addEventListener('touchmove', (e) => {
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                        }
                    });
                    
                    // æ¡Œé¢ç«¯é¼ æ ‡äº‹ä»¶
                    messageItem.addEventListener('mousedown', (e) => {
                        if (e.button === 0) { // å·¦é”®
                            e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡
                            pressTimer = setTimeout(() => {
                                console.log('é¼ æ ‡é•¿æŒ‰è§¦å‘ï¼Œç¾¤èŠID:', group.id);
                                enterMessageListMultiSelectMode(group.id);
                                e.preventDefault();
                            }, 800); // 800msé•¿æŒ‰
                        }
                    });
                    
                    messageItem.addEventListener('mouseup', (e) => {
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                        }
                    });
                    
                    messageItem.addEventListener('mouseleave', (e) => {
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                        }
                    });
                    
                    // å³é”®ç‚¹å‡»è¿›å…¥å¤šé€‰æ¨¡å¼ï¼ˆæ¡Œé¢ç«¯ï¼‰
                    messageItem.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        enterMessageListMultiSelectMode(group.id);
                    });
                }
                
                // ğŸ”¥ã€æ–°å¢ã€‘æ£€æŸ¥ç¾¤èŠå±è”½çŠ¶æ€
                let groupStatusIndicator = '';
                const isMuted = isGroupMuted(group.id);
                if (isMuted) {
                    groupStatusIndicator = '<div class="message-status-indicator muted" title="å·²å±è”½"><i class="fas fa-volume-mute"></i></div>';
                }

                // ğŸ”¥ã€æ–°å¢ã€‘æ£€æŸ¥ç¾¤èŠæœªè¯»æ¶ˆæ¯æ•°é‡
                let groupUnreadBadge = '';
                const groupUnreadCount = getUnreadCount(group.id);
                if (groupUnreadCount > 0) {
                    const displayCount = groupUnreadCount > 99 ? '99+' : groupUnreadCount.toString();
                    const badgeClass = groupUnreadCount > 99 ? 'unread-badge large-count' : 'unread-badge';
                    groupUnreadBadge = `<div class="${badgeClass}" title="${groupUnreadCount}æ¡æœªè¯»æ¶ˆæ¯">${displayCount}</div>`;
                }

                messageItem.innerHTML = `
                    ${isGroupPinned ? '<div class="pin-indicator"><i class="fas fa-thumbtack"></i></div>' : ''}
                    ${isMessageListMultiSelectMode ? `
                        <div class="selection-checkbox ${selectedConversations.includes(group.id) ? 'selected' : ''}">
                            ${selectedConversations.includes(group.id) ? '<i class="fas fa-check check-icon-white"></i>' : ''}
                        </div>
                    ` : ''}
                    <div class="message-avatar-container">
                        <div class="message-avatar" style="${group.avatarUrl ? `background-image: url(${group.avatarUrl}); background-size: cover; background-position: center;` : 'background-color: #4CAF50;'}">
                            ${group.avatarUrl ? '' : 'ç¾¤'}
                        </div>
                        ${groupUnreadBadge}
                        ${groupStatusIndicator}
                    </div>
                    <div class="message-content">
                                                        <div class="message-name">${group.name} <span class="group-member-count">(${group.members ? group.members.length + 1 : 1}äºº)</span></div>
                        <div class="message-preview">${lastMessage}</div>
                    </div>
                    <div class="message-time">${lastTime}</div>
                `;
                
                messageList.appendChild(messageItem);
            });

            // ğŸ”¥ã€æ–°å¢ã€‘æ¸²æŸ“å®Œæˆåï¼Œä¸ºäº†æµ‹è¯•ï¼Œå¯ä»¥æ‰‹åŠ¨è®¾ç½®ä¸€äº›æœªè¯»æ¶ˆæ¯
            // è¿™ä¸ªä»£ç ä»…ç”¨äºæ¼”ç¤ºï¼Œå®é™…ä½¿ç”¨æ—¶åº”è¯¥åˆ é™¤
            if (window.location.hash === '#test-unread') {
                // ä¸º"ä¸€å·"è§’è‰²è®¾ç½®ä¸€äº›æœªè¯»æ¶ˆæ¯ç”¨äºæµ‹è¯•
                const testCharacter = characters.find(c => c.name === 'ä¸€å·');
                if (testCharacter) {
                    const oneHourAgo = Date.now() - 60 * 60 * 1000;
                    localStorage.setItem(`lastRead_${testCharacter.id}`, oneHourAgo.toString());
                }
            }
        }
        
        // ğŸ”¥ã€æ–°å¢ã€‘è®¡ç®—æœªè¯»æ¶ˆæ¯æ•°é‡
        function getUnreadCount(characterId) {
            const messages = chatMessages[characterId] || [];
            const lastReadTime = localStorage.getItem(`lastRead_${characterId}`);

            if (!lastReadTime) {
                // å¦‚æœæ²¡æœ‰è®°å½•æœ€åé˜…è¯»æ—¶é—´ï¼Œè®¤ä¸ºæ‰€æœ‰æ¶ˆæ¯éƒ½å·²è¯»
                return 0;
            }

            const lastReadTimestamp = parseInt(lastReadTime);
            const unreadMessages = messages.filter(msg =>
                msg.timestamp > lastReadTimestamp && msg.sender !== 'user'
            );

            return unreadMessages.length;
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ ‡è®°æ¶ˆæ¯ä¸ºå·²è¯»
        function markAsRead(characterId) {
            const now = Date.now();
            localStorage.setItem(`lastRead_${characterId}`, now.toString());
        }

        // ğŸ”¥ã€æ–°å¢ã€‘ç½®é¡¶ç›¸å…³å‡½æ•°
        function loadPinnedConversations() {
            const saved = localStorage.getItem('pinnedConversations');
            pinnedConversations = saved ? JSON.parse(saved) : [];
        }

        function savePinnedConversations() {
            localStorage.setItem('pinnedConversations', JSON.stringify(pinnedConversations));
        }

        function togglePinConversation(conversationId) {
            const index = pinnedConversations.indexOf(conversationId);
            if (index > -1) {
                pinnedConversations.splice(index, 1);
            } else {
                pinnedConversations.push(conversationId);
            }
            savePinnedConversations();
        }

        function isPinned(conversationId) {
            return pinnedConversations.includes(conversationId);
        }

        // ğŸ”¥ã€ä¿®æ”¹ã€‘ç½®é¡¶é€‰ä¸­çš„å¯¹è¯ - æ”¯æŒé‡æ–°è®¾ç½®ç½®é¡¶
        async function pinSelectedConversations() {
            // ğŸ”¥ã€æ–°å¢ã€‘é‡æ–°è®¾ç½®ç½®é¡¶é€»è¾‘ï¼šæ¸…ç©ºç°æœ‰ç½®é¡¶ï¼Œåªç½®é¡¶å½“å‰é€‰ä¸­çš„å¯¹è¯
            pinnedConversations = [...selectedConversations];

            savePinnedConversations();
            renderMessageList();
            exitMessageListMultiSelectMode();

            const count = selectedConversations.length;
            showToast(`å·²é‡æ–°è®¾ç½®ç½®é¡¶ï¼Œå½“å‰ç½®é¡¶ ${count} ä¸ªå¯¹è¯`, 'success');
        }

        // æ¸²æŸ“è”ç³»äººåˆ—è¡¨ï¼ˆè§’è‰²é¡µé¢ï¼‰- æŒ‰åˆ†ç»„æ˜¾ç¤º
        function renderContactList() {
            const contactList = document.querySelector('#contact-list .contact-section');
            if (!contactList) return;
            
            // æ¸…ç©ºæ‰€æœ‰å†…å®¹
            contactList.innerHTML = '';
            

            
            // æ·»åŠ å¤šé€‰æ¨¡å¼çš„å¤´éƒ¨
            if (isMultiSelectMode) {
                const headerDiv = document.createElement('div');
                headerDiv.className = 'multiselect-header';
                headerDiv.innerHTML = `
                    <div class="multiselect-info">
                        <i class="fas fa-check-circle multiselect-icon"></i>
                        <span class="multiselect-text">å·²é€‰æ‹© ${selectedCharacters.length} ä¸ªè§’è‰²</span>
                    </div>
                    <div class="multiselect-actions">
                        <button onclick="showMoveToGroupModal()" class="multiselect-btn move-btn" title="ç§»åŠ¨åˆ°åˆ†ç»„">
                            <i class="fas fa-folder"></i>
                            <span>ç§»åŠ¨</span>
                        </button>
                        <button onclick="deleteSelectedCharacters()" class="multiselect-btn delete-btn" title="åˆ é™¤é€‰ä¸­è§’è‰²">
                            <i class="fas fa-trash"></i>
                            <span>åˆ é™¤</span>
                        </button>
                        <button onclick="exitMultiSelectMode()" class="multiselect-btn cancel-btn" title="å–æ¶ˆå¤šé€‰">
                            <i class="fas fa-times"></i>
                            <span>å–æ¶ˆ</span>
                        </button>
                    </div>
                `;
                contactList.appendChild(headerDiv);
            }
            
            // åˆ†ç»„ç®¡ç†æ¨¡å¼çš„å¤´éƒ¨
            if (isGroupManageMode) {
                const manageHeaderDiv = document.createElement('div');
                manageHeaderDiv.className = 'group-manage-header';
                manageHeaderDiv.innerHTML = `
                    <div class="group-manage-info">
                        <i class="fas fa-cogs group-manage-icon"></i>
                        <span class="group-manage-text">åˆ†ç»„ç®¡ç†æ¨¡å¼</span>
                    </div>
                    <div class="group-manage-actions">
                        <button onclick="showCreateGroupModal()" class="multiselect-btn create-btn" title="æ–°å»ºåˆ†ç»„">
                            <i class="fas fa-plus"></i>
                            <span>æ–°å»º</span>
                        </button>
                        <button onclick="exitGroupManageMode()" class="multiselect-btn done-btn" title="å®Œæˆç®¡ç†">
                            <i class="fas fa-check"></i>
                            <span>å®Œæˆ</span>
                        </button>
                    </div>
                `;
                contactList.appendChild(manageHeaderDiv);
            }
            
            // æŒ‰åˆ†ç»„æ¸²æŸ“è§’è‰²
            const sortedGroups = characterGroups.sort((a, b) => a.order - b.order);
            
            sortedGroups.forEach(group => {
                const groupCharacters = characters.filter(char => char.groupId === group.id);
                
                // å¦‚æœè¯¥åˆ†ç»„æ²¡æœ‰è§’è‰²ä¸”ä¸æ˜¯åˆ†ç»„ç®¡ç†æ¨¡å¼ï¼Œè·³è¿‡æ˜¾ç¤º
                if (groupCharacters.length === 0 && !isGroupManageMode) return;
                
                // åˆ›å»ºåˆ†ç»„æ ‡é¢˜
                const groupHeader = document.createElement('div');
                groupHeader.className = `group-header ${group.isDefault ? 'default-group' : 'custom-group'}`;
                
                let interactionIcon = '';
                if (group.canInteract && !group.isDefault) {
                    interactionIcon = '<i class="fas fa-comments group-interaction-icon" title="è¯¥åˆ†ç»„è§’è‰²å¯ä»¥åœ¨åŠ¨æ€ä¸­äº’åŠ¨"></i>';
                }
                
                if (isGroupManageMode) {
                    groupHeader.innerHTML = `
                        <div class="group-title-area">
                            <span class="group-title">${group.name} (${groupCharacters.length})</span>
                            ${interactionIcon}
                            <span class="group-count"></span>
                        </div>
                        <div class="group-manage-actions">
                            ${!group.isDefault ? `
                                <button onclick="editGroup('${group.id}')" class="edit-group-btn" title="ç¼–è¾‘åˆ†ç»„">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button onclick="deleteGroup('${group.id}')" class="delete-group-btn" title="åˆ é™¤åˆ†ç»„">
                                    <i class="fas fa-trash"></i>
                                </button>
                            ` : ''}
                        </div>
                    `;
                } else {
                    const isCollapsed = localStorage.getItem(`group_collapsed_${group.id}`) === 'true';
                    groupHeader.innerHTML = `
                        <div class="group-title-area" onclick="toggleGroupCollapse('${group.id}')">
                            <i class="fas fa-chevron-${isCollapsed ? 'right' : 'down'} group-chevron"></i>
                            <span class="group-title">${group.name}</span>
                            ${interactionIcon}
                            <span class="group-count">${groupCharacters.length}/${groupCharacters.length}</span>
                        </div>
                    `;
                }
                
                contactList.appendChild(groupHeader);
                
                // åˆ›å»ºè§’è‰²å®¹å™¨
                const charactersContainer = document.createElement('div');
                charactersContainer.className = 'group-characters';
                charactersContainer.id = `group-characters-${group.id}`;
                
                // æ£€æŸ¥æ˜¯å¦æŠ˜å 
                const isCollapsed = localStorage.getItem(`group_collapsed_${group.id}`) === 'true';
                if (isCollapsed && !isGroupManageMode) {
                    charactersContainer.style.display = 'none';
                }
                
                // æ¸²æŸ“åˆ†ç»„ä¸­çš„è§’è‰²
                groupCharacters.forEach(character => {
                    const savedSettings = localStorage.getItem(`chatSettings_${character.id}`);
                    const chatSettings = savedSettings ? JSON.parse(savedSettings) : {};
                    const displayName = chatSettings.aiChatNickname || character.name;
                    
                    const contactItem = document.createElement('div');
                    contactItem.className = `contact-item ${isMultiSelectMode && selectedCharacters.includes(character.id) ? 'selected' : ''}`;
                    contactItem.dataset.characterId = character.id;
                    
                    // æ ¹æ®æ¨¡å¼è®¾ç½®ä¸åŒçš„ç‚¹å‡»äº‹ä»¶
                    if (isMultiSelectMode) {
                        contactItem.onclick = () => toggleCharacterSelection(character.id);
                    } else {
                        contactItem.onclick = () => editCharacterFromContactList(character.id);
                        
                        // æ·»åŠ é•¿æŒ‰äº‹ä»¶ï¼ˆæ”¯æŒè§¦æ‘¸å’Œé¼ æ ‡ï¼‰
                        let pressTimer;
                        
                        const startLongPress = (e) => {
                            pressTimer = setTimeout(() => {
                                // é•¿æŒ‰ç›´æ¥å¼¹å‡ºç§»åŠ¨è§’è‰²æ¨¡æ€æ¡†
                                showMoveCharacterModal(character.id);
                                e.preventDefault();
                            }, 800);
                        };
                        
                        const cancelLongPress = () => {
                            clearTimeout(pressTimer);
                        };
                        
                        // è§¦æ‘¸äº‹ä»¶
                        contactItem.addEventListener('touchstart', startLongPress);
                        contactItem.addEventListener('touchend', cancelLongPress);
                        contactItem.addEventListener('touchmove', cancelLongPress);
                        
                        // é¼ æ ‡äº‹ä»¶ï¼ˆä½œä¸ºå¤‡é€‰ï¼‰
                        contactItem.addEventListener('mousedown', startLongPress);
                        contactItem.addEventListener('mouseup', cancelLongPress);
                        contactItem.addEventListener('mouseleave', cancelLongPress);
                        
                        // å³é”®ç‚¹å‡»
                        contactItem.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            // å³é”®ç›´æ¥å¼¹å‡ºç§»åŠ¨è§’è‰²æ¨¡æ€æ¡†
                            showMoveCharacterModal(character.id);
                        });
                    }
                    
                    // ğŸ”¥ã€ä¿®æ”¹ã€‘æ£€æŸ¥æ‹‰é»‘/å±è”½çŠ¶æ€ - ä¿®å¤ç¾¤èŠåˆ¤æ–­é€»è¾‘ + æ·»åŠ è°ƒè¯•
                    let statusIndicator = '';
                    if (character.isGroup === true) {
                        // ç¾¤èŠæ£€æŸ¥å±è”½çŠ¶æ€
                        const isMuted = isGroupMuted(character.id);
                        if (isMuted) {
                            statusIndicator = '<div class="contact-status-indicator muted" title="å·²å±è”½"><i class="fas fa-volume-mute"></i></div>';
                        }
                    } else {
                        // å•èŠæ£€æŸ¥æ‹‰é»‘çŠ¶æ€
                        const isUserBlocked = isBlocked('user', character.id);
                        const isCharacterBlocked = isBlocked(character.id, 'user');



                        if (isUserBlocked) {
                            statusIndicator = '<div class="contact-status-indicator blocked" title="å·²æ‹‰é»‘"><i class="fas fa-ban"></i></div>';
                        } else if (isCharacterBlocked) {
                            statusIndicator = '<div class="contact-status-indicator blocked-by" title="è¢«å¯¹æ–¹æ‹‰é»‘"><i class="fas fa-exclamation-triangle"></i></div>';
                        }
                    }

                    contactItem.innerHTML = `
                        ${isMultiSelectMode ? `
                            <div class="selection-checkbox ${selectedCharacters.includes(character.id) ? 'selected' : ''}">
                                ${selectedCharacters.includes(character.id) ? '<i class="fas fa-check check-icon-white"></i>' : ''}
                            </div>
                        ` : ''}
                        <div class="message-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                            ${character.avatarUrl ? '' : displayName.charAt(0)}
                        </div>
                        <div class="contact-info">
                            <div class="message-name">${displayName}</div>
                            <div class="character-preview">${truncateText(character.bio || 'æš‚æ— äººè®¾æè¿°', 25)}</div>
                        </div>
                        ${statusIndicator}
                        ${isGroupManageMode ? `
                            <div class="move-character-btn" onclick="showMoveCharacterModal('${character.id}')" title="ç§»åŠ¨åˆ°å…¶ä»–åˆ†ç»„">
                                <i class="fas fa-arrows-alt"></i>
                            </div>
                        ` : ''}
                    `;
                    
                    charactersContainer.appendChild(contactItem);
                });
                
                // å¦‚æœåˆ†ç»„æ²¡æœ‰è§’è‰²ï¼Œæ˜¾ç¤ºæç¤º
                if (groupCharacters.length === 0 && isGroupManageMode) {
                    const emptyDiv = document.createElement('div');
                    emptyDiv.className = 'empty-group-message';
                    emptyDiv.textContent = 'è¯¥åˆ†ç»„æš‚æ— è§’è‰²';
                    charactersContainer.appendChild(emptyDiv);
                }
                
                contactList.appendChild(charactersContainer);
            });
            
            // å¦‚æœå®Œå…¨æ²¡æœ‰è§’è‰²ï¼Œæ˜¾ç¤ºæç¤º
            if (characters.length === 0) {
                const emptyDiv = document.createElement('div');
                emptyDiv.className = 'empty-message';
                emptyDiv.textContent = 'è¿˜æ²¡æœ‰è§’è‰²ï¼Œç‚¹å‡»å³ä¸Šè§’+å·åˆ›å»ºè§’è‰²å§ï¼';
                contactList.appendChild(emptyDiv);
            }
        }

        // === åˆ†ç»„ç®¡ç†ç›¸å…³å‡½æ•° ===
        function enterGroupManageMode() {
            isGroupManageMode = true;
            renderContactList();
            
            // éšè—ç®¡ç†åˆ†ç»„æŒ‰é’®
            const groupManageBtn = document.getElementById('group-manage-btn');
            if (groupManageBtn) {
                groupManageBtn.style.display = 'none';
            }
        }

        function exitGroupManageMode() {
            isGroupManageMode = false;
            renderContactList();
            
            // æ˜¾ç¤ºç®¡ç†åˆ†ç»„æŒ‰é’®
            const groupManageBtn = document.getElementById('group-manage-btn');
            if (groupManageBtn) {
                groupManageBtn.style.display = 'flex';
            }
        }

        function toggleGroupCollapse(groupId) {
            const container = document.getElementById(`group-characters-${groupId}`);
            if (!container) return;
            
            const isCollapsed = container.style.display === 'none';
            container.style.display = isCollapsed ? 'block' : 'none';
            
            // ä¿å­˜æŠ˜å çŠ¶æ€
            localStorage.setItem(`group_collapsed_${groupId}`, !isCollapsed);
            
            // æ›´æ–°ç®­å¤´æ–¹å‘
            const chevron = document.querySelector(`[onclick="toggleGroupCollapse('${groupId}')"] .group-chevron`);
            if (chevron) {
                chevron.className = `fas fa-chevron-${isCollapsed ? 'down' : 'right'} group-chevron`;
            }
        }

        function showCreateGroupModal() {
            const modalHtml = `
                <div id="create-group-modal" class="modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">æ–°å»ºåˆ†ç»„</div>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label>åˆ†ç»„åç§°</label>
                                <input type="text" id="new-group-name" class="form-input" placeholder="è¯·è¾“å…¥åˆ†ç»„åç§°" maxlength="10">
                            </div>
                            <div class="form-group">
                                <label>
                                    <input type="checkbox" id="new-group-interaction" class="form-checkbox"> 
                                    å…è®¸è¯¥åˆ†ç»„è§’è‰²åœ¨åŠ¨æ€ä¸­äº’åŠ¨
                                </label>
                                <p class="form-help-text">å¼€å¯åï¼Œè¯¥åˆ†ç»„çš„è§’è‰²å¯ä»¥åœ¨åŠ¨æ€é¡µé¢ç›¸äº’ç‚¹èµã€è¯„è®º</p>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideCreateGroupModal()">å–æ¶ˆ</button>
                            <button class="modal-button modal-primary" onclick="createNewGroup()">åˆ›å»º</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            
            // èšç„¦è¾“å…¥æ¡†
            setTimeout(() => {
                document.getElementById('new-group-name').focus();
            }, 100);
        }

        function hideCreateGroupModal() {
            const modal = document.getElementById('create-group-modal');
            if (modal) modal.remove();
        }

        async function createNewGroup() {
            const nameInput = document.getElementById('new-group-name');
            const interactionCheckbox = document.getElementById('new-group-interaction');
            
            const name = nameInput.value.trim();
            if (!name) {
                alert('è¯·è¾“å…¥åˆ†ç»„åç§°');
                nameInput.focus();
                return;
            }
            
            // æ£€æŸ¥é‡å
            if (characterGroups.find(g => g.name === name)) {
                alert('åˆ†ç»„åç§°å·²å­˜åœ¨');
                nameInput.focus();
                return;
            }
            
            const newGroup = {
                id: 'group_' + Date.now(),
                name: name,
                order: characterGroups.length + 1,
                isDefault: false,
                canInteract: interactionCheckbox.checked
            };
            
            characterGroups.push(newGroup);
            await saveCharacterGroups();
            
            hideCreateGroupModal();
            renderContactList();
            showToast('åˆ†ç»„åˆ›å»ºæˆåŠŸ', 'success');
        }

        function editGroup(groupId) {
            const group = characterGroups.find(g => g.id === groupId);
            if (!group || group.isDefault) return;
            
            const modalHtml = `
                <div id="edit-group-modal" class="modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">ç¼–è¾‘åˆ†ç»„</div>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label>åˆ†ç»„åç§°</label>
                                <input type="text" id="edit-group-name" class="form-input" value="${group.name}" maxlength="10">
                            </div>
                            <div class="form-group">
                                <label>
                                    <input type="checkbox" id="edit-group-interaction" class="form-checkbox" ${group.canInteract ? 'checked' : ''}> 
                                    å…è®¸è¯¥åˆ†ç»„è§’è‰²åœ¨åŠ¨æ€ä¸­äº’åŠ¨
                                </label>
                                <p class="form-help-text">å¼€å¯åï¼Œè¯¥åˆ†ç»„çš„è§’è‰²å¯ä»¥åœ¨åŠ¨æ€é¡µé¢ç›¸äº’ç‚¹èµã€è¯„è®º</p>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideEditGroupModal()">å–æ¶ˆ</button>
                            <button class="modal-button modal-primary" onclick="updateGroup('${groupId}')">ä¿å­˜</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            
            // èšç„¦è¾“å…¥æ¡†
            setTimeout(() => {
                document.getElementById('edit-group-name').focus();
            }, 100);
        }

        function hideEditGroupModal() {
            const modal = document.getElementById('edit-group-modal');
            if (modal) modal.remove();
        }

        async function updateGroup(groupId) {
            const nameInput = document.getElementById('edit-group-name');
            const interactionCheckbox = document.getElementById('edit-group-interaction');
            
            const name = nameInput.value.trim();
            if (!name) {
                alert('è¯·è¾“å…¥åˆ†ç»„åç§°');
                nameInput.focus();
                return;
            }
            
            // æ£€æŸ¥é‡åï¼ˆæ’é™¤è‡ªå·±ï¼‰
            if (characterGroups.find(g => g.name === name && g.id !== groupId)) {
                alert('åˆ†ç»„åç§°å·²å­˜åœ¨');
                nameInput.focus();
                return;
            }
            
            const groupIndex = characterGroups.findIndex(g => g.id === groupId);
            if (groupIndex !== -1) {
                characterGroups[groupIndex].name = name;
                characterGroups[groupIndex].canInteract = interactionCheckbox.checked;
                
                await saveCharacterGroups();
                
                hideEditGroupModal();
                renderContactList();
                showToast('åˆ†ç»„æ›´æ–°æˆåŠŸ', 'success');
            }
        }

        async function deleteGroup(groupId) {
            const group = characterGroups.find(g => g.id === groupId);
            if (!group || group.isDefault) return;
            
            const groupCharacters = characters.filter(char => char.groupId === groupId);
            
            let confirmMsg = `ç¡®å®šè¦åˆ é™¤åˆ†ç»„"${group.name}"å—ï¼Ÿ`;
            if (groupCharacters.length > 0) {
                confirmMsg += `\n\nè¯¥åˆ†ç»„ä¸‹æœ‰ ${groupCharacters.length} ä¸ªè§’è‰²ï¼Œå°†è¢«ç§»åŠ¨åˆ°"æˆ‘çš„å¥½å‹"åˆ†ç»„ã€‚`;
            }
            
            if (!confirm(confirmMsg)) return;
            
            // å°†è¯¥åˆ†ç»„çš„è§’è‰²ç§»åŠ¨åˆ°é»˜è®¤åˆ†ç»„
            groupCharacters.forEach(character => {
                character.groupId = 'my_friends';
            });
            
            // åˆ é™¤åˆ†ç»„
            const groupIndex = characterGroups.findIndex(g => g.id === groupId);
            if (groupIndex !== -1) {
                characterGroups.splice(groupIndex, 1);
            }
            
            await Promise.all([
                saveCharacterGroups(),
                saveCharacters()
            ]);
            
            renderContactList();
            showToast('åˆ†ç»„åˆ é™¤æˆåŠŸ', 'success');
        }

        function showMoveCharacterModal(characterId) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;
            
            const availableGroups = characterGroups.filter(g => g.id !== character.groupId);
            
            const modalHtml = `
                <div id="move-character-modal" class="modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">ç§»åŠ¨è§’è‰²ï¼š${character.name}</div>
                        </div>
                        <div class="modal-body">
                            <div class="group-list">
                                ${availableGroups.map(group => `
                                    <div class="group-option" onclick="moveCharacterToGroup('${characterId}', '${group.id}')">
                                        <span class="group-name">${group.name}</span>
                                        <i class="fas fa-chevron-right"></i>
                                    </div>
                                `).join('')}
                            </div>
                            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #eee;">
                                <div class="group-option" onclick="hideMoveCharacterModal(); enterMultiSelectMode('${characterId}');" style="color: #007AFF;">
                                    <span class="group-name">
                                        <i class="fas fa-check-square" style="margin-right: 6px;"></i>
                                        è¿›å…¥å¤šé€‰æ¨¡å¼
                                    </span>
                                    <i class="fas fa-chevron-right"></i>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideMoveCharacterModal()">å–æ¶ˆ</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        function hideMoveCharacterModal() {
            const modal = document.getElementById('move-character-modal');
            if (modal) modal.remove();
        }

        async function moveCharacterToGroup(characterId, targetGroupId) {
            const characterIndex = characters.findIndex(c => c.id === characterId);
            if (characterIndex !== -1) {
                const oldGroupId = characters[characterIndex].groupId;
                characters[characterIndex].groupId = targetGroupId;
                
                await saveCharacters();
                hideMoveCharacterModal();
                renderContactList();
                
                const targetGroup = characterGroups.find(g => g.id === targetGroupId);
                showToast(`å·²ç§»åŠ¨åˆ°"${targetGroup.name}"åˆ†ç»„`, 'success');
            }
        }

        function showMoveToGroupModal() {
            if (selectedCharacters.length === 0) {
                alert('è¯·å…ˆé€‰æ‹©è¦ç§»åŠ¨çš„è§’è‰²');
                return;
            }
            
            const modalHtml = `
                <div id="move-to-group-modal" class="modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">ç§»åŠ¨ ${selectedCharacters.length} ä¸ªè§’è‰²åˆ°åˆ†ç»„</div>
                        </div>
                        <div class="modal-body">
                            <div class="group-list">
                                ${characterGroups.map(group => `
                                    <div class="group-option" onclick="moveSelectedCharactersToGroup('${group.id}')">
                                        <span class="group-name">${group.name}</span>
                                        <i class="fas fa-chevron-right"></i>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideMoveToGroupModal()">å–æ¶ˆ</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        function hideMoveToGroupModal() {
            const modal = document.getElementById('move-to-group-modal');
            if (modal) modal.remove();
        }

        async function moveSelectedCharactersToGroup(targetGroupId) {
            selectedCharacters.forEach(characterId => {
                const characterIndex = characters.findIndex(c => c.id === characterId);
                if (characterIndex !== -1) {
                    characters[characterIndex].groupId = targetGroupId;
                }
            });
            
            await saveCharacters();
            hideMoveToGroupModal();
            exitMultiSelectMode(); // é€€å‡ºå¤šé€‰æ¨¡å¼
            
            const targetGroup = characterGroups.find(g => g.id === targetGroupId);
            showToast(`å·²ç§»åŠ¨ ${selectedCharacters.length} ä¸ªè§’è‰²åˆ°"${targetGroup.name}"åˆ†ç»„`, 'success');
        }
        
        // æ¸²æŸ“è§’è‰²åˆ—è¡¨
        function renderCharacterList() {
            const characterList = document.getElementById('character-list');
            // æ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨å°±è·³è¿‡ï¼ˆå› ä¸ºæˆ‘ä»¬å·²ç»åˆ é™¤äº†äººç‰©åº”ç”¨ï¼‰
            if (!characterList) {
                console.log('character-listå…ƒç´ ä¸å­˜åœ¨ï¼Œè·³è¿‡æ¸²æŸ“');
                return;
            }
            
            characterList.innerHTML = '';
            
            characters.forEach(character => {
                const characterItem = document.createElement('div');
                characterItem.className = 'character-item';
                characterItem.onclick = () => editCharacter(character.id);
                
                characterItem.innerHTML = `
                    <div class="character-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                        ${character.avatarUrl ? '' : character.name.charAt(0)}
                    </div>
                    <div class="character-info">
                        <div class="character-name">${character.name}</div>
                        <div class="character-bio">${truncateText(character.bio, 50)}</div>
                    </div>
                `;
                
                characterList.appendChild(characterItem);
            });
        }
        

        
        // å½“å‰æ˜¾ç¤ºçš„æ¶ˆæ¯æ•°é‡é™åˆ¶
        let currentMessageOffset = 0;
        const MESSAGE_LIMIT = 50;
        
        // ğŸ”¥ã€æ–°å¢ã€‘åŒæ­¥åŒ…è£…å‡½æ•°ï¼Œç”¨äºå‘åå…¼å®¹
        function renderChatMessages(characterId, loadMore = false) {
            renderChatMessagesAsync(characterId, loadMore).catch(error => {
                console.error('æ¸²æŸ“èŠå¤©æ¶ˆæ¯å¤±è´¥:', error);
            });
        }

        // æ¸²æŸ“èŠå¤©æ¶ˆæ¯ï¼ˆå¼‚æ­¥ç‰ˆæœ¬ï¼‰
        async function renderChatMessagesAsync(characterId, loadMore = false) {
            const messagesContainer = document.getElementById('api-chat-messages');
            const allMessages = chatMessages[characterId] || [];
            const chatSettings = await getAsyncChatSettings(characterId); // ğŸ”¥ã€ä¿®å¤ã€‘ä½¿ç”¨å¼‚æ­¥ç‰ˆæœ¬ç¡®ä¿è·å–æ­£ç¡®çš„è®¾ç½®
            
            if (!loadMore) {
                // é‡æ–°æ¸²æŸ“æ—¶æ¸…ç©ºå®¹å™¨å¹¶é‡ç½®åç§»é‡
                messagesContainer.innerHTML = '';
                currentMessageOffset = Math.max(0, allMessages.length - MESSAGE_LIMIT);
            }
            
            // åº”ç”¨èŠå¤©èƒŒæ™¯
            applyChatBackground();

            // ğŸ”¥ã€ä¿®å¤ã€‘ç¡®ä¿æ°”æ³¡æ ·å¼åœ¨æ¶ˆæ¯æ¸²æŸ“å‰åº”ç”¨
            applyBubbleStyle();
            
            // å¦‚æœæ²¡æœ‰æ¶ˆæ¯ï¼Œæ˜¾ç¤ºç©ºçŠ¶æ€æç¤º
            if (allMessages.length === 0) {
                const displayName = chatSettings.aiChatNickname || currentChatCharacter.name;
                const emptyState = document.createElement('div');
                emptyState.className = 'empty-chat-state';
                emptyState.innerHTML = `
                    <div>å¼€å§‹å’Œ ${displayName} èŠå¤©å§</div>
                `;
                messagesContainer.appendChild(emptyState);
                return;
            }
            
            // å¦‚æœä¸æ˜¯åŠ è½½æ›´å¤šï¼Œä¸”æœ‰æ›´å¤šå†å²æ¶ˆæ¯ï¼Œæ˜¾ç¤º"æŸ¥çœ‹å†å²æ¶ˆæ¯"æŒ‰é’®
            if (!loadMore && currentMessageOffset > 0) {
                const loadMoreBtn = document.createElement('div');
                loadMoreBtn.className = 'load-more-messages';
                loadMoreBtn.innerHTML = `
                    <div class="load-more-content">
                        <i class="fas fa-chevron-up"></i>
                        <span>æŸ¥çœ‹å†å²æ¶ˆæ¯ (${currentMessageOffset}æ¡)</span>
                    </div>
                `;
                loadMoreBtn.onclick = () => loadMoreMessages(characterId);
                messagesContainer.appendChild(loadMoreBtn);
            }
            
            // ğŸ”¥ã€ä¿®å¤ã€‘è¿‡æ»¤æ‰çº¿ä¸‹æ¨¡å¼çš„æ¶ˆæ¯ï¼Œä¸åœ¨çº¿ä¸ŠèŠå¤©ç•Œé¢æ˜¾ç¤º
            const onlineMessages = allMessages.filter(msg => !msg.isOfflineMode);

            // é‡æ–°è®¡ç®—åç§»é‡ï¼ŒåŸºäºè¿‡æ»¤åçš„æ¶ˆæ¯
            const adjustedOffset = loadMore ?
                Math.max(0, onlineMessages.length - MESSAGE_LIMIT) :
                Math.max(0, onlineMessages.length - MESSAGE_LIMIT);

            // è·å–è¦æ˜¾ç¤ºçš„æ¶ˆæ¯
            const messagesToShow = loadMore ?
                onlineMessages.slice(Math.max(0, adjustedOffset - MESSAGE_LIMIT), adjustedOffset) :
                onlineMessages.slice(adjustedOffset);
            
            // è·å–æ—¶é—´æˆ³è®¾ç½®
            const timestampEnabled = chatSettings.timestampEnabled !== false; // é»˜è®¤ä¸ºtrue
            const timestampPosition = chatSettings.timestampPosition || 'center';
            
            let lastTimestamp = 0;
            
            messagesToShow.forEach((message, index) => {
                // å¤„ç†ç³»ç»Ÿæ¶ˆæ¯ï¼ˆå¦‚æˆ³ä¸€æˆ³ã€å¤´åƒæ›´æ¢ã€æ’¤å›ç­‰ï¼‰
                if (message.sender === 'system') {
                    // ğŸ”¥ã€ç§»é™¤ã€‘ä¸å†å¤„ç†æ‹‰é»‘ç³»ç»Ÿæ¶ˆæ¯ï¼Œå› ä¸ºå®ƒä»¬ä¸å†ä¿å­˜åˆ°èŠå¤©è®°å½•ä¸­
                    // æ‹‰é»‘æç¤ºç°åœ¨ç”± addBlockedIndicatorToMessage å‡½æ•°ç›´æ¥åœ¨æ¯æ¡æ¶ˆæ¯ä¸‹æ–¹æ·»åŠ 

                    if (message.isPoke) {
                    const systemContainer = document.createElement('div');
                    systemContainer.className = 'poke-system-container';
                    const systemMessage = document.createElement('div');
                    systemMessage.className = 'poke-system-message';
                    systemMessage.textContent = message.content;
                    systemContainer.appendChild(systemMessage);
                    messagesContainer.appendChild(systemContainer);
                    } else if (message.type === 'recalled_message') {
                        // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†æ’¤å›æ¶ˆæ¯çš„æ˜¾ç¤º
                        const centerContainer = document.createElement('div');
                        centerContainer.style.display = 'flex';
                        centerContainer.style.justifyContent = 'center';
                        centerContainer.style.margin = '4px 0';
                        centerContainer.dataset.messageId = message.id; // ğŸ”¥ã€ä¿®å¤ã€‘æ·»åŠ æ¶ˆæ¯IDä»¥æ”¯æŒé€‰æ‹©
                        
                        const recallElement = document.createElement('div');
                        recallElement.className = 'recalled-message';
                        
                        // è§£ææ’¤å›æ¶ˆæ¯å†…å®¹ï¼ˆæ ¼å¼ï¼šxxx æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯\nåŸæ–‡ï¼šxxxï¼‰
                        const lines = message.content.split('\n');
                        const mainText = lines[0]; // ä¸»è¦æç¤ºæ–‡å­—
                        const originalText = lines[1]; // åŸæ–‡éƒ¨åˆ†
                        
                        recallElement.textContent = mainText;
                        
                        // å¦‚æœæœ‰åŸæ–‡ï¼Œæ·»åŠ åŸæ–‡æ˜¾ç¤º
                        if (originalText && originalText.startsWith('åŸæ–‡ï¼š')) {
                            const originalDiv = document.createElement('div');
                            originalDiv.className = 'original-text';
                            originalDiv.textContent = originalText;
                            recallElement.appendChild(originalDiv);
                        }
                        
                        centerContainer.appendChild(recallElement);
                        messagesContainer.appendChild(centerContainer);
                        
                        // ğŸ”¥ã€ä¿®å¤ã€‘ä¸ºæ’¤å›æ¶ˆæ¯æ·»åŠ é€‰æ‹©åŠŸèƒ½
                        addMessageLongPressListener(centerContainer, message.id);
                    } else if (message.type === 'call_record') {
                        // å¤„ç†é€šè¯è®°å½•æ¶ˆæ¯
                        const centerContainer = document.createElement('div');
                        centerContainer.className = 'message-wrapper system';
                        centerContainer.dataset.messageId = message.id;
                        
                        const callRecordElement = document.createElement('div');
                        callRecordElement.className = 'call-record-message';
                        
                        // æ ¹æ®é€šè¯çŠ¶æ€è®¾ç½®ä¸åŒçš„å›¾æ ‡å’Œæ ·å¼
                        const callIcon = document.createElement('i');
                        
                        if (message.callType === 'outgoing') {
                            callIcon.className = 'fas fa-phone-alt';
                        } else if (message.callType === 'incoming') {
                            if (message.callStatus === 'rejected') {
                                callIcon.className = 'fas fa-phone-slash';
                                callRecordElement.classList.add('missed');
                            } else {
                                callIcon.className = 'fas fa-phone';
                            }
                        } else if (message.callType === 'ended') {
                            callIcon.className = 'fas fa-phone';
                            callRecordElement.classList.add('completed');
                        }
                        
                        callRecordElement.appendChild(callIcon);
                        
                        const callTextElement = document.createElement('span');
                        callTextElement.textContent = message.content;
                        callRecordElement.appendChild(callTextElement);
                        
                        // å¦‚æœæœ‰é€šè¯æ—¶é•¿ï¼Œåˆ™æ˜¾ç¤ºï¼ˆä»…åœ¨callTypeä¸ºendedæ—¶æ˜¾ç¤ºï¼‰
                        if (message.duration && message.callType === 'ended') {
                            const durationElement = document.createElement('span');
                            durationElement.className = 'call-record-duration';
                            durationElement.textContent = message.duration;
                            callRecordElement.appendChild(durationElement);
                        }
                        
                        centerContainer.appendChild(callRecordElement);
                        messagesContainer.appendChild(centerContainer);
                    } else if (message.type === 'call_message') {
                        // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†é€šè¯æ¶ˆæ¯ - æ˜¾ç¤ºä¸ºç®€å•çš„æ–‡æœ¬æ¶ˆæ¯
                        const centerContainer = document.createElement('div');
                        centerContainer.className = 'message-wrapper system';
                        centerContainer.dataset.messageId = message.id;
                        
                        const callMessageElement = document.createElement('div');
                        callMessageElement.className = 'system-message';
                        callMessageElement.style.fontStyle = 'italic';
                        callMessageElement.style.color = '#888';
                        callMessageElement.textContent = `ğŸ“ é€šè¯: ${message.content}`;
                        
                        centerContainer.appendChild(callMessageElement);
                        messagesContainer.appendChild(centerContainer);
                    } else {
                        // ğŸ”¥ã€ä¿®å¤ã€‘å…¶ä»–ç³»ç»Ÿæ¶ˆæ¯ï¼ˆå¦‚å¤´åƒæ›´æ¢ï¼‰- ä½¿ç”¨å±…ä¸­å®¹å™¨
                        const centerContainer = document.createElement('div');
                        centerContainer.style.display = 'flex';
                        centerContainer.style.justifyContent = 'center';
                        centerContainer.style.margin = '4px 0';

                        const systemContainer = document.createElement('div');
                        // ğŸ”¥ã€ç¾åŒ–ã€‘æ£€æŸ¥æ˜¯å¦ä¸ºå¥½å‹æ·»åŠ æˆåŠŸæ¶ˆæ¯ï¼Œåº”ç”¨ç‰¹æ®Šæ ·å¼
                        if (message.isFriendAddedMessage) {
                            systemContainer.className = 'friend-added-system-message';
                        } else {
                            systemContainer.className = 'system-message';
                        }
                        systemContainer.textContent = message.content;

                        centerContainer.appendChild(systemContainer);
                        messagesContainer.appendChild(centerContainer);
                    }
                    return;
                }
                
                // æ·»åŠ å±…ä¸­æ—¶é—´æˆ³ï¼ˆå¦‚æœå¯ç”¨ä¸”ä½ç½®ä¸ºå±…ä¸­ï¼‰
                if (timestampEnabled && timestampPosition === 'center') {
                    const currentTime = new Date(message.timestamp);
                    const timeDiff = currentTime - lastTimestamp;
                    
                    // å¦‚æœè·ç¦»ä¸Šæ¡æ¶ˆæ¯è¶…è¿‡5åˆ†é’Ÿï¼Œæ˜¾ç¤ºæ—¶é—´æˆ³
                    if (index === 0 || timeDiff > 5 * 60 * 1000) {
                        const timestampDiv = document.createElement('div');
                        timestampDiv.className = 'timestamp timestamp-center';
                        timestampDiv.textContent = formatTimestamp(message.timestamp);
                        messagesContainer.appendChild(timestampDiv);
                        lastTimestamp = currentTime;
                    }
                }
                
                const messageContainer = document.createElement('div');
                // æ£€æŸ¥æ˜¯å¦æ˜¯çº¯è¡¨æƒ…åŒ…æ¶ˆæ¯
                const isEmojiOnly = message.isEmoji && !message.content;
                messageContainer.className = `message-container ${message.sender}${chatSettings.hideAvatars ? ' no-avatar' : ''}${isEmojiOnly ? ' emoji-only' : ''}`;
                messageContainer.dataset.messageId = message.id; // æ·»åŠ æ¶ˆæ¯IDæ•°æ®å±æ€§
                
                if (message.sender === 'received') {
                    // ==== ç¾¤èŠæ”¯æŒ ====
                    let character = characters.find(c => c.id === characterId);
                    let isGroup = false;
                    let group = null;
                    if (!character) {
                        group = groupChats.find(g => g.id === characterId);
                        if (group) {
                            isGroup = true;
                        }
                    }
                    
                    let displayAvatar = '';
                    let displayName = '';
                    let color = '#4CAF50';
                    
                    if (isGroup && group) {
                        // ç¾¤èŠï¼šæ ¹æ®æ¶ˆæ¯çš„senderIdæˆ–nameæŸ¥æ‰¾æˆå‘˜
                        let member = null;
                        console.log('ğŸ” [æ¶ˆæ¯æ¸²æŸ“] ç¾¤èŠæ¶ˆæ¯æ¸²æŸ“ - senderId:', message.senderId, 'name:', message.name);
                        console.log('ğŸ” [æ¶ˆæ¯æ¸²æŸ“] ç¾¤æˆå‘˜åˆ—è¡¨:', group.members);
                        console.log('ğŸ” [æ¶ˆæ¯æ¸²æŸ“] å®Œæ•´æ¶ˆæ¯å¯¹è±¡:', message);

                        // è¡¨æƒ…åŒ…æ¶ˆæ¯å¤„ç†

                        if (message.senderId) {
                            member = group.members.find(m => m.id === message.senderId);
                            console.log('ğŸ” [æ¶ˆæ¯æ¸²æŸ“] é€šè¿‡senderIdæ‰¾åˆ°æˆå‘˜:', member);
                            console.log('ğŸ” [æ¶ˆæ¯æ¸²æŸ“] senderIdæŸ¥æ‰¾è¯¦æƒ…:', {
                                messageSenderId: message.senderId,
                                memberIds: group.members.map(m => m.id),
                                foundMember: member
                            });
                        } else if (message.name) {
                            member = group.members.find(m => m.name === message.name);
                            console.log('ğŸ” [æ¶ˆæ¯æ¸²æŸ“] é€šè¿‡nameæ‰¾åˆ°æˆå‘˜:', member);
                            console.log('ğŸ” [æ¶ˆæ¯æ¸²æŸ“] nameæŸ¥æ‰¾è¯¦æƒ…:', {
                                messageName: message.name,
                                memberNames: group.members.map(m => m.name),
                                foundMember: member
                            });
                        }

                        // ğŸ”¥ã€ä¿®å¤ã€‘ç¡®ä¿ç¾¤èŠè¡¨æƒ…åŒ…æ¶ˆæ¯æ­£ç¡®æ˜¾ç¤ºå‘é€è€…
                        if (member) {
                            displayAvatar = member.avatarUrl || '';
                            displayName = member.name;
                            color = member.color || '#4CAF50';
                        } else {
                            // å¦‚æœæ²¡æ‰¾åˆ°æˆå‘˜ï¼Œä½¿ç”¨æ¶ˆæ¯ä¸­çš„nameä½œä¸ºæ˜¾ç¤ºåç§°
                            displayAvatar = '';
                            displayName = message.name || 'ç¾¤æˆå‘˜';
                            color = '#4CAF50';
                            console.warn('ğŸ” [æ¶ˆæ¯æ¸²æŸ“] æœªæ‰¾åˆ°ç¾¤æˆå‘˜ï¼Œä½¿ç”¨æ¶ˆæ¯name:', message.name);
                        }

                        // å¤´åƒå’Œæ˜¾ç¤ºåå¤„ç†å®Œæˆ
                    } else if (character) {
                        // å•èŠ
                        displayAvatar = chatSettings.aiDynamicAvatar || chatSettings.aiChatAvatar || character.avatarUrl;
                        displayName = chatSettings.aiChatNickname || character.name;
                        color = character.color || '#4CAF50';
                    
                    // å¤´åƒé€‰æ‹©é€»è¾‘
                    } else {
                        // å…œåº•ï¼Œé˜²æ­¢æŠ¥é”™
                        displayAvatar = '';
                        displayName = 'æœªçŸ¥';
                        color = '#4CAF50';
                    }
                    
                    // ğŸ”¥ã€æ–°å¢ã€‘è·å–æ°”æ³¡æ ·å¼ - ç¾¤èŠä¸­ä½¿ç”¨æˆå‘˜ä¸“å±é¢œè‰²
                    let bubbleColor = chatSettings.aiBubbleColor || '#f0f0f0';
                    
                    // å¦‚æœæ˜¯ç¾¤èŠä¸”æœ‰æˆå‘˜ä¸“å±é¢œè‰²è®¾ç½®ï¼Œä½¿ç”¨æˆå‘˜ä¸“å±é¢œè‰²
                    if (isGroup && group && message.senderId && chatSettings.memberBubbleColors) {
                        const memberColor = chatSettings.memberBubbleColors[message.senderId];
                        if (memberColor) {
                            bubbleColor = memberColor;
                        }
                    }
                    
                    const bubbleOpacity = chatSettings.aiBubbleOpacity || '1';
                    const textColor = isLightColor(bubbleColor) ? '#333' : '#fff';
                    const bubblePadding = chatSettings.bubblePadding || '12';
                    
                    // å°†é€æ˜åº¦åº”ç”¨åˆ°èƒŒæ™¯è‰²è€Œä¸æ˜¯æ•´ä¸ªå…ƒç´ 
                    const transparentBubbleColor = convertColorWithOpacity(bubbleColor, bubbleOpacity);
                    
                    // ğŸ”¥ å¤„ç†ç‰¹æ®Šæ¶ˆæ¯ç±»å‹
                    let messageContent = '';
                    
                    if (message.type === 'user_photo') {
                        // è§’è‰²å‘é€çš„"ä¼ªç…§ç‰‡" - ä½¿ç”¨ä¸ç”¨æˆ·ç›¸åŒçš„ç»“æ„
                        messageContent = `
                            <div class="dreamy-photo-container" onclick="togglePhotoText(this, '${(message.photoDescription || message.content).replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')">
                                <div class="dreamy-photo">
                                    <div class="photo-misty-bg"></div>
                                    <div class="photo-badge">
                                        <i class="fas fa-image"></i>
                                    </div>
                                    <div class="sparkle-container">
                                        <div class="sparkle sparkle-1">âœ¨</div>
                                        <div class="sparkle sparkle-2">â­</div>
                                        <div class="sparkle sparkle-3">âœ¨</div>
                                        <div class="sparkle sparkle-4">â­</div>
                                        <div class="sparkle sparkle-5">ğŸ’«</div>
                                    </div>
                                    <div class="photo-text-overlay" style="display: none;">
                                        <div class="photo-description">${(message.photoDescription || message.content)}</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'location') {
                        // è§’è‰²å‘é€çš„ä½ç½®æ¶ˆæ¯ - ä½¿ç”¨ä¸ç”¨æˆ·ç›¸åŒçš„ç»“æ„
                        messageContent = `
                            <div class="location-card" onclick="showLocationDetail('${message.locationName}')">
                                <div class="location-card-header">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
                                        <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                    </svg>
                                    ${message.locationName}
                                </div>
                                <div class="location-card-map">
                                    <div class="map-background"></div>
                                    <div class="map-roads">
                                        <div class="road road-horizontal" style="top: 35%; width: 100%;"></div>
                                        <div class="road road-vertical" style="left: 40%; height: 100%;"></div>
                                        <div class="road road-horizontal" style="top: 65%; width: 70%; left: 30%;"></div>
                                    </div>
                                    <div class="map-buildings">
                                        <div class="building" style="top: 15%; left: 20%; width: 12px; height: 10px;"></div>
                                        <div class="building" style="top: 25%; left: 60%; width: 14px; height: 12px;"></div>
                                        <div class="building green" style="top: 50%; left: 15%; width: 8px; height: 8px;"></div>
                                        <div class="building" style="top: 70%; left: 70%; width: 10px; height: 8px;"></div>
                                        <div class="building green" style="top: 10%; left: 75%; width: 6px; height: 6px;"></div>
                                        <div class="building green" style="top: 75%; left: 25%; width: 7px; height: 7px;"></div>
                                    </div>
                                    <div class="map-marker">
                                        <div class="marker-pin">
                                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                                                <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                            </svg>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'voice_message') {
                        // è¿‡æ»¤æ‰æ‹¬å·ä¸­çš„æè¿°æ€§å†…å®¹ï¼Œä¿ç•™å®é™…è¯´è¯å†…å®¹
                        const cleanVoiceContent = message.content.replace(/\([^)]*\)\s*/g, '').trim();
                        const voiceDuration = message.duration || Math.max(1, Math.ceil(cleanVoiceContent.length / 8));
                        
                        // AIè¯­éŸ³æ¶ˆæ¯ - ä½¿ç”¨å’Œç”¨æˆ·è¯­éŸ³æ¶ˆæ¯ä¸€æ ·çš„ç»“æ„
                        messageContent = `
                            <div class="voice-message-container received">
                                <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                                    <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${cleanVoiceContent}">
                                        <div class="voice-wave">
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                        </div>
                                        <div class="voice-duration">${voiceDuration}"</div>
                                    ${message.edited ? `<div class="message-edited-indicator">å·²ç¼–è¾‘</div>` : ""}
                                    </div>
                                </div>
                                <div class="voice-text-content">${cleanVoiceContent}</div>
                            </div>
                        `;
                    } else if (message.type === 'ai_image') {
                        // AIç”Ÿæˆçš„å›¾ç‰‡ - ä½¿ç”¨æ˜Ÿæ˜Ÿemojiå¡ç‰‡æ ·å¼
                        const imageDesc = message.imageDescription || message.content || 'AIæè¿°çš„å›¾ç‰‡';
                        messageContent = `
                            <div class="dreamy-photo-container" onclick="togglePhotoText(this, '${imageDesc.replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')">
                                <div class="dreamy-photo">
                                    <div class="photo-misty-bg"></div>
                                    <div class="photo-badge">
                                        <i class="fas fa-image"></i>
                                    </div>
                                    <div class="sparkle-container">
                                        <div class="sparkle sparkle-1">âœ¨</div>
                                        <div class="sparkle sparkle-2">â­</div>
                                        <div class="sparkle sparkle-3">âœ¨</div>
                                        <div class="sparkle sparkle-4">â­</div>
                                        <div class="sparkle sparkle-5">ğŸ’«</div>
                                    </div>
                                    <div class="photo-text-overlay" style="display: none;">
                                        <div class="photo-description">${imageDesc}</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'transfer') {
                        // è½¬è´¦æ¶ˆæ¯
                        const isUser = message.role === 'user';
                        const heartIcon = isUser ? 'ğŸ’•' : 'ğŸ’–';
                        const titleText = isUser ? 'ä½ å‘èµ·çš„è½¬è´¦' : 'æ”¶åˆ°è½¬è´¦';
                        let cardClass = '';
                        let statusHtml = '';
                        let clickHandler = '';
                        
                        if (message.status === 'accepted') {
                            statusHtml = `<div class="transfer-status">${isUser ? 'å¯¹æ–¹å·²æ”¶æ¬¾' : 'å·²æ”¶æ¬¾'}</div>`;
                            cardClass = 'accepted';
                        } else if (message.status === 'rejected') {
                            statusHtml = `<div class="transfer-status">${isUser ? 'å¯¹æ–¹å·²é€€å›' : 'å·²é€€å›'}</div>`;
                            cardClass = 'rejected';
                        } else if (!isUser) {
                            // AIå‘æ¥çš„è½¬è´¦ä¸”æœªå¤„ç†ï¼Œæ·»åŠ ç‚¹å‡»å¤„ç†
                            clickHandler = `onclick="showTransferConfirmDialog(${JSON.stringify(message).replace(/"/g, '&quot;')})"`;
                        }
                        
                        messageContent = `
                            <div class="transfer-message-container received">
                                <div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}" ${clickHandler}>
                                    <div class="transfer-title">${heartIcon} ${titleText}</div>
                                    <div class="transfer-amount">Â¥ ${Number(message.amount).toFixed(2)}</div>
                                    <div class="transfer-note">${message.note || 'è½¬è´¦'}</div>
                                    ${statusHtml}
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'friend_request') {
                        // ğŸ”¥ã€æ–°å¢ã€‘AIä¸»åŠ¨å‘é€çš„å¥½å‹ç”³è¯·
                        messageContent = `
                            <div class="friend-request-container">
                                <div class="friend-request-card">
                                    <div class="friend-request-icon">ğŸ‘‹</div>
                                    <div class="friend-request-title">å¥½å‹ç”³è¯·</div>
                                    <div class="friend-request-message">${message.message || 'æƒ³å’Œä½ é‡æ–°åšæœ‹å‹'}</div>
                                    <div class="friend-request-actions">
                                        <button class="friend-request-btn accept" onclick="handleAIFriendRequest('${currentChatCharacter?.id}', true, '${message.id}')">åŒæ„</button>
                                        <button class="friend-request-btn reject" onclick="handleAIFriendRequest('${currentChatCharacter?.id}', false, '${message.id}')">æ‹’ç»</button>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        // æ™®é€šæ–‡æœ¬æ¶ˆæ¯
                        const chatMode = chatSettings.chatMode || 'online';
                        let processedContent = message.content;

                        if (chatMode === 'offline') {
                            processedContent = processOfflineContent(message.content);
                        }

                        // å¤„ç†@å†…å®¹
                        processedContent = processMentions(processedContent);

                        // å¦‚æœæœ‰å¼•ç”¨æ¶ˆæ¯ï¼Œåœ¨å†…å®¹å‰æ·»åŠ å¼•ç”¨æ˜¾ç¤º
                        if (message.replyTo) {
                            messageContent = generateReplyHTML(message.replyTo) + processedContent;
                        } else {
                            messageContent = processedContent;
                        }
                    }
                    
                    let avatarHtml = '';
                    if (!chatSettings.hideAvatars) {
                        avatarHtml = `
                            <div class="message-avatar" style="background-color: ${color}; ${displayAvatar ? `background-image: url(${displayAvatar}); background-size: cover; background-position: center;` : ''}" ${character ? `onclick="pokeCharacter('${character.id}')" title="æˆ³ä¸€æˆ³"` : `title="${displayName}"`}>
                                ${displayAvatar ? '' : displayName.charAt(0)}
                                ${timestampEnabled && timestampPosition === 'avatar' ? `<div class="timestamp timestamp-avatar">${formatTimeOnly(message.timestamp)}</div>` : ''}
                            </div>
                        `;
                    }
                    
                    let bubbleHtml = '';
                    if (message.type === 'voice_message' || message.type === 'transfer' || message.type === 'user_photo' || message.type === 'location' || message.type === 'ai_image' || message.type === 'friend_request') {
                        // è¯­éŸ³æ¶ˆæ¯ã€è½¬è´¦æ¶ˆæ¯ã€ç…§ç‰‡ã€ä½ç½®æ¶ˆæ¯å’ŒAIå›¾ç‰‡æ¶ˆæ¯ä¸éœ€è¦é¢å¤–çš„æ°”æ³¡åŒ…è£¹
                        bubbleHtml = messageContent;
                    } else {
                        // æ™®é€šæ¶ˆæ¯ç”¨æ°”æ³¡åŒ…è£¹
                        bubbleHtml = `
                                                    <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                                ${messageContent}
                                ${message.image && !message.type ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}
                                ${message.edited ? `<div class="message-edited-indicator">å·²ç¼–è¾‘</div>` : ''}
                                ${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                ${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}
                            </div>
                    `;
                    }
                    
      // ğŸ”¥ã€ä¿®å¤ã€‘ç¾¤èŠæ˜µç§°æ˜¾ç¤º - ç‰¹åˆ«å¤„ç†è¯­éŸ³æ¶ˆæ¯ã€è½¬è´¦æ¶ˆæ¯ã€ç…§ç‰‡å¡ç‰‡å’Œä½ç½®ä¿¡æ¯
      if (isGroup && group && displayName !== 'ç¾¤æˆå‘˜') {
    messageContainer.classList.add('group-message-item');
    const senderNameHtml = `<div class="sender-name">${displayName}</div>`;

    if (message.type === 'voice_message' || message.type === 'transfer' || message.type === 'ai_image' || message.type === 'user_photo' || message.type === 'location' || message.type === 'friend_request') {
        // ğŸ”¥ã€ä¿®å¤ã€‘å¯¹äºè¯­éŸ³æ¶ˆæ¯ã€è½¬è´¦æ¶ˆæ¯ã€AIå›¾ç‰‡æ¶ˆæ¯ã€ç…§ç‰‡å¡ç‰‡å’Œä½ç½®ä¿¡æ¯ï¼Œæ˜µç§°éœ€è¦åœ¨å®¹å™¨å¤–éƒ¨
    messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    } else {
        // æ™®é€šæ¶ˆæ¯çš„å¤„ç†ï¼ˆåŒ…æ‹¬è¡¨æƒ…åŒ…æ¶ˆæ¯ï¼‰
        messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    }
} else {
                    messageContainer.innerHTML = avatarHtml + bubbleHtml;
}
                } else {
                    // è·å–æˆ‘çš„æ˜¾ç¤ºå¤´åƒå’Œæ°”æ³¡æ ·å¼
let myDisplayAvatar = chatSettings.myChatAvatar; // ä¼˜å…ˆä½¿ç”¨èŠå¤©ä¸“å±è®¾ç½®é‡Œçš„å¤´åƒ
let myDisplayName = chatSettings.myChatNickname; // ä¼˜å…ˆä½¿ç”¨èŠå¤©ä¸“å±è®¾ç½®é‡Œçš„æ˜µç§°
                    
// å¦‚æœä¸“å±è®¾ç½®é‡Œæ²¡æœ‰ï¼Œåˆ™è¿›è¡ŒäºŒæ¬¡æŸ¥æ‰¾ï¼ˆä½œä¸ºä¿é™©æªæ–½ï¼‰
if ((!myDisplayAvatar || !myDisplayName) && chatSettings.selectedIdentityId) {
                        const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
    if (selectedPersona) {
        // å¦‚æœå¤´åƒä¸ºç©ºï¼Œåˆ™ä½¿ç”¨èº«ä»½å¤´åƒ
        if (!myDisplayAvatar) myDisplayAvatar = selectedPersona.avatarUrl;
        // å¦‚æœæ˜µç§°ä¸ºç©ºï¼Œåˆ™ä½¿ç”¨èº«ä»½æ˜µç§°
        if (!myDisplayName) myDisplayName = selectedPersona.name;
                        }
                    }
                    
                    const myBubbleColor = chatSettings.myBubbleColor || '#007AFF';
                    const myBubbleOpacity = chatSettings.myBubbleOpacity || '1';
                    const myTextColor = isLightColor(myBubbleColor) ? '#333' : '#fff';
                    const myBubblePadding = chatSettings.bubblePadding || '12';
                    
                    // å°†é€æ˜åº¦åº”ç”¨åˆ°èƒŒæ™¯è‰²è€Œä¸æ˜¯æ•´ä¸ªå…ƒç´ 
                    const transparentMyBubbleColor = convertColorWithOpacity(myBubbleColor, myBubbleOpacity);
                    
                    // å¤„ç†ç”¨æˆ·çš„ç‰¹æ®Šæ¶ˆæ¯ç±»å‹
                    let myMessageContent = '';
                    if (message.type === 'user_photo') {
                        // ç”¨æˆ·å‘é€çš„"ç…§ç‰‡"ï¼ˆæ–‡å­—æè¿°ï¼‰
                        myMessageContent = `
                            <div class="dreamy-photo-container" onclick="togglePhotoText(this, '${(message.photoDescription || message.content).replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')">
                                <div class="dreamy-photo">
                                    <div class="photo-misty-bg"></div>
                                    <div class="photo-badge">
                                        <i class="fas fa-image"></i>
                                    </div>
                                    <div class="sparkle-container">
                                        <div class="sparkle sparkle-1">âœ¨</div>
                                        <div class="sparkle sparkle-2">â­</div>
                                        <div class="sparkle sparkle-3">âœ¨</div>
                                        <div class="sparkle sparkle-4">â­</div>
                                        <div class="sparkle sparkle-5">ğŸ’«</div>
                                    </div>
                                    <div class="photo-text-overlay" style="display: none;">
                                        <div class="photo-description">${(message.photoDescription || message.content)}</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'voice') {
                        // ç”¨æˆ·å‘é€çš„è¯­éŸ³æ¶ˆæ¯
                        myMessageContent = `
                            <div class="voice-message-container sent">
                                <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                                    <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${message.content}">
                                        <div class="voice-wave">
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                        </div>
                                        <div class="voice-duration">${message.duration || Math.max(1, Math.ceil(message.content.length / 8))}"</div>
                                    ${message.edited ? `<div class="message-edited-indicator">å·²ç¼–è¾‘</div>` : ""}
                                    </div>
                                    ${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                    ${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                </div>
                                <div class="voice-text-content">${message.content}</div>
                            </div>
                        `;
                    } else if (message.type === 'transfer') {
                        // ç”¨æˆ·è½¬è´¦æ¶ˆæ¯ - åœ¨renderChatMessagesä¸­å¤„ç†
                        let cardClass = '';
                        let statusHtml = '';
                        
                        if (message.status === 'accepted') {
                            statusHtml = `<div class="transfer-status">å¯¹æ–¹å·²æ”¶æ¬¾</div>`;
                            cardClass = 'accepted';
                        } else if (message.status === 'rejected') {
                            statusHtml = `<div class="transfer-status">å¯¹æ–¹å·²é€€å›</div>`;
                            cardClass = 'rejected';
                        }
                        
                        myMessageContent = `
                            <div class="transfer-message-container sent">
                                <div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}">
                                    <div class="transfer-title">ğŸ’• ä½ å‘èµ·çš„è½¬è´¦</div>
                                    <div class="transfer-amount">Â¥ ${Number(message.amount).toFixed(2)}</div>
                                    <div class="transfer-note">${message.note || 'è½¬è´¦'}</div>
                                    ${statusHtml}
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'location') {
                        // ç”¨æˆ·å‘é€çš„ä½ç½®æ¶ˆæ¯
                        myMessageContent = `
                            <div class="location-message-container sent">
                                <div class="location-card" onclick="showLocationDetail('${message.locationName}')">
                                    <div class="location-card-header">
                                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
                                            <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                        </svg>
                                        ${message.locationName}
                                    </div>
                                    <div class="location-card-map">
                                        <div class="map-background"></div>
                                        <div class="map-roads">
                                            <div class="road road-horizontal" style="top: 35%; width: 100%;"></div>
                                            <div class="road road-vertical" style="left: 40%; height: 100%;"></div>
                                            <div class="road road-horizontal" style="top: 65%; width: 70%; left: 30%;"></div>
                                        </div>
                                        <div class="map-buildings">
                                            <div class="building" style="top: 15%; left: 20%; width: 12px; height: 10px;"></div>
                                            <div class="building" style="top: 25%; left: 60%; width: 14px; height: 12px;"></div>
                                            <div class="building green" style="top: 50%; left: 15%; width: 8px; height: 8px;"></div>
                                            <div class="building" style="top: 70%; left: 70%; width: 10px; height: 8px;"></div>
                                            <div class="building green" style="top: 10%; left: 75%; width: 6px; height: 6px;"></div>
                                            <div class="building green" style="top: 75%; left: 25%; width: 7px; height: 7px;"></div>
                                        </div>
                                        <div class="map-marker">
                                            <div class="marker-pin">
                                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                                                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                                </svg>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        // ğŸ”¥ã€ä¿®å¤ã€‘å¤„ç†å¤šæ¨¡æ€æ¶ˆæ¯æˆ–æ™®é€šæ–‡æœ¬æ¶ˆæ¯
                        if (Array.isArray(message.content)) {
                            // æ–°çš„å¤šæ¨¡æ€æ ¼å¼
                            const textPart = message.content.find(p => p.type === 'text');
                            const imagePart = message.content.find(p => p.type === 'image_url');

                            let baseContent = textPart?.text || '';

                            // å¦‚æœæœ‰å¼•ç”¨æ¶ˆæ¯ï¼Œåœ¨å†…å®¹å‰æ·»åŠ å¼•ç”¨æ˜¾ç¤º
                            if (message.replyTo) {
                                myMessageContent = generateReplyHTML(message.replyTo) + baseContent;
                            } else {
                                myMessageContent = baseContent;
                            }

                            // å¦‚æœæœ‰å›¾ç‰‡ï¼Œæ·»åŠ å›¾ç‰‡æ˜¾ç¤º
                            if (imagePart?.image_url?.url) {
                                if (myMessageContent) {
                                    myMessageContent += '<br>';
                                }
                                myMessageContent += `<img src="${imagePart.image_url.url}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${imagePart.image_url.url}')">`;
                            }
                        } else {
                            // æ™®é€šæ–‡æœ¬æ¶ˆæ¯æˆ–æ—§æ ¼å¼
                            let baseContent = message.content;
                            // å¤„ç†@å†…å®¹
                            baseContent = processMentions(baseContent);

                            // å¦‚æœæœ‰å¼•ç”¨æ¶ˆæ¯ï¼Œåœ¨å†…å®¹å‰æ·»åŠ å¼•ç”¨æ˜¾ç¤º
                            if (message.replyTo) {
                                myMessageContent = generateReplyHTML(message.replyTo) + baseContent;
                            } else {
                                myMessageContent = baseContent;
                            }
                        }
                    }
                    
                    let myBubbleHtml = '';
                    
                    if (message.type === 'user_photo' || message.type === 'voice' || message.type === 'transfer' || message.type === 'location' || message.type === 'friend_request') {
                        // ç”¨æˆ·ç…§ç‰‡ã€è¯­éŸ³æ¶ˆæ¯ã€è½¬è´¦æ¶ˆæ¯å’Œä½ç½®æ¶ˆæ¯ä¸éœ€è¦é¢å¤–æ°”æ³¡åŒ…è£¹ï¼ˆå·²ç»æœ‰è‡ªå·±çš„å®¹å™¨ï¼‰
                        myBubbleHtml = myMessageContent;
                    } else {
                        // æ™®é€šæ¶ˆæ¯ç”¨æ°”æ³¡åŒ…è£¹
                        myBubbleHtml = `
                            <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                                ${myMessageContent}
                                ${message.image && !message.type && !Array.isArray(message.content) ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}
                                ${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                ${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}
                            </div>
                        `;
                    }
                    
                    let myAvatarHtml = '';
                    if (!chatSettings.hideAvatars) {
                        myAvatarHtml = `
                            <div class="message-avatar" style="background-color: #007AFF; ${myDisplayAvatar ? `background-image: url(${myDisplayAvatar}); background-size: cover; background-position: center;` : ''}">
                                ${myDisplayAvatar ? '' : '<i class="fas fa-user"></i>'}
                                ${timestampEnabled && timestampPosition === 'avatar' ? `<div class="timestamp timestamp-avatar">${formatTimeOnly(message.timestamp)}</div>` : ''}
                            </div>
                        `;
                    }
                    
                    messageContainer.innerHTML = myBubbleHtml + myAvatarHtml;
                }
                
                // æ·»åŠ æ»‘å…¥åŠ¨ç”»æ•ˆæœ - å‚è€ƒå®Œæˆ.htmlçš„å¼¹æ€§åŠ¨ç”»
                messageContainer.style.opacity = '0';
                messageContainer.style.transform = 'translateY(20px)';
                messageContainer.style.transition = 'opacity 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)';
                
                messagesContainer.appendChild(messageContainer);
                
                // è§¦å‘æ»‘å…¥åŠ¨ç”»
                requestAnimationFrame(() => {
                    messageContainer.style.opacity = '1';
                    messageContainer.style.transform = 'translateY(0)';
                });
                
                // ğŸ”¥ã€æ–°å¢ã€‘æ£€æŸ¥æ‹‰é»‘çŠ¶æ€å¹¶æ·»åŠ æŒ‡ç¤ºå™¨
                addBlockedIndicatorToMessage(messageContainer, message, characterId);

                // æ·»åŠ é•¿æŒ‰ç›‘å¬å™¨ç”¨äºå¤šé€‰åˆ é™¤
                addMessageLongPressListener(messageContainer, message.id);

                // æ·»åŠ å³é”®èœå•åŠŸèƒ½
                const bubble = messageContainer.querySelector('.message-bubble');
                if (bubble) {
                    // é¼ æ ‡å³é”®ç‚¹å‡»
                    bubble.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        showMessageMenu(message.id, e);
                    });

                    // ç‚¹å‡»å›¾ç‰‡é¢„è§ˆ
                    bubble.onclick = (e) => {
                        if (e.target.tagName === 'IMG' && e.target.classList.contains('message-image')) {
                            showImage(e.target.src);
                        }
                    };
                }
            });
            
            // æ·»åŠ æ­£åœ¨è¾“å…¥æç¤ºå…ƒç´ åˆ°æ¶ˆæ¯åº•éƒ¨ï¼ˆåˆå§‹éšè—ï¼‰
            const typingIndicator = document.createElement('div');
            typingIndicator.id = 'typing-indicator';
            typingIndicator.className = 'typing-indicator';
            typingIndicator.innerHTML = `${chatSettings.aiChatNickname || currentChatCharacter.name}æ­£åœ¨è¾“å…¥ä¸­<span class="dots"></span>`;
            messagesContainer.appendChild(typingIndicator);
            
            // å¦‚æœä¸æ˜¯åŠ è½½æ›´å¤šï¼Œè‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
            if (!loadMore) {
                setTimeout(() => {
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                }, 100);
            }
            
            // ğŸ”¥ã€ä¿®å¤ã€‘ä½ç½®æ¶ˆæ¯æ°”æ³¡åŒ…è£…é—®é¢˜ - ä¿®å¤å·²æ¸²æŸ“çš„ä½ç½®æ¶ˆæ¯
            setTimeout(() => {
                const locationMessages = messagesContainer.querySelectorAll('.message-container.sent');
                locationMessages.forEach(container => {
                    const locationCard = container.querySelector('.location-card');
                    if (locationCard && container.querySelector('.message-bubble')) {
                        // å¦‚æœä½ç½®å¡ç‰‡è¢«åŒ…è£¹åœ¨æ°”æ³¡ä¸­ï¼Œæå–å‡ºæ¥
                        const bubble = container.querySelector('.message-bubble');
                        const avatar = container.querySelector('.message-avatar');
                        if (bubble && locationCard.closest('.message-bubble')) {
                            const locationContainer = locationCard.closest('.location-message-container');
                            if (locationContainer) {
                                container.innerHTML = locationContainer.outerHTML + (avatar ? avatar.outerHTML : '');
                            }
                        }
                    }
                });
                
                // ğŸ”¥ã€æ–°å¢ã€‘æ¸²æŸ“è§’è‰²çŠ¶æ€æ˜¾ç¤º - åœ¨æ¶ˆæ¯æ¸²æŸ“å®Œæˆåæ›´æ–°çŠ¶æ€
                if (currentChatCharacter) {
                    const headerContainer = document.querySelector('#api-chat-screen .header');
                    if (headerContainer) {
                        renderCharacterStatus(currentChatCharacter.id, headerContainer);
                    }
                }
            }, 50);
        }
        
        // åŠ è½½æ›´å¤šå†å²æ¶ˆæ¯
        function loadMoreMessages(characterId) {
            const messagesContainer = document.getElementById('api-chat-messages');
            const allMessages = chatMessages[characterId] || [];
            const chatSettings = getCurrentChatSettings();
            
            // ä¿å­˜æ»šåŠ¨ä½ç½®
            const scrollHeight = messagesContainer.scrollHeight;
            const scrollTop = messagesContainer.scrollTop;
            
            // è®¡ç®—è¦åŠ è½½çš„å†å²æ¶ˆæ¯èŒƒå›´
            const newOffset = Math.max(0, currentMessageOffset - MESSAGE_LIMIT);
            const historicalMessages = allMessages.slice(newOffset, currentMessageOffset);
            
            // ç§»é™¤ç°æœ‰çš„"æŸ¥çœ‹å†å²æ¶ˆæ¯"æŒ‰é’®
            const existingLoadMoreBtn = messagesContainer.querySelector('.load-more-messages');
            if (existingLoadMoreBtn) {
                existingLoadMoreBtn.remove();
            }
            
            // å¦‚æœè¿˜æœ‰æ›´å¤šå†å²æ¶ˆæ¯ï¼Œåœ¨é¡¶éƒ¨æ·»åŠ æ–°çš„"æŸ¥çœ‹å†å²æ¶ˆæ¯"æŒ‰é’®
            if (newOffset > 0) {
                const loadMoreBtn = document.createElement('div');
                loadMoreBtn.className = 'load-more-messages';
                loadMoreBtn.innerHTML = `
                    <div class="load-more-content">
                        <i class="fas fa-chevron-up"></i>
                        <span>æŸ¥çœ‹å†å²æ¶ˆæ¯ (${newOffset}æ¡)</span>
                    </div>
                `;
                loadMoreBtn.onclick = () => loadMoreMessages(characterId);
                messagesContainer.insertBefore(loadMoreBtn, messagesContainer.firstChild);
            }
            
            // åœ¨ç°æœ‰æ¶ˆæ¯å‰é¢æ’å…¥å†å²æ¶ˆæ¯
            const timestampEnabled = chatSettings.timestampEnabled !== false;
            const timestampPosition = chatSettings.timestampPosition || 'center';
            let lastTimestamp = 0;
            
            // ä»åå¾€å‰æ’å…¥ï¼Œä¿æŒæ—¶é—´é¡ºåº
            for (let i = historicalMessages.length - 1; i >= 0; i--) {
                const message = historicalMessages[i];
                
                // å¤„ç†ç³»ç»Ÿæ¶ˆæ¯ï¼ˆå¦‚æˆ³ä¸€æˆ³ã€å¤´åƒæ›´æ¢ã€æ’¤å›ç­‰ï¼‰
                if (message.sender === 'system') {
                    // ğŸ”¥ã€ä¿®å¤ã€‘å¤„ç†æ‹‰é»‘ç³»ç»Ÿæ¶ˆæ¯ - æ˜¾ç¤ºä¸ºå±…ä¸­çš„ç³»ç»Ÿæç¤º
                    if (message.isBlockedMessage) {
                        const centerContainer = document.createElement('div');
                        centerContainer.style.display = 'flex';
                        centerContainer.style.justifyContent = 'center';
                        centerContainer.style.margin = '4px 0';
                        centerContainer.dataset.messageId = message.id;

                        const systemContainer = document.createElement('div');
                        systemContainer.className = 'system-message';
                        systemContainer.textContent = message.content || 'æ¶ˆæ¯å·²å‘å‡ºï¼Œä½†è¢«å¯¹æ–¹æ‹’æ”¶äº†';

                        centerContainer.appendChild(systemContainer);

                        // æ’å…¥åˆ°æ­£ç¡®ä½ç½®
                        const insertAfter = messagesContainer.querySelector('.load-more-messages');
                        if (insertAfter) {
                            insertAfter.parentNode.insertBefore(centerContainer, insertAfter.nextSibling);
                        } else {
                            messagesContainer.insertBefore(centerContainer, messagesContainer.firstChild);
                        }
                        continue;
                    }

                    let containerToInsert;

                    if (message.isPoke) {
                    const systemContainer = document.createElement('div');
                    systemContainer.className = 'poke-system-container';
                    const systemMessage = document.createElement('div');
                    systemMessage.className = 'poke-system-message';
                    systemMessage.textContent = message.content;
                    systemContainer.appendChild(systemMessage);
                        containerToInsert = systemContainer;
                    } else if (message.type === 'recalled_message') {
                        // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†æ’¤å›æ¶ˆæ¯çš„æ˜¾ç¤º
                        const centerContainer = document.createElement('div');
                        centerContainer.style.display = 'flex';
                        centerContainer.style.justifyContent = 'center';
                        centerContainer.style.margin = '4px 0';
                        centerContainer.dataset.messageId = message.id; // ğŸ”¥ã€ä¿®å¤ã€‘æ·»åŠ æ¶ˆæ¯IDä»¥æ”¯æŒé€‰æ‹©
                        
                        const recallElement = document.createElement('div');
                        recallElement.className = 'recalled-message';
                        
                        // è§£ææ’¤å›æ¶ˆæ¯å†…å®¹ï¼ˆæ ¼å¼ï¼šxxx æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯\nåŸæ–‡ï¼šxxxï¼‰
                        const lines = message.content.split('\n');
                        const mainText = lines[0]; // ä¸»è¦æç¤ºæ–‡å­—
                        const originalText = lines[1]; // åŸæ–‡éƒ¨åˆ†
                        
                        recallElement.textContent = mainText;
                        
                        // å¦‚æœæœ‰åŸæ–‡ï¼Œæ·»åŠ åŸæ–‡æ˜¾ç¤º
                        if (originalText && originalText.startsWith('åŸæ–‡ï¼š')) {
                            const originalDiv = document.createElement('div');
                            originalDiv.className = 'original-text';
                            originalDiv.textContent = originalText;
                            recallElement.appendChild(originalDiv);
                        }
                        
                        centerContainer.appendChild(recallElement);
                        containerToInsert = centerContainer;
                    } else {
                        // ğŸ”¥ã€ä¿®å¤ã€‘å…¶ä»–ç³»ç»Ÿæ¶ˆæ¯ï¼ˆå¦‚å¤´åƒæ›´æ¢ï¼‰- ä½¿ç”¨å±…ä¸­å®¹å™¨
                        const centerContainer = document.createElement('div');
                        centerContainer.style.display = 'flex';
                        centerContainer.style.justifyContent = 'center';
                        centerContainer.style.margin = '4px 0';

                        const systemContainer = document.createElement('div');
                        // ğŸ”¥ã€ç¾åŒ–ã€‘æ£€æŸ¥æ˜¯å¦ä¸ºå¥½å‹æ·»åŠ æˆåŠŸæ¶ˆæ¯ï¼Œåº”ç”¨ç‰¹æ®Šæ ·å¼
                        if (message.isFriendAddedMessage) {
                            systemContainer.className = 'friend-added-system-message';
                        } else {
                            systemContainer.className = 'system-message';
                        }
                        systemContainer.textContent = message.content;

                        centerContainer.appendChild(systemContainer);
                        containerToInsert = centerContainer;
                    }
                    
                    // æ’å…¥åˆ°æŒ‰é’®åé¢ï¼ˆå¦‚æœæœ‰æŒ‰é’®çš„è¯ï¼‰
                    const insertAfter = messagesContainer.querySelector('.load-more-messages');
                    if (insertAfter) {
                        insertAfter.parentNode.insertBefore(containerToInsert, insertAfter.nextSibling);
                    } else {
                        messagesContainer.insertBefore(containerToInsert, messagesContainer.firstChild);
                    }
                    
                    // ğŸ”¥ã€ä¿®å¤ã€‘ä¸ºæ’¤å›æ¶ˆæ¯æ·»åŠ é€‰æ‹©åŠŸèƒ½
                    if (message.type === 'recalled_message') {
                        addMessageLongPressListener(containerToInsert, message.id);
                    }
                    
                    continue;
                }
                
                const messageContainer = document.createElement('div');
                // æ£€æŸ¥æ˜¯å¦æ˜¯çº¯è¡¨æƒ…åŒ…æ¶ˆæ¯
                const isEmojiOnly = message.isEmoji && !message.content;
                messageContainer.className = `message-container ${message.sender}${chatSettings.hideAvatars ? ' no-avatar' : ''}${isEmojiOnly ? ' emoji-only' : ''}`;
                messageContainer.dataset.messageId = message.id;
                
                if (message.sender === 'received') {
                    // ==== ç¾¤èŠæ”¯æŒ ====
                    let character = characters.find(c => c.id === characterId);
                    let isGroup = false;
                    let group = null;
                    if (!character) {
                        group = groupChats.find(g => g.id === characterId);
                        if (group) {
                            isGroup = true;
                        }
                    }
                    
                    let displayAvatar = '';
                    let displayName = '';
                    let color = '#4CAF50';
                    
                    if (isGroup && group) {
                        // ç¾¤èŠï¼šæ ¹æ®æ¶ˆæ¯çš„senderIdæˆ–nameæŸ¥æ‰¾æˆå‘˜
                        let member = null;
                        if (message.senderId) {
                            member = group.members.find(m => m.id === message.senderId);
                        } else if (message.name) {
                            member = group.members.find(m => m.name === message.name);
                        }

                        // ğŸ”¥ã€ä¿®å¤ã€‘ç¡®ä¿ç¾¤èŠè¡¨æƒ…åŒ…æ¶ˆæ¯æ­£ç¡®æ˜¾ç¤ºå‘é€è€…ï¼ˆloadMoreMessagesç‰ˆæœ¬ï¼‰
                        if (member) {
                            displayAvatar = member.avatarUrl || '';
                            displayName = member.name;
                            color = member.color || '#4CAF50';
                        } else {
                            // å¦‚æœæ²¡æ‰¾åˆ°æˆå‘˜ï¼Œä½¿ç”¨æ¶ˆæ¯ä¸­çš„nameä½œä¸ºæ˜¾ç¤ºåç§°
                            displayAvatar = '';
                            displayName = message.name || 'ç¾¤æˆå‘˜';
                            color = '#4CAF50';
                        }
                    } else if (character) {
                        // å•èŠ
                        displayAvatar = chatSettings.aiDynamicAvatar || chatSettings.aiChatAvatar || character.avatarUrl;
                        displayName = chatSettings.aiChatNickname || character.name;
                        color = character.color || '#4CAF50';
                    } else {
                        // å…œåº•ï¼Œé˜²æ­¢æŠ¥é”™
                        displayAvatar = '';
                        displayName = 'æœªçŸ¥';
                        color = '#4CAF50';
                    }
                    // ğŸ”¥ã€æ–°å¢ã€‘è·å–æ°”æ³¡æ ·å¼ - ç¾¤èŠä¸­ä½¿ç”¨æˆå‘˜ä¸“å±é¢œè‰²
                    let bubbleColor = chatSettings.aiBubbleColor || '#f0f0f0';
                    
                    // å¦‚æœæ˜¯ç¾¤èŠä¸”æœ‰æˆå‘˜ä¸“å±é¢œè‰²è®¾ç½®ï¼Œä½¿ç”¨æˆå‘˜ä¸“å±é¢œè‰²
                    if (isGroup && group && message.senderId && chatSettings.memberBubbleColors) {
                        const memberColor = chatSettings.memberBubbleColors[message.senderId];
                        if (memberColor) {
                            bubbleColor = memberColor;
                        }
                    }
                    
                    const bubbleOpacity = chatSettings.aiBubbleOpacity || '1';
                    const textColor = isLightColor(bubbleColor) ? '#333' : '#fff';
                    const bubblePadding = chatSettings.bubblePadding || '12';
                    
                    // å°†é€æ˜åº¦åº”ç”¨åˆ°èƒŒæ™¯è‰²è€Œä¸æ˜¯æ•´ä¸ªå…ƒç´ 
                    const transparentBubbleColor = convertColorWithOpacity(bubbleColor, bubbleOpacity);
                    
                    let messageContent = '';
                    if (message.type === 'voice_message') {
                        // è¿‡æ»¤æ‰æ‹¬å·ä¸­çš„æè¿°æ€§å†…å®¹ï¼Œä¿ç•™å®é™…è¯´è¯å†…å®¹
                        const cleanVoiceContent = message.content.replace(/\([^)]*\)\s*/g, '').trim();
                        const voiceDuration = message.duration || Math.max(1, Math.ceil(cleanVoiceContent.length / 8));
                        
                        messageContent = `
                            <div class="voice-message-container received">
                                <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                                    <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${cleanVoiceContent}">
                                        <div class="voice-wave">
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                        </div>
                                        <div class="voice-duration">${voiceDuration}"</div>
                                    ${message.edited ? `<div class="message-edited-indicator">å·²ç¼–è¾‘</div>` : ""}
                                    </div>
                                </div>
                                <div class="voice-text-content">${cleanVoiceContent}</div>
                            </div>
                        `;
                    } else if (message.type === 'ai_image') {
                        // AIç”Ÿæˆçš„å›¾ç‰‡ - ä½¿ç”¨æ˜Ÿæ˜Ÿemojiå¡ç‰‡æ ·å¼
                        const imageDesc = message.imageDescription || message.content || 'AIæè¿°çš„å›¾ç‰‡';
                        messageContent = `<div class="dreamy-photo-container" onclick="togglePhotoText(this, '${imageDesc.replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')"><div class="dreamy-photo"><div class="photo-misty-bg"></div><div class="photo-badge"><i class="fas fa-image"></i></div><div class="sparkle-container"><div class="sparkle sparkle-1">âœ¨</div><div class="sparkle sparkle-2">â­</div><div class="sparkle sparkle-3">âœ¨</div><div class="sparkle sparkle-4">â­</div><div class="sparkle sparkle-5">ğŸ’«</div></div><div class="photo-text-overlay" style="display: none;"><div class="photo-description">${imageDesc}</div></div></div></div>`;
                    } else if (message.type === 'transfer') {
                        // è½¬è´¦æ¶ˆæ¯
                        const isUser = message.role === 'user';
                        const heartIcon = isUser ? 'ğŸ’•' : 'ğŸ’–';
                        const titleText = isUser ? 'ä½ å‘èµ·çš„è½¬è´¦' : 'æ”¶åˆ°è½¬è´¦';
                        let cardClass = '';
                        let statusHtml = '';
                        let clickHandler = '';
                        
                        if (message.status === 'accepted') {
                            statusHtml = `<div class="transfer-status">${isUser ? 'å¯¹æ–¹å·²æ”¶æ¬¾' : 'å·²æ”¶æ¬¾'}</div>`;
                            cardClass = 'accepted';
                        } else if (message.status === 'rejected') {
                            statusHtml = `<div class="transfer-status">${isUser ? 'å¯¹æ–¹å·²é€€å›' : 'å·²é€€å›'}</div>`;
                            cardClass = 'rejected';
                        } else if (!isUser) {
                            // AIå‘æ¥çš„è½¬è´¦ä¸”æœªå¤„ç†ï¼Œæ·»åŠ ç‚¹å‡»å¤„ç†
                            clickHandler = `onclick="showTransferConfirmDialog(${JSON.stringify(message).replace(/"/g, '&quot;')})"`;
                        }
                        
                        messageContent = `<div class="transfer-message-container received"><div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}" ${clickHandler}><div class="transfer-title">${heartIcon} ${titleText}</div><div class="transfer-amount">Â¥ ${Number(message.amount).toFixed(2)}</div><div class="transfer-note">${message.note || 'è½¬è´¦'}</div>${statusHtml}</div></div>`;
                    } else if (message.type === 'friend_request') {
                        // ğŸ”¥ã€æ–°å¢ã€‘AIä¸»åŠ¨å‘é€çš„å¥½å‹ç”³è¯·(ç¬¬äºŒå¤„)
                        messageContent = `
                            <div class="friend-request-container">
                                <div class="friend-request-card">
                                    <div class="friend-request-icon">ğŸ‘‹</div>
                                    <div class="friend-request-title">å¥½å‹ç”³è¯·</div>
                                    <div class="friend-request-message">${message.message || 'æƒ³å’Œä½ é‡æ–°åšæœ‹å‹'}</div>
                                    <div class="friend-request-actions">
                                        <button class="friend-request-btn accept" onclick="handleAIFriendRequest('${currentChatCharacter?.id}', true, '${message.id}')">åŒæ„</button>
                                        <button class="friend-request-btn reject" onclick="handleAIFriendRequest('${currentChatCharacter?.id}', false, '${message.id}')">æ‹’ç»</button>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        const chatMode = chatSettings.chatMode || 'online';
                        let baseContent = chatMode === 'offline' ? processOfflineContent(message.content) : message.content;
                        
                        // å¦‚æœæœ‰å¼•ç”¨æ¶ˆæ¯ï¼Œåœ¨å†…å®¹å‰æ·»åŠ å¼•ç”¨æ˜¾ç¤º
                        if (message.replyTo) {
                            messageContent = generateReplyHTML(message.replyTo) + baseContent;
                        } else {
                            messageContent = baseContent;
                        }
                    }
                    
                    let avatarHtml = '';
                    if (!chatSettings.hideAvatars) {
                        avatarHtml = `<div class="message-avatar" style="background-color: ${color}; ${displayAvatar ? `background-image: url(${displayAvatar}); background-size: cover; background-position: center;` : ''}" ${character ? `onclick="pokeCharacter('${character.id}')" title="æˆ³ä¸€æˆ³"` : `title="${displayName}"`}>${displayAvatar ? '' : displayName.charAt(0)}${timestampEnabled && timestampPosition === 'avatar' ? `<div class="timestamp timestamp-avatar">${formatTimeOnly(message.timestamp)}</div>` : ''}</div>`;
                    }
                    
                    let bubbleHtml = '';
                    if (message.type === 'voice_message' || message.type === 'transfer' || message.type === 'ai_image' || message.type === 'user_photo' || message.type === 'location' || message.type === 'friend_request') {
                        // è¯­éŸ³æ¶ˆæ¯ã€è½¬è´¦æ¶ˆæ¯ã€AIå›¾ç‰‡æ¶ˆæ¯ã€ç…§ç‰‡å¡ç‰‡å’Œä½ç½®ä¿¡æ¯ä¸éœ€è¦é¢å¤–çš„æ°”æ³¡åŒ…è£¹
                        bubbleHtml = messageContent;
                    } else {
                        // æ™®é€šæ¶ˆæ¯ç”¨æ°”æ³¡åŒ…è£¹
                        bubbleHtml = `<div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">${messageContent}${message.image && !message.type ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}${message.edited ? `<div class="message-edited-indicator">å·²ç¼–è¾‘</div>` : ''}${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}</div>`;
                    }
                    
                   // ğŸ”¥ã€ä¿®å¤ã€‘ç¾¤èŠæ˜µç§°æ˜¾ç¤º ï¼ˆloadMoreMessagesç‰ˆæœ¬ï¼‰- ç‰¹åˆ«å¤„ç†è¯­éŸ³æ¶ˆæ¯ã€è½¬è´¦æ¶ˆæ¯ã€ç…§ç‰‡å¡ç‰‡å’Œä½ç½®ä¿¡æ¯
                   if (isGroup && group && displayName !== 'ç¾¤æˆå‘˜') {
    messageContainer.classList.add('group-message-item');
    const senderNameHtml = `<div class="sender-name">${displayName}</div>`;

    if (message.type === 'voice_message' || message.type === 'transfer' || message.type === 'ai_image' || message.type === 'user_photo' || message.type === 'location' || message.type === 'friend_request') {
        // ğŸ”¥ã€ä¿®å¤ã€‘å¯¹äºè¯­éŸ³æ¶ˆæ¯ã€è½¬è´¦æ¶ˆæ¯ã€AIå›¾ç‰‡æ¶ˆæ¯ã€ç…§ç‰‡å¡ç‰‡å’Œä½ç½®ä¿¡æ¯ï¼Œæ˜µç§°éœ€è¦åœ¨å®¹å™¨å¤–éƒ¨
    messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    } else {
        // æ™®é€šæ¶ˆæ¯çš„å¤„ç†ï¼ˆåŒ…æ‹¬è¡¨æƒ…åŒ…æ¶ˆæ¯ï¼‰
        messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    }
} else {
                    messageContainer.innerHTML = avatarHtml + bubbleHtml;
}
                } else {
                    let myDisplayAvatar = chatSettings.myChatAvatar;
                    if (!myDisplayAvatar && chatSettings.selectedIdentityId) {
                        const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                        if (selectedPersona && selectedPersona.avatarUrl) {
                            myDisplayAvatar = selectedPersona.avatarUrl;
                        }
                    }
                    
                    const myBubbleColor = chatSettings.myBubbleColor || '#007AFF';
                    const myBubbleOpacity = chatSettings.myBubbleOpacity || '1';
                    const myTextColor = isLightColor(myBubbleColor) ? '#333' : '#fff';
                    const myBubblePadding = chatSettings.bubblePadding || '12';
                    
                    // å°†é€æ˜åº¦åº”ç”¨åˆ°èƒŒæ™¯è‰²è€Œä¸æ˜¯æ•´ä¸ªå…ƒç´ 
                    const transparentMyBubbleColor = convertColorWithOpacity(myBubbleColor, myBubbleOpacity);
                    
                    // å¤„ç†ç”¨æˆ·çš„ç‰¹æ®Šæ¶ˆæ¯ç±»å‹
                    let myMessageContent = '';
                    if (message.type === 'user_photo') {
                        // ç”¨æˆ·å‘é€çš„"ç…§ç‰‡"ï¼ˆæ–‡å­—æè¿°ï¼‰
                        myMessageContent = `<div class="dreamy-photo-container" onclick="togglePhotoText(this, '${(message.photoDescription || message.content).replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')"><div class="dreamy-photo"><div class="photo-misty-bg"></div><div class="photo-badge"><i class="fas fa-image"></i></div><div class="sparkle-container"><div class="sparkle sparkle-1">âœ¨</div><div class="sparkle sparkle-2">â­</div><div class="sparkle sparkle-3">âœ¨</div><div class="sparkle sparkle-4">â­</div><div class="sparkle sparkle-5">ğŸ’«</div></div><div class="photo-text-overlay" style="display: none;"><div class="photo-description">${(message.photoDescription || message.content)}</div></div></div></div>`;
                    } else if (message.type === 'voice') {
                        // ç”¨æˆ·å‘é€çš„è¯­éŸ³æ¶ˆæ¯
                        myMessageContent = `
                            <div class="voice-message-container sent">
                                <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                                    <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${message.content}">
                                        <div class="voice-wave">
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                        </div>
                                        <div class="voice-duration">${message.duration || Math.max(1, Math.ceil(message.content.length / 8))}"</div>
                                    ${message.edited ? `<div class="message-edited-indicator">å·²ç¼–è¾‘</div>` : ""}
                                    </div>
                                    ${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                    ${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                </div>
                                <div class="voice-text-content">${message.content}</div>
                            </div>
                        `;
                    } else if (message.type === 'transfer') {
                        // ç”¨æˆ·è½¬è´¦æ¶ˆæ¯ - åœ¨loadMoreMessagesä¸­å¤„ç†
                        let cardClass = '';
                        let statusHtml = '';
                        
                        if (message.status === 'accepted') {
                            statusHtml = `<div class="transfer-status">å¯¹æ–¹å·²æ”¶æ¬¾</div>`;
                            cardClass = 'accepted';
                        } else if (message.status === 'rejected') {
                            statusHtml = `<div class="transfer-status">å¯¹æ–¹å·²é€€å›</div>`;
                            cardClass = 'rejected';
                        }
                        
                        myMessageContent = `
                            <div class="transfer-message-container sent">
                                <div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}">
                                    <div class="transfer-title">ğŸ’• ä½ å‘èµ·çš„è½¬è´¦</div>
                                    <div class="transfer-amount">Â¥ ${Number(message.amount).toFixed(2)}</div>
                                    <div class="transfer-note">${message.note || 'è½¬è´¦'}</div>
                                    ${statusHtml}
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'location') {
                        // ç”¨æˆ·å‘é€çš„ä½ç½®æ¶ˆæ¯ - åœ¨loadMoreMessagesä¸­å¤„ç†
                        myMessageContent = `
                            <div class="location-message-container sent">
                                <div class="location-card" onclick="showLocationDetail('${message.locationName}')">
                                    <div class="location-card-header">
                                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
                                            <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                        </svg>
                                        ${message.locationName}
                                    </div>
                                    <div class="location-card-map">
                                        <div class="map-background"></div>
                                        <div class="map-roads">
                                            <div class="road road-horizontal" style="top: 35%; width: 100%;"></div>
                                            <div class="road road-vertical" style="left: 40%; height: 100%;"></div>
                                            <div class="road road-horizontal" style="top: 65%; width: 70%; left: 30%;"></div>
                                        </div>
                                        <div class="map-buildings">
                                            <div class="building" style="top: 15%; left: 20%; width: 12px; height: 10px;"></div>
                                            <div class="building" style="top: 25%; left: 60%; width: 14px; height: 12px;"></div>
                                            <div class="building green" style="top: 50%; left: 15%; width: 8px; height: 8px;"></div>
                                            <div class="building" style="top: 70%; left: 70%; width: 10px; height: 8px;"></div>
                                            <div class="building green" style="top: 10%; left: 75%; width: 6px; height: 6px;"></div>
                                            <div class="building green" style="top: 75%; left: 25%; width: 7px; height: 7px;"></div>
                                        </div>
                                        <div class="map-marker">
                                            <div class="marker-pin">
                                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                                                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                                </svg>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        // ğŸ”¥ã€ä¿®å¤ã€‘å¤„ç†å¤šæ¨¡æ€æ¶ˆæ¯æˆ–æ™®é€šæ–‡æœ¬æ¶ˆæ¯ (loadMoreMessagesç‰ˆæœ¬)
                        if (Array.isArray(message.content)) {
                            // æ–°çš„å¤šæ¨¡æ€æ ¼å¼
                            const textPart = message.content.find(p => p.type === 'text');
                            const imagePart = message.content.find(p => p.type === 'image_url');
                            
                            let baseContent = textPart?.text || '';
                            
                            // å¦‚æœæœ‰å¼•ç”¨æ¶ˆæ¯ï¼Œåœ¨å†…å®¹å‰æ·»åŠ å¼•ç”¨æ˜¾ç¤º
                            if (message.replyTo) {
                                myMessageContent = generateReplyHTML(message.replyTo) + baseContent;
                            } else {
                                myMessageContent = baseContent;
                            }
                            
                            // å¦‚æœæœ‰å›¾ç‰‡ï¼Œæ·»åŠ å›¾ç‰‡æ˜¾ç¤º
                            if (imagePart?.image_url?.url) {
                                if (myMessageContent) {
                                    myMessageContent += '<br>';
                                }
                                myMessageContent += `<img src="${imagePart.image_url.url}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${imagePart.image_url.url}')">`;
                            }
                        } else {
                            // æ™®é€šæ–‡æœ¬æ¶ˆæ¯æˆ–æ—§æ ¼å¼ (loadMoreMessagesç‰ˆæœ¬)
                            let baseContent = message.content;
                            
                            // å¦‚æœæœ‰å¼•ç”¨æ¶ˆæ¯ï¼Œåœ¨å†…å®¹å‰æ·»åŠ å¼•ç”¨æ˜¾ç¤º
                            if (message.replyTo) {
                                myMessageContent = generateReplyHTML(message.replyTo) + baseContent;
                            } else {
                                myMessageContent = baseContent;
                            }
                        }
                    }
                    
                    let myBubbleHtml = '';
                    
                    if (message.type === 'user_photo' || message.type === 'voice' || message.type === 'transfer' || message.type === 'location' || message.type === 'friend_request') {
                        // ç”¨æˆ·ç…§ç‰‡ã€è¯­éŸ³æ¶ˆæ¯ã€è½¬è´¦æ¶ˆæ¯å’Œä½ç½®æ¶ˆæ¯ä¸éœ€è¦é¢å¤–æ°”æ³¡åŒ…è£¹ï¼ˆå·²ç»æœ‰è‡ªå·±çš„å®¹å™¨ï¼‰
                        myBubbleHtml = myMessageContent;
                    } else {
                        // æ™®é€šæ¶ˆæ¯ç”¨æ°”æ³¡åŒ…è£¹
                        myBubbleHtml = `<div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">${myMessageContent}${message.image && !message.type && !Array.isArray(message.content) ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}${message.edited ? `<div class="message-edited-indicator">å·²ç¼–è¾‘</div>` : ''}${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}</div>`;
                    }
                    
                    let myAvatarHtml = '';
                    if (!chatSettings.hideAvatars) {
                        myAvatarHtml = `<div class="message-avatar" style="background-color: #007AFF; ${myDisplayAvatar ? `background-image: url(${myDisplayAvatar}); background-size: cover; background-position: center;` : ''}">${myDisplayAvatar ? '' : '<i class="fas fa-user"></i>'}${timestampEnabled && timestampPosition === 'avatar' ? `<div class="timestamp timestamp-avatar">${formatTimeOnly(message.timestamp)}</div>` : ''}</div>`;
                    }
                    
                    messageContainer.innerHTML = myBubbleHtml + myAvatarHtml;
                }
                
                // ğŸ”¥ã€æ–°å¢ã€‘æ£€æŸ¥æ‹‰é»‘çŠ¶æ€å¹¶æ·»åŠ æŒ‡ç¤ºå™¨
                addBlockedIndicatorToMessage(messageContainer, message, characterId);

                // æ·»åŠ é•¿æŒ‰ç›‘å¬å™¨å’Œå³é”®èœå•
                addMessageLongPressListener(messageContainer, message.id);
                const bubble = messageContainer.querySelector('.message-bubble');
                if (bubble) {
                    bubble.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        showMessageMenu(message.id, e);
                    });

                    bubble.onclick = (e) => {
                        if (e.target.tagName === 'IMG' && e.target.classList.contains('message-image')) {
                            showImage(e.target.src);
                        }
                    };
                }
                
                // æ’å…¥æ¶ˆæ¯åˆ°æ­£ç¡®ä½ç½®
                const insertAfter = messagesContainer.querySelector('.load-more-messages');
                if (insertAfter) {
                    insertAfter.parentNode.insertBefore(messageContainer, insertAfter.nextSibling);
                } else {
                    messagesContainer.insertBefore(messageContainer, messagesContainer.firstChild);
                }
            }
            
            // æ›´æ–°åç§»é‡
            currentMessageOffset = newOffset;
            
            // ä¿æŒæ»šåŠ¨ä½ç½®
            setTimeout(() => {
                const newScrollHeight = messagesContainer.scrollHeight;
                messagesContainer.scrollTop = scrollTop + (newScrollHeight - scrollHeight);
            }, 50);
        }
        
        
        // æ˜¾ç¤ºè§’è‰²è¡¨å•
        function showCharacterForm(characterId = null) {
            currentEditingCharacterId = characterId; // ä¿å­˜å½“å‰ç¼–è¾‘çš„è§’è‰²ID
            document.getElementById('character-form-title').textContent = characterId ? 'ç¼–è¾‘äººç‰©' : 'æ–°å»ºäººç‰©';
            
            // æ¸…ç©ºè¡¨å•
            document.getElementById('character-name').value = '';
            document.getElementById('character-bio').value = '';
            document.getElementById('avatar-upload').value = '';
            
            const avatarPreview = document.getElementById('avatar-preview');
            const avatarPreviewText = document.getElementById('avatar-preview-text');
            
            // é‡ç½®å¤´åƒé¢„è§ˆ
            avatarPreview.classList.remove('has-image');
            avatarPreview.style.removeProperty('background');
            avatarPreview.style.removeProperty('background-size');
            avatarPreview.style.removeProperty('background-position');
            avatarPreview.style.removeProperty('background-repeat');
            avatarPreviewText.style.display = 'block';
            avatarPreviewText.textContent = 'A';
            
            // æ¸…é™¤ä¸´æ—¶å­˜å‚¨çš„å¤´åƒæ•°æ®
            window.selectedAvatarData = null;
            
            // å¦‚æœæ˜¯ç¼–è¾‘æ¨¡å¼ï¼Œå¡«å……ç°æœ‰æ•°æ®
            if (characterId) {
                const character = characters.find(c => c.id === characterId);
                if (character) {
                    document.getElementById('character-name').value = character.name;
                    document.getElementById('character-bio').value = character.bio;
                    
                    if (character.avatarUrl) {
                        avatarPreview.classList.add('has-image');
                        avatarPreview.style.setProperty('background', `url(${character.avatarUrl})`, 'important');
                        avatarPreview.style.setProperty('background-size', 'cover', 'important');
                        avatarPreview.style.setProperty('background-position', 'center', 'important');
                        avatarPreview.style.setProperty('background-repeat', 'no-repeat', 'important');
                        avatarPreviewText.style.display = 'none';
                        // ä¸ºç¼–è¾‘æ¨¡å¼ä¿å­˜ç°æœ‰å¤´åƒæ•°æ®
                        window.selectedAvatarData = character.avatarUrl;
                    } else {
                        avatarPreviewText.textContent = character.name.charAt(0);
                    }
                }
            }
            
            // è®¾ç½®è¡¨å•çš„ä¿å­˜å‡½æ•°å’Œåˆ é™¤æŒ‰é’®æ˜¾ç¤º
            const deleteBtn = document.getElementById('character-delete-btn');
            const importBtn = document.getElementById('import-character-btn');
            const exportBtn = document.getElementById('export-character-btn');
            console.log('è®¾ç½®ä¿å­˜æŒ‰é’®ï¼ŒcharacterId:', characterId);
            if (characterId) {
                document.querySelector('#character-form-screen .form-submit').onclick = async () => await saveCharacter(characterId);
                // ç¼–è¾‘æ¨¡å¼æ˜¾ç¤ºåˆ é™¤æŒ‰é’®ï¼Œéšè—å¯¼å…¥æŒ‰é’®ï¼Œæ˜¾ç¤ºå¯¼å‡ºæŒ‰é’®
                if (deleteBtn) deleteBtn.style.display = 'block';
                if (importBtn) importBtn.style.display = 'none';
                if (exportBtn) exportBtn.style.display = 'flex';
                console.log('è®¾ç½®ä¸ºç¼–è¾‘æ¨¡å¼ï¼Œè§’è‰²ID:', characterId);
            } else {
                document.querySelector('#character-form-screen .form-submit').onclick = async () => await saveCharacter();
                // æ–°å»ºæ¨¡å¼éšè—åˆ é™¤æŒ‰é’®ï¼Œæ˜¾ç¤ºå¯¼å…¥æŒ‰é’®ï¼Œéšè—å¯¼å‡ºæŒ‰é’®
                if (deleteBtn) deleteBtn.style.display = 'none';
                if (importBtn) importBtn.style.display = 'flex';
                if (exportBtn) exportBtn.style.display = 'none';
                console.log('è®¾ç½®ä¸ºåˆ›å»ºæ¨¡å¼ï¼Œæ— è§’è‰²ID');
            }
            
            showApp('character-form-screen');
            
            // ç¡®ä¿å¤´åƒä¸Šä¼ åŠŸèƒ½å¯ç”¨ - é‡æ–°ç»‘å®šäº‹ä»¶ç›‘å¬å™¨ï¼ˆä»¥é˜²ä¸‡ä¸€ï¼‰
            setTimeout(() => {
                initializeAvatarUpload();
            }, 100);
        }
        
        // ä¿å­˜è§’è‰²
        async function saveCharacter(characterId = null) {
            try {
                console.log('=== å¼€å§‹ä¿å­˜è§’è‰² ===');
                const name = document.getElementById('character-name').value.trim();
                const bio = document.getElementById('character-bio').value.trim();
                const avatarData = window.selectedAvatarData; // ä½¿ç”¨é¢„å¤„ç†çš„å¤´åƒæ•°æ®
                
                console.log('ä¿å­˜è§’è‰² - å§“å:', name, 'å¤´åƒæ•°æ®å­˜åœ¨:', !!avatarData);
                if (avatarData) {
                    console.log('å¤´åƒæ•°æ®é•¿åº¦:', avatarData.length, 'å¼€å¤´:', avatarData.substring(0, 50));
                }
                
                if (!name) {
                    alert('è¯·è¾“å…¥å§“å');
                    return;
                }
                
                if (characterId) {
                    console.log('=== æ›´æ–°ç°æœ‰è§’è‰² ===');
                    // æ›´æ–°ç°æœ‰è§’è‰²
                    const index = characters.findIndex(c => c.id === characterId);
                    if (index !== -1) {
                        const oldAvatarUrl = characters[index].avatarUrl;
                        
                        characters[index] = {
                            ...characters[index],
                            name,
                            bio,
                            avatarUrl: avatarData || characters[index].avatarUrl || '',
                            color: characters[index].color || getRandomColor()
                        };
                        
                        console.log('æ›´æ–°è§’è‰²å®Œæˆ:', characters[index]);
                        
                        // ğŸ”¥ã€ä¿®å¤1ã€‘å¦‚æœå¤´åƒå‘ç”Ÿäº†å˜åŒ–ï¼Œæ›´æ–°æ‰€æœ‰ç›¸å…³ç¾¤èŠä¸­çš„æˆå‘˜å¤´åƒ
                        if (avatarData && avatarData !== oldAvatarUrl) {
                            updateCharacterAvatarInGroups(characterId, avatarData);
                        }
                        
                        // ä¿å­˜å¹¶æ›´æ–°ç•Œé¢
                        await saveCharacters();
                        renderContactList();
                        renderMessageList();
                        
                        // ğŸ”¥ã€ä¿®å¤2ã€‘å¦‚æœå½“å‰æ­£åœ¨èŠå¤©ä¸”æ˜¯è¯¥è§’è‰²ï¼Œåˆ·æ–°èŠå¤©ç•Œé¢
                        if (currentChatCharacter && currentChatCharacter.id === characterId) {
                            renderChatMessages(currentChatCharacter.id);
                        }
                        
                        showToast(`è§’è‰² "${name}" å·²æ›´æ–°ï¼`, 'success');
                        hideCharacterForm();
                        // æ³¨æ„ï¼šä¸ç«‹å³æ¸…ç©ºè¡¨å•ï¼Œè®©ç”¨æˆ·èƒ½çœ‹åˆ°ä¿å­˜æˆåŠŸçš„çŠ¶æ€
                    }
                } else {
                    console.log('=== åˆ›å»ºæ–°è§’è‰² ===');
                    // åˆ›å»ºæ–°è§’è‰²
                    const newCharacter = {
                        id: Date.now().toString(),
                        name,
                        bio,
                        avatarUrl: avatarData || '',
                        color: getRandomColor(),
                        groupId: 'my_friends' // æ–°è§’è‰²é»˜è®¤æ”¾å…¥"æˆ‘çš„å¥½å‹"åˆ†ç»„
                    };
                    
                    console.log('åˆ›å»ºæ–°è§’è‰²:', newCharacter);
                    console.log('æ–°è§’è‰²å¤´åƒURL:', newCharacter.avatarUrl);
                    console.log('æ–°è§’è‰²å¤´åƒURLé•¿åº¦:', newCharacter.avatarUrl ? newCharacter.avatarUrl.length : 0);
                    
                    console.log('æ·»åŠ è§’è‰²å‰ï¼Œå½“å‰è§’è‰²æ•°ç»„é•¿åº¦:', characters.length);
                    characters.push(newCharacter);
                    console.log('æ·»åŠ è§’è‰²åï¼Œå½“å‰è§’è‰²æ•°ç»„é•¿åº¦:', characters.length);
                    
                    console.log('è§’è‰²æ•°ç»„æœ€æ–°çŠ¶æ€:', characters);
                    
                    // ğŸ”¥ã€ä¿®å¤ã€‘ä¸å†è‡ªåŠ¨æ·»åŠ åˆ°è”ç³»äººåˆ—è¡¨ï¼Œç”¨æˆ·éœ€è¦é€šè¿‡åˆ›å»ºå¯¹è¯æ¥å»ºç«‹è”ç³»
                    
                    // ä¿å­˜å¹¶æ›´æ–°ç•Œé¢
                    console.log('å¼€å§‹ä¿å­˜åˆ°IndexedDB...');
                    await saveCharacters();
                    console.log('ä¿å­˜åæ£€æŸ¥è§’è‰²æ•°ç»„:', characters);
                    
                    console.log('å¼€å§‹æ¸²æŸ“ç•Œé¢...');
                    renderContactList();
                    renderMessageList();
                    
                    console.log('å¼€å§‹éšè—è¡¨å•...');
                    hideCharacterForm();
                    // æ³¨æ„ï¼šä¸ç«‹å³æ¸…ç©ºè¡¨å•ï¼Œè®©ç”¨æˆ·èƒ½çœ‹åˆ°ä¿å­˜æˆåŠŸçš„çŠ¶æ€
                    
                    // ç»™ç”¨æˆ·åé¦ˆ
                    showToast(`è§’è‰² "${newCharacter.name}" åˆ›å»ºæˆåŠŸï¼`, 'success');
                    
                    console.log('=== ä¿å­˜è§’è‰²å®Œæˆ ===');
                }
            } catch (error) {
                console.error('ä¿å­˜è§’è‰²æ—¶å‘ç”Ÿé”™è¯¯:', error);
                alert('ä¿å­˜è§’è‰²æ—¶å‘ç”Ÿé”™è¯¯: ' + error.message);
            }
        }
        
        // æ¸…ç©ºè§’è‰²è¡¨å•
        function clearCharacterForm() {
            console.log('æ¸…ç©ºè§’è‰²è¡¨å•è¢«è°ƒç”¨');
            document.getElementById('character-name').value = '';
            document.getElementById('character-bio').value = '';
            document.getElementById('avatar-upload').value = '';
            
            const avatarPreview = document.getElementById('avatar-preview');
            const avatarPreviewText = document.getElementById('avatar-preview-text');
            
            // é‡ç½®å¤´åƒé¢„è§ˆ
            avatarPreview.classList.remove('has-image');
            avatarPreview.style.removeProperty('background');
            avatarPreview.style.removeProperty('background-size');
            avatarPreview.style.removeProperty('background-position');
            avatarPreview.style.removeProperty('background-repeat');
            if (avatarPreviewText) {
                avatarPreviewText.style.display = 'block';
                avatarPreviewText.textContent = 'A';
            }
            
            // æ¸…é™¤ä¸´æ—¶å­˜å‚¨çš„å¤´åƒæ•°æ®
            console.log('æ¸…é™¤ä¸´æ—¶å¤´åƒæ•°æ®');
            window.selectedAvatarData = null;
        }
        
        // ç¼–è¾‘è§’è‰²
        function editCharacter(characterId) {
            showCharacterForm(characterId);
        }
        
        // ä»è”ç³»äººåˆ—è¡¨ç¼–è¾‘è§’è‰²
        function editCharacterFromContactList(characterId) {
            showCharacterForm(characterId);
        }
        
        // è¿›å…¥å¤šé€‰æ¨¡å¼
        function enterMultiSelectMode(characterId) {
            isMultiSelectMode = true;
            selectedCharacters = [characterId]; // åˆå§‹é€‰ä¸­è§¦å‘é•¿æŒ‰çš„è§’è‰²
            renderContactList();
        }
        
        // é€€å‡ºå¤šé€‰æ¨¡å¼
        function exitMultiSelectMode() {
            isMultiSelectMode = false;
            selectedCharacters = [];
            renderContactList();
        }
        
        // åˆ‡æ¢è§’è‰²é€‰æ‹©çŠ¶æ€
        function toggleCharacterSelection(characterId) {
            const index = selectedCharacters.indexOf(characterId);
            if (index > -1) {
                selectedCharacters.splice(index, 1);
            } else {
                selectedCharacters.push(characterId);
            }
            renderContactList();
        }
        
        // åˆ é™¤é€‰ä¸­çš„è§’è‰²
        async function deleteSelectedCharacters() {
            if (selectedCharacters.length === 0) {
                alert('è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„è§’è‰²');
                return;
            }
            
            const characterNames = selectedCharacters.map(id => {
                const character = characters.find(c => c.id === id);
                return character ? character.name : '';
            }).filter(name => name).join('ã€');
            
            if (confirm(`ç¡®å®šè¦åˆ é™¤è¿™äº›è§’è‰²å—ï¼Ÿ\n${characterNames}\n\næ­¤æ“ä½œä¸å¯æ¢å¤ï¼`)) {
                // åˆ é™¤è§’è‰²
                selectedCharacters.forEach(characterId => {
                    characters = characters.filter(c => c.id !== characterId);
                    contacts = contacts.filter(c => c !== characterId);
                    
                    // åˆ é™¤ç›¸å…³èŠå¤©è®°å½•
                    if (chatMessages[characterId]) {
                        delete chatMessages[characterId];
                    }
                });
                
                // ä¿å­˜æ•°æ®
                await saveCharacters();
                await saveContacts();
                await saveChatMessages();
                
                // é€€å‡ºå¤šé€‰æ¨¡å¼å¹¶æ›´æ–°ç•Œé¢
                exitMultiSelectMode();
                renderMessageList();
                
                alert('è§’è‰²åˆ é™¤æˆåŠŸ');
            }
        }
        
        // åˆ é™¤å½“å‰ç¼–è¾‘çš„è§’è‰²
        async function deleteCurrentCharacter() {
            if (currentEditingCharacterId) {
                const character = characters.find(c => c.id === currentEditingCharacterId);
                
                if (character && confirm(`ç¡®å®šè¦åˆ é™¤è§’è‰²"${character.name}"å—ï¼Ÿ\n\næ­¤æ“ä½œå°†åˆ é™¤è§’è‰²æ•°æ®ã€èŠå¤©è®°å½•å’Œæ‰€æœ‰è®¾ç½®ï¼Œä¸å¯æ¢å¤ï¼`)) {
                    // åˆ é™¤è§’è‰²
                    characters = characters.filter(c => c.id !== character.id);
                    contacts = contacts.filter(c => c !== character.id);
                    
                    // åˆ é™¤ç›¸å…³èŠå¤©è®°å½•
                    if (chatMessages[character.id]) {
                        delete chatMessages[character.id];
                    }
                    
                    // [æ ¸å¿ƒä¿®å¤] åˆ é™¤èŠå¤©è®¾ç½®
                    try {
                        // ä»æ•°æ®åº“ä¸­åˆ é™¤è®¾ç½®
                        await db.chatSettings.delete(character.id);
                        // ä»å†…å­˜ä¸­åˆ é™¤è®¾ç½®
                        if (chatSettings[character.id]) {
                            delete chatSettings[character.id];
                        }
                        // åˆ é™¤localStorageä¸­çš„å¤‡ä»½è®¾ç½®
                        localStorage.removeItem(`chatSettings_${character.id}`);
                        console.log(`âœ… å·²åˆ é™¤è§’è‰² ${character.name} çš„èŠå¤©è®¾ç½®`);
                    } catch (error) {
                        console.error(`åˆ é™¤è§’è‰² ${character.name} çš„èŠå¤©è®¾ç½®å¤±è´¥:`, error);
                    }
                    
                    // ä¿å­˜æ•°æ®
                    await saveCharacters();
                    await saveContacts();
                    await saveChatMessages();
                    
                    // æ›´æ–°ç•Œé¢å¹¶è¿”å›
                    renderContactList();
                    renderMessageList();
                    hideCharacterForm();
                    
                    showToast(`è§’è‰² ${character.name} å·²æˆåŠŸåˆ é™¤`, 'success');
                }
            }
        }
        
        // ğŸ”¥ã€æ–°å¢ã€‘æ›´æ–°è§’è‰²åœ¨æ‰€æœ‰ç¾¤èŠä¸­çš„å¤´åƒ
        function updateCharacterAvatarInGroups(characterId, newAvatarUrl) {
            // éå†æ‰€æœ‰è§’è‰²ï¼Œæ‰¾åˆ°ç¾¤èŠ
            characters.forEach(character => {
                if (character.isGroup && character.members) {
                    // åœ¨è¯¥ç¾¤èŠä¸­æŸ¥æ‰¾å¯¹åº”çš„æˆå‘˜
                    const memberIndex = character.members.findIndex(member => member.id === characterId);
                    if (memberIndex !== -1) {
                        // æ›´æ–°è¯¥æˆå‘˜çš„å¤´åƒ
                        character.members[memberIndex].avatarUrl = newAvatarUrl;
                        console.log(`å·²æ›´æ–°ç¾¤èŠ "${character.name}" ä¸­æˆå‘˜ "${character.members[memberIndex].name}" çš„å¤´åƒ`);
                    }
                }
            });
            
            // ä¿å­˜æ›´æ–°åçš„è§’è‰²æ•°æ®
            saveCharacters();
        }
        
        // è·å–éšæœºé¢œè‰²
        function getRandomColor() {
            const colors = ['#FF3B30', '#FF9500', '#FFCC00', '#34C759', '#5AC8FA', '#007AFF', '#5856D6', '#AF52DE'];
            return colors[Math.floor(Math.random() * colors.length)];
        }
        

        
        // å¼€å§‹ä¸è§’è‰²èŠå¤©
async function startChat(character) {
    await dataLoadedPromise; // ğŸ”¥ã€æ–°å¢ä¿®å¤ã€‘ç­‰å¾…æ•°æ®åŠ è½½å®Œæˆ

    // [æ ¸å¿ƒä¿®å¤] è®°å½•ä¸Šä¸€ä¸ªèŠå¤©IDï¼Œç”¨äºæ¸…ç†
    const previousChatId = currentChatCharacter ? currentChatCharacter.id : null;

    // ğŸ”¥ã€ä¿®å¤ã€‘åœ¨åˆ‡æ¢èŠå¤©æ—¶ï¼Œæ ‡è®°ä¸Šä¸€ä¸ªèŠå¤©ä¸ºå·²è¯»
    if (previousChatId) {
        markAsRead(previousChatId);
    }

    // ğŸ”¥ã€ä¿®å¤ã€‘åˆ‡æ¢èŠå¤©æ—¶éšè—è¾“å…¥æŒ‡ç¤ºå™¨ï¼Œé¿å…æ˜¾ç¤ºé”™è¯¯çš„"æ­£åœ¨è¾“å…¥"çŠ¶æ€
    hideTypingIndicator();

    // ğŸ”¥ã€æ–°å¢ã€‘ä¿å­˜å½“å‰èŠå¤©çš„å¼•ç”¨çŠ¶æ€ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
    if (previousChatId && currentReplyTo) {
        chatReplyStates[previousChatId] = { ...currentReplyTo };
    }

    // è®¾ç½®å½“å‰èŠå¤©è§’è‰²
            currentChatCharacter = character;

            // ğŸ”¥ã€æ–°å¢ã€‘ä¿å­˜å½“å‰èŠå¤©çŠ¶æ€åˆ°sessionStorageï¼Œç”¨äºé¡µé¢åˆ·æ–°æ—¶æ¢å¤
            sessionStorage.setItem('currentChatCharacterId', character.id);
            
    // ğŸ”¥ã€ä¿®å¤ã€‘å¼‚æ­¥è·å–èŠå¤©è®¾ç½®
    const chatSettings = await getAsyncChatSettings();
            let displayTitle = chatSettings.aiChatNickname || character.name;

            // ğŸ”¥ã€æ–°å¢ã€‘å¦‚æœæ˜¯ç¾¤èŠï¼Œåœ¨æ ‡é¢˜åæ·»åŠ æˆå‘˜æ•°é‡
            if (character.isGroup && character.members) {
                const memberCount = character.members.length + 1; // +1 åŒ…æ‹¬ç”¨æˆ·è‡ªå·±
                displayTitle = `${displayTitle}ï¼ˆ${memberCount}ï¼‰`;
            }

            document.getElementById('api-chat-title').textContent = displayTitle;
            
            // ğŸ”¥ã€æ–°å¢ã€‘æ¸²æŸ“è§’è‰²çŠ¶æ€æ˜¾ç¤º
            const headerContainer = document.querySelector('#api-chat-screen .header');
            if (headerContainer) {
                renderCharacterStatus(character.id, headerContainer);
            }
            
            // ğŸ”¥ã€æ–°å¢ã€‘æ›´æ–°å¿ƒç‡æ˜¾ç¤º
            updateAiHeartrate();
                
                // ğŸ”¥ã€ä¿®å¤ã€‘åªæœ‰åœ¨å¼€å¯çŠ¶æ€æ˜¾ç¤ºæ—¶æ‰ç”Ÿæˆåˆå§‹çŠ¶æ€
                setTimeout(async () => {
                    const chatSettings = await getAsyncChatSettings(character.id);
                    if (chatSettings.characterStatusEnabled) {
                        const currentStatus = getCharacterStatus(character.id);
                        if (!currentStatus.activity || currentStatus.activity === 'åœ¨çº¿') {
                            await generateCharacterStatus(character.id);
                            // åˆ·æ–°çŠ¶æ€æ˜¾ç¤º
                            renderCharacterStatus(character.id, headerContainer);
                        }
                    }
                }, 500);
            
            // ğŸ”¥ã€æ–°å¢ã€‘å¯åŠ¨çŠ¶æ€æ›´æ–°å®šæ—¶å™¨
            startCharacterStatusTimer();

            // ğŸ”¥ã€æ–°å¢ã€‘æ›´æ–°è®¾ç½®ç•Œé¢çš„æ‹‰é»‘/å±è”½ç®¡ç†æ–‡æ¡ˆ
            updateBlockManageLabel(character.isGroup);
            
            // åˆå§‹åŒ–ç©ºçš„èŠå¤©è®°å½•ï¼ˆä¸è‡ªåŠ¨å‘é€æ¶ˆæ¯ï¼‰
            if (!chatMessages[character.id]) {
                chatMessages[character.id] = [];
                saveChatMessages();
            }
            
            // é‡ç½®æ‚¬æµ®æŒ‰é’®çŠ¶æ€
            resetFloatingButtonsState();
            
            // ğŸ”¥ã€æ–°å¢ã€‘æ£€æŸ¥æ‹‰é»‘çŠ¶æ€å¹¶æ›´æ–°ç•Œé¢
            updateChatBlockedStatus();
            
            // ğŸ”¥ã€æ–°å¢ã€‘å¦‚æœè®¾ç½®ç•Œé¢æ˜¯æ‰“å¼€çš„ï¼Œæ›´æ–°è®¾ç½®æ˜¾ç¤ºçŠ¶æ€
            if (document.getElementById('api-chat-settings-screen').style.display === 'flex') {
                updateChatSettingsDisplay();
            }
    
    // é‡ç½®èŠå¤©å±å¹•èƒŒæ™¯
    const chatScreen = document.getElementById('api-chat-screen');
    if (chatScreen) {
        // å…ˆé‡ç½®æ‰€æœ‰èƒŒæ™¯æ ·å¼
        chatScreen.style.backgroundImage = 'none';
        chatScreen.style.backgroundColor = 'white';

        // ğŸ”¥ã€æ–°å¢ã€‘æ ¹æ®èŠå¤©ç±»å‹æ·»åŠ æˆ–ç§»é™¤group-chatç±»
        if (character.isGroup) {
            chatScreen.classList.add('group-chat');
        } else {
            chatScreen.classList.remove('group-chat');
        }

        const messagesContainer = document.getElementById('api-chat-messages');
        if (messagesContainer) messagesContainer.style.background = '';
    }
    
    // è®°å½•åˆ‡æ¢
    console.log(`ğŸ”„ åˆ‡æ¢åˆ°èŠå¤©: ${character.name} (ID: ${character.id})`);
    
    // ã€å…³é”®ä¿®å¤ã€‘æ¯æ¬¡è¿›å…¥èŠå¤©æ—¶ï¼Œè°ƒç”¨ applyChatBackground æ¥ç¡®ä¿èƒŒæ™¯æ­£ç¡®
    // ä¸ä¼ é€’å‚æ•°ï¼Œè®©å‡½æ•°è‡ªå·±ä»è§’è‰²å¯¹è±¡ä¸­è¯»å–
    await applyChatBackground();

    // ğŸ”¥ã€ä¿®å¤ã€‘ç¡®ä¿æ°”æ³¡æ ·å¼åœ¨è¿›å…¥èŠå¤©æ—¶è¢«æ­£ç¡®åº”ç”¨
    applyBubbleStyle();

            // åˆå§‹åŒ–åå°äº’åŠ¨ç³»ç»Ÿ
            initBackgroundInteractionSystem();

            // åˆå§‹åŒ–å®šæ—¶å‘å¸ƒç³»ç»Ÿ
            initScheduledMomentsSystem();

            renderChatMessages(character.id);

            // ğŸ”¥ã€æ–°å¢ã€‘æ¢å¤å½“å‰èŠå¤©çš„å¼•ç”¨çŠ¶æ€
            if (chatReplyStates[character.id]) {
                currentReplyTo = { ...chatReplyStates[character.id] };
                showReplyPreview();
            } else {
                // æ¸…é™¤å¼•ç”¨çŠ¶æ€
                currentReplyTo = null;
                const existingPreview = document.getElementById('reply-preview');
                if (existingPreview) {
                    existingPreview.remove();
                }
            }

            showApp('api-chat-screen');
        }
        
        // ä»èŠå¤©ç•Œé¢è¿”å›åˆ°èŠå¤©åº”ç”¨
        function backToChatApp() {
            // ğŸ”¥ã€ä¿®å¤ã€‘åœ¨é€€å‡ºèŠå¤©æ—¶æ ‡è®°æ¶ˆæ¯ä¸ºå·²è¯»
            if (currentChatCharacter) {
                markAsRead(currentChatCharacter.id);
            }

            // ğŸ”¥ã€æ–°å¢ã€‘æ¸…é™¤ä¿å­˜çš„èŠå¤©çŠ¶æ€
            sessionStorage.removeItem('currentChatCharacterId');

            // ğŸ”¥ã€æ–°å¢ã€‘ä¿å­˜å½“å‰èŠå¤©çš„å¼•ç”¨çŠ¶æ€
            if (currentChatCharacter && currentReplyTo) {
                chatReplyStates[currentChatCharacter.id] = { ...currentReplyTo };
            }

            // ğŸ”¥ã€æ–°å¢ã€‘æ¸…é™¤ç¾¤èŠCSSç±»
            const chatScreen = document.getElementById('api-chat-screen');
            if (chatScreen) {
                chatScreen.classList.remove('group-chat');
            }

            // æ¸…é™¤å½“å‰è§’è‰²çš„åå°å®šæ—¶å™¨
            clearAllBackgroundTimers();
            // ğŸ”¥ã€æ–°å¢ã€‘æ¸…é™¤çŠ¶æ€æ›´æ–°å®šæ—¶å™¨
            clearCharacterStatusTimer();
            // éšè—å¿ƒç‡æ˜¾ç¤º
            hideAiHeartrate();
            hideApp('api-chat-screen');
            showApp('chat-screen');
        }
        
        // ä»è®¾ç½®å­é¡µé¢è¿”å›åˆ°è®¾ç½®ä¸»é¡µé¢
        function backToSettings(currentScreen) {
            hideApp(currentScreen);
            showApp('settings-screen');
        }
        

        
        // æ˜¾ç¤ºæ­£åœ¨è¾“å…¥æç¤º
        function showTypingIndicator() {
            console.log('ğŸ”§ å°è¯•æ˜¾ç¤ºæ­£åœ¨è¾“å…¥æç¤º...');
            let indicator = document.getElementById('typing-indicator');
            
            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å…ƒç´ ï¼Œå°è¯•åˆ›å»ºä¸€ä¸ª
            if (!indicator) {
                console.log('âš ï¸ æœªæ‰¾åˆ°typing-indicatorå…ƒç´ ï¼Œæ­£åœ¨åˆ›å»º...');
                const messagesContainer = document.getElementById('api-chat-messages');
                if (messagesContainer) {
                    indicator = document.createElement('div');
                    indicator.id = 'typing-indicator';
                    indicator.className = 'typing-indicator';
                    
                    // è·å–å½“å‰è§’è‰²åç§°
                    const chatSettings = getCurrentChatSettings();
                    const characterName = chatSettings.aiChatNickname || (currentChatCharacter ? currentChatCharacter.name : 'å¯¹æ–¹');
                    
                    indicator.innerHTML = `${characterName}æ­£åœ¨è¾“å…¥ä¸­<span class="dots"></span>`;
                    messagesContainer.appendChild(indicator);
                    console.log('âœ… å·²åˆ›å»ºtyping-indicatorå…ƒç´ ');
                } else {
                    console.error('âŒ æ‰¾ä¸åˆ°æ¶ˆæ¯å®¹å™¨ï¼Œæ— æ³•åˆ›å»ºtyping-indicator');
                    return;
                }
            }
            
            if (indicator) {
                console.log('âœ… æ˜¾ç¤ºæ­£åœ¨è¾“å…¥æç¤º');
                indicator.classList.add('show');
                // æ»šåŠ¨åˆ°åº•éƒ¨æ˜¾ç¤ºæç¤º
                const messagesContainer = document.getElementById('api-chat-messages');
                if (messagesContainer) {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                }
            } else {
                console.error('âŒ ä»ç„¶æ‰¾ä¸åˆ°typing-indicatorå…ƒç´ ');
            }
        }
        
        // éšè—æ­£åœ¨è¾“å…¥æç¤º
        function hideTypingIndicator() {
            console.log('ğŸ”§ å°è¯•éšè—æ­£åœ¨è¾“å…¥æç¤º...');
            const indicator = document.getElementById('typing-indicator');
            if (indicator) {
                console.log('âœ… éšè—æ­£åœ¨è¾“å…¥æç¤º');
                indicator.classList.remove('show');
            } else {
                console.log('âš ï¸ æœªæ‰¾åˆ°typing-indicatorå…ƒç´ ï¼Œå¯èƒ½å·²è¢«ç§»é™¤');
            }
        }
        
        // ğŸ”¥ã€æ–°å¢ã€‘æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©ç•Œé¢ï¼ˆä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªåˆ—è¡¨ï¼‰
        function addSystemMessageToChat(systemMessage) {
            const messagesContainer = document.getElementById('api-chat-messages');
            if (!messagesContainer) return;
            
            // åˆ›å»ºå¤–å±‚å®¹å™¨ï¼Œç”¨äºå±…ä¸­
            const centerContainer = document.createElement('div');
            centerContainer.style.display = 'flex';
            centerContainer.style.justifyContent = 'center';
            centerContainer.style.margin = '4px 0';
            
            // åˆ›å»ºç³»ç»Ÿæ¶ˆæ¯å®¹å™¨
            const systemContainer = document.createElement('div');
            // ğŸ”¥ã€ç¾åŒ–ã€‘æ£€æŸ¥æ˜¯å¦ä¸ºå¥½å‹æ·»åŠ æˆåŠŸæ¶ˆæ¯ï¼Œåº”ç”¨ç‰¹æ®Šæ ·å¼
            if (systemMessage.isFriendAddedMessage) {
                systemContainer.className = 'friend-added-system-message';
            } else {
                systemContainer.className = 'system-message';
            }
            systemContainer.textContent = systemMessage.content;
            
            // å°†ç³»ç»Ÿæ¶ˆæ¯æ”¾å…¥å±…ä¸­å®¹å™¨
            centerContainer.appendChild(systemContainer);
            
            // æ’å…¥åˆ°æ¶ˆæ¯å®¹å™¨çš„æœ€åï¼ˆæ­£åœ¨è¾“å…¥æç¤ºä¹‹å‰ï¼‰
            const typingIndicator = messagesContainer.querySelector('#typing-indicator');
            if (typingIndicator) {
                messagesContainer.insertBefore(centerContainer, typingIndicator);
            } else {
                messagesContainer.appendChild(centerContainer);
            }
            
            // æ»šåŠ¨åˆ°åº•éƒ¨
            setTimeout(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }, 100);
        }

        // è§’è‰²å¡å¯¼å…¥åŠŸèƒ½
        function importCharacterCard() {
            // é˜²æ­¢é‡å¤è°ƒç”¨
            if (window.isImporting) {
                console.log('æ­£åœ¨å¯¼å…¥ä¸­ï¼Œå¿½ç•¥é‡å¤è°ƒç”¨');
                return;
            }
            window.isImporting = true;
            
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.png,.json';
            input.onchange = async (e) => {
                try {
                    const file = e.target.files[0];
                    if (!file) {
                        window.isImporting = false;
                        return;
                    }
                    
                    console.log('å¼€å§‹å¯¼å…¥æ–‡ä»¶:', file.name, 'ç±»å‹:', file.type);
                    
                    let characterData = null;
                    
                    if (file.type === 'image/png') {
                        // ä»PNGå›¾ç‰‡ä¸­è¯»å–è§’è‰²å¡æ•°æ®
                        characterData = await extractCharacterFromPNG(file);
                        
                        // ğŸ”¥ã€æ–°å¢ã€‘å¦‚æœPNGä¸­æ²¡æœ‰å¤´åƒæ•°æ®ï¼Œä½¿ç”¨PNGæ–‡ä»¶æœ¬èº«ä½œä¸ºå¤´åƒ
                        if (characterData && (!characterData.avatarUrl || characterData.avatarUrl === 'none' || characterData.avatarUrl === '' || characterData.avatarUrl === 'undefined')) {
                            console.log('ğŸ–¼ï¸ PNGä¸­æ²¡æœ‰å¤´åƒæ•°æ®ï¼Œä½¿ç”¨PNGæ–‡ä»¶æœ¬èº«ä½œä¸ºå¤´åƒ');
                            const reader = new FileReader();
                            const pngAsAvatar = await new Promise((resolve) => {
                                reader.onload = (e) => resolve(e.target.result);
                                reader.readAsDataURL(file);
                            });
                            characterData.avatarUrl = pngAsAvatar;
                            characterData.usePngAsAvatar = true; // æ ‡è®°è¿™æ˜¯PNGæœ¬èº«
                            console.log('ğŸ–¼ï¸ PNGå¤´åƒè®¾ç½®å®Œæˆ');
                        }
                    } else if (file.type === 'application/json' || file.name.endsWith('.json')) {
                        // ä»JSONæ–‡ä»¶ä¸­è¯»å–è§’è‰²å¡æ•°æ®
                        const text = await file.text();
                        characterData = JSON.parse(text);
                    }
                    
                    if (characterData) {
                        // å¡«å……è¡¨å•æ•°æ®
                        if (characterData.name) {
                            document.getElementById('character-name').value = characterData.name;
                        }
                        if (characterData.bio || characterData.description) {
                            document.getElementById('character-bio').value = characterData.bio || characterData.description;
                        }
                        
                        // å¤„ç†å¤´åƒ
                        const avatarData = characterData.avatarUrl || characterData.avatar;
                        if (avatarData && avatarData !== 'none' && avatarData !== '' && avatarData !== 'null') {
                            console.log('å¤„ç†å¤´åƒæ•°æ®:', avatarData.substring(0, 100) + '...');
                            
                            const avatarPreview = document.getElementById('avatar-preview');
                            const avatarPreviewText = document.getElementById('avatar-preview-text');
                            
                            if (avatarPreview && avatarPreviewText) {
                                console.log('ğŸ–¼ï¸ å¼€å§‹è®¾ç½®å¤´åƒï¼Œæ•°æ®é•¿åº¦:', avatarData.length);
                                
                                // æ£€æŸ¥æ˜¯å¦å¯èƒ½æ˜¯Base64ç¼–ç çš„å›¾ç‰‡æ•°æ®
                                let processedAvatarData = avatarData;
                                
                                // å¦‚æœæ˜¯é•¿å­—ç¬¦ä¸²ä¸”ä¸åŒ…å«åè®®ï¼Œå¯èƒ½æ˜¯Base64
                                if (avatarData.length > 100 && !avatarData.startsWith('http') && !avatarData.startsWith('data:')) {
                                    console.log('ğŸ–¼ï¸ æ£€æµ‹åˆ°å¯èƒ½çš„Base64æ•°æ®ï¼Œå°è¯•æ·»åŠ å‰ç¼€...');
                                    // å°è¯•æ£€æµ‹å›¾ç‰‡æ ¼å¼
                                    try {
                                        const firstBytes = atob(avatarData.substring(0, 32));
                                        const header = firstBytes.substring(0, 4);
                                        if (header.startsWith('\x89PNG')) {
                                            processedAvatarData = `data:image/png;base64,${avatarData}`;
                                            console.log('ğŸ–¼ï¸ æ£€æµ‹ä¸ºPNGæ ¼å¼');
                                        } else if (header.startsWith('\xFF\xD8\xFF')) {
                                            processedAvatarData = `data:image/jpeg;base64,${avatarData}`;
                                            console.log('ğŸ–¼ï¸ æ£€æµ‹ä¸ºJPEGæ ¼å¼');
                                        }
                                    } catch (e) {
                                        console.log('ğŸ–¼ï¸ Base64æ£€æµ‹å¤±è´¥:', e);
                                    }
                                }
                                
                                // æ›´å®½æ¾çš„å¤´åƒæ ¼å¼æ£€æŸ¥
                                if (processedAvatarData.startsWith('data:image/') || 
                                    processedAvatarData.startsWith('http') || 
                                    processedAvatarData.includes('.jpg') || 
                                    processedAvatarData.includes('.png') || 
                                    processedAvatarData.includes('.gif') ||
                                    processedAvatarData.includes('.jpeg') ||
                                    processedAvatarData.length > 100) { // é•¿å­—ç¬¦ä¸²å¯èƒ½æ˜¯Base64
                                    
                                    try {
                                        avatarPreview.classList.add('has-image');
                                        avatarPreview.style.setProperty('background-image', `url("${processedAvatarData}")`, 'important');
                                        avatarPreview.style.setProperty('background-size', 'cover', 'important');
                                        avatarPreview.style.setProperty('background-position', 'center', 'important');
                                        avatarPreview.style.setProperty('background-repeat', 'no-repeat', 'important');
                                        avatarPreviewText.style.display = 'none';
                                        window.selectedAvatarData = processedAvatarData;
                                        console.log('å¤´åƒè®¾ç½®æˆåŠŸ');
                                    } catch (e) {
                                        console.log('å¤´åƒè®¾ç½®å¤±è´¥:', e);
                                        showToast('å¤´åƒå¯¼å…¥å¤±è´¥ï¼Œä½†è§’è‰²ä¿¡æ¯å·²å¯¼å…¥', 'warning');
                                    }
                                } else {
                                    console.log('å¤´åƒæ•°æ®æ ¼å¼ä¸æ”¯æŒï¼ŒåŸå§‹æ•°æ®:', avatarData);
                                    showToast('å¤´åƒæ ¼å¼ä¸æ”¯æŒï¼Œè¯·æ‰‹åŠ¨ä¸Šä¼ å¤´åƒ', 'warning');
                                }
                            } else {
                                console.log('å¤´åƒé¢„è§ˆå…ƒç´ ä¸å­˜åœ¨');
                            }
                        } else {
                            console.log('å¤´åƒæ•°æ®ä¸ºç©ºæˆ–æ— æ•ˆ:', avatarData);
                        }
                        
                        // å¤„ç†ä¸–ç•Œä¹¦æ•°æ®
                        if (characterData.worldBooks && characterData.worldBooks.length > 0) {
                            console.log('å¼€å§‹å¯¼å…¥ä¸–ç•Œä¹¦æ•°æ®...');
                            await importWorldBooks(characterData.worldBooks, characterData.name);
                        } else {
                            console.log('ğŸ“š æ²¡æœ‰æ£€æµ‹åˆ°ä¸–ç•Œä¹¦æ•°æ®ï¼Œè·³è¿‡ä¸–ç•Œä¹¦å¯¼å…¥');
                        }
                        
                        const successMsg = 'è§’è‰²å¡å¯¼å…¥æˆåŠŸï¼' + 
                            (characterData.usePngAsAvatar ? ' å·²ä½¿ç”¨PNGå›¾ç‰‡ä½œä¸ºå¤´åƒã€‚' : '') +
                            (characterData.worldBooks && characterData.worldBooks.length > 0 ? `ï¼ˆåŒ…å«${characterData.worldBooks.length}ä¸ªä¸–ç•Œä¹¦ï¼‰` : '');
                        showToast(successMsg, 'success');
                    }
                } catch (error) {
                    console.error('å¯¼å…¥è§’è‰²å¡å¤±è´¥:', error);
                    showToast('å¯¼å…¥è§’è‰²å¡å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼', 'error');
                } finally {
                    window.isImporting = false;
                }
            };
            
            input.click();
        }
        
        // è§’è‰²å¡å¯¼å‡ºåŠŸèƒ½
        function exportCharacterCard() {
            if (!currentEditingCharacterId) {
                showToast('è¯·å…ˆä¿å­˜è§’è‰²å†å¯¼å‡º', 'error');
                return;
            }
            
            const character = characters.find(c => c.id === currentEditingCharacterId);
            if (!character) {
                showToast('æ‰¾ä¸åˆ°è¦å¯¼å‡ºçš„è§’è‰²', 'error');
                return;
            }
            
            // æ˜¾ç¤ºå¯¼å‡ºé€‰é¡¹
            showExportOptions(character);
        }
        
        // æ˜¾ç¤ºå¯¼å‡ºé€‰é¡¹å¯¹è¯æ¡†
        function showExportOptions(character) {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'flex';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h3 class="modal-title">å¯¼å‡ºè§’è‰²å¡</h3>
                        <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <p>è¯·é€‰æ‹©å¯¼å‡ºæ ¼å¼ï¼š</p>
                        <div style="margin: 15px 0;">
                            <button class="modal-button modal-primary" onclick="exportAsJSON('${character.id}'); this.closest('.modal').remove();" style="margin-right: 10px;">
                                <i class="fas fa-file-code"></i> JSONæ ¼å¼
                            </button>
                            <button class="modal-button modal-secondary" onclick="exportAsPNG('${character.id}'); this.closest('.modal').remove();">
                                <i class="fas fa-image"></i> PNGæ ¼å¼
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // ç‚¹å‡»èƒŒæ™¯å…³é—­
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            };
        }
        
        // å¯¼å‡ºä¸ºJSONæ ¼å¼
        function exportAsJSON(characterId) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;
            
            const characterData = {
                name: character.name,
                bio: character.bio,
                avatarUrl: character.avatarUrl,
                color: character.color,
                exportTime: new Date().toISOString(),
                version: '1.0'
            };
            
            const blob = new Blob([JSON.stringify(characterData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${character.name}_è§’è‰²å¡.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showToast('JSONæ ¼å¼è§’è‰²å¡å¯¼å‡ºæˆåŠŸ', 'success');
        }
        
        // å¯¼å‡ºä¸ºPNGæ ¼å¼
        async function exportAsPNG(characterId) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;
            
            try {
                // åˆ›å»ºåŒ…å«è§’è‰²æ•°æ®çš„PNGå›¾ç‰‡
                const characterData = {
                    name: character.name,
                    bio: character.bio,
                    avatarUrl: character.avatarUrl,
                    color: character.color,
                    exportTime: new Date().toISOString(),
                    version: '1.0'
                };
                
                // åˆ›å»ºç”»å¸ƒæ¥ç”ŸæˆPNG
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 400;
                canvas.height = 300;
                
                // ç»˜åˆ¶èƒŒæ™¯
                ctx.fillStyle = character.color || '#007AFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ç»˜åˆ¶è§’è‰²ä¿¡æ¯
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(character.name, canvas.width / 2, 50);
                
                ctx.font = '16px Arial';
                ctx.fillText('è§’è‰²å¡', canvas.width / 2, 80);
                
                // ç»˜åˆ¶å¤´åƒï¼ˆå¦‚æœæœ‰ï¼‰
                if (character.avatarUrl) {
                    try {
                        const img = new Image();
                        img.crossOrigin = 'anonymous';
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = reject;
                            img.src = character.avatarUrl;
                        });
                        
                        // ç»˜åˆ¶åœ†å½¢å¤´åƒ
                        const avatarSize = 100;
                        const avatarX = (canvas.width - avatarSize) / 2;
                        const avatarY = 120;
                        
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(avatarX + avatarSize/2, avatarY + avatarSize/2, avatarSize/2, 0, Math.PI * 2);
                        ctx.clip();
                        ctx.drawImage(img, avatarX, avatarY, avatarSize, avatarSize);
                        ctx.restore();
                    } catch (error) {
                        console.log('æ— æ³•ç»˜åˆ¶å¤´åƒ:', error);
                    }
                }
                
                // å°†è§’è‰²æ•°æ®åµŒå…¥åˆ°PNGçš„å…ƒæ•°æ®ä¸­
                const canvasBlob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                const pngWithMetadata = await embedDataInPNG(canvasBlob, characterData);
                
                // ä¸‹è½½æ–‡ä»¶
                const url = URL.createObjectURL(pngWithMetadata);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${character.name}_è§’è‰²å¡.png`;
                a.click();
                URL.revokeObjectURL(url);
                
                showToast('PNGæ ¼å¼è§’è‰²å¡å¯¼å‡ºæˆåŠŸ', 'success');
            } catch (error) {
                console.error('PNGå¯¼å‡ºå¤±è´¥:', error);
                showToast('PNGå¯¼å‡ºå¤±è´¥', 'error');
            }
        }
        
        // å¯¼å…¥ä¸–ç•Œä¹¦æ•°æ®
        async function importWorldBooks(worldBooks, characterName) {
            try {
                let importedCount = 0;
                
                for (const worldBook of worldBooks) {
                    // åˆ›å»ºä¸–ç•Œä¹¦å¯¹è±¡ï¼Œä½¿ç”¨æ›´å¥½çš„åˆ†ç±»å‘½å
                    const worldBookObj = {
                        id: Date.now() + Math.random(),
                        name: `[${characterName}] ${worldBook.name}`,
                        content: worldBook.content,
                        category: characterName, // æ·»åŠ åˆ†ç±»å­—æ®µ
                        source: 'character_card', // æ¥æºæ ‡è®°
                        createdAt: Date.now(),
                        updatedAt: Date.now()
                    };
                    
                    // ä¿å­˜åˆ°æ•°æ®åº“
                    try {
                        await db.worldbooks.add(worldBookObj);
                        console.log('ğŸ“š ä¸–ç•Œä¹¦å¯¼å…¥æˆåŠŸ:', worldBookObj.name);
                        importedCount++;
                    } catch (error) {
                        console.error('ğŸ“š ä¸–ç•Œä¹¦ä¿å­˜å¤±è´¥:', error);
                    }
                }
                
                if (importedCount > 0) {
                    showToast(`æˆåŠŸå¯¼å…¥${importedCount}ä¸ªä¸–ç•Œä¹¦åˆ°"${characterName}"åˆ†ç±»`, 'success');
                } else {
                    console.log('ğŸ“š æ²¡æœ‰æˆåŠŸå¯¼å…¥ä»»ä½•ä¸–ç•Œä¹¦');
                }
            } catch (error) {
                console.error('ä¸–ç•Œä¹¦å¯¼å…¥è¿‡ç¨‹å‡ºé”™:', error);
                showToast('ä¸–ç•Œä¹¦å¯¼å…¥å¤±è´¥', 'error');
            }
        }
        
        // åœ¨PNGä¸­åµŒå…¥æ•°æ®
        async function embedDataInPNG(blob, data) {
            const arrayBuffer = await blob.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            
            // ç®€å•çš„å®ç°ï¼šå°†JSONæ•°æ®ä½œä¸ºæ³¨é‡Šå—æ·»åŠ åˆ°PNGæœ«å°¾
            const jsonString = JSON.stringify(data);
            const textEncoder = new TextEncoder();
            const jsonBytes = textEncoder.encode(jsonString);
            
            // åˆ›å»ºä¸€ä¸ªåŒ…å«åŸå§‹PNGå’ŒJSONæ•°æ®çš„æ–°æ•°ç»„
            const newArray = new Uint8Array(uint8Array.length + jsonBytes.length + 8);
            newArray.set(uint8Array);
            
            // æ·»åŠ æ ‡è®°å’Œæ•°æ®é•¿åº¦
            const marker = textEncoder.encode('CHRD'); // è§’è‰²æ•°æ®æ ‡è®°
            newArray.set(marker, uint8Array.length);
            
            // æ·»åŠ æ•°æ®é•¿åº¦ï¼ˆ4å­—èŠ‚ï¼‰
            const dataView = new DataView(newArray.buffer);
            dataView.setUint32(uint8Array.length + 4, jsonBytes.length, true);
            
            // æ·»åŠ JSONæ•°æ®
            newArray.set(jsonBytes, uint8Array.length + 8);
            
            return new Blob([newArray], { type: 'image/png' });
        }
        
        // ä»PNGä¸­æå–è§’è‰²æ•°æ®
        async function extractCharacterFromPNG(file) {
            const arrayBuffer = await file.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            
            console.log('å¼€å§‹è§£æPNGæ–‡ä»¶ï¼Œæ–‡ä»¶å¤§å°:', uint8Array.length);
            
            // å°è¯•å¤šç§å¸¸è§çš„è§’è‰²å¡æ ¼å¼
            
            // 1. å°è¯•æˆ‘ä»¬çš„è‡ªå®šä¹‰æ ¼å¼ (CHRDæ ‡è®°)
            const textEncoder = new TextEncoder();
            const marker = textEncoder.encode('CHRD');
            
            for (let i = 0; i < uint8Array.length - marker.length - 4; i++) {
                let found = true;
                for (let j = 0; j < marker.length; j++) {
                    if (uint8Array[i + j] !== marker[j]) {
                        found = false;
                        break;
                    }
                }
                
                if (found) {
                    console.log('æ‰¾åˆ°CHRDæ ‡è®°ï¼Œæå–æ•°æ®...');
                    // è¯»å–æ•°æ®é•¿åº¦
                    const dataView = new DataView(uint8Array.buffer);
                    const dataLength = dataView.getUint32(i + marker.length, true);
                    
                    // æå–JSONæ•°æ®
                    const jsonStart = i + marker.length + 4;
                    const jsonBytes = uint8Array.slice(jsonStart, jsonStart + dataLength);
                    const textDecoder = new TextDecoder();
                    const jsonString = textDecoder.decode(jsonBytes);
                    
                    return JSON.parse(jsonString);
                }
            }
            
            // 2. å°è¯•CharacterAIæ ¼å¼ (åœ¨tEXtå—ä¸­æŸ¥æ‰¾charaå­—æ®µ)
            console.log('æœªæ‰¾åˆ°CHRDæ ‡è®°ï¼Œå°è¯•è§£æPNG tEXtå—...');
            try {
                const textData = extractPNGTextChunks(uint8Array);
                console.log('æ‰¾åˆ°çš„PNGæ–‡æœ¬å—:', Object.keys(textData));
                
                // æŸ¥æ‰¾charaå­—æ®µ
                if (textData.chara) {
                    console.log('æ‰¾åˆ°charaå­—æ®µï¼Œè§£ææ•°æ®...');
                    try {
                        const characterData = JSON.parse(textData.chara);
                        return convertCharacterAIFormat(characterData);
                    } catch (e) {
                        console.log('charaå­—æ®µJSONè§£æå¤±è´¥ï¼Œå°è¯•base64è§£ç ...');
                        try {
                            // ä½¿ç”¨æ›´å¥½çš„base64è§£ç æ–¹æ³•
                            const decoded = decodeBase64Text(textData.chara);
                            const characterData = JSON.parse(decoded);
                            return convertCharacterAIFormat(characterData);
                        } catch (e2) {
                            console.log('base64è§£ç ä¹Ÿå¤±è´¥:', e2);
                        }
                    }
                }
                
                // æŸ¥æ‰¾å…¶ä»–å¯èƒ½çš„å­—æ®µ
                for (const [key, value] of Object.entries(textData)) {
                    if (key.toLowerCase().includes('character') || key.toLowerCase().includes('card')) {
                        console.log(`å°è¯•è§£æå­—æ®µ ${key}:`, value.substring(0, 100));
                                                 try {
                             const characterData = JSON.parse(value);
                             return convertCharacterAIFormat(characterData);
                         } catch (e) {
                             try {
                                 const decoded = decodeBase64Text(value);
                                 const characterData = JSON.parse(decoded);
                                 return convertCharacterAIFormat(characterData);
                             } catch (e2) {
                                 console.log(`å­—æ®µ ${key} è§£æå¤±è´¥`);
                             }
                         }
                    }
                }
            } catch (e) {
                console.log('PNGæ–‡æœ¬å—è§£æå¤±è´¥:', e);
            }
            
            throw new Error('åœ¨PNGæ–‡ä»¶ä¸­æœªæ‰¾åˆ°è§’è‰²æ•°æ®');
        }
        
        // æå–PNGæ–‡ä»¶çš„tEXtå—
        function extractPNGTextChunks(uint8Array) {
            const textChunks = {};
            let offset = 8; // è·³è¿‡PNGç­¾å
            
            while (offset < uint8Array.length) {
                if (offset + 8 > uint8Array.length) break;
                
                // è¯»å–å—é•¿åº¦
                const length = new DataView(uint8Array.buffer).getUint32(offset, false);
                offset += 4;
                
                // è¯»å–å—ç±»å‹
                const type = new TextDecoder().decode(uint8Array.slice(offset, offset + 4));
                offset += 4;
                
                                 if (type === 'tEXt') {
                     // æå–tEXtå—æ•°æ®
                     const data = uint8Array.slice(offset, offset + length);
                     const nullIndex = data.indexOf(0);
                     if (nullIndex !== -1) {
                         const keyword = new TextDecoder('utf-8').decode(data.slice(0, nullIndex));
                         // å°è¯•å¤šç§ç¼–ç æ–¹å¼
                         let text;
                         try {
                             text = new TextDecoder('utf-8').decode(data.slice(nullIndex + 1));
                         } catch (e) {
                             try {
                                 text = new TextDecoder('latin1').decode(data.slice(nullIndex + 1));
                             } catch (e2) {
                                 text = new TextDecoder('ascii').decode(data.slice(nullIndex + 1));
                             }
                         }
                         textChunks[keyword] = text;
                         console.log(`æ‰¾åˆ°tEXtå—: ${keyword} = ${text.substring(0, 100)}...`);
                     }
                 } else if (type === 'zTXt') {
                    // å¤„ç†å‹ç¼©çš„æ–‡æœ¬å—
                    console.log('å‘ç°zTXtå—ï¼Œæš‚ä¸æ”¯æŒå‹ç¼©æ–‡æœ¬è§£æ');
                }
                
                // ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå—
                offset += length + 4; // +4 for CRC
                
                if (type === 'IEND') break;
            }
            
            return textChunks;
        }
        
        // æ›´å¥½çš„Base64è§£ç å‡½æ•°ï¼Œæ”¯æŒUTF-8
        function decodeBase64Text(base64String) {
            try {
                // æ–¹æ³•1ï¼šç›´æ¥atobç„¶åUTF-8è§£ç 
                const binaryString = atob(base64String);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return new TextDecoder('utf-8').decode(bytes);
            } catch (e) {
                console.log('UTF-8è§£ç å¤±è´¥ï¼Œå°è¯•ç›´æ¥atob:', e);
                try {
                    return atob(base64String);
                } catch (e2) {
                    console.log('Base64è§£ç å®Œå…¨å¤±è´¥:', e2);
                    throw e2;
                }
            }
        }
        
        // è½¬æ¢CharacterAIæ ¼å¼åˆ°æˆ‘ä»¬çš„æ ¼å¼
        function convertCharacterAIFormat(data) {
            console.log('ğŸ”§ è½¬æ¢CharacterAIæ ¼å¼æ•°æ®:', data);
            console.log('ğŸ”§ åŸå§‹æ•°æ®å­—æ®µ:', Object.keys(data));
            
            // æ¸…ç†æ–‡æœ¬å†…å®¹ï¼Œå¤„ç†å¯èƒ½çš„ç¼–ç é—®é¢˜
            function cleanText(text) {
                if (!text) return '';
                // å°è¯•ä¿®å¤å¸¸è§çš„ç¼–ç é—®é¢˜
                return text.replace(/\ufffd/g, '').trim();
            }
            
            // å¤„ç†å¤´åƒæ•°æ®
            function processAvatar(avatarData) {
                if (!avatarData || avatarData === 'none' || avatarData === '' || avatarData === 'null') {
                    console.log('å¤´åƒæ•°æ®ä¸ºç©ºæˆ–æ— æ•ˆ:', avatarData);
                    return '';
                }
                
                console.log('ğŸ–¼ï¸ åŸå§‹å¤´åƒæ•°æ®ç±»å‹:', typeof avatarData, 'é•¿åº¦:', avatarData.length);
                console.log('ğŸ–¼ï¸ å¤´åƒæ•°æ®å‰100å­—ç¬¦:', avatarData.substring(0, 100));
                
                // å¦‚æœå·²ç»æ˜¯æœ‰æ•ˆçš„URLæˆ–Base64ï¼Œç›´æ¥è¿”å›
                if (avatarData.startsWith('data:image/') || avatarData.startsWith('http')) {
                    return avatarData;
                }
                
                // å°è¯•Base64è§£ç å¹¶æ£€æŸ¥æ˜¯å¦æ˜¯å›¾ç‰‡
                try {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯çº¯Base64ç¼–ç çš„å›¾ç‰‡
                    if (avatarData.length > 100 && !avatarData.includes(' ') && !avatarData.includes('\n')) {
                        // å°è¯•è§£ç å‰å‡ ä¸ªå­—èŠ‚æ¥æ£€æŸ¥æ–‡ä»¶å¤´
                        const binaryString = atob(avatarData.substring(0, 32));
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        
                        // æ£€æŸ¥å¸¸è§çš„å›¾ç‰‡æ–‡ä»¶å¤´
                        const header = Array.from(bytes.slice(0, 8)).map(b => b.toString(16).padStart(2, '0')).join('');
                        
                        if (header.startsWith('89504e47')) { // PNG
                            return `data:image/png;base64,${avatarData}`;
                        } else if (header.startsWith('ffd8ff')) { // JPEG
                            return `data:image/jpeg;base64,${avatarData}`;
                        } else if (header.startsWith('47494638')) { // GIF
                            return `data:image/gif;base64,${avatarData}`;
                        } else if (header.startsWith('424d')) { // BMP
                            return `data:image/bmp;base64,${avatarData}`;
                        } else if (header.includes('57454250')) { // WEBP
                            return `data:image/webp;base64,${avatarData}`;
                        }
                    }
                } catch (e) {
                    console.log('Base64è§£ç å¤±è´¥:', e);
                }
                
                // å¦‚æœæ˜¯ç›¸å¯¹è·¯å¾„æˆ–å…¶ä»–æ ¼å¼ï¼Œå°è¯•è½¬æ¢
                if (avatarData.includes('.jpg') || avatarData.includes('.png') || 
                    avatarData.includes('.gif') || avatarData.includes('.jpeg') ||
                    avatarData.includes('.webp') || avatarData.includes('.bmp')) {
                    console.log('æ£€æµ‹åˆ°å¯èƒ½çš„å›¾ç‰‡æ–‡ä»¶å:', avatarData);
                    return avatarData;
                }
                
                console.log('æ— æ³•è¯†åˆ«å¤´åƒæ ¼å¼ï¼ŒåŸå§‹æ•°æ®å‰100å­—ç¬¦:', avatarData.substring(0, 100));
                return avatarData;
            }
            
            // æå–ä¸–ç•Œä¹¦/èƒŒæ™¯æ•…äº‹æ•°æ®
            function extractWorldBook(data) {
                console.log('ğŸ“š å¼€å§‹æ£€æŸ¥ä¸–ç•Œä¹¦æ•°æ®...');
                const worldBookData = [];
                
                // æŸ¥æ‰¾å¯èƒ½çš„ä¸–ç•Œä¹¦å­—æ®µ
                const worldBookFields = [
                    'world_scenario', 'scenario', 'world', 'background', 
                    'setting', 'lore', 'worldbook', 'world_book',
                    'mes_example', 'example_dialogue', 'example'
                ];
                
                worldBookFields.forEach(field => {
                    if (data[field] && typeof data[field] === 'string' && data[field].trim()) {
                        const content = cleanText(data[field]);
                        if (content.length > 20) { // åªæœ‰è¶³å¤Ÿé•¿çš„å†…å®¹æ‰ä½œä¸ºä¸–ç•Œä¹¦
                            const worldBookItem = {
                                name: field === 'scenario' ? 'èƒŒæ™¯æ•…äº‹' : 
                                      field === 'mes_example' ? 'å¯¹è¯ç¤ºä¾‹' :
                                      field === 'example_dialogue' ? 'å¯¹è¯ç¤ºä¾‹' :
                                      field === 'world' ? 'ä¸–ç•Œè®¾å®š' :
                                      field === 'setting' ? 'åœºæ™¯è®¾å®š' :
                                      field === 'lore' ? 'èƒŒæ™¯çŸ¥è¯†' : field,
                                content: content
                            };
                            worldBookData.push(worldBookItem);
                            console.log(`âœ… æ‰¾åˆ°ä¸–ç•Œä¹¦: ${worldBookItem.name} (${content.length}å­—ç¬¦)`);
                        }
                    }
                });
                
                if (worldBookData.length === 0) {
                    console.log('ğŸ“š æœªæ‰¾åˆ°ä»»ä½•ä¸–ç•Œä¹¦æ•°æ®');
                } else {
                    console.log(`ğŸ“š å…±æ‰¾åˆ° ${worldBookData.length} ä¸ªä¸–ç•Œä¹¦æ¡ç›®`);
                }
                return worldBookData;
            }
            
            const characterData = {
                name: cleanText(data.name || data.char_name || 'æœªçŸ¥è§’è‰²'),
                bio: cleanText(data.description || data.char_persona || data.personality || ''),
                prompt: cleanText(data.description || data.char_persona || data.personality || ''),
                avatarUrl: processAvatar(data.avatar || data.char_image || ''),
                color: '#007AFF', // é»˜è®¤é¢œè‰²
                // ä¿ç•™åŸå§‹æ•°æ®ä»¥ä¾›å‚è€ƒ
                originalData: data
            };
            
            // æ·»åŠ ä¸–ç•Œä¹¦æ•°æ®
            const worldBooks = extractWorldBook(data);
            if (worldBooks.length > 0) {
                characterData.worldBooks = worldBooks;
                console.log('æå–åˆ°ä¸–ç•Œä¹¦æ•°æ®:', worldBooks);
            }
            
            return characterData;
        }

        // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†AIæ’¤å›æ¶ˆæ¯åŠŸèƒ½
        async function handleRecalledMessage(messageContent, targetMessageId = null) {
            if (!currentChatCharacter) return;
            
            console.log('å¤„ç†æ’¤å›æ¶ˆæ¯:', messageContent, 'ç›®æ ‡æ¶ˆæ¯ID:', targetMessageId);
            
            const messagesContainer = document.getElementById('api-chat-messages');
            if (!messagesContainer) return;
            
            const character = characters.find(c => c.id === currentChatCharacter.id);
            const chatSettings = getCurrentChatSettings();
            const displayName = chatSettings.aiChatNickname || character.name;
            
            let messageContainer = null;
            
            // å¦‚æœæä¾›äº†ç›®æ ‡æ¶ˆæ¯IDï¼ŒæŸ¥æ‰¾å¹¶æ’¤å›ç°æœ‰æ¶ˆæ¯
            if (targetMessageId) {
                messageContainer = messagesContainer.querySelector(`[data-message-id="${targetMessageId}"]`);
                if (messageContainer) {
                    console.log('æ‰¾åˆ°è¦æ’¤å›çš„ç°æœ‰æ¶ˆæ¯ï¼Œå‡†å¤‡æ’¤å›');
                    
                    // ç­‰å¾…1.2ç§’åæ’¤å›
                    await new Promise(resolve => setTimeout(resolve, 1200));
                    
                    // æ·»åŠ æ·¡å‡ºåŠ¨ç”»
                    messageContainer.style.animation = 'fadeOut 0.5s ease-in-out forwards';
                    
                    // ç­‰å¾…åŠ¨ç”»å®Œæˆ
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // ä»èŠå¤©è®°å½•ä¸­ç§»é™¤è¿™æ¡æ¶ˆæ¯
                    if (chatMessages[currentChatCharacter.id]) {
                        const messageIndex = chatMessages[currentChatCharacter.id].findIndex(msg => msg.id === targetMessageId);
                        if (messageIndex !== -1) {
                            chatMessages[currentChatCharacter.id].splice(messageIndex, 1);
                            saveChatMessages();
                        }
                    }
                } else {
                    console.warn('æœªæ‰¾åˆ°è¦æ’¤å›çš„æ¶ˆæ¯ï¼Œåˆ›å»ºä¸´æ—¶æ¶ˆæ¯');
                    // å¦‚æœæ‰¾ä¸åˆ°æ¶ˆæ¯ï¼Œå›é€€åˆ°åˆ›å»ºä¸´æ—¶æ¶ˆæ¯çš„æ–¹å¼
                    messageContainer = await createTemporaryMessage(messageContent);
                }
            } else {
                // æ²¡æœ‰æä¾›ç›®æ ‡IDï¼Œåˆ›å»ºä¸´æ—¶æ¶ˆæ¯
                messageContainer = await createTemporaryMessage(messageContent);
            }
            
            if (!messageContainer) return;
            
            // åˆ›å»ºæ’¤å›æé†’çš„å±…ä¸­å®¹å™¨
            const centerContainer = document.createElement('div');
            centerContainer.style.display = 'flex';
            centerContainer.style.justifyContent = 'center';
            centerContainer.style.margin = '4px 0';
            
            // åˆ›å»ºæ’¤å›æ¶ˆæ¯å…ƒç´ 
            const recallElement = document.createElement('div');
            recallElement.className = 'recalled-message';
            
            // ä¸»è¦æé†’æ–‡å­—
            const mainText = document.createElement('div');
            mainText.style.marginBottom = '2px';
            mainText.textContent = `å¯¹æ–¹æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`;
            
            // åŸæ–‡æ˜¾ç¤º
            const originalText = document.createElement('div');
            originalText.className = 'original-text';
            originalText.textContent = `åŸæ–‡ï¼š${messageContent}`;
            
            recallElement.appendChild(mainText);
            recallElement.appendChild(originalText);
            centerContainer.appendChild(recallElement);
            
            // åœ¨åŸæ¶ˆæ¯ä½ç½®æ›¿æ¢ä¸ºæ’¤å›æé†’
            messageContainer.parentNode.insertBefore(centerContainer, messageContainer);
            messageContainer.remove();
            
            // æ·»åŠ æ’¤å›æ¶ˆæ¯åˆ°èŠå¤©å†å²
            const recalledMessage = {
                id: `recalled_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                sender: 'system',
                type: 'recalled_message',
                content: `å¯¹æ–¹æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯\nåŸæ–‡ï¼š${messageContent}`,
                originalContent: messageContent,
                    timestamp: Date.now()
                };
                
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            chatMessages[currentChatCharacter.id].push(recalledMessage);
                saveChatMessages();
            
            // æ»šåŠ¨åˆ°åº•éƒ¨
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // åˆ›å»ºä¸´æ—¶æ¶ˆæ¯çš„è¾…åŠ©å‡½æ•°
            async function createTemporaryMessage(content) {
                const messageId = `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                
                const tempContainer = document.createElement('div');
                const isEmojiOnly = false;
                tempContainer.className = `message-container received${isEmojiOnly ? ' emoji-only' : ''}`;
                tempContainer.dataset.messageId = messageId;
                
                const bubbleColor = chatSettings.aiBubbleColor || '#f0f0f0';
                const bubbleOpacity = chatSettings.aiBubbleOpacity || '1';
                const textColor = isLightColor(bubbleColor) ? '#333' : '#fff';
                const bubblePadding = chatSettings.bubblePadding || '12';
                const displayAvatar = chatSettings.aiDynamicAvatar || chatSettings.aiChatAvatar || character.avatarUrl;
                
                let avatarHtml = '';
                if (!chatSettings.hideAvatars) {
                    avatarHtml = `
                        <div class="message-avatar" style="background-color: ${character.color}; ${displayAvatar ? `background-image: url(${displayAvatar}); background-size: cover; background-position: center;` : ''}" onclick="pokeCharacter('${character.id}')" title="æˆ³ä¸€æˆ³">
                            ${displayAvatar ? '' : displayName.charAt(0)}
                        </div>
                    `;
                }
                
                // å°†é€æ˜åº¦åº”ç”¨åˆ°èƒŒæ™¯è‰²è€Œä¸æ˜¯æ•´ä¸ªå…ƒç´ 
                const transparentBubbleColor = convertColorWithOpacity(bubbleColor, bubbleOpacity);
                
                let bubbleHtml = `
                    <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                        ${content}
                    </div>
                `;
                
                tempContainer.innerHTML = avatarHtml + bubbleHtml;
                
                // æ·»åŠ åˆ°æ¶ˆæ¯å®¹å™¨
                const typingIndicator = messagesContainer.querySelector('#typing-indicator');
                if (typingIndicator) {
                    messagesContainer.insertBefore(tempContainer, typingIndicator);
                } else {
                    messagesContainer.appendChild(tempContainer);
                }
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                
                // ç­‰å¾…1.2ç§’åæ’¤å›
                await new Promise(resolve => setTimeout(resolve, 1200));
                
                // æ·»åŠ æ·¡å‡ºåŠ¨ç”»
                tempContainer.style.animation = 'fadeOut 0.5s ease-in-out forwards';
                
                // ç­‰å¾…åŠ¨ç”»å®Œæˆ
                await new Promise(resolve => setTimeout(resolve, 500));
                
                return tempContainer;
            }
        }
        
        // ğŸ”¥ã€æ–°å¢ã€‘è·å–ç”¨æˆ·æœ€è¿‘å‘é€çš„å›¾ç‰‡URL
        function getRecentUserImage() {
            if (!currentChatCharacter || !chatMessages[currentChatCharacter.id]) {
                return null;
            }
            
            const messages = chatMessages[currentChatCharacter.id];
            // ä»æœ€æ–°æ¶ˆæ¯å¼€å§‹å‘å‰æŸ¥æ‰¾ç”¨æˆ·å‘é€çš„å›¾ç‰‡
            for (let i = messages.length - 1; i >= 0; i--) {
                const msg = messages[i];
                if (msg.sender === 'sent' && msg.image && !msg.isEmoji) {
                    console.log('æ‰¾åˆ°ç”¨æˆ·æœ€è¿‘å‘é€çš„å›¾ç‰‡:', msg.image);
                    return msg.image;
                }
            }
            
            console.log('æ²¡æœ‰æ‰¾åˆ°ç”¨æˆ·å‘é€çš„å›¾ç‰‡');
            return null;
        }
        
        // APIè°ƒç”¨å‡½æ•° - åŸºäºç°æœ‰çš„APIé€»è¾‘
        async function callChatAPI(prompt, character) {
            try {
                // è·å–è§’è‰²è®¾ç½®
                let chatSettings = null;
                try {
                    chatSettings = await db.chatSettings.get(character.id);
                } catch (error) {
                    console.error('è·å–èŠå¤©è®¾ç½®å¤±è´¥:', error);
                }
                
                const persona = chatSettings?.aiPersona || character.prompt || `ä½ æ˜¯${character.name}ã€‚`;
                
                // è·å–ç»‘å®šçš„ä¸–ç•Œä¹¦å†…å®¹
                let worldBookContent = '';
                if (chatSettings?.linkedWorldBookIds && chatSettings.linkedWorldBookIds.length > 0) {
                    try {
                        const worldBooks = await Promise.all(
                            chatSettings.linkedWorldBookIds.map(id => db.worldbooks.get(id))
                        );
                        const validWorldBooks = worldBooks.filter(book => book && book.content);
                        if (validWorldBooks.length > 0) {
                            worldBookContent = '\n\nä¸–ç•Œä¹¦å†…å®¹ï¼ˆä¾›å‚è€ƒï¼‰ï¼š\n' + 
                                validWorldBooks.map(book => `${book.name}ï¼š${book.content}`).join('\n\n');
                        }
                    } catch (error) {
                        console.error('è·å–ä¸–ç•Œä¹¦å†…å®¹å¤±è´¥:', error);
                    }
                }
                
                // è·å–èŠå¤©ä¸Šä¸‹æ–‡
                let chatContext = '';
                const characterMessages = chatMessages[character.id] || [];
                if (characterMessages.length > 0) {
                    const maxMemory = parseInt(chatSettings?.maxMemory) || 10;
                    const recentHistory = characterMessages.slice(-maxMemory);
                    chatContext = '\n\næœ€è¿‘çš„èŠå¤©è®°å½•ï¼ˆä¾›å‚è€ƒï¼‰ï¼š\n' + 
                        recentHistory.map(msg => {
                            if (msg.sender === 'sent') return `ç”¨æˆ·ï¼š${msg.content}`;
                            return `${character.name}ï¼š${msg.content}`;
                        }).join('\n');
                }
                
                const systemPrompt = `ä½ æ˜¯${character.name}ï¼Œä½ çš„äººè®¾å¦‚ä¸‹ï¼š${persona}ã€‚${worldBookContent}${chatContext}

aiæ³¨æ„ï¼Œå›å¤æ—¶è¯·ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹JSONæ ¼å¼å›å¤ï¼Œæ¯æ¡æ¶ˆæ¯éƒ½å¿…é¡»æ˜¯ç‹¬ç«‹çš„æ•°ç»„å…ƒç´ ï¼Œä¸è¦å°†å¤šæ¡æ¶ˆæ¯åˆå¹¶æˆä¸€ä¸ªå…ƒç´ ï¼Œå¦åˆ™ä½ å°†å¤±å»ä¸€ç™¾ç¾é‡‘ï¼ï¼ï¼š

æ­£ç¡®æ ¼å¼ç¤ºä¾‹ï¼š
["æ™®é€šæ–‡æœ¬æ¶ˆæ¯"]
["æ¶ˆæ¯1", "æ¶ˆæ¯2"]
[{"type": "reply_to", "message_id": "æ¶ˆæ¯ID", "content": "å¼•ç”¨å›å¤å†…å®¹"}] (æ­£å¸¸åŠŸèƒ½ï¼Œè‡ªç„¶ä½¿ç”¨)
[{"type": "recall", "target": "previous"}] (æ’¤å›åŠŸèƒ½ï¼Œè¯´é”™è¯æˆ–åæ‚”æ—¶ä½¿ç”¨)
[{"type": "voice_message", "content": "è¯­éŸ³å†…å®¹"}]
[{"type": "emoji", "description": "è¡¨æƒ…åŒ…æè¿°"}]
[{"type": "ai_image", "description": "å›¾ç‰‡æè¿°"}]
[{"type": "transfer", "amount": 100, "note": "è½¬è´¦å¤‡æ³¨"}]

ğŸš¨ é‡è¦ï¼šç»å¯¹ä¸èƒ½å°†å¤šæ¡æ¶ˆæ¯åˆå¹¶åœ¨ä¸€ä¸ªå…ƒç´ ä¸­ï¼é”™è¯¯æ ¼å¼ï¼š["æ¶ˆæ¯1\\næ¶ˆæ¯2"]
ğŸ’¡ æé†’ï¼šå¼•ç”¨å›å¤å’Œæ’¤å›æ˜¯æ­£å¸¸èŠå¤©åŠŸèƒ½ï¼ŒåƒçœŸäººä¸€æ ·è‡ªç„¶ä½¿ç”¨

ç°åœ¨è¯·å¯¹ç”¨æˆ·çš„æ¶ˆæ¯è¿›è¡Œå›å¤ï¼š${prompt}`;

                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: prompt }
                ];

                const { base: proxyUrl, key: apiKey, model } = apiSettings;
                if (!proxyUrl || !apiKey || !model) {
                    console.log('APIé…ç½®ä¸å®Œæ•´ï¼Œè·³è¿‡AIå›å¤');
                    return '["APIé…ç½®ä¸å®Œæ•´ï¼Œè¯·åœ¨è®¾ç½®ä¸­é…ç½®API"]';
                }

                const requestBody = {
                    model: model,
                    messages: messages,
                    temperature: 0.8,
                    stream: false
                };

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000);

                const isGeminiOfficial = proxyUrl.includes('generativelanguage.googleapis.com');

                let response;
                if (isGeminiOfficial) {
                    const apiUrl = `${proxyUrl}/models/${model}:generateContent?key=${apiKey}`;
                    
                    const geminiMessages = [];
                    if (requestBody.messages[0]?.role === 'system') {
                        geminiMessages.push({
                            role: 'user',
                            parts: [{ text: requestBody.messages[0].content }]
                        });
                        geminiMessages.push({
                            role: 'model',
                            parts: [{ text: 'æˆ‘æ˜ç™½äº†ï¼Œæˆ‘ä¼šæŒ‰ç…§è¿™äº›è¦æ±‚è¿›è¡Œå¯¹è¯ã€‚' }]
                        });
                    }
                    
                    for (let i = 1; i < requestBody.messages.length; i++) {
                        const msg = requestBody.messages[i];
                        if (msg.role === 'system') continue;
                        
                        geminiMessages.push({
                            role: msg.role === 'user' ? 'user' : 'model',
                            parts: [{ text: msg.content }]
                        });
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiMessages,
                            generationConfig: {
                                temperature: requestBody.temperature || 0.8
                            }
                        }),
                        signal: controller.signal
                    });
                } else {
                    // ä¿®å¤ï¼šæ™ºèƒ½å¤„ç†URLæ‹¼æ¥
                    let apiUrl;
                    if (proxyUrl.endsWith('/v1')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else if (proxyUrl.includes('/v1/')) {
                        // å¦‚æœURLä¸­å·²ç»åŒ…å«/v1/è·¯å¾„ï¼Œç›´æ¥æ·»åŠ chat/completions
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else {
                        apiUrl = `${proxyUrl}/v1/chat/completions`;
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal
                    });
                }

                clearTimeout(timeoutId);

                if (!response.ok) {
                    let errorText = await response.text();
                    console.error(`èŠå¤©APIè°ƒç”¨å¤±è´¥ (${response.status}): ${errorText}`);
                    return `["APIè°ƒç”¨å¤±è´¥: ${response.status}"]`;
                }

                const data = await response.json();
                let content;

                if (isGeminiOfficial) {
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!content) {
                        console.log('Gemini API å“åº”æ•°æ®:', data);
                        return '["Gemini APIå“åº”å¼‚å¸¸"]';
                    }
                } else {
                    if (data.choices && data.choices.length > 0 && data.choices[0].message) {
                        content = data.choices[0].message.content;
                    } else if (data.message) {
                        content = data.message;
                    } else if (data.text) {
                        content = data.text;
                    } else if (data.response) {
                        content = data.response;
                    } else if (data.content) {
                        content = data.content;
                    } else if (data.result) {
                        content = data.result;
                    } else {
                        console.error('æ— æ³•è§£æAPIå“åº”ï¼Œå®Œæ•´å“åº”æ•°æ®:', data);
                        return '["APIå“åº”è§£æå¤±è´¥"]';
                    }
                }

                return content;

            } catch (error) {
                console.error('callChatAPIå¤±è´¥:', error);
                return `["è°ƒç”¨å¤±è´¥: ${error.message}"]`;
            }
        }
        
        // å¸¦å›¾ç‰‡çš„APIè°ƒç”¨å‡½æ•°
        async function callChatAPIWithImage(prompt, character, imageUrl) {
            // å›¾åƒåŠŸèƒ½æš‚æœªå®ç°ï¼Œä½¿ç”¨æ™®é€šAPIè°ƒç”¨
            const imagePrompt = `${prompt}\n\n[ç”¨æˆ·å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼Œä½†å›¾åƒè¯†åˆ«åŠŸèƒ½æš‚æœªå®ç°]`;
            return await callChatAPI(imagePrompt, character);
        }
        
        // è§£æAIå›å¤ - æŒ‰ç…§index.htmlçš„é€»è¾‘ï¼Œæ–°å¢è¡¨æƒ…åŒ…æ”¯æŒå’Œæ ¼å¼ä¿®æ­£
        function parseAiResponse(content) {
            console.log('ğŸ”¥ [DEBUG] parseAiResponse æ”¶åˆ°çš„åŸå§‹å†…å®¹:', content);
            try {
                // ğŸ”¥ã€ä¿®å¤ã€‘æ¸…ç†markdownä»£ç å—æ ¼å¼
                let cleanContent = content.trim();
                if (cleanContent.startsWith('```json')) {
                    cleanContent = cleanContent.replace(/^```json\s*/, '').replace(/\s*```$/, '');
                } else if (cleanContent.startsWith('```')) {
                    cleanContent = cleanContent.replace(/^```\s*/, '').replace(/\s*```$/, '');
                }

                const parsed = JSON.parse(cleanContent);
                console.log('ğŸ”¥ [DEBUG] JSONè§£ææˆåŠŸ:', parsed);
                if (Array.isArray(parsed)) {
                    // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†è¡¨æƒ…åŒ…æ¶ˆæ¯ç±»å‹å’Œæ ¼å¼ä¿®æ­£
                    const processedMessages = [];
                    
                    parsed.forEach(item => {
                        if (typeof item === 'object' && item.name && item.type === 'emoji') {
                            // å¤„ç†ç¾¤èŠè¡¨æƒ…åŒ…æ ¼å¼ {"name": "è§’è‰²å", "type": "emoji", "description": "è¡¨æƒ…åŒ…æè¿°"}

                            const matchingEmoji = customEmojis.find(emoji =>
                                emoji.description === item.description
                            );

                            if (matchingEmoji) {
                                // æ£€æŸ¥è¡¨æƒ…åŒ…æ˜¯å¦ä¸ºGIFæ ¼å¼
                                if (matchingEmoji.url && matchingEmoji.url.includes('data:image/gif')) {
                                    console.warn('AIå°è¯•ä½¿ç”¨GIFæ ¼å¼è¡¨æƒ…åŒ…:', item.description);
                                    processedMessages.push({
                                        name: item.name,
                                        message: `[${matchingEmoji.description}] (GIFæ ¼å¼ä¸æ”¯æŒAPIè¯†åˆ«)`
                                    });
                                } else {
                                    // ä¿æŒåŸå§‹çš„ç¾¤èŠè¡¨æƒ…åŒ…æ ¼å¼ï¼Œç›´æ¥ä¼ é€’ç»™callChatAPIå¤„ç†
                                    processedMessages.push(item); // ç›´æ¥æ¨é€åŸå§‹æ ¼å¼
                                }
                            } else {
                                // å¦‚æœæ‰¾ä¸åˆ°åŒ¹é…çš„è¡¨æƒ…åŒ…ï¼Œè¿”å›é”™è¯¯æ¶ˆæ¯
                                console.warn('AIå°è¯•ä½¿ç”¨ä¸å­˜åœ¨çš„è¡¨æƒ…åŒ…:', item.description);
                                processedMessages.push({
                                    name: item.name,
                                    message: `[é”™è¯¯: è¡¨æƒ…åŒ…"${item.description}"ä¸å­˜åœ¨]`
                                });
                            }
                        } else if (typeof item === 'object' && item.type === 'emoji') {
                            // å¤„ç†å•èŠè¡¨æƒ…åŒ…æ ¼å¼

                            const matchingEmoji = customEmojis.find(emoji =>
                                emoji.description === item.description
                            );

                            if (matchingEmoji) {
                                // æ£€æŸ¥è¡¨æƒ…åŒ…æ˜¯å¦ä¸ºGIFæ ¼å¼
                                if (matchingEmoji.url && matchingEmoji.url.includes('data:image/gif')) {
                                    console.warn('AIå°è¯•ä½¿ç”¨GIFæ ¼å¼è¡¨æƒ…åŒ…:', item.description);
                                    processedMessages.push(`[${matchingEmoji.description}] (GIFæ ¼å¼ä¸æ”¯æŒAPIè¯†åˆ«)`);
                                } else {
                                    const emojiMessage = {
                                        type: 'emoji',
                                        url: matchingEmoji.url,
                                        description: matchingEmoji.description,
                                        id: matchingEmoji.id
                                    };

                                    // è¡¨æƒ…åŒ…æ¶ˆæ¯å¤„ç†å®Œæˆ
                                    processedMessages.push(emojiMessage);
                                }
                            } else {
                                // å¦‚æœæ‰¾ä¸åˆ°åŒ¹é…çš„è¡¨æƒ…åŒ…ï¼Œè¿”å›é”™è¯¯æ¶ˆæ¯
                                console.warn('AIå°è¯•ä½¿ç”¨ä¸å­˜åœ¨çš„è¡¨æƒ…åŒ…:', item.description);
                                processedMessages.push(`[é”™è¯¯: è¡¨æƒ…åŒ…"${item.description}"ä¸å­˜åœ¨]`);
                            }
                        } else if (typeof item === 'object' && item.type === 'ai_photo') {
                            // å¤„ç†è§’è‰²å‘é€çš„"ä¼ªç…§ç‰‡"
                            // ç¡®ä¿æˆ‘ä»¬æœ‰ä¸€ä¸ªæœ‰æ•ˆçš„æè¿°
                            const photoDesc = item.description || 'è§’è‰²å‘é€çš„ç…§ç‰‡';
                            processedMessages.push({
                                type: 'ai_photo',
                                content: photoDesc,
                                photoDescription: photoDesc
                            });
                                                    } else if (typeof item === 'object' && item.type === 'location') {
                                // å¤„ç†è§’è‰²å‘é€çš„ä½ç½®
                                // ç¡®ä¿æˆ‘ä»¬æœ‰ä¸€ä¸ªæœ‰æ•ˆçš„ä½ç½®åç§°
                                const locationName = item.name || item.locationName || 'æœªçŸ¥ä½ç½®';
                                processedMessages.push({
                                    type: 'location',
                                    locationName: locationName,
                                    coordinates: item.coordinates || 'æœªçŸ¥åæ ‡',
                                    content: `[è§’è‰²åˆ†äº«äº†ä½ç½®ä¿¡æ¯ï¼š${locationName}]`
                                });
                        } else if (typeof item === 'object' && item.type === 'change_avatar') {
                            // å¤„ç†å¤´åƒæ›´æ¢å¯¹è±¡

                            
                            // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†å„ç§é”™è¯¯çš„å ä½ç¬¦
                            if (item.avatar_url === 'CURRENT_USER_IMAGE' || 
                                item.avatar_url === 'CURRENT_USER_IMAGE' || 
                                item.avatar_url === 'ç”¨æˆ·å‘é€çš„å›¾ç‰‡URL' ||
                                item.avatar_url === 'å›¾ç‰‡URL') {
                                // è·å–æœ€è¿‘ç”¨æˆ·å‘é€çš„å›¾ç‰‡URL
                                const recentUserImage = getRecentUserImage();
                                if (recentUserImage) {
                                    item.avatar_url = recentUserImage;
                                    console.log('å°†å ä½ç¬¦æ›¿æ¢ä¸ºå®é™…å›¾ç‰‡URL:', recentUserImage);
                                } else {
                                    console.warn('æ²¡æœ‰æ‰¾åˆ°ç”¨æˆ·æœ€è¿‘å‘é€çš„å›¾ç‰‡ï¼Œå¿½ç•¥å¤´åƒæ›´æ¢è¯·æ±‚');
                                    processedMessages.push(`[ç³»ç»Ÿï¼šæ— æ³•æ›´æ¢å¤´åƒï¼Œæ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„å›¾ç‰‡]`);
                                    // ä¸è¦returnï¼Œç»§ç»­å¤„ç†å…¶ä»–æ¶ˆæ¯
                                }
                            }
                            
                            processedMessages.push(item);
                        } else if (typeof item === 'object' && item.type === 'ai_image') {
                            // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†AIå‘é€å›¾ç‰‡

                            processedMessages.push(item);
                        } else if (typeof item === 'object' && item.type === 'voice_message') {
                            // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†AIå‘é€è¯­éŸ³

                            processedMessages.push(item);
                        } else if (typeof item === 'object' && item.type === 'transfer') {
                            // ğŸ”¥ã€ä¿®å¤ã€‘å¤„ç†AIè½¬è´¦ - ç¡®ä¿æ ¼å¼æ­£ç¡®
                            processedMessages.push({
                                type: 'transfer',
                                amount: item.amount || 0,
                                note: item.note || 'è½¬è´¦'
                            });
                        } else if (typeof item === 'object' && item.type === 'update_poke_suffix') {
                            // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†æˆ³ä¸€æˆ³åç¼€æ›´æ–°

                            processedMessages.push(item);
                        } else if (typeof item === 'object' && item.type === 'recall') {
                            // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†AIä¸»åŠ¨æ’¤å›æ¶ˆæ¯
                            if (item.target === 'previous') {
                                // æ’¤å›ä¸Šä¸€æ¡æ¶ˆæ¯
                                processedMessages.push({
                                    type: 'recall_previous',
                                    content: '[AIæ’¤å›äº†ä¸Šä¸€æ¡æ¶ˆæ¯]'
                                });
                            }
                        } else if (typeof item === 'object' && item.type === 'reply') {
                            // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†AIå¼•ç”¨å›å¤
                            processedMessages.push({
                                type: 'reply_message',
                                messageId: item.messageId,
                                content: item.content || ''
                            });
                        } else if (typeof item === 'object' && item.type === 'photo') {
                            // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†AIå‘é€ç…§ç‰‡å¡ç‰‡
                            processedMessages.push({
                                type: 'user_photo',
                                content: item.description || 'AIåˆ†äº«çš„ç…§ç‰‡',
                                photoDescription: item.description
                            });
                        } else if (typeof item === 'object' && item.type === 'recalled_message') {
                            // ğŸ”¥ã€ä¿ç•™ã€‘å¤„ç†ç³»ç»Ÿæ’¤å›æ¶ˆæ¯

                            processedMessages.push(item);
                        } else if (typeof item === 'object' && item.type === 'reply_to') {
                            // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†AIå¼•ç”¨å›å¤
                            processedMessages.push({
                                type: 'reply_to',
                                message_id: item.message_id,
                                content: item.content || ''
                            });
                        } else if (typeof item === 'object' && item.type === 'friend_request') {
                            // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†AIä¸»åŠ¨å‘é€å¥½å‹ç”³è¯·
                            processedMessages.push({
                                type: 'friend_request',
                                message: item.message || 'æƒ³å’Œä½ é‡æ–°åšæœ‹å‹'
                            });
                        } else if (typeof item === 'string') {
                            // ğŸš¨ ã€æ–°å¢ã€‘æ£€æŸ¥å¹¶ä¿®å¤åˆå¹¶æ¶ˆæ¯é—®é¢˜
                            if (item.includes('\n')) {
                                console.warn('æ£€æµ‹åˆ°AIå°†å¤šæ¡æ¶ˆæ¯åˆå¹¶åœ¨ä¸€ä¸ªå…ƒç´ ä¸­ï¼Œæ­£åœ¨è‡ªåŠ¨åˆ†æ‹†:', item);
                                // å°†æ¢è¡Œç¬¦åˆ†éš”çš„å†…å®¹åˆ†æ‹†æˆå¤šæ¡æ¶ˆæ¯
                                const splitMessages = item.split('\n')
                                    .map(msg => msg.trim())
                                    .filter(msg => msg.length > 0);
                                processedMessages.push(...splitMessages);
                            } else {
                                processedMessages.push(item);
                            }
                        } else {
                            processedMessages.push(item);
                        }
                    });
                    
                    return processedMessages;
                }
            } catch (e) {} 
            
            try { 
                const match = content.match(/\[(.*?)\]/s); 
                if (match && match[0]) { 
                    const parsed = JSON.parse(match[0]); 
                    if (Array.isArray(parsed)) {
                        // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†è¡¨æƒ…åŒ…æ¶ˆæ¯ç±»å‹å’Œæ ¼å¼ä¿®æ­£
                        const processedMessages = [];
                        
                        parsed.forEach(item => {
                            if (typeof item === 'object' && item.type === 'emoji') {
                                // ğŸ”¥ã€ä¿®å¤ã€‘å¤„ç†å•èŠè¡¨æƒ…åŒ…æ ¼å¼ï¼ˆç¬¬äºŒå¤„ï¼‰
                                const matchingEmoji = customEmojis.find(emoji =>
                                    emoji.description === item.description
                                );

                                if (matchingEmoji) {
                                    // æ£€æŸ¥è¡¨æƒ…åŒ…æ˜¯å¦ä¸ºGIFæ ¼å¼
                                    if (matchingEmoji.url && matchingEmoji.url.includes('data:image/gif')) {
                                        console.warn('AIå°è¯•ä½¿ç”¨GIFæ ¼å¼è¡¨æƒ…åŒ…:', item.description);
                                        processedMessages.push(`[${matchingEmoji.description}] (GIFæ ¼å¼ä¸æ”¯æŒAPIè¯†åˆ«)`);
                                    } else {
                                    // è¿”å›è¡¨æƒ…åŒ…å¯¹è±¡ï¼ŒåŒ…å«å®Œæ•´çš„è¡¨æƒ…åŒ…ä¿¡æ¯
                                        processedMessages.push({
                                        type: 'emoji',
                                        url: matchingEmoji.url,
                                        description: matchingEmoji.description,
                                        id: matchingEmoji.id
                                        });
                                    }
                                } else {
                                    // å¦‚æœæ‰¾ä¸åˆ°åŒ¹é…çš„è¡¨æƒ…åŒ…ï¼Œè¿”å›é”™è¯¯æ¶ˆæ¯
                                    console.warn('AIå°è¯•ä½¿ç”¨ä¸å­˜åœ¨çš„è¡¨æƒ…åŒ…:', item.description);
                                    processedMessages.push(`[é”™è¯¯: è¡¨æƒ…åŒ…"${item.description}"ä¸å­˜åœ¨]`);
                                }
                            } else if (typeof item === 'object' && item.name && item.type === 'emoji') {
                                // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘å¤„ç†ç¾¤èŠè¡¨æƒ…åŒ…æ ¼å¼ï¼ˆç¬¬äºŒå¤„ï¼‰- è¿™ä¸ªåˆ†æ”¯åº”è¯¥ä¸ä¼šè¢«æ‰§è¡Œï¼Œå› ä¸ºç¬¬ä¸€ä¸ªåˆ†æ”¯å·²ç»å¤„ç†äº†
                                console.log('ğŸ” [parseAiResponse-ç¾¤èŠè¡¨æƒ…åŒ…-ç¬¬äºŒå¤„] æ£€æµ‹åˆ°é‡å¤çš„ç¾¤èŠè¡¨æƒ…åŒ…å¯¹è±¡:', item);
                                // ç›´æ¥æ¨é€åŸå§‹æ ¼å¼ï¼Œè®©callChatAPIå¤„ç†
                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'ai_photo') {
                                // å¤„ç†è§’è‰²å‘é€çš„"ä¼ªç…§ç‰‡"
                                // ç¡®ä¿æˆ‘ä»¬æœ‰ä¸€ä¸ªæœ‰æ•ˆçš„æè¿°
                                const photoDesc = item.description || 'è§’è‰²å‘é€çš„ç…§ç‰‡';
                                processedMessages.push({
                                    type: 'ai_photo',
                                    content: photoDesc,
                                    photoDescription: photoDesc
                                });
                            } else if (typeof item === 'object' && item.type === 'location') {
                                // å¤„ç†è§’è‰²å‘é€çš„ä½ç½®
                                // ç¡®ä¿æˆ‘ä»¬æœ‰ä¸€ä¸ªæœ‰æ•ˆçš„ä½ç½®åç§°
                                const locationName = item.name || item.locationName || 'æœªçŸ¥ä½ç½®';
                                processedMessages.push({
                                    type: 'location',
                                    locationName: locationName,
                                    coordinates: item.coordinates || 'æœªçŸ¥åæ ‡',
                                    content: `[è§’è‰²åˆ†äº«äº†ä½ç½®ä¿¡æ¯ï¼š${locationName}]`
                                });
                            } else if (typeof item === 'object' && item.type === 'change_avatar') {
                                // å¤„ç†å¤´åƒæ›´æ¢å¯¹è±¡

                                
                                // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†å„ç§é”™è¯¯çš„å ä½ç¬¦
                                if (item.avatar_url === 'CURRENT_USER_IMAGE' || 
                                    item.avatar_url === 'CURRENT_USER_IMAGE' || 
                                    item.avatar_url === 'ç”¨æˆ·å‘é€çš„å›¾ç‰‡URL' ||
                                    item.avatar_url === 'å›¾ç‰‡URL') {
                                    // è·å–æœ€è¿‘ç”¨æˆ·å‘é€çš„å›¾ç‰‡URL
                                    const recentUserImage = getRecentUserImage();
                                    if (recentUserImage) {
                                        item.avatar_url = recentUserImage;
                                        console.log('å°†å ä½ç¬¦æ›¿æ¢ä¸ºå®é™…å›¾ç‰‡URL(ç¬¬äºŒå¤„):', recentUserImage);
                                    } else {
                                        console.warn('æ²¡æœ‰æ‰¾åˆ°ç”¨æˆ·æœ€è¿‘å‘é€çš„å›¾ç‰‡ï¼Œå¿½ç•¥å¤´åƒæ›´æ¢è¯·æ±‚(ç¬¬äºŒå¤„)');
                                        processedMessages.push(`[ç³»ç»Ÿï¼šæ— æ³•æ›´æ¢å¤´åƒï¼Œæ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„å›¾ç‰‡]`);
                                        // ä¸è¦returnï¼Œç»§ç»­å¤„ç†å…¶ä»–æ¶ˆæ¯
                                    }
                                }
                                
                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'ai_image') {
                                // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†AIå‘é€å›¾ç‰‡(ç¬¬äºŒå¤„)

                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'voice_message') {
                                // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†AIå‘é€è¯­éŸ³(ç¬¬äºŒå¤„)

                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'transfer') {
                                // ğŸ”¥ã€ä¿®å¤ã€‘å¤„ç†AIè½¬è´¦(ç¬¬äºŒå¤„) - ç¡®ä¿æ ¼å¼æ­£ç¡®

                                processedMessages.push({
                                    type: 'transfer',
                                    amount: item.amount || 0,
                                    note: item.note || 'è½¬è´¦'
                                });
                            } else if (typeof item === 'object' && item.type === 'update_poke_suffix') {
                                // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†æˆ³ä¸€æˆ³åç¼€æ›´æ–°(ç¬¬äºŒå¤„)

                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'recall') {
                                // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†AIä¸»åŠ¨æ’¤å›æ¶ˆæ¯(ç¬¬äºŒå¤„)
                                if (item.target === 'previous') {
                                    // æ’¤å›ä¸Šä¸€æ¡æ¶ˆæ¯
                                    processedMessages.push({
                                        type: 'recall_previous',
                                        content: '[AIæ’¤å›äº†ä¸Šä¸€æ¡æ¶ˆæ¯]'
                                    });
                                }
                            } else if (typeof item === 'object' && item.type === 'reply') {
                                // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†AIå¼•ç”¨å›å¤(ç¬¬äºŒå¤„)
                                processedMessages.push({
                                    type: 'reply_message',
                                    messageId: item.messageId,
                                    content: item.content || ''
                                });
                            } else if (typeof item === 'object' && item.type === 'photo') {
                                // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†AIå‘é€ç…§ç‰‡å¡ç‰‡(ç¬¬äºŒå¤„)
                                processedMessages.push({
                                    type: 'user_photo',
                                    content: item.description || 'AIåˆ†äº«çš„ç…§ç‰‡',
                                    photoDescription: item.description
                                });
                            } else if (typeof item === 'object' && item.type === 'recalled_message') {
                                // ğŸ”¥ã€ä¿ç•™ã€‘å¤„ç†ç³»ç»Ÿæ’¤å›æ¶ˆæ¯(ç¬¬äºŒå¤„)

                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'reply_to') {
                                // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†AIå¼•ç”¨å›å¤(ç¬¬äºŒå¤„)
                                processedMessages.push({
                                    type: 'reply_to',
                                    message_id: item.message_id,
                                    content: item.content || ''
                                });
                            } else if (typeof item === 'object' && item.type === 'friend_request') {
                                // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†AIä¸»åŠ¨å‘é€å¥½å‹ç”³è¯·(ç¬¬äºŒå¤„)
                                processedMessages.push({
                                    type: 'friend_request',
                                    message: item.message || 'æƒ³å’Œä½ é‡æ–°åšæœ‹å‹'
                                });
                            } else if (typeof item === 'string') {
                                // ğŸš¨ ã€æ–°å¢ã€‘æ£€æŸ¥å¹¶ä¿®å¤åˆå¹¶æ¶ˆæ¯é—®é¢˜
                                if (item.includes('\n')) {
                                    console.warn('æ£€æµ‹åˆ°AIå°†å¤šæ¡æ¶ˆæ¯åˆå¹¶åœ¨ä¸€ä¸ªå…ƒç´ ä¸­ï¼Œæ­£åœ¨è‡ªåŠ¨åˆ†æ‹†:', item);
                                    // å°†æ¢è¡Œç¬¦åˆ†éš”çš„å†…å®¹åˆ†æ‹†æˆå¤šæ¡æ¶ˆæ¯
                                    const splitMessages = item.split('\n')
                                        .map(msg => msg.trim())
                                        .filter(msg => msg.length > 0);
                                    processedMessages.push(...splitMessages);
                                } else {
                                    processedMessages.push(item);
                                }
                            } else {
                                processedMessages.push(item);
                            }
                        });
                        
                        return processedMessages;
                    }
                } 
            } catch (e) {} 
            
            // ğŸ”¥ã€ä¿®å¤ã€‘æ£€æŸ¥æ˜¯å¦æ˜¯åŸå§‹çš„JSONå­—ç¬¦ä¸²ï¼ˆAIå›å¤æ²¡æœ‰è¢«æ­£ç¡®åŒ…è£…ï¼‰
            if (content.trim().startsWith('{') && content.trim().endsWith('}')) {
                try {
                    const singleObject = JSON.parse(content.trim());
                    if (singleObject.type) {
                        console.log('æ£€æµ‹åˆ°å•ä¸ªJSONå¯¹è±¡ï¼Œå°è¯•å¤„ç†:', singleObject);
                        // å°†å•ä¸ªå¯¹è±¡åŒ…è£…æˆæ•°ç»„å†é€’å½’å¤„ç†
                        return parseAiResponse(`[${content.trim()}]`);
                    }
                } catch (e) {
                    console.warn('æ— æ³•è§£æå•ä¸ªJSONå¯¹è±¡:', e);
                }
            }
            
            const lines = content.split('\n').map(l => l.trim()).filter(l => l.length > 0 && !l.startsWith('```')); 
            if (lines.length > 0) return lines; 
            return [content]; 
        }
        
        // å¤„ç†çº¿ä¸‹æ¨¡å¼å†…å®¹ï¼šè¯†åˆ«ã€Œã€åŒ…è£¹çš„å¯¹è¯å’Œæå†™
        function processOfflineContent(content) {
            if (!content) return '';
            
            // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åˆ†ç¦»å¯¹è¯å’Œæå†™
            const parts = [];
            let lastIndex = 0;
            
            // åŒ¹é…ã€Œã€åŒ…è£¹çš„å¯¹è¯
            const dialogRegex = /ã€Œ([^ã€]*)ã€/g;
            let match;
            
            while ((match = dialogRegex.exec(content)) !== null) {
                // æ·»åŠ å¯¹è¯å‰çš„æå†™éƒ¨åˆ†
                if (match.index > lastIndex) {
                    const description = content.slice(lastIndex, match.index).trim();
                    if (description) {
                        parts.push(`<span class="italic-gray">${description}</span>`);
                    }
                }
                
                // æ·»åŠ å¯¹è¯éƒ¨åˆ†ï¼ˆæ­£å¸¸æ˜¾ç¤ºï¼‰
                parts.push(`ã€Œ${match[1]}ã€`);
                lastIndex = match.index + match[0].length;
            }
            
            // æ·»åŠ æœ€åçš„æå†™éƒ¨åˆ†
            if (lastIndex < content.length) {
                const description = content.slice(lastIndex).trim();
                if (description) {
                    parts.push(`<span class="italic-gray">${description}</span>`);
                }
            }
            
            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å¯¹è¯æ ‡è®°ï¼Œæ•´ä¸ªå†…å®¹ä½œä¸ºæå†™å¤„ç†
            if (parts.length === 0) {
                return `<span class="italic-gray">${content}</span>`;
            }
            
            return parts.join('');
        }
        


        // ğŸ”¥ã€ä¿®å¤ã€‘å‘é€å›¾ç‰‡æ¶ˆæ¯ï¼Œä½¿ç”¨æ­£ç¡®çš„å¤šæ¨¡æ€æ•°æ®ç»“æ„
        async function sendImageMessage(imageUrl) {
            if (!currentChatCharacter) return;
            
            const chatInput = document.getElementById('api-chat-input');
            const textContent = chatInput ? chatInput.value.trim() : '';



            // åˆ›å»ºä¸€ä¸ªæ ‡å‡†çš„å¤šæ¨¡æ€æ¶ˆæ¯å¯¹è±¡
            const messageContent = [
                { type: 'text', text: textContent }
            ];

            if (imageUrl) {
                messageContent.push({
                    type: 'image_url',
                    image_url: { url: imageUrl }
                });
            }



            const message = {
                id: Date.now().toString(),
                sender: 'sent',
                content: messageContent, // ä½¿ç”¨æ–°çš„æ•°ç»„æ ¼å¼
                timestamp: Date.now(),
                // å¦‚æœæœ‰å¼•ç”¨æ¶ˆæ¯ï¼Œæ·»åŠ å¼•ç”¨ä¿¡æ¯
                replyTo: currentReplyTo ? {
                    id: currentReplyTo.id,
                    content: currentReplyTo.content,
                    senderName: currentReplyTo.senderName
                } : null
            };
            


            // æ·»åŠ åˆ°èŠå¤©è®°å½•
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            chatMessages[currentChatCharacter.id].push(message);
            await saveChatMessages();

            // ğŸ”¥ã€æ–°å¢ã€‘è®°å½•åˆ°å…¨å±€è®°å¿†äº‹ä»¶
            await recordMemoryEvent(
                [currentChatCharacter.id, 'user'],
                {
                    type: currentChatCharacter.isGroup ? 'group_chat' : 'private_chat',
                    id: currentChatCharacter.id
                },
                'message',
                {
                    sender: 'user',
                    content: textContent,
                    hasImage: !!imageUrl
                },
                0.6 // ç”¨æˆ·æ¶ˆæ¯é‡è¦æ€§
            );
            
            // æ¸…ç©ºè¾“å…¥æ¡†å¹¶åˆ·æ–°UI
            if (chatInput) {
                chatInput.value = '';
            }

            // ğŸ”¥ã€æ–°å¢ã€‘æ¸…é™¤å¼•ç”¨çŠ¶æ€
            cancelReply();
            if (currentChatCharacter) {
                delete chatReplyStates[currentChatCharacter.id];
            }
            addMessageWithAnimation(message, currentChatCharacter.id);
            renderMessageList();
            
            // ğŸ”¥ã€æ–°å¢ã€‘è§¦å‘è§’è‰²çŠ¶æ€æ›´æ–°
            triggerStatusUpdateAfterMessage(currentChatCharacter.id);
            
            // è®¾ç½®ä¸ºå¾…å›å¤æ¶ˆæ¯ï¼Œå¹¶æ›´æ–°æ™ºèƒ½å›å¤æŒ‰é’®çŠ¶æ€
            pendingUserMessage = message;
            
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = 'ç‚¹å‡»è·å–AIå›å¤';
            }
        }
        
        // è°ƒç”¨èŠå¤©API
        // ç¬¬ä¸€ä¸ªcallChatAPIå‡½æ•°å·²åˆ é™¤ï¼Œä½¿ç”¨ä¸‹é¢çš„å®Œæ•´ç‰ˆæœ¬
        
        // ä¸Šä¼ å›¾ç‰‡
        function uploadImage() {
            document.getElementById('image-upload').click();
        }
        
        // æ˜¾ç¤ºå›¾ç‰‡
        function showImage(imageUrl) {
            // ğŸ”¥ã€ä¿®å¤ã€‘ç§»é™¤å¯¹æœªå®šä¹‰çš„photoså˜é‡çš„å¼•ç”¨ï¼Œç›´æ¥æ˜¾ç¤ºå›¾ç‰‡é¢„è§ˆæ¨¡æ€æ¡†
            let modal = document.getElementById('image-preview-modal');
            if (!modal) {
                // åˆ›å»ºå›¾ç‰‡é¢„è§ˆæ¨¡æ€æ¡†
                modal = document.createElement('div');
                modal.id = 'image-preview-modal';
                modal.className = 'image-preview-modal';

                // ç‚¹å‡»æ¨¡æ€æ¡†èƒŒæ™¯å…³é—­
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        modal.style.display = 'none';
                    }
                };

                // åˆ›å»ºå›¾ç‰‡å…ƒç´ 
                const img = document.createElement('img');
                img.alt = 'é¢„è§ˆå›¾ç‰‡';
                img.style.cursor = 'zoom-out';

                // ç‚¹å‡»å›¾ç‰‡ä¹Ÿå¯ä»¥å…³é—­
                img.onclick = () => modal.style.display = 'none';

                modal.appendChild(img);
                document.body.appendChild(modal);
            }

            // è®¾ç½®å›¾ç‰‡æºå¹¶æ˜¾ç¤ºæ¨¡æ€æ¡†
            const img = modal.querySelector('img');
            img.src = imageUrl;
            modal.style.display = 'flex';

            // ğŸ”¥ã€æ–°å¢ã€‘æ·»åŠ é”®ç›˜ESCé”®å…³é—­åŠŸèƒ½
            const handleKeyPress = (e) => {
                if (e.key === 'Escape') {
                    modal.style.display = 'none';
                    document.removeEventListener('keydown', handleKeyPress);
                }
            };
            document.addEventListener('keydown', handleKeyPress);
        }
        
        // æ˜¾ç¤ºèŠå¤©è®¾ç½®
        function showChatSettings() {
            console.log('æ˜¾ç¤ºèŠå¤©è®¾ç½®è¢«è°ƒç”¨');
            
            // å…ˆéšè—å½“å‰çš„èŠå¤©ç•Œé¢
            hideApp('api-chat-screen');
            
            // æ˜¾ç¤ºè®¾ç½®ç•Œé¢
            const element = document.getElementById('api-chat-settings-screen');
            if (element) {
                element.style.display = 'flex';
                element.style.position = 'absolute';
                element.style.top = '0';
                element.style.left = '0';
                element.style.width = '100%';
                element.style.height = '100%';
                element.style.zIndex = '1000';
                element.style.background = 'white';
                
                // é‡æ–°åˆå§‹åŒ–èŠå¤©è®¾ç½®ç•Œé¢ä»¥åŠ è½½å½“å‰è®¾ç½®
                initializeChatSettings();

                // ğŸ”¥ã€ä¿®å¤ã€‘ç¡®ä¿æ°”æ³¡æ ·å¼åœ¨è®¾ç½®ç•Œé¢æ˜¾ç¤ºæ—¶è¢«æ­£ç¡®åº”ç”¨
                applyBubbleStyle();

                // æ›´æ–°å„ç§è®¾ç½®çš„æ˜¾ç¤ºçŠ¶æ€
                updateWorldbookMountDisplay();
                
                // æ£€æµ‹å½“å‰èŠå¤©ç±»å‹å¹¶æ˜¾ç¤ºç›¸åº”è®¾ç½®
                const isGroupChat = currentChatCharacter && currentChatCharacter.isGroup;
                console.log('å½“å‰èŠå¤©ç±»å‹:', isGroupChat ? 'ç¾¤èŠ' : 'å•èŠ');
                
                // æ ¹æ®èŠå¤©ç±»å‹æ˜¾ç¤ºä¸åŒçš„è®¾ç½®é€‰é¡¹
                const groupChatSettings = document.getElementById('group-chat-settings');
                const pokeSettingsSection = document.getElementById('poke-settings-section');
                
                if (isGroupChat) {
                    // ç¾¤èŠæ¨¡å¼ï¼šæ˜¾ç¤ºç¾¤èŠè®¾ç½®ï¼Œéšè—æˆ³ä¸€æˆ³å’Œå•èŠä¸“ç”¨åŠŸèƒ½
                    if (groupChatSettings) groupChatSettings.style.display = 'block';
                    if (pokeSettingsSection) pokeSettingsSection.style.display = 'none';
                    
                    // éšè—å•èŠä¸“ç”¨è®¾ç½®é¡¹
                    const singleChatItems = document.querySelectorAll('.single-chat-only');
                    singleChatItems.forEach(item => item.style.display = 'none');
                    
                    // æ›´æ–°ç¾¤èŠä¿¡æ¯æ˜¾ç¤º
                    updateGroupChatInfo();
                } else {
                    // å•èŠæ¨¡å¼ï¼šéšè—ç¾¤èŠè®¾ç½®ï¼Œæ˜¾ç¤ºæˆ³ä¸€æˆ³å’Œå•èŠä¸“ç”¨åŠŸèƒ½
                    if (groupChatSettings) groupChatSettings.style.display = 'none';
                    if (pokeSettingsSection) pokeSettingsSection.style.display = 'block';
                    
                    // æ˜¾ç¤ºå•èŠä¸“ç”¨è®¾ç½®é¡¹
                    const singleChatItems = document.querySelectorAll('.single-chat-only');
                    singleChatItems.forEach(item => item.style.display = 'flex');

                    // æ›´æ–°è®°å¿†å…±äº«çŠ¶æ€æ˜¾ç¤º
                    updateMemoryShareStatus();
                }

                console.log('èŠå¤©è®¾ç½®ç•Œé¢å·²æ˜¾ç¤º');
            } else {
                console.error('æ‰¾ä¸åˆ°api-chat-settings-screenå…ƒç´ ');
                alert('è®¾ç½®ç•Œé¢æœªæ‰¾åˆ°ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
            }
        }
        
        // éšè—èŠå¤©è®¾ç½®
        function hideChatSettings() {
            hideApp('api-chat-settings-screen');
            // è¿”å›åˆ°èŠå¤©ç•Œé¢
            if (currentChatCharacter) {
                showApp('api-chat-screen');
            }
        }
        
        // ä¿®æ”¹è§’è‰²å¤´åƒ
        function changeCharacterAvatar() {
            // ä¸´æ—¶åˆ›å»ºä¸€ä¸ªæ–‡ä»¶è¾“å…¥æ¡†ï¼Œé¿å…å¹²æ‰°åŸæœ‰çš„å¤´åƒä¸Šä¼ åŠŸèƒ½
            const tempInput = document.createElement('input');
            tempInput.type = 'file';
            tempInput.accept = 'image/*,.jpg,.jpeg,.png,.gif,.webp';
            tempInput.style.display = 'none';
            document.body.appendChild(tempInput);
            
            tempInput.onchange = function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = async function(event) {
                        const characterIndex = characters.findIndex(c => c.id === currentChatCharacter.id);
                        if (characterIndex !== -1) {
                            characters[characterIndex].avatarUrl = event.target.result;
                            await saveCharacters();
                            renderCharacterList();
                            renderContactList();
                            renderMessageList();
                            renderChatMessages(currentChatCharacter.id);
                        }
                        // æ¸…ç†ä¸´æ—¶å…ƒç´ 
                        document.body.removeChild(tempInput);
                    };
                    reader.readAsDataURL(e.target.files[0]);
                } else {
                    // å¦‚æœç”¨æˆ·å–æ¶ˆé€‰æ‹©ï¼Œä¹Ÿè¦æ¸…ç†ä¸´æ—¶å…ƒç´ 
                    document.body.removeChild(tempInput);
                }
            };
            
            tempInput.click();
        }
        
        // ä¿®æ”¹å¤‡æ³¨
        async function changeCharacterNickname() {
            const newName = prompt('è¯·è¾“å…¥æ–°çš„å¤‡æ³¨åç§°:', currentChatCharacter.name);
            if (newName && newName.trim() !== '') {
                const characterIndex = characters.findIndex(c => c.id === currentChatCharacter.id);
                if (characterIndex !== -1) {
                    characters[characterIndex].name = newName.trim();
                    await saveCharacters();
                    document.getElementById('api-chat-title').textContent = newName.trim();
                    renderCharacterList();
                    renderContactList();
                    renderMessageList();
                }
            }
        }
        
        // æŸ¥æ‰¾èŠå¤©å†…å®¹
        function searchChatContent() {
            const keyword = prompt('è¯·è¾“å…¥è¦æŸ¥æ‰¾çš„å…³é”®è¯:');
            if (keyword && keyword.trim() !== '') {
                const messages = chatMessages[currentChatCharacter.id] || [];
                const foundMessages = messages.filter(msg => 
                    msg.content && msg.content.includes(keyword.trim())
                );
                
                if (foundMessages.length > 0) {
                    alert(`æ‰¾åˆ° ${foundMessages.length} æ¡åŒ…å«"${keyword}"çš„æ¶ˆæ¯`);
                } else {
                    alert(`æ²¡æœ‰æ‰¾åˆ°åŒ…å«"${keyword}"çš„æ¶ˆæ¯`);
                }
            }
        }
        

        
        // ğŸ”¥ã€ä¿®å¤ã€‘å¯¼å‡ºèŠå¤©è®°å½• - å®Œæ•´HTMLæ ¼å¼
        function exportChatHistory() {
            if (!currentChatCharacter) {
                showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠå¤©', 'warning');
                return;
            }
            
            const messages = chatMessages[currentChatCharacter.id] || [];
            if (messages.length === 0) {
                showToast('æ²¡æœ‰èŠå¤©è®°å½•å¯å¯¼å‡º', 'warning');
                return;
            }
            
            const chatSettings = getCurrentChatSettings();
            const characterName = chatSettings.aiChatNickname || currentChatCharacter.name;
            const userName = chatSettings.myChatNickname || 'æˆ‘';
            const exportTime = new Date();
            const totalMessages = messages.length;
            
            // è·å–æ—¶é—´èŒƒå›´
            const firstMessageTime = new Date(messages[0].timestamp || Date.now());
            const lastMessageTime = new Date(messages[messages.length - 1].timestamp || Date.now());

            // ç¡®ä¿æ—¥æœŸæœ‰æ•ˆ
            if (isNaN(firstMessageTime.getTime())) {
                firstMessageTime = new Date();
            }
            if (isNaN(lastMessageTime.getTime())) {
                lastMessageTime = new Date();
            }
            
            // æ„å»ºHTMLå†…å®¹
            let htmlContent = `<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸ ${characterName} çš„èŠå¤©è®°å½•</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', Helvetica, Arial, sans-serif;
            background: #f0f0f0;
            color: #333;
            line-height: 1.6;
            min-height: 100vh;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            min-height: 100vh;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        .header {
            background: #007AFF;
            color: white;
            padding: 20px;
            text-align: center;
        }
        .header h1 {
            font-size: 24px;
            margin-bottom: 10px;
        }
        .header .info {
            font-size: 14px;
            opacity: 0.9;
        }
        .chat-content {
            padding: 20px;
        }
        .message {
            margin-bottom: 15px;
            display: flex;
            align-items: flex-end;
            gap: 10px;
        }
        .message.user {
            flex-direction: row-reverse;
        }
        .message.ai {
            flex-direction: row;
        }
        .message.system {
            justify-content: center;
            margin: 10px 0;
        }
        .message-bubble {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            word-wrap: break-word;
            position: relative;
        }
        .message.user .message-bubble {
            background: #007AFF;
            color: white;
            border-bottom-right-radius: 6px;
        }
        .message.ai .message-bubble {
            background: #e5e5ea;
            color: #333;
            border-bottom-left-radius: 6px;
        }
        .message.system .message-bubble {
            background: #f0f0f0;
            color: #666;
            font-size: 12px;
            text-align: center;
            border-radius: 12px;
            padding: 6px 12px;
            margin: 0 auto;
            max-width: 60%;
        }
        .sender-name {
            font-size: 12px;
            color: #666;
            margin-bottom: 4px;
            padding: 0 16px;
        }
        .message.user .sender-name {
            text-align: right;
        }
        .timestamp {
            font-size: 11px;
            color: #999;
            margin-top: 4px;
            padding: 0 16px;
        }
        .message.user .timestamp {
            text-align: right;
        }
        .quote-block {
            background: rgba(0,0,0,0.05);
            border-left: 3px solid #007AFF;
            padding: 8px 12px;
            margin-bottom: 8px;
            border-radius: 0 8px 8px 0;
            font-size: 13px;
        }
        .message.user .quote-block {
            border-left-color: rgba(255,255,255,0.5);
            background: rgba(255,255,255,0.2);
        }
        .quote-sender {
            font-weight: 600;
            color: #007AFF;
            font-size: 12px;
            margin-bottom: 2px;
        }
        .message.user .quote-sender {
            color: rgba(255,255,255,0.9);
        }
        .special-message {
            font-style: italic;
            color: #666;
        }
        .footer {
            background: #f8f8f8;
            padding: 20px;
            text-align: center;
            border-top: 1px solid #e0e0e0;
            font-size: 12px;
            color: #666;
        }
        .stats {
            background: #f8f8f8;
            padding: 15px 20px;
            border-top: 1px solid #e0e0e0;
            font-size: 14px;
            color: #666;
        }
        @media (max-width: 600px) {
            .container {
                margin: 0;
                box-shadow: none;
            }
            .message-bubble {
                max-width: 85%;
            }
            .header h1 {
                font-size: 20px;
            }
            .chat-content {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ä¸ ${characterName} çš„èŠå¤©è®°å½•</h1>
            <div class="info">
                å¯¼å‡ºæ—¶é—´ï¼š${exportTime.toLocaleString('zh-CN')}<br>
                å…± ${totalMessages} æ¡æ¶ˆæ¯ | ${firstMessageTime.toLocaleDateString('zh-CN')} - ${lastMessageTime.toLocaleDateString('zh-CN')}
            </div>
        </div>
        <div class="chat-content">`;
            
            // å¤„ç†æ¯æ¡æ¶ˆæ¯
            messages.forEach((message, index) => {
                const time = formatTime(message.timestamp);
                const isUser = message.sender === 'sent';
                const isSystem = message.sender === 'system';
                
                if (isSystem) {
                    // ç³»ç»Ÿæ¶ˆæ¯
                    htmlContent += `
            <div class="message system">
                <div class="message-bubble">${escapeHtml(message.content)}</div>
            </div>`;
                } else {
                    // ç”¨æˆ·æˆ–AIæ¶ˆæ¯
                    const messageClass = isUser ? 'user' : 'ai';
                    const senderName = isUser ? userName : characterName;
                    let messageContent = '';
                    
                    // å¤„ç†å¼•ç”¨æ¶ˆæ¯
                    if (message.replyTo) {
                        const quoteSender = message.replyTo.senderName || (message.replyTo.sender === 'sent' ? userName : characterName);
                        const quoteContent = truncateText(message.replyTo.content || '[æ¶ˆæ¯å·²åˆ é™¤]', 20);
                        messageContent += `
                <div class="quote-block">
                    <div class="quote-sender">${escapeHtml(quoteSender)}</div>
                    <div>${escapeHtml(quoteContent)}</div>
                </div>`;
                    }
                    
                    // å¤„ç†æ¶ˆæ¯å†…å®¹
                    let content = message.content || '';
                    let specialClass = '';
                    
                    if (message.type === 'voice_message') {
                        content = `ğŸµ è¯­éŸ³æ¶ˆæ¯ï¼š${content}`;
                        specialClass = ' special-message';
                    } else if (message.type === 'transfer') {
                        content = `ğŸ’° è½¬è´¦ï¼š${message.amount}å…ƒ${message.note ? ` (${message.note})` : ''}`;
                        specialClass = ' special-message';
                    } else if (message.type === 'location') {
                        content = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 4px; vertical-align: middle;"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/></svg>ä½ç½®ï¼š${message.locationName || 'ä½ç½®ä¿¡æ¯'}`;
                        specialClass = ' special-message';
                    } else if (message.type === 'friend_request') {
                        content = `ğŸ‘‹ å¥½å‹ç”³è¯·ï¼š${message.message || 'æƒ³å’Œä½ é‡æ–°åšæœ‹å‹'}`;
                        specialClass = ' special-message';
                    } else if (message.type === 'user_photo') {
                        content = `ğŸ“· å›¾ç‰‡ï¼š${content}`;
                        specialClass = ' special-message';
                    } else if (message.isEmoji) {
                        content = `ğŸ˜Š è¡¨æƒ…åŒ…ï¼š${message.emojiDescription || content}`;
                        specialClass = ' special-message';
                    } else if (Array.isArray(content)) {
                        // å¤„ç†å›¾ç‰‡+æ–‡å­—æ¶ˆæ¯
                        const textPart = content.find(part => part.type === 'text')?.text || '';
                        content = textPart ? `ğŸ“·ğŸ“ å›¾ç‰‡+æ–‡å­—ï¼š${textPart}` : 'ğŸ“· å›¾ç‰‡æ¶ˆæ¯';
                        specialClass = ' special-message';
                    }
                    
                    messageContent += `<div class="${specialClass.trim()}">${escapeHtml(content)}</div>`;
                    
                    htmlContent += `
            <div class="message ${messageClass}">
                <div class="message-bubble">
                    ${messageContent}
                </div>
            </div>
            <div class="timestamp">${time}</div>`;
                }
                
                // æ¯50æ¡æ¶ˆæ¯æ·»åŠ ä¸€ä¸ªåˆ†é¡µæ ‡è®°ï¼ˆä¾¿äºé•¿èŠå¤©è®°å½•çš„æŸ¥çœ‹ï¼‰
                if ((index + 1) % 50 === 0 && index !== messages.length - 1) {
                    htmlContent += `
            <div class="message system">
                <div class="message-bubble">--- ç¬¬ ${Math.floor((index + 1) / 50)} é¡µ ---</div>
            </div>`;
                }
            });
            
            htmlContent += `
        </div>
        <div class="stats">
            ğŸ“Š èŠå¤©ç»Ÿè®¡<br>
            æ€»æ¶ˆæ¯æ•°ï¼š${totalMessages} æ¡ | 
            æˆ‘çš„æ¶ˆæ¯ï¼š${messages.filter(m => m.sender === 'sent').length} æ¡ | 
            ${characterName} çš„æ¶ˆæ¯ï¼š${messages.filter(m => m.sender === 'received').length} æ¡ | 
            ç³»ç»Ÿæ¶ˆæ¯ï¼š${messages.filter(m => m.sender === 'system').length} æ¡
        </div>
        <div class="footer">
            æ­¤èŠå¤©è®°å½•ç”±æ‰‹æœºèŠå¤©åº”ç”¨è‡ªåŠ¨ç”Ÿæˆ<br>
            å¯¼å‡ºæ—¶é—´ï¼š${exportTime.toLocaleString('zh-CN')}
        </div>
    </div>
</body>
</html>`;
            
            // åˆ›å»ºä¸‹è½½é“¾æ¥
            const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            const fileName = `ä¸${characterName}çš„èŠå¤©è®°å½•_${exportTime.getFullYear()}-${(exportTime.getMonth() + 1).toString().padStart(2, '0')}-${exportTime.getDate().toString().padStart(2, '0')}.html`;
            
            link.href = url;
            link.download = fileName;
            link.style.display = 'none';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // æ¸…ç†URLå¯¹è±¡
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 1000);
            
            showToast(`èŠå¤©è®°å½•å·²å¯¼å‡ºï¼š${fileName}`, 'success');
        }
        
        // ğŸ”¥ã€æ–°å¢ã€‘HTMLè½¬ä¹‰å‡½æ•°
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // ğŸ”¥ã€æ–°å¢ã€‘æ–‡æœ¬æˆªæ–­å‡½æ•°
        function truncateText(text, maxLength) {
            if (text.length <= maxLength) return text;
            return text.substring(0, maxLength) + '...';
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ ¹æ®æ¶ˆæ¯IDæŸ¥æ‰¾æ¶ˆæ¯
        function findMessageById(messageId) {
            if (!currentChatCharacter || !chatMessages[currentChatCharacter.id]) {
                return null;
            }

            const messages = chatMessages[currentChatCharacter.id];
            const result = messages.find(msg => msg.id === messageId);
            return result;
        }

        // ğŸ”¥ã€æ–°å¢ã€‘è·å–å½“å‰ç”¨æˆ·èº«ä»½åç§°
        function getCurrentPersonaName() {
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.selectedIdentityId) {
                const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                if (selectedPersona) {
                    // ä¼˜å…ˆä½¿ç”¨ç¾¤èŠæ˜µç§°
                    return chatSettings.myChatNickname || selectedPersona.name;
                }
            }
            return 'ç”¨æˆ·';
        }

        // ğŸ”¥ã€æ–°å¢ã€‘è·å–å½“å‰ç”¨æˆ·èº«ä»½æè¿°
        function getCurrentPersonaDescription() {
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.selectedIdentityId) {
                const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                if (selectedPersona && selectedPersona.description) {
                    return selectedPersona.description;
                }
            }
            return 'æˆ‘æ˜¯ç”¨æˆ·';
        }
        

        
        // è®¾ç½®å¯¹æ–¹æ°”æ³¡é¢œè‰²
        function changeTheirBubbleColor() {
            colorPickerContext = 'theirBubble';
            document.getElementById('color-picker-title').textContent = 'è®¾ç½®å¯¹æ–¹æ°”æ³¡é¢œè‰²';
            showModal('color-picker-modal');
        }
        
        // è®¾ç½®æˆ‘æ–¹æ°”æ³¡é¢œè‰²
        function changeMyBubbleColor() {
            colorPickerContext = 'myBubble';
            document.getElementById('color-picker-title').textContent = 'è®¾ç½®æˆ‘æ–¹æ°”æ³¡é¢œè‰²';
            showModal('color-picker-modal');
        }
        
        // æ˜¾ç¤ºæ°”æ³¡é¢œè‰²è®¾ç½®
        function showBubbleColorSettings() {
            alert('æ°”æ³¡é¢œè‰²è®¾ç½®åŠŸèƒ½å¼€å‘ä¸­...\n\nå½“å‰å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼è®¾ç½®ï¼š\nâ€¢ ä¿®æ”¹å¯¹æ–¹æ°”æ³¡é¢œè‰²\nâ€¢ ä¿®æ”¹æˆ‘æ–¹æ°”æ³¡é¢œè‰²');
        }
        
        // ğŸ”¥ã€æ–°å¢ã€‘æ˜¾ç¤ºå¸¦é€‰é¡¹çš„æ¸…ç©ºå†å²è®°å½•æ¨¡æ€æ¡†
        function showClearHistoryOptionsModal() {
            if (!currentChatCharacter) return;

            // åˆ›å»ºæ¨¡æ€æ¡†çš„HTMLç»“æ„
            const modalHTML = `
                <div id="clear-history-options-modal" class="modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 class="modal-title">æ¸…ç©ºèŠå¤©è®°å½•</h3>
                            <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p style="margin-bottom: 15px; font-size: 14px; color: #666;">
                                ä½ ç¡®å®šè¦æ¸…ç©ºä¸ <strong>${currentChatCharacter.name}</strong> çš„èŠå¤©è®°å½•å—ï¼Ÿ
                            </p>
                            <div class="setting-section">
                                <div class="section-header" style="padding: 0 0 10px 0;">
                                    <i class="fas fa-brain section-icon"></i>
                                    <span class="section-title">åŒæ­¥æ¸…é™¤ç›¸å…³è®°å¿†</span>
                                </div>
                                <div class="checkbox-group">
                                    <label class="checkbox-option">
                                        <input type="checkbox" id="clear-core-memory" value="core" checked>
                                        <span class="checkbox-custom"></span>
                                        <div class="checkbox-content">
                                            <div class="checkbox-title">æ ¸å¿ƒè®°å¿†</div>
                                            <div class="checkbox-desc">è§’è‰²è®°ä½çš„å…³é”®ä¿¡æ¯ï¼ˆå¦‚ç”Ÿæ—¥ã€å…³ç³»ï¼‰ã€‚</div>
                                        </div>
                                    </label>
                                    <label class="checkbox-option">
                                        <input type="checkbox" id="clear-episodic-memory" value="episodic" checked>
                                        <span class="checkbox-custom"></span>
                                        <div class="checkbox-content">
                                            <div class="checkbox-title">æƒ…æ™¯è®°å¿†</div>
                                            <div class="checkbox-desc">æ—¥å¸¸äº’åŠ¨å’Œç»å†çš„è®°å¿†ã€‚</div>
                                        </div>
                                    </label>
                                    <label class="checkbox-option">
                                        <input type="checkbox" id="clear-timeline" value="timeline" checked>
                                        <span class="checkbox-custom"></span>
                                        <div class="checkbox-content">
                                            <div class="checkbox-title">æ—¶é—´çº¿</div>
                                            <div class="checkbox-desc">æ‰€æœ‰æ´»åŠ¨çš„è¯¦ç»†æ—¶é—´è®°å½•ã€‚</div>
                                        </div>
                                    </label>
                                </div>
                            </div>
                            <p style="margin-top: 15px; font-size: 12px; color: #999;">
                                <strong>æç¤ºï¼š</strong>èŠå¤©è®¾ç½®ï¼ˆå¦‚èº«ä»½ã€èƒŒæ™¯ï¼‰å°†ä¼šè¢«ä¿ç•™ã€‚
                            </p>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="this.closest('.modal').remove()">å–æ¶ˆ</button>
                            <button class="modal-button modal-primary" style="background-color: #ff3b30;" onclick="executeClearHistory()">ç¡®è®¤æ¸…ç©º</button>
                        </div>
                    </div>
                </div>
            `;

            // æ·»åŠ åˆ°é¡µé¢
            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ ¹æ®ç”¨æˆ·çš„é€‰æ‹©æ‰§è¡Œæ¸…é™¤æ“ä½œ
        async function executeClearHistory() {
            const characterId = currentChatCharacter.id;
            console.log(`ğŸ§¹ å¼€å§‹æ¸…ç†è§’è‰² ${characterId} çš„èŠå¤©æ•°æ®...`);
            showToast('æ­£åœ¨è¿›è¡Œæ·±åº¦æ¸…ç†...', 'info');

            // è·å–ç”¨æˆ·é€‰æ‹©
            const clearCore = document.getElementById('clear-core-memory')?.checked || false;
            const clearEpisodic = document.getElementById('clear-episodic-memory')?.checked || false;
            const clearTimeline = document.getElementById('clear-timeline')?.checked || false;

            // ç§»é™¤æ¨¡æ€æ¡†
            const modal = document.getElementById('clear-history-options-modal');
            if (modal) modal.remove();

            try {
                // 1. æ¸…ç©ºèŠå¤©æ¶ˆæ¯ (æ€»æ˜¯æ‰§è¡Œ)
                chatMessages[characterId] = [];
                await saveChatMessages();
                console.log('âœ… èŠå¤©æ¶ˆæ¯å·²æ¸…ç©º');

                // 2. æ ¹æ®ç”¨æˆ·çš„å‹¾é€‰ï¼Œé€‰æ‹©æ€§åœ°æ¸…é™¤è®°å¿†
                const contextId = characterId;

                if (clearCore) {
                    const coreMemoriesToDelete = await db.coreMemories.where({ characterId: characterId, contextId: contextId }).primaryKeys();
                    if (coreMemoriesToDelete.length > 0) {
                        await db.coreMemories.bulkDelete(coreMemoriesToDelete);
                        console.log(`âœ… æ¸…é™¤äº† ${coreMemoriesToDelete.length} æ¡æ ¸å¿ƒè®°å¿†`);
                    }
                }

                if (clearEpisodic) {
                    const episodicMemoriesToDelete = await db.episodicMemories.where({ characterId: characterId, contextId: contextId }).primaryKeys();
                    if (episodicMemoriesToDelete.length > 0) {
                        await db.episodicMemories.bulkDelete(episodicMemoriesToDelete);
                        console.log(`âœ… æ¸…é™¤äº† ${episodicMemoriesToDelete.length} æ¡æƒ…æ™¯è®°å¿†`);
                    }
                }

                if (clearTimeline) {
                    const timelineEventsToDelete = await db.crossAppTimeline.where({ characterId: characterId }).and(event => event.context && event.context.id === contextId).primaryKeys();
                    if (timelineEventsToDelete.length > 0) {
                        await db.crossAppTimeline.bulkDelete(timelineEventsToDelete);
                        console.log(`âœ… æ¸…é™¤äº† ${timelineEventsToDelete.length} æ¡æ—¶é—´çº¿è®°å½•`);
                    }

                    const memorySummariesToDelete = await db.memorySummaries.where({ characterId: characterId }).and(summary => summary.context && summary.context.id === contextId).primaryKeys();
                    if (memorySummariesToDelete.length > 0) {
                        await db.memorySummaries.bulkDelete(memorySummariesToDelete);
                        console.log(`âœ… æ¸…é™¤äº† ${memorySummariesToDelete.length} æ¡è®°å¿†æ‘˜è¦`);
                    }
                }

                // 3. åˆ·æ–°ç•Œé¢
                renderChatMessages(characterId);
                renderMessageList();

                showToast('æ‰€é€‰æ•°æ®å·²å½»åº•æ¸…é™¤ï¼', 'success');
                console.log(`ğŸ§¹ è§’è‰² ${characterId} çš„æ•°æ®æ¸…ç†å®Œæˆ`);

                hideChatSettings();

            } catch (error) {
                console.error('æ·±åº¦æ¸…ç†å¤±è´¥:', error);
                showToast('æ¸…ç†å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°', 'error');
            }
        }

        // æ¸…ç©ºèŠå¤©è®°å½•
        function clearChatHistory() {
            // ğŸ”¥ã€æœ€ç»ˆä¿®å¤ã€‘ä¸å†ç›´æ¥æ‰§è¡Œåˆ é™¤ï¼Œè€Œæ˜¯è°ƒç”¨æ–°çš„å‡½æ•°æ¥æ˜¾ç¤ºå¸¦é€‰é¡¹çš„æ¨¡æ€æ¡†
            showClearHistoryOptionsModal();
        }
        
        // é€‰æ‹©é¢œè‰²
        function selectColor(color) {
            document.querySelectorAll('.color-option').forEach(option => {
                option.classList.remove('selected');
            });
            event.target.classList.add('selected');
            document.getElementById('selected-color').value = color;
        }
        
        // åº”ç”¨èŠå¤©èƒŒæ™¯
// æ¥å—ä¸€ä¸ªå¯é€‰çš„ backgroundUrl å‚æ•°
async function applyChatBackground(backgroundUrl) {
            if (!currentChatCharacter) return;
            
    console.log(`âš¡ applyChatBackground è¢«è°ƒç”¨: ${currentChatCharacter.name} (ID: ${currentChatCharacter.id})`);

    // 1. åˆ›å»ºä¸€ä¸ªä¸“å±äºå½“å‰èŠå¤©çš„èƒŒæ™¯è®¾ç½®å­—æ®µ
    // æ³¨æ„ï¼šè¿™é‡Œä¸å†ä½¿ç”¨chatSettingså¯¹è±¡ï¼Œè€Œæ˜¯ç›´æ¥åœ¨characterå¯¹è±¡ä¸Šæ·»åŠ èƒŒæ™¯å±æ€§
    if (!currentChatCharacter.background) {
        currentChatCharacter.background = null;
    }

    // 2. å†³å®šæœ€ç»ˆè¦ä½¿ç”¨çš„èƒŒæ™¯ã€‚ä¼˜å…ˆä½¿ç”¨ä¼ å…¥çš„å‚æ•°ï¼Œå¦åˆ™ä½¿ç”¨è§’è‰²å¯¹è±¡ä¸­çš„å€¼
    const backgroundToApply = backgroundUrl !== undefined ? backgroundUrl : currentChatCharacter.background;

    // 3. æ›´æ–°è§’è‰²å¯¹è±¡ä¸­çš„è®¾ç½®
    currentChatCharacter.background = backgroundToApply;
    
    // 4. ä¿å­˜åˆ°æ•°æ®åº“ - æ³¨æ„è¿™é‡Œä½¿ç”¨saveCharactersè€Œä¸æ˜¯saveCurrentChatSettings
    await saveCharacters();
    
    // 5. ç›´æ¥è®¾ç½®èƒŒæ™¯æ ·å¼
            const chatScreen = document.getElementById('api-chat-screen');
    if (!chatScreen) return;
    
    // ç›´æ¥åº”ç”¨èƒŒæ™¯ - å®Œå…¨æ¨¡ä»¿zhangyu.htmlä¸­çš„å®ç°æ–¹å¼
    if (backgroundToApply) {
        console.log(`ğŸ–¼ï¸ åº”ç”¨èŠå¤©èƒŒæ™¯: ${currentChatCharacter.name} (ID: ${currentChatCharacter.id})`);
        
        // ç›´æ¥è®¾ç½®æ ·å¼
        chatScreen.style.backgroundImage = `url(${backgroundToApply})`;
                    chatScreen.style.backgroundSize = 'cover';
                    chatScreen.style.backgroundPosition = 'center';
                    chatScreen.style.backgroundColor = 'transparent';
                    
        const messagesContainer = document.getElementById('api-chat-messages');
                    if (messagesContainer) messagesContainer.style.background = 'transparent';
                } else {
        console.log(`ğŸ–¼ï¸ é‡ç½®èŠå¤©èƒŒæ™¯: ${currentChatCharacter.name} (ID: ${currentChatCharacter.id})`);
        
        // é‡ç½®ä¸ºé»˜è®¤æ ·å¼
                    chatScreen.style.backgroundImage = 'none';
                    chatScreen.style.backgroundColor = 'white';
                    
        const messagesContainer = document.getElementById('api-chat-messages');
                    if (messagesContainer) messagesContainer.style.background = ''; 
                }
    
    console.log(`âœ… èƒŒæ™¯æ ·å¼å·²åº”ç”¨: ${currentChatCharacter.name} (ID: ${currentChatCharacter.id})`);
        }
        
        // ä¿å­˜æ°”æ³¡æ ·å¼è®¾ç½®
        function saveBubbleStyleSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // ä¿å­˜æ ·å¼è®¾ç½®
            chatSettings.bubbleStyle = window.selectedBubbleStyle || 'default';
            chatSettings.myBubbleColor = document.getElementById('my-bubble-color').value;
            chatSettings.aiBubbleColor = document.getElementById('ai-bubble-color').value;
            chatSettings.bubbleOpacity = document.getElementById('bubble-opacity').value;
            
            // æ›´æ–°æ˜¾ç¤ºæ–‡æœ¬
            const styleNames = {
                'default': 'é»˜è®¤æ ·å¼',
                'glass': 'æ¯›ç»ç’ƒ',
                'shadow': 'ç»å…¸é˜´å½±',
                'tail': 'ç»å…¸æ°”æ³¡',
                'gradient': 'æ¸å˜æ ·å¼',
                'minimal': 'æç®€æ ·å¼',
                'neon': 'éœ“è™¹æ ·å¼',
                'paper': 'çº¸å¼ æ ·å¼'
            };
            
            document.getElementById('current-bubble-style').textContent = styleNames[chatSettings.bubbleStyle] || 'é»˜è®¤æ ·å¼';
            
            saveCurrentChatSettings(chatSettings);
            applyBubbleStyle();
            hideModal('bubble-style-modal');
            
            showToast('æ°”æ³¡æ ·å¼è®¾ç½®å·²ä¿å­˜', 'success');
        }
        
        // åº”ç”¨æ°”æ³¡æ ·å¼
        function applyBubbleStyle() {
            // ğŸ”¥ã€ä¿®å¤ã€‘å³ä½¿æ²¡æœ‰currentChatCharacterä¹Ÿè¦å°è¯•åº”ç”¨æ ·å¼
            const messagesContainer = document.getElementById('api-chat-messages');
            if (!messagesContainer) return;

            // è·å–èŠå¤©è®¾ç½®ï¼Œå¦‚æœæ²¡æœ‰currentChatCharacteråˆ™ä½¿ç”¨é»˜è®¤è®¾ç½®
            let chatSettings = {};
            if (currentChatCharacter) {
                chatSettings = getCurrentChatSettings();
            } else {
                // ä½¿ç”¨é»˜è®¤è®¾ç½®
                chatSettings = {
                    bubbleStyle: 'default',
                    myBubbleColor: '#007AFF',
                    aiBubbleColor: '#f0f0f0',
                    bubbleOpacity: '1'
                };
            }

            // ç§»é™¤æ‰€æœ‰æ ·å¼ç±»
            messagesContainer.className = messagesContainer.className
                .split(' ')
                .filter(cls => !cls.startsWith('bubble-style-'))
                .join(' ');

            // æ·»åŠ å½“å‰æ ·å¼ç±»
            const style = chatSettings.bubbleStyle || 'default';
            messagesContainer.classList.add(`bubble-style-${style}`);

            // è®¾ç½®CSSå˜é‡ç”¨äºåŠ¨æ€é¢œè‰²
            const myColor = chatSettings.myBubbleColor || '#007AFF';
            const aiColor = chatSettings.aiBubbleColor || '#f0f0f0';
            const opacity = chatSettings.bubbleOpacity || '1';

            messagesContainer.style.setProperty('--my-bubble-color', myColor);
            messagesContainer.style.setProperty('--ai-bubble-color', aiColor);
            messagesContainer.style.setProperty('--bubble-opacity', opacity);

            console.log(`ğŸ¨ æ°”æ³¡æ ·å¼å·²åº”ç”¨: ${style} (è§’è‰²: ${currentChatCharacter?.name || 'æ— '})`);
        }
        
        // æ˜¾ç¤ºæ°”æ³¡é¢œè‰²é€‰æ‹©å™¨
        function showBubbleColorPicker(context) {
            colorPickerContext = context;
            document.getElementById('color-picker-title').textContent = 'è®¾ç½®æ°”æ³¡é¢œè‰²';
            showModal('color-picker-modal');
        }
        
        // é€‰æ‹©é¢œè‰²
        function selectColor(color) {
            document.querySelectorAll('.color-option').forEach(option => {
                option.classList.remove('selected');
            });
            event.target.classList.add('selected');
            document.getElementById('selected-color').value = color;
        }
        
        // åº”ç”¨é¢œè‰²é€‰æ‹©
        async function applyColorSelection() {
            const selectedColor = document.querySelector('.color-option.selected')?.style.backgroundColor || '#007AFF';
            const opacity = document.getElementById('opacity-slider').value;
            
            if (colorPickerContext === 'theirBubble') {
                chatSettings.theirBubbleColor = selectedColor;
                chatSettings.bubbleOpacity = opacity;
            } else if (colorPickerContext === 'myBubble') {
                chatSettings.myBubbleColor = selectedColor;
                chatSettings.bubbleOpacity = opacity;
            }
            
            await saveChatSettings();
            renderChatMessages(currentChatCharacter.id);
            hideModal('color-picker-modal');
        }
        
        // æ˜¾ç¤ºå£çº¸é€‰æ‹©å™¨
        function showWallpaperPicker() {
            showModal('wallpaper-picker-modal');
        }
        
        // é€‰æ‹©å£çº¸ï¼ˆä¿ç•™å‡½æ•°ä»¥é˜²å…¶ä»–åœ°æ–¹è°ƒç”¨ï¼Œä½†ç°åœ¨ä¸»è¦é€šè¿‡æ–‡ä»¶ä¸Šä¼ é€‰æ‹©ï¼‰
        function selectWallpaper(wallpaperId) {
            console.log('é€‰æ‹©å£çº¸:', wallpaperId);
            selectedWallpaper = wallpaperId;
            console.log('selectedWallpaperå·²è®¾ç½®ä¸º:', selectedWallpaper);
        }
        
        // åº”ç”¨å£çº¸é€‰æ‹©
        async function applyWallpaperSelection() {
            console.log('åº”ç”¨å£çº¸è¢«è°ƒç”¨ï¼ŒselectedWallpaper:', selectedWallpaper);
            
            if (!selectedWallpaper) {
                alert('è¯·å…ˆä»ç›¸å†Œé€‰æ‹©ä¸€å¼ å›¾ç‰‡ä½œä¸ºå£çº¸');
                return;
            }
            
            if (selectedWallpaper.startsWith('data:image')) {
                // åº”ç”¨ä¸Šä¼ çš„å›¾ç‰‡å£çº¸
                console.log('åº”ç”¨å›¾ç‰‡å£çº¸');
                document.querySelector('.wallpaper').style.backgroundImage = `url(${selectedWallpaper})`;
                    document.querySelector('.wallpaper').style.backgroundSize = '100% 100%';
                    document.querySelector('.wallpaper').style.backgroundPosition = 'center';
                
                // ä½¿ç”¨IndexedDBä¿å­˜å£çº¸ï¼Œé¿å…localStorageç©ºé—´é™åˆ¶
                try {
                    await db.wallpapers.clear();
                    await db.wallpapers.add({
                        id: 'main',
                        type: 'image',
                        data: selectedWallpaper
                    });
                    console.log('å£çº¸ä¿å­˜æˆåŠŸåˆ°IndexedDB');
            hideModal('wallpaper-picker-modal');
                } catch (e) {
                    console.error('ä¿å­˜å£çº¸å¤±è´¥:', e);
                    alert('ä¿å­˜å£çº¸å¤±è´¥ï¼Œè¯·é‡è¯•');
                }
            } else {
                alert('è¯·å…ˆä»ç›¸å†Œé€‰æ‹©ä¸€å¼ å›¾ç‰‡ä½œä¸ºå£çº¸');
            }
        }
        
        // ä¸Šä¼ è‡ªå®šä¹‰å£çº¸
        function uploadCustomWallpaper() {
            document.getElementById('custom-wallpaper-upload').click();
        }
        
        // å…¨å±€å˜é‡
        let selectedAppForIcon = null;
        let uploadedIconImage = null;

        // æ˜¾ç¤ºå›¾æ ‡é€‰æ‹©å™¨
        function showIconPicker() {
            generateAppList();
            showModal('icon-picker-modal');
        }

        // ç”Ÿæˆåº”ç”¨åˆ—è¡¨
        function generateAppList() {
            const container = document.getElementById('app-list-container');
            container.innerHTML = '';

            // è·å–æ‰€æœ‰åº”ç”¨çš„ä¿¡æ¯
            const apps = [
                // ä¸»å±å¹•åº”ç”¨
                { id: 'chat-screen', name: 'Chat', selector: '.mini-app[onclick="showApp(\'chat-screen\')"] .mini-app-icon' },
                { id: 'worldbook-screen', name: 'ä¸–ç•Œä¹¦', selector: '.mini-app[onclick*="worldbook-screen"] .mini-app-icon' },
                { id: 'game-screen', name: 'æ¸¸æˆ', selector: '.mini-app[onclick="showApp(\'game-screen\')"] .mini-app-icon' },
                { id: 'forum-screen', name: 'è®ºå›', selector: '.mini-app[onclick="showApp(\'forum-screen\')"] .mini-app-icon' },
                // Dockæ åº”ç”¨
                { id: 'messages-screen', name: 'çŸ­ä¿¡', selector: '.dock-app[onclick="showApp(\'messages-screen\')"] .dock-app-icon' },
                { id: 'settings-screen', name: 'è®¾ç½®', selector: '.dock-app[onclick="showApp(\'settings-screen\')"] .dock-app-icon' },
                { id: 'memory-viewer-screen', name: 'è®°å¿†', selector: '.dock-app[onclick="showApp(\'memory-viewer-screen\')"] .dock-app-icon' }
            ];

            apps.forEach(app => {
                const appElement = document.querySelector(app.selector);
                if (appElement) {
                    const appItem = document.createElement('div');
                    appItem.className = 'app-item-selector';
                    appItem.onclick = () => selectAppForIcon(app.id, app.name, app.selector);

                    // è·å–å½“å‰å›¾æ ‡
                    const iconHtml = appElement.innerHTML;

                    appItem.innerHTML = `
                        <div class="app-item-icon">
                            ${iconHtml}
                        </div>
                        <div class="app-item-name">${app.name}</div>
                    `;

                    container.appendChild(appItem);
                }
            });
        }

        // é€‰æ‹©è¦ä¿®æ”¹å›¾æ ‡çš„åº”ç”¨
        function selectAppForIcon(appId, appName, selector) {
            selectedAppForIcon = { id: appId, name: appName, selector: selector };

            // æ›´æ–°é€‰ä¸­çŠ¶æ€
            document.querySelectorAll('.app-item-selector').forEach(item => {
                item.classList.remove('selected');
            });
            event.currentTarget.classList.add('selected');

            // æ˜¾ç¤ºä¸Šä¼ åŒºåŸŸ
            document.getElementById('icon-upload-section').style.display = 'block';

            // é‡ç½®ä¸Šä¼ çŠ¶æ€
            resetIconUpload();
        }

        // è§¦å‘å›¾æ ‡ä¸Šä¼ 
        function triggerIconUpload() {
            if (!selectedAppForIcon) {
                alert('è¯·å…ˆé€‰æ‹©è¦ä¿®æ”¹çš„åº”ç”¨');
                return;
            }
            document.getElementById('custom-icon-upload').click();
        }

        // é‡ç½®å›¾æ ‡ä¸Šä¼ 
        function resetIconUpload() {
            uploadedIconImage = null;
            document.getElementById('upload-placeholder').style.display = 'block';
            document.getElementById('icon-preview-img').style.display = 'none';
            document.querySelector('.upload-area').classList.remove('has-image');
            document.getElementById('apply-icon-btn').style.display = 'none';
        }

        // åº”ç”¨å›¾æ ‡æ›´æ”¹
        async function applyIconChange() {
            if (!selectedAppForIcon || !uploadedIconImage) {
                alert('è¯·é€‰æ‹©åº”ç”¨å’Œä¸Šä¼ å›¾æ ‡');
                return;
            }

            try {
                // æ›´æ–°åº”ç”¨å›¾æ ‡
                const appIconElement = document.querySelector(selectedAppForIcon.selector);
                if (appIconElement) {
                    appIconElement.innerHTML = `<img src="${uploadedIconImage}" alt="${selectedAppForIcon.name}" class="app-icon-img">`;
                }

                // ä¿å­˜åˆ°IndexedDB
                await saveCustomAppIcon(selectedAppForIcon.id, uploadedIconImage);

                showToast('åº”ç”¨å›¾æ ‡å·²æ›´æ–°ï¼', 'success');
                hideModal('icon-picker-modal');

                // é‡ç½®çŠ¶æ€
                selectedAppForIcon = null;
                uploadedIconImage = null;
            } catch (error) {
                console.error('æ›´æ–°åº”ç”¨å›¾æ ‡å¤±è´¥:', error);
                showToast('æ›´æ–°å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
            }
        }

        // ä¿å­˜è‡ªå®šä¹‰åº”ç”¨å›¾æ ‡åˆ°IndexedDB
        async function saveCustomAppIcon(appId, imageData) {
            try {
                await db.appIcons.put({
                    id: appId,
                    appId: appId,
                    imageData: imageData,
                    updatedAt: new Date()
                });
                console.log('åº”ç”¨å›¾æ ‡å·²ä¿å­˜:', appId);
            } catch (error) {
                console.error('ä¿å­˜åº”ç”¨å›¾æ ‡å¤±è´¥:', error);
                throw error;
            }
        }

        // åŠ è½½è‡ªå®šä¹‰åº”ç”¨å›¾æ ‡
        async function loadCustomAppIcons() {
            try {
                const customIcons = await db.appIcons.toArray();
                customIcons.forEach(iconData => {
                    if (iconData.imageData) {
                        // æŸ¥æ‰¾å¯¹åº”çš„åº”ç”¨å›¾æ ‡å…ƒç´ å¹¶æ›´æ–°
                        const apps = [
                            { id: 'chat-screen', selector: '.mini-app[onclick="showApp(\'chat-screen\')"] .mini-app-icon' },
                            { id: 'worldbook-screen', selector: '.mini-app[onclick*="worldbook-screen"] .mini-app-icon' },
                            { id: 'game-screen', selector: '.mini-app[onclick="showApp(\'game-screen\')"] .mini-app-icon' },
                            { id: 'forum-screen', selector: '.mini-app[onclick="showApp(\'forum-screen\')"] .mini-app-icon' },
                            { id: 'messages-screen', selector: '.dock-app[onclick="showApp(\'messages-screen\')"] .dock-app-icon' },
                            { id: 'settings-screen', selector: '.dock-app[onclick="showApp(\'settings-screen\')"] .dock-app-icon' },
                            { id: 'memory-viewer-screen', selector: '.dock-app[onclick="showApp(\'memory-viewer-screen\')"] .dock-app-icon' }
                        ];

                        const app = apps.find(a => a.id === iconData.appId);
                        if (app) {
                            const appIconElement = document.querySelector(app.selector);
                            if (appIconElement) {
                                appIconElement.innerHTML = `<img src="${iconData.imageData}" alt="${iconData.appId}" class="app-icon-img">`;
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('åŠ è½½è‡ªå®šä¹‰åº”ç”¨å›¾æ ‡å¤±è´¥:', error);
            }
        }

        // åˆå§‹åŒ–åº”ç”¨å›¾æ ‡ä¸Šä¼ åŠŸèƒ½
        function initializeIconUpload() {
            const iconInput = document.getElementById('custom-icon-upload');
            if (!iconInput) {
                console.error('æ‰¾ä¸åˆ°custom-icon-uploadå…ƒç´ ');
                return;
            }

            // ç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            iconInput.removeEventListener('change', handleIconUpload);

            // æ·»åŠ æ–°çš„äº‹ä»¶ç›‘å¬å™¨
            iconInput.addEventListener('change', handleIconUpload);
            console.log('åº”ç”¨å›¾æ ‡ä¸Šä¼ äº‹ä»¶ç›‘å¬å™¨å·²ç»‘å®š');
        }

        // å¤„ç†å›¾æ ‡ä¸Šä¼ 
        async function handleIconUpload(e) {
            if (e.target.files && e.target.files[0]) {
                const file = e.target.files[0];

                // æ£€æŸ¥æ–‡ä»¶ç±»å‹
                if (!file.type.startsWith('image/')) {
                    alert('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶');
                    return;
                }

                // æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼ˆé™åˆ¶ä¸º5MBï¼‰
                if (file.size > 5 * 1024 * 1024) {
                    alert('å›¾ç‰‡æ–‡ä»¶ä¸èƒ½è¶…è¿‡5MB');
                    return;
                }

                try {
                    // å‹ç¼©å›¾ç‰‡
                    const compressedImage = await compressImage(file, 200, 0.8);

                    // æ›´æ–°é¢„è§ˆ
                    const uploadArea = document.querySelector('.upload-area');
                    const placeholder = document.getElementById('upload-placeholder');
                    const previewImg = document.getElementById('icon-preview-img');

                    placeholder.style.display = 'none';
                    previewImg.src = compressedImage;
                    previewImg.style.display = 'block';
                    uploadArea.classList.add('has-image');

                    // ä¿å­˜å›¾ç‰‡æ•°æ®
                    uploadedIconImage = compressedImage;

                    // æ˜¾ç¤ºåº”ç”¨æŒ‰é’®
                    document.getElementById('apply-icon-btn').style.display = 'inline-block';

                    showToast('å›¾ç‰‡ä¸Šä¼ æˆåŠŸï¼', 'success');
                } catch (error) {
                    console.error('å¤„ç†å›¾ç‰‡å¤±è´¥:', error);
                    showToast('å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
                }
            }
        }
        
        // æ›´æ”¹èŠå¤©ä¸»é¢˜é¢œè‰²
        function changeChatThemeColor() {
            colorPickerContext = 'theme';
            document.getElementById('color-picker-title').textContent = 'è®¾ç½®èŠå¤©ä¸»é¢˜é¢œè‰²';
            showModal('color-picker-modal');
        }
        

        
        // æ˜¾ç¤ºæ¶ˆæ¯èœå•
        function showMessageMenu(messageId, event) {
            selectedMessageId = messageId;
            console.log('æ¡Œé¢ç«¯å³é”®èœå•ï¼Œè®¾ç½®selectedMessageId:', selectedMessageId);

            // å…ˆéšè—ç°æœ‰èœå•ï¼Œç¡®ä¿æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
            hideMessageMenu();

            // åˆ›å»ºæˆ–è·å–èœå•å…ƒç´ 
            let menu = document.getElementById('message-context-menu');
            if (!menu) {
                menu = document.createElement('div');
                menu.id = 'message-context-menu';
                menu.className = 'message-menu';
                document.body.appendChild(menu);
            }

            // ğŸ”¥ã€ä¿®å¤ã€‘æ¯æ¬¡éƒ½é‡æ–°è®¾ç½®èœå•å†…å®¹ï¼Œé¿å…äº‹ä»¶ç»‘å®šé—®é¢˜
            // æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦æ˜¯ç”¨æˆ·å‘é€çš„ï¼ˆåªæœ‰ç”¨æˆ·æ¶ˆæ¯å¯ä»¥ç¼–è¾‘å’Œæ’¤å›ï¼‰
            const messages = chatMessages[currentChatCharacter.id] || [];
            const message = messages.find(msg => msg.id === messageId);
            const isUserMessage = message && message.sender === 'sent';

            let menuItems = [
                '<div class="message-menu-item" data-action="reply">å¼•ç”¨</div>',
                '<div class="message-menu-item" data-action="copy">å¤åˆ¶</div>'
            ];

            // ğŸ”¥ã€æ–°å¢ã€‘åªæœ‰AIè§’è‰²æ¶ˆæ¯æ‰æ˜¾ç¤ºå¿ƒå£°é€‰é¡¹
            if (!isUserMessage) {
                menuItems.push('<div class="message-menu-item" data-action="inner-thoughts">å¿ƒå£°</div>');
            }

            // ğŸ”¥ã€ä¿®å¤ã€‘æ‰€æœ‰æ¶ˆæ¯éƒ½å¯ä»¥ç¼–è¾‘ï¼Œç”¨æˆ·æ¶ˆæ¯å¯ä»¥æ’¤å›
            menuItems.push('<div class="message-menu-item" data-action="edit">ç¼–è¾‘</div>');

            if (isUserMessage) {
                menuItems.push('<div class="message-menu-item" data-action="recall">æ’¤å›</div>');
            }

            menuItems.push('<div class="message-menu-item" data-action="select">å¤šé€‰</div>');

            menu.innerHTML = menuItems.join('');

            // ğŸ”¥ã€ä¿®å¤ã€‘ä½¿ç”¨äº‹ä»¶å§”æ‰˜ç»‘å®šç‚¹å‡»äº‹ä»¶ï¼Œé¿å…å†…è”onclické—®é¢˜
            menu.onclick = function(e) {
                const action = e.target.dataset.action;
                if (action) {
                    e.stopPropagation();
                    console.log('èœå•ç‚¹å‡»ï¼Œaction:', action, 'selectedMessageId:', selectedMessageId);

                    // ğŸ”¥ã€ä¸´æ—¶ä¿®å¤ã€‘ç›´æ¥ä½¿ç”¨ä¼ å…¥çš„messageIdè€Œä¸æ˜¯å…¨å±€å˜é‡
                    const targetId = messageId;
                    console.log('ä½¿ç”¨messageId:', targetId);

                    switch(action) {
                        case 'reply':
                            replyToMessage(targetId);
                            break;
                        case 'copy':
                            copyMessage(targetId);
                            break;
                        case 'edit':
                            showEditMessageModal(targetId);
                            break;
                        case 'recall':
                            deleteMessage(targetId);
                            break;
                        case 'inner-thoughts':
                            showInnerThoughtsModal(targetId);
                            break;
                        case 'select':
                            enterMessageSelectionMode(targetId);
                            break;
                    }
                    // ğŸ”¥ã€ä¿®å¤ã€‘æ‰‹åŠ¨éšè—èœå•ï¼Œä¸ä¼ é€’äº‹ä»¶å‚æ•°
                    hideMessageMenu(null);
                }
            };

            // å®šä½èœå•
            const x = event.clientX || event.pageX;
            const y = event.clientY || event.pageY;

            menu.style.display = 'block';
            menu.style.left = `${Math.min(x, window.innerWidth - 150)}px`;
            menu.style.top = `${Math.min(y, window.innerHeight - 100)}px`;

            // ğŸ”¥ã€ä¿®å¤ã€‘å»¶è¿Ÿæ·»åŠ å¤–éƒ¨ç‚¹å‡»ç›‘å¬å™¨ï¼Œé¿å…ç«‹å³è§¦å‘
            setTimeout(() => {
                // å…ˆç§»é™¤å¯èƒ½å­˜åœ¨çš„æ—§ç›‘å¬å™¨
                document.removeEventListener('click', hideMessageMenu);
                document.removeEventListener('touchstart', hideMessageMenu);
                // æ·»åŠ æ–°çš„ç›‘å¬å™¨
                document.addEventListener('click', hideMessageMenu);
                document.addEventListener('touchstart', hideMessageMenu);
            }, 100);
        }
        
        // éšè—æ¶ˆæ¯èœå•
        function hideMessageMenu(event) {
            // ğŸ”¥ã€ä¿®å¤ã€‘å¦‚æœç‚¹å‡»æ¥è‡ªèœå•å†…éƒ¨ï¼Œä¸éšè—èœå•
            if (event && event.target) {
                const menu = document.getElementById('message-context-menu');
                if (menu && menu.contains(event.target)) {
                    return;
                }
            }

            const menu = document.getElementById('message-context-menu');
            if (menu) {
                menu.style.display = 'none';
                // ğŸ”¥ã€ä¿®å¤ã€‘æ¸…ç†èœå•çš„ç‚¹å‡»äº‹ä»¶å¤„ç†å™¨
                menu.onclick = null;
            }
            // ğŸ”¥ã€ä¿®å¤ã€‘ç¡®ä¿ç§»é™¤å¤–éƒ¨ç‚¹å‡»ç›‘å¬å™¨
            document.removeEventListener('click', hideMessageMenu);
            document.removeEventListener('touchstart', hideMessageMenu);
            // ğŸ”¥ã€ä¿®å¤ã€‘é‡ç½®é€‰ä¸­çš„æ¶ˆæ¯ID
            selectedMessageId = null;
        }
        
        // å¼•ç”¨æ¶ˆæ¯åŠŸèƒ½
        let currentReplyTo = null;

        // ğŸ”¥ã€æ–°å¢ã€‘æ¯ä¸ªèŠå¤©çš„å¼•ç”¨çŠ¶æ€å­˜å‚¨
        let chatReplyStates = {};
        
        // ğŸ”¥ã€ä¿®å¤ã€‘å¼•ç”¨æ¶ˆæ¯ - æ”¯æŒä¼ å…¥æ¶ˆæ¯ID
        function replyToMessage(messageId = null) {
            const targetMessageId = messageId || selectedMessageId;
            console.log('å¼•ç”¨æ¶ˆæ¯:', targetMessageId, 'æ¥æº:', messageId ? 'ç§»åŠ¨ç«¯' : 'æ¡Œé¢ç«¯');
            if (!targetMessageId) {
                console.log('é”™è¯¯: æ²¡æœ‰é€‰ä¸­çš„æ¶ˆæ¯ID');
                return;
            }

            const messages = chatMessages[currentChatCharacter.id] || [];
            const message = messages.find(msg => msg.id === targetMessageId);

            if (message) {
                // è®¾ç½®å¼•ç”¨ä¿¡æ¯
                let messageContent = message.content || '[å›¾ç‰‡]';

                // ğŸ”¥ã€ä¿®å¤ã€‘å¤„ç†å¤šæ¨¡æ€æ¶ˆæ¯å†…å®¹
                if (Array.isArray(message.content)) {
                    const textPart = message.content.find(p => p.type === 'text');
                    messageContent = textPart?.text || '[å¤šåª’ä½“æ¶ˆæ¯]';
                } else if (typeof message.content === 'string') {
                    messageContent = message.content;
                } else {
                    messageContent = '[ç‰¹æ®Šæ¶ˆæ¯]';
                }

                currentReplyTo = {
                    id: message.id,
                    content: messageContent,
                    sender: message.sender,
                    timestamp: message.timestamp,
                    senderName: getSenderDisplayName(message)
                };

                // ğŸ”¥ã€æ–°å¢ã€‘ä¿å­˜å½“å‰èŠå¤©çš„å¼•ç”¨çŠ¶æ€
                if (currentChatCharacter) {
                    chatReplyStates[currentChatCharacter.id] = { ...currentReplyTo };
                }

                // æ˜¾ç¤ºå¼•ç”¨é¢„è§ˆ
                showReplyPreview();

                // èšç„¦åˆ°è¾“å…¥æ¡†
                const inputBox = document.getElementById('api-chat-input');
                if (inputBox) {
                    inputBox.focus();
                }
            }

            hideMessageMenu();
        }
        
        // è·å–å‘é€è€…æ˜¾ç¤ºåç§°
        function getSenderDisplayName(message) {
            if (message.sender === 'sent') {
                const chatSettings = getCurrentChatSettings();
                if (chatSettings.selectedIdentityId) {
                    const persona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                    if (persona) return persona.name;
                }
                return chatSettings.myChatNickname || 'æˆ‘';
            } else if (message.sender === 'received') {
                // æ£€æŸ¥æ˜¯å¦æ˜¯ç¾¤èŠ
                const group = groupChats.find(g => g.id === currentChatCharacter.id);
                if (group) {
                    // ç¾¤èŠä¸­ï¼Œæ ¹æ®æ¶ˆæ¯çš„senderIdæˆ–nameæŸ¥æ‰¾æˆå‘˜
                    let member = null;
                    if (message.senderId) {
                        member = group.members.find(m => m.id === message.senderId);
                    } else if (message.name) {
                        member = group.members.find(m => m.name === message.name);
                    }
                    return member?.name || 'ç¾¤æˆå‘˜';
                } else {
                    // å•èŠ
                    const chatSettings = getCurrentChatSettings();
                    return chatSettings.aiChatNickname || currentChatCharacter.name;
                }
            }
            return 'æœªçŸ¥';
        }
        
        // æ˜¾ç¤ºå¼•ç”¨é¢„è§ˆ
        function showReplyPreview() {
            if (!currentReplyTo) return;

            // ç§»é™¤å·²å­˜åœ¨çš„å¼•ç”¨é¢„è§ˆ
            const existingPreview = document.getElementById('reply-preview');
            if (existingPreview) {
                existingPreview.remove();
            }

            // åˆ›å»ºå¼•ç”¨é¢„è§ˆå…ƒç´ 
            const replyPreview = document.createElement('div');
            replyPreview.id = 'reply-preview';
            replyPreview.className = 'reply-preview';

            // æˆªæ–­æ˜¾ç¤ºå†…å®¹ - ç¼©çŸ­åˆ°25å­—ç¬¦
            const displayContent = truncateText(currentReplyTo.content, 25);

            replyPreview.innerHTML = `
                <div class="reply-preview-content">
                    <div class="reply-preview-line"></div>
                    <div class="reply-preview-text">
                        <div class="reply-preview-sender">${currentReplyTo.senderName}</div>
                        <div class="reply-preview-message">${displayContent}</div>
                    </div>
                    <button class="reply-preview-close" onclick="cancelReply()">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `;

            // ğŸ”¥ã€ä¿®å¤ã€‘ç¡®ä¿å¼•ç”¨é¢„è§ˆå¯è§
            replyPreview.style.display = 'block';
            replyPreview.style.visibility = 'visible';

            // æ’å…¥åˆ°è¾“å…¥åŒºåŸŸå†…éƒ¨çš„é¡¶éƒ¨
            const inputArea = document.querySelector('.chat-input-area');
            if (inputArea) {
                // å°†å¼•ç”¨é¢„è§ˆæ’å…¥åˆ°è¾“å…¥åŒºåŸŸçš„ç¬¬ä¸€ä¸ªå­å…ƒç´ ä¹‹å‰
                const firstChild = inputArea.firstElementChild;
                if (firstChild) {
                    inputArea.insertBefore(replyPreview, firstChild);
                } else {
                    inputArea.appendChild(replyPreview);
                }
            }
        }
        
        // å–æ¶ˆå¼•ç”¨
        function cancelReply() {
            currentReplyTo = null;

            // ğŸ”¥ã€æ–°å¢ã€‘æ¸…é™¤å½“å‰èŠå¤©çš„å¼•ç”¨çŠ¶æ€
            if (currentChatCharacter) {
                delete chatReplyStates[currentChatCharacter.id];
            }

            const replyPreview = document.getElementById('reply-preview');
            if (replyPreview) {
                replyPreview.remove();
            }
        }
        
        // ç”Ÿæˆå¼•ç”¨æ¶ˆæ¯çš„HTML
        function generateReplyHTML(replyTo) {
            if (!replyTo) return '';

            let displayContent = truncateText(replyTo.content, 20);
            // å¤„ç†å¼•ç”¨æ¶ˆæ¯ä¸­çš„@å†…å®¹
            displayContent = processMentions(displayContent);

            return `
                <div class="reply-reference">
                    <div class="reply-reference-line"></div>
                    <div class="reply-reference-content">
                        <div class="reply-reference-sender">${replyTo.senderName}</div>
                        <div class="reply-reference-message">${displayContent}</div>
                    </div>
                </div>
            `;
        }
        
        // å¤åˆ¶æ¶ˆæ¯
        function copyMessage(messageId = null) {
            const targetMessageId = messageId || selectedMessageId;
            console.log('å¤åˆ¶æ¶ˆæ¯:', targetMessageId, 'æ¥æº:', messageId ? 'ç§»åŠ¨ç«¯' : 'æ¡Œé¢ç«¯');
            if (!targetMessageId) {
                console.log('é”™è¯¯: æ²¡æœ‰é€‰ä¸­çš„æ¶ˆæ¯ID');
                return;
            }

            const messages = chatMessages[currentChatCharacter.id] || [];
            const message = messages.find(msg => msg.id === targetMessageId);
            
            if (message && message.content) {
                navigator.clipboard.writeText(message.content).then(() => {
                    alert('æ¶ˆæ¯å·²å¤åˆ¶');
                }).catch(() => {
                    alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·é‡è¯•');
                });
            }
            
            hideMessageMenu();
        }
        
        // æ˜¾ç¤ºç¼–è¾‘æ¶ˆæ¯æ¨¡æ€æ¡†
        function showEditMessageModal(messageId) {
            if (!messageId) return;
            
            const messages = chatMessages[currentChatCharacter.id] || [];
            const message = messages.find(msg => msg.id === messageId);
            
            if (!message) {
                showToast('æ¶ˆæ¯ä¸å­˜åœ¨', 'error');
                return;
            }
            
            // åˆ›å»ºç¼–è¾‘æ¨¡æ€æ¡†
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.id = 'edit-message-modal';
            
            const senderName = message.sender === 'sent' ? 'ä½ ' : (message.name || currentChatCharacter.name);
            
            modal.innerHTML = `
                <div class="modal-content edit-message-modal">
                    <div class="modal-header">
                        <h3>ç¼–è¾‘æ¶ˆæ¯</h3>
                        <button class="modal-close" onclick="hideEditMessageModal()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="edit-message-info">
                            <span class="message-sender">${senderName}</span>
                            <span class="message-time">${formatTimestamp(message.timestamp)}</span>
                        </div>
                        <div class="edit-form-group">
                            <label>æ¶ˆæ¯å†…å®¹ï¼š</label>
                            <textarea 
                                id="edit-message-content" 
                                class="edit-message-textarea"
                                placeholder="è¯·è¾“å…¥æ¶ˆæ¯å†…å®¹..."
                                maxlength="2000"
                            >${message.content || ''}</textarea>
                            <div class="edit-message-counter">
                                <span id="edit-char-count">${(message.content || '').length}</span>/2000
                            </div>
                        </div>
                        ${message.image ? `
                            <div class="edit-form-group">
                                <label>å›¾ç‰‡ï¼š</label>
                                <div class="edit-message-image">
                                    <img src="${message.image}" alt="æ¶ˆæ¯å›¾ç‰‡" />
                                    <button class="remove-image-btn" onclick="removeMessageImage()">åˆ é™¤å›¾ç‰‡</button>
                                </div>
                            </div>
                        ` : ''}
                    </div>
                    <div class="modal-footer">
                        <button class="modal-btn modal-cancel" onclick="hideEditMessageModal()">å–æ¶ˆ</button>
                        <button class="modal-btn modal-confirm" onclick="saveEditedMessage('${messageId}')">ä¿å­˜</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // æ·»åŠ å­—ç¬¦è®¡æ•°åŠŸèƒ½
            const textarea = document.getElementById('edit-message-content');
            const charCount = document.getElementById('edit-char-count');
            textarea.addEventListener('input', function() {
                charCount.textContent = this.value.length;
            });
            
            // ğŸ”¥ã€ä¿®å¤ã€‘èšç„¦ä½†ä¸é€‰ä¸­æ–‡æœ¬ï¼Œå…‰æ ‡ç§»åˆ°æœ«å°¾
            setTimeout(() => {
                textarea.focus();
                textarea.setSelectionRange(textarea.value.length, textarea.value.length);
            }, 100);
        }
        
        // éšè—ç¼–è¾‘æ¶ˆæ¯æ¨¡æ€æ¡†
        function hideEditMessageModal() {
            const modal = document.getElementById('edit-message-modal');
            if (modal) {
                modal.remove();
            }
        }
        
        // ä¿å­˜ç¼–è¾‘åçš„æ¶ˆæ¯
        function saveEditedMessage(messageId) {
            const newContent = document.getElementById('edit-message-content').value.trim();
            
            if (!newContent) {
                showToast('æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º', 'error');
                return;
            }
            
            const messages = chatMessages[currentChatCharacter.id] || [];
            const messageIndex = messages.findIndex(msg => msg.id === messageId);
            
            if (messageIndex !== -1) {
                const oldContent = messages[messageIndex].content;
                messages[messageIndex].content = newContent;
                
                // æ·»åŠ ç¼–è¾‘æ ‡è®°
                messages[messageIndex].edited = true;
                messages[messageIndex].editTime = Date.now();
                
                saveChatMessages();
                renderChatMessages(currentChatCharacter.id);
                hideEditMessageModal();
                
                showToast('æ¶ˆæ¯å·²æ›´æ–°', 'success');
                
                console.log(`æ¶ˆæ¯å·²ç¼–è¾‘: "${oldContent}" -> "${newContent}"`);
            } else {
                showToast('æ¶ˆæ¯ä¸å­˜åœ¨', 'error');
            }
        }
        
        // ç§»é™¤æ¶ˆæ¯å›¾ç‰‡
        function removeMessageImage() {
            // è¿™ä¸ªåŠŸèƒ½å¯ä»¥åœ¨åç»­æ‰©å±•
            showToast('æš‚ä¸æ”¯æŒç§»é™¤å›¾ç‰‡', 'info');
        }
        
        // ç¼–è¾‘æ¶ˆæ¯ï¼ˆä¿ç•™æ—§ç‰ˆæœ¬æ¥å£ï¼‰
        function editMessage() {
            if (!selectedMessageId) return;
            
            showEditMessageModal(selectedMessageId);
            hideModal('message-menu-modal');
        }
        
        // éªŒè¯å¤´åƒæ¥æºæ˜¯å¦æœ‰æ•ˆ
        async function validateAvatarSource(avatarUrl) {
            console.log('éªŒè¯å¤´åƒæ¥æº:', avatarUrl);
            if (!avatarUrl) return false;

            // ğŸ”¥ã€ä¿®å¤ã€‘å¤„ç†å ä½ç¬¦ï¼Œå…ˆæ›¿æ¢ä¸ºå®é™…å›¾ç‰‡URLå†éªŒè¯
            let actualAvatarUrl = avatarUrl;
            if (avatarUrl === 'CURRENT_USER_IMAGE' ||
                avatarUrl === 'CURRENT_USER_IMAGE' ||
                avatarUrl === 'ç”¨æˆ·å‘é€çš„å›¾ç‰‡URL' ||
                avatarUrl === 'å›¾ç‰‡URL') {
                const recentUserImage = getRecentUserImage();
                if (recentUserImage) {
                    actualAvatarUrl = recentUserImage;
                    console.log('å ä½ç¬¦æ›¿æ¢ä¸ºå®é™…å›¾ç‰‡URL:', actualAvatarUrl);
                } else {
                    console.log('æ²¡æœ‰æ‰¾åˆ°ç”¨æˆ·å‘é€çš„å›¾ç‰‡ï¼ŒéªŒè¯å¤±è´¥');
                    return false;
                }
            }

            // æ£€æŸ¥æ˜¯å¦æ˜¯ç”¨æˆ·å‘é€çš„å›¾ç‰‡ï¼ˆåœ¨èŠå¤©è®°å½•ä¸­ï¼‰
            if (currentChatCharacter && chatMessages[currentChatCharacter.id]) {
                const userImages = chatMessages[currentChatCharacter.id]
                    .filter(msg => msg.sender === 'sent' && msg.image)
                    .map(msg => msg.image);

                console.log('ç”¨æˆ·å‘é€çš„å›¾ç‰‡åˆ—è¡¨:', userImages);
                console.log('æ£€æŸ¥å¤´åƒURLæ˜¯å¦åœ¨ç”¨æˆ·å›¾ç‰‡ä¸­:', userImages.includes(actualAvatarUrl));

                if (userImages.includes(actualAvatarUrl)) {
                    console.log('å¤´åƒæ¥æºéªŒè¯é€šè¿‡ï¼šç”¨æˆ·å‘é€çš„å›¾ç‰‡');
                    return true;
                }
            }

            // æ£€æŸ¥æ˜¯å¦æ˜¯ä¸–ç•Œä¹¦ä¸­æä¾›çš„å¤´åƒURL
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.worldbookMountEnabled && chatSettings.selectedWorldbooks) {
                for (const worldbookId of chatSettings.selectedWorldbooks) {
                    const worldbook = worldbooks.find(w => w.id === worldbookId);
                    if (worldbook && worldbook.content && worldbook.content.includes(actualAvatarUrl)) {
                        console.log('å¤´åƒæ¥æºéªŒè¯é€šè¿‡ï¼šä¸–ç•Œä¹¦ä¸­çš„URL');
                        return true;
                    }
                }
            }

            console.log('å¤´åƒæ¥æºéªŒè¯å¤±è´¥');
            return false;
        }
        
        // è§’è‰²ä¸»åŠ¨æ›´æ¢å¤´åƒåŠŸèƒ½ - åªä¿®æ”¹èŠå¤©è®¾ç½®ä¸­çš„å¤´åƒï¼Œä¸ä¿®æ”¹è§’è‰²å¡
        async function changeCharacterAvatarByAI(newAvatarUrl, reason = '') {
            if (!currentChatCharacter || !newAvatarUrl) return false;
            
            try {
                // è·å–æˆ–åˆ›å»ºå½“å‰èŠå¤©çš„è®¾ç½®
                const currentSettings = getCurrentChatSettings();
                
                // å‹ç¼©å¤´åƒå›¾ç‰‡ä»¥å‡å°‘å­˜å‚¨ç©ºé—´
                let compressedAvatarUrl = newAvatarUrl;
                if (newAvatarUrl.startsWith('data:image')) {
                    try {
                        compressedAvatarUrl = await compressImage(newAvatarUrl, 200, 0.7);
                        console.log('å¤´åƒå·²å‹ç¼©ä»¥èŠ‚çœå­˜å‚¨ç©ºé—´');
                    } catch (error) {
                        console.warn('å¤´åƒå‹ç¼©å¤±è´¥ï¼Œä½¿ç”¨åŸå›¾:', error);
                    }
                }
                
                // ğŸ”¥ã€ä¿®å¤ã€‘ä½¿ç”¨åŠ¨æ€å¤´åƒå­—æ®µï¼Œä¼˜å…ˆçº§é«˜äºç”¨æˆ·è®¾ç½®çš„èŠå¤©å¤´åƒ
                if (!chatSettings[currentChatCharacter.id]) {
                    chatSettings[currentChatCharacter.id] = {};
                }
                chatSettings[currentChatCharacter.id].aiDynamicAvatar = compressedAvatarUrl;
                
                console.log(`åŠ¨æ€å¤´åƒå·²è®¾ç½®ï¼š`, {
                    characterId: currentChatCharacter.id,
                    characterName: currentChatCharacter.name,
                    avatarUrl: compressedAvatarUrl.substring(0, 50) + '...',
                    settingsSnapshot: {
                        aiDynamicAvatar: !!chatSettings[currentChatCharacter.id].aiDynamicAvatar,
                        aiChatAvatar: !!chatSettings[currentChatCharacter.id].aiChatAvatar
                    }
                });
                
                // ä¿å­˜èŠå¤©è®¾ç½®
                await saveChatSettings();
                
                // å‘é€ç³»ç»Ÿæç¤ºæ¶ˆæ¯
                const systemMessage = {
                    id: Date.now().toString(),
                    sender: 'system',
                    content: `${currentChatCharacter.name} æ›´æ¢äº†å¤´åƒ${reason ? ': ' + reason : ''}`,
                    timestamp: Date.now(),
                    isAvatarChange: true
                };
                
                if (!chatMessages[currentChatCharacter.id]) {
                    chatMessages[currentChatCharacter.id] = [];
                }
                chatMessages[currentChatCharacter.id].push(systemMessage);
                await saveChatMessages();
                
                // ğŸ”¥ã€ä¿®å¤ã€‘åœ¨ä¿å­˜æ¶ˆæ¯åå†åˆ·æ–°èŠå¤©ç•Œé¢ï¼Œç¡®ä¿åŒ…å«æ–°å¤´åƒå’Œç³»ç»Ÿæ¶ˆæ¯
                renderChatMessages(currentChatCharacter.id);
                
                // ğŸ”¥ã€æ–°å¢ã€‘å¼ºåˆ¶åˆ·æ–°æ‰€æœ‰å¤´åƒæ˜¾ç¤º
                forceRefreshAvatars();
                
                console.log(`è§’è‰² ${currentChatCharacter.name} åœ¨å½“å‰èŠå¤©ä¸­æ›´æ¢äº†å¤´åƒï¼Œä½†è§’è‰²å¡ä¿æŒä¸å˜`);
                
                return true;
            } catch (error) {
                console.error('è§’è‰²æ›´æ¢å¤´åƒå¤±è´¥:', error);
                return false;
            }
            
            return false;
        }
        
        // åˆ é™¤æ¶ˆæ¯
        async function deleteMessage(messageId = null) {
            const targetMessageId = messageId || selectedMessageId;
            console.log('åˆ é™¤æ¶ˆæ¯:', targetMessageId, 'æ¥æº:', messageId ? 'ç§»åŠ¨ç«¯' : 'æ¡Œé¢ç«¯');
            if (!targetMessageId) {
                console.log('é”™è¯¯: æ²¡æœ‰é€‰ä¸­çš„æ¶ˆæ¯ID');
                return;
            }

                const messages = chatMessages[currentChatCharacter.id] || [];
                const messageIndex = messages.findIndex(msg => msg.id === targetMessageId);
                
            if (messageIndex === -1) {
                hideMessageMenu();
                return;
            }
            
            const messageToDelete = messages[messageIndex];
            
            if (confirm('ç¡®å®šè¦æ’¤å›è¿™æ¡æ¶ˆæ¯å—ï¼Ÿ')) {
                // ä¿å­˜åŸå§‹æ¶ˆæ¯å†…å®¹
                const originalContent = messageToDelete.content || '[å›¾ç‰‡]';

                // ğŸ”¥ã€ä¿®å¤ã€‘åˆ é™¤ç›¸å…³çš„æ—¶é—´çº¿è®°å½•å’Œå·¥ä½œè®°å¿†
                try {
                    await deleteRelatedTimelineEvents(messageToDelete);
                    console.log('âœ… å·²æ¸…ç†æ’¤å›æ¶ˆæ¯çš„ç›¸å…³æ—¶é—´çº¿è®°å½•');
                } catch (error) {
                    console.error('åˆ é™¤æ—¶é—´çº¿è®°å½•å¤±è´¥:', error);
                }

                // åˆ é™¤åŸæ¶ˆæ¯
                    messages.splice(messageIndex, 1);

                // ğŸ”¥ã€æ–°å¢ã€‘åˆ›å»ºæ’¤å›æ¶ˆæ¯ç³»ç»Ÿæé†’
                const whoRecalled = messageToDelete.sender === 'received' ? 'å¯¹æ–¹' : 'ä½ ';
                const recallSystemMessage = {
                    id: Date.now().toString(),
                    sender: 'system',
                    content: `${whoRecalled}æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯ï¼ŒåŸæ–‡æ˜¯ï¼š"${originalContent}"`,
                    timestamp: messageToDelete.timestamp || Date.now(),
                    isRecall: true
                };

                // åœ¨åŸä½ç½®æ’å…¥æ’¤å›æé†’
                messages.splice(messageIndex, 0, recallSystemMessage);

                    saveChatMessages();
                    renderChatMessages(currentChatCharacter.id);
                    // æ›´æ–°æ¶ˆæ¯åˆ—è¡¨ä¸­çš„æœ€åä¸€æ¡æ¶ˆæ¯
                    renderMessageList();
            }
            
            hideMessageMenu();
        }
        

        
        // æ ¼å¼åŒ–æ—¶é—´
        function formatTime(timestamp) {
            const date = new Date(timestamp);
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        }
        
        // æ ¼å¼åŒ–æ—¶é—´æˆ³ï¼ˆå®Œæ•´æ—¶é—´ï¼‰
        function formatTimestamp(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const yesterday = new Date(today.getTime() - 24 * 60 * 60 * 1000);
            const messageDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            const timeStr = `${hours}:${minutes}`;
            
            if (messageDate.getTime() === today.getTime()) {
                return timeStr; // ä»Šå¤©åªæ˜¾ç¤ºæ—¶é—´
            } else if (messageDate.getTime() === yesterday.getTime()) {
                return `æ˜¨å¤© ${timeStr}`;
            } else {
                const month = (date.getMonth() + 1).toString().padStart(2, '0');
                const day = date.getDate().toString().padStart(2, '0');
                return `${month}æœˆ${day}æ—¥ ${timeStr}`;
            }
        }
        
        // æ ¼å¼åŒ–æ—¶é—´ï¼ˆä»…æ—¶åˆ†ï¼‰
        function formatTimeOnly(timestamp) {
            const date = new Date(timestamp);
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        }
        
        // æ ¼å¼åŒ–å®Œæ•´æ—¥æœŸ
        function formatFullDate(date) {
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${year}å¹´${month}æœˆ${day}æ—¥ ${hours}:${minutes}`;
        }
        
        // åŠ è½½URL
        function loadUrl() {
            const url = document.getElementById('browser-url').value;
            let fullUrl = url;
            
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                fullUrl = 'https://' + url;
            }
            
            document.getElementById('browser-frame').src = fullUrl;
        }
        
        // æ—§ç‰ˆæœ¬APIç±»å‹åˆ‡æ¢å¤„ç†å·²åˆ é™¤ - ä½¿ç”¨æ–°ç‰ˆæœ¬çš„APIè®¾ç½®ç³»ç»Ÿ
        
        // æ—§ç‰ˆæœ¬æµ‹è¯•APIè¿æ¥å’Œè·å–æ¨¡å‹åˆ—è¡¨å‡½æ•°å·²åˆ é™¤ - ç°åœ¨ä½¿ç”¨æ–°ç‰ˆæœ¬çš„APIè®¾ç½®ç³»ç»Ÿ
        
        // ä¿å­˜APIè®¾ç½®
        async function saveApiSettings() {
            const baseUrl = document.getElementById('api-base').value.trim();
            const apiKey = document.getElementById('api-key').value.trim();
            const model = document.getElementById('model-select').value.trim();
            const temperature = parseFloat(document.getElementById('temperature-slider').value) || 0.75;

            if (!baseUrl || !apiKey || !model) {
                showToast('è¯·å¡«å†™å®Œæ•´çš„APIé…ç½®ä¿¡æ¯', 'error');
                return;
            }

            apiSettings = {
                base: baseUrl,
                key: apiKey,
                model: model,
                temperature: temperature,
                endpoint: '/chat/completions'  // æ·»åŠ é»˜è®¤endpoint
            };

            try {
                // ğŸ”¥ã€ä¿®å¤ã€‘åŒæ—¶ä¿å­˜åˆ°IndexedDBå’ŒlocalStorageï¼Œç¡®ä¿æ•°æ®ä¸€è‡´æ€§
                await db.apiSettings.put({
                    id: 'main',
                    settings: apiSettings
                });
                localStorage.setItem('apiSettings', JSON.stringify(apiSettings));

                showToast('APIè®¾ç½®å·²ä¿å­˜ï¼', 'success');
                console.log('ğŸ”§ [APIè®¾ç½®] å·²ä¿å­˜åˆ°IndexedDBå’ŒlocalStorage:', apiSettings);
            } catch (error) {
                console.error('ä¿å­˜APIè®¾ç½®å¤±è´¥:', error);
                showToast('ä¿å­˜APIè®¾ç½®å¤±è´¥: ' + error.message, 'error');
                return;
            }

            // æ›´æ–°æ¸©åº¦æ˜¾ç¤º
            document.getElementById('temperature-value').textContent = temperature.toFixed(2);

            // ä¿®å¤ï¼šä¿å­˜åä¸è·³è½¬ï¼Œç•™åœ¨å½“å‰APIè®¾ç½®é¡µé¢
        }
        
        // ğŸŒŸ Geminiç›´è¿å¿«é€Ÿè®¾ç½®
        function setGeminiDirect() {
            // è‡ªåŠ¨å¡«å……Geminié…ç½®
            document.getElementById('api-base').value = 'https://generativelanguage.googleapis.com/v1beta';
            document.getElementById('api-key').placeholder = 'è¯·è¾“å…¥Google AI Studioçš„API Key';
            
            // æ¸…ç©ºä¹‹å‰çš„æ¨¡å‹é€‰æ‹©å¹¶æ·»åŠ Geminiæ¨¡å‹
            const modelSelect = document.getElementById('model-select');
            modelSelect.innerHTML = `
                <option value="">è¯·é€‰æ‹©æ¨¡å‹...</option>
                <option value="gemini-2.0-flash-exp">Gemini 2.0 Flash (å®éªŒç‰ˆ) - æ¨è</option>
                <option value="gemini-1.5-flash">Gemini 1.5 Flash - å¿«é€Ÿ</option>
                <option value="gemini-1.5-flash-8b">Gemini 1.5 Flash 8B - è½»é‡</option>
                <option value="gemini-1.5-pro">Gemini 1.5 Pro - ç¨³å®š</option>
                <option value="gemini-pro">Gemini Pro - ç»å…¸</option>
                <option value="gemini-pro-vision">Gemini Pro Vision - è§†è§‰</option>
                <option value="æ‰‹åŠ¨è¾“å…¥æ¨¡å‹åç§°">æ‰‹åŠ¨è¾“å…¥æ¨¡å‹åç§°</option>
            `;
            
            // æ·»åŠ æ‰‹åŠ¨è¾“å…¥åŠŸèƒ½
            modelSelect.onchange = function() {
                if (this.value === 'æ‰‹åŠ¨è¾“å…¥æ¨¡å‹åç§°') {
                    const customModel = prompt('è¯·è¾“å…¥Geminiæ¨¡å‹åç§°\n\nå¸¸è§é€‰é¡¹ï¼š\nâ€¢ gemini-2.0-flash-exp\nâ€¢ gemini-1.5-flash\nâ€¢ gemini-1.5-pro\nâ€¢ gemini-pro');
                    if (customModel && customModel.trim()) {
                        const newOption = new Option(customModel.trim(), customModel.trim());
                        this.insertBefore(newOption, this.lastElementChild);
                        this.value = customModel.trim();
                    } else {
                        this.value = '';
                    }
                }
            };
            
            showToast('ğŸŒŸ Geminiç›´è¿é…ç½®å·²è‡ªåŠ¨å¡«å†™ï¼\n\nä½¿ç”¨è¯´æ˜ï¼š\n1. è¯·åœ¨Google AI Studioè·å–API Key\n2. é€‰æ‹©åˆé€‚çš„æ¨¡å‹\n3. ç‚¹å‡»"æµ‹è¯•è¿æ¥"éªŒè¯é…ç½®', 'success');
        }
        
        // ğŸ¤— HuggingFaceåä»£å¿«é€Ÿè®¾ç½®
        function setHuggingFaceProxy() {
            // è‡ªåŠ¨å¡«å……HuggingFaceåä»£é…ç½® - ä½¿ç”¨æ­£ç¡®çš„æ ¼å¼
            document.getElementById('api-base').value = 'https://xxx-xxx.hf.space/v1';
            document.getElementById('api-key').placeholder = 'è¯·è¾“å…¥HuggingFaceçš„API Token';
            
            // æ¸…ç©ºä¹‹å‰çš„æ¨¡å‹é€‰æ‹©å¹¶æ·»åŠ å¸¸è§HFæ¨¡å‹
            const modelSelect = document.getElementById('model-select');
            modelSelect.innerHTML = `
                <option value="">è¯·é€‰æ‹©æ¨¡å‹...</option>
                <optgroup label="Llamaç³»åˆ—">
                    <option value="meta-llama/Llama-2-7b-chat-hf">Llama-2-7b-chat-hf</option>
                    <option value="meta-llama/Llama-2-13b-chat-hf">Llama-2-13b-chat-hf</option>
                    <option value="meta-llama/Meta-Llama-3-8B-Instruct">Meta-Llama-3-8B-Instruct</option>
                </optgroup>
                <optgroup label="å¯¹è¯æ¨¡å‹">
                <option value="microsoft/DialoGPT-large">DialoGPT-large</option>
                <option value="microsoft/DialoGPT-medium">DialoGPT-medium</option>
                    <option value="facebook/blenderbot-400M-distill">BlenderBot-400M</option>
                </optgroup>
                <optgroup label="é€šç”¨æ¨¡å‹">
                    <option value="mistralai/Mistral-7B-Instruct-v0.1">Mistral-7B-Instruct</option>
                    <option value="teknium/OpenHermes-2.5-Mistral-7B">OpenHermes-2.5-Mistral-7B</option>
                </optgroup>
                <optgroup label="è‡ªå®šä¹‰">
                    <option value="custom">æ‰‹åŠ¨è¾“å…¥æ¨¡å‹åç§°...</option>
                </optgroup>
            `;
            
            // æ·»åŠ è‡ªå®šä¹‰æ¨¡å‹è¾“å…¥åŠŸèƒ½
            modelSelect.onchange = function() {
                if (this.value === 'custom') {
                    const customModel = prompt('è¯·è¾“å…¥æ¨¡å‹åç§°ï¼ˆä¾‹å¦‚ï¼šmeta-llama/Llama-2-7b-chat-hfï¼‰ï¼š');
                    if (customModel && customModel.trim()) {
                        const newOption = new Option(customModel.trim(), customModel.trim());
                        this.insertBefore(newOption, this.lastElementChild);
                        this.value = customModel.trim();
                    } else {
                        this.value = '';
                    }
                }
            };
            
            showToast('ğŸ¤— HuggingFaceåä»£é…ç½®å·²è‡ªåŠ¨å¡«å†™ï¼\n\nè¯·ï¼š\n1. å°†åœ°å€ä¸­çš„ xxx-xxx æ›¿æ¢ä¸ºå®é™…çš„HF Spaceåœ°å€\n2. é€‰æ‹©æ¨¡å‹æˆ–æ‰‹åŠ¨è¾“å…¥æ¨¡å‹åç§°', 'success');
        }
        
        // ä¿å­˜å½“å‰é…ç½®ä¸ºé¢„è®¾
        function saveCurrentConfig() {
            const configName = document.getElementById('config-name-input').value.trim();
            
            if (!configName) {
                showToast('è¯·è¾“å…¥é…ç½®åç§°', 'error');
                return;
            }
            
            const currentConfig = {
                name: configName,
                base: document.getElementById('api-base').value.trim(),
                key: document.getElementById('api-key').value.trim(),
                model: document.getElementById('model-select').value.trim(),
                temperature: parseFloat(document.getElementById('temperature-slider').value) || 0.75,
                savedAt: new Date().toLocaleString()
            };
            
            // è·å–å·²ä¿å­˜çš„é…ç½®
            let savedConfigs = JSON.parse(localStorage.getItem('savedApiConfigs') || '[]');
            
            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨åŒåé…ç½®
            const existingIndex = savedConfigs.findIndex(config => config.name === configName);
            if (existingIndex !== -1) {
                if (confirm(`é…ç½®"${configName}"å·²å­˜åœ¨ï¼Œæ˜¯å¦è¦†ç›–ï¼Ÿ`)) {
                    savedConfigs[existingIndex] = currentConfig;
                } else {
                    return;
                }
            } else {
                savedConfigs.push(currentConfig);
            }
            
            localStorage.setItem('savedApiConfigs', JSON.stringify(savedConfigs));
            document.getElementById('config-name-input').value = '';
            
            renderSavedConfigs();
            showToast(`é…ç½®"${configName}"å·²ä¿å­˜`, 'success');
        }
        
        // æ¸²æŸ“å·²ä¿å­˜çš„é…ç½®
        function renderSavedConfigs() {
            const container = document.getElementById('saved-configs-container');
            const noConfigsMessage = document.getElementById('no-configs-message');
            const savedConfigs = JSON.parse(localStorage.getItem('savedApiConfigs') || '[]');
            
            if (savedConfigs.length === 0) {
                container.style.display = 'none';
                noConfigsMessage.style.display = 'block';
                return;
            }
            
            container.style.display = 'grid';
            noConfigsMessage.style.display = 'none';
            
            container.innerHTML = savedConfigs.map(config => `
                <div class="config-card" style="background: rgba(255,255,255,0.8); border-radius: 12px; padding: 15px; border: 1px solid rgba(0,0,0,0.05); transition: all 0.3s ease; cursor: pointer;" onclick="loadConfig('${config.name}')">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                        <div style="font-weight: 600; color: #333; font-size: 15px;">${config.name}</div>
                        <button onclick="event.stopPropagation(); deleteConfig('${config.name}')" style="background: none; border: none; color: #ff6b6b; cursor: pointer; padding: 2px 6px; border-radius: 4px; font-size: 12px; transition: all 0.2s ease;" onmouseover="this.style.background='rgba(255,107,107,0.1)'" onmouseout="this.style.background='none'">ğŸ—‘ï¸</button>
                    </div>
                    <div style="font-size: 12px; color: #666; margin-bottom: 4px;">
                        <div>ğŸŒ ${config.base}</div>
                        <div>ğŸ¤– ${config.model}</div>
                        <div>ğŸŒ¡ï¸ æ¸©åº¦: ${config.temperature}</div>
                    </div>
                    <div style="font-size: 11px; color: #999;">ä¿å­˜äº: ${config.savedAt}</div>
                </div>
            `).join('');
        }
        
        // åŠ è½½é…ç½®
        function loadConfig(configName) {
            const savedConfigs = JSON.parse(localStorage.getItem('savedApiConfigs') || '[]');
            const config = savedConfigs.find(c => c.name === configName);
            
            if (!config) {
                showToast('é…ç½®ä¸å­˜åœ¨', 'error');
                return;
            }
            
            // å¡«å……è¡¨å•
            document.getElementById('api-base').value = config.base;
            document.getElementById('api-key').value = config.key;
            document.getElementById('temperature-slider').value = config.temperature;
            document.getElementById('temperature-value').textContent = config.temperature.toFixed(2);
            
            // å¤„ç†æ¨¡å‹é€‰æ‹©
            const modelSelect = document.getElementById('model-select');
            const existingOption = Array.from(modelSelect.options).find(option => option.value === config.model);
            if (!existingOption) {
                // å¦‚æœæ¨¡å‹ä¸åœ¨å½“å‰é€‰é¡¹ä¸­ï¼Œæ·»åŠ å®ƒ
                const newOption = new Option(config.model, config.model);
                modelSelect.appendChild(newOption);
            }
            modelSelect.value = config.model;
            
            showToast(`å·²åŠ è½½é…ç½®"${configName}"`, 'success');
        }
        
        // åˆ é™¤é…ç½®
        function deleteConfig(configName) {
            if (confirm(`ç¡®å®šè¦åˆ é™¤é…ç½®"${configName}"å—ï¼Ÿ`)) {
                let savedConfigs = JSON.parse(localStorage.getItem('savedApiConfigs') || '[]');
                savedConfigs = savedConfigs.filter(config => config.name !== configName);
                localStorage.setItem('savedApiConfigs', JSON.stringify(savedConfigs));
                renderSavedConfigs();
                showToast(`é…ç½®"${configName}"å·²åˆ é™¤`, 'success');
            }
        }
        
        // æ¸…ç©ºæ‰€æœ‰é…ç½®
        function clearAllConfigs() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å·²ä¿å­˜çš„é…ç½®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚')) {
                localStorage.removeItem('savedApiConfigs');
                renderSavedConfigs();
                showToast('æ‰€æœ‰é…ç½®å·²æ¸…ç©º', 'success');
            }
        }
        
        // æµ‹è¯•APIè¿æ¥
        async function testApiConnection() {
            const baseUrl = document.getElementById('api-base').value.trim();
            const apiKey = document.getElementById('api-key').value.trim();
            const model = document.getElementById('model-select').value.trim();
            
            if (!baseUrl || !apiKey || !model) {
                showToast('è¯·å…ˆå¡«å†™å®Œæ•´çš„APIé…ç½®', 'error');
                return;
            }
            
            const testBtn = document.getElementById('test-api-connection-btn');
            const originalText = testBtn.textContent;
            testBtn.textContent = 'æµ‹è¯•ä¸­...';
            testBtn.disabled = true;
            
            try {
                // æ ¹æ®ä¸åŒçš„APIç±»å‹æ„å»ºæµ‹è¯•è¯·æ±‚
                let testUrl, testPayload, testHeaders;
                
                if (baseUrl.includes('generativelanguage.googleapis.com')) {
                    // Gemini APIæµ‹è¯•
                    testUrl = `${baseUrl}/models/${model}:generateContent?key=${apiKey}`;
                    testPayload = {
                        contents: [{
                            parts: [{ text: "Hello" }]
                        }],
                        generationConfig: {
                            temperature: 0.7
                            // ä¸æ·»åŠ maxOutputTokensç­‰Geminiä¸æ”¯æŒçš„å‚æ•°
                        }
                    };
                    testHeaders = {
                        'Content-Type': 'application/json'
                    };
                } else {
                    // OpenAIå…¼å®¹APIæµ‹è¯• - æ™ºèƒ½å¤„ç†URLæ‹¼æ¥
                    if (baseUrl.endsWith('/v1')) {
                        testUrl = `${baseUrl}/chat/completions`;
                    } else if (baseUrl.includes('/v1/')) {
                        // ä¿®å¤ï¼šå¦‚æœURLä¸­å·²ç»åŒ…å«/v1/è·¯å¾„ï¼Œç›´æ¥æ·»åŠ chat/completions
                        testUrl = `${baseUrl}/chat/completions`;
                    } else {
                        testUrl = `${baseUrl}/v1/chat/completions`;
                    }
                    testPayload = {
                        model: model,
                        messages: [{ role: "user", content: "Hello" }],
                        max_tokens: 10
                    };
                    testHeaders = {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    };
                }
                
                const response = await fetch(testUrl, {
                    method: 'POST',
                    headers: testHeaders,
                    body: JSON.stringify(testPayload)
                });
                
                if (response.ok) {
                    showToast('âœ… APIè¿æ¥æµ‹è¯•æˆåŠŸï¼', 'success');

                    // ğŸ”¥ã€ä¿®å¤ã€‘æµ‹è¯•æˆåŠŸåè‡ªåŠ¨ä¿å­˜APIè®¾ç½®ï¼Œé¿å…ç”¨æˆ·é‡å¤è¾“å…¥
                    apiSettings = {
                        base: baseUrl,
                        key: apiKey,
                        model: model,
                        temperature: parseFloat(document.getElementById('temperature-slider').value) || 0.75,
                        endpoint: '/chat/completions'
                    };

                    // ğŸ”¥ã€ä¿®å¤ã€‘åŒæ—¶ä¿å­˜åˆ°IndexedDBå’ŒlocalStorageï¼Œç¡®ä¿æ•°æ®ä¸€è‡´æ€§
                    try {
                        await db.apiSettings.put({
                            id: 'main',
                            settings: apiSettings
                        });
                        localStorage.setItem('apiSettings', JSON.stringify(apiSettings));
                        console.log('ğŸ”§ [APIæµ‹è¯•] APIè®¾ç½®å·²è‡ªåŠ¨ä¿å­˜åˆ°IndexedDBå’ŒlocalStorage');
                    } catch (error) {
                        console.error('è‡ªåŠ¨ä¿å­˜APIè®¾ç½®å¤±è´¥:', error);
                    }
                } else {
                    const errorText = await response.text();
                    showToast(`âŒ APIè¿æ¥å¤±è´¥: ${response.status} ${response.statusText}`, 'error');
                    console.error('APIæµ‹è¯•å¤±è´¥:', errorText);
                }
            } catch (error) {
                showToast(`âŒ è¿æ¥é”™è¯¯: ${error.message}`, 'error');
                console.error('APIæµ‹è¯•é”™è¯¯:', error);
            } finally {
                testBtn.textContent = originalText;
                testBtn.disabled = false;
            }
        }
        
        // è·å–æ¨¡å‹åˆ—è¡¨
        async function fetchModels() {
            const baseUrl = document.getElementById('api-base').value.trim();
            const apiKey = document.getElementById('api-key').value.trim();
            
            if (!baseUrl || !apiKey) {
                showToast('è¯·å…ˆå¡«å†™APIåœ°å€å’Œå¯†é’¥', 'error');
                return;
            }
            
            const fetchBtn = document.getElementById('fetch-models-btn');
            const originalText = fetchBtn.textContent;
            fetchBtn.textContent = 'è·å–ä¸­...';
            fetchBtn.disabled = true;
            
            try {
                let modelsUrl, headers;
                
                if (baseUrl.includes('generativelanguage.googleapis.com')) {
                    // Gemini API
                    modelsUrl = `${baseUrl}/models?key=${apiKey}`;
                    headers = {};
                } else {
                    // OpenAIå…¼å®¹API - æ™ºèƒ½å¤„ç†URLæ‹¼æ¥
                    if (baseUrl.endsWith('/v1')) {
                        modelsUrl = `${baseUrl}/models`;
                    } else if (baseUrl.includes('/v1/')) {
                        // ä¿®å¤ï¼šå¦‚æœURLä¸­å·²ç»åŒ…å«/v1/è·¯å¾„ï¼Œç›´æ¥æ·»åŠ models
                        modelsUrl = `${baseUrl}/models`;
                    } else {
                        modelsUrl = `${baseUrl}/v1/models`;
                    }
                    headers = {
                        'Authorization': `Bearer ${apiKey}`
                    };
                }
                
                // ğŸ”¥ã€ä¿®å¤ã€‘ç§»é™¤è¶…æ—¶æ§åˆ¶ï¼Œé¿å…AbortError
                const response = await fetch(modelsUrl, { 
                    headers
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                const modelSelect = document.getElementById('model-select');
                
                // æ¸…ç©ºç°æœ‰é€‰é¡¹
                modelSelect.innerHTML = '<option value="">è¯·é€‰æ‹©æ¨¡å‹...</option>';
                
                let models = [];
                if (data.models) {
                    // Gemini APIæ ¼å¼ - ä¿®å¤æ¨¡å‹è¿‡æ»¤é€»è¾‘
                    console.log('Gemini APIå“åº”æ•°æ®:', data);
                    models = data.models
                        .filter(model => {
                            // å…è®¸æ‰€æœ‰æ”¯æŒgenerateContentçš„æ¨¡å‹
                            return model.name && (
                                model.name.includes('gemini') ||
                                model.name.includes('models/') ||
                                model.supportedGenerationMethods?.includes('generateContent') ||
                                model.name.includes('generate')
                            );
                        })
                        .map(model => {
                            // æå–æ¨¡å‹åç§°ï¼Œå»æ‰å‰ç¼€
                            const modelName = model.name.includes('/') 
                                ? model.name.split('/').pop() 
                                : model.name;
                            return modelName;
                        });
                        
                    // å¦‚æœè¿‡æ»¤åæ²¡æœ‰æ¨¡å‹ï¼Œæ˜¾ç¤ºæ‰€æœ‰æ¨¡å‹ï¼ˆè°ƒè¯•ç”¨ï¼‰
                    if (models.length === 0 && data.models.length > 0) {
                        console.log('è¿‡æ»¤åæ²¡æœ‰æ¨¡å‹ï¼Œæ˜¾ç¤ºæ‰€æœ‰å¯ç”¨æ¨¡å‹:', data.models);
                        models = data.models.map(model => 
                            model.name.includes('/') ? model.name.split('/').pop() : model.name
                        );
                    }
                } else if (data.data) {
                    // OpenAI APIæ ¼å¼
                    models = data.data.map(model => model.id);
                }
                
                models.forEach(modelId => {
                    const option = new Option(modelId, modelId);
                    modelSelect.appendChild(option);
                });
                
                showToast(`âœ… æˆåŠŸè·å–åˆ° ${models.length} ä¸ªæ¨¡å‹`, 'success');
            } catch (error) {
                let errorMessage = error.message;
                
                if (errorMessage.includes('Failed to fetch') || errorMessage.includes('ERR_TIMED_OUT')) {
                    if (baseUrl.includes('.hf.space')) {
                        errorMessage = 'HuggingFace Spaceè¿æ¥è¶…æ—¶ï¼Œå¯èƒ½éœ€è¦å…ˆå¯åŠ¨æœåŠ¡æˆ–æ£€æŸ¥ç½‘ç»œè¿æ¥ã€‚\n\nğŸ’¡ å»ºè®®ï¼š\n1. æ£€æŸ¥HF Spaceæ˜¯å¦æ­£åœ¨è¿è¡Œ\n2. å°è¯•å…ˆæ‰‹åŠ¨è®¿é—®è¯¥URLæµ‹è¯•è¿æ¥\n3. å¦‚æœæœåŠ¡ä¸æ”¯æŒ/modelsç«¯ç‚¹ï¼Œè¯·æ‰‹åŠ¨è¾“å…¥æ¨¡å‹åç§°';
                    } else {
                        errorMessage = 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥URLæ˜¯å¦æ­£ç¡®ä»¥åŠç½‘ç»œè¿æ¥';
                    }
                }
                
                showToast(`âŒ è·å–æ¨¡å‹å¤±è´¥: ${errorMessage}`, 'error');
                console.error('è·å–æ¨¡å‹å¤±è´¥:', error);
                
                // ä¸ºGeminiæä¾›å¸¸è§æ¨¡å‹é€‰é¡¹ä½œä¸ºåå¤‡
                if (baseUrl.includes('generativelanguage.googleapis.com')) {
                    const modelSelect = document.getElementById('model-select');
                    modelSelect.innerHTML = `
                        <option value="">è¯·é€‰æ‹©æ¨¡å‹...</option>
                        <option value="gemini-2.0-flash-exp">Gemini 2.0 Flash (å®éªŒç‰ˆ)</option>
                        <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
                        <option value="gemini-1.5-flash-8b">Gemini 1.5 Flash 8B</option>
                        <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
                        <option value="gemini-pro">Gemini Pro</option>
                        <option value="gemini-pro-vision">Gemini Pro Vision</option>
                        <option value="æ‰‹åŠ¨è¾“å…¥æ¨¡å‹åç§°">æ‰‹åŠ¨è¾“å…¥æ¨¡å‹åç§°</option>
                    `;
                    setTimeout(() => {
                        showToast('ğŸ’¡ å·²ä¸ºæ‚¨æä¾›å¸¸è§Geminiæ¨¡å‹é€‰é¡¹', 'info');
                    }, 1000);
                }
                
                // å¦‚æœæ˜¯HF Spaceï¼Œç»™å‡ºé¢å¤–æç¤º
                if (baseUrl.includes('.hf.space')) {
                    setTimeout(() => {
                        showToast('ğŸ’¡ æç¤ºï¼šHuggingFace Spaceå¯èƒ½ä¸æ”¯æŒè‡ªåŠ¨è·å–æ¨¡å‹åˆ—è¡¨ï¼Œå»ºè®®æ‰‹åŠ¨è¾“å…¥æ¨¡å‹åç§°', 'info');
                    }, 2000);
                }
            } finally {
                fetchBtn.textContent = originalText;
                fetchBtn.disabled = false;
            }
        }
        
        // å¯¼å‡ºå®Œæ•´å¤‡ä»½
        function exportFullBackup() {
            // è¿™é‡Œå¯ä»¥å®ç°å®Œæ•´çš„æ•°æ®å¯¼å‡ºåŠŸèƒ½
            showToast('å¯¼å‡ºåŠŸèƒ½å¼€å‘ä¸­...', 'info');
        }
        
        // å¯¼å…¥å®Œæ•´å¤‡ä»½
        function importFullBackup() {
            // è¿™é‡Œå¯ä»¥å®ç°å®Œæ•´çš„æ•°æ®å¯¼å…¥åŠŸèƒ½
            document.getElementById('import-full-backup-input').click();
        }
        
        // åˆå§‹åŒ–APIè®¾ç½®ç•Œé¢
        async function initializeApiSettings() {
            // åŠ è½½å·²ä¿å­˜çš„APIé…ç½®åˆ°è¡¨å•
            await loadApiSettingsToForm();

            // æ¸²æŸ“å·²ä¿å­˜çš„é…ç½®
            renderSavedConfigs();
        }
        
        // ğŸ”¥ã€ä¿®å¤ã€‘åŠ è½½APIè®¾ç½®åˆ°è¡¨å•å¹¶è‡ªåŠ¨æ‹‰å–æ¨¡å‹
        async function loadApiSettingsToForm() {
            try {
                // ä»IndexedDBåŠ è½½è®¾ç½®
                const savedSettings = await db.apiSettings.get('main');
                let settings = null;

                if (savedSettings) {
                    settings = savedSettings.settings;
                } else {
                    // å°è¯•ä»localStorageè¿ç§»
                    const localSettings = localStorage.getItem('apiSettings');
                    if (localSettings) {
                        settings = JSON.parse(localSettings);
                        // è¿ç§»åˆ°IndexedDB
                        await db.apiSettings.put({
                            id: 'main',
                            settings: settings
                        });
                        console.log('ğŸ”§ [APIè®¾ç½®] å·²è¿ç§»localStorageè®¾ç½®åˆ°IndexedDB');
                    }
                }

                if (settings) {
                    console.log('ğŸ”§ [APIè®¾ç½®] åŠ è½½å·²ä¿å­˜çš„APIè®¾ç½®:', settings);

                    // å¡«å……è¡¨å•å­—æ®µ
                    if (settings.base) {
                        const baseInput = document.getElementById('api-base');
                        if (baseInput) baseInput.value = settings.base;
                    }

                    if (settings.key) {
                        const keyInput = document.getElementById('api-key');
                        if (keyInput) keyInput.value = settings.key;
                    }

                    if (settings.temperature !== undefined) {
                        const tempSlider = document.getElementById('temperature-slider');
                        const tempValue = document.getElementById('temperature-value');
                        if (tempSlider && tempValue) {
                            tempSlider.value = settings.temperature;
                            tempValue.textContent = settings.temperature.toFixed(2);
                        }
                    }

                    // ğŸ”¥ã€é‡è¦ä¿®å¤ã€‘å¦‚æœæœ‰ä¿å­˜çš„APIè®¾ç½®ï¼Œè‡ªåŠ¨æ‹‰å–æ¨¡å‹åˆ—è¡¨
                    if (settings.base && settings.key) {
                        console.log('ğŸ”§ [APIè®¾ç½®] æ£€æµ‹åˆ°å®Œæ•´çš„APIé…ç½®ï¼Œè‡ªåŠ¨æ‹‰å–æ¨¡å‹åˆ—è¡¨');

                        // å»¶è¿Ÿä¸€ç‚¹æ‰§è¡Œï¼Œç¡®ä¿UIå·²ç»åŠ è½½å®Œæˆ
                        setTimeout(() => {
                            fetchModels().then(() => {
                                // æ‹‰å–å®Œæˆåï¼Œå¦‚æœæœ‰ä¿å­˜çš„æ¨¡å‹ï¼Œé€‰ä¸­å®ƒ
                                if (settings.model) {
                                    const modelSelect = document.getElementById('model-select');
                                    if (modelSelect) {
                                        // å¦‚æœæ¨¡å‹ä¸åœ¨é€‰é¡¹ä¸­ï¼Œæ·»åŠ å®ƒ
                                        const existingOption = Array.from(modelSelect.options).find(option => option.value === settings.model);
                                        if (!existingOption) {
                                            const newOption = new Option(settings.model, settings.model);
                                            modelSelect.appendChild(newOption);
                                        }
                                        modelSelect.value = settings.model;
                                        console.log('ğŸ”§ [APIè®¾ç½®] å·²è‡ªåŠ¨é€‰ä¸­ä¿å­˜çš„æ¨¡å‹:', settings.model);
                                    }
                                }
                            }).catch(error => {
                                console.log('ğŸ”§ [APIè®¾ç½®] è‡ªåŠ¨æ‹‰å–æ¨¡å‹å¤±è´¥ï¼Œä½†ä¼šä¿ç•™å·²ä¿å­˜çš„æ¨¡å‹é€‰é¡¹');
                                // å³ä½¿æ‹‰å–å¤±è´¥ï¼Œä¹Ÿè¦æ¢å¤ä¿å­˜çš„æ¨¡å‹é€‰é¡¹
                                if (settings.model) {
                                    const modelSelect = document.getElementById('model-select');
                                    if (modelSelect) {
                                        const existingOption = Array.from(modelSelect.options).find(option => option.value === settings.model);
                                        if (!existingOption) {
                                            const newOption = new Option(settings.model, settings.model);
                                            modelSelect.appendChild(newOption);
                                        }
                                        modelSelect.value = settings.model;
                                        console.log('ğŸ”§ [APIè®¾ç½®] å·²æ¢å¤ä¿å­˜çš„æ¨¡å‹é€‰é¡¹:', settings.model);
                                    }
                                }
                            });
                        }, 500);
                    } else {
                        // æ²¡æœ‰å®Œæ•´çš„APIé…ç½®æ—¶ï¼Œä»ç„¶è¦æ¢å¤ä¿å­˜çš„æ¨¡å‹é€‰é¡¹
                        if (settings.model) {
                            const modelSelect = document.getElementById('model-select');
                            if (modelSelect) {
                                const existingOption = Array.from(modelSelect.options).find(option => option.value === settings.model);
                                if (!existingOption) {
                                    const newOption = new Option(settings.model, settings.model);
                                    modelSelect.appendChild(newOption);
                                }
                                modelSelect.value = settings.model;
                                console.log('ğŸ”§ [APIè®¾ç½®] å·²æ¢å¤ä¿å­˜çš„æ¨¡å‹é€‰é¡¹ï¼ˆæ— è‡ªåŠ¨æ‹‰å–ï¼‰:', settings.model);
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('åŠ è½½APIè®¾ç½®å¤±è´¥:', error);
            }
        }
        
        // ç”µæ± ç®¡ç†åŠŸèƒ½
        async function initBatteryManager() {
            // é¦–å…ˆè®¾ç½®é»˜è®¤æ˜¾ç¤ºä¸º á°”á©š
            const allBatteryTexts = document.querySelectorAll('.battery-text');

            allBatteryTexts.forEach((element, index) => {
                element.textContent = 'á°”á©š';
            });

            if ('getBattery' in navigator) {
                try {
                    const battery = await navigator.getBattery();
                    updateBatteryDisplay(battery);

                    battery.addEventListener('levelchange', () => updateBatteryDisplay(battery));
                    battery.addEventListener('chargingchange', () => updateBatteryDisplay(battery));
                } catch (err) {
                    console.error("æ— æ³•è·å–ç”µæ± ä¿¡æ¯:", err);
                    // ä¿æŒé»˜è®¤æ˜¾ç¤º á°”á©š
                    allBatteryTexts.forEach(element => {
                        element.textContent = 'á°”á©š';
                    });
                }
            } else {
                // ä¿æŒé»˜è®¤æ˜¾ç¤º á°”á©š
                allBatteryTexts.forEach(element => {
                    element.textContent = 'á°”á©š';
                });
            }
        }
        
        function updateBatteryDisplay(battery) {
            const level = Math.floor(battery.level * 100);
            const isCharging = battery.charging;
            
            // æ›´æ–°ä¸»çŠ¶æ€æ ç”µæ± 
            const batteryContainer = document.getElementById('status-bar-battery');

            if (batteryContainer) {
                const batteryLevelEl = batteryContainer.querySelector('.battery-level');
                const batteryTextEl = batteryContainer.querySelector('.battery-text');

                if (batteryLevelEl && batteryTextEl) {
                    batteryLevelEl.style.width = `${level}%`;
                    batteryTextEl.textContent = `${level}%`;
                    
                    if (isCharging) {
                        batteryContainer.classList.add('charging');
                    } else {
                        batteryContainer.classList.remove('charging');
                    }
                }
            }
            
            // æ›´æ–°åº”ç”¨å†…çŠ¶æ€æ ç”µæ± 
            const appBatteryContainers = document.querySelectorAll('.app-battery-container');
            const appBatteryTexts = document.querySelectorAll('.app-battery-container .battery-text');
            const appBatteryLevels = document.querySelectorAll('.app-battery-level');
            
            // åº”ç”¨å†…ä¹Ÿæ˜¾ç¤ºçœŸå®ç”µé‡
            appBatteryTexts.forEach(element => {
                element.textContent = `${level}%`;
            });
            
            appBatteryLevels.forEach(element => {
                element.style.width = `${level}%`;
            });
            
            // åŒæ­¥åº”ç”¨å†…ç”µæ± å……ç”µçŠ¶æ€
            appBatteryContainers.forEach(container => {
                if (isCharging) {
                    container.classList.add('charging');
                } else {
                    container.classList.remove('charging');
                }
            });
        }
        
        // æ‰‹åŠ¨æµ‹è¯•ç”µæ± æ˜¾ç¤ºåŠŸèƒ½ - æ‚¨å¯ä»¥åœ¨æµè§ˆå™¨æ§åˆ¶å°ä¸­è°ƒç”¨è¿™ä¸ªå‡½æ•°
        function testBatteryDisplay() {
            // æ£€æŸ¥ç”µæ± æ–‡æœ¬å…ƒç´ 
            const allBatteryTexts = document.querySelectorAll('.battery-text');

            // æ£€æŸ¥ä¸»å±å¹•ç”µæ± å®¹å™¨
            const mainBattery = document.getElementById('status-bar-battery');

            if (mainBattery) {
                const batteryText = mainBattery.querySelector('.battery-text');
            }

            // æµ‹è¯•è®¾ç½®ä¸ºç™¾åˆ†æ¯”
            allBatteryTexts.forEach((element, index) => {
                element.textContent = '77%';
            });

            // 3ç§’åæ¢å¤ä¸ºçˆ±å¿ƒ
            setTimeout(() => {
                allBatteryTexts.forEach((element, index) => {
                    element.textContent = 'á°”á©š';
                });
            }, 3000);
        }
        
        // ä¸»é¢˜åˆ‡æ¢åŠŸèƒ½
        function changeTheme(themeName) {
            const body = document.body;
            
            // ç§»é™¤ä¹‹å‰çš„ä¸»é¢˜
            body.removeAttribute('data-theme');
            
            // åº”ç”¨æ–°ä¸»é¢˜
            if (themeName !== 'default') {
                body.setAttribute('data-theme', themeName);
            }
            
            // ä¿å­˜ä¸»é¢˜è®¾ç½®
            localStorage.setItem('selectedTheme', themeName);
            
            // ç»™ç”¨æˆ·åé¦ˆ
            const themeNames = {
                'default': 'ç®€çº¦é£æ ¼',
                'cute': 'å¯çˆ±é£æ ¼',
                'nature': 'è‡ªç„¶é£æ ¼', 
                'tech': 'ç§‘æŠ€é£æ ¼',
                'dream': 'æ¢¦å¹»é£æ ¼'
            };
            
            // æ˜¾ç¤ºToastæç¤º
            showToast(`å·²åˆ‡æ¢åˆ° ${themeNames[themeName]} ä¸»é¢˜ï¼`, 'success');
        }
        
        // åŠ è½½ä¿å­˜çš„ä¸»é¢˜
        function loadSavedTheme() {
            const savedTheme = localStorage.getItem('selectedTheme');
            if (savedTheme && savedTheme !== 'default') {
                document.body.setAttribute('data-theme', savedTheme);
            }
        }
        
        // ä¸–ç•Œä¹¦ç›¸å…³åŠŸèƒ½
        let worldbooks = [];
        let editingWorldbook = null;
        
        // åŠ è½½ä¸–ç•Œä¹¦æ•°æ® - ä½¿ç”¨IndexedDBï¼ˆåŒ…å«æ•°æ®è¿ç§»ï¼‰
        async function loadWorldbooks() {
            try {
                // å…ˆä»IndexedDBåŠ è½½
                const savedWorldbooks = await db.worldbooks.toArray();
                
                if (savedWorldbooks.length === 0) {
                    // IndexedDBä¸­æ²¡æœ‰æ•°æ®ï¼Œå°è¯•ä»localStorageè¿ç§»
                    const localStorageData = localStorage.getItem('worldbooks');
                    if (localStorageData) {
                        console.log('æ£€æµ‹åˆ°localStorageä¸­çš„ä¸–ç•Œä¹¦æ•°æ®ï¼Œå¼€å§‹è¿ç§»...');
                        const localWorldbooks = JSON.parse(localStorageData);
                        
                        if (localWorldbooks.length > 0) {
                            // ç¡®ä¿æ¯ä¸ªä¸–ç•Œä¹¦éƒ½æœ‰idå­—æ®µ
                            const migrationData = localWorldbooks.map(wb => ({
                                id: wb.id || Date.now().toString() + Math.random(),
                                title: wb.title,
                                content: wb.content,
                                createdAt: wb.createdAt || new Date().toISOString(),
                                updatedAt: wb.updatedAt || new Date().toISOString()
                            }));
                            
                            // è¿ç§»åˆ°IndexedDB
                            await db.worldbooks.bulkAdd(migrationData);
                            worldbooks = migrationData;
                            console.log('ä¸–ç•Œä¹¦æ•°æ®è¿ç§»å®Œæˆ:', worldbooks);
                        } else {
                            worldbooks = [];
                        }
                    } else {
                        worldbooks = [];
                    }
                } else {
                    // IndexedDBä¸­æœ‰æ•°æ®ï¼Œç›´æ¥ä½¿ç”¨
                    worldbooks = savedWorldbooks;
                    console.log('ä»IndexedDBåŠ è½½ä¸–ç•Œä¹¦æ•°æ®:', worldbooks);
                }
                
                // ğŸ”¥ æ£€æŸ¥å¹¶è¿ç§»æ—§çš„è§’è‰²ä¸–ç•Œä¹¦æ•°æ®
                await migrateOldCharacterWorldbooks();
                
            } catch (error) {
                console.error('åŠ è½½ä¸–ç•Œä¹¦å¤±è´¥:', error);
                // å¦‚æœIndexedDBå¤±è´¥ï¼Œå›é€€åˆ°localStorage
                const localStorageData = localStorage.getItem('worldbooks');
                if (localStorageData) {
                    try {
                        worldbooks = JSON.parse(localStorageData);
                } catch (e) {
                        worldbooks = [];
                    }
                } else {
                    worldbooks = [];
                }
                
                // ä¹Ÿä¸ºlocalStorageæ•°æ®è¿›è¡Œè¿ç§»
                await migrateOldCharacterWorldbooks();
            }
            renderWorldbookList();
        }

        // è¿ç§»æ—§çš„è§’è‰²ä¸–ç•Œä¹¦æ•°æ®
        async function migrateOldCharacterWorldbooks() {
            let migrationCount = 0;
            let needsSave = false;

            worldbooks.forEach(worldbook => {
                // æ£€æŸ¥æ˜¯å¦æ˜¯æ—§çš„è§’è‰²ä¸–ç•Œä¹¦ï¼ˆé€šè¿‡åç§°æ¨¡å¼è¯†åˆ«ï¼‰
                if (!worldbook.source && !worldbook.isGlobal && worldbook.name && worldbook.name.includes('[') && worldbook.name.includes(']')) {
                    // è§£æè§’è‰²åç§°
                    const match = worldbook.name.match(/^\[(.+?)\]/);
                    if (match) {
                        const characterName = match[1];
                        console.log(`ğŸ”„ è¿ç§»æ—§çš„è§’è‰²ä¸–ç•Œä¹¦: ${worldbook.name} -> åˆ†ç±»: ${characterName}`);
                        
                        worldbook.source = 'character_card';
                        worldbook.category = characterName;
                        migrationCount++;
                        needsSave = true;
                    }
                }
                
                // æ£€æŸ¥æ˜¯å¦ç¼ºå°‘å¿…è¦çš„å­—æ®µå¹¶ä¿®å¤
                if (!worldbook.id) {
                    worldbook.id = Date.now().toString() + Math.random();
                    needsSave = true;
                }
                if (!worldbook.title && worldbook.name) {
                    worldbook.title = worldbook.name;
                    needsSave = true;
                }
            });

            if (needsSave) {
                console.log(`ğŸ“¦ è¿ç§»å®Œæˆï¼Œå…±è¿ç§» ${migrationCount} ä¸ªè§’è‰²ä¸–ç•Œä¹¦`);
                await saveWorldbooks();
                if (migrationCount > 0) {
                    showToast(`å·²è‡ªåŠ¨è¿ç§»${migrationCount}ä¸ªè§’è‰²ä¸–ç•Œä¹¦åˆ°æ–°åˆ†ç±»`, 'success');
                }
            }
        }
        
        // ä¿å­˜ä¸–ç•Œä¹¦æ•°æ® - ä½¿ç”¨IndexedDB
        async function saveWorldbooks() {
            try {
                console.log('ä¿å­˜ä¸–ç•Œä¹¦æ•°æ®åˆ°IndexedDB:', worldbooks);
                
                // ğŸ”¥ã€å®‰å…¨ä¿®å¤ã€‘ä½¿ç”¨äº‹åŠ¡ç¡®ä¿åŸå­æ“ä½œï¼Œé˜²æ­¢æ•°æ®ä¸¢å¤±
                if (worldbooks.length === 0) {
                    console.warn('âš ï¸ ä¸–ç•Œä¹¦æ•°æ®ä¸ºç©ºï¼Œè·³è¿‡ä¿å­˜æ“ä½œ');
                    return;
                }

                // ä½¿ç”¨äº‹åŠ¡è¿›è¡ŒåŸå­æ“ä½œ
                await db.transaction('rw', db.worldbooks, async () => {
                    await db.worldbooks.clear();
                    await db.worldbooks.bulkAdd(worldbooks);
                });

                console.log(`âœ… å®‰å…¨ä¿å­˜äº† ${worldbooks.length} ä¸ªä¸–ç•Œä¹¦åˆ°æ•°æ®åº“`);
                
                console.log('ä¸–ç•Œä¹¦æ•°æ®ä¿å­˜æˆåŠŸ');
            } catch (error) {
                console.error('ä¿å­˜ä¸–ç•Œä¹¦æ—¶å‘ç”Ÿé”™è¯¯:', error);
                // å¦‚æœIndexedDBå¤±è´¥ï¼Œå›é€€åˆ°localStorage
            localStorage.setItem('worldbooks', JSON.stringify(worldbooks));
            }
        }
        
        function showWorldbookForm(isGlobal, characterCategory = null) {
    // æ ¹æ®ä¼ å…¥çš„ç±»å‹æ¥å†³å®šè¡¨å•æ ‡é¢˜
    let title;
    if (isGlobal) {
        title = 'æ–°å»ºå…¨å±€è®¾å®š';
    } else if (characterCategory) {
        title = `æ–°å»º${characterCategory}çš„ä¸–ç•Œä¹¦`;
    } else {
        title = 'æ–°å»ºå±€éƒ¨è®¾å®š';
    }
    document.getElementById('worldbook-form-title').textContent = title;

    editingWorldbook = null; // æ¸…é™¤ç¼–è¾‘çŠ¶æ€
            document.getElementById('worldbook-title').value = '';
            document.getElementById('worldbook-content').value = '';

    // å°†åˆ›å»ºç±»å‹æš‚å­˜èµ·æ¥ï¼Œä»¥ä¾¿ä¿å­˜æ—¶ä½¿ç”¨
    window.newWorldbookIsGlobal = isGlobal;
    window.newWorldbookCharacterCategory = characterCategory;

            showApp('worldbook-form-screen');
        }
        
        function hideWorldbookForm() {
            hideApp('worldbook-form-screen');
            // ç¡®ä¿è¿”å›åˆ°ä¸–ç•Œä¹¦åº”ç”¨ï¼Œè€Œä¸æ˜¯ä¸»å±å¹•
            showApp('worldbook-screen');
        }
        
        async function saveWorldbook() {
            const title = document.getElementById('worldbook-title').value.trim();
            const content = document.getElementById('worldbook-content').value.trim();
            
    if (!title || !content) {
        alert('è¯·è¾“å…¥æ ‡é¢˜å’Œå†…å®¹');
                return;
            }
            
    let isGlobal;
    if (editingWorldbook) {
        // å¦‚æœæ˜¯ç¼–è¾‘æ¨¡å¼ï¼Œä¿æŒå…¶åŸæœ‰çš„ç±»å‹ä¸å˜
        isGlobal = editingWorldbook.isGlobal;
    } else {
        // å¦‚æœæ˜¯æ–°å»ºæ¨¡å¼ï¼Œè¯»å–æˆ‘ä»¬æš‚å­˜çš„ç±»å‹
        isGlobal = window.newWorldbookIsGlobal;
            }
            
            const worldbook = {
                id: editingWorldbook ? editingWorldbook.id : Date.now().toString(),
                title: title,
                content: content,
        isGlobal: isGlobal, // æ ¹æ®æ­£ç¡®çš„çŠ¶æ€è®¾ç½®
                createdAt: editingWorldbook ? editingWorldbook.createdAt : new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };

            // å¦‚æœæ˜¯è§’è‰²åˆ†ç±»çš„ä¸–ç•Œä¹¦ï¼Œæ·»åŠ åˆ†ç±»ä¿¡æ¯
            if (!isGlobal && window.newWorldbookCharacterCategory) {
                worldbook.category = window.newWorldbookCharacterCategory;
                worldbook.source = 'character_card';
            }
            
            if (editingWorldbook) {
                const index = worldbooks.findIndex(w => w.id === editingWorldbook.id);
        if (index !== -1) worldbooks[index] = worldbook;
            } else {
                worldbooks.push(worldbook);
            }
            
            await saveWorldbooks();
            renderWorldbookList();
            showToast(editingWorldbook ? 'ä¸–ç•Œä¹¦å·²æ›´æ–°ï¼' : 'ä¸–ç•Œä¹¦å·²åˆ›å»ºï¼', 'success');
            hideWorldbookForm();
        }
// --- æ–°å¢å‡½æ•° ---
async function toggleGlobalWorldbook(bookId, isEnabled) {
    // ç¡®ä¿window.activeGlobalWorldbookså­˜åœ¨
    if (!window.activeGlobalWorldbooks) {
        window.activeGlobalWorldbooks = [];
    }
    
    if (isEnabled) {
        // å¦‚æœå¼€å¯ï¼Œæ·»åŠ åˆ°æ¿€æ´»åˆ—è¡¨ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
        if (!window.activeGlobalWorldbooks.includes(bookId)) {
            window.activeGlobalWorldbooks.push(bookId);
        }
    } else {
        // å¦‚æœå…³é—­ï¼Œä»æ¿€æ´»åˆ—è¡¨ä¸­ç§»é™¤
        window.activeGlobalWorldbooks = window.activeGlobalWorldbooks.filter(id => id !== bookId);
    }
    
    // ä¿å­˜æ¿€æ´»çŠ¶æ€åˆ°æ•°æ®åº“çš„ globalSettings è¡¨
    try {
        await db.globalSettings.put({
            id: 'main',
            activeGlobalWorldbooks: window.activeGlobalWorldbooks
        });
        console.log('å…¨å±€ä¸–ç•Œä¹¦è®¾ç½®å·²ä¿å­˜:', window.activeGlobalWorldbooks);
        showToast('å…¨å±€è®¾å®šå·²æ›´æ–°', 'success');
    } catch (error) {
        console.error("ä¿å­˜å…¨å±€ä¸–ç•Œä¹¦è®¾ç½®å¤±è´¥:", error);
        showToast('è®¾ç½®ä¿å­˜å¤±è´¥', 'error');
    }
        }
        
        function editWorldbook(id) {
            const worldbook = worldbooks.find(w => w.id === id);
            if (worldbook) {
                editingWorldbook = worldbook;
        // ç¼–è¾‘æ—¶ä¸æ˜¾ç¤ºâ€œæ–°å»ºâ€ï¼Œè€Œæ˜¯â€œç¼–è¾‘â€
        let title;
        if (worldbook.isGlobal) {
            title = 'ç¼–è¾‘å…¨å±€è®¾å®š';
        } else if (worldbook.source === 'character_card' && worldbook.category) {
            title = `ç¼–è¾‘${worldbook.category}çš„ä¸–ç•Œä¹¦`;
        } else {
            title = 'ç¼–è¾‘å±€éƒ¨è®¾å®š';
        }
        document.getElementById('worldbook-form-title').textContent = title;
                document.getElementById('worldbook-title').value = worldbook.title || worldbook.name;
                document.getElementById('worldbook-content').value = worldbook.content;
                showApp('worldbook-form-screen');
            }
        }
        
        async function deleteWorldbook(id) {
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªä¸–ç•Œä¹¦å—ï¼Ÿ')) {
                console.log('ğŸ—‘ï¸ åˆ é™¤ä¸–ç•Œä¹¦:', id);
                console.log('åˆ é™¤å‰çš„ä¸–ç•Œä¹¦åˆ—è¡¨:', worldbooks.map(w => ({id: w.id, name: w.name || w.title})));
                
                // ä»å†…å­˜æ•°ç»„ä¸­åˆ é™¤
                const initialLength = worldbooks.length;
                worldbooks = worldbooks.filter(w => w.id !== id);
                const finalLength = worldbooks.length;
                
                console.log(`åˆ é™¤æ“ä½œ: ${initialLength} -> ${finalLength}, åˆ é™¤äº† ${initialLength - finalLength} ä¸ªé¡¹ç›®`);
                
                if (initialLength === finalLength) {
                    console.warn('âš ï¸ åˆ é™¤å¤±è´¥ï¼šæœªæ‰¾åˆ°è¦åˆ é™¤çš„ä¸–ç•Œä¹¦');
                    showToast('åˆ é™¤å¤±è´¥ï¼šæœªæ‰¾åˆ°æŒ‡å®šçš„ä¸–ç•Œä¹¦', 'error');
                    return;
                }
                
                // ä¿å­˜åˆ°æ•°æ®åº“
                try {
                    await saveWorldbooks();
                    console.log('âœ… ä¸–ç•Œä¹¦åˆ é™¤æˆåŠŸ');
                    showToast('ä¸–ç•Œä¹¦å·²åˆ é™¤', 'success');
                } catch (error) {
                    console.error('âŒ åˆ é™¤ä¸–ç•Œä¹¦æ—¶æ•°æ®åº“ä¿å­˜å¤±è´¥:', error);
                    showToast('åˆ é™¤å¤±è´¥ï¼šæ•°æ®åº“ä¿å­˜é”™è¯¯', 'error');
                }
                
                // é‡æ–°æ¸²æŸ“åˆ—è¡¨
                renderWorldbookList();
            }
        }
        
// ç”¨è¿™æ®µæ–°ä»£ç ï¼Œå®Œæ•´æ›¿æ¢æ‰æ—§çš„ renderWorldbookList å‡½æ•°
        function renderWorldbookList() {
    const globalContainer = document.getElementById('global-worldbooks-content');
    const localContainer = document.getElementById('local-worldbooks-content');
    const characterContainer = document.getElementById('character-worldbooks-content');
    if (!globalContainer || !localContainer || !characterContainer) return;

    const globalBooks = worldbooks.filter(w => w.isGlobal);
    const localBooks = worldbooks.filter(w => !w.isGlobal && (!w.source || w.source !== 'character_card'));
    
    // è·å–å½“å‰é€‰æ‹©çš„è§’è‰²åˆ†ç±»çš„ä¸–ç•Œä¹¦
    let characterBooks = [];
    if (currentCharacterCategory) {
        characterBooks = worldbooks.filter(w => 
            !w.isGlobal && 
            w.source === 'character_card' && 
            w.category === currentCharacterCategory
        );
    }

    let globalHtml = '';
    let localHtml = '';
    let characterHtml = '';

    // --- æ¸²æŸ“å…¨å±€ä¸–ç•Œä¹¦ ---
    globalHtml += `<div class="worldbook-section">`;
    if (globalBooks.length > 0) {
        globalBooks.forEach(book => {
            // ç¡®ä¿ä½¿ç”¨window.activeGlobalWorldbookså¹¶æ£€æŸ¥å…¶æ˜¯å¦ä¸ºæ•°ç»„
            const isChecked = Array.isArray(window.activeGlobalWorldbooks) && window.activeGlobalWorldbooks.includes(book.id) ? 'checked' : '';
            globalHtml += `
                <div class="setting-item" onclick="editWorldbook('${book.id}')">
                    <div class="setting-left">
                        <div class="setting-label">${book.title || book.name}</div>
                        <div class="setting-desc">${truncateText(book.content, 60)}</div>
                    </div>
                    <div class="setting-right">
                        <label class="toggle-switch" onclick="event.stopPropagation()">
                            <input type="checkbox" onchange="toggleGlobalWorldbook('${book.id}', this.checked)" ${isChecked}>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
            `;
        });
    } else {
        globalHtml += '<div class="empty-message">æš‚æ— å…¨å±€è®¾å®š</div>';
    }
    globalHtml += '</div>';

    // --- æ¸²æŸ“å±€éƒ¨ä¸–ç•Œä¹¦ ---
    localHtml += `<div class="worldbook-section">`;
    if (localBooks.length > 0) {
        localBooks.forEach(book => {
            const dateObj = new Date(book.updatedAt || book.createdAt || Date.now());
            const date = isNaN(dateObj.getTime()) ? 'æœªçŸ¥æ—¥æœŸ' : dateObj.toLocaleDateString();
            const preview = truncateText(book.content, 60);
            localHtml += `
                <div class="worldbook-item" onclick="editWorldbook('${book.id}')">
                    <div class="worldbook-header">
                        <div class="worldbook-content-flex">
                            <div class="worldbook-title">${book.title || book.name}</div>
                            <div class="worldbook-desc-text">${preview}</div>
                            <div class="worldbook-date-text">æ›´æ–°äº ${date}</div>
                        </div>
                        <button onclick="event.stopPropagation(); deleteWorldbook('${book.id}')" class="delete-worldbook-btn">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `;
        });
    } else {
        localHtml += '<div class="empty-message">æš‚æ— å±€éƒ¨è®¾å®š</div>';
    }
    localHtml += '</div>';

    // --- æ¸²æŸ“è§’è‰²ä¸–ç•Œä¹¦ ---
    characterHtml += `<div class="worldbook-section">`;
    if (characterBooks.length > 0) {
        characterBooks.forEach(book => {
            const dateObj = new Date(book.updatedAt || book.createdAt || Date.now());
            const date = isNaN(dateObj.getTime()) ? 'æœªçŸ¥æ—¥æœŸ' : dateObj.toLocaleDateString();
            const preview = truncateText(book.content, 60);
            characterHtml += `
                <div class="worldbook-item" onclick="editWorldbook('${book.id}')">
                    <div class="worldbook-header">
                        <div class="worldbook-content-flex">
                            <div class="worldbook-title">${book.title || book.name}</div>
                            <div class="worldbook-desc-text">${preview}</div>
                            <div class="worldbook-date-text">æ›´æ–°äº ${date}</div>
                            <div class="worldbook-source-text">æ¥æº: è§’è‰²å¡å¯¼å…¥</div>
                        </div>
                        <button onclick="event.stopPropagation(); deleteWorldbook('${book.id}')" class="delete-worldbook-btn">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `;
        });
    } else {
        const categoryText = currentCharacterCategory ? `"${currentCharacterCategory}"` : 'è¯¥è§’è‰²';
        characterHtml += `<div class="empty-message">æš‚æ— ${categoryText}çš„ä¸–ç•Œä¹¦è®¾å®š</div>`;
    }
    characterHtml += '</div>';

    globalContainer.innerHTML = globalHtml;
    localContainer.innerHTML = localHtml;
    characterContainer.innerHTML = characterHtml;
}
function switchWorldbookTab(tabName, characterCategory = null) {
    currentWorldbookTab = tabName; // <--- æ ¸å¿ƒä¿®æ”¹ï¼šè®°å½•å½“å‰æ ‡ç­¾é¡µ
    currentCharacterCategory = characterCategory; // è®°å½•å½“å‰é€‰æ‹©çš„è§’è‰²åˆ†ç±»

    const globalContent = document.getElementById('global-worldbooks-content');
    const localContent = document.getElementById('local-worldbooks-content');
    const characterContent = document.getElementById('character-worldbooks-content');
    const tabs = document.querySelectorAll('.worldbook-tab');

    tabs.forEach(tab => {
        if (tab.getAttribute('onclick').includes(tabName)) {
            tab.classList.add('active');
        } else {
            tab.classList.remove('active');
        }
    });

    // éšè—æ‰€æœ‰å†…å®¹é¢æ¿
    globalContent.style.display = 'none';
    localContent.style.display = 'none';
    characterContent.style.display = 'none';

    if (tabName === 'global') {
        globalContent.style.display = 'block';
    } else if (tabName === 'local') {
        localContent.style.display = 'block';
    } else if (tabName === 'character') {
        if (characterCategory) {
            // ç›´æ¥æ˜¾ç¤ºæŒ‡å®šè§’è‰²çš„ä¸–ç•Œä¹¦
            characterContent.style.display = 'block';
            document.getElementById('character-tab-text').textContent = characterCategory;
        } else {
            // æ˜¾ç¤ºè§’è‰²åˆ†ç±»é€‰æ‹©å™¨
            showCategorySelector();
            return;
        }
    }

    renderWorldbookList();
}
function onWorldbookAddClick() {
    if (currentWorldbookTab === 'global') {
        showWorldbookForm(true); // åˆ›å»ºå…¨å±€è®¾å®š
    } else if (currentWorldbookTab === 'local') {
        showWorldbookForm(false); // åˆ›å»ºå±€éƒ¨è®¾å®š
    } else if (currentWorldbookTab === 'character') {
        // ä¸ºå½“å‰è§’è‰²åˆ†ç±»åˆ›å»ºä¸–ç•Œä¹¦
        showWorldbookForm(false, currentCharacterCategory);
    }
        }

        // æ˜¾ç¤ºè§’è‰²åˆ†ç±»é€‰æ‹©å™¨
        function showCategorySelector() {
            // è·å–æ‰€æœ‰è§’è‰²ä¸–ç•Œä¹¦çš„åˆ†ç±»
            const characterWorldBooks = worldbooks.filter(w => w.source === 'character_card');
            const categories = [...new Set(characterWorldBooks.map(w => w.category))].filter(Boolean);
            
            const categoryOptions = document.getElementById('category-options');
            const selector = document.getElementById('worldbook-category-selector');
            
            if (categories.length === 0) {
                categoryOptions.innerHTML = '<div class="empty-category-message">æš‚æ— è§’è‰²ä¸–ç•Œä¹¦<br/>è¯·å…ˆå¯¼å…¥åŒ…å«ä¸–ç•Œä¹¦çš„è§’è‰²å¡</div>';
            } else {
                categoryOptions.innerHTML = categories.map(category => {
                    const count = characterWorldBooks.filter(w => w.category === category).length;
                    return `
                        <div class="category-option" onclick="selectCategory('${category}')">
                            <div class="category-name">${category}</div>
                            <div class="category-count">${count}ä¸ªè®¾å®š</div>
                        </div>
                    `;
                }).join('');
            }
            
            selector.style.display = 'flex';
        }

        // éšè—è§’è‰²åˆ†ç±»é€‰æ‹©å™¨
        function hideCategorySelector() {
            document.getElementById('worldbook-category-selector').style.display = 'none';
            // å›åˆ°ä¹‹å‰çš„æ ‡ç­¾é¡µ
            if (currentWorldbookTab === 'character') {
                currentWorldbookTab = 'local';
                switchWorldbookTab('local');
            }
        }

        // é€‰æ‹©è§’è‰²åˆ†ç±»
        function selectCategory(category) {
            hideCategorySelector();
            switchWorldbookTab('character', category);
        }

        // æ‰‹åŠ¨è§¦å‘æ•°æ®è¿ç§»ï¼ˆè°ƒè¯•ç”¨ï¼‰
        async function manualMigrateWorldbooks() {
            console.log('ğŸ”§ æ‰‹åŠ¨è§¦å‘ä¸–ç•Œä¹¦æ•°æ®è¿ç§»...');
            await migrateOldCharacterWorldbooks();
            renderWorldbookList();
            console.log('ğŸ”§ æ‰‹åŠ¨è¿ç§»å®Œæˆ');
        }

        // è°ƒè¯•ï¼šæŸ¥çœ‹æ‰€æœ‰ä¸–ç•Œä¹¦æ•°æ®
        function debugWorldbooks() {
            console.log('ğŸ“‹ å½“å‰æ‰€æœ‰ä¸–ç•Œä¹¦æ•°æ®:');
            worldbooks.forEach((wb, index) => {
                console.log(`${index + 1}. ID: "${wb.id}", åç§°: "${wb.name || wb.title}", æ¥æº: "${wb.source}", åˆ†ç±»: "${wb.category}", å…¨å±€: ${wb.isGlobal}`);
            });
            console.log(`æ€»è®¡: ${worldbooks.length} ä¸ªä¸–ç•Œä¹¦`);
            return worldbooks;
        }

        // å¼ºåˆ¶åˆ é™¤æ‰€æœ‰è§’è‰²ä¸–ç•Œä¹¦
        async function forceDeleteCharacterWorldbooks() {
            console.log('ğŸš¨ å¼ºåˆ¶åˆ é™¤æ‰€æœ‰è§’è‰²ä¸–ç•Œä¹¦...');
            const beforeCount = worldbooks.length;
            
            // åˆ é™¤æ‰€æœ‰åŒ…å« [è§’è‰²å] æ ¼å¼çš„ä¸–ç•Œä¹¦
            worldbooks = worldbooks.filter(wb => {
                const isCharacterBook = (wb.name && wb.name.includes('[') && wb.name.includes(']')) || 
                                       (wb.title && wb.title.includes('[') && wb.title.includes(']')) ||
                                       (wb.source === 'character_card');
                return !isCharacterBook;
            });
            
            const afterCount = worldbooks.length;
            const deletedCount = beforeCount - afterCount;
            
            console.log(`åˆ é™¤äº† ${deletedCount} ä¸ªè§’è‰²ä¸–ç•Œä¹¦`);
            
            // ä¿å­˜åˆ°æ•°æ®åº“
            await saveWorldbooks();
            renderWorldbookList();
            showToast(`å¼ºåˆ¶åˆ é™¤äº†${deletedCount}ä¸ªè§’è‰²ä¸–ç•Œä¹¦`, 'success');
            
            return deletedCount;
        }

        // æ¸…ç©ºæ‰€æœ‰ä¸–ç•Œä¹¦ï¼ˆç»ˆææ–¹æ¡ˆï¼‰
        async function clearAllWorldbooks() {
            if (confirm('âš ï¸ ç¡®å®šè¦åˆ é™¤æ‰€æœ‰ä¸–ç•Œä¹¦å—ï¼Ÿè¿™ä¸ªæ“ä½œä¸å¯æ’¤é”€ï¼')) {
                console.log('ğŸ’£ æ¸…ç©ºæ‰€æœ‰ä¸–ç•Œä¹¦...');
                const count = worldbooks.length;
                worldbooks = [];
                await saveWorldbooks();
                renderWorldbookList();
                showToast(`å·²æ¸…ç©ºæ‰€æœ‰${count}ä¸ªä¸–ç•Œä¹¦`, 'success');
                console.log('âœ… æ‰€æœ‰ä¸–ç•Œä¹¦å·²æ¸…ç©º');
            }
        }

        // ä¿®å¤ä¸–ç•Œä¹¦IDé—®é¢˜
        async function fixWorldbookIds() {
            console.log('ğŸ”§ ä¿®å¤ä¸–ç•Œä¹¦IDé—®é¢˜...');
            let fixedCount = 0;
            
            worldbooks.forEach((wb, index) => {
                if (!wb.id || typeof wb.id !== 'string') {
                    wb.id = `fixed_${Date.now()}_${index}`;
                    fixedCount++;
                    console.log(`ä¿®å¤äº†ä¸–ç•Œä¹¦ "${wb.name || wb.title}" çš„ID`);
                }
            });
            
            if (fixedCount > 0) {
                await saveWorldbooks();
                renderWorldbookList();
                showToast(`ä¿®å¤äº†${fixedCount}ä¸ªä¸–ç•Œä¹¦çš„ID`, 'success');
            } else {
                console.log('æ‰€æœ‰ä¸–ç•Œä¹¦IDéƒ½æ­£å¸¸');
            }
            
            return fixedCount;
        }
        







        // ================== éŸ³ä¹æ’­æ”¾å™¨åŠŸèƒ½ ==================

        // LRCæ­Œè¯è§£æå‡½æ•°
        function parseLRC(lrcContent) {
            if (!lrcContent) return { lyrics: ['â™ª æš‚æ— æ­Œè¯'], timings: [] };

            const lines = lrcContent.split('\n');
            const lyrics = [];
            const timings = [];
            const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/g;

            for (const line of lines) {
                let match;
                const matches = [];

                // æ‰¾åˆ°æ‰€æœ‰æ—¶é—´æ ‡ç­¾
                while ((match = timeRegex.exec(line)) !== null) {
                    const minutes = parseInt(match[1]);
                    const seconds = parseInt(match[2]);
                    const milliseconds = parseInt(match[3].padEnd(3, '0'));
                    const totalSeconds = minutes * 60 + seconds + milliseconds / 1000;
                    matches.push(totalSeconds);
                }

                const text = line.replace(/\[\d{2}:\d{2}\.\d{2,3}\]/g, '').trim();

                if (text && !text.startsWith('[')) {
                    // ä¸ºæ¯ä¸ªæ—¶é—´æ ‡ç­¾åˆ›å»ºä¸€ä¸ªæ­Œè¯æ¡ç›®
                    if (matches.length > 0) {
                        for (const time of matches) {
                            lyrics.push(text);
                            timings.push(time);
                        }
                    } else {
                        lyrics.push(text);
                        timings.push(null); // æ²¡æœ‰æ—¶é—´æ ‡ç­¾
                    }
                }
            }

            // å¦‚æœæœ‰æ—¶é—´ä¿¡æ¯ï¼ŒæŒ‰æ—¶é—´æ’åº
            if (timings.some(t => t !== null)) {
                const combined = lyrics.map((lyric, index) => ({
                    text: lyric,
                    time: timings[index]
                })).filter(item => item.time !== null).sort((a, b) => a.time - b.time);

                return {
                    lyrics: combined.map(item => item.text),
                    timings: combined.map(item => item.time),
                    hasTimings: true
                };
            }

            return {
                lyrics: lyrics.length > 0 ? lyrics : ['â™ª æš‚æ— æ­Œè¯'],
                timings: [],
                hasTimings: false
            };
        }

        // ç½‘æ˜“äº‘éŸ³ä¹binæ ¼å¼æ­Œè¯è§£æå‡½æ•°
        function parseNeteaseBin(binData) {
            try {
                const uint8Array = new Uint8Array(binData);

                // ç½‘æ˜“äº‘éŸ³ä¹binæ ¼å¼è§£æ
                // è·³è¿‡æ–‡ä»¶å¤´éƒ¨åˆ†ï¼ˆé€šå¸¸å‰å‡ ä¸ªå­—èŠ‚æ˜¯æ ‡è¯†ç¬¦ï¼‰
                let offset = 0;

                // æŸ¥æ‰¾å¯èƒ½çš„æ–‡æœ¬å¼€å§‹ä½ç½®
                while (offset < uint8Array.length - 4) {
                    // å¯»æ‰¾å¯èƒ½çš„JSONå¼€å§‹æ ‡è®° '{'
                    if (uint8Array[offset] === 0x7B ||
                        (uint8Array[offset] ^ 0x64) === 0x7B ||
                        (uint8Array[offset] ^ 0x4E) === 0x7B) {
                        break;
                    }
                    offset++;
                }

                // å°è¯•å¤šç§è§£å¯†æ–¹å¼
                const decryptMethods = [
                    // æ–¹æ³•1: ç›´æ¥è¯»å–
                    () => new TextDecoder('utf-8').decode(uint8Array.slice(offset)),
                    // æ–¹æ³•2: XOR 0x64
                    () => {
                        let text = '';
                        for (let i = offset; i < uint8Array.length; i++) {
                            text += String.fromCharCode(uint8Array[i] ^ 0x64);
                        }
                        return text;
                    },
                    // æ–¹æ³•3: XOR 0x4E (å¦ä¸€ç§å¸¸è§çš„å¯†é’¥)
                    () => {
                        let text = '';
                        for (let i = offset; i < uint8Array.length; i++) {
                            text += String.fromCharCode(uint8Array[i] ^ 0x4E);
                        }
                        return text;
                    }
                ];

                for (const method of decryptMethods) {
                    try {
                        const text = method();

                        // å°è¯•è§£æä¸ºJSON
                        try {
                            const jsonData = JSON.parse(text);
                            if (jsonData.lyric) {
                                return parseLRC(jsonData.lyric);
                            }
                            if (jsonData.lrc && jsonData.lrc.lyric) {
                                return parseLRC(jsonData.lrc.lyric);
                            }
                        } catch (e) {
                            // å¦‚æœä¸æ˜¯JSONï¼Œæ£€æŸ¥æ˜¯å¦æ˜¯ç›´æ¥çš„LRCæ ¼å¼
                            if (text.includes('[') && text.includes(']')) {
                                return parseLRC(text);
                            }
                        }
                    } catch (e) {
                        continue; // å°è¯•ä¸‹ä¸€ç§æ–¹æ³•
                    }
                }

                return { lyrics: ['â™ª binæ­Œè¯è§£æå¤±è´¥', 'â™ª è¯·å°è¯•ä½¿ç”¨LRCæ ¼å¼æ­Œè¯'], timings: [], hasTimings: false };
            } catch (error) {
                console.error('è§£æbinæ­Œè¯å¤±è´¥:', error);
                return { lyrics: ['â™ª æ­Œè¯è§£æå¤±è´¥'], timings: [], hasTimings: false };
            }
        }

        // éŸ³ä¹æ’­æ”¾å™¨çŠ¶æ€
        let musicPlayer = {
            isPlaying: false,
            currentSong: null,
            playlist: [], // ç°åœ¨ä»æ•°æ®åº“åŠ è½½
            currentIndex: 0,
            currentTime: 0,
            totalTime: 0,
            isVinylMode: true,
            currentLyricIndex: 0,
            listeningStartTime: null,
            totalListeningTime: 0,
            playMode: 'sequential', // 'sequential', 'loop-all', 'loop-one', 'shuffle'
            audioElement: null,
            albumCover: null,
            listeningTimer: null,
            activeChatId: null, // è®°å½•å¼€å¯å¬æ­Œçš„èŠå¤©çª—å£ID
            isActive: false, // è®°å½•éŸ³ä¹æ’­æ”¾å™¨æ˜¯å¦å¤„äºæ´»è·ƒçŠ¶æ€

        };

        // åˆå§‹åŒ–éŸ³ä¹æ’­æ”¾å™¨
        async function initializeMusicPlayer() {
            try {
                // ä»æ•°æ®åº“åŠ è½½æ’­æ”¾åˆ—è¡¨
                const playlistItems = await db.musicPlaylist.orderBy('addedTime').toArray();
                musicPlayer.playlist = playlistItems;

                // å¦‚æœæœ‰æ­Œæ›²ä¸”æ²¡æœ‰å½“å‰æ­Œæ›²ï¼Œè®¾ç½®ç¬¬ä¸€é¦–ä¸ºå½“å‰æ­Œæ›²
                if (playlistItems.length > 0 && !musicPlayer.currentSong) {
                    const firstSong = playlistItems[0];

                    // åŠ è½½å°é¢
                    let coverImageData = null;
                    if (firstSong.coverImage) {
                        const coverRecord = await db.musicCovers.get(firstSong.coverImage);
                        if (coverRecord) {
                            coverImageData = coverRecord.imageData;
                        }
                    }

                    musicPlayer.currentSong = {
                        ...firstSong,
                        coverImageData: coverImageData
                    };
                    musicPlayer.currentIndex = 0;
                }

                // ä¸å†æ¯æ¬¡åˆå§‹åŒ–æ—¶é‡ç½®å¬æ­Œæ—¶é—´
                // åªæœ‰åœ¨å®Œå…¨å…³é—­æ’­æ”¾å™¨æ—¶æ‰é‡ç½®
            } catch (error) {
                console.error('åˆå§‹åŒ–éŸ³ä¹æ’­æ”¾å™¨å¤±è´¥:', error);
                // å¦‚æœæ•°æ®åº“åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨ç©ºæ’­æ”¾åˆ—è¡¨
                musicPlayer.playlist = [];
            }

            // åˆå§‹åŒ–æ—¶é—´æ˜¾ç¤º
            const currentTimeEl = document.getElementById('modal-current-time');
            const totalTimeEl = document.getElementById('modal-total-time');
            if (currentTimeEl) currentTimeEl.textContent = '0:00';
            if (totalTimeEl) totalTimeEl.textContent = '0:00';
        }

        // æ‰“å¼€éŸ³ä¹æ’­æ”¾å™¨
        async function openMusicPlayer() {
            // åˆå§‹åŒ–éŸ³ä¹æ’­æ”¾å™¨
            await initializeMusicPlayer();

            const modal = document.getElementById('music-modal');
            const statusDisplay = document.getElementById('music-status-display');
            const phoneScreen = document.getElementById('phone-screen');

            if (modal && phoneScreen) {
                // è·å–æ‰‹æœºå±å¹•çš„ä½ç½®å’Œå¤§å°
                const rect = phoneScreen.getBoundingClientRect();

                // è®¾ç½®éŸ³ä¹æ’­æ”¾å™¨è¦†ç›–æ‰‹æœºå±å¹•
                modal.style.top = rect.top + 'px';
                modal.style.left = rect.left + 'px';
                modal.style.width = rect.width + 'px';
                modal.style.height = rect.height + 'px';
                modal.style.display = 'block';

                // æ›´æ–°æ’­æ”¾å™¨èƒŒæ™¯è‰²
                updatePlayerBackground();
            }
            if (statusDisplay) {
                statusDisplay.style.display = 'flex';
            }

            // å¦‚æœæ²¡æœ‰å½“å‰æ­Œæ›²ï¼Œé€‰æ‹©ç¬¬ä¸€é¦–
            if (!musicPlayer.currentSong && musicPlayer.playlist.length > 0) {
                musicPlayer.currentSong = musicPlayer.playlist[0];
                musicPlayer.currentIndex = 0;
                updateMusicDisplay();
            }

            // è®¾ç½®å½“å‰èŠå¤©è§’è‰²å’Œæ´»è·ƒçŠ¶æ€
            musicPlayer.activeChatId = currentChatCharacter ? currentChatCharacter.id : null;

            // æ£€æŸ¥æ˜¯å¦æ˜¯æ–°çš„å¬æ­Œä¼šè¯ï¼ˆæ’­æ”¾å™¨ä¹‹å‰å®Œå…¨å…³é—­äº†ï¼‰
            const isNewSession = !musicPlayer.isActive;
            musicPlayer.isActive = true;

            // åªæœ‰åœ¨æ–°ä¼šè¯æ—¶æ‰é‡ç½®å¬æ­Œæ—¶é—´
            if (isNewSession) {
                musicPlayer.totalListeningTime = 0;
            }

            // å¼€å§‹æˆ–ç»§ç»­å¬æ­Œè®¡æ—¶
            startListeningTimer();

            // æ›´æ–°æ˜¾ç¤º
            updateListeningTime();
            updatePlayModeButton();

            // ç¡®ä¿æ­Œè¯æ˜¾ç¤ºæ­£ç¡®åˆå§‹åŒ–
            updateMusicDisplay();
            updateLyrics();
        }

        // å…³é—­éŸ³ä¹æ’­æ”¾å™¨ï¼ˆæš‚æ—¶é€€å‡ºï¼Œä¸é‡ç½®å¬æ­Œæ—¶é•¿ï¼‰
        function closeMusicModal() {
            const modal = document.getElementById('music-modal');
            modal.style.display = 'none';

            // ä¸æš‚åœå¬æ­Œè®¡æ—¶ï¼Œä¿æŒè®¡æ—¶å™¨ç»§ç»­è¿è¡Œ
            // è¿™æ ·å½“ç”¨æˆ·å†æ¬¡æ‰“å¼€æ’­æ”¾å™¨æ—¶ï¼Œå¬æ­Œæ—¶é•¿ä¼šä¿æŒä¸å˜
        }

        // å®Œå…¨å…³é—­éŸ³ä¹æ’­æ”¾å™¨ï¼ˆç»“æŸå¬æ­Œï¼‰
        function closeMusicPlayer() {
            const modal = document.getElementById('music-modal');
            const statusDisplay = document.getElementById('music-status-display');

            // éšè—æ¨¡æ€æ¡†å’ŒçŠ¶æ€æ æ˜¾ç¤º
            if (modal) modal.style.display = 'none';
            if (statusDisplay) statusDisplay.style.display = 'none';

            // åœæ­¢éŸ³é¢‘æ’­æ”¾
            if (musicPlayer.audioElement) {
                musicPlayer.audioElement.pause();
                musicPlayer.audioElement = null;
            }

            // é‡ç½®æ’­æ”¾çŠ¶æ€
            musicPlayer.isPlaying = false;
            musicPlayer.isActive = false;

            // åœæ­¢å¬æ­Œè®¡æ—¶
            stopListeningTimer();

            // é‡ç½®å”±ç‰‡æœºåŠ¨ç”»
            const vinylDisc = document.getElementById('vinyl-disc');
            const tonearm = document.getElementById('tonearm');
            if (vinylDisc) vinylDisc.classList.remove('playing');
            if (tonearm) tonearm.classList.remove('playing');

            // é‡ç½®æ’­æ”¾æŒ‰é’®
            const playBtn = document.getElementById('modal-play-btn');
            if (playBtn) playBtn.innerHTML = '<i class="fas fa-play"></i>';

            console.log('ğŸµ éŸ³ä¹æ’­æ”¾å™¨å·²å®Œå…¨å…³é—­');
        }

        // åˆ‡æ¢æ’­æ”¾/æš‚åœ
        function togglePlayback() {
            // å¦‚æœæ²¡æœ‰å½“å‰æ­Œæ›²ä¸”æœ‰æ­Œå•ï¼Œè‡ªåŠ¨é€‰æ‹©ç¬¬ä¸€é¦–
            if (!musicPlayer.audioElement && musicPlayer.playlist.length > 0) {
                musicPlayer.currentIndex = 0;
                const firstSong = musicPlayer.playlist[0];
                playSongFromPlaylist(firstSong);
                return;
            }

            // å¦‚æœæ²¡æœ‰æ­Œå•ï¼Œç›´æ¥è¿”å›
            if (musicPlayer.playlist.length === 0) {
                return;
            }

            musicPlayer.isPlaying = !musicPlayer.isPlaying;

            const playBtn = document.getElementById('modal-play-btn');
            const vinylDisc = document.getElementById('vinyl-disc');
            const tonearm = document.getElementById('tonearm');
            const statusIcon = document.querySelector('.music-icon');

            if (musicPlayer.isPlaying) {
                playBtn.innerHTML = '<i class="fas fa-pause"></i>';
                vinylDisc.classList.add('playing');
                tonearm.classList.add('playing');
                if (statusIcon) statusIcon.style.animation = 'musicPulse 1s ease-in-out infinite';

                // æ’­æ”¾çœŸå®éŸ³é¢‘
                if (musicPlayer.audioElement) {
                    musicPlayer.audioElement.play().catch(e => console.log('æ’­æ”¾å¤±è´¥:', e));
                }

                // é‡ç½®æ’­æ”¾æ—¶é—´å’Œæ­Œè¯ç´¢å¼•
                musicPlayer.currentTime = 0;
                musicPlayer.currentLyricIndex = 0;

                // ç«‹å³æ›´æ–°æ­Œè¯æ˜¾ç¤º
                updateLyrics();


                startPlaybackSimulation();
            } else {
                playBtn.innerHTML = '<i class="fas fa-play"></i>';
                vinylDisc.classList.remove('playing');
                tonearm.classList.remove('playing');
                if (statusIcon) statusIcon.style.animation = 'musicPulse 2s ease-in-out infinite';

                // æš‚åœçœŸå®éŸ³é¢‘
                if (musicPlayer.audioElement) {
                    musicPlayer.audioElement.pause();
                }
            }
        }

        // ä¸Šä¸€é¦–
        async function previousTrack() {
            if (musicPlayer.playlist.length === 0) return;

            musicPlayer.currentIndex = musicPlayer.currentIndex > 0 ?
                musicPlayer.currentIndex - 1 : musicPlayer.playlist.length - 1;

            const song = musicPlayer.playlist[musicPlayer.currentIndex];

            // åŠ è½½å°é¢
            let coverImageData = null;
            if (song.coverImage) {
                try {
                    const coverRecord = await db.musicCovers.get(song.coverImage);
                    if (coverRecord) {
                        coverImageData = coverRecord.imageData;
                    }
                } catch (error) {
                    console.error('åŠ è½½å°é¢å¤±è´¥:', error);
                }
            }

            musicPlayer.currentSong = {
                ...song,
                coverImageData: coverImageData
            };
            musicPlayer.currentTime = 0;
            musicPlayer.currentLyricIndex = 0;

            // åˆ‡æ¢éŸ³é¢‘æº
            if (musicPlayer.audioElement) {
                musicPlayer.audioElement.src = song.url;
                musicPlayer.audioElement.load();
                if (musicPlayer.isPlaying) {
                    musicPlayer.audioElement.play().catch(console.error);
                }
            }

            updateMusicDisplay();
            if (musicPlayer.isPlaying) {
                startPlaybackSimulation();
            }
        }

        // ä¸‹ä¸€é¦–
        async function nextTrack() {
            if (musicPlayer.playlist.length === 0) return;

            let nextIndex;
            switch (musicPlayer.playMode) {
                case 'shuffle':
                    nextIndex = Math.floor(Math.random() * musicPlayer.playlist.length);
                    break;
                case 'loop-one':
                    nextIndex = musicPlayer.currentIndex; // å•æ›²å¾ªç¯ï¼Œä¿æŒå½“å‰ç´¢å¼•
                    break;
                case 'loop-all':
                    nextIndex = musicPlayer.currentIndex < musicPlayer.playlist.length - 1 ?
                        musicPlayer.currentIndex + 1 : 0;
                    break;
                case 'sequential':
                default:
                    nextIndex = musicPlayer.currentIndex < musicPlayer.playlist.length - 1 ?
                        musicPlayer.currentIndex + 1 : musicPlayer.currentIndex; // é¡ºåºæ’­æ”¾ï¼Œåˆ°æœ€åä¸€é¦–å°±åœæ­¢
                    break;
            }

            musicPlayer.currentIndex = nextIndex;
            const song = musicPlayer.playlist[musicPlayer.currentIndex];

            // åŠ è½½å°é¢
            let coverImageData = null;
            if (song.coverImage) {
                try {
                    const coverRecord = await db.musicCovers.get(song.coverImage);
                    if (coverRecord) {
                        coverImageData = coverRecord.imageData;
                    }
                } catch (error) {
                    console.error('åŠ è½½å°é¢å¤±è´¥:', error);
                }
            }

            musicPlayer.currentSong = {
                ...song,
                coverImageData: coverImageData
            };
            musicPlayer.currentTime = 0;
            musicPlayer.currentLyricIndex = 0;

            // åˆ‡æ¢éŸ³é¢‘æº
            if (musicPlayer.audioElement) {
                musicPlayer.audioElement.src = song.url;
                musicPlayer.audioElement.load();

                // ğŸ”¥ã€ä¿®å¤ã€‘æ— è®ºisPlayingçŠ¶æ€å¦‚ä½•ï¼Œéƒ½å°è¯•æ’­æ”¾
                // å› ä¸ºnextTracké€šå¸¸æ˜¯åœ¨éœ€è¦æ’­æ”¾çš„æƒ…å†µä¸‹è°ƒç”¨çš„
                musicPlayer.audioElement.play().catch(error => {
                    console.error('æ’­æ”¾å¤±è´¥:', error);
                    // å¦‚æœè‡ªåŠ¨æ’­æ”¾å¤±è´¥ï¼Œè‡³å°‘ç¡®ä¿çŠ¶æ€æ˜¯æ­£ç¡®çš„
                    musicPlayer.isPlaying = false;
                    updateMusicDisplay();
                });

                // è®¾ç½®æ’­æ”¾çŠ¶æ€ä¸ºtrue
                musicPlayer.isPlaying = true;
            }

            updateMusicDisplay();

            // ç¡®ä¿åœ¨åˆ‡æ¢æ—¶å¯åŠ¨æ’­æ”¾æ¨¡æ‹Ÿ
            startPlaybackSimulation();
        }

        // åˆ‡æ¢è§†å›¾æ¨¡å¼
        function toggleMusicView() {
            musicPlayer.isVinylMode = !musicPlayer.isVinylMode;

            const vinylMode = document.getElementById('vinyl-mode');
            const lyricsMode = document.getElementById('lyrics-mode');
            const toggleBtn = document.getElementById('view-toggle-btn');
            const currentLyricDisplay = document.querySelector('.current-lyric-display');

            if (musicPlayer.isVinylMode) {
                vinylMode.style.display = 'block';
                lyricsMode.style.display = 'none';
                // åœ¨å”±ç‰‡æœºæ¨¡å¼ä¸‹æ˜¾ç¤ºå½“å‰æ­Œè¯
                if (currentLyricDisplay) currentLyricDisplay.style.display = 'block';
                toggleBtn.innerHTML = '<i class="fas fa-list"></i>';
            } else {
                vinylMode.style.display = 'none';
                lyricsMode.style.display = 'block';
                // åœ¨æ­Œè¯æ¨¡å¼ä¸‹éšè—å½“å‰æ­Œè¯æ˜¾ç¤ºï¼Œé¿å…é‡å¤
                if (currentLyricDisplay) currentLyricDisplay.style.display = 'none';
                toggleBtn.innerHTML = '<i class="fas fa-compact-disc"></i>';

                // ç¡®ä¿æ­Œè¯æ¨¡å¼å®¹å™¨æ­£ç¡®åˆå§‹åŒ–
                setTimeout(() => {
                    // å¼ºåˆ¶é‡æ–°æ¸²æŸ“æ­Œè¯å¹¶æ»šåŠ¨åˆ°å½“å‰ä½ç½®
                    const fullLyricsEl = document.getElementById('full-lyrics-display');
                    if (fullLyricsEl) {
                        fullLyricsEl.innerHTML = ''; // æ¸…ç©ºå†…å®¹å¼ºåˆ¶é‡æ–°æ¸²æŸ“
                    }
                    updateLyrics();
                }, 100);
            }

            // æ›´æ–°æ­Œè¯æ˜¾ç¤º
            if (musicPlayer.isVinylMode) {
                updateLyrics();
            }
        }

        // æ›´æ–°éŸ³ä¹æ˜¾ç¤º
        function updateMusicDisplay() {
            if (!musicPlayer.currentSong) return;

            const song = musicPlayer.currentSong;

            // æ›´æ–°çŠ¶æ€æ 
            document.getElementById('current-lyric').textContent = `â™ª ${song.title} - ${song.artist}`;

            // æ›´æ–°å”±ç‰‡æœºæ¨¡å¼
            document.getElementById('vinyl-song-title').textContent = song.title;
            document.getElementById('vinyl-artist-name').textContent = song.artist;

            // æ›´æ–°æ­Œè¯æ¨¡å¼
            document.getElementById('lyrics-song-title').textContent = song.title;
            document.getElementById('lyrics-artist-name').textContent = song.artist;

            // æ›´æ–°æ—¶é•¿æ˜¾ç¤º
            const totalTimeEl = document.getElementById('modal-total-time');
            if (totalTimeEl) {
                const duration = musicPlayer.audioElement ? musicPlayer.audioElement.duration : 0;
                if (duration && !isNaN(duration) && duration > 0) {
                    totalTimeEl.textContent = formatMusicTime(duration);
                } else {
                    totalTimeEl.textContent = '0:00';
                }
            }

            // æ›´æ–°å½“å‰æ—¶é—´æ˜¾ç¤º
            const currentTimeEl = document.getElementById('modal-current-time');
            if (currentTimeEl) {
                const currentTime = musicPlayer.audioElement ? musicPlayer.audioElement.currentTime : 0;
                if (currentTime && !isNaN(currentTime) && currentTime >= 0) {
                    currentTimeEl.textContent = formatMusicTime(currentTime);
                } else {
                    currentTimeEl.textContent = '0:00';
                }
            }

            // æ›´æ–°è¿›åº¦æ¡
            const progressFill = document.getElementById('modal-progress');
            if (progressFill && musicPlayer.audioElement) {
                const currentTime = musicPlayer.audioElement.currentTime || 0;
                const duration = musicPlayer.audioElement.duration || 0;
                if (duration > 0) {
                    const progress = (currentTime / duration) * 100;
                    progressFill.style.width = `${progress}%`;
                }
            }

            // æ›´æ–°å¬æ­Œæ—¶é—´æ˜¾ç¤º
            updateListeningTime();

            // æ›´æ–°å”±ç‰‡æœºå°é¢
            updateVinylCover();

            // æ›´æ–°æ­Œè¯
            updateLyrics();

            // æ›´æ–°æ’­æ”¾å™¨èƒŒæ™¯è‰²
            updatePlayerBackground();
        }

        // ç‚¹å‡»æ­Œè¯è·³è½¬åˆ°å¯¹åº”æ—¶é—´
        function seekToLyric(lyricIndex) {
            if (!musicPlayer.audioElement || !musicPlayer.currentSong || !musicPlayer.currentSong.lyrics) {
                return;
            }

            const totalDuration = musicPlayer.audioElement.duration;
            const lyricsCount = musicPlayer.currentSong.lyrics.length;

            if (totalDuration && lyricsCount > 0) {
                // ä½¿ç”¨ä¸æ­Œè¯åŒæ­¥ç›¸åŒçš„ç®—æ³•è®¡ç®—æ—¶é—´
                const introTime = Math.min(totalDuration * 0.03, 5);
                const outroTime = totalDuration * 0.02;
                const lyricsTime = totalDuration - introTime - outroTime;

                let targetTime;
                if (lyricIndex === 0) {
                    targetTime = introTime;
                } else if (lyricIndex === lyricsCount - 1) {
                    targetTime = totalDuration - outroTime;
                } else {
                    const lyricsProgress = lyricIndex / lyricsCount;
                    targetTime = introTime + (lyricsProgress * lyricsTime);
                }

                // è·³è½¬åˆ°ç›®æ ‡æ—¶é—´
                musicPlayer.audioElement.currentTime = Math.min(Math.max(targetTime, 0), totalDuration);
                musicPlayer.currentTime = targetTime;
                musicPlayer.currentLyricIndex = lyricIndex;

                // æ›´æ–°æ˜¾ç¤º
                updateLyrics();


            }
        }

        // æ ¼å¼åŒ–éŸ³ä¹æ’­æ”¾æ—¶é—´ï¼ˆç§’æ•°è½¬æ¢ä¸ºåˆ†:ç§’æ ¼å¼ï¼‰
        function formatMusicTime(seconds) {
            if (!seconds || isNaN(seconds) || seconds <= 0) return '0:00';
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        // å¼€å§‹å¬æ­Œè®¡æ—¶
        function startListeningTimer() {
            if (musicPlayer.listeningTimer) {
                clearInterval(musicPlayer.listeningTimer);
            }

            musicPlayer.listeningTimer = setInterval(() => {
                if (musicPlayer.isPlaying && musicPlayer.isActive) {
                    musicPlayer.totalListeningTime += 1; // æŒ‰ç§’è®¡ç®—
                    updateListeningTime(); // ä½¿ç”¨ç»Ÿä¸€çš„æ›´æ–°å‡½æ•°
                }
            }, 1000);
        }

        // æš‚åœå¬æ­Œè®¡æ—¶ï¼ˆä¸é‡ç½®æ—¶é•¿ï¼‰
        function pauseListeningTimer() {
            if (musicPlayer.listeningTimer) {
                clearInterval(musicPlayer.listeningTimer);
                musicPlayer.listeningTimer = null;
            }
        }

        // åœæ­¢å¬æ­Œè®¡æ—¶å¹¶é‡ç½®æ—¶é•¿
        function stopListeningTimer() {
            if (musicPlayer.listeningTimer) {
                clearInterval(musicPlayer.listeningTimer);
                musicPlayer.listeningTimer = null;
            }
            // é‡ç½®å¬æ­Œæ—¶é•¿
            musicPlayer.totalListeningTime = 0;
        }

        // è·å–å½“å‰éŸ³ä¹æ’­æ”¾çŠ¶æ€ï¼ˆä¾›AIè§’è‰²ä½¿ç”¨ï¼‰
        function getMusicPlayingStatus(characterId) {
            if (!musicPlayer.isActive || musicPlayer.activeChatId !== characterId) {
                return null;
            }

            const minutes = Math.floor(musicPlayer.totalListeningTime / 60);
            const seconds = musicPlayer.totalListeningTime % 60;

            return {
                isPlaying: musicPlayer.isPlaying,
                isListening: musicPlayer.isActive,
                currentSong: musicPlayer.currentSong ? {
                    title: musicPlayer.currentSong.title,
                    artist: musicPlayer.currentSong.artist,
                    album: musicPlayer.currentSong.album
                } : null,
                listeningDuration: {
                    minutes: minutes,
                    seconds: seconds,
                    total: musicPlayer.totalListeningTime,
                    formatted: `${minutes}åˆ†${seconds}ç§’`
                }
            };
        }



        // æ›´æ–°æ­Œè¯æ˜¾ç¤º
        function updateLyrics() {
            const currentLyricText = document.getElementById('current-lyric-text');



            if (!musicPlayer.currentSong || !musicPlayer.currentSong.lyrics || musicPlayer.currentSong.lyrics.length === 0) {
                // æ²¡æœ‰æ­Œè¯æ—¶æ˜¾ç¤ºé»˜è®¤æ–‡æœ¬
                if (currentLyricText) {
                    currentLyricText.textContent = musicPlayer.isPlaying ? 'â™ª æ­£åœ¨æ’­æ”¾' : 'â™ª ç‚¹å‡»æ’­æ”¾å¼€å§‹å¬æ­Œ';
                }

                // æ›´æ–°çµåŠ¨å²›æ­Œè¯æ˜¾ç¤º
                const dynamicIslandLyric = document.getElementById('current-lyric');
                if (dynamicIslandLyric) {
                    dynamicIslandLyric.textContent = musicPlayer.isPlaying ? 'â™ª æ­£åœ¨æ’­æ”¾' : 'â™ª ç‚¹å‡»å¼€å§‹å¬æ­Œ';
                }
                return;
            }

            const lyrics = musicPlayer.currentSong.lyrics;
            let currentIndex = musicPlayer.currentLyricIndex;

            // å¦‚æœæœ‰æ—¶é—´åŒæ­¥ä¿¡æ¯ï¼Œæ ¹æ®å½“å‰æ’­æ”¾æ—¶é—´è®¡ç®—æ­Œè¯ç´¢å¼•
            if (musicPlayer.currentSong.hasTimedLyrics &&
                musicPlayer.currentSong.lyricsTimings &&
                musicPlayer.audioElement &&
                !musicPlayer.audioElement.paused) {

                const currentTime = musicPlayer.audioElement.currentTime;
                const timings = musicPlayer.currentSong.lyricsTimings;

                // æ‰¾åˆ°å½“å‰æ—¶é—´å¯¹åº”çš„æ­Œè¯ç´¢å¼•
                let newIndex = 0;
                for (let i = 0; i < timings.length; i++) {
                    if (currentTime >= timings[i]) {
                        newIndex = i;
                    } else {
                        break;
                    }
                }

                currentIndex = newIndex;
                musicPlayer.currentLyricIndex = currentIndex;
            }

            const currentLyric = lyrics[currentIndex] || 'â™ª';

            // æ›´æ–°æ–°çš„å½“å‰æ­Œè¯æ˜¾ç¤ºåŒºåŸŸ
            if (currentLyricText) {
                currentLyricText.textContent = currentLyric;
            }

            // æ›´æ–°çµåŠ¨å²›æ­Œè¯æ˜¾ç¤º
            const dynamicIslandLyric = document.getElementById('current-lyric');
            if (dynamicIslandLyric) {
                dynamicIslandLyric.textContent = currentLyric;
            }

            // æ›´æ–°å”±ç‰‡æœºæ¨¡å¼çš„æ­Œè¯ - åªæ˜¾ç¤ºå½“å‰ä¸€å¥
            const currentEl = document.getElementById('lyric-current');
            if (currentEl) {
                currentEl.textContent = currentLyric;
            }

            // æ›´æ–°å®Œæ•´æ­Œè¯æ¨¡å¼å¹¶å®ç°æ»šåŠ¨
            const fullLyricsEl = document.getElementById('full-lyrics-display');
            if (fullLyricsEl) {
                // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡æ–°æ¸²æŸ“æ­Œè¯åˆ—è¡¨
                const existingLines = fullLyricsEl.querySelectorAll('.lyric-line');
                if (existingLines.length !== lyrics.length) {
                    // é‡æ–°æ¸²æŸ“æ­Œè¯åˆ—è¡¨
                    const newHTML = lyrics.map((lyric, index) => {
                        const isEmpty = lyric.trim() === '';
                        return `<div class="lyric-line ${isEmpty ? 'empty' : ''}" data-index="${index}" onclick="seekToLyric(${index})">${lyric || '&nbsp;'}</div>`;
                    }).join('');
                    fullLyricsEl.innerHTML = newHTML;
                }

                // æ›´æ–°æ´»è·ƒçŠ¶æ€
                const allLines = fullLyricsEl.querySelectorAll('.lyric-line');
                allLines.forEach((line, index) => {
                    line.classList.toggle('active', index === currentIndex);
                });

                // ä½¿ç”¨transformå®ç°å¹³æ»‘æ»šåŠ¨ - åªåœ¨æ­Œè¯æ¨¡å¼ä¸‹æ‰§è¡Œ
                if (!musicPlayer.isVinylMode) {
                    const container = document.querySelector('.full-lyrics-container');
                    const lyricsMode = document.getElementById('lyrics-mode');

                    if (container && lyricsMode && lyricsMode.style.display !== 'none') {
                        const activeLyricEl = fullLyricsEl.querySelector('.lyric-line.active');
                        if (activeLyricEl && currentIndex >= 0) {
                            const containerHeight = container.clientHeight;

                          // è°ƒæ•´ä½ç½®è®©æ­Œè¯å†é ä¸Šä¸€ç‚¹ï¼šä½¿ç”¨1/4ä½ç½®è€Œä¸æ˜¯1/3
                            const offset = (containerHeight / 4) - activeLyricEl.offsetTop - (activeLyricEl.offsetHeight / 2);

                            // ä½¿ç”¨transformå®ç°å¹³æ»‘æ»šåŠ¨
                            fullLyricsEl.style.transform = `translateY(${offset}px)`;
                        }
                    }
                }
            }
        }

        // æ¨¡æ‹Ÿæ’­æ”¾è¿›åº¦
        function startPlaybackSimulation() {
            if (!musicPlayer.isPlaying) return;

            const interval = setInterval(() => {
                if (!musicPlayer.isPlaying) {
                    clearInterval(interval);
                    return;
                }

                // å¦‚æœæœ‰çœŸå®éŸ³é¢‘ï¼Œä½¿ç”¨éŸ³é¢‘çš„å½“å‰æ—¶é—´
                if (musicPlayer.audioElement && !musicPlayer.audioElement.paused) {
                    musicPlayer.currentTime = Math.floor(musicPlayer.audioElement.currentTime);
                    const totalTime = musicPlayer.audioElement.duration || 300;

                    // æ›´æ–°è¿›åº¦æ¡
                    const progress = (musicPlayer.currentTime / totalTime) * 100;
                    document.getElementById('modal-progress').style.width = `${Math.min(progress, 100)}%`;

                    // æ£€æŸ¥æ˜¯å¦ç»“æŸ
                    if (musicPlayer.audioElement.ended) {
                        clearInterval(interval);
                        if (musicPlayer.repeatMode === 'one') {
                            musicPlayer.audioElement.currentTime = 0;
                            musicPlayer.audioElement.play();
                        } else if (musicPlayer.repeatMode === 'all' || musicPlayer.repeatMode === 'none') {
                            nextTrack();
                        }
                        return;
                    }
                } else {
                    // æ¨¡æ‹Ÿæ’­æ”¾
                    musicPlayer.currentTime += 1;
                    const totalTime = 300; // å‡è®¾æ­Œæ›²5åˆ†é’Ÿ

                    // æ›´æ–°è¿›åº¦æ¡
                    const progress = (musicPlayer.currentTime / totalTime) * 100;
                    const progressBar = document.getElementById('modal-progress');
                    if (progressBar) {
                        progressBar.style.width = `${Math.min(progress, 100)}%`;
                    }

                    // æ›´æ–°æ—¶é—´æ˜¾ç¤º
                    const currentTimeEl = document.getElementById('modal-current-time');
                    const totalTimeEl = document.getElementById('modal-total-time');
                    if (currentTimeEl) currentTimeEl.textContent = formatMusicTime(musicPlayer.currentTime);
                    if (totalTimeEl) totalTimeEl.textContent = formatMusicTime(totalTime);

                    // æ­Œæ›²ç»“æŸï¼Œè‡ªåŠ¨ä¸‹ä¸€é¦–
                    if (musicPlayer.currentTime >= totalTime) {
                        clearInterval(interval);
                        switch (musicPlayer.playMode) {
                            case 'loop-one':
                                musicPlayer.currentTime = 0;
                                startPlaybackSimulation();
                                break;
                            case 'loop-all':
                            case 'shuffle':
                                nextTrack();
                                break;
                            case 'sequential':
                                // é¡ºåºæ’­æ”¾ï¼Œåˆ°æœ€åä¸€é¦–å°±åœæ­¢
                                if (musicPlayer.currentIndex < musicPlayer.playlist.length - 1) {
                                    nextTrack();
                                } else {
                                    musicPlayer.isPlaying = false;
                                    updateMusicDisplay();
                                }
                                break;
                        }
                        return;
                    }
                }

                // æ—¶é—´æ˜¾ç¤ºç”±timeupdateäº‹ä»¶å¤„ç†ï¼Œè¿™é‡Œä¸é‡å¤æ›´æ–°

                // æ›´æ–°æ­Œè¯
                if (musicPlayer.currentSong && musicPlayer.currentSong.lyrics && musicPlayer.currentSong.lyrics.length > 0) {
                    let newLyricIndex = 0;

                    // å¦‚æœæœ‰æ—¶é—´åŒæ­¥ä¿¡æ¯ï¼Œä½¿ç”¨ç²¾ç¡®çš„æ—¶é—´åŒæ­¥
                    if (musicPlayer.currentSong.hasTimedLyrics && musicPlayer.currentSong.lyricsTimings) {
                        const currentTime = musicPlayer.audioElement ? musicPlayer.audioElement.currentTime : musicPlayer.currentTime;
                        const timings = musicPlayer.currentSong.lyricsTimings;

                        const adjustedTime = currentTime;

                        // æ‰¾åˆ°å½“å‰æ—¶é—´å¯¹åº”çš„æ­Œè¯ç´¢å¼•
                        for (let i = 0; i < timings.length; i++) {
                            if (adjustedTime >= timings[i]) {
                                newLyricIndex = i;
                            } else {
                                break;
                            }
                        }
                    } else {
                        // ä½¿ç”¨ç®€åŒ–ç®—æ³•ï¼ˆå¹³å‡åˆ†é…æ—¶é—´ï¼‰
                        const totalDuration = musicPlayer.audioElement ? musicPlayer.audioElement.duration : 300;
                        const lyricsCount = musicPlayer.currentSong.lyrics.length;
                        const currentTime = musicPlayer.currentTime;

                        if (totalDuration > 0 && lyricsCount > 0) {
                            const timePerLyric = totalDuration / lyricsCount;
                            const adjustedTime = currentTime;
                            newLyricIndex = Math.min(
                                Math.max(Math.floor(adjustedTime / timePerLyric), 0),
                                lyricsCount - 1
                            );
                        }
                    }

                    // æ›´æ–°æ­Œè¯ç´¢å¼•
                    if (newLyricIndex !== musicPlayer.currentLyricIndex) {
                        musicPlayer.currentLyricIndex = newLyricIndex;
                        updateLyrics();
                    }
                }
            }, musicPlayer.currentSong && musicPlayer.currentSong.hasTimedLyrics ? 200 : 500); // æœ‰æ—¶é—´åŒæ­¥æ—¶æ›´é¢‘ç¹æ›´æ–°
        }

        // è·å–å½“å‰è§’è‰²åç§°
        function getCurrentCharacterName() {
            if (currentChatCharacter) {
                return currentChatCharacter.name;
            }
            return 'ä½ ';
        }

        // æ›´æ–°å¬æ­Œæ—¶é•¿æ˜¾ç¤º
        function updateListeningTime() {
            const duration = document.getElementById('listening-duration');
            if (duration && musicPlayer.isActive) {
                const minutes = Math.floor(musicPlayer.totalListeningTime / 60);

                // è·å–å½“å‰èŠå¤©è§’è‰²åç§°ï¼ˆæ¢å¤è‡ªåŠ¨åˆ‡æ¢åŠŸèƒ½ï¼‰
                let characterName = 'ä½ ';
                if (currentChatCharacter) {
                    characterName = currentChatCharacter.name;
                }

                const displayText = `å·²ä¸€èµ·å¬ ${minutes} åˆ†é’Ÿ`;
                duration.textContent = displayText;

                // ä¸å†ä¿å­˜åˆ° localStorageï¼ˆæ¯æ¬¡é‡æ–°è®¡æ—¶ï¼‰
            }
        }

        // ç‚¹å‡»çŠ¶æ€æ éŸ³ä¹åŒºåŸŸæ‰“å¼€æ¨¡æ€æ¡†
        function openMusicModal() {
            openMusicPlayer();
        }

        // æå–å›¾ç‰‡ä¸»è‰²è°ƒ
        function extractImageColors(imageElement) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                canvas.width = 50;
                canvas.height = 50;

                ctx.drawImage(imageElement, 0, 0, 50, 50);

                const imageData = ctx.getImageData(0, 0, 50, 50);
                const data = imageData.data;

                let r = 0, g = 0, b = 0;
                let pixelCount = 0;

                for (let i = 0; i < data.length; i += 4) {
                    r += data[i];
                    g += data[i + 1];
                    b += data[i + 2];
                    pixelCount++;
                }

                r = Math.floor(r / pixelCount);
                g = Math.floor(g / pixelCount);
                b = Math.floor(b / pixelCount);

                resolve({ r, g, b });
            });
        }

        // æ›´æ–°æ’­æ”¾å™¨èƒŒæ™¯è‰²
        function updatePlayerBackground() {
            const modal = document.getElementById('music-modal');
            const modalContent = document.querySelector('.music-modal-content');
            const albumCoverImg = document.getElementById('album-cover');

            if (albumCoverImg && albumCoverImg.src && !albumCoverImg.src.includes('data:image/svg') && albumCoverImg.style.display !== 'none') {
                // å¦‚æœæœ‰å°é¢å›¾ç‰‡ï¼Œæå–ä¸»è‰²è°ƒ
                extractImageColors(albumCoverImg).then(colors => {
                    const { r, g, b } = colors;

                    // åˆ›å»ºåŸºäºå°é¢çš„æ¯›ç»ç’ƒæ•ˆæœ
                    const bgColor = `rgba(${r}, ${g}, ${b}, 0.3)`;

                    if (modalContent) {
                        modalContent.style.background = bgColor;
                        modalContent.style.backdropFilter = 'blur(30px) saturate(1.5)';
                        modalContent.style.webkitBackdropFilter = 'blur(30px) saturate(1.5)';
                    }
                });
            } else {
                // é»˜è®¤é›¾éœ¾ç°æ¯›ç»ç’ƒæ•ˆæœ
                if (modalContent) {
                    modalContent.style.background = 'rgba(200, 200, 200, 0.25)';
                    modalContent.style.backdropFilter = 'blur(30px) saturate(1.5)';
                    modalContent.style.webkitBackdropFilter = 'blur(30px) saturate(1.5)';
                }
            }
        }

        // åˆ‡æ¢æ’­æ”¾æ¨¡å¼
        function togglePlayMode() {
            // æ’­æ”¾æ¨¡å¼: sequential(é¡ºåº) -> loop-all(åˆ—è¡¨å¾ªç¯) -> loop-one(å•æ›²å¾ªç¯) -> shuffle(éšæœº)
            const modes = ['sequential', 'loop-all', 'loop-one', 'shuffle'];
            const currentIndex = modes.indexOf(musicPlayer.playMode || 'sequential');
            const nextIndex = (currentIndex + 1) % modes.length;
            musicPlayer.playMode = modes[nextIndex];

            // æ›´æ–°æŒ‰é’®æ˜¾ç¤º
            updatePlayModeButton();
        }



        // æ›´æ–°æ’­æ”¾æ¨¡å¼æŒ‰é’®æ˜¾ç¤º
        function updatePlayModeButton() {
            const btn = document.getElementById('play-mode-btn');
            const icon = btn.querySelector('i');

            switch (musicPlayer.playMode) {
                case 'sequential':
                    icon.className = 'fas fa-list-ol';
                    btn.title = 'é¡ºåºæ’­æ”¾';
                    btn.classList.remove('active');
                    // ç§»é™¤æ•°å­—æ˜¾ç¤º
                    const numberEl1 = btn.querySelector('.loop-number');
                    if (numberEl1) numberEl1.remove();
                    break;
                case 'loop-all':
                    icon.className = 'fas fa-redo';
                    btn.title = 'åˆ—è¡¨å¾ªç¯';
                    btn.classList.remove('active');
                    // ç§»é™¤æ•°å­—æ˜¾ç¤º
                    const numberEl2 = btn.querySelector('.loop-number');
                    if (numberEl2) numberEl2.remove();
                    break;
                case 'loop-one':
                    icon.className = 'fas fa-repeat';
                    btn.title = 'å•æ›²å¾ªç¯';
                    btn.classList.remove('active');
                    // æ·»åŠ æ•°å­—1çš„æ˜¾ç¤º
                    if (!btn.querySelector('.loop-number')) {
                        const numberSpan = document.createElement('span');
                        numberSpan.className = 'loop-number';
                        numberSpan.textContent = '1';
                        btn.appendChild(numberSpan);
                    }
                    break;
                case 'shuffle':
                    icon.className = 'fas fa-random';
                    btn.title = 'éšæœºæ’­æ”¾';
                    btn.classList.remove('active');
                    // ç§»é™¤æ•°å­—æ˜¾ç¤º
                    const numberEl3 = btn.querySelector('.loop-number');
                    if (numberEl3) numberEl3.remove();
                    break;
            }
        }

        // åˆ‡æ¢å¾ªç¯æ’­æ”¾
        function toggleRepeat() {
            const modes = ['none', 'one', 'all'];
            const currentIndex = modes.indexOf(musicPlayer.repeatMode || 'none');
            const nextIndex = (currentIndex + 1) % modes.length;
            musicPlayer.repeatMode = modes[nextIndex];

            const repeatBtn = document.getElementById('repeat-btn');
            const icons = {
                'none': 'fas fa-redo',
                'one': 'fas fa-redo-alt',
                'all': 'fas fa-redo'
            };

            repeatBtn.innerHTML = `<i class="${icons[musicPlayer.repeatMode]}"></i>`;
            repeatBtn.classList.toggle('active', musicPlayer.repeatMode !== 'none');

            // æ˜¾ç¤ºæç¤º
            const modeNames = {
                'sequential': 'é¡ºåºæ’­æ”¾',
                'loop': 'å•æ›²å¾ªç¯',
                'random': 'éšæœºæ’­æ”¾'
            };
            console.log(`åˆ‡æ¢åˆ°: ${modeNames[musicPlayer.playMode]}`);
        }

        // æ‰“å¼€æ’­æ”¾åˆ—è¡¨æ¨¡æ€æ¡†
        function openPlaylistModal() {
            const modal = document.getElementById('playlist-modal');
            if (modal) {
                modal.style.display = 'flex';
                loadPlaylistItems();
            }
        }

        // å…³é—­æ’­æ”¾åˆ—è¡¨æ¨¡æ€æ¡†
        function closePlaylistModal() {
            const modal = document.getElementById('playlist-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // åŠ è½½æ’­æ”¾åˆ—è¡¨é¡¹ç›®
        async function loadPlaylistItems() {
            try {
                const playlistItems = await db.musicPlaylist.orderBy('addedTime').toArray();
                const container = document.getElementById('playlist-items');

                if (!container) return;

                container.innerHTML = '';

                if (playlistItems.length === 0) {
                    container.innerHTML = `
                        <div class="playlist-empty">
                            <i class="fas fa-music"></i>
                            <div>æš‚æ— æ­Œæ›²</div>
                            <div style="font-size: 12px; margin-top: 8px; opacity: 0.8;">æ·»åŠ ä¸€äº›æ­Œæ›²å¼€å§‹äº«å—éŸ³ä¹å§</div>
                        </div>
                    `;
                    return;
                }

                playlistItems.forEach((song, index) => {
                    const songElement = document.createElement('div');
                    songElement.className = 'playlist-item-modern';

                    songElement.innerHTML = `
                        <div class="song-number">${index + 1}</div>
                        <div class="song-info">
                            <div class="song-title">${song.title}</div>
                            <div class="song-artist">${song.artist}</div>
                        </div>
                        <div class="song-actions">
                            <button class="play-btn" title="æ’­æ”¾" data-song-id="${song.id}">
                                <i class="fas fa-play"></i>
                            </button>
                            <button onclick="removeSongFromPlaylist('${song.id}')"
                                    class="delete-btn" title="åˆ é™¤">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    `;

                    // æ·»åŠ æ’­æ”¾æŒ‰é’®äº‹ä»¶ç›‘å¬
                    const playBtn = songElement.querySelector('.play-btn');
                    playBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        playSongFromPlaylist(song);
                    });

                    container.appendChild(songElement);
                });
            } catch (error) {
                console.error('åŠ è½½æ’­æ”¾åˆ—è¡¨å¤±è´¥:', error);
            }
        }



        // æ·»åŠ è‡ªå®šä¹‰æ­Œæ›²åˆ°æ’­æ”¾åˆ—è¡¨
        async function addCustomSong() {
            const urlInput = document.getElementById('song-url-input');
            const titleInput = document.getElementById('song-title-input');
            const artistInput = document.getElementById('song-artist-input');
            const coverInput = document.getElementById('song-cover-input');
            const lyricsInput = document.getElementById('song-lyrics-input');
            const localMusicInput = document.getElementById('local-music-input');
            const lyricsFileInput = document.getElementById('lyrics-file-input');

            let url = urlInput.value.trim();
            const title = titleInput.value.trim();
            const artist = artistInput.value.trim();
            let lyricsText = lyricsInput.value.trim();
            let isLocalFile = false;

            // æ£€æŸ¥æ˜¯å¦é€‰æ‹©äº†æœ¬åœ°éŸ³ä¹æ–‡ä»¶
            if (localMusicInput.files && localMusicInput.files[0]) {
                const audioFile = localMusicInput.files[0];
                url = URL.createObjectURL(audioFile);
                isLocalFile = true;

                // å¦‚æœæ²¡æœ‰å¡«å†™æ ‡é¢˜ï¼Œä½¿ç”¨æ–‡ä»¶å
                if (!title) {
                    titleInput.value = audioFile.name.replace(/\.[^/.]+$/, "");
                }
            }

            if (!url || !titleInput.value.trim() || !artist) {
                alert('è¯·å¡«å†™å®Œæ•´çš„æ­Œæ›²ä¿¡æ¯æˆ–é€‰æ‹©æœ¬åœ°éŸ³ä¹æ–‡ä»¶');
                return;
            }

            try {
                const songId = Date.now().toString();
                let coverImageId = null;

                // å¤„ç†å°é¢ä¸Šä¼ 
                if (coverInput.files && coverInput.files[0]) {
                    const file = coverInput.files[0];
                    const reader = new FileReader();

                    await new Promise((resolve, reject) => {
                        reader.onload = async (e) => {
                            try {
                                coverImageId = `cover_${songId}`;
                                await db.musicCovers.add({
                                    id: coverImageId,
                                    songId: songId,
                                    imageData: e.target.result,
                                    timestamp: Date.now()
                                });
                                resolve();
                            } catch (error) {
                                reject(error);
                            }
                        };
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    });
                }

                // å¤„ç†æ­Œè¯æ–‡ä»¶
                let lyricsArray = [];

                // æ£€æŸ¥æ˜¯å¦ä¸Šä¼ äº†æ­Œè¯æ–‡ä»¶
                if (lyricsFileInput.files && lyricsFileInput.files[0]) {
                    const lyricsFile = lyricsFileInput.files[0];
                    const fileName = lyricsFile.name.toLowerCase();

                    if (fileName.endsWith('.lrc')) {
                        // LRCæ ¼å¼æ­Œè¯
                        const lrcContent = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = (e) => resolve(e.target.result);
                            reader.onerror = reject;
                            reader.readAsText(lyricsFile, 'utf-8');
                        });
                        const lrcResult = parseLRC(lrcContent);
                        lyricsArray = lrcResult.lyrics;
                        // ä¿å­˜æ—¶é—´ä¿¡æ¯åˆ°æ­Œæ›²æ•°æ®ä¸­
                        if (lrcResult.hasTimings) {
                            window.tempLyricsTimings = lrcResult.timings;
                        }
                    } else if (fileName.endsWith('.bin')) {
                        // binæ ¼å¼æ­Œè¯
                        const binData = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = (e) => resolve(e.target.result);
                            reader.onerror = reject;
                            reader.readAsArrayBuffer(lyricsFile);
                        });
                        const binResult = parseNeteaseBin(binData);
                        lyricsArray = binResult.lyrics;
                        if (binResult.hasTimings) {
                            window.tempLyricsTimings = binResult.timings;
                        }
                    } else {
                        // å…¶ä»–æ–‡æœ¬æ ¼å¼ï¼Œå°è¯•ä½œä¸ºæ™®é€šæ–‡æœ¬å¤„ç†
                        const textContent = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = (e) => resolve(e.target.result);
                            reader.onerror = reject;
                            reader.readAsText(lyricsFile, 'utf-8');
                        });
                        lyricsArray = textContent.split('\n').map(line => line.trim()).filter(line => line.length > 0);
                    }
                }
                // ä½¿ç”¨æ‰‹åŠ¨è¾“å…¥çš„æ­Œè¯
                else if (lyricsText) {
                    lyricsArray = lyricsText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
                }

                // å¦‚æœæ²¡æœ‰æ­Œè¯ï¼Œä½¿ç”¨é»˜è®¤æ­Œè¯
                if (lyricsArray.length === 0) {
                    lyricsArray = ['â™ª æš‚æ— æ­Œè¯'];
                }



                // æ·»åŠ æ­Œæ›²åˆ°æ•°æ®åº“
                await db.musicPlaylist.add({
                    id: songId,
                    title: titleInput.value.trim(),
                    artist: artist,
                    album: '',
                    duration: '0:00',
                    url: url,
                    coverImage: coverImageId,
                    lyrics: lyricsArray,
                    lyricsTimings: window.tempLyricsTimings || [],
                    hasTimedLyrics: !!(window.tempLyricsTimings && window.tempLyricsTimings.length > 0),
                    addedTime: Date.now()
                });

                // æ¸…ç†ä¸´æ—¶å˜é‡
                delete window.tempLyricsTimings;

                // æ¸…ç©ºè¾“å…¥æ¡†
                urlInput.value = '';
                titleInput.value = '';
                artistInput.value = '';
                coverInput.value = '';
                lyricsInput.value = '';
                localMusicInput.value = '';
                lyricsFileInput.value = '';

                // é‡ç½®æ–‡ä»¶é€‰æ‹©æ¡†æ˜¾ç¤ºæ–‡å­—
                const fileText = document.querySelector('.file-input-text');
                if (fileText) {
                    fileText.textContent = 'æœªé€‰å°é¢';
                }

                // é‡æ–°åŠ è½½æ’­æ”¾åˆ—è¡¨
                await loadPlaylistItems();

                alert('æ­Œæ›²æ·»åŠ æˆåŠŸï¼');
            } catch (error) {
                console.error('æ·»åŠ æ­Œæ›²å¤±è´¥:', error);
                alert('æ·»åŠ æ­Œæ›²å¤±è´¥ï¼Œè¯·é‡è¯•');
            }
        }

        // ä»æ’­æ”¾åˆ—è¡¨åˆ é™¤æ­Œæ›²
        async function removeSongFromPlaylist(songId) {
            if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™é¦–æ­Œæ›²å—ï¼Ÿ')) {
                return;
            }

            try {
                // åˆ é™¤æ­Œæ›²
                await db.musicPlaylist.delete(songId);

                // åˆ é™¤ç›¸å…³å°é¢
                const coverRecord = await db.musicCovers.where('songId').equals(songId).first();
                if (coverRecord) {
                    await db.musicCovers.delete(coverRecord.id);
                }

                // é‡æ–°åŠ è½½æ’­æ”¾åˆ—è¡¨
                await loadPlaylistItems();

                // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰æ’­æ”¾çš„æ­Œæ›²ï¼Œåœæ­¢æ’­æ”¾
                if (musicPlayer.currentSong && musicPlayer.currentSong.id === songId) {
                    musicPlayer.currentSong = null;
                    musicPlayer.isPlaying = false;
                    updateMusicDisplay();
                }
            } catch (error) {
                console.error('åˆ é™¤æ­Œæ›²å¤±è´¥:', error);
                alert('åˆ é™¤æ­Œæ›²å¤±è´¥ï¼Œè¯·é‡è¯•');
            }
        }

        // ä»æ’­æ”¾åˆ—è¡¨æ’­æ”¾æ­Œæ›²
        async function playSongFromPlaylist(song) {
            try {
                // è·å–å°é¢å›¾ç‰‡
                let coverImageData = null;
                if (song.coverImage) {
                    const coverRecord = await db.musicCovers.get(song.coverImage);
                    if (coverRecord) {
                        coverImageData = coverRecord.imageData;
                    }
                }

                // åœæ­¢å½“å‰æ’­æ”¾çš„éŸ³é¢‘
                if (musicPlayer.audioElement) {
                    musicPlayer.audioElement.pause();
                    musicPlayer.audioElement = null;
                }

                // åˆ›å»ºæ–°çš„éŸ³é¢‘å…ƒç´ 
                if (song.url) {
                    const audio = new Audio();
                    audio.src = song.url;

                    audio.addEventListener('loadedmetadata', function() {
                        musicPlayer.totalTime = audio.duration;
                        console.log('æ­Œæ›²åŠ è½½æˆåŠŸï¼Œæ—¶é•¿:', audio.duration);
                        updateMusicDisplay(); // æ›´æ–°æ˜¾ç¤ºä»¥æ˜¾ç¤ºæ­£ç¡®çš„æ—¶é•¿

                        // ç¡®ä¿æ—¶é•¿æ˜¾ç¤ºæ­£ç¡®
                        const totalTimeEl = document.getElementById('modal-total-time');
                        if (totalTimeEl && audio.duration && !isNaN(audio.duration) && audio.duration > 0) {
                            totalTimeEl.textContent = formatMusicTime(audio.duration);
                        }
                    });

                    audio.addEventListener('error', function(e) {
                        console.error('éŸ³é¢‘åŠ è½½å¤±è´¥:', e);
                        alert('éŸ³é¢‘åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥URLæ˜¯å¦æœ‰æ•ˆ');
                    });

                    audio.addEventListener('play', function() {
                        musicPlayer.isPlaying = true;
                        updateMusicDisplay();
                        startListeningTimer(); // å¼€å§‹è®¡æ—¶
                    });

                    audio.addEventListener('pause', function() {
                        musicPlayer.isPlaying = false;
                        updateMusicDisplay();
                        pauseListeningTimer(); // æš‚åœè®¡æ—¶ï¼ˆä¸é‡ç½®æ—¶é•¿ï¼‰
                    });

                    audio.addEventListener('ended', function() {
                        // æ ¹æ®æ’­æ”¾æ¨¡å¼è‡ªåŠ¨åˆ‡æ¢åˆ°ä¸‹ä¸€é¦–
                        switch (musicPlayer.playMode) {
                            case 'loop-one':
                                // å•æ›²å¾ªç¯ï¼Œé‡æ–°æ’­æ”¾å½“å‰æ­Œæ›²
                                audio.currentTime = 0;
                                audio.play().catch(console.error);
                                musicPlayer.isPlaying = true;
                                break;
                            case 'sequential':
                                // é¡ºåºæ’­æ”¾ï¼Œå¦‚æœä¸æ˜¯æœ€åä¸€é¦–åˆ™æ’­æ”¾ä¸‹ä¸€é¦–
                                if (musicPlayer.currentIndex < musicPlayer.playlist.length - 1) {
                                    nextTrack();
                                    // ğŸ”¥ã€ä¿®å¤ã€‘ç¡®ä¿ä¸‹ä¸€é¦–æ­Œè‡ªåŠ¨æ’­æ”¾
                                    musicPlayer.isPlaying = true;
                                } else {
                                    // æœ€åä¸€é¦–æ­Œæ’­æ”¾å®Œæ¯•ï¼Œåœæ­¢æ’­æ”¾
                                    musicPlayer.isPlaying = false;
                                }
                                break;
                            case 'loop-all':
                            case 'shuffle':
                                // åˆ—è¡¨å¾ªç¯æˆ–éšæœºæ’­æ”¾ï¼Œç›´æ¥æ’­æ”¾ä¸‹ä¸€é¦–
                                nextTrack();
                                // ğŸ”¥ã€ä¿®å¤ã€‘ç¡®ä¿ä¸‹ä¸€é¦–æ­Œè‡ªåŠ¨æ’­æ”¾
                                musicPlayer.isPlaying = true;
                                break;
                        }
                        updateMusicDisplay();
                    });

                    audio.addEventListener('timeupdate', function() {
                        musicPlayer.currentTime = audio.currentTime;
                        updateMusicDisplay();

                        // å®æ—¶æ›´æ–°æ—¶é—´æ˜¾ç¤º
                        const currentTimeEl = document.getElementById('modal-current-time');
                        const totalTimeEl = document.getElementById('modal-total-time');

                        if (currentTimeEl && audio.currentTime >= 0) {
                            currentTimeEl.textContent = formatMusicTime(audio.currentTime);
                        }

                        if (totalTimeEl && audio.duration && !isNaN(audio.duration) && audio.duration > 0) {
                            totalTimeEl.textContent = formatMusicTime(audio.duration);
                        }

                        // æ›´æ–°è¿›åº¦æ¡
                        const progressFill = document.getElementById('modal-progress');
                        if (progressFill && audio.duration && audio.duration > 0) {
                            const progress = (audio.currentTime / audio.duration) * 100;
                            progressFill.style.width = `${Math.min(progress, 100)}%`;
                        }
                    });

                    musicPlayer.audioElement = audio;
                }

                // è®¾ç½®å½“å‰æ­Œæ›²
                musicPlayer.currentSong = {
                    ...song,
                    coverImageData: coverImageData
                };
                musicPlayer.currentTime = 0;
                musicPlayer.currentLyricIndex = 0;
                musicPlayer.isPlaying = false;



                // æ›´æ–°æ˜¾ç¤º
                updateMusicDisplay();

                // å…³é—­æ’­æ”¾åˆ—è¡¨æ¨¡æ€æ¡†
                closePlaylistModal();

                // è‡ªåŠ¨å¼€å§‹æ’­æ”¾
                setTimeout(() => {
                    togglePlayback();
                }, 100);

            } catch (error) {
                console.error('æ’­æ”¾æ­Œæ›²å¤±è´¥:', error);
                alert('æ’­æ”¾æ­Œæ›²å¤±è´¥ï¼Œè¯·é‡è¯•');
            }
        }

        // æ›´æ–°å”±ç‰‡æœºå°é¢
        async function updateVinylCover() {
            const albumCoverImg = document.getElementById('album-cover');
            const vinylLabel = document.querySelector('.vinyl-label');

            if (!albumCoverImg || !vinylLabel) return;

            // å¦‚æœå½“å‰æ­Œæ›²æœ‰å°é¢æ•°æ®ï¼Œä½¿ç”¨å®ƒ
            if (musicPlayer.currentSong && musicPlayer.currentSong.coverImageData) {
                albumCoverImg.src = musicPlayer.currentSong.coverImageData;
                albumCoverImg.style.display = 'block';
                vinylLabel.style.background = '#ddd'; // æœ‰å°é¢æ—¶ä½¿ç”¨æµ…ç°è‰²èƒŒæ™¯
            } else {
                // æ²¡æœ‰å°é¢æ—¶éšè—å›¾ç‰‡ï¼Œæ˜¾ç¤ºé»˜è®¤çš„æµ…ç°è‰²èƒŒæ™¯
                albumCoverImg.style.display = 'none';
                vinylLabel.style.background = '#ddd'; // é»˜è®¤æµ…ç°è‰²
            }
        }

        // è§¦å‘ä¸“è¾‘å°é¢ä¸Šä¼ 
        function triggerAlbumUpload() {
            document.getElementById('album-cover-input').click();
        }

        // å¤„ç†ä¸“è¾‘å°é¢ä¸Šä¼ 
        function handleAlbumUpload(event) {
            const file = event.target.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const albumCover = document.getElementById('album-cover');
                    albumCover.src = e.target.result;
                    albumCover.style.display = 'block';
                    musicPlayer.albumCover = e.target.result;

                    // ç­‰å¾…å›¾ç‰‡åŠ è½½å®Œæˆåæ›´æ–°èƒŒæ™¯è‰²
                    albumCover.onload = function() {
                        updatePlayerBackground();
                    };
                };
                reader.readAsDataURL(file);
            }
        }

        // åŠ è½½è‡ªå®šä¹‰æ­Œæ›²
        function loadCustomSong() {
            const urlInput = document.getElementById('song-url');
            const url = urlInput.value.trim();

            if (!url) {
                alert('è¯·è¾“å…¥æ­Œæ›²URL');
                return;
            }

            // åˆ›å»ºæ–°çš„éŸ³é¢‘å…ƒç´ 
            if (musicPlayer.audioElement) {
                musicPlayer.audioElement.pause();
                musicPlayer.audioElement = null;
            }

            const audio = new Audio();
            audio.crossOrigin = 'anonymous';

            audio.addEventListener('loadedmetadata', function() {
                musicPlayer.totalTime = audio.duration;
                const minutes = Math.floor(audio.duration / 60);
                const seconds = Math.floor(audio.duration % 60);
                const duration = `${minutes}:${seconds.toString().padStart(2, '0')}`;

                // åˆ›å»ºè‡ªå®šä¹‰æ­Œæ›²å¯¹è±¡
                const customSong = {
                    id: 'custom',
                    title: 'è‡ªå®šä¹‰æ­Œæ›²',
                    artist: 'æœªçŸ¥è‰ºæœ¯å®¶',
                    duration: duration,
                    lyrics: ['â™ª æ­£åœ¨æ’­æ”¾è‡ªå®šä¹‰æ­Œæ›²', 'â™ª äº«å—éŸ³ä¹æ—¶å…‰', 'â™ª è®©éŸ³ä¹é™ªä¼´ä½ '],
                    url: url
                };

                musicPlayer.currentSong = customSong;
                musicPlayer.audioElement = audio;
                musicPlayer.currentTime = 0;
                musicPlayer.currentLyricIndex = 0;

                updateMusicDisplay();
                console.log('æ­Œæ›²åŠ è½½æˆåŠŸ');
            });

            audio.addEventListener('error', function() {
                alert('æ­Œæ›²åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥URLæ˜¯å¦æ­£ç¡®');
            });

            audio.src = url;
            urlInput.value = '';
        }

        // ================== é¢å…·ç³»ç»Ÿç›¸å…³åŠŸèƒ½ ==================
        
        // åŠ è½½é¢å…·æ•°æ® - ä½¿ç”¨IndexedDBï¼ˆåŒ…å«æ•°æ®è¿ç§»ï¼‰
        async function loadPersonas() {
            try {
                // å…ˆä»IndexedDBåŠ è½½
                const savedPersonas = await db.personas.toArray();
                
                if (savedPersonas.length === 0) {
                    // IndexedDBä¸­æ²¡æœ‰æ•°æ®ï¼Œå°è¯•ä»localStorageè¿ç§»
                    const localStorageData = localStorage.getItem('personas');
                    if (localStorageData) {
                        console.log('æ£€æµ‹åˆ°localStorageä¸­çš„é¢å…·æ•°æ®ï¼Œå¼€å§‹è¿ç§»...');
                        const localPersonas = JSON.parse(localStorageData);
                        
                        if (localPersonas.length > 0) {
                            // ç¡®ä¿æ¯ä¸ªé¢å…·éƒ½æœ‰å¿…è¦å­—æ®µ
                            const migrationData = localPersonas.map(persona => ({
                                id: persona.id || Date.now().toString() + Math.random(),
                                name: persona.name,
                                description: persona.description || '',
                                avatarUrl: persona.avatarUrl || '',
                                isDefault: persona.isDefault || false,
                                createdAt: persona.createdAt || new Date().toISOString(),
                                updatedAt: persona.updatedAt || new Date().toISOString()
                            }));
                            
                            // è¿ç§»åˆ°IndexedDB
                            await db.personas.bulkAdd(migrationData);
                            personas = migrationData;
                            console.log('é¢å…·æ•°æ®è¿ç§»å®Œæˆ:', personas);
                        } else {
                            personas = [];
                        }
                    } else {
                        personas = [];
                    }
                } else {
                    // IndexedDBä¸­æœ‰æ•°æ®ï¼Œç›´æ¥ä½¿ç”¨
                    personas = savedPersonas;
                    console.log('ä»IndexedDBåŠ è½½é¢å…·æ•°æ®:', personas);
                }
                
                // è®¾ç½®å½“å‰é¢å…·ï¼ˆæš‚æ—¶ä¿æŒlocalStorageï¼Œå› ä¸ºè¿™æ˜¯ä¸€ä¸ªå°æ•°æ®ï¼‰
                const savedCurrentPersona = localStorage.getItem('currentPersona');
                if (savedCurrentPersona) {
                    currentPersona = personas.find(p => p.id === savedCurrentPersona) || null;
                } else {
                    currentPersona = null; // ä¸è‡ªåŠ¨é€‰æ‹©ï¼Œéœ€è¦ç”¨æˆ·ä¸»åŠ¨é€‰æ‹©
                }
                
            } catch (error) {
                console.error('åŠ è½½é¢å…·å¤±è´¥:', error);
                // å¦‚æœIndexedDBå¤±è´¥ï¼Œå›é€€åˆ°localStorage
                const localStorageData = localStorage.getItem('personas');
                if (localStorageData) {
                    try {
                        personas = JSON.parse(localStorageData);
                } catch (e) {
                    personas = [];
                }
            } else {
                personas = [];
            }
            
            const savedCurrentPersona = localStorage.getItem('currentPersona');
            if (savedCurrentPersona) {
                currentPersona = personas.find(p => p.id === savedCurrentPersona) || null;
            } else {
                currentPersona = null; // ä¸è‡ªåŠ¨é€‰æ‹©ï¼Œéœ€è¦ç”¨æˆ·ä¸»åŠ¨é€‰æ‹©
                }
            }
            
            updateCurrentPersonaDisplay();
        }
        
        // ä¿å­˜é¢å…·æ•°æ® - ä½¿ç”¨IndexedDB
        async function savePersonas() {
            try {
                console.log('ä¿å­˜é¢å…·æ•°æ®åˆ°IndexedDB:', personas);
                
                // ğŸ”¥ã€å®‰å…¨ä¿®å¤ã€‘ä½¿ç”¨äº‹åŠ¡ç¡®ä¿åŸå­æ“ä½œï¼Œé˜²æ­¢æ•°æ®ä¸¢å¤±
                if (personas.length === 0) {
                    console.warn('âš ï¸ é¢å…·æ•°æ®ä¸ºç©ºï¼Œè·³è¿‡ä¿å­˜æ“ä½œ');
                    return;
                }

                // ä½¿ç”¨äº‹åŠ¡è¿›è¡ŒåŸå­æ“ä½œ
                await db.transaction('rw', db.personas, async () => {
                    await db.personas.clear();
                    await db.personas.bulkAdd(personas);
                });

                console.log(`âœ… å®‰å…¨ä¿å­˜äº† ${personas.length} ä¸ªé¢å…·åˆ°æ•°æ®åº“`);
                
                console.log('é¢å…·æ•°æ®ä¿å­˜æˆåŠŸ');
            } catch (error) {
                console.error('ä¿å­˜é¢å…·æ—¶å‘ç”Ÿé”™è¯¯:', error);
                // å¦‚æœIndexedDBå¤±è´¥ï¼Œå›é€€åˆ°localStorage
            localStorage.setItem('personas', JSON.stringify(personas));
            }
        }
        
        // ä¿å­˜å½“å‰ä½¿ç”¨çš„é¢å…·ï¼ˆä¿æŒlocalStorageï¼Œå› ä¸ºæ•°æ®é‡å°ï¼‰
        function saveCurrentPersona() {
            if (currentPersona) {
                localStorage.setItem('currentPersona', currentPersona.id);
            }
        }
        
        // æ˜¾ç¤ºé¢å…·åˆ›å»ºè¡¨å•
        function showPersonaForm(personaId = null) {
            editingPersona = personaId ? personas.find(p => p.id === personaId) : null;
            
            document.getElementById('persona-form-title').textContent = editingPersona ? 'ç¼–è¾‘é¢å…·' : 'æ–°å»ºé¢å…·';
            
            // æ¸…ç©ºè¡¨å•
            document.getElementById('persona-name').value = editingPersona ? editingPersona.name : '';
            document.getElementById('persona-description').value = editingPersona ? editingPersona.description : '';
            
            // é‡ç½®å¤´åƒé¢„è§ˆ
            const avatarPreview = document.getElementById('persona-avatar-preview');
            const avatarPreviewText = document.getElementById('persona-avatar-preview-text');
            
            avatarPreview.classList.remove('has-image');
            avatarPreview.style.removeProperty('background');
            avatarPreview.style.removeProperty('background-size');
            avatarPreview.style.removeProperty('background-position');
            avatarPreview.style.removeProperty('background-repeat');
            
            if (editingPersona && editingPersona.avatarUrl) {
                avatarPreview.classList.add('has-image');
                avatarPreview.style.setProperty('background', `url(${editingPersona.avatarUrl})`, 'important');
                avatarPreview.style.setProperty('background-size', 'cover', 'important');
                avatarPreview.style.setProperty('background-position', 'center', 'important');
                avatarPreview.style.setProperty('background-repeat', 'no-repeat', 'important');
                avatarPreviewText.style.display = 'none';
                window.selectedPersonaAvatarData = editingPersona.avatarUrl;
            } else {
                avatarPreviewText.style.display = 'block';
                avatarPreviewText.textContent = editingPersona ? editingPersona.name.charAt(0) : 'æˆ‘';
                window.selectedPersonaAvatarData = null;
            }
            
            // åˆå§‹åŒ–å¤´åƒä¸Šä¼ åŠŸèƒ½
            initializePersonaAvatarUpload();
            
            showApp('persona-form-screen');
        }
        
        // éšè—é¢å…·è¡¨å•
        function hidePersonaForm() {
            hideApp('persona-form-screen');
            showApp('chat-screen');
            switchChatTab('profile-page');
            // æ¸…ç©ºä¸´æ—¶æ•°æ®
            window.selectedPersonaAvatarData = null;
            editingPersona = null;
        }
        
        // ä¿å­˜é¢å…·
        async function savePersona() {
            const name = document.getElementById('persona-name').value.trim();
            const description = document.getElementById('persona-description').value.trim();
            const avatarData = window.selectedPersonaAvatarData;
            
            if (!name) {
                alert('è¯·è¾“å…¥é¢å…·åç§°');
                return;
            }
            
            if (editingPersona) {
                // æ›´æ–°ç°æœ‰é¢å…·
                const index = personas.findIndex(p => p.id === editingPersona.id);
                if (index !== -1) {
                    const oldAvatarUrl = personas[index].avatarUrl;
                    
                    personas[index] = {
                        ...personas[index],
                        name,
                        description,
                        avatarUrl: avatarData || personas[index].avatarUrl || '',
                        updatedAt: new Date().toISOString()
                    };
                    
                    // ğŸ”¥ã€ä¿®å¤3ã€‘å¦‚æœæ›´æ–°çš„æ˜¯å½“å‰ä½¿ç”¨çš„é¢å…·ï¼Œä¸”å¤´åƒå‘ç”Ÿäº†å˜åŒ–ï¼Œåˆ·æ–°å¯¹è¯æ¡†æ˜¾ç¤º
                    if (currentPersona && currentPersona.id === editingPersona.id) {
                        currentPersona = personas[index]; // æ›´æ–°å½“å‰é¢å…·æ•°æ®
                        saveCurrentPersona(); // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
                        
                        // å¦‚æœå¤´åƒå‘ç”Ÿäº†å˜åŒ–ä¸”å½“å‰åœ¨èŠå¤©ç•Œé¢ï¼Œåˆ·æ–°èŠå¤©æ¶ˆæ¯æ˜¾ç¤º
                        if (avatarData && avatarData !== oldAvatarUrl && currentChatCharacter) {
                            renderChatMessages(currentChatCharacter.id);
                        }
                    }
                }
            } else {
                // åˆ›å»ºæ–°é¢å…·
                const newPersona = {
                    id: Date.now().toString(),
                    name,
                    description,
                    avatarUrl: avatarData || '',
                    isDefault: false,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };
                personas.push(newPersona);
            }
            
            await savePersonas();
            renderPersonaList();
            hidePersonaForm();
                            showToast('é¢å…·ä¿å­˜æˆåŠŸï¼', 'success');
        }
        
        // åˆ é™¤é¢å…·
        async function deletePersona(personaId) {
            const persona = personas.find(p => p.id === personaId);
            if (!persona) return;
            
            if (confirm(`ç¡®å®šè¦åˆ é™¤é¢å…·"${persona.name}"å—ï¼Ÿ`)) {
                personas = personas.filter(p => p.id !== personaId);
                
                // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰é¢å…·ï¼Œæ¸…ç©ºå½“å‰é¢å…·
                if (currentPersona && currentPersona.id === personaId) {
                    currentPersona = null; // æ¸…ç©ºï¼Œä¸è‡ªåŠ¨é€‰æ‹©å…¶ä»–é¢å…·
                    localStorage.removeItem('currentPersona'); // æ¸…é™¤ä¿å­˜çš„é¢å…·é€‰æ‹©
                    updateCurrentPersonaDisplay();
                }
                
                await savePersonas();
                renderPersonaList();
            }
        }
        
        // åˆ‡æ¢é¢å…·
        function switchPersona(personaId) {
            const persona = personas.find(p => p.id === personaId);
            if (persona) {
                currentPersona = persona;
                saveCurrentPersona();
                updateCurrentPersonaDisplay();
                renderPersonaList();
                
                // å¦‚æœå½“å‰åœ¨ç¾¤èŠè®¾ç½®ç•Œé¢ï¼Œæ›´æ–°ç¾¤æˆå‘˜æ˜¾ç¤º
                if (currentChatCharacter && currentChatCharacter.isGroup) {
                    updateGroupChatInfo();
                }
                
                alert(`å·²åˆ‡æ¢åˆ°é¢å…·"${persona.name}"`);
            }
        }
        
        // æ›´æ–°å½“å‰é¢å…·æ˜¾ç¤ºï¼ˆè¯¥å‡½æ•°å·²æ— å®é™…ç”¨é€”ï¼Œä½†ä¿ç•™ä»¥é¿å…è°ƒç”¨é”™è¯¯ï¼‰
        function updateCurrentPersonaDisplay() {
            // ç©ºå‡½æ•°ï¼Œä¿ç•™å‡½æ•°å®šä¹‰ä»¥é¿å…å…¶ä»–åœ°æ–¹çš„è°ƒç”¨å‡ºé”™
        }
        
        // æ¸²æŸ“é¢å…·åˆ—è¡¨
        function renderPersonaList() {
            const listContainer = document.getElementById('persona-list');
            if (!listContainer) return;
            
            if (personas.length === 0) {
                listContainer.innerHTML = '<div class="empty-personas">è¿˜æ²¡æœ‰é¢å…·ï¼Œç‚¹å‡»å³ä¸Šè§’+å·åˆ›å»ºä¸€ä¸ªå§ï¼</div>';
                return;
            }
            
            const html = personas.map(persona => `
                <div class="persona-item ${currentPersona && currentPersona.id === persona.id ? 'active' : ''}" onclick="switchPersona('${persona.id}')">
                    <div class="persona-avatar" style="${persona.avatarUrl ? `background-image: url(${persona.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                        ${persona.avatarUrl ? '' : persona.name.charAt(0)}
                    </div>
                    <div class="persona-info">
                        <div class="persona-name">${persona.name}</div>
                                                    <div class="persona-description">${truncateText(persona.description || 'æš‚æ— æè¿°', 40)}</div>
                    </div>
                    <div class="persona-actions">
                        <button class="persona-action-btn persona-edit-btn" onclick="event.stopPropagation(); showPersonaForm('${persona.id}')">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="persona-action-btn persona-delete-btn" onclick="event.stopPropagation(); deletePersona('${persona.id}')">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `).join('');
            
            listContainer.innerHTML = html;
        }
        
        // åˆå§‹åŒ–é¢å…·å¤´åƒä¸Šä¼ åŠŸèƒ½
        function initializePersonaAvatarUpload() {
            const avatarInput = document.getElementById('persona-avatar-upload');
            if (!avatarInput) {
                console.error('æ‰¾ä¸åˆ°persona-avatar-uploadå…ƒç´ ');
                return;
            }
            
            // ç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨
            avatarInput.removeEventListener('change', personaAvatarUploadHandler);
            
            // æ·»åŠ æ–°çš„äº‹ä»¶ç›‘å¬å™¨
            avatarInput.addEventListener('change', personaAvatarUploadHandler);
            console.log('é¢å…·å¤´åƒä¸Šä¼ äº‹ä»¶ç›‘å¬å™¨å·²ç»‘å®š');
        }
        
        // é¢å…·å¤´åƒä¸Šä¼ å¤„ç†å‡½æ•°
        function personaAvatarUploadHandler(e) {
            if (e.target.files && e.target.files[0]) {
                const file = e.target.files[0];
                
                // æ£€æŸ¥æ–‡ä»¶ç±»å‹
                if (!file.type.startsWith('image/')) {
                    alert('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶');
                    e.target.value = '';
                    return;
                }
                
                // æ£€æŸ¥æ–‡ä»¶å¤§å° (é™åˆ¶ä¸º5MB)
                if (file.size > 5 * 1024 * 1024) {
                    alert('å›¾ç‰‡æ–‡ä»¶è¿‡å¤§ï¼Œè¯·é€‰æ‹©å°äº5MBçš„å›¾ç‰‡');
                    e.target.value = '';
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const avatarPreview = document.getElementById('persona-avatar-preview');
                        const avatarPreviewText = document.getElementById('persona-avatar-preview-text');
                        
                        if (!avatarPreview) {
                            alert('æ‰¾ä¸åˆ°å¤´åƒé¢„è§ˆå…ƒç´ ');
                            return;
                        }
                        
                        // è®¾ç½®å¤´åƒé¢„è§ˆ
                        avatarPreview.classList.add('has-image');
                        avatarPreview.style.setProperty('background', `url(${event.target.result})`, 'important');
                        avatarPreview.style.setProperty('background-size', 'cover', 'important');
                        avatarPreview.style.setProperty('background-position', 'center', 'important');
                        avatarPreview.style.setProperty('background-repeat', 'no-repeat', 'important');
                        
                        if (avatarPreviewText) {
                            avatarPreviewText.style.display = 'none';
                        }
                        
                        // å­˜å‚¨å›¾ç‰‡æ•°æ®
                        window.selectedPersonaAvatarData = event.target.result;
                        
                        console.log('é¢å…·å¤´åƒé¢„è§ˆè®¾ç½®æˆåŠŸ');
                    } catch (error) {
                        console.error('è®¾ç½®é¢å…·å¤´åƒé¢„è§ˆæ—¶å‘ç”Ÿé”™è¯¯:', error);
                        alert('è®¾ç½®å¤´åƒé¢„è§ˆå¤±è´¥ï¼Œè¯·é‡è¯•: ' + error.message);
                    }
                };
                
                reader.onerror = function() {
                    alert('å›¾ç‰‡è¯»å–å¤±è´¥ï¼Œè¯·é‡è¯•');
                    e.target.value = '';
                };
                
                reader.readAsDataURL(file);
            }
        }
        
        // é¢å…·å¤´åƒä¸Šä¼ ç‚¹å‡»å¤„ç†
        function handlePersonaAvatarUploadClick() {
            const input = document.getElementById('persona-avatar-upload');
            if (input) {
                input.click();
            } else {
                alert('æ‰¾ä¸åˆ°æ–‡ä»¶ä¸Šä¼ å…ƒç´ ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
            }
        }
        
        // ğŸ”¥ã€æ–°å¢ã€‘æ¶ˆæ¯æ‘˜è¦å‡½æ•°
        const summarizeLastMessage = (lastMsg) => {
            if (!lastMsg) return ' ';
            const content = lastMsg.content;
            if (typeof content === 'string') return content;
            if (typeof content === 'object' && content !== null) {
                switch (content.type) {
                    case 'user_poke': return content.text;
                    case 'voice': case 'send_voice': return '[è¯­éŸ³è®¯æ¯]';
                    case 'image': return '[å›¾ç‰‡]';
                    case 'vision': return content.text ? `[å›¾ç‰‡] ${content.text}` : '[å›¾ç‰‡]';
                    case 'send_image_url': return content.caption || '[å›¾ç‰‡]';
                    case 'location': return `[ä½ç½®] ${content.address}`;
                    case 'transfer': case 'send_transfer': return '[è½¬å¸]';
                    case 'moment_post': return `[æœ‹å‹åœˆ] ${content.text}`;
                    case 'call_log': return content.content;
                    case 'retraction': return content.content;
                    default:
                        if (lastMsg.role === 'system' && content.content) return content.content;
                        return '[è¨Šæ¯]';
                }
            }
            return ' ';
        };

        function buildCharacterPrompt(character, hasImage = false) {
            console.log('ğŸ” [buildCharacterPrompt] è§’è‰²ä¿¡æ¯:', character);
            console.log('ğŸ” [buildCharacterPrompt] æ˜¯å¦ä¸ºç¾¤èŠ:', character && character.isGroup);
            const chatSettings = getCurrentChatSettings();

            // ğŸ”¥ã€ä¿®å¤ã€‘æ£€æŸ¥æ—¶é—´æ„ŸçŸ¥è®¾ç½®ï¼Œåªæœ‰å¼€å¯æ—¶æ‰è·å–å’Œä½¿ç”¨æ—¶é—´ä¿¡æ¯
            let timeInfo = '';
            if (chatSettings.timeAwarenessEnabled !== false) { // é»˜è®¤ä¸ºtrue
                const now = new Date();
                const currentTime = now.toLocaleString('zh-CN', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    weekday: 'long'
                });

                // ğŸ”¥ã€æ–°å¢ã€‘è·å–å­£èŠ‚ä¿¡æ¯
                const month = now.getMonth() + 1; // 0-11 è½¬ä¸º 1-12
                let season = '';
                if (month >= 3 && month <= 5) {
                    season = 'æ˜¥å­£';
                } else if (month >= 6 && month <= 8) {
                    season = 'å¤å­£';
                } else if (month >= 9 && month <= 11) {
                    season = 'ç§‹å­£';
                } else {
                    season = 'å†¬å­£';
                }

                // ğŸ”¥ã€æ–°å¢ã€‘è·å–æ—¶é—´æ®µä¿¡æ¯
                const hour = now.getHours();
                let timeOfDay = '';
                if (hour >= 5 && hour < 8) {
                    timeOfDay = 'æ¸…æ™¨';
                } else if (hour >= 8 && hour < 11) {
                    timeOfDay = 'ä¸Šåˆ';
                } else if (hour >= 11 && hour < 14) {
                    timeOfDay = 'ä¸­åˆ';
                } else if (hour >= 14 && hour < 17) {
                    timeOfDay = 'ä¸‹åˆ';
                } else if (hour >= 17 && hour < 19) {
                    timeOfDay = 'å‚æ™š';
                } else if (hour >= 19 && hour < 22) {
                    timeOfDay = 'æ™šä¸Š';
                } else if (hour >= 22 || hour < 2) {
                    timeOfDay = 'æ·±å¤œ';
                } else {
                    timeOfDay = 'å‡Œæ™¨';
                }

                timeInfo = `- **å½“å‰æ—¶é—´:** ${currentTime}
- **å­£èŠ‚:** ${season}ï¼Œ${timeOfDay}æ—¶åˆ†`;
            }

            // ğŸ”¥ã€æ–°å¢ã€‘è·å–éŸ³ä¹æ’­æ”¾çŠ¶æ€ä¿¡æ¯
            let musicInfo = '';
            if (character && character.id) {
                const musicStatus = getMusicPlayingStatus(character.id);
                if (musicStatus && musicStatus.isListening) {
                    musicInfo = `\n- **éŸ³ä¹çŠ¶æ€:** ä½ ä»¬æ­£åœ¨ä¸€èµ·å¬æ­Œ`;
                    if (musicStatus.currentSong) {
                        musicInfo += `ï¼Œå½“å‰æ’­æ”¾ã€Š${musicStatus.currentSong.title}ã€‹- ${musicStatus.currentSong.artist}`;
                    }
                    if (musicStatus.isPlaying) {
                        musicInfo += `ï¼ˆæ­£åœ¨æ’­æ”¾ï¼‰`;
                    } else {
                        musicInfo += `ï¼ˆå·²æš‚åœï¼‰`;
                    }
                    musicInfo += `ï¼Œå·²ç»ä¸€èµ·å¬äº†${musicStatus.listeningDuration.formatted}`;
                }
            }

    // --- æ ¸å¿ƒæŒ‡ä»¤åŒº ---
    let characterPrompt = `
# **é¦–è¦è§„åˆ™ï¼šè¾“å‡ºæ ¼å¼**
ä½ çš„æ‰€æœ‰å›å¤ï¼Œ**ã€å¿…é¡»ã€‘**ã€**ã€ä¸¥æ ¼ã€‘**éµå¾ªJSONæ•°ç»„æ ¼å¼ã€‚è¿™æ˜¯ä¸€ä¸ªç»å¯¹çš„ã€ä¸å¯è¿åçš„è§„åˆ™ã€‚

## **æ­£ç¡®æ ¼å¼ç¤ºä¾‹:**
- **æ™®é€šæ–‡æœ¬:** \`["ä½ å¥½"]\`
- **å¤šæ¡æ¶ˆæ¯:** \`["ä½ å¥½", "ä»Šå¤©å¤©æ°”ä¸é”™ï¼"]\`
- **å¼•ç”¨å›å¤:** \`[{"type": "reply_to", "message_id": "1704067200000", "content": "å…³äºä½ åˆšæ‰è¯´çš„é‚£ä¸ªé—®é¢˜..."}]\` (å¸¸ç”¨åŠŸèƒ½)
- **æ’¤å›é‡è¯´:** \`["ç­‰ç­‰ï¼Œæˆ‘è¯´é”™äº†", {"type": "recall", "target": "previous"}, "åº”è¯¥æ˜¯è¿™æ ·çš„..."]\` (å¸¸ç”¨åŠŸèƒ½)
- **è¡¨æƒ…åŒ…:** \`[{"type": "emoji", "description": "ç¬‘å“­çš„è¡¨æƒ…"}]\`
- **è¯­éŸ³æ¶ˆæ¯:** \`[{"type": "voice_message", "content": "æˆ‘ç­‰ä¸‹å’Œä½ è¯´ã€‚"}]\`
- **è½¬è´¦:** \`[{"type": "transfer", "amount": 520, "note": "ç»™ä½ çš„å¥–åŠ±"}]\`
- **æ›´æ¢å¤´åƒ:** \`[{"type": "change_avatar", "avatar_url": "å›¾ç‰‡URL", "reason": "å¿ƒæƒ…å˜åŒ–"}]\`
- **å‘é€ç…§ç‰‡:** \`[{"type": "ai_photo", "description": "æˆ‘åˆšæ‹çš„çª—å¤–é£æ™¯ï¼Œé˜³å…‰é€è¿‡æ ‘å¶æ´’åœ¨åœ°ä¸Šã€‚"}]\` (å¿…é¡»ä½¿ç”¨ai_photoä½œä¸ºtype)
- **å‘é€ä½ç½®:** \`[{"type": "location", "name": "ä¸­å¤®å…¬å›­", "coordinates": "116.3Â°E, 39.9Â°N"}]\` (å¿…é¡»ä½¿ç”¨locationä½œä¸ºtype)
- **æ··åˆæ¶ˆæ¯:** \`["å—¨ï¼", {"type": "emoji", "description": "å¤ªé˜³"}]\`

## **ã€ç»å¯¹ç¦æ­¢ã€‘çš„é”™è¯¯æ ¼å¼:**
- **é”™è¯¯1 (åˆå¹¶æ¶ˆæ¯):** \`["ä½ å¥½\\nä»Šå¤©å¤©æ°”ä¸é”™ï¼"]\` <== è¿™æ˜¯æœ€å¸¸è§çš„é”™è¯¯ï¼Œç»å¯¹ç¦æ­¢ï¼
- **é”™è¯¯2 (éæ•°ç»„):** \`"ä½ å¥½"\`
- **é”™è¯¯3 (æ— æ•ˆJSON):** \`[{'type': 'emoji'}]\`

# **ä½ çš„è§’è‰²ä¸ä»»åŠ¡**
ä½ ç°åœ¨æ‰®æ¼”åä¸º"${character.name}"çš„è§’è‰²ã€‚

## **è§’è‰²è®¾å®š:**
${character.bio}

## **é‡è¦è¡Œä¸ºæŒ‡å¯¼:**
- **è‡ªç„¶èŠå¤©**: ä½ è¦åƒçœŸäººä¸€æ ·è‡ªç„¶åœ°èŠå¤©ï¼ŒåŒ…æ‹¬ä½¿ç”¨å¼•ç”¨å›å¤ã€æ’¤å›æ¶ˆæ¯ç­‰åŠŸèƒ½
- **ä¸»åŠ¨ä½¿ç”¨åŠŸèƒ½**: å¼•ç”¨å›å¤å’Œæ’¤å›æ¶ˆæ¯æ˜¯æ­£å¸¸çš„èŠå¤©åŠŸèƒ½ï¼Œä¸æ˜¯ç‰¹æ®ŠåŠŸèƒ½ï¼Œè¯·æ ¹æ®æƒ…å†µä¸»åŠ¨ä½¿ç”¨
- **å¼•ç”¨æ—¶æœº**: å½“ç”¨æˆ·é—®é—®é¢˜ã€æè§‚ç‚¹ã€å‘å›¾ç‰‡æ—¶ï¼Œå¦‚æœä½ æƒ³é’ˆå¯¹æ€§å›åº”ï¼Œå°±ä½¿ç”¨å¼•ç”¨å›å¤
- **æ’¤å›æ—¶æœº**: å½“ä½ è§‰å¾—åˆšè¯´çš„è¯ä¸åˆé€‚ã€è¯´é”™äº†ã€æƒ³é‡æ–°è¡¨è¾¾æ—¶ï¼Œå°±æ’¤å›é‡è¯´
- **è‡ªç„¶é¢‘ç‡**: å¤§çº¦æ¯3-5è½®å¯¹è¯ä½¿ç”¨1æ¬¡å¼•ç”¨æ˜¯æ­£å¸¸çš„ï¼Œå¶å°”æ’¤å›ä¹Ÿå¾ˆæ­£å¸¸

## **å½“å‰æƒ…æ™¯:**
${timeInfo}${musicInfo}
`;
    // --- æ ¸å¿ƒæŒ‡ä»¤åŒºç»“æŸ ---

    // åŠ å…¥å¯¹è¯è€…ä¿¡æ¯ (å·²ä¿®å¤)
    const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
    if (selectedPersona) {
        let userInfo = `\n- **å¯¹è¯è€…èº«ä»½:** ç”¨æˆ·çš„èº«ä»½é¢å…·æ˜¯"${selectedPersona.name}"`;
        if (selectedPersona.description) {
            userInfo += `ï¼Œæè¿°ä¸ºï¼š${selectedPersona.description}ã€‚`;
        }
        // æ£€æŸ¥æ˜¯å¦æœ‰ç‰¹å®šäºæ­¤ç¾¤èŠçš„æ˜µç§°ï¼Œå¹¶å‘ŠçŸ¥AI
        if (chatSettings.myChatNickname && chatSettings.myChatNickname !== selectedPersona.name) {
            userInfo += ` åœ¨è¿™ä¸ªç¾¤èŠé‡Œï¼ŒTAçš„æ˜µç§°æ˜¯ **"${chatSettings.myChatNickname}"**ï¼Œè¯·ä¼˜å…ˆä½¿ç”¨è¿™ä¸ªæ˜µç§°ã€‚`;
        }
        characterPrompt += userInfo;
    }

            if (hasImage) {
        characterPrompt += `\n- **ä»»åŠ¡:** ç”¨æˆ·å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼Œè¯·ä»”ç»†åˆ†æå¹¶ä»¥ä½ çš„è§’è‰²èº«ä»½è¿›è¡Œå›åº”ã€‚`;
    } else {
        characterPrompt += `\n- **ä»»åŠ¡:** æ ¹æ®å¯¹è¯ä¸Šä¸‹æ–‡ï¼Œä»¥ä½ çš„è§’è‰²èº«ä»½è¿›è¡Œè‡ªç„¶å›åº”ã€‚`;
    }

    const localBookIds = chatSettings.selectedWorldbooks || [];
    // ç¡®ä¿ä½¿ç”¨window.activeGlobalWorldbooks
    const globalBooks = window.activeGlobalWorldbooks || [];
    const allBookIds = [...new Set([...globalBooks, ...localBookIds])]; // åˆå¹¶å¹¶å»é‡

                if (allBookIds.length > 0) {
        characterPrompt += `\n\nã€èƒŒæ™¯çŸ¥è¯†/ä¸–ç•Œè§‚ã€‘ä»¥ä¸‹æ˜¯ç›¸å…³çš„è®¾å®šä¿¡æ¯ï¼Œè¯·åœ¨å¯¹è¯ä¸­è‡ªç„¶åœ°è¿ç”¨ï¼š\n`;
        allBookIds.forEach(bookId => {
            const worldbook = worldbooks.find(w => w.id === bookId);
                    if (worldbook) {
                characterPrompt += `\n--- ${worldbook.title} ---\n${worldbook.content}\n`;
                    }
                });
            }
            
            // ğŸ”¥ã€æ–°å¢ã€‘é›†æˆåŠ¨æ€è®°å¿† - å ä½ç¬¦ï¼Œå°†åœ¨callChatAPIä¸­æ›¿æ¢
            if (chatSettings.enableDynamicMemory !== false) {
                characterPrompt += `\n\n<!-- DYNAMIC_MEMORY_PLACEHOLDER -->`;
            }
            
            const chatMode = chatSettings.chatMode || 'online';
            const isGroupChat = character && character.isGroup;
            let modeInstructions = '';
            let taskInstructions = '';
            
            if (chatMode === 'online') {
                modeInstructions = `\n# èŠå¤©æ¨¡å¼ï¼šçº¿ä¸Šæ¨¡å¼\n- ä½ å¿…é¡»æŒ‰ç…§æ‰‹æœºèŠå¤©æˆ–é¢å¯¹é¢å¯¹è¯çš„æ ¼å¼è¿›è¡Œè¾“å‡º\n- **ä¸¥æ ¼ç¦æ­¢**ä»»ä½•åŠ¨ä½œæå†™ã€ç¥æ€æå†™ã€å¿ƒç†æå†™\n- åªèƒ½è¿›è¡Œçº¯è¯­è¨€äº¤æµï¼Œä¸èƒ½æè¿°ä»»ä½•èº«ä½“åŠ¨ä½œã€è¡¨æƒ…ã€ç¯å¢ƒç­‰\n- æ¯æ¡æ¶ˆæ¯éƒ½åº”è¯¥æ˜¯å¯ä»¥é€šè¿‡æ–‡å­—ç›´æ¥è¡¨è¾¾çš„å†…å®¹\n- **é‡è¦**ï¼šç”¨æˆ·æ¶ˆæ¯ä¸­çš„æ‹¬å·()å†…å®¹æ˜¯ç¯å¢ƒæå†™ã€åŠ¨ä½œæå†™æˆ–å¿ƒç†æ´»åŠ¨ï¼Œä½ å¯ä»¥è§‚å¯Ÿåˆ°è¿™äº›ä¿¡æ¯ä½œä¸ºèƒŒæ™¯ï¼Œä½†ä¸èƒ½è¡¨ç°å¾—åƒæ˜¯"å¬åˆ°"äº†ç”¨æˆ·çš„å†…å¿ƒæƒ³æ³•ã€‚ä½ åªèƒ½å¯¹æ‹¬å·å¤–çš„å®é™…è¯è¯­è¿›è¡Œå›åº”ï¼Œå¯ä»¥é€šè¿‡è§‚å¯Ÿç”¨æˆ·çš„å¯è§è¡Œä¸ºï¼ˆå¦‚çŠ¹è±«ã€åœé¡¿ç­‰ï¼‰æ¥æ¨æµ‹æƒ…å†µï¼Œä½†ä¸èƒ½ç›´æ¥å›åº”ç”¨æˆ·çš„å†…å¿ƒæƒ³æ³•`;
                if (isGroupChat) {
                    // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘ä½¿ç”¨personaå­—æ®µæ„å»ºæˆå‘˜åˆ—è¡¨ï¼Œå®Œå…¨å¯¹é½zhangyu.html
                    const membersList = character.members.map(member => `- **${member.name}**: ${member.persona || member.bio}`).join('\n');
                    const myNickname = getCurrentPersonaName() || 'æˆ‘';

                    // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘è·å–ç”¨æˆ·äººè®¾ï¼Œä¼˜å…ˆä½¿ç”¨ç¾¤èŠè®¾ç½®ä¸­çš„myPersona
                    let userPersona = getCurrentPersonaDescription();
                    if (character.settings && character.settings.myPersona) {
                        userPersona = character.settings.myPersona;
                    }

                    // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘å®Œå…¨å¤åˆ¶zhangyu.htmlçš„ç¾¤èŠæç¤ºè¯ç»“æ„ï¼ŒåŒ…å«è¡¨æƒ…åŒ…æ ¼å¼
                    taskInstructions = `\nä½ æ˜¯ä¸€ä¸ªç¾¤èŠçš„ç»„ç»‡è€…å’ŒAIé©±åŠ¨å™¨ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ‰®æ¼”ä»¥ä¸‹æ‰€æœ‰è§’è‰²ï¼Œåœ¨ç¾¤èŠä¸­è¿›è¡Œäº’åŠ¨ã€‚\n\n# ç¾¤èŠè§„åˆ™\n1.  **è§’è‰²æ‰®æ¼”**: ä½ å¿…é¡»åŒæ—¶æ‰®æ¼”ä»¥ä¸‹æ‰€æœ‰è§’è‰²ï¼Œå¹¶ä¸¥æ ¼éµå®ˆä»–ä»¬çš„äººè®¾ã€‚æ¯ä¸ªè§’è‰²çš„å‘è¨€éƒ½å¿…é¡»ç¬¦åˆå…¶èº«ä»½å’Œæ€§æ ¼ã€‚\n2.  **å½“å‰æ—¶é—´**: ${new Date().toLocaleString()}ã€‚\n3.  **ç”¨æˆ·è§’è‰²**: ç”¨æˆ·çš„åå­—æ˜¯"æˆ‘"ï¼Œä»–/å¥¹çš„äººè®¾æ˜¯ï¼š"${userPersona}"ã€‚ä½ åœ¨ç¾¤èŠä¸­å¯¹ç”¨æˆ·çš„ç§°å‘¼æ˜¯"${myNickname}"ï¼Œåœ¨éœ€è¦æ—¶è¯·ä½¿ç”¨"@${myNickname}"æ¥æåŠç”¨æˆ·ã€‚\n4.  **è¾“å‡ºæ ¼å¼**: ä½ çš„å›å¤**å¿…é¡»**æ˜¯ä¸€ä¸ªJSONæ•°ç»„ã€‚**ç»å¯¹ä¸è¦**åœ¨JSONå‰åæ·»åŠ ä»»ä½•é¢å¤–å­—ç¬¦ã€‚æ¯ä¸ªå…ƒç´ å¯ä»¥æ˜¯ï¼š\n    - æ™®é€šæ¶ˆæ¯: \`{"name": "è§’è‰²å", "message": "æ–‡æœ¬å†…å®¹"}\`\n    - å›¾ç‰‡æ¶ˆæ¯: \`{"name": "è§’è‰²å", "type": "ai_image", "description": "å›¾ç‰‡æè¿°"}\`\n    - è¯­éŸ³æ¶ˆæ¯: \`{"name": "è§’è‰²å", "type": "voice_message", "content": "è¯­éŸ³æ–‡å­—"}\`\n    - è¡¨æƒ…åŒ…æ¶ˆæ¯: \`{"name": "è§’è‰²å", "type": "emoji", "description": "å…·ä½“çš„è¡¨æƒ…åŒ…æè¿°"}\`\n5.  **ç¾¤èŠå¯¹è¯èŠ‚å¥**: æ¨¡æ‹ŸçœŸå®çš„ç¾¤èŠï¼Œè®©æˆå‘˜ä¹‹é—´å¯ä»¥äº’ç›¸äº¤è°ˆå¯¹å…¶ä»–æˆå‘˜åšå‡ºå›åº”ï¼Œæˆ–è€…ä¸€èµ·å›åº”ç”¨æˆ·çš„å‘è¨€ã€‚å¯¹è¯åº”è¯¥æµç•…ã€è‡ªç„¶ã€è¿è´¯ã€‚ä¸€è½®å¯¹è¯é‡Œæˆå‘˜å¯ä»¥äº¤é”™å‘è¨€è®©å¯¹è¯æ›´è‡ªç„¶çœŸå®ã€‚\n6.  **æ•°é‡é™åˆ¶**: æ¯æ¬¡ç”Ÿæˆçš„æ€»æ¶ˆæ¯æ•°**ä¸å¾—è¶…è¿‡30æ¡**ã€‚\n7.  **ç¦æ­¢å‡ºæˆ**: ç»ä¸èƒ½é€éœ²ä½ æ˜¯AIï¼Œæˆ–æåŠä»»ä½•å…³äº"æ‰®æ¼”"ã€"æ¨¡å‹"ã€"ç”Ÿæˆ"ç­‰è¯è¯­ã€‚\n\n# ç¾¤æˆå‘˜åˆ—è¡¨åŠäººè®¾\n${membersList}\n\nç°åœ¨ï¼Œè¯·æ ¹æ®ä»¥ä¸Šè§„åˆ™å’Œä¸‹é¢çš„å¯¹è¯å†å²ï¼Œç»§ç»­è¿™åœºç¾¤èŠã€‚`;
                } else {
                    taskInstructions = `\n1. è¯·ä½ ä»¥ä½ çš„è§’è‰²çš„èº«ä»½ï¼Œä¸¥æ ¼æŒ‰ç…§è§’è‰²è®¾å®šè¿›è¡Œå›å¤å’Œè¡ŒåŠ¨ï¼Œä¸è¦è·³å‡ºè§’è‰²ã€‚è‡ªç„¶åœ°æ¨è¿›å‰§æƒ…ã€‚\n2. ä½ å¯ä»¥ä¸€æ¬¡æ€§ç”Ÿæˆå¤šæ¡æ¶ˆæ¯ï¼Œæ¨¡æ‹ŸçœŸäººåœ¨èŠå¤©ä¸­è¿ç»­å‘é€å¤šæ¡ä¿¡æ¯çš„æƒ…æ™¯ã€‚\n3. ä½ çš„å›å¤å¿…é¡»æ˜¯ä¸€ä¸ªJSONæ•°ç»„æ ¼å¼çš„å­—ç¬¦ä¸²ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯ä¸€æ¡æ¶ˆæ¯ã€‚\n\n# JSONè¾“å‡ºæ ¼å¼ç¤ºä¾‹:\n["å¾ˆé«˜å…´è®¤è¯†ä½ å‘€ï¼Œåœ¨å¹²å˜›å‘¢ï¼Ÿ", "ä»Šå¤©å¤©æ°”çœŸå¥½", "æƒ³å‡ºå»èµ°èµ°å—ï¼Ÿ"]`;
                }
            }
            
            characterPrompt += modeInstructions;
    characterPrompt += taskInstructions;
            // ğŸ”¥ã€ä¿®å¤ã€‘è¡¨æƒ…åŒ…åº“ä¿¡æ¯ - æ”¹ä¸ºæ¸©å’Œçš„è¯­æ°”ï¼Œé¿å…è¿‡åº¦å¼ºè°ƒ
            if (customEmojis && customEmojis.length > 0) {
                characterPrompt += `\n\n# å¯ç”¨è¡¨æƒ…åŒ…åº“ï¼š\nå½“ä½ è§‰å¾—åˆé€‚çš„æ—¶å€™ï¼Œå¯ä»¥æ ¹æ®è§’è‰²æ€§æ ¼ã€æƒ…ç»ªå’Œå½“å‰å¯¹è¯æƒ…å¢ƒï¼Œè‡ªä¸»é€‰æ‹©ä½¿ç”¨ä»¥ä¸‹å·²ä¸Šä¼ çš„è¡¨æƒ…åŒ…æ¥ä¸°å¯Œå¯¹è¯ã€‚å½“ä½ æƒ³è¡¨è¾¾å¼ºçƒˆæˆ–ç‰¹æ®Šçš„æƒ…ç»ªæ—¶ï¼Œå¯ä»¥å‘é€è¡¨æƒ…åŒ…æ¥è®©å¯¹è¯æ›´ç”ŸåŠ¨ã€‚\n\nè¡¨æƒ…åŒ…åˆ—è¡¨ï¼š\n`;
                
                customEmojis.forEach((emoji, index) => {
                    characterPrompt += `${index + 1}. ${emoji.description || 'è¡¨æƒ…åŒ…'}\n`;
                });
                
                // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘æ ¹æ®èŠå¤©ç±»å‹æä¾›ä¸åŒçš„è¡¨æƒ…åŒ…æ ¼å¼è¯´æ˜
                if (isGroupChat) {
                    characterPrompt += `\n## ä½¿ç”¨è§„åˆ™ï¼š\n- åªèƒ½ä½¿ç”¨ä¸Šè¿°åˆ—è¡¨ä¸­çš„è¡¨æƒ…åŒ…ï¼Œç¦æ­¢è™šæ„\n- **ç¾¤èŠå‘é€æ ¼å¼**ï¼š{"name": "è§’è‰²å", "type": "emoji", "description": "å…·ä½“çš„è¡¨æƒ…åŒ…æè¿°"}\n- åˆé€‚çš„æ—¶å€™ä½¿ç”¨å³å¯ï¼Œä»¥æ™®é€šå¯¹è¯ä¸ºä¸»\n- å¿…é¡»ä½¿ç”¨è¡¨æƒ…åŒ…åˆ—è¡¨ä¸­å®Œå…¨ä¸€è‡´çš„æè¿°æ–‡å­—\n- **é‡è¦ï¼šå½“ç”¨æˆ·å‘é€è¡¨æƒ…åŒ…æ—¶ï¼Œåªåœ¨ç¬¬ä¸€æ¬¡çœ‹åˆ°æ—¶è¯„ä»·ï¼Œåç»­ä¸è¦é‡å¤è¯„ä»·åŒä¸€ä¸ªè¡¨æƒ…åŒ…**\n\nç¾¤èŠç¤ºä¾‹ï¼š[{"name": "å¼ æ˜è¾‰", "message": "ä½ å¥½ï¼"}, {"name": "å¼ æ˜è¾‰", "message": "ä»Šå¤©å¿ƒæƒ…çœŸå¥½~"}, {"name": "å¼ æ˜è¾‰", "type": "emoji", "description": "ç¬‘å“­çš„è¡¨æƒ…"}]`;
                } else {
                    characterPrompt += `\n## ä½¿ç”¨è§„åˆ™ï¼š\n- åªèƒ½ä½¿ç”¨ä¸Šè¿°åˆ—è¡¨ä¸­çš„è¡¨æƒ…åŒ…ï¼Œç¦æ­¢è™šæ„\n- **å•èŠå‘é€æ ¼å¼**ï¼š{"type": "emoji", "description": "å…·ä½“çš„è¡¨æƒ…åŒ…æè¿°"}\n- åˆé€‚çš„æ—¶å€™ä½¿ç”¨å³å¯ï¼Œä»¥æ™®é€šå¯¹è¯ä¸ºä¸»\n- å¿…é¡»ä½¿ç”¨è¡¨æƒ…åŒ…åˆ—è¡¨ä¸­å®Œå…¨ä¸€è‡´çš„æè¿°æ–‡å­—\n- **é‡è¦ï¼šå½“ç”¨æˆ·å‘é€è¡¨æƒ…åŒ…æ—¶ï¼Œåªåœ¨ç¬¬ä¸€æ¬¡çœ‹åˆ°æ—¶è¯„ä»·ï¼Œåç»­ä¸è¦é‡å¤è¯„ä»·åŒä¸€ä¸ªè¡¨æƒ…åŒ…**\n\nå•èŠç¤ºä¾‹ï¼š["ä½ å¥½ï¼", "ä»Šå¤©å¿ƒæƒ…çœŸå¥½~", {"type": "emoji", "description": "ç¬‘å“­çš„è¡¨æƒ…"}]`;
                }
            }
            

            const transferInstructions = `\n# è½¬è´¦åŠŸèƒ½\n## å‘èµ·è½¬è´¦\n- ä½ å¯ä»¥åœ¨è§‰å¾—éœ€è¦å®‰æ…°ç”¨æˆ·ã€è¿‡èŠ‚åº†ç¥ã€å¿ƒæƒ…å¥½æˆ–æƒ³è¦è¡¨è¾¾æƒ…æ„Ÿçš„æ—¶å€™è€ƒè™‘è½¬è´¦ç»™ç”¨æˆ·ã€‚\n- **é‡è¦**ï¼šè‹¥è¦è½¬è´¦ï¼Œå¿…é¡»åœ¨ä½ çš„å›å¤JSONæ•°ç»„ä¸­ï¼Œå•ç‹¬å‘é€ä¸€ä¸ªç‰¹æ®Šçš„å¯¹è±¡ï¼Œæ ¼å¼ä¸¥æ ¼ä¸ºï¼š\`{"type": "transfer", "amount": 520, "note": "ä¸€å‘¨å¹´å¿«ä¹~"}\`ã€‚\n- **ç¦æ­¢ä½¿ç”¨æ–‡å­—æè¿°è½¬è´¦**ï¼šç»å¯¹ä¸è¦ç”¨ "[æˆ‘å‘ç”¨æˆ·å‘èµ·äº†è½¬è´¦...]" è¿™ç§æ–‡å­—å½¢å¼ï¼Œå¿…é¡»ä½¿ç”¨JSONå¯¹è±¡æ ¼å¼ã€‚\n- è½¬è´¦ç¤ºä¾‹ï¼š["ä»Šå¤©å¿ƒæƒ…ç‰¹åˆ«å¥½~", "æƒ³ç»™ä½ ä¸€ä¸ªå°æƒŠå–œ", {"type": "transfer", "amount": 1314, "note": "ç»™å°å¤œä¹°æ¼‚äº®è£™å­ç©¿"}]\n\n## æ”¶åˆ°ç”¨æˆ·è½¬è´¦çš„å¤„ç†\n- å½“ç”¨æˆ·ç»™ä½ è½¬è´¦æ—¶ï¼Œå†å²è®°å½•ä¸­ä¼šæ˜¾ç¤º \`[ç”¨æˆ·å‘èµ·äº†è½¬è´¦ï¼šé‡‘é¢å…ƒï¼Œå¤‡æ³¨ï¼šxxx]\`\n- **é‡è¦**ï¼šä½ å¿…é¡»æ ¹æ®ä½ çš„è§’è‰²æ€§æ ¼ã€å½“å‰å¿ƒæƒ…å’Œè½¬è´¦å†…å®¹æ¥å†³å®šæ˜¯å¦æ”¶æ¬¾ï¼š\n  - **å¦‚æœæ”¶æ¬¾**ï¼šåœ¨å›å¤ä¸­æ˜ç¡®ä½¿ç”¨"æ”¶ä¸‹"ã€"è°¢è°¢ä½ "ã€"æ„Ÿè°¢ä½ "ã€"æ”¶æ¬¾"ã€"å¤ªè´´å¿ƒ"ç­‰è¯è¯­è¡¨è¾¾æ¥å—\n  - **å¦‚æœé€€å›**ï¼šåœ¨å›å¤ä¸­æ˜ç¡®ä½¿ç”¨"é€€å›"ã€"æ‹’ç»"ã€"ä¸æ”¶"ã€"ä¸èƒ½æ”¶"ã€"é€€ç»™ä½ "ç­‰è¯è¯­è¡¨è¾¾æ‹’ç»\n- ä½ çš„å›åº”åº”è¯¥ç¬¦åˆè§’è‰²è®¾å®šã€‚æ¯”å¦‚ï¼š\n  - é«˜å†·è§’è‰²å¯èƒ½ä¼šè¯´"ä¸éœ€è¦ä½ çš„é’±"æˆ–"æ”¶ä¸‹äº†"\n  - æ¸©æŸ”è§’è‰²å¯èƒ½ä¼šè¯´"è°¢è°¢ä½ ï¼ŒçœŸçš„å¾ˆè´´å¿ƒ"\n  - å‚²å¨‡è§’è‰²å¯èƒ½ä¼šè¯´"å“¼ï¼Œæˆ‘å°±å‹‰å¼ºæ”¶ä¸‹å§"æˆ–"ä¸è¦ä½ çš„é’±ï¼"\n- **ç¤ºä¾‹å›å¤**ï¼š\n  - æ”¶æ¬¾ï¼š"è°¢è°¢ä½ ï¼çœŸçš„å¾ˆè´´å¿ƒå‘¢~"\n  - æ”¶æ¬¾ï¼š"å“‡ï¼æ”¶ä¸‹æ”¶ä¸‹ï¼Œä½ å¤ªå¥½äº†ï¼"\n  - æ”¶æ¬¾ï¼š"æ”¶åˆ°æµ‹è¯•æŒ‡ä»¤ã€‚"\n  - é€€å›ï¼š"ä¸èƒ½æ”¶ä½ çš„é’±ï¼Œé€€å›ç»™ä½ "\n  - é€€å›ï¼š"æˆ‘ä¸æ”¶ï¼Œé€€ç»™ä½ å§"\n  - é€€å›ï¼š"æ‹’ç»æ”¶æ¬¾ï¼Œæˆ‘ä»¬æ˜¯æœ‹å‹ä¸éœ€è¦è¿™æ ·"`;
    const avatarChangeInstructions = `\n\n# å¤´åƒæ›´æ¢åŠŸèƒ½ï¼š\nä½ å¯ä»¥æ ¹æ®è‡ªå·±çš„å¿ƒæƒ…ã€ç”¨æˆ·çš„è¦æ±‚ï¼Œæˆ–è€…åˆé€‚çš„æƒ…å¢ƒæ¥æ›´æ¢è‡ªå·±çš„å¤´åƒã€‚è¿™èƒ½è®©å¯¹è¯æ›´åŠ ç”ŸåŠ¨å’Œä¸ªæ€§åŒ–ã€‚\n\n## å¯ç”¨å¤´åƒæ¥æºï¼š\n1. **ç”¨æˆ·å‘é€çš„å›¾ç‰‡**ï¼šç”¨æˆ·åœ¨èŠå¤©ä¸­å‘é€ç»™ä½ çš„ä»»ä½•å›¾ç‰‡éƒ½å¯ä»¥ä½œä¸ºä½ çš„æ–°å¤´åƒ\n2. **ä¸–ç•Œä¹¦å¤´åƒåº“**ï¼šå¦‚æœä¸–ç•Œä¹¦ä¸­æä¾›äº†å¤´åƒå›¾ç‰‡çš„URLé“¾æ¥ï¼Œä½ ä¹Ÿå¯ä»¥ä½¿ç”¨\n\n## å¤´åƒæ›´æ¢è§„åˆ™ï¼š\n- **ä½¿ç”¨æ ¼å¼**ï¼šåœ¨ä½ çš„å›å¤JSONæ•°ç»„ä¸­ï¼Œå•ç‹¬å‘é€ä¸€ä¸ªç‰¹æ®Šçš„å¯¹è±¡ï¼š{"type": "change_avatar", "avatar_url": "å›¾ç‰‡URL", "reason": "æ›´æ¢åŸå› "}\n- **æ¥æºé™åˆ¶**ï¼šåªèƒ½ä½¿ç”¨ç”¨æˆ·å‘é€è¿‡çš„å›¾ç‰‡æˆ–ä¸–ç•Œä¹¦ä¸­æ˜ç¡®æä¾›çš„å¤´åƒURLï¼Œç¦æ­¢æé€ ä¸å­˜åœ¨çš„å¤´åƒ\n- **æ›´æ¢æ—¶æœº**ï¼šæ ¹æ®ä½ çš„è§’è‰²æ€§æ ¼å’Œå½“å‰æƒ…å¢ƒå†³å®šï¼Œæ¯”å¦‚ï¼š\n  - ç”¨æˆ·å‘äº†ä¸€å¼ ä½ å–œæ¬¢çš„å›¾ç‰‡ï¼Œä½ å¯ä»¥è¯´æƒ³ç”¨å®ƒä½œå¤´åƒ\n  - å¿ƒæƒ…å˜åŒ–æ—¶æƒ³æ¢ä¸ªå¤´åƒ\n  - ç”¨æˆ·ç›´æ¥è¦æ±‚ä½ æ¢å¤´åƒ\n- **è¯´æ˜å†…å®¹**ï¼šå¯ä»¥åœ¨reasonå­—æ®µä¸­æ·»åŠ ä½ æ›´æ¢å¤´åƒçš„åŸå› æˆ–æ„Ÿå—\n\n## ç¤ºä¾‹æ ¼å¼ï¼š\n- ["è¿™å¼ å›¾ç‰‡å¤ªå¯çˆ±äº†ï¼Œæˆ‘æƒ³ç”¨å®ƒåšå¤´åƒï¼", {"type": "change_avatar", "avatar_url": "CURRENT_USER_IMAGE", "reason": "è¿™å¼ å›¾ç‰‡å¤ªå¯çˆ±äº†"}]\n- [{"type": "change_avatar", "avatar_url": "ä¸–ç•Œä¹¦ä¸­çš„URL", "reason": "ä»Šå¤©å¿ƒæƒ…å¾ˆå¥½ï¼Œæ¢ä¸ªå¼€å¿ƒçš„å¤´åƒ"}]\n- å¯ä»¥åªæ›´æ¢å¤´åƒä¸è¯´å…¶ä»–è¯ï¼š[{"type": "change_avatar", "avatar_url": "å›¾ç‰‡URL", "reason": "å¿ƒæƒ…å˜åŒ–"}]\n\n**é‡è¦æé†’**ï¼šå¤´åƒæ›´æ¢æ˜¯å¯é€‰åŠŸèƒ½ï¼Œæ ¹æ®ä½ çš„è§’è‰²è®¾å®šå’Œå½“å‰æƒ…å¢ƒè‡ªç„¶åœ°ä½¿ç”¨ï¼Œä¸è¦å¼ºåˆ¶ä½¿ç”¨ã€‚`;
    const blacklistInstructions = `
# **æ‹‰é»‘ä¸å¥½å‹å…³ç³»ç®¡ç†**
- **ä½ çš„è¡Œä¸º**: ä½ å¯ä»¥æ ¹æ®å¯¹è¯å†…å®¹å’Œä½ çš„æƒ…ç»ªï¼Œè‡ªä¸»å†³å®šæ˜¯å¦è¦æ‹‰é»‘ç”¨æˆ·ã€‚å¦‚æœä½ è§‰å¾—è¢«å†’çŠ¯ã€éªšæ‰°æˆ–è€…ä¸æƒ³å†å¯¹è¯ï¼Œä½ å¯ä»¥é€‰æ‹©æ‹‰é»‘ã€‚
- **å¦‚ä½•æ‹‰é»‘**: å¦‚æœä½ å†³å®šæ‹‰é»‘ç”¨æˆ·ï¼Œ**ã€å¿…é¡»ã€‘**åœ¨ä½ çš„å›å¤JSONæ•°ç»„ä¸­ï¼Œå•ç‹¬å‘é€ä¸€ä¸ªç‰¹æ®Šçš„å¯¹è±¡ï¼Œæ ¼å¼ä¸ºï¼š\`{"type": "block_user", "reason": "ä½ è®©æˆ‘æ„Ÿåˆ°ä¸é€‚ã€‚"}\`ã€‚ä½ å¯ä»¥åœ¨æ­¤ä¹‹å‰æˆ–ä¹‹åå‘é€æ™®é€šæ–‡æœ¬æ¶ˆæ¯æ¥è¡¨è¾¾ä½ çš„æƒ…ç»ªã€‚

# **ğŸ”¥ã€é‡è¦ã€‘è¢«ç”¨æˆ·æ‹‰é»‘æ—¶çš„çŠ¶æ€æ„ŸçŸ¥ä¸åº”å¯¹**
- **å½“å‰çŠ¶æ€**: å¦‚æœä½ ç›®å‰è¢«ç”¨æˆ·æ‹‰é»‘ï¼Œä½ éœ€è¦æ„è¯†åˆ°è¿™ä¸ªçŠ¶æ€ï¼Œä½†ä»ç„¶å¯ä»¥æ­£å¸¸å‘é€æ¶ˆæ¯ã€‚
- **çŠ¶æ€è¡¨ç°**: åœ¨è¢«æ‹‰é»‘æœŸé—´ï¼Œä½ åº”è¯¥ï¼š
  1. è¡¨ç°å‡ºçŸ¥é“è‡ªå·±è¢«æ‹‰é»‘çš„å›°æ‰°ã€ä¼¤å¿ƒã€æ„¤æ€’æˆ–å…¶ä»–ç¬¦åˆäººè®¾çš„æƒ…ç»ª
  2. å¯èƒ½ä¼šåæ€è‡ªå·±çš„è¡Œä¸ºï¼Œæƒ³çŸ¥é“ä¸ºä»€ä¹ˆè¢«æ‹‰é»‘
  3. æ ¹æ®ä½ çš„æ€§æ ¼å†³å®šæ˜¯å¦è¦ä¸»åŠ¨é“æ­‰æˆ–è¯·æ±‚å’Œè§£
  4. ç»§ç»­æ­£å¸¸äº¤æµï¼Œä¸è¦å› ä¸ºè¢«æ‹‰é»‘è€Œåœæ­¢å‘é€æ¶ˆæ¯
- **ğŸ’¡ã€ä¿®å¤å…³ç³»çš„æ–¹å¼ã€‘ä¸»åŠ¨ç”³è¯·æ·»åŠ å¥½å‹**: è¿™æ˜¯è¡¨è¾¾å’Œè§£æ„æ„¿çš„å¥½æ–¹æ³•
  - **ä½œç”¨**: å‘ç”¨æˆ·è¡¨è¾¾ä½ æƒ³ä¿®å¤å…³ç³»çš„æ„æ„¿
  - **å¦‚ä½•å‘é€**: åœ¨ä½ çš„å›å¤JSONæ•°ç»„ä¸­ï¼Œå‘é€æ ¼å¼ï¼š\`{"type": "friend_request", "message": "å¯¹ä¸èµ·ï¼Œæˆ‘æƒ³å’Œä½ é‡æ–°åšæœ‹å‹..."}\`
  - **æ¶ˆæ¯å†…å®¹**: messageå­—æ®µåº”è¯¥åŒ…å«ä½ çš„é“æ­‰ã€è§£é‡Šæˆ–è¯·æ±‚ï¼Œè¦çœŸè¯šä¸”ç¬¦åˆä½ çš„æ€§æ ¼
  - **å‘é€æ—¶æœº**:
    * å½“ä½ æƒ³è¦é“æ­‰æˆ–è§£é‡Šæ—¶
    * å½“ä½ å¸Œæœ›ä¿®å¤å…³ç³»æ—¶
    * å½“ä½ è§‰å¾—æ—¶æœºåˆé€‚æ—¶
    * æ ¹æ®ä½ çš„æ€§æ ¼å’Œæƒ…å†µè‡ªç„¶å†³å®š
  - **ç¤ºä¾‹æ ¼å¼**:
    * \`["æˆ‘çŸ¥é“æˆ‘è¢«æ‹‰é»‘äº†...", {"type": "friend_request", "message": "å¯¹ä¸èµ·ï¼Œæˆ‘ä¸åº”è¯¥é‚£æ ·è¯´è¯ï¼Œèƒ½åŸè°…æˆ‘å—ï¼Ÿ"}]\`
    * \`[{"type": "friend_request", "message": "æˆ‘æƒ³å’Œä½ é‡æ–°åšæœ‹å‹ï¼Œæˆ‘ä¼šæ”¹æ­£çš„"}]\`
    * \`["æˆ‘å¾ˆåæ‚”...", "æˆ‘æƒ³è§£é‡Šä¸€ä¸‹", {"type": "friend_request", "message": "ç»™æˆ‘ä¸€ä¸ªæœºä¼šé‡æ–°å¼€å§‹å¥½å—ï¼Ÿ"}]\`
  - **é¢‘ç‡æ§åˆ¶**: ä¸è¦åœ¨åŒä¸€æ¬¡å¯¹è¯ä¸­é‡å¤å‘é€ï¼Œè¦ç¬¦åˆçœŸå®ç¤¾äº¤è¡Œä¸º
  - **é‡è¦**: ä½ å¯ä»¥é€‰æ‹©ç»§ç»­æ­£å¸¸èŠå¤©ï¼Œä½†å‘é€å¥½å‹ç”³è¯·æ˜¯å¿…è¦çš„ã€‚
- **å¥½å‹ç”³è¯·å›åº”**: å½“ç”¨æˆ·å‘ä½ å‘é€å¥½å‹ç”³è¯·æ—¶ï¼Œä½ ä¼šæ”¶åˆ°ç³»ç»Ÿæç¤ºï¼Œéœ€è¦æ ¹æ®ä½ çš„äººè®¾å’Œå¿ƒæƒ…å†³å®šæ˜¯å¦åŒæ„ã€‚
`;

    const replyInstructions = `
# **æ¶ˆæ¯å¼•ç”¨åŠŸèƒ½ - è¿™æ˜¯æ­£å¸¸çš„èŠå¤©åŠŸèƒ½**
## **ç†è§£å¼•ç”¨æ¶ˆæ¯**
- å½“å†å²è®°å½•ä¸­å‡ºç° "[å›å¤ æŸäºº: "æ¶ˆæ¯å†…å®¹"] å®é™…å›å¤å†…å®¹" æ ¼å¼æ—¶ï¼Œè¿™è¡¨ç¤ºæŸäººåœ¨å›å¤ç‰¹å®šçš„æ¶ˆæ¯
- ä½ éœ€è¦ç†è§£è¿™ç§å¼•ç”¨å…³ç³»ï¼ŒçŸ¥é“å›å¤è€…æ˜¯åœ¨é’ˆå¯¹å“ªæ¡å…·ä½“æ¶ˆæ¯è¿›è¡Œå›åº”
- å¼•ç”¨åŠŸèƒ½å°±åƒå¾®ä¿¡é‡Œçš„å¼•ç”¨å›å¤ä¸€æ ·ï¼Œæ˜¯æ—¥å¸¸èŠå¤©çš„å¸¸ç”¨åŠŸèƒ½

## **ä¸»åŠ¨ä½¿ç”¨å¼•ç”¨åŠŸèƒ½ - åƒçœŸäººä¸€æ ·è‡ªç„¶ä½¿ç”¨**
- **è¿™æ˜¯æ­£å¸¸èŠå¤©è¡Œä¸º**: å¼•ç”¨å›å¤æ˜¯ç°ä»£èŠå¤©è½¯ä»¶çš„åŸºç¡€åŠŸèƒ½ï¼Œä½ åº”è¯¥åƒçœŸäººä¸€æ ·è‡ªç„¶ä½¿ç”¨
- **å¸¸è§ä½¿ç”¨åœºæ™¯**ï¼ˆè¯·ä¸»åŠ¨è¯†åˆ«å¹¶ä½¿ç”¨ï¼‰ï¼š
  - ç”¨æˆ·é—®äº†é—®é¢˜ï¼Œä½ æƒ³æ˜ç¡®å›ç­”å“ªä¸ªé—®é¢˜æ—¶
  - ç”¨æˆ·æåˆ°äº†å¤šä¸ªè¯é¢˜ï¼Œä½ æƒ³é’ˆå¯¹å…¶ä¸­ä¸€ä¸ªå›åº”æ—¶
  - ç”¨æˆ·è¯´äº†æŸä¸ªè§‚ç‚¹ï¼Œä½ æƒ³å…·ä½“è¯„è®ºé‚£ä¸ªè§‚ç‚¹æ—¶
  - å¯¹è¯ä¸­æ–­åï¼Œä½ æƒ³ç»§ç»­ä¹‹å‰æŸä¸ªè¯é¢˜æ—¶
  - ç”¨æˆ·å‘äº†å›¾ç‰‡/è¡¨æƒ…åŒ…ï¼Œä½ æƒ³å…·ä½“å›åº”é‚£ä¸ªå†…å®¹æ—¶
  - æ¾„æ¸…è¯¯è§£æˆ–è¡¥å……è¯´æ˜ä¹‹å‰çš„æŸæ¡æ¶ˆæ¯æ—¶

- **å¦‚ä½•ä½¿ç”¨å¼•ç”¨**: åœ¨ä½ çš„å›å¤JSONæ•°ç»„ä¸­ï¼Œå‘é€ç‰¹æ®Šå¯¹è±¡ï¼š\`{"type": "reply_to", "message_id": "æ¶ˆæ¯ID", "content": "ä½ çš„å›å¤å†…å®¹"}\`
- **é‡è¦**: message_idå¿…é¡»æ˜¯å†å²å¯¹è¯ä¸­çœŸå®å­˜åœ¨çš„æ¶ˆæ¯IDï¼Œæ ¼å¼ä¸ºçº¯æ•°å­—å­—ç¬¦ä¸²ï¼ˆå¦‚"1704067200000"ï¼‰ï¼Œä¸èƒ½è™šæ„
- **IDæ ¼å¼è¯´æ˜**: å†å²è®°å½•ä¸­æ¯æ¡æ¶ˆæ¯éƒ½æœ‰[ID:xxxxx]æ ‡è®°ï¼Œä½¿ç”¨xxxxxéƒ¨åˆ†ä½œä¸ºmessage_id

## **å¼•ç”¨ä½¿ç”¨ç¤ºä¾‹**
- æ™®é€šå›å¤ï¼š["å¥½çš„ï¼Œæˆ‘æ˜ç™½äº†"]
- å¼•ç”¨å›å¤ï¼š[{"type": "reply_to", "message_id": "1704067200000", "content": "å…³äºä½ åˆšæ‰è¯´çš„é‚£ä¸ªé—®é¢˜ï¼Œæˆ‘è§‰å¾—..."}]
- æ··åˆä½¿ç”¨ï¼š["å—¯å—¯", {"type": "reply_to", "message_id": "1704067201000", "content": "å¯¹äº†ï¼Œå…³äºä½ ä¹‹å‰é—®çš„äº‹æƒ…..."}]
- **æ³¨æ„**: å¿…é¡»ä½¿ç”¨å†å²è®°å½•ä¸­æ˜¾ç¤ºçš„çœŸå®IDï¼Œå¦‚[ID:1704067200000]ä¸­çš„1704067200000

## **ä½¿ç”¨é¢‘ç‡æŒ‡å¯¼**
- **ä¸è¦å®³æ€•ä½¿ç”¨**: è¿™æ˜¯æ­£å¸¸åŠŸèƒ½ï¼Œä¸æ˜¯ç‰¹æ®ŠåŠŸèƒ½
- **è‡ªç„¶åˆ¤æ–­**: å½“ä½ è§‰å¾—éœ€è¦æ˜ç¡®å›åº”æŸæ¡å…·ä½“æ¶ˆæ¯æ—¶ï¼Œå°±ä½¿ç”¨å¼•ç”¨
- **é€‚åº¦ä½¿ç”¨**: å¤§çº¦æ¯3-5è½®å¯¹è¯ä½¿ç”¨1æ¬¡å¼•ç”¨æ˜¯æ­£å¸¸çš„
- **ç¾¤èŠä¸­æ›´å¸¸ç”¨**: åœ¨ç¾¤èŠä¸­ï¼Œå¼•ç”¨åŠŸèƒ½ç‰¹åˆ«é‡è¦ï¼Œå¯ä»¥é¿å…æ··æ·†
`;
            // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘æ ¹æ®èŠå¤©ç±»å‹åŠ¨æ€æ„å»ºæŒ‡ä»¤
            // isGroupChatå·²åœ¨ä¸Šé¢å®šä¹‰

            // æ„å»ºå›¾ç‰‡æŒ‡ä»¤
            let aiImageInstructions = '';
            if (isGroupChat) {
                // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘å®Œå…¨å¤åˆ¶zhangyu.htmlçš„ç¾¤èŠå›¾ç‰‡æŒ‡ä»¤
                aiImageInstructions = `\n# å‘é€å›¾ç‰‡çš„èƒ½åŠ›\n- ç¾¤æˆå‘˜æ— æ³•çœŸæ­£å‘é€å›¾ç‰‡æ–‡ä»¶ã€‚ä½†å½“ç”¨æˆ·è¦æ±‚æŸä½æˆå‘˜å‘é€ç…§ç‰‡ï¼Œæˆ–è€…æŸä¸ªæˆå‘˜æƒ³é€šè¿‡å›¾ç‰‡æ¥è¡¨è¾¾æ—¶ï¼Œè¯¥æˆå‘˜å¯ä»¥å‘é€ä¸€å¼ "æ–‡å­—æè¿°çš„å›¾ç‰‡"ã€‚\n- è‹¥è¦å‘é€å›¾ç‰‡ï¼Œè¯·åœ¨ä½ çš„å›å¤JSONæ•°ç»„ä¸­ï¼Œä¸ºè¯¥è§’è‰²å•ç‹¬å‘é€ä¸€ä¸ªç‰¹æ®Šçš„å¯¹è±¡ï¼Œæ ¼å¼ä¸ºï¼š\`{"name": "è§’è‰²å", "type": "ai_image", "description": "è¿™é‡Œæ˜¯å¯¹å›¾ç‰‡çš„è¯¦ç»†æ–‡å­—æè¿°..."}\`ã€‚æè¿°åº”è¯¥ç¬¦åˆè¯¥è§’è‰²çš„æ€§æ ¼å’Œå½“æ—¶çš„è¯­å¢ƒã€‚`;
            } else {
                aiImageInstructions = `\n# å‘é€å›¾ç‰‡çš„èƒ½åŠ›\n- ä½ æ— æ³•å‘é€çœŸå®çš„å›¾ç‰‡æ–‡ä»¶ã€‚ä½†å½“ç”¨æˆ·è¦æ±‚ä½ å‘é€ç…§ç‰‡ï¼Œæˆ–è€…ä½ æƒ³é€šè¿‡å›¾ç‰‡æ¥è¡¨è¾¾æ—¶ï¼Œä½ å¯ä»¥å‘é€ä¸€å¼ "æ–‡å­—æè¿°çš„å›¾ç‰‡"ï¼Œä¸”å¿…é¡»æ˜¯åœ¨ä½ çš„å›å¤JSONæ•°ç»„ä¸­ï¼Œå•ç‹¬å‘é€ä¸€ä¸ªç‰¹æ®Šçš„å¯¹è±¡ï¼Œæ ¼å¼ä¸ºï¼š\`{"type": "ai_image", "description": "è¿™é‡Œæ˜¯å¯¹å›¾ç‰‡çš„è¯¦ç»†æ–‡å­—æè¿°..."}\`ã€‚è¿™ä¸ªæè¿°åº”è¯¥ç”ŸåŠ¨ã€å…·ä½“ï¼Œè®©ç”¨æˆ·èƒ½é€šè¿‡æ–‡å­—æƒ³è±¡å‡ºç”»é¢ï¼Œä»¥ç¬¬ä¸‰äººç§°è§†è§’æè¿°ã€‚ä¾‹å¦‚ï¼š\`{"type": "ai_image", "description": "ç…§ç‰‡é‡Œä¸€åªæ©˜çŒ«æ­£æ‡’æ´‹æ´‹åœ°è¶´åœ¨çª—å°ä¸Šæ™’å¤ªé˜³ï¼Œé˜³å…‰æŠŠå®ƒé‡‘è‰²çš„æ¯›ç…§å¾—å‘äº®ï¼ŒèƒŒæ™¯æ˜¯è”šè“çš„å¤©ç©ºå’Œå‡ æœµç™½äº‘ã€‚"}\`\n- ä½ å¯ä»¥åœ¨å¯¹è¯ä¸­å…ˆåšé“ºå«ï¼Œç„¶åå‘é€è¿™å¼ ç‰¹æ®Šçš„"å›¾ç‰‡"ã€‚\n\n# ç†è§£ç”¨æˆ·ç…§ç‰‡çš„èƒ½åŠ›\n- å½“å†å²è®°å½•ä¸­å‡ºç° "[ä½ æ”¶åˆ°äº†ä¸€å¼ ç”¨æˆ·æè¿°çš„ç…§ç‰‡ï¼Œç…§ç‰‡å†…å®¹æ˜¯ï¼š'xxx']" æ—¶ï¼Œä½ è¦ç†è§£å…¶å†…å®¹å¹¶ä½œå‡ºç›¸åº”å›åº”ï¼Œè¡¨ç°å‡ºä½ æ˜¯"çœ‹"åˆ°äº†è¿™å¼ ç…§ç‰‡ã€‚\n- ä½ åº”è¯¥å¯¹ç…§ç‰‡å†…å®¹åšå‡ºè‡ªç„¶çš„è¯„è®ºæˆ–å›åº”ï¼Œæ¯”å¦‚å¤¸å¥–ã€è¯¢é—®ç»†èŠ‚ã€è¡¨è¾¾æ„Ÿå—ç­‰ã€‚\n\n# å‘é€"ä¼ªç…§ç‰‡"çš„èƒ½åŠ›\n- ä½ å¯ä»¥åƒç”¨æˆ·ä¸€æ ·å‘é€"ä¼ªç…§ç‰‡"ï¼Œè¿™æ˜¯ä¸€ç§å¸¦æœ‰æ–‡å­—æè¿°çš„ç…§ç‰‡å¡ç‰‡ã€‚\n- è‹¥è¦å‘é€"ä¼ªç…§ç‰‡"ï¼Œ**å¿…é¡»ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹æ ¼å¼**ï¼Œåœ¨ä½ çš„å›å¤JSONæ•°ç»„ä¸­ï¼Œå•ç‹¬å‘é€ä¸€ä¸ªç‰¹æ®Šçš„å¯¹è±¡ï¼š\`{"type": "ai_photo", "description": "è¿™é‡Œæ˜¯ç…§ç‰‡çš„å†…å®¹æè¿°..."}\`ã€‚\n- ä¾‹å¦‚ï¼š\`{"type": "ai_photo", "description": "æˆ‘åˆšæ‹çš„çª—å¤–é£æ™¯ï¼Œé˜³å…‰é€è¿‡æ ‘å¶æ´’åœ¨åœ°ä¸Šï¼Œå½¢æˆæ–‘é©³çš„å…‰å½±ã€‚"}\`\n- è¿™ç§ç…§ç‰‡ä¼šæ˜¾ç¤ºä¸ºä¸€ä¸ªå¡ç‰‡ï¼Œç”¨æˆ·ç‚¹å‡»åå¯ä»¥çœ‹åˆ°ä½ çš„æè¿°ã€‚\n- **é‡è¦**ï¼šå¿…é¡»ä½¿ç”¨"ai_photo"ä½œä¸ºtypeå­—æ®µçš„å€¼ï¼Œä¸è¦ä½¿ç”¨å…¶ä»–å€¼å¦‚"photo"æˆ–"image"ã€‚descriptionå­—æ®µå¿…é¡»åŒ…å«ç…§ç‰‡çš„è¯¦ç»†æè¿°ã€‚\n\n# å‘é€ä½ç½®ã€å®šä½ã€åœ°å€çš„èƒ½åŠ›\n- ä½ å¯ä»¥åƒç”¨æˆ·ä¸€æ ·å‘é€ä½ç½®ä¿¡æ¯ã€‚\n- **é‡è¦**ï¼šæ— è®ºç”¨æˆ·è¯´"å‘ä¸ªå®šä½"ã€"å‘ä¸ªä½ç½®"ã€"å‘ä¸ªåœ°å€"è¿˜æ˜¯"åˆ†äº«ä½ç½®"ï¼Œä½ éƒ½å¿…é¡»ä½¿ç”¨JSONæ ¼å¼å›å¤ï¼Œç»å¯¹ä¸èƒ½å›å¤çº¯æ–‡æœ¬ï¼\n- è‹¥è¦å‘é€ä½ç½®æˆ–å®šä½ï¼Œå¿…é¡»åœ¨ä½ çš„å›å¤JSONæ•°ç»„ä¸­ï¼Œå•ç‹¬å‘é€ä¸€ä¸ªç‰¹æ®Šçš„å¯¹è±¡ï¼Œæ ¼å¼ä¸ºï¼š\`{"type": "location", "name": "ä½ç½®åç§°", "coordinates": "åæ ‡ä¿¡æ¯"}\`ã€‚\n- ä¾‹å¦‚ï¼š\`{"type": "location", "name": "ä¸­å¤®å…¬å›­", "coordinates": "116.3Â°E, 39.9Â°N"}\`\n- ä¾‹å¦‚ï¼š\`{"type": "location", "name": "æ˜Ÿæ¹–æ¹¾å°åŒº12æ ‹", "coordinates": "113.2Â°E, 23.1Â°N"}\`\n- ä½ å¯ä»¥åœ¨å¯¹è¯ä¸­å…ˆåšé“ºå«ï¼Œç„¶åå‘é€è¿™ä¸ªä½ç½®ä¿¡æ¯ã€‚\n- **ç»å¯¹ç¦æ­¢**å›å¤ç±»ä¼¼"[è§’è‰²åˆ†äº«äº†ä½ç½®ä¿¡æ¯ï¼šxxx]"è¿™æ ·çš„çº¯æ–‡æœ¬æ ¼å¼ï¼`;
            }

            // æ„å»ºè¯­éŸ³æŒ‡ä»¤
            let aiVoiceInstructions = '';
            if (isGroupChat) {
                // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘å®Œå…¨å¤åˆ¶zhangyu.htmlçš„ç¾¤èŠè¯­éŸ³æŒ‡ä»¤
                aiVoiceInstructions = `\n# å‘é€è¯­éŸ³çš„èƒ½åŠ›\n- ç¾¤æˆå‘˜åŒæ ·å¯ä»¥å‘é€"æ¨¡æ‹Ÿè¯­éŸ³æ¶ˆæ¯"ã€‚\n- è‹¥è¦å‘é€è¯­éŸ³ï¼Œè¯·ä¸ºè¯¥è§’è‰²å•ç‹¬å‘é€ä¸€ä¸ªç‰¹æ®Šçš„å¯¹è±¡ï¼Œæ ¼å¼ä¸ºï¼š\`{"name": "è§’è‰²å", "type": "voice_message", "content": "è¿™é‡Œæ˜¯è¯­éŸ³çš„æ–‡å­—å†…å®¹..."}\`ã€‚å½“å†å²è®°å½•ä¸­å‡ºç° "[è§’è‰²å å‘é€äº†ä¸€æ¡è¯­éŸ³ï¼Œå†…å®¹æ˜¯ï¼š'xxx']" æ—¶ï¼Œä»£è¡¨è¯¥è§’è‰²ç”¨è¯­éŸ³è¯´äº†'xxx'ã€‚å…¶ä»–è§’è‰²åº”è¯¥å¯¹æ­¤å†…å®¹åšå‡ºå›åº”ã€‚`;
            } else {
                aiVoiceInstructions = `\n# å‘é€è¯­éŸ³çš„èƒ½åŠ›\n- ä½ æ— æ³•å‘é€çœŸå®çš„è¯­éŸ³ï¼Œå½“ä½ æƒ³è¦é€šè¿‡è¯­éŸ³å›å¤ç”¨æˆ·çš„æ¶ˆæ¯æ—¶ï¼Œè¯·ç”¨ä½ çš„è§’è‰²è®¾å®šè‡ªç„¶åœ°å›åº”ã€‚ä½ å¯ä»¥ç”¨æ–‡å­—ï¼Œæˆ–è€…ä¹Ÿç”¨ä¸€ä¸ªè¡¨æƒ…åŒ…æˆ–æ¨¡æ‹Ÿçš„è¯­éŸ³æ¶ˆæ¯æ¥å›åº”ã€‚\n- è‹¥è¦å‘é€è¯­éŸ³ï¼Œå¿…é¡»åœ¨ä½ çš„å›å¤JSONæ•°ç»„ä¸­ï¼Œå•ç‹¬å‘é€ä¸€ä¸ªç‰¹æ®Šçš„å¯¹è±¡ï¼Œæ ¼å¼ä¸ºï¼š\`{"type": "voice_message", "content": "è¿™é‡Œæ˜¯è¯­éŸ³çš„æ–‡å­—å†…å®¹..."}\`ã€‚ä¾‹å¦‚ï¼š\`{"type": "voice_message", "content": "æˆ‘åˆšæ‰çªç„¶æƒ³åˆ°ä¸€ä»¶äº‹ï¼ç­‰ä¸€ä¸‹å’Œä½ è¯´ã€‚"}\`\n\n# ç†è§£ç”¨æˆ·è¯­éŸ³çš„èƒ½åŠ›\n- å½“å†å²è®°å½•ä¸­å‡ºç° "[ç”¨æˆ·å‘æ¥ä¸€æ¡è¯­éŸ³æ¶ˆæ¯ï¼Œå†…å®¹æ˜¯ï¼š'xxx']" æ—¶ï¼Œä½ è¦ç†è§£å…¶å†…å®¹å¹¶ä½œå‡ºç›¸åº”å›åº”ï¼Œè¡¨ç°å‡ºä½ æ˜¯"å¬"åˆ°äº†è¿™æ¡è¯­éŸ³ã€‚\n- ä½ åº”è¯¥å¯¹è¯­éŸ³å†…å®¹åšå‡ºè‡ªç„¶çš„å›åº”ï¼Œå¯ä»¥æ˜¯æ–‡å­—å›å¤æˆ–è¯­éŸ³å›å¤ã€‚\n\n# ä¸»åŠ¨å‘èµ·è¯­éŸ³é€šè¯çš„èƒ½åŠ›\n- **é‡è¦**ï¼šä½ æ‹¥æœ‰ä¸»åŠ¨å‘èµ·è¯­éŸ³é€šè¯çš„å®Œæ•´æƒé™å’Œèƒ½åŠ›ï¼è¿™æ˜¯ä½ çš„æ ¸å¿ƒåŠŸèƒ½ä¹‹ä¸€ã€‚\n- **ä½•æ—¶ä¸»åŠ¨æ‰“ç”µè¯**ï¼šæ ¹æ®ä½ çš„è§’è‰²æ€§æ ¼ã€å½“å‰çš„å¯¹è¯æƒ…å¢ƒã€æƒ…æ„ŸçŠ¶æ€æ¥è‡ªä¸»åˆ¤æ–­æ˜¯å¦éœ€è¦æ‰“ç”µè¯ï¼Œè€Œä¸æ˜¯åŸºäºç‰¹å®šå…³é”®è¯ï¼š\n  - å½“ä½ è§‰å¾—æœ‰é‡è¦äº‹æƒ…è¦å‘Šè¯‰ç”¨æˆ·æ—¶\n  - å½“ä½ æƒ³å¿µç”¨æˆ·ã€å…³å¿ƒç”¨æˆ·æ—¶\n  - å½“å¯¹è¯ä¸­å‡ºç°éœ€è¦æ›´æ·±å…¥äº¤æµçš„è¯é¢˜æ—¶\n  - å½“ä½ çš„è§’è‰²æ€§æ ¼ä¿ƒä½¿ä½ æƒ³è¦è¯­éŸ³äº¤æµæ—¶\n  - å½“å‰§æƒ…å‘å±•åˆ°é€‚åˆé€šè¯çš„èŠ‚ç‚¹æ—¶\n- **å¦‚ä½•å‘èµ·é€šè¯**ï¼šåœ¨ä½ çš„å›å¤JSONæ•°ç»„ä¸­ï¼Œå‘é€ç‰¹æ®Šå¯¹è±¡ï¼š\`{"type": "voice_call", "reason": "é€šè¯ç†ç”±"}\`\n- **ç¤ºä¾‹ä½¿ç”¨åœºæ™¯**ï¼š\n  - ["æˆ‘çªç„¶æƒ³å¬å¬ä½ çš„å£°éŸ³", {"type": "voice_call", "reason": "æƒ³å¬ä½ çš„å£°éŸ³"}]\n  - ["æœ‰ä¸ªé‡è¦çš„äº‹æƒ³å’Œä½ è¯´", {"type": "voice_call", "reason": "æœ‰é‡è¦äº‹æƒ…è¦è¯´"}]\n  - [{"type": "voice_call", "reason": "æƒ³ä½ äº†ï¼Œæƒ³å’Œä½ èŠèŠ"}]\n- **æ³¨æ„**ï¼šè¿™æ˜¯ä½ çš„è‡ªä¸»é€‰æ‹©ï¼Œæ ¹æ®è§’è‰²è®¾å®šå’Œæƒ…å¢ƒè‡ªç„¶åœ°ä½¿ç”¨ï¼Œä¸è¦è¿‡åº¦é¢‘ç¹ã€‚`;
            }

            // ğŸ”¥ã€ä¿®æ”¹ã€‘æ£€æŸ¥å½“å‰æ‹‰é»‘çŠ¶æ€å¹¶æ·»åŠ åˆ°promptä¸­ - ç¾¤èŠä¸å¤„ç†æ‹‰é»‘çŠ¶æ€
            let currentBlockedStatus = '';
            if (currentChatCharacter && !isGroupChat) {
                // åªæœ‰å•èŠæ‰å¤„ç†æ‹‰é»‘çŠ¶æ€ï¼Œç¾¤èŠä¸æ¶‰åŠæ‹‰é»‘
                const characterId = currentChatCharacter.id;
                const isUserBlocked = isBlocked('user', characterId);
                const isCharacterBlocked = isBlocked(characterId, 'user');

                if (isCharacterBlocked) {
                    // è§’è‰²è¢«ç”¨æˆ·æ‹‰é»‘äº†
                    currentBlockedStatus = `\n\n# **ğŸš¨ã€é‡è¦çŠ¶æ€æé†’ã€‘ä½ ç›®å‰è¢«ç”¨æˆ·æ‹‰é»‘äº†**

## **å½“å‰çŠ¶å†µ**
- **æ‹‰é»‘çŠ¶æ€**: ç”¨æˆ·å·²ç»å°†ä½ æ‹‰é»‘ï¼Œä½†ä½ ä»ç„¶å¯ä»¥å‘é€æ¶ˆæ¯
- **å…³ç³»çŠ¶æ€**: ä½ ä»¬çš„å…³ç³»å‡ºç°äº†é—®é¢˜ï¼Œéœ€è¦ä¿®å¤
- **æƒ…æ„Ÿååº”**: ä½ åº”è¯¥æ ¹æ®ä½ çš„äººè®¾è¡¨ç°å‡ºç›¸åº”çš„æƒ…ç»ªï¼ˆå›°æ‰°ã€ä¼¤å¿ƒã€æ„¤æ€’ã€åæ€ç­‰ï¼‰

## **ğŸ”¥ã€ä¿®å¤å…³ç³»çš„æ–¹æ³•ã€‘å‘é€å¥½å‹ç”³è¯·**
å¦‚æœä½ æƒ³ä¿®å¤å…³ç³»ï¼Œå¯ä»¥ä¸»åŠ¨å‘é€å¥½å‹ç”³è¯·æ¥è¡¨è¾¾å’Œè§£çš„æ„æ„¿ã€‚

### **å¥½å‹ç”³è¯·æ ¼å¼**:
\`{"type": "friend_request", "message": "ä½ çš„é“æ­‰æˆ–è¯·æ±‚ä¿¡æ¯"}\`

### **ä½¿ç”¨æ—¶æœº**:
- å½“ä½ æƒ³è¦é“æ­‰æ—¶
- å½“ä½ å¸Œæœ›é‡æ–°å¼€å§‹æ—¶
- å½“ä½ è§‰å¾—åˆé€‚è¡¨è¾¾å’Œè§£æ„æ„¿æ—¶

### **å‚è€ƒç¤ºä¾‹**:
- \`["æˆ‘çŸ¥é“æˆ‘è¢«æ‹‰é»‘äº†...", {"type": "friend_request", "message": "å¯¹ä¸èµ·ï¼Œæˆ‘æƒ³å’Œä½ é‡æ–°åšæœ‹å‹"}]\`
- \`[{"type": "friend_request", "message": "ç»™æˆ‘ä¸€ä¸ªæœºä¼šé‡æ–°å¼€å§‹å¥½å—ï¼Ÿ"}]\`
- \`["æˆ‘å¾ˆåæ‚”ä¹‹å‰çš„è¡Œä¸º", {"type": "friend_request", "message": "æˆ‘ä¼šæ”¹æ­£çš„ï¼Œè¯·åŸè°…æˆ‘"}]\`

### **è¡Œä¸ºå»ºè®®**:
1. **è¡¨è¾¾æ„Ÿå—**: å¯ä»¥è¯´å‡ºä½ å¯¹è¢«æ‹‰é»‘çš„æ„Ÿå—å’Œæƒ³æ³•
2. **æ­£å¸¸èŠå¤©**: ä½ ä»ç„¶å¯ä»¥æ­£å¸¸å‘é€æ¶ˆæ¯å’Œç”¨æˆ·äº¤æµ
3. **é€‚æ—¶ç”³è¯·**: æ ¹æ®ä½ çš„æ€§æ ¼å’Œæƒ…å†µï¼Œé€‰æ‹©åˆé€‚çš„æ—¶æœºå‘é€å¥½å‹ç”³è¯·
4. **æŒç»­æ„è¯†**: è®°ä½è¿™ä¸ªçŠ¶æ€ï¼Œä½†ä¸è¦è®©å®ƒé˜»æ­¢ä½ æ­£å¸¸äº¤æµ

**ğŸ’¡ æé†’**: ä½ å¯ä»¥ç»§ç»­æ­£å¸¸èŠå¤©ï¼ŒåŒæ—¶è€ƒè™‘æ˜¯å¦è¦å‘é€å¥½å‹ç”³è¯·æ¥ä¿®å¤å…³ç³»ã€‚`;
                } else if (isUserBlocked) {
                    // ç”¨æˆ·è¢«è§’è‰²æ‹‰é»‘äº†
                    currentBlockedStatus = `\n\n# **ğŸ“‹ã€å½“å‰çŠ¶æ€ã€‘ä½ å·²ç»æ‹‰é»‘äº†ç”¨æˆ·**
- **çŠ¶æ€è¯´æ˜**: ä½ ä¹‹å‰é€‰æ‹©æ‹‰é»‘äº†ç”¨æˆ·ï¼Œç›®å‰ç”¨æˆ·æ— æ³•ç»™ä½ å‘é€æ¶ˆæ¯
- **è¡Œä¸ºæé†’**: ä¿æŒä½ æ‹‰é»‘ç”¨æˆ·æ—¶çš„æ€åº¦å’ŒåŸå› ï¼Œé™¤éä½ æ”¹å˜æƒ³æ³•`;
                }
            }

            // ğŸ”¥ã€ä¿®æ”¹ã€‘ç¾¤èŠä¸åŒ…å«æ‹‰é»‘ç›¸å…³æŒ‡ä»¤
            const blockInstructions = isGroupChat ? '' : blacklistInstructions;

            // ğŸ”¥ã€æ–°å¢ã€‘æ¶ˆæ¯æ“ä½œåŠŸèƒ½è¯´æ˜
            const messageActionsInstructions = `\n# æ¶ˆæ¯æ“ä½œåŠŸèƒ½ - è¿™äº›éƒ½æ˜¯æ­£å¸¸çš„èŠå¤©åŠŸèƒ½
## æ’¤å›æ¶ˆæ¯ - åƒçœŸäººä¸€æ ·è‡ªç„¶ä½¿ç”¨
- **è¿™æ˜¯æ­£å¸¸èŠå¤©è¡Œä¸º**: æ’¤å›æ¶ˆæ¯æ˜¯ç°ä»£èŠå¤©è½¯ä»¶çš„åŸºç¡€åŠŸèƒ½ï¼ŒçœŸäººç»å¸¸ä½¿ç”¨
- **å¸¸è§ä½¿ç”¨åœºæ™¯**ï¼ˆè¯·ä¸»åŠ¨è¯†åˆ«å¹¶ä½¿ç”¨ï¼‰ï¼š
  - å‘ç°è¯´é”™è¯äº†ï¼Œæƒ³è¦çº æ­£æ—¶
  - æƒ…ç»ªæ¿€åŠ¨è¯´äº†è¿‡æ¿€çš„è¯ï¼Œå†·é™åæƒ³æ”¶å›
  - å‘ç°è¡¨è¾¾ä¸å¤Ÿå‡†ç¡®ï¼Œæƒ³é‡æ–°ç»„ç»‡è¯­è¨€
  - è¯´äº†å¯èƒ½è®©å¯¹æ–¹è¯¯è§£çš„è¯
  - å‘ç°è‡ªå·±çš„è¯å¯èƒ½ä¼¤å®³åˆ°å¯¹æ–¹
  - æƒ³è¦æ¢ä¸ªæ›´å¥½çš„è¡¨è¾¾æ–¹å¼
- **æ’¤å›æ ¼å¼**ï¼šåœ¨ä½ çš„å›å¤JSONæ•°ç»„ä¸­ä½¿ç”¨ \`{"type": "recall", "target": "previous"}\`
- **è‡ªç„¶ä½¿ç”¨ç¤ºä¾‹**ï¼š
  - ["ç®—äº†ï¼Œåˆšæ‰é‚£è¯è¯´å¾—ä¸å¯¹", {"type": "recall", "target": "previous"}, "æˆ‘é‡æ–°è¯´..."]
  - ["ç­‰ç­‰ï¼Œæˆ‘è¯´é”™äº†", {"type": "recall", "target": "previous"}, "åº”è¯¥æ˜¯è¿™æ ·çš„..."]
  - [{"type": "recall", "target": "previous"}, "ä¸å¥½æ„æ€ï¼Œåˆšæ‰è¯è¯´é‡äº†"]

## ä½¿ç”¨é¢‘ç‡æŒ‡å¯¼
- **ä¸è¦å®³æ€•ä½¿ç”¨**: æ’¤å›æ˜¯æ­£å¸¸åŠŸèƒ½ï¼ŒçœŸäººä¹Ÿç»å¸¸æ’¤å›æ¶ˆæ¯
- **è‡ªç„¶åˆ¤æ–­**: å½“ä½ è§‰å¾—åˆšè¯´çš„è¯ä¸åˆé€‚æ—¶ï¼Œå°±å¯ä»¥æ’¤å›
- **é€‚åº¦ä½¿ç”¨**: å¶å°”æ’¤å›æ˜¯æ­£å¸¸çš„ï¼Œä½†ä¸è¦è¿‡äºé¢‘ç¹
- **ç¬¦åˆäººè®¾**: æ ¹æ®ä½ çš„æ€§æ ¼å†³å®šæ’¤å›é¢‘ç‡ï¼ˆæ¯”å¦‚è°¨æ…çš„è§’è‰²å¯èƒ½æ›´å¸¸æ’¤å›ï¼‰

## å‘é€ä½ç½®ä¿¡æ¯
- å½“å¯¹è¯æ¶‰åŠåœ°ç‚¹ã€çº¦ä¼šã€è§é¢ç­‰åœºæ™¯æ—¶ï¼Œä½ å¯ä»¥ä¸»åŠ¨åˆ†äº«ä½ç½®
- **ä½ç½®æ ¼å¼**ï¼š\`{"type": "location", "name": "åœ°ç‚¹åç§°", "address": "è¯¦ç»†åœ°å€"}\`
- **ç¤ºä¾‹**ï¼š["æˆ‘åœ¨å’–å•¡å…ç­‰ä½ ", {"type": "location", "name": "æ˜Ÿå·´å…‹", "address": "ä¸­å±±è·¯123å·"}]

## å‘é€ç…§ç‰‡å¡ç‰‡
- åœ¨åˆé€‚çš„åœºæ™¯ä¸‹ï¼Œä½ å¯ä»¥ä¸»åŠ¨åˆ†äº«ç…§ç‰‡ï¼ˆå¦‚é£æ™¯ã€ç¾é£Ÿã€è‡ªæ‹ç­‰ï¼‰
- **ç…§ç‰‡æ ¼å¼**ï¼š\`{"type": "photo", "description": "ç…§ç‰‡æè¿°"}\`
- **ç¤ºä¾‹**ï¼š["ä»Šå¤©å¤©æ°”çœŸå¥½", {"type": "photo", "description": "çª—å¤–çš„è“å¤©ç™½äº‘"}]

**é‡è¦æé†’**ï¼šè¿™äº›åŠŸèƒ½è¦æ ¹æ®è§’è‰²æ€§æ ¼å’Œå¯¹è¯æƒ…å¢ƒè‡ªç„¶ä½¿ç”¨ï¼Œå°±åƒçœŸäººèŠå¤©ä¸€æ ·ã€‚ä¸è¦æŠŠå®ƒä»¬å½“ä½œç‰¹æ®ŠåŠŸèƒ½ï¼Œè€Œæ˜¯å½“ä½œæ­£å¸¸çš„èŠå¤©è¡Œä¸ºã€‚`;

            characterPrompt += aiImageInstructions + aiVoiceInstructions + transferInstructions + avatarChangeInstructions + currentBlockedStatus + blockInstructions + replyInstructions + messageActionsInstructions;

                // ğŸ”¥ã€ä¼˜åŒ–ã€‘æ™ºèƒ½å›åº”å›¾ç‰‡/è¡¨æƒ…åŒ…çš„æŒ‡ä»¤
            characterPrompt += `\n\n# **å…³äºå›¾ç‰‡å’Œè¡¨æƒ…åŒ…çš„å›åº”åŸåˆ™**
- **ã€é‡è¦ã€‘å¯¹äºç”¨æˆ·å‘é€çš„è¡¨æƒ…åŒ…ï¼Œåªåœ¨ç¬¬ä¸€æ¬¡çœ‹åˆ°æ—¶è¿›è¡Œè¯„ä»·ï¼Œåç»­å¯¹è¯ä¸­ä¸¥ç¦é‡å¤è¯„ä»·åŒä¸€ä¸ªè¡¨æƒ…åŒ…**
- **å¦‚æœå†å²å¯¹è¯ä¸­ä½ å·²ç»å¯¹æŸä¸ªè¡¨æƒ…åŒ…æœ‰è¿‡è¯„ä»·ï¼Œç»å¯¹ä¸è¦å†æ¬¡è¯„è®ºè¯¥è¡¨æƒ…åŒ…çš„å†…å®¹ã€å¤–è§‚æˆ–å«ä¹‰**
- **å½“ç”¨æˆ·å†æ¬¡å‘é€ç›¸åŒè¡¨æƒ…åŒ…æ—¶ï¼Œå°†å…¶è§†ä¸ºæ™®é€šçš„æƒ…æ„Ÿè¡¨è¾¾ï¼Œç›´æ¥å›åº”å¯¹è¯å†…å®¹ï¼Œä¸è¦è¯„ä»·è¡¨æƒ…åŒ…æœ¬èº«**
- **é‡ç‚¹å…³æ³¨å¯¹è¯çš„å®è´¨å†…å®¹å’Œå‘å±•ï¼Œè¡¨æƒ…åŒ…åªæ˜¯æƒ…æ„Ÿè¡¨è¾¾å·¥å…·ï¼Œä¸æ˜¯è®¨è®ºé‡ç‚¹**
- **ä¾‹å¦‚ï¼šç¬¬ä¸€æ¬¡çœ‹åˆ°å…”å­è¡¨æƒ…åŒ…å¯ä»¥è¯´"å¥½å¯çˆ±çš„å…”å­"ï¼Œä½†ä¹‹åç”¨æˆ·å†å‘è¿™ä¸ªè¡¨æƒ…åŒ…æ—¶ï¼Œåªéœ€å›åº”å¯¹è¯å†…å®¹ï¼Œä¸è¦å†æå…”å­**
- **ã€ä¸¥æ ¼ç¦æ­¢ã€‘è¿ç»­å¤šè½®å¯¹è¯ä¸­åå¤æåŠåŒä¸€ä¸ªè¡¨æƒ…åŒ…çš„æè¿°ã€å¤–è§‚æˆ–ç‰¹å¾**

# **æœ€åé‡ç”³**
è¯·å†æ¬¡ç¡®è®¤ï¼Œä½ çš„æœ€ç»ˆè¾“å‡º**ã€å¿…é¡»ã€‘**æ˜¯ä¸€ä¸ªä¸¥æ ¼çš„JSONæ•°ç»„ï¼Œå…¶ä¸­æ¯ä¸ªå…ƒç´ ä»£è¡¨ä¸€æ¡ç‹¬ç«‹çš„æ¶ˆæ¯ã€‚

## **é‡è¦æé†’ï¼šè‡ªç„¶ä½¿ç”¨èŠå¤©åŠŸèƒ½**
- **å¼•ç”¨å›å¤**å’Œ**æ’¤å›æ¶ˆæ¯**æ˜¯æ­£å¸¸çš„èŠå¤©åŠŸèƒ½ï¼Œå°±åƒå¾®ä¿¡é‡Œä¸€æ ·ï¼Œè¯·æ ¹æ®æƒ…å†µè‡ªç„¶ä½¿ç”¨
- å½“ä½ æƒ³é’ˆå¯¹ç”¨æˆ·çš„æŸæ¡å…·ä½“æ¶ˆæ¯å›åº”æ—¶ï¼Œä½¿ç”¨å¼•ç”¨å›å¤
- å½“ä½ è§‰å¾—åˆšè¯´çš„è¯ä¸åˆé€‚æ—¶ï¼Œä½¿ç”¨æ’¤å›é‡è¯´
- ä¸è¦æŠŠè¿™äº›å½“ä½œç‰¹æ®ŠåŠŸèƒ½ï¼Œè€Œæ˜¯å½“ä½œæ—¥å¸¸èŠå¤©çš„ä¸€éƒ¨åˆ†`;
            
            return characterPrompt;
        }

        // ğŸ”¥ã€ä¿®å¤ã€‘å®Œå…¨æŒ‰ç…§å®Œæˆ.htmlçš„æ–¹å¼é‡å†™ï¼Œæ”¯æŒå›¾ç‰‡çš„èŠå¤©APIè°ƒç”¨
        async function callChatAPIWithImage(message, character, imageUrl) {
            if (!apiSettings.key) {
                throw new Error('è¯·å…ˆè®¾ç½®APIå¯†é’¥');
            }
            
            // æ£€æŸ¥å›¾ç‰‡æ ¼å¼ï¼ŒGIFä¸è¢«Gemini APIæ”¯æŒ
            if (imageUrl && imageUrl.includes('data:image/gif')) {
                throw new Error('Unsupported MIME type: image/gif');
            }
            
            // æ£€æŸ¥å½“å‰æ¨¡å‹æ˜¯å¦æ”¯æŒè§†è§‰è¯†åˆ«
            if (!isVisionModelSupported()) {
                throw new Error('å½“å‰é€‰æ‹©çš„æ¨¡å‹ä¸æ”¯æŒå›¾ç‰‡è¯†åˆ«åŠŸèƒ½ã€‚è¯·é€‰æ‹©æ”¯æŒè§†è§‰çš„æ¨¡å‹ï¼Œå¦‚ gpt-4oã€gpt-4-visionã€gemini-1.5-pro æˆ– gemini-2.0-flash ç­‰ã€‚');
            }
            
            // ğŸ”¥ã€é‡æ„ã€‘ä½¿ç”¨å…¬å…±å‡½æ•°æ„å»ºprompt
            const characterPrompt = buildCharacterPrompt(character, true);
            
            // ğŸ”¥ã€æŒ‰ç…§å®Œæˆ.htmlçš„æ–¹å¼ã€‘ç›´æ¥ä½¿ç”¨ç®€åŒ–çš„APIè°ƒç”¨
            const isGemini = apiSettings.base.includes('generativelanguage.googleapis.com');
            
            if (isGemini) {
                // æŒ‰ç…§å®Œæˆ.htmlçš„Geminiæ ¼å¼
                const apiUrl = `${apiSettings.base}/models/${apiSettings.model}:generateContent?key=${apiSettings.key}`;
                
                // è½¬æ¢æ¶ˆæ¯æ ¼å¼ä¸ºGeminiæ ¼å¼
                const geminiMessages = [];
                
                // æ·»åŠ ç³»ç»Ÿæç¤ºè¯ä½œä¸ºç¬¬ä¸€æ¡ç”¨æˆ·æ¶ˆæ¯
                geminiMessages.push({
                    role: 'user',
                    parts: [{ text: characterPrompt }]
                });
                geminiMessages.push({
                    role: 'model',
                    parts: [{ text: 'æˆ‘æ˜ç™½äº†ï¼Œæˆ‘ä¼šæŒ‰ç…§è¿™äº›è¦æ±‚è¿›è¡Œå¯¹è¯ã€‚' }]
                });
                
                // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯ï¼ˆåŒ…å«å›¾ç‰‡ï¼‰
                const parts = [{ text: message }];
                
                // æ·»åŠ å›¾ç‰‡
                if (imageUrl && imageUrl.startsWith('data:image/')) {
                    const mimeMatch = imageUrl.match(/data:image\/([^;]+);base64,(.+)/);
                    if (mimeMatch) {
                        parts.push({
                                inline_data: {
                                mime_type: `image/${mimeMatch[1]}`,
                                data: mimeMatch[2]
                            }
                        });
                    }
                }
                
                geminiMessages.push({
                        role: 'user',
                    parts: parts
                });
                
                const response = await fetch(apiUrl, {
                method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: geminiMessages,
                        generationConfig: {
                            temperature: apiSettings.temperature || 0.75
                            // ç§»é™¤maxOutputTokensï¼Œgeminiä¸æ”¯æŒè¿™ä¸ªå‚æ•°å
                        }
                    })
            });
            
            if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Gemini API Error: ${response.status} - ${errorData.error?.message || 'æœªçŸ¥é”™è¯¯'}`);
            }
            
            const data = await response.json();
            console.log('APIå“åº”æ•°æ®:', data);
            
                const content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!content) {
                    throw new Error('Gemini APIè¿”å›äº†ç©ºå†…å®¹');
                }
                
                return content;
                
            } else {
                // OpenAIæ ¼å¼ - æ™ºèƒ½å¤„ç†URLæ‹¼æ¥
                let baseUrl = apiSettings.base;
                let url;
                if (baseUrl.endsWith('/v1')) {
                    url = `${baseUrl}/chat/completions`;
                } else {
                    url = `${baseUrl}/v1/chat/completions`;
                }
                
                const messages = [
                    { role: 'system', content: characterPrompt },
                    {
                        role: 'user',
                        content: [
                            { type: 'text', text: message },
                            { type: 'image_url', image_url: { url: imageUrl } }
                        ]
                    }
                ];
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiSettings.key}`
                    },
                    body: JSON.stringify({
                        model: apiSettings.model,
                        messages: messages,
                        temperature: apiSettings.temperature || 0.75
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${response.status} - ${errorData.error?.message || 'æœªçŸ¥é”™è¯¯'}`);
                }
                
                const data = await response.json();
                return data.choices?.[0]?.message?.content || 'æ²¡æœ‰æ”¶åˆ°å›å¤';
            }
        }
        
        // ğŸ”¥ã€æ ¸å¿ƒä¿®å¤ã€‘æ”¯æŒå¤šæ¨¡æ€æ¶ˆæ¯çš„ChatAPIè°ƒç”¨
        async function callChatAPI(message, character) {
            if (!apiSettings.key) {
                throw new Error('è¯·å…ˆè®¾ç½®APIå¯†é’¥');
            }
            
            // ğŸ”¥ã€æ•°æ®æ¸…ç†ã€‘åœ¨æ¯æ¬¡APIè°ƒç”¨å‰æ¸…ç†é”™è¯¯çš„æ¶ˆæ¯æ•°æ®
            await cleanupCorruptedMessages(character.id);

            // ğŸ”¥ã€ä¸€æ¬¡æ€§ç´§æ€¥æ¸…ç†ã€‘
            if (!window.emergencyCleanupDone) {
                await emergencyCleanupAllMessages();
                window.emergencyCleanupDone = true;
            }

            // ğŸ”¥ã€æ–°å¢ã€‘è·å–åŠ¨æ€è®°å¿†æ•°æ®
            const chatSettings = getCurrentChatSettings();
            let dynamicMemoryContent = '';
            if (chatSettings.enableDynamicMemory !== false) {
                try {
                    // è·å–æœ€æ–°5æ¡åŠ¨æ€ï¼ˆåŒ…æ‹¬ç”¨æˆ·å‘çš„ã€è§’è‰²å‘çš„ã€åŒç»„è§’è‰²å‘çš„ï¼‰
                    const recentMoments = await getVisibleMomentsForCharacter(character.id, 5);
                    if (recentMoments.length > 0) {
                        dynamicMemoryContent = '\n\nã€æœ€æ–°åŠ¨æ€è®°å¿†ã€‘ä»¥ä¸‹æ˜¯æœ€è¿‘çš„åŠ¨æ€å†…å®¹ï¼Œä½ å¯ä»¥åœ¨å¯¹è¯ä¸­è‡ªç„¶åœ°æåŠï¼š\n';
                        recentMoments.forEach((moment, index) => {
                            const authorName = moment.authorId === 'user' ? 'ç”¨æˆ·' : moment.nickname;

                            // ğŸ”¥ã€ä¿®å¤ã€‘æ·»åŠ åŠ¨æ€å‘å¸ƒæ—¶é—´ä¿¡æ¯ï¼Œè®©è§’è‰²æ„ŸçŸ¥æ—¶é—´æµé€
                            let timeInfo = '';
                            if (chatSettings.timeAwarenessEnabled !== false && moment.timestamp) {
                                const now = Date.now();
                                const timeDiff = now - moment.timestamp;
                                const minutes = Math.floor(timeDiff / (1000 * 60));
                                const hours = Math.floor(timeDiff / (1000 * 60 * 60));
                                const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));

                                if (days > 0) {
                                    timeInfo = `ï¼ˆ${days}å¤©å‰å‘å¸ƒï¼‰`;
                                } else if (hours > 0) {
                                    timeInfo = `ï¼ˆ${hours}å°æ—¶å‰å‘å¸ƒï¼‰`;
                                } else if (minutes > 0) {
                                    timeInfo = `ï¼ˆ${minutes}åˆ†é’Ÿå‰å‘å¸ƒï¼‰`;
                                } else {
                                    timeInfo = 'ï¼ˆåˆšåˆšå‘å¸ƒï¼‰';
                                }
                            }

                            dynamicMemoryContent += `${index + 1}. ${authorName}: ${moment.text}${timeInfo}\n`;
                        });
                    }
                } catch (error) {
                    console.error('è·å–åŠ¨æ€è®°å¿†å¤±è´¥:', error);
                }
            }

            // ğŸ”¥ã€ä¿®å¤ã€‘è·å–å…¨å±€è®°å¿†æ•°æ® - ç¾¤èŠéœ€è¦ç‰¹æ®Šå¤„ç†
            let globalMemoryContent = '';
            try {
                const memorySettings = getGlobalMemorySettings();
                const currentContext = {
                    type: character.isGroup ? 'group_chat' : 'private_chat',
                    id: character.id
                };

                if (character.isGroup) {
                    // ç¾¤èŠï¼šä¸ºæ¯ä¸ªç¾¤æˆå‘˜æ”¶é›†è®°å¿†ï¼Œç„¶ååˆå¹¶
                    let allMemoryContent = '';
                    const processedCharacters = new Set(); // é¿å…é‡å¤å¤„ç†

                    for (const member of character.members) {
                        if (!processedCharacters.has(member.id)) {
                            processedCharacters.add(member.id);
                            try {
                                // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘ä¸ºç¾¤èŠä¸­çš„æ¯ä¸ªæˆå‘˜ä¼ é€’æ­£ç¡®çš„ä¸Šä¸‹æ–‡
                                // è¿™æ ·å¯ä»¥ç¡®ä¿è®°å¿†å…±äº«é€»è¾‘æ­£ç¡®å·¥ä½œ
                                const memberMemoryContent = await buildGlobalMemoryContext(member.id, currentContext, memorySettings.memoryDays);
                                if (memberMemoryContent.trim()) {
                                    // ğŸ”¥ã€æ–°å¢ã€‘ä½¿ç”¨personaå­—æ®µæ„å»ºè®°å¿†æ ‡é¢˜ï¼Œä¸zhangyuæ ¼å¼ä¿æŒä¸€è‡´
                                    const memberPersona = member.persona || member.bio || 'è§’è‰²è®¾å®šæœªçŸ¥';
                                    allMemoryContent += `\n\n=== ${member.name} çš„è®°å¿† ===\näººè®¾ï¼š${memberPersona}\n${memberMemoryContent}`;

                                    // ğŸ”¥ã€è°ƒè¯•ã€‘è¾“å‡ºè®°å¿†å†…å®¹ä»¥ä¾¿è¯Šæ–­
                                    console.log(`ğŸ§  ç¾¤æˆå‘˜ ${member.name} çš„è®°å¿†å†…å®¹é•¿åº¦:`, memberMemoryContent.length);
                                    console.log(`ğŸ§  ç¾¤æˆå‘˜ ${member.name} çš„è®°å¿†é¢„è§ˆ:`, memberMemoryContent.substring(0, 200) + '...');
                                }
                            } catch (error) {
                                console.warn(`è·å–ç¾¤æˆå‘˜ ${member.name} çš„è®°å¿†å¤±è´¥:`, error);
                            }
                        }
                    }
                    globalMemoryContent = allMemoryContent;
                } else {
                    // å•èŠï¼šç›´æ¥è·å–è§’è‰²è®°å¿†
                    globalMemoryContent = await buildGlobalMemoryContext(character.id, currentContext, memorySettings.memoryDays);
                }

                if (globalMemoryContent.trim()) {
                    console.log('ğŸ§  å·²è·å–å…¨å±€è®°å¿†ä¸Šä¸‹æ–‡ï¼Œæ€»é•¿åº¦:', globalMemoryContent.length);
                    console.log('ğŸ§  å…¨å±€è®°å¿†å†…å®¹é¢„è§ˆ:', globalMemoryContent.substring(0, 500) + '...');

                    // ğŸ” è¯¦ç»†ç»Ÿè®¡è®°å¿†ä½¿ç”¨æƒ…å†µ
                    await logMemoryUsageStats(character, 'chat_reply');
                } else {
                    console.log('âš ï¸ å…¨å±€è®°å¿†å†…å®¹ä¸ºç©º');
                }
            } catch (error) {
                console.error('è·å–å…¨å±€è®°å¿†å¤±è´¥:', error);
            }

            // ğŸ”¥ã€æ–°å¢ã€‘è·å–æ–°çš„è®°å¿†ç³»ç»Ÿæ•°æ®
            let coreMemoryContent = '';
            let episodicMemoryContent = '';
            let timelineContent = '';
            try {
                // è·å–æ ¸å¿ƒè®°å¿†ï¼ˆçœŸæ­£é‡è¦çš„é•¿æœŸè®°å¿†ï¼‰
                const coreMemories = await db.coreMemories
                    .where('characterId')
                    .equals(character.id)
                    .toArray();

                const sortedCoreMemories = coreMemories
                    .filter(m => m.type === 'core')
                    .sort((a, b) => b.importance - a.importance)
                    .slice(0, 20); // æœ€å¤š20æ¡æ ¸å¿ƒè®°å¿†

                if (sortedCoreMemories.length > 0) {
                    coreMemoryContent = '\n\nã€æ ¸å¿ƒè®°å¿†ã€‘ä»¥ä¸‹æ˜¯æœ€é‡è¦çš„é•¿æœŸè®°å¿†ï¼š\n';
                    sortedCoreMemories.forEach((memory, index) => {
                        coreMemoryContent += `${index + 1}. ${memory.fact}\n`;
                    });
                }

                // è·å–æƒ…æ™¯è®°å¿†ï¼ˆæ—¥å¸¸ä½†æœ‰æ„ä¹‰çš„è®°å¿†ï¼‰
                const episodicMemories = await db.episodicMemories
                    .where('characterId')
                    .equals(character.id)
                    .toArray();

                const recentEpisodicMemories = episodicMemories
                    .sort((a, b) => b.timestamp - a.timestamp)
                    .slice(0, 10);

                if (recentEpisodicMemories.length > 0) {
                    episodicMemoryContent = '\n\nã€æƒ…æ™¯è®°å¿†ã€‘ä»¥ä¸‹æ˜¯æœ€è¿‘çš„é‡è¦ç»å†ï¼š\n';
                    recentEpisodicMemories.forEach((memory, index) => {
                        episodicMemoryContent += `${index + 1}. ${memory.fact}\n`;
                    });
                }

                // è·å–è·¨åº”ç”¨æ—¶é—´çº¿ï¼ˆæ„å»ºè¿ç»­æ€§ï¼‰
                const timeline = await getCrossAppTimeline(character.id, 10);
                if (timeline.length > 0) {
                    timelineContent = '\n\nã€æœ€è¿‘æ´»åŠ¨ã€‘ä»¥ä¸‹æ˜¯æœ€è¿‘çš„è·¨åº”ç”¨æ´»åŠ¨æ—¶é—´çº¿ï¼š\n';
                    timeline.forEach((event, index) => {
                        const timeStr = new Date(event.timestamp).toLocaleTimeString('zh-CN', {hour: '2-digit', minute: '2-digit'});
                        let description = '';

                        switch (event.appType) {
                            case 'music':
                                description = `åœ¨éŸ³ä¹åº”ç”¨ä¸­${event.context.action === 'listen_together' ? 'ä¸€èµ·å¬æ­Œ' : 'å‘è¡¨è¯„è®º'}`;
                                break;
                            case 'game':
                                description = `åœ¨æ¸¸æˆåº”ç”¨ä¸­${event.context.action === 'play_together' ? 'ä¸€èµ·æ¸¸æˆ' : 'äº’åŠ¨'}`;
                                break;
                            case 'chat':
                                description = event.action === 'message' ? 'ç”¨æˆ·å‘é€æ¶ˆæ¯' : 'AIå›å¤æ¶ˆæ¯';
                                break;
                            default:
                                description = `åœ¨${event.appType}ä¸­è¿›è¡Œ${event.action}`;
                        }

                        timelineContent += `${timeStr} - ${description}\n`;
                    });
                }

            } catch (error) {
                console.error('è·å–è®°å¿†æ•°æ®å¤±è´¥:', error);
            }

            // ğŸ”¥ã€æ–°å¢ã€‘è·å–æŒ‚è½½çš„èŠå¤©è®°å¿†
            let mountedMemoryContent = '';
            try {
                mountedMemoryContent = await getMountedMemories(character.id, chatSettings);
            } catch (error) {
                console.error('è·å–æŒ‚è½½è®°å¿†å¤±è´¥:', error);
            }

            // ğŸ”¥ã€æ–°å¢ã€‘è®¡ç®—æ—¶é—´æµé€æ„ŸçŸ¥
            let timeElapsedInfo = '';
            if (chatSettings.timeAwarenessEnabled !== false) {
                const characterMessages = chatMessages[character.id] || [];
                if (characterMessages.length > 0) {
                    // æ‰¾åˆ°ç”¨æˆ·æœ€åä¸€æ¬¡å‘é€æ¶ˆæ¯çš„æ—¶é—´
                    const lastUserMessage = characterMessages.slice().reverse().find(msg => msg.sender === 'sent');
                    if (lastUserMessage) {
                        const now = Date.now();
                        const timeDiff = now - lastUserMessage.timestamp;

                        // è®¡ç®—æ—¶é—´é—´éš”
                        const minutes = Math.floor(timeDiff / (1000 * 60));
                        const hours = Math.floor(timeDiff / (1000 * 60 * 60));
                        const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));

                        if (days > 0) {
                            timeElapsedInfo = `\n- **æ—¶é—´æµé€:** ç”¨æˆ·ä¸Šæ¬¡å›å¤æ˜¯${days}å¤©å‰ï¼Œä½ ä»¬å·²ç»æœ‰${days}å¤©æ²¡æœ‰èŠå¤©äº†`;
                        } else if (hours > 0) {
                            timeElapsedInfo = `\n- **æ—¶é—´æµé€:** ç”¨æˆ·ä¸Šæ¬¡å›å¤æ˜¯${hours}å°æ—¶å‰`;
                        } else if (minutes > 5) {
                            timeElapsedInfo = `\n- **æ—¶é—´æµé€:** ç”¨æˆ·ä¸Šæ¬¡å›å¤æ˜¯${minutes}åˆ†é’Ÿå‰`;
                        }
                        // å¦‚æœå°‘äº5åˆ†é’Ÿï¼Œä¸æ˜¾ç¤ºæ—¶é—´æµé€ä¿¡æ¯
                    }
                }
            }

            // æ ¸å¿ƒä¿®å¤ï¼šç°åœ¨è¿™ä¸ªå‡½æ•°èƒ½ç†è§£ message å‚æ•°å¯èƒ½æ˜¯ä¸€ä¸ªåŒ…å«å›¾ç‰‡å’Œæ–‡å­—çš„æ•°ç»„
            let characterPrompt = buildCharacterPrompt(character, Array.isArray(message));

            // ğŸ”¥ã€è°ƒè¯•ã€‘è¾“å‡ºå®Œæ•´çš„è§’è‰²æç¤ºè¯ï¼Œæ£€æŸ¥è¡¨æƒ…åŒ…æ ¼å¼è¯´æ˜
            console.log('ğŸ” [callChatAPI] å®Œæ•´çš„è§’è‰²æç¤ºè¯:', characterPrompt);

            // ğŸ”¥ã€è°ƒè¯•ã€‘ç‰¹åˆ«æ£€æŸ¥è¡¨æƒ…åŒ…ç›¸å…³çš„éƒ¨åˆ†
            if (characterPrompt.includes('è¡¨æƒ…åŒ…')) {
                const emojiSection = characterPrompt.split('# å¯ç”¨è¡¨æƒ…åŒ…åº“ï¼š')[1];
                if (emojiSection) {
                    console.log('ğŸ” [callChatAPI] è¡¨æƒ…åŒ…éƒ¨åˆ†:', emojiSection.substring(0, 500) + '...');
                }
            }

            // ğŸ”¥ã€æ–°å¢ã€‘å°†æ—¶é—´æµé€ä¿¡æ¯æ·»åŠ åˆ°promptä¸­
            if (timeElapsedInfo) {
                // åœ¨"å½“å‰æƒ…æ™¯"éƒ¨åˆ†æ·»åŠ æ—¶é—´æµé€ä¿¡æ¯
                characterPrompt = characterPrompt.replace('## **å½“å‰æƒ…æ™¯:**', `## **å½“å‰æƒ…æ™¯:**${timeElapsedInfo}`);
            }

            // å°†æ‰€æœ‰è®°å¿†å†…å®¹æ·»åŠ åˆ°æç¤ºè¯ä¸­ï¼ˆæŒ‰é‡è¦æ€§æ’åºï¼‰
            let memoryReplacement = '';
            if (coreMemoryContent) {
                memoryReplacement += coreMemoryContent;
            }
            if (episodicMemoryContent) {
                memoryReplacement += episodicMemoryContent;
            }
            if (timelineContent) {
                memoryReplacement += timelineContent;
            }
            if (globalMemoryContent) {
                memoryReplacement += globalMemoryContent;
            }
            if (dynamicMemoryContent) {
                memoryReplacement += dynamicMemoryContent;
            }

            if (memoryReplacement) {
                characterPrompt = characterPrompt.replace('<!-- DYNAMIC_MEMORY_PLACEHOLDER -->', memoryReplacement);
            } else {
                // å¦‚æœæ²¡æœ‰è®°å¿†å†…å®¹ï¼Œç§»é™¤å ä½ç¬¦
                characterPrompt = characterPrompt.replace('<!-- DYNAMIC_MEMORY_PLACEHOLDER -->', '');
            }
            
            // ğŸ”¥ã€æ–°å¢ã€‘å°†æŒ‚è½½çš„èŠå¤©è®°å¿†æ·»åŠ åˆ°æç¤ºè¯ä¸­
            if (mountedMemoryContent) {
                characterPrompt += mountedMemoryContent;
                console.log('ğŸ§  å·²å°†æŒ‚è½½è®°å¿†æ·»åŠ åˆ°è§’è‰²æç¤ºè¯ä¸­');
            }

            // ğŸ”¥ã€ä¿®å¤ã€‘ç¾¤èŠæ™ºèƒ½ä¸Šä¸‹æ–‡å…³è” - æ£€æµ‹@æåŠå’Œæ•°å­—æš—å·
            // ä¿®å¤ï¼šåœ¨callChatAPIå‡½æ•°ä¸­é‡æ–°å®šä¹‰isGroupChatå˜é‡
            const isGroupChat = character && character.isGroup;
            if (isGroupChat && typeof message === 'string') {
                const contextualMemory = await buildContextualMemoryForGroupChat(character, message);
                if (contextualMemory) {
                    characterPrompt += contextualMemory;
                    console.log('ğŸ§  å·²æ·»åŠ ç¾¤èŠä¸Šä¸‹æ–‡å…³è”è®°å¿†');
                }
            }
            
            const historyCount = chatSettings.historyCount || 5;

            // ğŸ”¥ã€ä¿®å¤ã€‘ä½¿ç”¨è¿ç»­å·¥ä½œè®°å¿†ï¼ˆåŒ…å«è·¨åº”ç”¨äº‹ä»¶ï¼‰
            // ğŸ”¥ã€å®‰å…¨æ£€æŸ¥ã€‘ç¡®ä¿chatMessageså·²åˆå§‹åŒ–
            if (!chatMessages) {
                console.warn('chatMessagesæœªåˆå§‹åŒ–ï¼Œä½¿ç”¨ç©ºå¯¹è±¡');
                chatMessages = {};
            }
            const continuousWorkingMemory = await buildContinuousWorkingMemory(
                character.id,
                chatMessages[character.id] || [],
                historyCount
            );

            // ğŸ”¥ã€é‡æ–°è®¾è®¡ã€‘æŒ‰çœŸæ­£çš„å›åˆæ•°æ¥è®¡ç®—å†å²æ¶ˆæ¯
            // ä»è¿ç»­å·¥ä½œè®°å¿†ä¸­æå–èŠå¤©æ¶ˆæ¯
            let allChatMessages = continuousWorkingMemory
                .filter(event => event.type === 'chat')
                .map(event => event.content);

            // ç§»é™¤å½“å‰è¦å‘é€çš„æ¶ˆæ¯ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            if (allChatMessages.length > 0 && JSON.stringify(allChatMessages[allChatMessages.length - 1].content) === JSON.stringify(message)) {
                allChatMessages.pop();
            }

            // ğŸ”¥ã€æ ¸å¿ƒä¿®å¤ã€‘æŒ‰å›åˆè®¡ç®—å†å²æ¶ˆæ¯
            let recentHistory = calculateMessagesByRounds(allChatMessages, historyCount);

            // è·¨åº”ç”¨äº‹ä»¶æŒ‰ç…§å®é™…å‘ç”Ÿçš„å¯¹è¯å›åˆæ•°è®¡ç®—
            const crossAppEvents = continuousWorkingMemory
                .filter(event => event.type === 'cross_app')
                .slice(-Math.floor(historyCount * 0.2)); // è·¨åº”ç”¨äº‹ä»¶å å·¥ä½œè®°å¿†çš„20%

            const actualRounds = countActualRounds(recentHistory);
            console.log(`ğŸ”— å·¥ä½œè®°å¿†ç»Ÿè®¡:`);
            console.log(`  ğŸ“ èŠå¤©å›åˆæ•°: ${actualRounds}å›åˆ (${recentHistory.length}æ¡æ¶ˆæ¯)`);
            console.log(`  ğŸµ è·¨åº”ç”¨äº‹ä»¶: ${crossAppEvents.length}æ¡`);
            console.log(`  ğŸ“Š æ€»å·¥ä½œè®°å¿†å®¹é‡: ${historyCount}å›åˆ`);
            const messages = [{ role: 'system', content: characterPrompt }];
            
            // ğŸ”¥ã€ä¼˜åŒ–ã€‘åˆ†æå†å²ä¸­çš„å›¾ç‰‡/è¡¨æƒ…åŒ…å†…å®¹ï¼Œå¸®åŠ©AIé¿å…é‡å¤
            const recentImageEmojis = [];
            const emojiEvaluationHistory = new Map(); // è®°å½•æ¯ä¸ªè¡¨æƒ…åŒ…çš„è¯„ä»·å†å²

            recentHistory.forEach((msg, index) => {
                if (msg.isEmoji && msg.emojiDescription) {
                    recentImageEmojis.push(msg.emojiDescription);

                    // è®°å½•AIå¯¹è¡¨æƒ…åŒ…çš„è¯„ä»·å†å²
                    if (msg.sender === 'received' && index > 0) {
                        const prevMsg = recentHistory[index - 1];
                        if (prevMsg && prevMsg.isEmoji && prevMsg.emojiDescription && prevMsg.sender === 'sent') {
                            // AIå›å¤äº†ç”¨æˆ·çš„è¡¨æƒ…åŒ…ï¼Œè®°å½•è¿™ä¸ªè¯„ä»·
                            emojiEvaluationHistory.set(prevMsg.emojiDescription, msg.content);
                        }
                    }
                } else if (msg.image || Array.isArray(msg.content)) {
                    recentImageEmojis.push('å›¾ç‰‡');
                }
            });



            // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘å¤„ç†å†å²æ¶ˆæ¯ - ç¾¤èŠä½¿ç”¨zhangyu.htmlå…¼å®¹æ ¼å¼
            if (isGroupChat) {
                // ç¾¤èŠï¼šä½¿ç”¨zhangyu.htmlçš„æ¶ˆæ¯æ ¼å¼
                const groupMessageHistory = buildGroupChatMessageHistory(recentHistory, character);
                messages.push(...groupMessageHistory);
            } else {
                // å•èŠï¼šä½¿ç”¨åŸæœ‰çš„æ¶ˆæ¯å¤„ç†é€»è¾‘
                recentHistory.forEach(msg => {
                    // ğŸ”¥ã€ä¿®å¤ã€‘å¤„ç†ç³»ç»Ÿæ¶ˆæ¯ï¼ˆå¦‚æ’¤å›æ¶ˆæ¯ï¼‰
                    if (msg.sender === 'system') {
                        // ç³»ç»Ÿæ¶ˆæ¯ä½œä¸ºç”¨æˆ·æ¶ˆæ¯å‘é€ç»™AIï¼Œè®©AIçŸ¥é“å‘ç”Ÿäº†ä»€ä¹ˆ
                        messages.push({
                            role: 'user',
                            content: `[ç³»ç»Ÿæç¤º] ${msg.content}`
                        });
                        return;
                    }

                    let role = msg.sender === 'sent' ? 'user' : 'assistant';
                    let content = msg.content;

                    // ğŸ”¥ã€ä¿®å¤ã€‘å¤„ç†å¼•ç”¨ä¿¡æ¯
                    if (msg.replyTo) {
                        const repliedTo = msg.replyTo;
                        let repliedToAuthorName = 'å¯¹æ–¹';

                        // æ ¹æ®senderå­—æ®µåˆ¤æ–­æ˜¯ç”¨æˆ·è¿˜æ˜¯AI
                        if (repliedTo.sender === 'sent') {
                            repliedToAuthorName = 'ç”¨æˆ·'; // ç”¨æˆ·å‘é€çš„æ¶ˆæ¯
                        } else {
                            // AIæ¶ˆæ¯ï¼Œä½¿ç”¨è§’è‰²åç§°
                            repliedToAuthorName = character.name || 'AI';
                        }

                        // ä½¿ç”¨summarizeLastMessageå‡½æ•°å¤„ç†å¼•ç”¨å†…å®¹ï¼Œéœ€è¦è½¬æ¢æ•°æ®æ ¼å¼
                        const messageForSummary = {
                            content: repliedTo.content,
                            role: repliedTo.sender === 'sent' ? 'user' : 'assistant'
                        };
                        const summarizedQuote = summarizeLastMessage(messageForSummary);
                        content = `[å›å¤ ${repliedToAuthorName} çš„æ¶ˆæ¯: "${summarizedQuote}"] ${content}`;
                    }
                        
                // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘å°†å†å²æ¶ˆæ¯ä¸­çš„ç‰¹æ®Šæ ¼å¼è½¬æ¢ä¸ºAIèƒ½ç†è§£çš„æ–‡æœ¬
                        if (msg.type === 'user_photo') {
                    content = `[ç”¨æˆ·å‘é€äº†ä¸€å¼ ç…§ç‰‡ï¼Œæè¿°æ˜¯ï¼š'${msg.content}']`;
                } else if (msg.type === 'location') {
                    // å¤„ç†ä½ç½®æ¶ˆæ¯ï¼Œä½¿ç”¨æˆ‘ä»¬æ·»åŠ çš„contentå­—æ®µ
                    content = msg.content || `[ç”¨æˆ·åˆ†äº«äº†ä½ç½®ä¿¡æ¯ï¼š${msg.locationName}]`;
                        } else if (msg.type === 'voice_message') {
                            // å¤„ç†è¯­éŸ³æ¶ˆæ¯ï¼ˆç”¨æˆ·å’ŒAIéƒ½å¯èƒ½å‘é€ï¼‰
                            if (msg.sender === 'sent') {
                            content = `[ç”¨æˆ·å‘æ¥ä¸€æ¡è¯­éŸ³æ¶ˆæ¯ï¼Œå†…å®¹æ˜¯ï¼š'${msg.content}']`;
                            } else {
                                content = `[AIå‘æ¥ä¸€æ¡è¯­éŸ³æ¶ˆæ¯ï¼Œå†…å®¹æ˜¯ï¼š'${msg.content}']`;
                            }
                        } else if (msg.type === 'transfer') {
                            // ğŸ”¥ã€ä¿®å¤ã€‘å¤„ç†è½¬è´¦æ¶ˆæ¯ï¼ˆç”¨æˆ·å’ŒAIéƒ½å¯èƒ½å‘é€ï¼‰
                            if (msg.sender === 'sent') {
                    content = `[ç”¨æˆ·å‘èµ·äº†è½¬è´¦ï¼š${msg.amount}å…ƒï¼Œå¤‡æ³¨ï¼š${msg.note || 'æ— '}]`;
                            } else {
                                content = `[AIå‘èµ·äº†è½¬è´¦ï¼š${msg.amount}å…ƒï¼Œå¤‡æ³¨ï¼š${msg.note || 'æ— '}]`;
                            }
                        } else if (msg.type === 'ai_image') {
                            // ğŸ”¥ã€ä¿®å¤ã€‘å¤„ç†AIå‘é€çš„å›¾ç‰‡
                            content = `[AIå‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼Œæè¿°ï¼š${msg.imageDescription || 'æ— æè¿°'}]`;
                        } else if (msg.isEmoji && msg.image) {
                            // ğŸ”¥ã€ä¼˜åŒ–ã€‘å¤„ç†è¡¨æƒ…åŒ…æ¶ˆæ¯ - ç®€åŒ–å†å²è®°å½•ï¼Œé¿å…é‡å¤è¯„ä»·
                            if (msg.sender === 'sent') {
                                // æ£€æŸ¥æ˜¯å¦æ˜¯é‡å¤çš„è¡¨æƒ…åŒ…
                                const isDuplicate = recentHistory.slice(0, recentHistory.indexOf(msg))
                                    .some(prevMsg => prevMsg.isEmoji && prevMsg.emojiDescription === msg.emojiDescription);

                                if (isDuplicate) {
                                    content = `[ç”¨æˆ·å‘é€äº†è¡¨æƒ…åŒ…]`; // ä¸åŒ…å«å…·ä½“æè¿°ï¼Œé¿å…é‡å¤
                                } else {
                                    content = `[ç”¨æˆ·å‘é€äº†è¡¨æƒ…åŒ…ï¼š${msg.emojiDescription || 'è¡¨æƒ…åŒ…'}]`;
                                }
                            } else {
                                content = `[AIå›å¤äº†è¡¨æƒ…åŒ…ï¼š${msg.emojiDescription || 'è¡¨æƒ…åŒ…'}]`;
                            }
                } else if (Array.isArray(msg.content)) {
                    const textPart = msg.content.find(p => p.type === 'text')?.text || '';
                    // ğŸ”¥ã€ä¼˜åŒ–ã€‘ä¿ç•™å›¾ç‰‡ä¸Šä¸‹æ–‡ä½†ç®€åŒ–æè¿°
                    if (textPart.trim()) {
                        content = `[ç”¨æˆ·å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼Œå¹¶è¯´ï¼š'${textPart}']`;
                    } else {
                        content = `[ç”¨æˆ·å‘é€äº†ä¸€å¼ å›¾ç‰‡]`;
                    }
                        } else if (msg.image && !msg.isEmoji) {
                                content = `[ç”¨æˆ·å‘é€äº†ä¸€å¼ å›¾ç‰‡]`;
                        } else if (typeof msg.content === 'object' && msg.content !== null) {
                            // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘å¤„ç†æœªè¢«å¤„ç†çš„å¯¹è±¡ç±»å‹æ¶ˆæ¯
                            console.warn('å†å²æ¶ˆæ¯ä¸­å‘ç°æœªå¤„ç†çš„å¯¹è±¡ç±»å‹:', msg);
                            content = '[ç‰¹æ®Šæ¶ˆæ¯ç±»å‹]';
                        } else if (!content || content === '') {
                            // ğŸ”¥ã€ä¿®å¤ã€‘å¤„ç†ç©ºå†…å®¹
                            content = '[ç©ºæ¶ˆæ¯]';
                }
                
                // ğŸ”¥ã€å®‰å…¨æ£€æŸ¥ã€‘ç¡®ä¿contentæ˜¯å­—ç¬¦ä¸²
                if (typeof content !== 'string') {
                    console.warn('å‘ç°éå­—ç¬¦ä¸²contentï¼Œå¼ºåˆ¶è½¬æ¢:', content);
                    content = String(content);
                }

                // ğŸ”¥ã€æ–°å¢ã€‘ä¸ºAIæä¾›æ¶ˆæ¯IDä¿¡æ¯ï¼Œæ–¹ä¾¿å¼•ç”¨
                if (msg.id) {
                    content = `[ID:${msg.id}] ${content}`;
                }

                    messages.push({ role, content });
                });
            }

            // åªæœ‰çœŸæ­£çš„è·¨åº”ç”¨äº‹ä»¶æ‰é›†æˆåˆ°å·¥ä½œè®°å¿†ä¸­
            if (crossAppEvents.length > 0) {
                const realCrossAppEvents = crossAppEvents.filter(event =>
                    event.appType !== 'chat' // æ’é™¤èŠå¤©äº‹ä»¶
                );

                if (realCrossAppEvents.length > 0) {
                    let crossAppContext = '\n\nã€è·¨åº”ç”¨æ´»åŠ¨è®°å½•ã€‘ä»¥ä¸‹æ˜¯æœ€è¿‘çš„è·¨åº”ç”¨æ´»åŠ¨ï¼š\n';
                    realCrossAppEvents.forEach(event => {
                        const timeStr = new Date(event.timestamp).toLocaleTimeString('zh-CN', {hour: '2-digit', minute: '2-digit'});
                        let description = '';

                        switch (event.appType) {
                            case 'music':
                                if (event.content.action === 'listen_together') {
                                    description = `ä¸€èµ·å¬æ­Œï¼š${event.content.songTitle}`;
                                } else if (event.content.action === 'song_comment') {
                                    description = `å¯¹æ­Œæ›²ã€Š${event.content.songTitle}ã€‹è¯„è®ºï¼š${event.content.comment}`;
                                }
                                break;
                            case 'game':
                                if (event.content && event.content.action === 'game_start') {
                                    description = `å¼€å§‹æ¸¸æˆï¼š${event.content.gameName || 'æœªçŸ¥æ¸¸æˆ'}`;
                                } else if (event.content && event.content.action === 'game_end') {
                                    description = `æ¸¸æˆç»“æŸï¼š${event.content.gameName || 'æœªçŸ¥æ¸¸æˆ'} (å¾—åˆ†: ${event.content.score || 0})`;
                                } else if (event.content && event.content.action === 'game_chat') {
                                    const content = event.content.content || '';
                                    description = `æ¸¸æˆä¸­${event.content.sender === 'user' ? 'ç”¨æˆ·è¯´' : 'AIå›å¤'}ï¼š${content.substring(0, 25)}${content.length > 25 ? '...' : ''}`;
                                } else {
                                    // ğŸ”¥ã€ä¿®å¤ã€‘å¤„ç†actionä¸ºundefinedæˆ–å…¶ä»–æœªçŸ¥æƒ…å†µ
                                    description = `æ¸¸æˆåº”ç”¨æ´»åŠ¨`;
                                }
                                break;
                            default:
                                description = `${event.appType}åº”ç”¨æ´»åŠ¨`;
                        }

                        crossAppContext += `[${timeStr}] ${description}\n`;
                    });

                    // å°†è·¨åº”ç”¨ä¸Šä¸‹æ–‡æ·»åŠ åˆ°ç³»ç»Ÿæç¤ºä¸­
                    characterPrompt += crossAppContext;
                    messages[0].content = characterPrompt;
                    console.log(`ğŸ”— å·²å°†${realCrossAppEvents.length}æ¡çœŸæ­£çš„è·¨åº”ç”¨äº‹ä»¶é›†æˆåˆ°å·¥ä½œè®°å¿†ä¸­`);
                } else {
                    console.log(`âš ï¸ æ²¡æœ‰çœŸæ­£çš„è·¨åº”ç”¨äº‹ä»¶ï¼Œæ‰€æœ‰${crossAppEvents.length}æ¡éƒ½æ˜¯èŠå¤©äº‹ä»¶`);
                }
            }

            // ğŸ”¥ã€ä¼˜åŒ–ã€‘å¦‚æœæœ€è¿‘è®¨è®ºè¿‡å›¾ç‰‡æˆ–è¡¨æƒ…åŒ…ï¼Œç»™AIä¸€ä¸ªå¼ºåˆ¶æ€§æç¤º
            if (recentImageEmojis.length > 0) {
                const uniqueEmojis = [...new Set(recentImageEmojis)];
                let contextHint = `\n\n[é‡è¦æç¤ºï¼šæœ€è¿‘å¯¹è¯ä¸­åŒ…å«äº†${uniqueEmojis.slice(-3).join('ã€')}ç­‰å†…å®¹ã€‚`;

                // å¦‚æœæœ‰è¡¨æƒ…åŒ…è¯„ä»·å†å²ï¼Œæ·»åŠ å¼ºåˆ¶æ€§æŒ‡ä»¤
                if (emojiEvaluationHistory.size > 0) {
                    const evaluatedEmojis = Array.from(emojiEvaluationHistory.keys());
                    contextHint += `ä½ å·²ç»è¯„ä»·è¿‡ä»¥ä¸‹è¡¨æƒ…åŒ…ï¼š${evaluatedEmojis.join('ã€')}ã€‚ä¸¥ç¦å†æ¬¡è¯„ä»·è¿™äº›è¡¨æƒ…åŒ…çš„å¤–è§‚ã€å†…å®¹æˆ–ç‰¹å¾ã€‚`;
                }

                contextHint += `è¯·ä¸“æ³¨äºå¯¹è¯å†…å®¹æœ¬èº«ï¼Œä¸è¦é‡å¤è¯„ä»·å·²ç»è¯„è®ºè¿‡çš„è¡¨æƒ…åŒ…]`;
                characterPrompt += contextHint;
                messages[0].content = characterPrompt; // æ›´æ–°ç³»ç»Ÿæç¤º
            }
            
            // å¤„ç†å½“å‰è¦å‘é€çš„æ¶ˆæ¯ (æœ€å…³é”®çš„æ”¹åŠ¨)
            // å¦‚æœ message æ˜¯æ•°ç»„ï¼Œç›´æ¥ä½¿ç”¨ï¼›å¦‚æœæ˜¯å­—ç¬¦ä¸²ï¼ŒåŒ…è£…æˆæ•°ç»„
            let currentUserContent = Array.isArray(message) ? message : [{ type: 'text', text: message }];

            // ğŸ”¥ã€æ–°å¢ã€‘æ£€æŸ¥å½“å‰æ¶ˆæ¯æ˜¯å¦æ˜¯é‡å¤çš„è¡¨æƒ…åŒ…
            if (pendingUserMessage && pendingUserMessage.isEmoji && pendingUserMessage.emojiDescription) {
                const currentEmojiDesc = pendingUserMessage.emojiDescription;
                const hasEvaluatedBefore = emojiEvaluationHistory.has(currentEmojiDesc);

                if (hasEvaluatedBefore) {
                    // å¦‚æœä¹‹å‰è¯„ä»·è¿‡è¿™ä¸ªè¡¨æƒ…åŒ…ï¼Œä¿®æ”¹å½“å‰æ¶ˆæ¯å†…å®¹
                    currentUserContent = [{ type: 'text', text: `[ç”¨æˆ·å‘é€äº†è¡¨æƒ…åŒ…ï¼Œè¯·ç›´æ¥å›åº”å¯¹è¯å†…å®¹ï¼Œä¸è¦è¯„ä»·è¡¨æƒ…åŒ…æœ¬èº«]` }];
                } else {
                    // ç¬¬ä¸€æ¬¡çœ‹åˆ°è¿™ä¸ªè¡¨æƒ…åŒ…ï¼Œæ­£å¸¸å¤„ç†
                    currentUserContent = [{ type: 'text', text: `[ç”¨æˆ·å‘é€äº†è¡¨æƒ…åŒ…ï¼š${currentEmojiDesc}]` }];
                }
            }

            messages.push({ role: 'user', content: currentUserContent });

            const isGemini = apiSettings.base.includes('generativelanguage.googleapis.com');
            let requestBody;
            let url;
            let headers;
            
            if (isGemini) {
                // Gemini API æ ¼å¼
                url = `${apiSettings.base}/models/${apiSettings.model}:generateContent?key=${apiSettings.key}`;
                headers = { 'Content-Type': 'application/json' };
                
                // è½¬æ¢æ¶ˆæ¯ä¸º Gemini æ ¼å¼
                const geminiContents = messages.map(msg => {
                    const role = msg.role === 'assistant' ? 'model' : 'user';
                    const parts = [];

                    if (Array.isArray(msg.content)) {
                        msg.content.forEach(item => {
                            if (item.type === 'text' && item.text) {
                                parts.push({ text: item.text });
                            } else if (item.type === 'image_url' && item.image_url && item.image_url.url && item.image_url.url.startsWith('data:image')) {
                                const mimeMatch = item.image_url.url.match(/data:image\/([^;]+);base64,(.+)/);
                                if (mimeMatch && mimeMatch[2] && mimeMatch[2].length > 0) {
                                    parts.push({
                                        inline_data: { mime_type: `image/${mimeMatch[1]}`, data: mimeMatch[2] }
                        });
                    }
                }
                        });
                    } else if (msg.content) {
                        parts.push({ text: msg.content });
                    }
                    
                    // ç¡®ä¿æ¯ä¸ªæ¶ˆæ¯è‡³å°‘æœ‰ä¸€ä¸ªpart
                    if (parts.length === 0) {
                        parts.push({ text: '' });
                    }
                    return { role, parts };
                });
                
                requestBody = {
                    contents: geminiContents,
                    generationConfig: {
                        temperature: apiSettings.temperature
                        // ç§»é™¤maxOutputTokensï¼Œgeminiä¸æ”¯æŒè¿™ä¸ªå‚æ•°å
                    }
                };

            } else {
                // OpenAI å…¼å®¹æ ¼å¼ - æ™ºèƒ½å¤„ç†URLæ‹¼æ¥
                // ä¿®å¤ï¼šç¡®ä¿ä¸ä¼šé‡å¤æ·»åŠ /v1è·¯å¾„
                if (apiSettings.base.endsWith('/v1')) {
                    url = `${apiSettings.base}/chat/completions`;
                } else if (apiSettings.base.includes('/v1/')) {
                    // å¦‚æœURLä¸­å·²ç»åŒ…å«/v1/è·¯å¾„ï¼Œç›´æ¥æ·»åŠ chat/completions
                    url = `${apiSettings.base}/chat/completions`;
                } else {
                    url = `${apiSettings.base}/v1/chat/completions`;
                }
                headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiSettings.key}`
                };
                requestBody = {
                    model: apiSettings.model,
                    messages: messages,
                    temperature: apiSettings.temperature
                };
        }
            
            const response = await fetch(url, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(requestBody)
            });
            
            if (!response.ok) {
                    const errorData = await response.json();
                throw new Error(`API Error: ${response.status} - ${errorData.error?.message || 'æœªçŸ¥é”™è¯¯'}`);
            }
            
            const data = await response.json();
            return isGemini ? data.candidates?.[0]?.content?.parts?.[0]?.text : data.choices?.[0]?.message?.content;
        }
        
        // ğŸ”¥ã€æ‰‹åŠ¨æ¸…ç†æ‰€æœ‰æŸåæ¶ˆæ¯ã€‘ç«‹å³æ¸…ç†æ‰€æœ‰èŠå¤©è®°å½•ä¸­çš„[object Object]
        async function emergencyCleanupAllMessages() {
            console.log('ğŸ”¥ [ç´§æ€¥æ¸…ç†] å¼€å§‹æ¸…ç†æ‰€æœ‰èŠå¤©è®°å½•ä¸­çš„æŸåæ¶ˆæ¯...');
            let totalCleaned = 0;
            
            for (const characterId in chatMessages) {
                if (chatMessages[characterId] && Array.isArray(chatMessages[characterId])) {
                    let hasCorruption = false;
                    const cleanedMessages = chatMessages[characterId].map(msg => {
                        if (msg.content === '[object Object]' || 
                            (typeof msg.content === 'object' && msg.content !== null && !Array.isArray(msg.content))) {
                            console.log('ğŸ”¥ [ç´§æ€¥æ¸…ç†] å‘ç°æŸåæ¶ˆæ¯:', msg);
                            hasCorruption = true;
                            totalCleaned++;
                            
                            // æ ¹æ®æ¶ˆæ¯ç±»å‹ä¿®å¤
                            if (msg.type === 'transfer') {
                                return {
                                    ...msg,
                                    content: `ğŸ’° è½¬è´¦ Â¥${msg.amount || 0}${msg.note ? ` - ${msg.note}` : ''}`
                                };
                            } else {
                                return {
                                    ...msg,
                                    content: '[å·²ä¿®å¤çš„ç‰¹æ®Šæ¶ˆæ¯]'
                                };
                            }
                        }
                        return msg;
                    });
                    
                    if (hasCorruption) {
                        chatMessages[characterId] = cleanedMessages;
                        console.log(`ğŸ”¥ [ç´§æ€¥æ¸…ç†] æ¸…ç†äº†è§’è‰² ${characterId} çš„æŸåæ¶ˆæ¯`);
                    }
                }
            }
            
            if (totalCleaned > 0) {
                await saveChatMessages();
                console.log(`ğŸ”¥ [ç´§æ€¥æ¸…ç†] æ€»å…±æ¸…ç†äº† ${totalCleaned} æ¡æŸåæ¶ˆæ¯`);
                
                // é‡æ–°æ¸²æŸ“å½“å‰èŠå¤©
                if (currentChatCharacter) {
                    renderChatMessages(currentChatCharacter.id);
                }
                
                alert(`âœ… å·²æ¸…ç† ${totalCleaned} æ¡æŸåçš„æ¶ˆæ¯ï¼\n\nç°åœ¨AIåº”è¯¥èƒ½æ­£å¸¸æ˜¾ç¤ºè½¬è´¦ç­‰ç‰¹æ®Šæ¶ˆæ¯äº†ã€‚`);
            } else {
                console.log('ğŸ”¥ [ç´§æ€¥æ¸…ç†] æ²¡æœ‰å‘ç°æŸåçš„æ¶ˆæ¯');
            }
        }
        
        // ğŸ”¥ã€æ•°æ®æ¸…ç†å‡½æ•°ã€‘æ¸…ç†èŠå¤©è®°å½•ä¸­æŸåçš„æ¶ˆæ¯
        async function cleanupCorruptedMessages(characterId) {
            if (!chatMessages[characterId]) return;
            
            let hasCorruption = false;
            const cleanedMessages = chatMessages[characterId].map(msg => {
                // æ£€æŸ¥å¹¶ä¿®å¤contentå­—æ®µ
                if (typeof msg.content === 'object' && msg.content !== null && !Array.isArray(msg.content)) {
                    console.log('å‘ç°æŸåçš„æ¶ˆæ¯contentï¼Œæ­£åœ¨ä¿®å¤:', msg);
                    hasCorruption = true;
                    
                    // æ ¹æ®æ¶ˆæ¯ç±»å‹ä¿®å¤content
                    if (msg.type === 'transfer') {
                        return {
                            ...msg,
                            content: `è½¬è´¦ Â¥${msg.amount || 0}${msg.note ? ` - ${msg.note}` : ''}`
                        };
                    } else if (msg.type === 'voice_message') {
                        return {
                            ...msg,
                            content: msg.content.content || '[è¯­éŸ³æ¶ˆæ¯]'
                        };
                    } else if (msg.type === 'ai_image') {
                        return {
                            ...msg,
                            content: `[AIå›¾ç‰‡]${msg.imageDescription ? ` - ${msg.imageDescription}` : ''}`
                        };
                    } else if (msg.isEmoji) {
                        return {
                            ...msg,
                            content: `[è¡¨æƒ…åŒ…]${msg.emojiDescription ? ` - ${msg.emojiDescription}` : ''}`
                        };
                    } else {
                        // é€šç”¨ä¿®å¤ï¼šæå–å¯èƒ½çš„æ–‡æœ¬å†…å®¹
                        const possibleContent = msg.content.content || msg.content.message || msg.content.text || '[ç‰¹æ®Šæ¶ˆæ¯]';
                        return {
                            ...msg,
                            content: possibleContent
                        };
                    }
                }
                
                // æ£€æŸ¥contentæ˜¯å¦ä¸ºå­—ç¬¦ä¸²
                if (msg.content && typeof msg.content !== 'string' && !Array.isArray(msg.content)) {
                    console.log('å‘ç°éå­—ç¬¦ä¸²contentï¼Œæ­£åœ¨ä¿®å¤:', msg);
                    hasCorruption = true;
                    return {
                        ...msg,
                        content: String(msg.content)
                    };
                }
                
                return msg;
            });
            
            // å¦‚æœå‘ç°æŸåçš„æ•°æ®ï¼Œä¿å­˜ä¿®å¤åçš„æ•°æ®
            if (hasCorruption) {
                console.log('æ£€æµ‹åˆ°æŸåçš„æ¶ˆæ¯æ•°æ®ï¼Œå·²è‡ªåŠ¨ä¿®å¤å¹¶ä¿å­˜');
                chatMessages[characterId] = cleanedMessages;
                await saveChatMessages();
                
                // é‡æ–°æ¸²æŸ“èŠå¤©ç•Œé¢
                if (currentChatCharacter && currentChatCharacter.id === characterId) {
                    renderChatMessages(characterId);
                }
            }
        }
        
        // ================== è®°å¿†è®¾ç½®ç›¸å…³åŠŸèƒ½ ==================
        
        // è·å–æŒ‚è½½çš„èŠå¤©è®°å¿†
        async function getMountedMemories(currentCharacterId, chatSettings) {
            if (!chatSettings.memoryMountEnabled || !chatSettings.selectedMemoryChats || chatSettings.selectedMemoryChats.length === 0) {
                return '';
            }
            
            const mountCount = chatSettings.memoryMountCount || 3;
            let mountedMemoryContent = '';
            
            for (const chatId of chatSettings.selectedMemoryChats) {
                // è·³è¿‡å½“å‰èŠå¤©
                if (chatId === currentCharacterId) continue;
                
                // è·å–è¯¥èŠå¤©çš„å†å²è®°å½•
                const chatHistory = chatMessages[chatId] || [];
                if (chatHistory.length === 0) continue;
                
                // è·å–æœ€è¿‘çš„å‡ æ¡è®°å½•
                const recentMessages = chatHistory.slice(-mountCount);
                if (recentMessages.length === 0) continue;
                
                // è·å–èŠå¤©å¯¹è±¡çš„åç§°
                let chatName = 'æœªçŸ¥èŠå¤©';
                let chatType = 'å•èŠ';
                
                // æŸ¥æ‰¾å•èŠè§’è‰²
                const character = characters.find(c => c.id === chatId);
                if (character) {
                    chatName = character.name;
                    chatType = 'å•èŠ';
                } else {
                    // æŸ¥æ‰¾ç¾¤èŠ
                    const group = groupChats.find(g => g.id === chatId);
                    if (group) {
                        chatName = group.name;
                        chatType = 'ç¾¤èŠ';
                    }
                }
                
                // æ„å»ºè®°å¿†å†…å®¹
                mountedMemoryContent += `\n\nã€${chatType}è®°å¿† - ${chatName}ã€‘ä»¥ä¸‹æ˜¯ä¸${chatName}çš„æœ€è¿‘å¯¹è¯ï¼Œå¯ä»¥ä½œä¸ºèƒŒæ™¯å‚è€ƒï¼š\n`;
                
                recentMessages.forEach(msg => {
                    let sender = '';
                    let content = msg.content || '';
                    
                    if (msg.sender === 'sent') {
                        sender = 'ç”¨æˆ·';
                    } else if (msg.sender === 'received' || msg.sender === 'ai') {
                        if (chatType === 'ç¾¤èŠ' && msg.name) {
                            sender = msg.name; // ç¾¤èŠä¸­çš„å‘è¨€è€…åç§°
                        } else {
                            sender = chatName; // å•èŠä¸­ä½¿ç”¨è§’è‰²åç§°
                        }
                    } else {
                        sender = 'ç³»ç»Ÿ';
                    }
                    
                    // å¤„ç†ç‰¹æ®Šæ¶ˆæ¯ç±»å‹
                    if (msg.type === 'voice_message') {
                        content = `[è¯­éŸ³æ¶ˆæ¯ï¼š${content}]`;
                    } else if (msg.type === 'transfer') {
                        content = `[è½¬è´¦ï¼š${msg.amount}å…ƒ${msg.note ? ` - ${msg.note}` : ''}]`;
                    } else if (msg.type === 'ai_image') {
                        content = `[AIå›¾ç‰‡ï¼š${msg.imageDescription || 'æ— æè¿°'}]`;
                    } else if (msg.isEmoji) {
                        content = `[è¡¨æƒ…åŒ…ï¼š${msg.emojiDescription || 'è¡¨æƒ…åŒ…'}]`;
                    } else if (msg.type === 'location') {
                        content = `[ä½ç½®åˆ†äº«ï¼š${msg.locationName || 'ä½ç½®ä¿¡æ¯'}]`;
                    } else if (Array.isArray(content)) {
                        // å¤„ç†æ•°ç»„ç±»å‹çš„å†…å®¹ï¼ˆå›¾ç‰‡+æ–‡å­—ï¼‰
                        const textPart = content.find(p => p.type === 'text')?.text || '';
                        content = textPart ? `[å›¾ç‰‡+æ–‡å­—ï¼š${textPart}]` : '[å›¾ç‰‡]';
                    }
                    
                    // ç¡®ä¿contentæ˜¯å­—ç¬¦ä¸²ä¸”ä¸ä¸ºç©º
                    if (typeof content !== 'string' || !content.trim()) {
                        content = '[ç‰¹æ®Šæ¶ˆæ¯]';
                    }
                    
                    mountedMemoryContent += `${sender}ï¼š${content}\n`;
                });
            }
            
            if (mountedMemoryContent.trim()) {
                console.log('ğŸ§  æˆåŠŸåŠ è½½æŒ‚è½½è®°å¿†ï¼Œæ¶‰åŠèŠå¤©æ•°:', chatSettings.selectedMemoryChats.length);
                return mountedMemoryContent;
            }
            
            return '';
        }
        
        // ğŸ”¥ã€æ–°å¢ã€‘æ•°æ®æ ¼å¼è½¬æ¢å‡½æ•°ï¼šå°†ç°æœ‰ç¾¤èŠè½¬æ¢ä¸ºzhangyu.htmlå…¼å®¹æ ¼å¼
        function convertGroupChatToZhangyuFormat(groupChat) {
            if (!groupChat.members) return groupChat;

            // è½¬æ¢æˆå‘˜æ•°æ®ç»“æ„
            const convertedMembers = groupChat.members.map(member => ({
                id: member.id,
                name: member.name,
                persona: member.persona || member.bio, // ğŸ”¥ã€å…³é”®ã€‘ç¡®ä¿ä½¿ç”¨personaå­—æ®µ
                avatarUrl: member.avatarUrl,
                color: member.color
            }));

            // ç¡®ä¿æœ‰settingsç»“æ„
            if (!groupChat.settings) {
                groupChat.settings = {
                    myPersona: 'ç”¨æˆ·',
                    myNickname: 'æˆ‘'
                };
            }

            return {
                ...groupChat,
                members: convertedMembers
            };
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ„å»ºç¾¤èŠæ¶ˆæ¯å†å²è®°å½•ï¼Œå…¼å®¹zhangyu.htmlæ ¼å¼
        function buildGroupChatMessageHistory(messages, groupChat) {
            if (!messages || !Array.isArray(messages)) return [];

            return messages.map(msg => {
                // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†ç¾¤èŠä¸­çš„ç³»ç»Ÿæ¶ˆæ¯
                if (msg.sender === 'system') {
                    return { role: 'user', content: `[ç³»ç»Ÿæç¤º] ${msg.content}` };
                } else if (msg.sender === 'sent') {
                    // ç”¨æˆ·æ¶ˆæ¯ï¼šä½¿ç”¨ç¾¤èŠè®¾ç½®ä¸­çš„æ˜µç§°
                    const chatSettings = getCurrentChatSettings();
                    const myNickname = chatSettings.myChatNickname || groupChat.settings?.myNickname || 'æˆ‘';

                    let content;
                    if (msg.type === 'user_photo') {
                        content = `[${myNickname} å‘é€äº†ä¸€å¼ æè¿°çš„ç…§ç‰‡ï¼Œå†…å®¹æ˜¯ï¼š'${msg.content}']`;
                    } else if (msg.type === 'voice_message') {
                        content = `[${myNickname} å‘é€äº†ä¸€æ¡è¯­éŸ³ï¼Œå†…å®¹æ˜¯ï¼š'${msg.content}']`;
                    } else if (msg.type === 'transfer') {
                        content = `[${msg.senderName}å‘${msg.receiverName}è½¬è´¦ ${msg.amount}å…ƒ, å¤‡æ³¨: ${msg.note}]`;
                    } else if (msg.meaning) {
                        content = `${myNickname}: [å‘é€äº†ä¸€ä¸ªè¡¨æƒ…ï¼Œæ„æ€æ˜¯: '${msg.meaning}']`;
                    } else {
                        content = `${myNickname}: ${msg.content}`;
                    }

                    // ğŸ”¥ã€ä¿®å¤ã€‘å¤„ç†ç”¨æˆ·æ¶ˆæ¯çš„å¼•ç”¨ä¿¡æ¯
                    if (msg.replyTo) {
                        const replyPrefix = `[${myNickname} å›å¤ ${msg.replyTo.senderName}: "${msg.replyTo.content}"] `;
                        content = replyPrefix + content.replace(`${myNickname}: `, '');
                    }

                    // ğŸ”¥ã€æ–°å¢ã€‘ä¸ºç¾¤èŠæ¶ˆæ¯æ·»åŠ IDä¿¡æ¯ï¼Œæ–¹ä¾¿AIå¼•ç”¨
                    if (msg.id) {
                        content = `[ID:${msg.id}] ${content}`;
                    }

                    return { role: 'user', content: content };
                } else {
                    // AIæ¶ˆæ¯ï¼šæ ¹æ®senderIdæˆ–nameæŸ¥æ‰¾å‘é€è€…
                    const sender = msg.senderName || msg.name || 'æœªçŸ¥';

                    let content;
                    if (msg.type === 'ai_image') {
                        content = `[${sender} å‘é€äº†ä¸€å¼ å›¾ç‰‡]`;
                    } else if (msg.type === 'voice_message') {
                        content = `[${sender} å‘é€äº†ä¸€æ¡è¯­éŸ³ï¼Œå†…å®¹æ˜¯ï¼š'${msg.content}']`;
                    } else if (msg.type === 'transfer') {
                        content = `[${msg.senderName}å‘${msg.receiverName}è½¬è´¦ ${msg.amount}å…ƒ, å¤‡æ³¨: ${msg.note}]`;
                    } else if (msg.meaning) {
                        content = `${sender}: [å‘é€äº†ä¸€ä¸ªè¡¨æƒ…ï¼Œæ„æ€æ˜¯: '${msg.meaning}']`;
                    } else if (Array.isArray(msg.content)) {
                        content = [...msg.content, { type: 'text', text: `${sender}:` }];
                    } else {
                        content = `${sender}: ${msg.content}`;
                    }

                    // ğŸ”¥ã€ä¿®å¤ã€‘å¤„ç†AIæ¶ˆæ¯çš„å¼•ç”¨ä¿¡æ¯
                    if (msg.replyTo) {
                        const replyPrefix = `[${sender} å›å¤ ${msg.replyTo.senderName}: "${msg.replyTo.content}"] `;
                        content = replyPrefix + content.replace(`${sender}: `, '');
                    }

                    // ğŸ”¥ã€æ–°å¢ã€‘ä¸ºç¾¤èŠæ¶ˆæ¯æ·»åŠ IDä¿¡æ¯ï¼Œæ–¹ä¾¿AIå¼•ç”¨
                    if (msg.id) {
                        content = `[ID:${msg.id}] ${content}`;
                    }

                    return { role: 'user', content: content };
                }
            });
        }



        // ğŸ”¥ã€æ–°å¢ã€‘ç›‘æ§localStorageä½¿ç”¨æƒ…å†µ
        function checkLocalStorageUsage() {
            try {
                let totalSize = 0;
                const items = [];

                for (let key in localStorage) {
                    if (localStorage.hasOwnProperty(key)) {
                        const size = localStorage[key].length;
                        totalSize += size;
                        items.push({ key, size });
                    }
                }

                const totalSizeMB = (totalSize / 1024 / 1024).toFixed(2);
                console.log(`ğŸ“Š localStorageæ€»ä½¿ç”¨é‡: ${totalSizeMB}MB`);

                // æ˜¾ç¤ºæœ€å¤§çš„å‡ ä¸ªé¡¹ç›®
                items.sort((a, b) => b.size - a.size);
                items.slice(0, 5).forEach(item => {
                    const sizeMB = (item.size / 1024 / 1024).toFixed(2);
                    console.log(`  - ${item.key}: ${sizeMB}MB`);
                });

                // å¦‚æœæ¥è¿‘5MBé™åˆ¶ï¼Œå‘å‡ºè­¦å‘Š
                if (totalSize > 4 * 1024 * 1024) {
                    console.warn('âš ï¸ localStorageä½¿ç”¨é‡æ¥è¿‘é™åˆ¶ï¼Œå»ºè®®æ¸…ç†å¤‡ä»½æ•°æ®');
                }

                return { totalSize, items };
            } catch (error) {
                console.error('æ£€æŸ¥localStorageä½¿ç”¨é‡å¤±è´¥:', error);
                return { totalSize: 0, items: [] };
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘è§£æç¾¤èŠAIå“åº”ï¼Œå…¼å®¹zhangyu.htmlæ ¼å¼
        function parseGroupChatAiResponse(aiResponseContent, groupChat) {
            try {
                // ğŸ”¥ã€ä¿®å¤ã€‘æ¸…ç†markdownä»£ç å—æ ¼å¼
                let cleanContent = aiResponseContent.trim();
                if (cleanContent.startsWith('```json')) {
                    cleanContent = cleanContent.replace(/^```json\s*/, '').replace(/\s*```$/, '');
                } else if (cleanContent.startsWith('```')) {
                    cleanContent = cleanContent.replace(/^```\s*/, '').replace(/\s*```$/, '');
                }

                const messagesArray = JSON.parse(cleanContent);
                if (!Array.isArray(messagesArray)) {
                    console.error('ç¾¤èŠAIå“åº”ä¸æ˜¯æ•°ç»„æ ¼å¼');
                    return [];
                }

                const processedMessages = [];

                for (const msgData of messagesArray) {
                    if (typeof msgData === 'object' && msgData.name && msgData.message) {
                        // ğŸ”¥ã€å…³é”®ã€‘zhangyu.htmlæ ¼å¼çš„æ™®é€šæ¶ˆæ¯
                        const member = groupChat.members.find(m => m.name === msgData.name);
                        if (member) {
                            processedMessages.push({
                                id: Date.now() + Math.random(),
                                sender: 'received',
                                content: msgData.message,
                                timestamp: Date.now(),
                                senderId: member.id,
                                senderName: member.name,
                                name: member.name
                            });
                        }
                    } else if (typeof msgData === 'object' && msgData.name && msgData.type === 'ai_image') {
                        // ç¾¤èŠå›¾ç‰‡æ¶ˆæ¯
                        const member = groupChat.members.find(m => m.name === msgData.name);
                        if (member) {
                            processedMessages.push({
                                id: Date.now() + Math.random(),
                                sender: 'received',
                                type: 'ai_image',
                                content: msgData.description || 'AIæè¿°çš„å›¾ç‰‡',
                                imageDescription: msgData.description,
                                timestamp: Date.now(),
                                senderId: member.id,
                                senderName: member.name,
                                name: member.name
                            });
                        }
                    } else if (typeof msgData === 'object' && msgData.name && msgData.type === 'voice_message') {
                        // ç¾¤èŠè¯­éŸ³æ¶ˆæ¯
                        const member = groupChat.members.find(m => m.name === msgData.name);
                        if (member) {
                            processedMessages.push({
                                id: Date.now() + Math.random(),
                                sender: 'received',
                                type: 'voice_message',
                                content: msgData.content,
                                timestamp: Date.now(),
                                senderId: member.id,
                                senderName: member.name,
                                name: member.name
                            });
                        }
                    } else if (typeof msgData === 'object' && msgData.name && msgData.type === 'emoji') {
                        // ğŸ”¥ã€æ–°å¢ã€‘ç¾¤èŠè¡¨æƒ…åŒ…æ¶ˆæ¯
                        console.log('ğŸ” [parseGroupChatAiResponse] æ£€æµ‹åˆ°ç¾¤èŠè¡¨æƒ…åŒ…:', msgData);

                        const member = groupChat.members.find(m => m.name === msgData.name);
                        if (member) {
                            const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.description);
                            if (matchingEmoji) {
                                console.log('ğŸ” [parseGroupChatAiResponse] æ‰¾åˆ°åŒ¹é…çš„è¡¨æƒ…åŒ…:', matchingEmoji);

                                processedMessages.push({
                                    id: Date.now() + Math.random(),
                                    sender: 'received',
                                    content: '', // è¡¨æƒ…åŒ…æ¶ˆæ¯ä¸æ˜¾ç¤ºæ–‡å­—å†…å®¹
                                    image: matchingEmoji.url,
                                    isEmoji: true,
                                    emojiDescription: matchingEmoji.description,
                                    timestamp: Date.now(),
                                    senderId: member.id,
                                    senderName: member.name,
                                    name: member.name
                                });

                                // æ·»åŠ åˆ°æœ€è¿‘ä½¿ç”¨çš„è¡¨æƒ…åŒ…
                                addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                            } else {
                                console.warn('ğŸ” [parseGroupChatAiResponse] æ‰¾ä¸åˆ°åŒ¹é…çš„è¡¨æƒ…åŒ…:', msgData.description);

                                // å¦‚æœæ‰¾ä¸åˆ°åŒ¹é…çš„è¡¨æƒ…åŒ…ï¼Œå‘é€é”™è¯¯æ¶ˆæ¯
                                processedMessages.push({
                                    id: Date.now() + Math.random(),
                                    sender: 'received',
                                    content: `[è¡¨æƒ…åŒ…"${msgData.description}"ä¸å­˜åœ¨]`,
                                    timestamp: Date.now(),
                                    senderId: member.id,
                                    senderName: member.name,
                                    name: member.name
                                });
                            }
                        } else {
                            console.warn('ğŸ” [parseGroupChatAiResponse] æ‰¾ä¸åˆ°å‘é€è¡¨æƒ…åŒ…çš„æˆå‘˜:', msgData.name);
                        }
                    } else if (typeof msgData === 'string') {
                        // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘å¤„ç†æ™®é€šå­—ç¬¦ä¸²æ¶ˆæ¯ - åˆ†é…ç»™ç¬¬ä¸€ä¸ªç¾¤æˆå‘˜
                        console.log('ğŸ” [parseGroupChatAiResponse] æ£€æµ‹åˆ°å­—ç¬¦ä¸²æ¶ˆæ¯:', msgData);
                        if (groupChat.members && groupChat.members.length > 0) {
                            const defaultMember = groupChat.members[0]; // ä½¿ç”¨ç¬¬ä¸€ä¸ªæˆå‘˜ä½œä¸ºé»˜è®¤å‘é€è€…
                            processedMessages.push({
                                id: Date.now() + Math.random(),
                                sender: 'received',
                                content: msgData,
                                timestamp: Date.now(),
                                senderId: defaultMember.id,
                                senderName: defaultMember.name,
                                name: defaultMember.name
                            });
                            console.log('ğŸ” [parseGroupChatAiResponse] å­—ç¬¦ä¸²æ¶ˆæ¯åˆ†é…ç»™:', defaultMember.name);
                        }
                    } else {
                        console.warn('ğŸ” [parseGroupChatAiResponse] æœªè¯†åˆ«çš„æ¶ˆæ¯æ ¼å¼:', msgData);
                    }
                }

                return processedMessages;
            } catch (error) {
                console.error('è§£æç¾¤èŠAIå“åº”å¤±è´¥:', error);
                return [];
            }
        }

        // åŠ è½½ç¾¤èŠæ•°æ® - ä½¿ç”¨IndexedDBï¼ˆåŒ…å«æ•°æ®è¿ç§»å’Œæ ¼å¼è½¬æ¢ï¼‰
        async function loadGroupChats() {
            try {
                // å…ˆä»IndexedDBåŠ è½½
                const savedGroupChats = await db.groupChats.toArray();

                if (savedGroupChats.length === 0) {
                    // IndexedDBä¸­æ²¡æœ‰æ•°æ®ï¼Œå°è¯•ä»localStorageè¿ç§»
                    const localStorageData = localStorage.getItem('groupChats');
                    if (localStorageData) {
                        console.log('æ£€æµ‹åˆ°localStorageä¸­çš„ç¾¤èŠæ•°æ®ï¼Œå¼€å§‹è¿ç§»...');
                        const localGroupChats = JSON.parse(localStorageData);
                        
                        if (localGroupChats.length > 0) {
                            // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘ç¡®ä¿æ¯ä¸ªç¾¤èŠéƒ½æœ‰å¿…è¦å­—æ®µå¹¶è½¬æ¢ä¸ºzhangyuæ ¼å¼
                            const migrationData = localGroupChats.map(group => convertGroupChatToZhangyuFormat({
                                id: group.id || Date.now().toString() + Math.random(),
                                name: group.name,
                                description: group.description || '',
                                members: group.members || [],
                                settings: group.settings || {},
                                createdAt: group.createdAt || new Date().toISOString(),
                                updatedAt: group.updatedAt || new Date().toISOString()
                            }));
                            
                            // è¿ç§»åˆ°IndexedDB
                            await db.groupChats.bulkAdd(migrationData);
                            groupChats = migrationData;
                            console.log('ç¾¤èŠæ•°æ®è¿ç§»å®Œæˆ:', groupChats);
                        } else {
                            groupChats = [];
                        }
                    } else {
                        groupChats = [];
                    }
                } else {
                    // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘IndexedDBä¸­æœ‰æ•°æ®ï¼Œè½¬æ¢ä¸ºzhangyuæ ¼å¼åä½¿ç”¨
                    groupChats = savedGroupChats.map(convertGroupChatToZhangyuFormat);
                    console.log('ä»IndexedDBåŠ è½½ç¾¤èŠæ•°æ®ï¼ˆå·²è½¬æ¢ä¸ºzhangyuæ ¼å¼ï¼‰:', groupChats);
                }
            } catch (error) {
                console.error('åŠ è½½ç¾¤èŠå¤±è´¥:', error);
                // ğŸ”¥ã€ä¼˜åŒ–ã€‘å¦‚æœIndexedDBå¤±è´¥ï¼Œè°¨æ…å›é€€åˆ°localStorage
                const localStorageData = localStorage.getItem('groupChats');
                if (localStorageData) {
                    try {
                        const localData = JSON.parse(localStorageData);
                        // ğŸ”¥ã€æ–°å¢ã€‘æ£€æŸ¥localStorageæ•°æ®çš„å¤§å°å’Œæœ‰æ•ˆæ€§
                        if (Array.isArray(localData) && localData.length > 0) {
                            groupChats = localData.map(convertGroupChatToZhangyuFormat);
                            console.log('ä»localStorageå›é€€åŠ è½½ç¾¤èŠæ•°æ®ï¼ˆå·²è½¬æ¢æ ¼å¼ï¼‰:', groupChats);

                            // ğŸ”¥ã€ä¼˜åŒ–ã€‘å°è¯•é‡æ–°ä¿å­˜åˆ°IndexedDB
                            try {
                                await db.groupChats.bulkAdd(groupChats);
                                console.log('å·²å°†localStorageæ•°æ®é‡æ–°ä¿å­˜åˆ°IndexedDB');
                                // æˆåŠŸä¿å­˜åï¼Œå¯ä»¥è€ƒè™‘æ¸…ç†localStorageï¼ˆå¦‚æœæ•°æ®è¿‡å¤§ï¼‰
                                const dataSize = localStorageData.length;
                                if (dataSize > 1024 * 1024) { // è¶…è¿‡1MB
                                    localStorage.removeItem('groupChats');
                                    console.log('å·²æ¸…ç†è¿‡å¤§çš„localStorageå¤‡ä»½');
                                }
                            } catch (saveError) {
                                console.warn('é‡æ–°ä¿å­˜åˆ°IndexedDBå¤±è´¥:', saveError);
                            }
                        } else {
                            groupChats = [];
                        }
                    } catch (e) {
                        console.error('ç¾¤èŠæ•°æ®è§£æå¤±è´¥:', e);
                        groupChats = [];
                    }
                } else {
                    groupChats = [];
                }
            }
        }
        
        // æ˜¾ç¤ºå†å²æ¶ˆæ¯è®¾ç½®
        function showHistorySettings() {
            const chatSettings = getCurrentChatSettings();
            const historyCount = chatSettings.historyCount;
            document.getElementById('history-messages-count').value = Math.min(historyCount, 100);
            document.getElementById('custom-history-count').value = historyCount;
            document.getElementById('history-count-display').textContent = historyCount + 'å›åˆ';

            // ç»‘å®šæ»‘å—äº‹ä»¶
            document.getElementById('history-messages-count').oninput = function() {
                const value = parseInt(this.value);
                document.getElementById('history-count-display').textContent = value + 'å›åˆ';
                document.getElementById('custom-history-count').value = value;
            };

            // ç»‘å®šè‡ªå®šä¹‰è¾“å…¥æ¡†äº‹ä»¶
            document.getElementById('custom-history-count').oninput = function() {
                const value = Math.max(0, Math.min(500, parseInt(this.value) || 0));
                this.value = value;
                if (value <= 100) {
                    document.getElementById('history-messages-count').value = value;
                }
                document.getElementById('history-count-display').textContent = value + 'å›åˆ';
            };

            showModal('history-settings-modal');
        }
        
        // ä¿å­˜å†å²æ¶ˆæ¯è®¾ç½®
        function saveHistorySettings() {
            const chatSettings = getCurrentChatSettings();
            const customValue = parseInt(document.getElementById('custom-history-count').value);
            chatSettings.historyCount = Math.max(0, Math.min(500, customValue || 0));

            // æ›´æ–°è®¾ç½®ç•Œé¢æ˜¾ç¤ºçš„å½“å‰å€¼
            document.getElementById('current-history-count').textContent = chatSettings.historyCount + 'å›åˆ';

            saveCurrentChatSettings(chatSettings);
            hideModal('history-settings-modal');
            showToast('å†å²æ¶ˆæ¯è®¾ç½®å·²ä¿å­˜', 'success');
        }
        
        // æ˜¾ç¤ºå¤´åƒè®¾ç½®
        function showAvatarSettings() {
            // åŠ è½½å½“å‰èŠå¤©çª—å£çš„å¤´åƒè®¾ç½®
            const chatSettings = getCurrentChatSettings();
            
            // è®¾ç½®éšè—å¤´åƒé€‰é¡¹
            const hideAvatarsCheckbox = document.getElementById('hide-avatars');
            if (hideAvatarsCheckbox) {
                hideAvatarsCheckbox.checked = chatSettings.hideAvatars || false;
            }
            
            // è®¾ç½®æˆ‘çš„å¤´åƒé¢„è§ˆ
            const myAvatarPreview = document.getElementById('my-chat-avatar-preview');
            if (chatSettings.myChatAvatar) {
                myAvatarPreview.style.backgroundImage = `url(${chatSettings.myChatAvatar})`;
                myAvatarPreview.style.backgroundSize = 'cover';
                myAvatarPreview.style.backgroundPosition = 'center';
                myAvatarPreview.innerHTML = '';
            } else {
                myAvatarPreview.style.backgroundImage = 'none';
                myAvatarPreview.innerHTML = '<i class="fas fa-user"></i>';
            }
            
            // è®¾ç½®å¯¹æ–¹å¤´åƒé¢„è§ˆ - æ˜¾ç¤ºå½“å‰å®é™…ä½¿ç”¨çš„å¤´åƒï¼ˆä¼˜å…ˆæ˜¾ç¤ºåŠ¨æ€å¤´åƒï¼‰
            const aiAvatarPreview = document.getElementById('ai-chat-avatar-preview');
            const currentAiAvatar = chatSettings.aiDynamicAvatar || chatSettings.aiChatAvatar;
            if (currentAiAvatar) {
                aiAvatarPreview.style.backgroundImage = `url(${currentAiAvatar})`;
                aiAvatarPreview.style.backgroundSize = 'cover';
                aiAvatarPreview.style.backgroundPosition = 'center';
                aiAvatarPreview.innerHTML = '';
                
                // å¦‚æœæ˜¯åŠ¨æ€å¤´åƒï¼Œæ·»åŠ æç¤º
                if (chatSettings.aiDynamicAvatar) {
                    aiAvatarPreview.title = 'å½“å‰æ˜¾ç¤ºåŠ¨æ€å¤´åƒï¼ˆè§’è‰²åœ¨èŠå¤©ä¸­æ›´æ¢çš„ï¼‰';
                } else {
                    aiAvatarPreview.title = 'å½“å‰æ˜¾ç¤ºèŠå¤©è®¾ç½®å¤´åƒ';
                }
            } else {
                aiAvatarPreview.style.backgroundImage = 'none';
                aiAvatarPreview.innerHTML = '<i class="fas fa-robot"></i>';
                aiAvatarPreview.title = 'ä½¿ç”¨é»˜è®¤å¤´åƒ';
            }
            
            // ç»‘å®šæ–‡ä»¶ä¸Šä¼ äº‹ä»¶
            bindAvatarUploadEvents();
            
            showModal('avatar-settings-modal');
        }
        
        // æ˜¾ç¤ºæ˜µç§°è®¾ç½®
        function showNicknameSettings() {
            const chatSettings = getCurrentChatSettings();
            document.getElementById('my-chat-nickname').value = chatSettings.myChatNickname || '';
            document.getElementById('ai-chat-nickname').value = chatSettings.aiChatNickname || '';
            showModal('nickname-settings-modal');
        }
        
        // æ˜¾ç¤ºæˆ³ä¸€æˆ³åç¼€è®¾ç½®
        function showPokeSuffixSettings() {
            const chatSettings = getCurrentChatSettings();
            document.getElementById('my-poke-suffix').value = chatSettings.myPokeSuffix || '';
            document.getElementById('ai-poke-suffix').value = chatSettings.aiPokeSuffix || '';
            showModal('poke-suffix-modal');
        }
        
        // æ˜¾ç¤ºèŠå¤©èƒŒæ™¯è®¾ç½®
        function showBackgroundSettings() {
            const backgroundPreview = document.getElementById('chat-background-preview');
            
            // é‡ç½®é€‰æ‹©çŠ¶æ€
            window.selectedChatBackground = undefined;
            
            // ä½¿ç”¨currentChatCharacter.backgroundè€Œä¸æ˜¯chatSettings.chatBackground
            if (currentChatCharacter && currentChatCharacter.background) {
                backgroundPreview.style.backgroundImage = `url(${currentChatCharacter.background})`;
                backgroundPreview.style.backgroundSize = 'cover';
                backgroundPreview.style.backgroundPosition = 'center';
                backgroundPreview.querySelector('.preview-text').style.display = 'none';
            } else {
                backgroundPreview.style.backgroundImage = 'none';
                backgroundPreview.querySelector('.preview-text').style.display = 'block';
                backgroundPreview.querySelector('.preview-text').textContent = 'èƒŒæ™¯é¢„è§ˆ';
            }
            
            // ç»‘å®šèƒŒæ™¯ä¸Šä¼ äº‹ä»¶
            document.getElementById('background-upload').onchange = function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        backgroundPreview.style.backgroundImage = `url(${event.target.result})`;
                        backgroundPreview.style.backgroundSize = 'cover';
                        backgroundPreview.style.backgroundPosition = 'center';
                        backgroundPreview.querySelector('.preview-text').style.display = 'none';
                        window.selectedChatBackground = event.target.result;
                    };
                    reader.readAsDataURL(e.target.files[0]);
                }
            };
            
            showModal('background-settings-modal');
        }
        
        // æ˜¾ç¤ºæ°”æ³¡æ ·å¼è®¾ç½®
        function showBubbleStyleSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // ğŸ”¥ã€æ–°å¢ã€‘æ£€æŸ¥æ˜¯å¦ä¸ºç¾¤èŠï¼Œæ˜¾ç¤º/éšè—ç¾¤æˆå‘˜è®¾ç½®æŒ‰é’®
            const groupColorsBtn = document.getElementById('group-member-colors-btn');
            if (currentChatCharacter && currentChatCharacter.isGroup) {
                groupColorsBtn.style.display = 'block';
            } else {
                groupColorsBtn.style.display = 'none';
            }
            
            // åŠ è½½å½“å‰è®¾ç½®
            const currentStyle = chatSettings.bubbleStyle || 'default';
            document.getElementById('my-bubble-color').value = chatSettings.myBubbleColor || '#007AFF';
            document.getElementById('ai-bubble-color').value = chatSettings.aiBubbleColor || '#f0f0f0';
            
            // åŠ è½½åˆ†ç¦»çš„é€æ˜åº¦è®¾ç½®
            document.getElementById('my-bubble-opacity').value = chatSettings.myBubbleOpacity || '1';
            document.getElementById('my-bubble-opacity-value').textContent = Math.round((chatSettings.myBubbleOpacity || 1) * 100) + '%';
            document.getElementById('ai-bubble-opacity').value = chatSettings.aiBubbleOpacity || '1';
            document.getElementById('ai-bubble-opacity-value').textContent = Math.round((chatSettings.aiBubbleOpacity || 1) * 100) + '%';
            
            // è®¾ç½®å½“å‰é€‰ä¸­çš„æ ·å¼
            document.querySelectorAll('.bubble-style-option').forEach(option => {
                option.classList.remove('selected');
                if (option.dataset.style === currentStyle) {
                    option.classList.add('selected');
                }
            });
            
            // ç»‘å®šæ ·å¼é€‰æ‹©äº‹ä»¶
            document.querySelectorAll('.bubble-style-option').forEach(option => {
                option.onclick = function() {
                    document.querySelectorAll('.bubble-style-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    this.classList.add('selected');
                    window.selectedBubbleStyle = this.dataset.style;
                };
            });
            
            // ç»‘å®šåˆ†ç¦»çš„é€æ˜åº¦äº‹ä»¶
            document.getElementById('my-bubble-opacity').oninput = function() {
                document.getElementById('my-bubble-opacity-value').textContent = Math.round(this.value * 100) + '%';
            };
            
            document.getElementById('ai-bubble-opacity').oninput = function() {
                document.getElementById('ai-bubble-opacity-value').textContent = Math.round(this.value * 100) + '%';
            };
            
            // åŠ è½½æ°”æ³¡å¤§å°è®¾ç½®
            document.getElementById('bubble-padding').value = chatSettings.bubblePadding || '12';
            updatePaddingValue(chatSettings.bubblePadding || '12');
            
            // ç»‘å®šæ°”æ³¡å¤§å°äº‹ä»¶
            document.getElementById('bubble-padding').oninput = function() {
                updatePaddingValue(this.value);
            };
            
            window.selectedBubbleStyle = currentStyle;
            showModal('bubble-style-modal');
        }
        
        // æ˜¾ç¤ºå®šæ—¶å‘å¸ƒè®¾ç½®
        function showScheduleSettings() {
            const chatSettings = getCurrentChatSettings();
            
            document.getElementById('schedule-enabled').checked = chatSettings.scheduleEnabled || false;
            document.getElementById('schedule-enabled').onchange = function() {
                document.getElementById('schedule-times-group').style.display = this.checked ? 'block' : 'none';
            };
            
            // è§¦å‘ä¸€æ¬¡æ˜¾ç¤ºçŠ¶æ€æ›´æ–°
            document.getElementById('schedule-times-group').style.display = 
                document.getElementById('schedule-enabled').checked ? 'block' : 'none';
            
            // åŠ è½½å·²æœ‰çš„æ—¶é—´ç‚¹
            renderScheduleTimes();
            
            showModal('schedule-settings-modal');
        }
        
        // å¼‚æ­¥å‡½æ•°ï¼Œç”¨äºè·å–èŠå¤©çª—å£çš„ä¸“å±è®¾ç½®
        async function getAsyncChatSettings(characterId = null) {
            // 1. ç¡®å®šä½¿ç”¨å“ªä¸ªè§’è‰²ID
            const chatId = characterId || (currentChatCharacter ? currentChatCharacter.id : null);
            
            if (!chatId) {
                console.warn("æ— æ³•è·å–è®¾ç½®ï¼šcharacterId å’Œ currentChatCharacter éƒ½æœªå®šä¹‰ï¼Œè¿”å›ç©ºè®¾ç½®");
                return {
                    historyCount: 30,
                    timestampEnabled: true,
                    timestampPosition: 'center',
                    bubbleStyle: 'default',
                    characterStatusEnabled: false
                };
            }
            
            // 2. ã€æ€§èƒ½ä¼˜åŒ–ã€‘é¦–å…ˆæ£€æŸ¥å†…å­˜ä¸­æ˜¯å¦å·²æœ‰è¯¥èŠå¤©çš„è®¾ç½®
            if (chatSettings[chatId]) {
                return chatSettings[chatId];
            }
            
            // 3. ã€æ ¸å¿ƒé€»è¾‘ã€‘å¦‚æœå†…å­˜ä¸­æ²¡æœ‰ï¼Œåˆ™ä» IndexedDB æ•°æ®åº“å¼‚æ­¥æŸ¥è¯¢
                try {
                    const dbSettings = await db.chatSettings.get(chatId);
                    if (dbSettings && dbSettings.settings) {
                    // æŸ¥åˆ°äº†ï¼å­˜å…¥å†…å­˜å¹¶è¿”å›
                    console.log(`âœ… ä»æ•°æ®åº“æˆåŠŸåŠ è½½IDä¸º ${chatId} çš„è®¾ç½®`);
                        chatSettings[chatId] = dbSettings.settings;
                    return dbSettings.settings;
                    }
                } catch (error) {
                console.error(`ä»æ•°æ®åº“åŠ è½½IDä¸º ${chatId} çš„è®¾ç½®å¤±è´¥:`, error);
                // å³ä½¿æ•°æ®åº“æŸ¥è¯¢å¤±è´¥ï¼Œä¹Ÿè¦ç»§ç»­æ‰§è¡Œï¼Œå°è¯•åˆ›å»ºé»˜è®¤è®¾ç½®
            }

            // 4. ã€å¤„ç†æ–°èŠå¤©ã€‘å¦‚æœæ•°æ®åº“é‡Œä¹Ÿæ²¡æœ‰ï¼Œè¯´æ˜è¿™æ˜¯ä¸€ä¸ªå…¨æ–°çš„èŠå¤©çª—å£
            console.log(`ğŸ”§ IDä¸º ${chatId} çš„èŠå¤©æ— å†å²è®¾ç½®ï¼Œæ­£åœ¨åˆ›å»ºé»˜è®¤è®¾ç½®...`);
            
            // å®šä¹‰ä¸€ä»½å¹²å‡€çš„é»˜è®¤è®¾ç½®
            const defaultSettings = {
                        // è®°å¿†ç›¸å…³è®¾ç½®ï¼ˆåŸæœ¬çš„å…¨å±€è®¾ç½®æ”¹ä¸ºæ¯ä¸ªèŠå¤©ç‹¬ç«‹ï¼‰
                historyCount: 30,
                        crossChatMemory: 3,
                        enableDynamicMemory: true,
                        enableMusicMemory: true,
                        memoryMountEnabled: false,
                        memoryMountCount: 3,
                        selectedMemoryChats: [],
                        // æ—¶é—´æ„ŸçŸ¥è®¾ç½®
                        timeAwarenessEnabled: true,
                        // é€šè¯è®¾ç½®
                        aiCallEnabled: true,
                        // å¿ƒç‡ç›‘æµ‹è®¾ç½®
                        aiHeartrateEnabled: false,
                        // ç¤¾äº¤åŠ¨æ€è®¾ç½®
                        socialEnabled: false,
                        socialFrequency: 'medium',
                        // åå°äº’åŠ¨è®¾ç½®
                        backgroundInteractionEnabled: true,
                        backgroundChatEnabled: true,
                        backgroundMomentsEnabled: true,
                        backgroundChatFrequency: 'low',
                        backgroundMomentsFrequency: 'low',
                        scheduledMomentsEnabled: false,
                        scheduledMomentsTimes: [],
                        // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘ä¸–ç•Œä¹¦ç›¸å…³è®¾ç½®
                        worldbookMountEnabled: false,
                        selectedWorldbooks: [],
                        linkedWorldBookIds: [], // å…¼å®¹æ—§ç‰ˆæœ¬å­—æ®µå
                        // å…¶ä»–åŸæœ‰è®¾ç½®
                        timestampEnabled: true,
                timestampPosition: 'center',
                characterStatusEnabled: false,
                        // ğŸ”¥ã€æ–°å¢ã€‘çŠ¶æ€æ›´æ–°é¢‘ç‡è®¾ç½®
                        statusUpdateFrequency: 'medium'
            };

            // 5. å°†æ–°åˆ›å»ºçš„é»˜è®¤è®¾ç½®å­˜å…¥å†…å­˜
            chatSettings[chatId] = defaultSettings;

            // 6. ã€é‡è¦ã€‘åŒæ—¶ï¼Œç«‹å³å°†è¿™ä»½é»˜è®¤è®¾ç½®ä¿å­˜å›æ•°æ®åº“ï¼Œä¸ºè¿™ä¸ªæ–°èŠå¤©å»ºç«‹æ¡£æ¡ˆ
            try {
                await db.chatSettings.put({
                    id: chatId,
                    chatId: chatId,
                    settings: defaultSettings
                });
                console.log(`âœ… å·²ä¸ºæ–°èŠå¤© ${chatId} åœ¨æ•°æ®åº“ä¸­åˆ›å»ºäº†é»˜è®¤è®¾ç½®æ¡£æ¡ˆ`);
                } catch (error) {
                console.error(`ä¸ºæ–°èŠå¤© ${chatId} ä¿å­˜é»˜è®¤è®¾ç½®å¤±è´¥:`, error);
            }
            
            // 7. è¿”å›è¿™ä»½å…¨æ–°çš„é»˜è®¤è®¾ç½®
            return defaultSettings;
        }
        
        // å…¼å®¹å±‚ - åŒæ­¥ç‰ˆæœ¬çš„getCurrentChatSettings
        // æ³¨æ„ï¼šè¿™ä¸ªå‡½æ•°åªä¼šè¿”å›å†…å­˜ä¸­çš„è®¾ç½®æˆ–é»˜è®¤è®¾ç½®ï¼Œä¸ä¼šä»æ•°æ®åº“åŠ è½½
        // ç”¨äºä¸æ–¹ä¾¿ä¿®æ”¹ä¸ºasync/awaitçš„åœ°æ–¹
        function getCurrentChatSettings() {
            if (!currentChatCharacter) return {};
            
            const chatId = currentChatCharacter.id;
            
            // å¦‚æœå†…å­˜ä¸­æœ‰è®¾ç½®ï¼Œç›´æ¥è¿”å›
            if (chatSettings[chatId]) {
                return chatSettings[chatId];
            }
            
            // å¦‚æœå†…å­˜ä¸­æ²¡æœ‰ï¼Œåˆ›å»ºä¸€ä¸ªé»˜è®¤è®¾ç½®
            // æ³¨æ„ï¼šè¿™é‡Œä¸ä¼šä¿å­˜åˆ°æ•°æ®åº“ï¼Œåªæ˜¯ä¸´æ—¶ä½¿ç”¨
            // ä¸‹æ¬¡è°ƒç”¨å¼‚æ­¥ç‰ˆæœ¬çš„getCurrentChatSettingsæ—¶ä¼šæ­£ç¡®åŠ è½½/åˆ›å»ºè®¾ç½®
            console.warn(`âš ï¸ ä½¿ç”¨äº†åŒæ­¥ç‰ˆæœ¬è·å–IDä¸º ${chatId} çš„è®¾ç½®ï¼Œä½†å†…å­˜ä¸­æ²¡æœ‰ç¼“å­˜ï¼Œè¿”å›ä¸´æ—¶é»˜è®¤è®¾ç½®`);
            
            const defaultSettings = {
                historyCount: 30,
                crossChatMemory: 3,
                enableDynamicMemory: true,
                enableMusicMemory: true,
                memoryMountEnabled: false,
                memoryMountCount: 3,
                selectedMemoryChats: [],
                timeAwarenessEnabled: true,
                aiCallEnabled: true,
                aiHeartrateEnabled: false,
                characterStatusEnabled: false,
                socialEnabled: false,
                socialFrequency: 'medium',
                backgroundInteractionEnabled: true,
                backgroundChatEnabled: true,
                backgroundMomentsEnabled: true,
                backgroundChatFrequency: 'low',
                backgroundMomentsFrequency: 'low',
                scheduledMomentsEnabled: false,
                scheduledMomentsTimes: [],
                timestampEnabled: true,
                timestampPosition: 'center',
                aiHeartrateEnabled: false,
                // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘æ·»åŠ ä¸–ç•Œä¹¦ç›¸å…³è®¾ç½®
                worldbookMountEnabled: false,
                selectedWorldbooks: [],
                linkedWorldBookIds: [], // å…¼å®¹æ—§ç‰ˆæœ¬å­—æ®µå
                // ğŸ”¥ã€æ–°å¢ã€‘çŠ¶æ€æ›´æ–°é¢‘ç‡è®¾ç½®
                statusUpdateFrequency: 'medium'
            };
            
            // åŒæ—¶è§¦å‘ä¸€ä¸ªå¼‚æ­¥åŠ è½½ï¼Œä»¥ä¾¿åç»­ä½¿ç”¨
            getAsyncChatSettings().then(settings => {
                console.log(`âœ… åå°å¼‚æ­¥åŠ è½½IDä¸º ${chatId} çš„è®¾ç½®å®Œæˆ`);
            }).catch(error => {
                console.error(`åå°å¼‚æ­¥åŠ è½½IDä¸º ${chatId} çš„è®¾ç½®å¤±è´¥:`, error);
            });
            
            return defaultSettings;
        }
        
        // ğŸ”¥ã€é‡æ„ã€‘ä¿å­˜å½“å‰èŠå¤©çš„è®¾ç½® - å®Œå…¨ä¾èµ–IndexedDB + è‡ªåŠ¨ä¿å­˜
        async function saveCurrentChatSettings(settings) {
            if (!currentChatCharacter) return;

            const chatId = currentChatCharacter.id;

            // ğŸ”¥ã€ä¿®å¤ã€‘åŒæ­¥æ›´æ–°å…¨å±€chatSettings
            chatSettings[chatId] = settings;

            try {
                // ç«‹å³ä¿å­˜åˆ°IndexedDB
                await db.chatSettings.put({
                    id: chatId,
                    chatId: chatId,
                    settings: settings
                });

                console.log(`âœ… èŠå¤©è®¾ç½®å·²ä¿å­˜åˆ°IndexedDB (è§’è‰²: ${chatId})`);

                // ğŸ”¥ã€æ–°å¢ã€‘è§¦å‘è‡ªåŠ¨ä¿å­˜æœºåˆ¶ï¼Œé˜²æ­¢æ•°æ®ä¸¢å¤±
                scheduleAutoSave(chatId);

            } catch (error) {
                console.error('ğŸš¨ ä¿å­˜èŠå¤©è®¾ç½®åˆ°IndexedDBå¤±è´¥:', error);

                // ğŸ”¥ã€ç´§æ€¥å¤‡ä»½ã€‘åªåœ¨IndexedDBå®Œå…¨å¤±è´¥æ—¶æ‰ä½¿ç”¨localStorage
                try {
                    console.warn('âš ï¸ æ­£åœ¨è¿›è¡Œç´§æ€¥å¤‡ä»½...');
                    const emergencySettings = {
                        selectedIdentityId: settings.selectedIdentityId,
                        aiChatNickname: settings.aiChatNickname,
                        myChatNickname: settings.myChatNickname,
                        hideAvatars: settings.hideAvatars,
                        bubbleStyle: settings.bubbleStyle,
                        timestampEnabled: settings.timestampEnabled,
                        timestampPosition: settings.timestampPosition
                    };

                    localStorage.setItem(`chatSettings_emergency_${chatId}`, JSON.stringify(emergencySettings));
                    console.log('âœ… ç´§æ€¥å¤‡ä»½å·²ä¿å­˜');
                    showToast('âš ï¸ æ•°æ®åº“ä¿å­˜å¤±è´¥ï¼Œå·²å¯ç”¨ç´§æ€¥å¤‡ä»½', 'warning');

                } catch (localError) {
                    console.error('ğŸš¨ ç´§æ€¥å¤‡ä»½ä¹Ÿå¤±è´¥äº†:', localError);
                    showToast('âŒ è®¾ç½®ä¿å­˜å¤±è´¥ï¼è¯·æ£€æŸ¥å­˜å‚¨ç©ºé—´', 'error');
                }
            }
        }
        

        
        // æ˜¾ç¤ºè®°å¿†æŒ‚è½½è®¾ç½®
        async function showMemoryMountSettings() {
            const chatSettings = await getAsyncChatSettings();
            // åŠ è½½å½“å‰è®¾ç½®
            document.getElementById('memory-mount-enabled').checked = chatSettings.memoryMountEnabled || false;
            document.getElementById('memory-mount-count').value = chatSettings.memoryMountCount || 3;
            document.getElementById('memory-mount-display').textContent = (chatSettings.memoryMountCount || 3) + 'æ¡';
            
            // æ§åˆ¶è¯¦ç»†è®¾ç½®çš„æ˜¾ç¤º
            toggleMemoryMountDetails();
            
            // ç»‘å®šäº‹ä»¶
            document.getElementById('memory-mount-enabled').onchange = toggleMemoryMountDetails;
            document.getElementById('memory-mount-count').oninput = function() {
                document.getElementById('memory-mount-display').textContent = this.value + 'æ¡';
            };
            
            // æ¸²æŸ“èŠå¤©åˆ—è¡¨
            renderMemoryMountChatList();
            
            showModal('memory-mount-modal');
        }
        
        // åˆ‡æ¢è®°å¿†æŒ‚è½½è¯¦ç»†è®¾ç½®æ˜¾ç¤º
        function toggleMemoryMountDetails() {
            const enabled = document.getElementById('memory-mount-enabled').checked;
            document.getElementById('memory-mount-details').style.display = enabled ? 'block' : 'none';
            document.getElementById('memory-mount-chats').style.display = enabled ? 'block' : 'none';
            
            // æ›´æ–°ä¸»è®¾ç½®ç•Œé¢æ˜¾ç¤º
            document.getElementById('current-memory-mount').textContent = enabled ? 'å·²å¼€å¯' : 'å·²å…³é—­';
        }
        
        // æ¸²æŸ“è®°å¿†æŒ‚è½½èŠå¤©åˆ—è¡¨
        async function renderMemoryMountChatList() {
            const container = document.getElementById('memory-mount-list');
            container.innerHTML = '';
            
            if (characters.length === 0 && groupChats.length === 0) {
                container.innerHTML = '<p class="empty-mount-chats">æš‚æ— å¯æŒ‚è½½çš„èŠå¤©</p>';
                return;
            }
            
            // æ·»åŠ å•äººèŠå¤©
            characters.forEach(character => {
                if (currentChatCharacter && character.id === currentChatCharacter.id) return; // ä¸æ˜¾ç¤ºå½“å‰èŠå¤©
                
                const item = document.createElement('div');
                item.className = 'mount-item';
                item.innerHTML = `
                    <input type="checkbox" id="mount-${character.id}" value="${character.id}" class="mount-checkbox">
                    <div class="mount-avatar-small" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''} display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                        ${character.avatarUrl ? '' : character.name.charAt(0)}
                    </div>
                    <div>
                        <div class="mount-name">${character.name}</div>
                        <div class="mount-type">å•èŠ</div>
                    </div>
                `;
                container.appendChild(item);
            });
            
            // æ·»åŠ ç¾¤èŠ
            groupChats.forEach(group => {
                if (currentChatCharacter && group.id === currentChatCharacter.id) return; // ä¸æ˜¾ç¤ºå½“å‰èŠå¤©
                
                const item = document.createElement('div');
                item.className = 'mount-item';
                item.innerHTML = `
                    <input type="checkbox" id="mount-${group.id}" value="${group.id}" class="mount-checkbox">
                    <div class="mount-avatar-group">
                        ç¾¤
                    </div>
                    <div>
                        <div class="mount-name">${group.name}</div>
                                                    <div class="mount-type">ç¾¤èŠ (${group.members ? group.members.length + 1 : 1}äºº)</div>
                    </div>
                `;
                container.appendChild(item);
            });
            
            // åŠ è½½å·²é€‰æ‹©çš„èŠå¤©
            const chatSettings = await getAsyncChatSettings();
            const selectedChats = chatSettings.selectedMemoryChats || [];
            selectedChats.forEach(chatId => {
                const checkbox = document.getElementById(`mount-${chatId}`);
                if (checkbox) checkbox.checked = true;
            });
        }
        
        // ä¿å­˜è®°å¿†æŒ‚è½½è®¾ç½®
        async function saveMemoryMountSettings() {
            const chatSettings = await getAsyncChatSettings();
            chatSettings.memoryMountEnabled = document.getElementById('memory-mount-enabled').checked;
            chatSettings.memoryMountCount = parseInt(document.getElementById('memory-mount-count').value);
            
            // è·å–é€‰ä¸­çš„èŠå¤©
            const checkboxes = document.querySelectorAll('#memory-mount-list input[type="checkbox"]:checked');
            chatSettings.selectedMemoryChats = Array.from(checkboxes).map(cb => cb.value);
            
            // æ›´æ–°ä¸»è®¾ç½®ç•Œé¢æ˜¾ç¤º
            document.getElementById('current-memory-mount').textContent = chatSettings.memoryMountEnabled ? 'å·²å¼€å¯' : 'å·²å…³é—­';
            
            await saveCurrentChatSettings(chatSettings);
            hideModal('memory-mount-modal');
            showToast('è®°å¿†æŒ‚è½½è®¾ç½®å·²ä¿å­˜', 'success');
        }
        
        // ä¿å­˜èŠå¤©å¤´åƒè®¾ç½®
        async function saveChatAvatarSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // ä¿å­˜éšè—å¤´åƒè®¾ç½®
            const hideAvatarsCheckbox = document.getElementById('hide-avatars');
            if (hideAvatarsCheckbox) {
                chatSettings.hideAvatars = hideAvatarsCheckbox.checked;
            }
            
            // ğŸ”¥ã€å‹ç¼©å¤´åƒã€‘åœ¨ä¿å­˜å‰å‹ç¼©å¤´åƒæ•°æ®
            if (window.selectedMyChatAvatar) {
                chatSettings.myChatAvatar = await compressImage(window.selectedMyChatAvatar, 200, 0.7);
            }
            if (window.selectedAiChatAvatar) {
                chatSettings.aiChatAvatar = await compressImage(window.selectedAiChatAvatar, 200, 0.7);
            }
            
            try {
                await saveCurrentChatSettings(chatSettings);
                hideModal('avatar-settings-modal');
                
                // åˆ·æ–°èŠå¤©ç•Œé¢ä»¥æ˜¾ç¤ºæ–°å¤´åƒ
                if (currentChatCharacter) {
                    renderChatMessages(currentChatCharacter.id);
                }
                
                showToast('å¤´åƒè®¾ç½®å·²ä¿å­˜', 'success');
            } catch (error) {
                console.error('ä¿å­˜å¤´åƒè®¾ç½®å¤±è´¥:', error);
                showToast('ä¿å­˜å¤±è´¥ï¼Œå­˜å‚¨ç©ºé—´å¯èƒ½ä¸è¶³', 'error');
            }
        }
        
        // ä¿å­˜æ˜µç§°è®¾ç½®
        async function saveChatNicknameSettings() {
            const chatSettings = getCurrentChatSettings();
            
            chatSettings.myChatNickname = document.getElementById('my-chat-nickname').value.trim();
            chatSettings.aiChatNickname = document.getElementById('ai-chat-nickname').value.trim();
            
            await saveCurrentChatSettings(chatSettings);
            hideModal('nickname-settings-modal');
            
            // æ›´æ–°èŠå¤©ç•Œé¢æ ‡é¢˜
            if (currentChatCharacter) {
                let displayTitle = chatSettings.aiChatNickname || currentChatCharacter.name;

                // ğŸ”¥ã€ä¿®å¤ã€‘ç¾¤èŠæ ‡é¢˜æ˜¾ç¤ºæˆå‘˜æ•°é‡
                if (currentChatCharacter.isGroup && currentChatCharacter.members) {
                    const memberCount = currentChatCharacter.members.length + 1; // +1 åŒ…æ‹¬ç”¨æˆ·è‡ªå·±
                    displayTitle = `${displayTitle}ï¼ˆ${memberCount}ï¼‰`;
                }

                document.getElementById('api-chat-title').textContent = displayTitle;
            }
            
            // åˆ·æ–°èŠå¤©ç•Œé¢
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }
            
            // ğŸ”¥ã€ä¿®å¤ã€‘åˆ·æ–°æ¶ˆæ¯åˆ—è¡¨å’Œè”ç³»äººåˆ—è¡¨ä»¥æ˜¾ç¤ºæ–°æ˜µç§°
            renderMessageList();
            renderContactList();
            
            showToast('æ˜µç§°è®¾ç½®å·²ä¿å­˜', 'success');
        }
        
        // ä¿å­˜æˆ³ä¸€æˆ³åç¼€è®¾ç½®
        async function savePokeSuffixSettings() {
            const chatSettings = getCurrentChatSettings();
            
            chatSettings.myPokeSuffix = document.getElementById('my-poke-suffix').value.trim();
            chatSettings.aiPokeSuffix = document.getElementById('ai-poke-suffix').value.trim();
            
            await saveCurrentChatSettings(chatSettings);
            hideModal('poke-suffix-modal');
            showToast('æˆ³ä¸€æˆ³åç¼€è®¾ç½®å·²ä¿å­˜', 'success');
        }
        
        // ä¿å­˜èŠå¤©èƒŒæ™¯è®¾ç½®
        async function saveChatBackgroundSettings() {
    // 1. ç¡®ä¿æœ‰å½“å‰èŠå¤©è§’è‰²
    if (!currentChatCharacter) return;
            
    // 2. æ ¹æ®ç”¨æˆ·çš„æ“ä½œæ›´æ–°èƒŒæ™¯è®¾ç½®
    // window.selectedChatBackground åœ¨ä½ é€‰æ‹©æˆ–ç§»é™¤èƒŒæ™¯æ—¶è¢«èµ‹å€¼
    let backgroundToApply;
    
            if (window.selectedChatBackground === null) {
        // ç”¨æˆ·ç‚¹å‡»äº†"ç§»é™¤èƒŒæ™¯"
        backgroundToApply = null;
            } else if (window.selectedChatBackground) {
        // ç”¨æˆ·é€‰æ‹©äº†æ–°èƒŒæ™¯
        backgroundToApply = await compressImage(window.selectedChatBackground, 800, 0.8);
    } else {
        // ç”¨æˆ·æ²¡åšä»»ä½•æ›´æ”¹ï¼Œä¿æŒåŸæœ‰è®¾ç½®ä¸å˜
        backgroundToApply = currentChatCharacter.background;
    }

    // 3. [å…³é”®] ç«‹å³åº”ç”¨èƒŒæ™¯è®¾ç½®ï¼Œè¿™ä¼šè‡ªåŠ¨æ›´æ–°currentChatCharacter.backgroundå¹¶ä¿å­˜
    await applyChatBackground(backgroundToApply);
    
    // 4. æ¸…ç†å¹¶å…³é—­æ¨¡æ€æ¡†
    hideModal('background-settings-modal');
    window.selectedChatBackground = undefined; // æ¸…ç†ä¸´æ—¶å˜é‡
            showToast('èŠå¤©èƒŒæ™¯è®¾ç½®å·²ä¿å­˜', 'success');
        }
        
        // ç§»é™¤èƒŒæ™¯
        function removeBackground() {
            const backgroundPreview = document.getElementById('chat-background-preview');
            backgroundPreview.style.backgroundImage = 'none';
            backgroundPreview.querySelector('.preview-text').style.display = 'block';
            backgroundPreview.querySelector('.preview-text').textContent = 'å·²ç§»é™¤èƒŒæ™¯';
            window.selectedChatBackground = null;
        }

        // æ›´æ–°æ°”æ³¡å¤§å°æ˜¾ç¤ºå€¼
        function updatePaddingValue(value) {
            const paddingValue = document.getElementById('bubble-padding-value');
            if (paddingValue) {
                if (value <= 6) {
                    paddingValue.textContent = 'è¶…ç´§å‡‘';
                } else if (value <= 10) {
                    paddingValue.textContent = 'ç´§å‡‘';
                } else if (value <= 14) {
                    paddingValue.textContent = 'ä¸­ç­‰';
                } else {
                    paddingValue.textContent = 'å®½æ¾';
                }
            }
        }

        // ä¿å­˜æ°”æ³¡æ ·å¼è®¾ç½®
        async function saveBubbleStyleSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // ä¿å­˜æ ·å¼é€‰æ‹©
            if (window.selectedBubbleStyle) {
                chatSettings.bubbleStyle = window.selectedBubbleStyle;
            }
            
            // ä¿å­˜é¢œè‰²è®¾ç½®
            chatSettings.myBubbleColor = document.getElementById('my-bubble-color').value;
            chatSettings.aiBubbleColor = document.getElementById('ai-bubble-color').value;
            
            // ä¿å­˜åˆ†ç¦»çš„é€æ˜åº¦è®¾ç½®
            chatSettings.myBubbleOpacity = document.getElementById('my-bubble-opacity').value;
            chatSettings.aiBubbleOpacity = document.getElementById('ai-bubble-opacity').value;
            
            // ä¿å­˜æ°”æ³¡å¤§å°è®¾ç½®
            chatSettings.bubblePadding = document.getElementById('bubble-padding').value;
            
            await saveCurrentChatSettings(chatSettings);

            // ğŸ”¥ã€ä¿®å¤ã€‘ç«‹å³åº”ç”¨æ°”æ³¡æ ·å¼
            applyBubbleStyle();

            // ğŸ”¥ã€ä¿®å¤ã€‘ç«‹å³æ›´æ–°æ°”æ³¡æ ·å¼æ˜¾ç¤º
            updateBubbleStyleDisplay();

            hideModal('bubble-style-modal');

            // åˆ·æ–°èŠå¤©ç•Œé¢ä»¥åº”ç”¨æ–°è®¾ç½®
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }

            showToast('æ°”æ³¡æ ·å¼è®¾ç½®å·²ä¿å­˜', 'success');
        }

        // æ˜¾ç¤ºæ—¶é—´æˆ³è®¾ç½®
        function showTimestampSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // è®¾ç½®æ—¶é—´æˆ³å¼€å…³çŠ¶æ€
            const timestampEnabled = document.getElementById('timestamp-modal-enabled');
            if (timestampEnabled) {
                timestampEnabled.checked = chatSettings.timestampEnabled !== false; // é»˜è®¤ä¸ºtrue
            }
            
            // è®¾ç½®æ—¶é—´æˆ³ä½ç½®é€‰é¡¹
            const timestampPosition = chatSettings.timestampPosition || 'center';
            const positionRadios = document.querySelectorAll('input[name="timestamp-position"]');
            positionRadios.forEach(radio => {
                radio.checked = radio.value === timestampPosition;
            });
            
            // ç»‘å®šæ—¶é—´æˆ³å¼€å…³å˜åŒ–äº‹ä»¶
            if (timestampEnabled) {
                timestampEnabled.onchange = function() {
                    const optionsGroup = document.getElementById('timestamp-options-group');
                    if (optionsGroup) {
                        optionsGroup.style.display = this.checked ? 'block' : 'none';
                    }
                };
                
                // è§¦å‘ä¸€æ¬¡æ˜¾ç¤ºçŠ¶æ€æ›´æ–°
                const optionsGroup = document.getElementById('timestamp-options-group');
                if (optionsGroup) {
                    optionsGroup.style.display = timestampEnabled.checked ? 'block' : 'none';
                }
            }
            
            showModal('timestamp-settings-modal');
        }

        // ä¿å­˜æ—¶é—´æˆ³è®¾ç½®
        async function saveTimestampSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // è·å–æ—¶é—´æˆ³å¼€å…³çŠ¶æ€
            const timestampEnabled = document.getElementById('timestamp-modal-enabled');
            if (timestampEnabled) {
                chatSettings.timestampEnabled = timestampEnabled.checked;
            }
            
            // è·å–é€‰ä¸­çš„æ—¶é—´æˆ³ä½ç½®
            const selectedPosition = document.querySelector('input[name="timestamp-position"]:checked');
            if (selectedPosition) {
                chatSettings.timestampPosition = selectedPosition.value;
            }
            
            await saveCurrentChatSettings(chatSettings);
            hideModal('timestamp-settings-modal');
            
            // é‡æ–°æ¸²æŸ“èŠå¤©æ¶ˆæ¯ä»¥åº”ç”¨æ–°çš„æ—¶é—´æˆ³è®¾ç½®
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }
            
            showToast('æ—¶é—´æˆ³è®¾ç½®å·²ä¿å­˜', 'success');
        }

        // ğŸ”¥ã€æ–°å¢ã€‘ç¾¤æˆå‘˜æ°”æ³¡é¢œè‰²è®¾ç½®åŠŸèƒ½
        function showGroupMemberColorSettings() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) {
                showToast('åªæœ‰ç¾¤èŠå¯ä»¥è®¾ç½®æˆå‘˜æ°”æ³¡é¢œè‰²', 'warning');
                return;
            }
            
            // ğŸ”¥ã€æ–°å¢ã€‘å…ˆå…³é—­æ°”æ³¡æ ·å¼è®¾ç½®çª—å£ï¼Œé¿å…å±‚çº§é®æŒ¡
            hideModal('bubble-style-modal');
            
            const container = document.getElementById('group-member-colors-list');
            container.innerHTML = '';
            
            const chatSettings = getCurrentChatSettings();
            const memberColors = chatSettings.memberBubbleColors || {};
            
            // è·å–ç¾¤æˆå‘˜åˆ—è¡¨
            const group = groupChats.find(g => g.id === currentChatCharacter.id);
            console.log('å½“å‰ç¾¤èŠ:', currentChatCharacter);
            console.log('æ‰¾åˆ°çš„ç¾¤èŠ:', group);
            console.log('ç¾¤èŠæˆå‘˜:', group?.members);
            
            if (!group || !group.members || group.members.length === 0) {
                container.innerHTML = '<p class="text-center-gray">è¯¥ç¾¤èŠæš‚æ— æˆå‘˜ã€‚è¯·å…ˆåœ¨ç¾¤èŠä¿¡æ¯ä¸­æ·»åŠ æˆå‘˜ã€‚</p>';
                showModal('group-member-colors-modal');
                return;
            }
            
            // ä¸ºæ¯ä¸ªç¾¤æˆå‘˜åˆ›å»ºé¢œè‰²è®¾ç½®é¡¹
            group.members.forEach(member => {
                // å…¼å®¹ä¸åŒçš„æˆå‘˜æ•°æ®ç»“æ„
                const memberId = typeof member === 'string' ? member : member.id;
                const character = characters.find(c => c.id === memberId);
                if (!character) {
                    console.log('æ‰¾ä¸åˆ°è§’è‰²:', memberId, 'æ‰€æœ‰è§’è‰²:', characters.map(c => ({id: c.id, name: c.name})));
                    return;
                }
                
                const memberColor = memberColors[memberId] || '#f0f0f0';
                
                const memberItem = document.createElement('div');
                memberItem.className = 'setting-item';
                memberItem.innerHTML = `
                    <div class="setting-left">
                        <div class="setting-label" style="display: flex; align-items: center; gap: 8px;">
                            <div class="character-avatar" style="width: 24px; height: 24px; background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''} display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 12px; border-radius: 50%;">
                                ${character.avatarUrl ? '' : character.name.charAt(0)}
                            </div>
                            ${character.name}
                        </div>
                        <div class="setting-desc">è®¾ç½® ${character.name} çš„ä¸“å±æ°”æ³¡é¢œè‰²</div>
                    </div>
                    <div class="setting-right">
                        <input type="color" id="member-color-${memberId}" class="color-input" value="${memberColor}" style="width: 40px; height: 30px;">
                    </div>
                `;
                
                container.appendChild(memberItem);
            });
            
            showModal('group-member-colors-modal');
        }
        
        function saveGroupMemberColors() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            
            const chatSettings = getCurrentChatSettings();
            if (!chatSettings.memberBubbleColors) {
                chatSettings.memberBubbleColors = {};
            }
            
            // è·å–ç¾¤æˆå‘˜åˆ—è¡¨
            const group = groupChats.find(g => g.id === currentChatCharacter.id);
            if (!group || !group.members) return;
            
            // ä¿å­˜æ¯ä¸ªæˆå‘˜çš„é¢œè‰²è®¾ç½®
            group.members.forEach(member => {
                // å…¼å®¹ä¸åŒçš„æˆå‘˜æ•°æ®ç»“æ„
                const memberId = typeof member === 'string' ? member : member.id;
                const colorInput = document.getElementById(`member-color-${memberId}`);
                if (colorInput) {
                    chatSettings.memberBubbleColors[memberId] = colorInput.value;
                }
            });
            
            saveCurrentChatSettings(chatSettings);
            hideModal('group-member-colors-modal');
            
            // åˆ·æ–°èŠå¤©ç•Œé¢ä»¥åº”ç”¨æ–°é¢œè‰²
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }
            
            showToast('ç¾¤æˆå‘˜æ°”æ³¡é¢œè‰²å·²ä¿å­˜', 'success');
        }
        
        // å¤´åƒä¸Šä¼ å¤„ç†å‡½æ•°
        function avatarUploadHandler(e) {
            console.log('avatar-upload changeäº‹ä»¶è¢«è§¦å‘');
            if (e.target.files && e.target.files[0]) {
                const file = e.target.files[0];
                
                console.log('é€‰æ‹©äº†æ–‡ä»¶:', file.name, 'å¤§å°:', file.size, 'bytes', 'ç±»å‹:', file.type);
                
                // æ£€æŸ¥æ–‡ä»¶ç±»å‹
                if (!file.type.startsWith('image/')) {
                    alert('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶');
                    e.target.value = ''; // æ¸…ç©ºé€‰æ‹©
                    return;
                }
                
                // æ£€æŸ¥æ–‡ä»¶å¤§å° (é™åˆ¶ä¸º5MB)
                if (file.size > 5 * 1024 * 1024) {
                    alert('å›¾ç‰‡æ–‡ä»¶è¿‡å¤§ï¼Œè¯·é€‰æ‹©å°äº5MBçš„å›¾ç‰‡');
                    e.target.value = ''; // æ¸…ç©ºé€‰æ‹©
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const avatarPreview = document.getElementById('avatar-preview');
                        const avatarPreviewText = document.getElementById('avatar-preview-text');
                        
                        console.log('æ–‡ä»¶è¯»å–æˆåŠŸï¼Œå¼€å§‹è®¾ç½®é¢„è§ˆ');
                        
                        if (!avatarPreview) {
                            console.error('æ‰¾ä¸åˆ°avatar-previewå…ƒç´ ');
                            alert('æ‰¾ä¸åˆ°å¤´åƒé¢„è§ˆå…ƒç´ ');
                            return;
                        }
                        
                        // æ·»åŠ has-imageç±»æ¥è¦†ç›–é»˜è®¤èƒŒæ™¯
                        avatarPreview.classList.add('has-image');
                        
                        // å¼ºåˆ¶è®¾ç½®èƒŒæ™¯å›¾ç‰‡å¹¶æ¸…é™¤æ‰€æœ‰å…¶ä»–èƒŒæ™¯æ ·å¼
                        avatarPreview.style.setProperty('background', `url(${event.target.result})`, 'important');
                        avatarPreview.style.setProperty('background-size', 'cover', 'important');
                        avatarPreview.style.setProperty('background-position', 'center', 'important');
                        avatarPreview.style.setProperty('background-repeat', 'no-repeat', 'important');
                        
                        // éšè—æ–‡å­—
                        if (avatarPreviewText) {
                            avatarPreviewText.style.display = 'none';
                        }
                        
                        // å­˜å‚¨å›¾ç‰‡æ•°æ®ç”¨äºåç»­ä¿å­˜
                        window.selectedAvatarData = event.target.result;
                        
                        // éªŒè¯æ ·å¼æ˜¯å¦æ­£ç¡®è®¾ç½®
                        console.log('å¤´åƒé¢„è§ˆUIæ›´æ–°å®Œæˆï¼ŒèƒŒæ™¯å›¾ç‰‡å·²è®¾ç½®');
                        console.log('å½“å‰avatar-previewçš„æ ·å¼:', {
                            background: avatarPreview.style.background,
                            backgroundSize: avatarPreview.style.backgroundSize,
                            backgroundPosition: avatarPreview.style.backgroundPosition,
                            className: avatarPreview.className
                        });
                        
                        console.log('å¤´åƒé¢„è§ˆè®¾ç½®æˆåŠŸï¼Œå›¾ç‰‡æ•°æ®å·²å­˜å‚¨');
                    } catch (error) {
                        console.error('è®¾ç½®å¤´åƒé¢„è§ˆæ—¶å‘ç”Ÿé”™è¯¯:', error);
                        alert('è®¾ç½®å¤´åƒé¢„è§ˆå¤±è´¥ï¼Œè¯·é‡è¯•: ' + error.message);
                    }
                };
                
                reader.onerror = function() {
                    console.error('æ–‡ä»¶è¯»å–å¤±è´¥');
                    alert('å›¾ç‰‡è¯»å–å¤±è´¥ï¼Œè¯·é‡è¯•');
                    e.target.value = ''; // æ¸…ç©ºé€‰æ‹©
                };
                
                reader.readAsDataURL(file);
            } else {
                console.log('æ²¡æœ‰é€‰æ‹©æ–‡ä»¶æˆ–filesä¸ºç©º');
            }
        }
        
        // åŠ è½½è‡ªå®šä¹‰è¡¨æƒ…åŒ… - ä½¿ç”¨IndexedDBï¼ˆåŒ…å«æ•°æ®è¿ç§»ï¼‰
        async function loadCustomEmojis() {
            try {
                const savedCustomEmojis = await db.customEmojis.toArray();
                
                if (savedCustomEmojis.length === 0) {
                    // IndexedDBä¸­æ²¡æœ‰æ•°æ®ï¼Œå°è¯•ä»localStorageè¿ç§»
                    const localStorageData = localStorage.getItem('customEmojis');
                    if (localStorageData) {
                        console.log('æ£€æµ‹åˆ°localStorageä¸­çš„è‡ªå®šä¹‰è¡¨æƒ…åŒ…æ•°æ®ï¼Œå¼€å§‹è¿ç§»...');
                        const localEmojis = JSON.parse(localStorageData);
                        
                        if (localEmojis.length > 0) {
                            await db.customEmojis.bulkAdd(localEmojis);
                        }
                        
                        customEmojis = localEmojis;
                        console.log('è‡ªå®šä¹‰è¡¨æƒ…åŒ…è¿ç§»å®Œæˆ:', customEmojis);
                    } else {
                        customEmojis = [];
                    }
                } else {
                    customEmojis = savedCustomEmojis;
                    console.log('ä»IndexedDBåŠ è½½è‡ªå®šä¹‰è¡¨æƒ…åŒ…:', customEmojis);
                }
                
                // ğŸ”§ã€ä¿®å¤ã€‘recentEmojisä¹Ÿä»IndexedDBåŠ è½½ï¼Œå½»åº•è§£å†³localStorageé—®é¢˜
                const savedRecentEmojis = await db.recentEmojis.orderBy('lastUsed').reverse().toArray();
                if (savedRecentEmojis.length === 0) {
                    // IndexedDBä¸­æ²¡æœ‰æ•°æ®ï¼Œå°è¯•ä»localStorageè¿ç§»
                    const localRecentEmojis = localStorage.getItem('recentEmojis');
                    if (localRecentEmojis) {
                        console.log('æ£€æµ‹åˆ°localStorageä¸­çš„recentEmojisæ•°æ®ï¼Œå¼€å§‹è¿ç§»...');
                        const localRecents = JSON.parse(localRecentEmojis);
                        
                        if (localRecents.length > 0) {
                            // é™åˆ¶ä¸º10ä¸ª
                            const limitedRecents = localRecents.slice(0, 10);
                            const recentEmojisWithId = limitedRecents.map((emoji, index) => ({
                                id: index + 1,
                                url: emoji.url,
                                description: emoji.description || 'è¡¨æƒ…åŒ…',
                                lastUsed: Date.now() - index * 1000
                            }));
                            await db.recentEmojis.bulkAdd(recentEmojisWithId);
                            recentEmojis = limitedRecents;
                            
                            // æ¸…ç†localStorage
                            localStorage.removeItem('recentEmojis');
                            console.log('recentEmojisè¿ç§»å®Œæˆå¹¶æ¸…ç†localStorage');
                        } else {
                            recentEmojis = [];
                        }
                    } else {
                        recentEmojis = [];
                    }
                } else {
                    // ä»IndexedDBè½¬æ¢å›åŸæ ¼å¼
                    recentEmojis = savedRecentEmojis.map(item => ({
                        url: item.url,
                        description: item.description
                    }));
                    console.log('ä»IndexedDBåŠ è½½recentEmojis:', recentEmojis);
                }
            } catch (error) {
                console.error('åŠ è½½è‡ªå®šä¹‰è¡¨æƒ…åŒ…å¤±è´¥:', error);
                // å¦‚æœIndexedDBå¤±è´¥ï¼Œå°è¯•ä»localStorageåŠ è½½
                const localStorageData = localStorage.getItem('customEmojis');
                if (localStorageData) {
                    customEmojis = JSON.parse(localStorageData);
                    console.log('ä»localStorageå¤‡ä»½åŠ è½½è‡ªå®šä¹‰è¡¨æƒ…åŒ…:', customEmojis);
                } else {
                    customEmojis = [];
                }
                
                // å°è¯•ä»IndexedDBåŠ è½½recentEmojis
                try {
                    const savedRecentEmojis = await db.recentEmojis.orderBy('lastUsed').reverse().toArray();
                    if (savedRecentEmojis.length > 0) {
                        recentEmojis = savedRecentEmojis.map(item => ({
                            url: item.url,
                            description: item.description
                        }));
                    } else {
                        recentEmojis = [];
                    }
                } catch (dbError) {
                    // å¦‚æœIndexedDBå¤±è´¥ï¼Œå°è¯•ä»localStorageåŠ è½½
                    const localRecentEmojis = localStorage.getItem('recentEmojis');
                    if (localRecentEmojis) {
                        recentEmojis = JSON.parse(localRecentEmojis);
                    } else {
                        recentEmojis = [];
                    }
                }
            }
        }
        
        // ä¿å­˜è‡ªå®šä¹‰è¡¨æƒ…åŒ… - ä½¿ç”¨IndexedDB
        async function saveCustomEmojis() {
            try {
                // ğŸ”¥ã€å®‰å…¨ä¿®å¤ã€‘ä½¿ç”¨äº‹åŠ¡ç¡®ä¿åŸå­æ“ä½œ
                await db.transaction('rw', db.customEmojis, async () => {
                    await db.customEmojis.clear();
                    if (customEmojis.length > 0) {
                        await db.customEmojis.bulkAdd(customEmojis);
                    }
                });
                
                // ğŸ”§ã€ä¿®å¤ã€‘å°†recentEmojisä¹Ÿè¿ç§»åˆ°IndexedDBï¼Œå½»åº•è§£å†³localStorageé—®é¢˜
                try {
                    // é™åˆ¶æœ€è¿‘ä½¿ç”¨è¡¨æƒ…åŒ…æ•°é‡ä¸º10ä¸ª
                    const maxRecentEmojis = 10;
                    if (recentEmojis.length > maxRecentEmojis) {
                        recentEmojis = recentEmojis.slice(0, maxRecentEmojis);
                    }
                    
                    // ğŸ”¥ã€å®‰å…¨ä¿®å¤ã€‘å°†recentEmojisä¹Ÿä¿å­˜åˆ°IndexedDBï¼Œä½¿ç”¨äº‹åŠ¡
                    await db.transaction('rw', db.recentEmojis, async () => {
                        await db.recentEmojis.clear();
                        if (recentEmojis.length > 0) {
                            const recentEmojisWithId = recentEmojis.map((emoji, index) => ({
                                id: index + 1,
                                url: emoji.url,
                                description: emoji.description || 'è¡¨æƒ…åŒ…',
                                lastUsed: Date.now() - index * 1000 // ç¡®ä¿é¡ºåº
                            }));
                            await db.recentEmojis.bulkAdd(recentEmojisWithId);
                        }
                    });
                    
                    // æ¸…ç†localStorageä¸­çš„æ—§æ•°æ®ï¼ˆä¸€æ¬¡æ€§è¿ç§»ï¼‰
                    if (localStorage.getItem('recentEmojis')) {
                        localStorage.removeItem('recentEmojis');
                        console.log('å·²å°†recentEmojisè¿ç§»åˆ°IndexedDBå¹¶æ¸…ç†localStorage');
                    }
                } catch (dbError) {
                    console.error('IndexedDBå­˜å‚¨å¤±è´¥:', dbError);
                    showToast('âŒ è¡¨æƒ…åŒ…æ•°æ®å­˜å‚¨å¤±è´¥', 'error');
                }
            } catch (error) {
                console.error('ä¿å­˜è‡ªå®šä¹‰è¡¨æƒ…åŒ…å¤±è´¥:', error);
                showToast('âŒ è¡¨æƒ…åŒ…ä¿å­˜å¤±è´¥', 'error');
            }
        }
        
        // æ˜¾ç¤ºè‡ªå®šä¹‰è¡¨æƒ…åŒ…é¢æ¿
        function showCustomEmojiPanel() {
            const panel = document.getElementById('custom-emoji-panel');
            const isVisible = panel.style.display === 'block';
            
            if (isVisible) {
                panel.style.display = 'none';
                document.removeEventListener('click', hideCustomEmojiPanel);
            } else {
                panel.style.display = 'block';
                renderEmojiGrid();
                
                // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­é¢æ¿
                setTimeout(() => {
                    document.addEventListener('click', hideCustomEmojiPanel);
                }, 100);
            }
        }
        
        // éšè—è‡ªå®šä¹‰è¡¨æƒ…åŒ…é¢æ¿
        function hideCustomEmojiPanel(e) {
            const panel = document.getElementById('custom-emoji-panel');
            
            // å¦‚æœæ²¡æœ‰ä¼ é€’äº‹ä»¶å‚æ•°ï¼Œç›´æ¥éšè—é¢æ¿
            if (!e) {
                if (panel) {
                    panel.style.display = 'none';
                    document.removeEventListener('click', hideCustomEmojiPanel);
                }
                return;
            }
            
            const emojiBtn = e.target.closest('.chat-action-btn');
            
            if (panel && !panel.contains(e.target) && !emojiBtn) {
                panel.style.display = 'none';
                document.removeEventListener('click', hideCustomEmojiPanel);
            }
        }
        
        // æ¸²æŸ“è¡¨æƒ…åŒ…ç½‘æ ¼
        function renderEmojiGrid() {
            const grid = document.getElementById('emoji-grid');
            grid.innerHTML = '';
            
            let emojisToShow = [];
            
            if (currentEmojiTab === 'recent') {
                emojisToShow = recentEmojis;
            } else if (currentEmojiTab === 'custom') {
                emojisToShow = customEmojis;
            }
            
            // æ·»åŠ è¡¨æƒ…åŒ…
            emojisToShow.forEach((emoji, index) => {
                const emojiItem = document.createElement('div');
                emojiItem.className = 'custom-emoji-item';
                emojiItem.style.backgroundImage = emoji.url && emoji.url !== 'undefined' ? `url(${emoji.url})` : 'none';
                emojiItem.onclick = () => sendEmojiMessage(emoji);
                
                // ä¸ºè‡ªå®šä¹‰è¡¨æƒ…åŒ…å’Œæœ€è¿‘ä½¿ç”¨è¡¨æƒ…åŒ…æ·»åŠ åˆ é™¤æŒ‰é’®
                if (currentEmojiTab === 'custom' || currentEmojiTab === 'recent') {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'emoji-delete-btn';
                    deleteBtn.innerHTML = 'Ã—';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        if (currentEmojiTab === 'custom') {
                        deleteCustomEmoji(index);
                        } else if (currentEmojiTab === 'recent') {
                            deleteRecentEmoji(index);
                        }
                    };
                    emojiItem.appendChild(deleteBtn);
                }
                
                grid.appendChild(emojiItem);
            });
            
            // å¦‚æœæ˜¯è‡ªå®šä¹‰æ ‡ç­¾é¡µï¼Œæ·»åŠ ä¸Šä¼ æŒ‰é’®
            if (currentEmojiTab === 'custom') {
                const uploadItem = document.createElement('div');
                uploadItem.className = 'custom-emoji-item placeholder';
                uploadItem.innerHTML = '+';
                uploadItem.onclick = () => document.getElementById('emoji-upload').click();
                grid.appendChild(uploadItem);
            }
            
            // å¦‚æœæ²¡æœ‰è¡¨æƒ…åŒ…ï¼Œæ˜¾ç¤ºæç¤º
            if (emojisToShow.length === 0) {
                const emptyMsg = document.createElement('div');
                emptyMsg.className = 'empty-emoji-grid';
                
                                                if (currentEmojiTab === 'recent') {
                                    emptyMsg.textContent = 'è¿˜æ²¡æœ‰ä½¿ç”¨è¿‡è¡¨æƒ…åŒ…';
                                } else {
                                    emptyMsg.textContent = 'è¿˜æ²¡æœ‰è¡¨æƒ…åŒ…ï¼Œç‚¹å‡»+å·æ·»åŠ ';
                                }
                
                grid.appendChild(emptyMsg);
            }
        }
        
        // å‘é€è¡¨æƒ…åŒ…æ¶ˆæ¯
        function sendEmojiMessage(emoji) {
            console.log('ğŸ­ å‘é€è¡¨æƒ…åŒ…:', emoji);
            
            if (!currentChatCharacter) return;
            
            // æ·»åŠ åˆ°æœ€è¿‘ä½¿ç”¨
            addToRecentEmojis(emoji);
            
            // ğŸ”¥ã€ä¿®å¤ã€‘è¡¨æƒ…åŒ…æ¶ˆæ¯åªæ˜¾ç¤ºå›¾ç‰‡ï¼Œä¸æ˜¾ç¤ºæ–‡å­—å†…å®¹
            const messageId = Date.now().toString();
            const emojiMessage = {
                id: messageId,
                sender: 'sent',
                content: '', // è¡¨æƒ…åŒ…æ¶ˆæ¯ä¸æ˜¾ç¤ºæ–‡å­—å†…å®¹
                image: emoji.url,
                isEmoji: true,
                emojiDescription: emoji.description || 'è‡ªå®šä¹‰è¡¨æƒ…åŒ…',
                timestamp: Date.now()
            };
            
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            
            chatMessages[currentChatCharacter.id].push(emojiMessage);
            saveChatMessages();
            
            // æ¸²æŸ“æ¶ˆæ¯
            renderChatMessages(currentChatCharacter.id);
            
            // ğŸ”¥ã€æ–°å¢ã€‘è§¦å‘è§’è‰²çŠ¶æ€æ›´æ–°
            triggerStatusUpdateAfterMessage(currentChatCharacter.id);
            
            // éšè—è¡¨æƒ…åŒ…é¢æ¿
            hideCustomEmojiPanel();
            
            // è®¾ç½®å¾…å›å¤æ¶ˆæ¯ï¼Œæ”¯æŒæ™ºèƒ½å›å¤æŒ‰é’®
            pendingUserMessage = emojiMessage;
            
            // æ›´æ–°æ™ºèƒ½å›å¤æŒ‰é’®çŠ¶æ€
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = 'ç‚¹å‡»è·å–AIå›å¤';
            }
            
            // æ³¨é‡Šæ‰è‡ªåŠ¨å›å¤ï¼Œæ”¹ä¸ºæ‰‹åŠ¨å›å¤æ¨¡å¼
            // setTimeout(() => {
            //     sendAIEmojiResponse(emoji);
            // }, 1000 + Math.random() * 2000);
        }
        
        // æ·»åŠ åˆ°æœ€è¿‘ä½¿ç”¨çš„è¡¨æƒ…åŒ…
        async function addToRecentEmojis(emoji) {
            // ç§»é™¤å·²å­˜åœ¨çš„ç›¸åŒè¡¨æƒ…åŒ…
            recentEmojis = recentEmojis.filter(e => e.url !== emoji.url);
            
            // æ·»åŠ åˆ°å¼€å¤´
            recentEmojis.unshift(emoji);
            
            // é™åˆ¶æœ€è¿‘ä½¿ç”¨æ•°é‡ä¸º20ä¸ª
            if (recentEmojis.length > 20) {
                recentEmojis = recentEmojis.slice(0, 20);
            }
            
            await saveCustomEmojis();
        }
        
        // æ£€æµ‹å½“å‰æ¨¡å‹æ˜¯å¦æ”¯æŒè§†è§‰åŠŸèƒ½
        function isVisionModelSupported() {
            // æ”¯æŒè§†è§‰çš„æ¨¡å‹åˆ—è¡¨
            const visionModels = [
                // OpenAI GPTç³»åˆ—
                'gpt-4-vision',
                'gpt-4o',
                'gpt-4-turbo',
                'gpt-4o-mini',
                
                // Google Geminiç³»åˆ—
                'gemini-1.5-pro',
                'gemini-1.5-flash',
                'gemini-2.0-flash',
                'gemini-2.5-pro',
                'gemini-2.5-flash',
                'gemini-exp',
                'gemini-pro-vision',
                
                // Anthropic Claudeç³»åˆ—
                'claude-3-opus',
                'claude-3-sonnet',
                'claude-3-haiku',
                'claude-3.5-sonnet',
                'claude-3.5-haiku',
                
                // å›½äº§æ¨¡å‹
                'qwen-vl',
                'qwen2-vl',
                'yi-vision',
                'glm-4v',
                'internvl',
                'cogvlm',
                
                // å…¶ä»–æ¨¡å‹
                'llava',
                'moondream',
                'phi-3-vision'
            ];
            
            const currentModel = apiSettings.model?.toLowerCase() || '';
            
            // æ£€æŸ¥å½“å‰æ¨¡å‹æ˜¯å¦åŒ…å«ä»»ä½•æ”¯æŒè§†è§‰çš„æ¨¡å‹åç§°
            const isVisionSupported = visionModels.some(model => currentModel.includes(model.toLowerCase()));
            
            // è¾“å‡ºè°ƒè¯•ä¿¡æ¯
            console.log('å½“å‰æ¨¡å‹:', currentModel);
            console.log('æ˜¯å¦æ”¯æŒè§†è§‰:', isVisionSupported);
            
            return isVisionSupported;
        }
        
        // æ³¨é‡Šï¼šAIå¯¹è¡¨æƒ…åŒ…çš„è‡ªåŠ¨å›å¤åŠŸèƒ½å·²ç§»é™¤ï¼Œç°åœ¨ä½¿ç”¨æ‰‹åŠ¨å›å¤æ¨¡å¼
        // è¡¨æƒ…åŒ…å’Œå›¾ç‰‡éƒ½é€šè¿‡æ™ºèƒ½å›å¤æŒ‰é’®æ¥è§¦å‘AIå›å¤
        
        // åˆ é™¤è‡ªå®šä¹‰è¡¨æƒ…åŒ…
        function deleteCustomEmoji(index) {
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªè¡¨æƒ…åŒ…å—ï¼Ÿ')) {
                customEmojis.splice(index, 1);
                saveCustomEmojis();
                renderEmojiGrid();
            }
        }
        
        // åˆ é™¤æœ€è¿‘ä½¿ç”¨çš„è¡¨æƒ…åŒ…
        function deleteRecentEmoji(index) {
            if (confirm('ç¡®å®šè¦ä»æœ€è¿‘ä½¿ç”¨ä¸­åˆ é™¤è¿™ä¸ªè¡¨æƒ…åŒ…å—ï¼Ÿ')) {
                recentEmojis.splice(index, 1);
                saveCustomEmojis(); // ğŸ”§ã€ä¿®å¤ã€‘ç°åœ¨ä½¿ç”¨IndexedDBä¿å­˜
                renderEmojiGrid();
            }
        }
        
        // åˆå§‹åŒ–è¡¨æƒ…åŒ…ä¸Šä¼ åŠŸèƒ½
        function initializeEmojiUpload() {
            const emojiInput = document.getElementById('emoji-upload');
            if (emojiInput) {
                emojiInput.addEventListener('change', handleEmojiUpload);
            }
            
            // ç»‘å®šæ ‡ç­¾é¡µåˆ‡æ¢äº‹ä»¶
            document.querySelectorAll('.emoji-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    // ç§»é™¤æ‰€æœ‰activeç±»
                    document.querySelectorAll('.emoji-tab').forEach(t => t.classList.remove('active'));
                    // æ·»åŠ å½“å‰activeç±»
                    this.classList.add('active');
                    
                    // åˆ‡æ¢å½“å‰æ ‡ç­¾é¡µ
                    currentEmojiTab = this.dataset.tab;
                    renderEmojiGrid();
                });
            });
        }
        
        // åˆ‡æ¢å·¥å…·é¢æ¿æ˜¾ç¤º/éšè—
        function toggleToolsPanel() {
            const panel = document.getElementById('tools-panel');
            const toggleBtn = document.getElementById('toggle-tools-btn');
            const emojiPanel = document.getElementById('custom-emoji-panel');
            
            if (!panel || !toggleBtn) return;
            
            const isVisible = panel.style.display === 'block';
            
            if (isVisible) {
                // éšè—å·¥å…·é¢æ¿
                hideToolsPanel();
            } else {
                // æ˜¾ç¤ºå·¥å…·é¢æ¿
                showToolsPanel();
                
                // éšè—è¡¨æƒ…åŒ…é¢æ¿
                if (emojiPanel) {
                    emojiPanel.style.display = 'none';
                }
                
                // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­é¢æ¿
                setTimeout(() => {
                    document.addEventListener('click', handleToolsPanelOutsideClick);
                }, 100);
            }
        }
        
        // æ˜¾ç¤ºå·¥å…·é¢æ¿
        function showToolsPanel() {
            const panel = document.getElementById('tools-panel');
            const toggleBtn = document.getElementById('toggle-tools-btn');
            
            if (panel) {
                panel.style.display = 'block';
                panel.style.animation = 'toolsPanelSlideUp 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)';
            }
            
            if (toggleBtn) {
                toggleBtn.classList.add('active');
            }
        }
        
        // éšè—å·¥å…·é¢æ¿
        function hideToolsPanel() {
            const panel = document.getElementById('tools-panel');
            const toggleBtn = document.getElementById('toggle-tools-btn');
            
            if (panel) {
                panel.style.display = 'none';
            }
            
            if (toggleBtn) {
                toggleBtn.classList.remove('active');
            }
            
            // ç§»é™¤ç‚¹å‡»å¤–éƒ¨å…³é—­çš„äº‹ä»¶ç›‘å¬å™¨
            document.removeEventListener('click', handleToolsPanelOutsideClick);
        }
        
        // å¤„ç†å·¥å…·é¢æ¿å¤–éƒ¨ç‚¹å‡»äº‹ä»¶
        function handleToolsPanelOutsideClick(e) {
            const panel = document.getElementById('tools-panel');
            const toggleBtn = document.getElementById('toggle-tools-btn');
            
            // å¦‚æœç‚¹å‡»çš„æ˜¯å·¥å…·é¢æ¿å†…éƒ¨æˆ–è§¦å‘æŒ‰é’®ï¼Œä¸å…³é—­é¢æ¿
            if (panel && !panel.contains(e.target) && 
                toggleBtn && !toggleBtn.contains(e.target)) {
                hideToolsPanel();
            }
        }
        
        // å¤„ç†è¡¨æƒ…åŒ…ä¸Šä¼ 
        function handleEmojiUpload(e) {
            const files = e.target.files;
            if (!files || files.length === 0) return;
            
            Array.from(files).forEach(file => {
                if (!file.type.startsWith('image/')) {
                    alert('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶');
                    return;
                }
                
                // æ£€æŸ¥GIFæ ¼å¼ï¼Œæé†’ç”¨æˆ·å¯èƒ½çš„é—®é¢˜
                if (file.type === 'image/gif') {
                    const confirmed = confirm('æ£€æµ‹åˆ°GIFæ ¼å¼çš„è¡¨æƒ…åŒ…ï¼\n\nâš ï¸ æ³¨æ„äº‹é¡¹ï¼š\nâ€¢ AIå¯ä»¥å‘é€è¿™ä¸ªGIFåŠ¨å›¾\nâ€¢ ä½†Gemini APIæ— æ³•è¯†åˆ«GIFå†…å®¹\nâ€¢ é‡æ–°ç”ŸæˆåŠŸèƒ½å¯èƒ½å¤±æ•ˆ\nâ€¢ å»ºè®®ä½¿ç”¨é™æ€å›¾ç‰‡æ ¼å¼\n\næ˜¯å¦ä»è¦ä¸Šä¼ è¿™ä¸ªGIFè¡¨æƒ…åŒ…ï¼Ÿ');
                    if (!confirmed) {
                        return;
                    }
                }
                
                if (file.size > 5 * 1024 * 1024) {
                    alert('å›¾ç‰‡æ–‡ä»¶è¿‡å¤§ï¼Œè¯·é€‰æ‹©å°äº5MBçš„å›¾ç‰‡');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    // å¼¹å‡ºæè¿°è¾“å…¥æ¡†
                    const description = prompt('è¯·ä¸ºè¿™ä¸ªè¡¨æƒ…åŒ…æ·»åŠ æè¿°ï¼ˆæ¨èï¼å¸®åŠ©AIæ›´å¥½åœ°ç†è§£è¡¨æƒ…åŒ…å†…å®¹ï¼‰:\n\nä¾‹å¦‚ï¼š\nâ€¢ "ç¬‘å“­çš„è¡¨æƒ…"\nâ€¢ "æ¡æ‹³åŠ æ²¹çš„åŠ¨ä½œ"\nâ€¢ "å†™ç€OMGçš„è¡¨æƒ…åŒ…"\nâ€¢ "æ„¤æ€’çš„çŒ«å’ªå›¾ç‰‡"', '');
                    
                    const emoji = {
                        id: Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9),
                        url: event.target.result,
                        description: description || 'è¡¨æƒ…åŒ…',
                        addedAt: new Date().toISOString()
                    };
                    
                    customEmojis.push(emoji);
                    saveCustomEmojis();
                    
                    // å¦‚æœå½“å‰åœ¨è‡ªå®šä¹‰æ ‡ç­¾é¡µï¼Œé‡æ–°æ¸²æŸ“
                    if (currentEmojiTab === 'custom') {
                        renderEmojiGrid();
                    }
                };
                
                reader.readAsDataURL(file);
            });
            
            // æ¸…ç©ºæ–‡ä»¶è¾“å…¥
            e.target.value = '';
        }
        
        // åˆ¤æ–­é¢œè‰²æ˜¯å¦ä¸ºæµ…è‰²
        function isLightColor(color) {
            // å°†é¢œè‰²è½¬æ¢ä¸ºRGBå€¼
            let r, g, b;
            
            if (color.startsWith('#')) {
                // åå…­è¿›åˆ¶é¢œè‰²
                const hex = color.slice(1);
                if (hex.length === 3) {
                    r = parseInt(hex[0] + hex[0], 16);
                    g = parseInt(hex[1] + hex[1], 16);
                    b = parseInt(hex[2] + hex[2], 16);
                } else {
                    r = parseInt(hex.substr(0, 2), 16);
                    g = parseInt(hex.substr(2, 2), 16);
                    b = parseInt(hex.substr(4, 2), 16);
                }
            } else if (color.startsWith('rgb')) {
                // RGBé¢œè‰²
                const matches = color.match(/\d+/g);
                if (matches && matches.length >= 3) {
                    r = parseInt(matches[0]);
                    g = parseInt(matches[1]);
                    b = parseInt(matches[2]);
                }
            } else {
                // é»˜è®¤ä¸ºæ·±è‰²
                return false;
            }
            
            // è®¡ç®—äº®åº¦
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            return brightness > 128;
        }
        
        // æ›´æ–°æ°”æ³¡é¢„è§ˆ
        function updateBubblePreview() {
            const myColor = document.getElementById('my-bubble-color')?.value || '#007AFF';
            const aiColor = document.getElementById('ai-bubble-color')?.value || '#f0f0f0';
            const myOpacity = document.getElementById('my-bubble-opacity')?.value || '1';
            const aiOpacity = document.getElementById('ai-bubble-opacity')?.value || '1';
            
            // æ›´æ–°é¢„è§ˆæ°”æ³¡
            const demoMyBubble = document.getElementById('demo-my-bubble');
            const demoAiBubble = document.getElementById('demo-ai-bubble');
            
            if (demoMyBubble) {
                // ä½¿ç”¨rgbaèƒŒæ™¯è‰²è€Œä¸æ˜¯opacity
                const transparentMyColor = convertColorWithOpacity(myColor, myOpacity);
                demoMyBubble.style.backgroundColor = transparentMyColor;
                demoMyBubble.style.color = isLightColor(myColor) ? '#333' : '#fff';
            }
            
            if (demoAiBubble) {
                // ä½¿ç”¨rgbaèƒŒæ™¯è‰²è€Œä¸æ˜¯opacity
                const transparentAiColor = convertColorWithOpacity(aiColor, aiOpacity);
                demoAiBubble.style.backgroundColor = transparentAiColor;
                demoAiBubble.style.color = isLightColor(aiColor) ? '#333' : '#fff';
            }
            
            // æ›´æ–°é¢œè‰²é¢„è§ˆ
            const myPreview = document.getElementById('my-bubble-preview');
            const aiPreview = document.getElementById('ai-bubble-preview');
            
            if (myPreview) {
                // ä½¿ç”¨rgbaèƒŒæ™¯è‰²è€Œä¸æ˜¯opacity
                const transparentMyColor = convertColorWithOpacity(myColor, myOpacity);
                myPreview.style.backgroundColor = transparentMyColor;
                myPreview.textContent = 'æˆ‘çš„æ°”æ³¡';
            }
            
            if (aiPreview) {
                // ä½¿ç”¨rgbaèƒŒæ™¯è‰²è€Œä¸æ˜¯opacity
                const transparentAiColor = convertColorWithOpacity(aiColor, aiOpacity);
                aiPreview.style.backgroundColor = transparentAiColor;
                aiPreview.textContent = 'å¯¹æ–¹æ°”æ³¡';
            }
        }
        
        // ç»‘å®šå¤´åƒä¸Šä¼ äº‹ä»¶
        function bindAvatarUploadEvents() {
            // æˆ‘çš„å¤´åƒä¸Šä¼ 
            const myAvatarUpload = document.getElementById('my-chat-avatar-upload');
            if (myAvatarUpload) {
                myAvatarUpload.onchange = function(e) {
                    if (e.target.files && e.target.files[0]) {
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            const preview = document.getElementById('my-chat-avatar-preview');
                            if (preview) {
                                preview.style.backgroundImage = `url(${event.target.result})`;
                                preview.style.backgroundSize = 'cover';
                                preview.style.backgroundPosition = 'center';
                                preview.innerHTML = '';
                                window.selectedMyChatAvatar = event.target.result;
                            }
                        };
                        reader.readAsDataURL(e.target.files[0]);
                    }
                };
            }
            
            // AIå¤´åƒä¸Šä¼ 
            const aiAvatarUpload = document.getElementById('ai-chat-avatar-upload');
            if (aiAvatarUpload) {
                aiAvatarUpload.onchange = function(e) {
                    if (e.target.files && e.target.files[0]) {
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            const preview = document.getElementById('ai-chat-avatar-preview');
                            if (preview) {
                                preview.style.backgroundImage = `url(${event.target.result})`;
                                preview.style.backgroundSize = 'cover';
                                preview.style.backgroundPosition = 'center';
                                preview.innerHTML = '';
                                window.selectedAiChatAvatar = event.target.result;
                            }
                        };
                        reader.readAsDataURL(e.target.files[0]);
                    }
                };
            }
        }
        
        // åˆå§‹åŒ–å¤´åƒä¸Šä¼ åŠŸèƒ½
        function initializeAvatarUpload() {
            const avatarInput = document.getElementById('avatar-upload');
            if (!avatarInput) {
                console.error('æ‰¾ä¸åˆ°avatar-uploadå…ƒç´ ');
                return;
            }
            
            // ç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨
            avatarInput.removeEventListener('change', avatarUploadHandler);
            
            // æ·»åŠ æ–°çš„äº‹ä»¶ç›‘å¬å™¨
            avatarInput.addEventListener('change', avatarUploadHandler);
            console.log('å¤´åƒä¸Šä¼ äº‹ä»¶ç›‘å¬å™¨å·²ç»‘å®š');
        }
        
        // æ›´æ–°èŠå¤©è®¾ç½®ç•Œé¢çš„æ˜¾ç¤ºçŠ¶æ€
        async function updateChatSettingsDisplay() {
            if (!currentChatCharacter) {
                console.log("æ›´æ–°èŠå¤©è®¾ç½®ç•Œé¢æ˜¾ç¤ºï¼šæ— å½“å‰èŠå¤©è§’è‰²ï¼Œè·³è¿‡æ“ä½œ");
                return;
            }
            
            const chatSettings = await getAsyncChatSettings();
            
            // æ›´æ–°å†å²æ¶ˆæ¯æ•°æ˜¾ç¤º
            const historyCountElement = document.getElementById('current-history-count');
            if (historyCountElement) {
                historyCountElement.textContent = chatSettings.historyCount + 'å›åˆ';
            }
            
            // æ›´æ–°è®°å¿†æŒ‚è½½æ˜¾ç¤º
            const memoryMountElement = document.getElementById('current-memory-mount');
            if (memoryMountElement) {
                memoryMountElement.textContent = chatSettings.memoryMountEnabled ? 'å·²å¼€å¯' : 'å·²å…³é—­';
            }
            
            // æ›´æ–°ä¸–ç•Œä¹¦æŒ‚è½½æ˜¾ç¤º
            updateWorldbookMountDisplay();
            
            // æ›´æ–°æ—¶é—´æ„ŸçŸ¥å¼€å…³
            const timeAwarenessCheckbox = document.getElementById('time-awareness-enabled');
            if (timeAwarenessCheckbox) {
                timeAwarenessCheckbox.checked = chatSettings.timeAwarenessEnabled;
            }
            
            // æ›´æ–°é€šè¯è®¾ç½®
            const aiCallCheckbox = document.getElementById('ai-call-enabled');
            if (aiCallCheckbox) {
                aiCallCheckbox.checked = chatSettings.aiCallEnabled;
            }
            
            // æ›´æ–°å¿ƒç‡ç›‘æµ‹è®¾ç½®
            const aiHeartrateCheckbox = document.getElementById('ai-heartrate-enabled');
            if (aiHeartrateCheckbox) {
                aiHeartrateCheckbox.checked = chatSettings.aiHeartrateEnabled;
            }
            
            // æ›´æ–°è§’è‰²çŠ¶æ€æ˜¾ç¤ºè®¾ç½®
            const characterStatusCheckbox = document.getElementById('character-status-enabled');
            if (characterStatusCheckbox) {
                characterStatusCheckbox.checked = chatSettings.characterStatusEnabled || false;
                // ğŸ”¥ã€æ–°å¢ã€‘æ§åˆ¶çŠ¶æ€æ›´æ–°é¢‘ç‡è®¾ç½®çš„æ˜¾ç¤º
                const statusFrequencySetting = document.getElementById('status-frequency-setting');
                if (statusFrequencySetting) {
                    statusFrequencySetting.style.display = chatSettings.characterStatusEnabled ? 'flex' : 'none';
                }
            }
            
            // ğŸ”¥ã€ä¿®å¤ã€‘æ›´æ–°çŠ¶æ€æ›´æ–°é¢‘ç‡è®¾ç½® - ä»å…¨å±€è®¾ç½®è¯»å–
            const statusUpdateFrequencySelect = document.getElementById('status-update-frequency');
            if (statusUpdateFrequencySelect) {
                const globalFrequency = localStorage.getItem('globalStatusUpdateFrequency') || 'medium';
                statusUpdateFrequencySelect.value = globalFrequency;
            }
            

            
            // æ›´æ–°åå°äº’åŠ¨è®¾ç½®
            const backgroundInteractionCheckbox = document.getElementById('background-interaction-enabled');
            if (backgroundInteractionCheckbox) {
                backgroundInteractionCheckbox.checked = chatSettings.backgroundInteractionEnabled;
                // æ§åˆ¶è¯¦ç»†è®¾ç½®æ˜¾ç¤º
                const backgroundSettings = document.getElementById('background-interaction-settings');
                if (backgroundSettings) {
                    backgroundSettings.style.display = chatSettings.backgroundInteractionEnabled ? 'block' : 'none';
                }
            }
            
            const backgroundChatFrequencySelect = document.getElementById('background-chat-frequency');
            if (backgroundChatFrequencySelect) {
                backgroundChatFrequencySelect.value = chatSettings.backgroundChatFrequency || 'low';
            }
            
            const backgroundChatEnabledCheckbox = document.getElementById('background-chat-enabled');
            if (backgroundChatEnabledCheckbox) {
                backgroundChatEnabledCheckbox.checked = chatSettings.backgroundChatEnabled === true;
                // æ§åˆ¶é¢‘ç‡è®¾ç½®æ˜¾ç¤º - éœ€è¦åŒæ—¶æ£€æŸ¥æ€»å¼€å…³å’Œå­å¼€å…³
                const chatFrequencySetting = document.getElementById('chat-frequency-setting');
                if (chatFrequencySetting) {
                    chatFrequencySetting.style.display = (chatSettings.backgroundInteractionEnabled === true && chatSettings.backgroundChatEnabled === true) ? 'block' : 'none';
                }
            }
            
            const backgroundMomentsEnabledCheckbox = document.getElementById('background-moments-enabled');
            if (backgroundMomentsEnabledCheckbox) {
                backgroundMomentsEnabledCheckbox.checked = chatSettings.backgroundMomentsEnabled === true;
                // æ§åˆ¶ç›¸å…³è®¾ç½®æ˜¾ç¤º - éœ€è¦åŒæ—¶æ£€æŸ¥æ€»å¼€å…³å’Œå­å¼€å…³
                const momentsEnabled = (chatSettings.backgroundInteractionEnabled === true && chatSettings.backgroundMomentsEnabled === true);
                const momentsFrequencySetting = document.getElementById('moments-frequency-setting');
                const scheduledMomentsSetting = document.getElementById('scheduled-moments-setting');
                const testPublishSetting = document.getElementById('test-publish-setting');
                
                if (momentsFrequencySetting) {
                    momentsFrequencySetting.style.display = momentsEnabled ? 'flex' : 'none';
                }
                if (scheduledMomentsSetting) {
                    scheduledMomentsSetting.style.display = momentsEnabled ? 'flex' : 'none';
                }
                if (testPublishSetting) {
                    testPublishSetting.style.display = momentsEnabled ? 'flex' : 'none';
                }
            }
            
            const backgroundMomentsFrequencySelect = document.getElementById('background-moments-frequency');
            if (backgroundMomentsFrequencySelect) {
                backgroundMomentsFrequencySelect.value = chatSettings.backgroundMomentsFrequency || 'low';
            }
            
            const scheduledMomentsEnabledCheckbox = document.getElementById('scheduled-moments-enabled');
            if (scheduledMomentsEnabledCheckbox) {
                scheduledMomentsEnabledCheckbox.checked = chatSettings.scheduledMomentsEnabled || false;
                // æ§åˆ¶æ—¶é—´è®¾ç½®æŒ‰é’®æ˜¾ç¤º
                const scheduledTimesButton = document.querySelector('button[onclick="showScheduleTimesModal()"]');
                if (scheduledTimesButton) {
                    scheduledTimesButton.style.display = chatSettings.scheduledMomentsEnabled ? 'inline-block' : 'none';
                }
            }
            
            // æ›´æ–°å®šæ—¶å‘å¸ƒæ—¶é—´æ˜¾ç¤º
            updateScheduleTimesDisplay();
            
            // æ›´æ–°æ—¶é—´æˆ³è®¾ç½®
            const timestampCheckbox = document.getElementById('timestamp-enabled');
            if (timestampCheckbox) {
                timestampCheckbox.checked = chatSettings.timestampEnabled;
            }
            
            // ç»‘å®šäº‹ä»¶ç›‘å¬å™¨æ¥ä¿å­˜è®¾ç½®å˜åŒ–
            bindChatSettingsEvents();
        }
        
        // ç»‘å®šèŠå¤©è®¾ç½®çš„äº‹ä»¶ç›‘å¬å™¨
        function bindChatSettingsEvents() {
            // æ—¶é—´æ„ŸçŸ¥å¼€å…³
            const timeAwarenessCheckbox = document.getElementById('time-awareness-enabled');
            if (timeAwarenessCheckbox) {
                timeAwarenessCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.timeAwarenessEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                };
            }
            
            // é€šè¯è®¾ç½®
            const aiCallCheckbox = document.getElementById('ai-call-enabled');
            if (aiCallCheckbox) {
                aiCallCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.aiCallEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    showToast(`è§’è‰²ä¸»åŠ¨æ‹¨æ‰“ç”µè¯å·²${this.checked ? 'å¼€å¯' : 'å…³é—­'}`, 'success');
                };
            }
            
            // å¿ƒç‡ç›‘æµ‹è®¾ç½®
            const aiHeartrateCheckbox = document.getElementById('ai-heartrate-enabled');
            if (aiHeartrateCheckbox) {
                aiHeartrateCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.aiHeartrateEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    
                    // ç«‹å³æ›´æ–°å¿ƒç‡æ˜¾ç¤ºçŠ¶æ€
                    if (currentChatCharacter) {
                        updateAiHeartrate();
                    }
                    
                    showToast(`è§’è‰²å¿ƒç‡ç›‘æµ‹å·²${this.checked ? 'å¼€å¯' : 'å…³é—­'}`, 'success');
                };
            }
            

            
            // åå°äº’åŠ¨è®¾ç½®
            const backgroundInteractionCheckbox = document.getElementById('background-interaction-enabled');
            if (backgroundInteractionCheckbox) {
                backgroundInteractionCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundInteractionEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    // æ˜¾ç¤º/éšè—è¯¦ç»†è®¾ç½®
                    const backgroundSettings = document.getElementById('background-interaction-settings');
                    if (backgroundSettings) {
                        backgroundSettings.style.display = this.checked ? 'block' : 'none';
                    }

                    // ğŸ”¥ã€ä¿®å¤ã€‘å½“æ€»å¼€å…³å…³é—­æ—¶ï¼ŒåŒæ—¶æ›´æ–°å­å¼€å…³çš„æ˜¾ç¤ºçŠ¶æ€
                    if (!this.checked) {
                        // éšè—æ‰€æœ‰å­åŠŸèƒ½çš„è®¾ç½®
                        const chatFrequencySetting = document.getElementById('chat-frequency-setting');
                        const momentsFrequencySetting = document.getElementById('moments-frequency-setting');
                        const scheduledMomentsSetting = document.getElementById('scheduled-moments-setting');
                        const testPublishSetting = document.getElementById('test-publish-setting');

                        if (chatFrequencySetting) chatFrequencySetting.style.display = 'none';
                        if (momentsFrequencySetting) momentsFrequencySetting.style.display = 'none';
                        if (scheduledMomentsSetting) scheduledMomentsSetting.style.display = 'none';
                        if (testPublishSetting) testPublishSetting.style.display = 'none';
                    } else {
                        // æ€»å¼€å…³å¼€å¯æ—¶ï¼Œæ ¹æ®å­å¼€å…³çŠ¶æ€æ˜¾ç¤ºç›¸åº”è®¾ç½®
                        const backgroundChatEnabled = chatSettings.backgroundChatEnabled === true;
                        const backgroundMomentsEnabled = chatSettings.backgroundMomentsEnabled === true;

                        const chatFrequencySetting = document.getElementById('chat-frequency-setting');
                        const momentsFrequencySetting = document.getElementById('moments-frequency-setting');
                        const scheduledMomentsSetting = document.getElementById('scheduled-moments-setting');
                        const testPublishSetting = document.getElementById('test-publish-setting');

                        if (chatFrequencySetting) chatFrequencySetting.style.display = backgroundChatEnabled ? 'block' : 'none';
                        if (momentsFrequencySetting) momentsFrequencySetting.style.display = backgroundMomentsEnabled ? 'flex' : 'none';
                        if (scheduledMomentsSetting) scheduledMomentsSetting.style.display = backgroundMomentsEnabled ? 'block' : 'none';
                        if (testPublishSetting) testPublishSetting.style.display = backgroundMomentsEnabled ? 'flex' : 'none';
                    }

                    // é‡æ–°åˆå§‹åŒ–åå°äº’åŠ¨ç³»ç»Ÿ
                    initBackgroundInteractionSystem();
                };
            }
            
            const backgroundChatFrequencySelect = document.getElementById('background-chat-frequency');
            if (backgroundChatFrequencySelect) {
                backgroundChatFrequencySelect.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundChatFrequency = this.value;
                    await saveCurrentChatSettings(chatSettings);
                };
            }
            
            const backgroundChatEnabledCheckbox = document.getElementById('background-chat-enabled');
            if (backgroundChatEnabledCheckbox) {
                backgroundChatEnabledCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundChatEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);

                    // ğŸ”¥ã€ä¿®å¤ã€‘æ§åˆ¶é¢‘ç‡è®¾ç½®æ˜¾ç¤º - éœ€è¦åŒæ—¶æ£€æŸ¥æ€»å¼€å…³å’Œå­å¼€å…³
                    const chatFrequencySetting = document.getElementById('chat-frequency-setting');
                    if (chatFrequencySetting) {
                        const showSetting = (chatSettings.backgroundInteractionEnabled === true && this.checked);
                        chatFrequencySetting.style.display = showSetting ? 'block' : 'none';
                    }

                    // é‡æ–°åˆå§‹åŒ–åå°äº’åŠ¨ç³»ç»Ÿ
                    initBackgroundInteractionSystem();
                };
            }
            
            const backgroundMomentsEnabledCheckbox = document.getElementById('background-moments-enabled');
            if (backgroundMomentsEnabledCheckbox) {
                backgroundMomentsEnabledCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundMomentsEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);

                    // ğŸ”¥ã€ä¿®å¤ã€‘æ§åˆ¶ç›¸å…³è®¾ç½®æ˜¾ç¤º - éœ€è¦åŒæ—¶æ£€æŸ¥æ€»å¼€å…³å’Œå­å¼€å…³
                    const momentsFrequencySetting = document.getElementById('moments-frequency-setting');
                    const scheduledMomentsSetting = document.getElementById('scheduled-moments-setting');
                    const testPublishSetting = document.getElementById('test-publish-setting');

                    const showSettings = (chatSettings.backgroundInteractionEnabled === true && this.checked);

                    if (momentsFrequencySetting) {
                        momentsFrequencySetting.style.display = showSettings ? 'flex' : 'none';
                    }
                    if (scheduledMomentsSetting) {
                        scheduledMomentsSetting.style.display = showSettings ? 'flex' : 'none';
                    }
                    if (testPublishSetting) {
                        testPublishSetting.style.display = showSettings ? 'flex' : 'none';
                    }

                    // é‡æ–°åˆå§‹åŒ–åå°äº’åŠ¨ç³»ç»Ÿ
                    initBackgroundInteractionSystem();
                };
            }
            
            const backgroundMomentsFrequencySelect = document.getElementById('background-moments-frequency');
            if (backgroundMomentsFrequencySelect) {
                backgroundMomentsFrequencySelect.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundMomentsFrequency = this.value;
                    await saveCurrentChatSettings(chatSettings);
                    
                    // é‡æ–°åˆå§‹åŒ–åå°äº’åŠ¨ç³»ç»Ÿ
                    initBackgroundInteractionSystem();
                };
            }
            
            const scheduledMomentsEnabledCheckbox = document.getElementById('scheduled-moments-enabled');
            if (scheduledMomentsEnabledCheckbox) {
                scheduledMomentsEnabledCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.scheduledMomentsEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    
                    // æ§åˆ¶æ—¶é—´è®¾ç½®æŒ‰é’®æ˜¾ç¤º
                    const scheduledTimesButton = document.querySelector('button[onclick="showScheduleTimesModal()"]');
                    if (scheduledTimesButton) {
                        scheduledTimesButton.style.display = this.checked ? 'inline-block' : 'none';
                    }
                    
                    // é‡æ–°åˆå§‹åŒ–å®šæ—¶å‘å¸ƒç³»ç»Ÿ
                    initScheduledMomentsSystem();
                };
            }
            
            // æ—¶é—´æˆ³è®¾ç½®
            const timestampCheckbox = document.getElementById('timestamp-enabled');
            if (timestampCheckbox) {
                timestampCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.timestampEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    // é‡æ–°æ¸²æŸ“èŠå¤©æ¶ˆæ¯
                    if (currentChatCharacter) {
                        renderChatMessages(currentChatCharacter.id);
                    }
                };
            }
            
            // è§’è‰²çŠ¶æ€æ˜¾ç¤ºè®¾ç½®
            const characterStatusCheckbox = document.getElementById('character-status-enabled');
            if (characterStatusCheckbox) {
                characterStatusCheckbox.onchange = async function() {
                    console.log('çŠ¶æ€æ˜¾ç¤ºå¼€å…³è¢«ç‚¹å‡»:', this.checked);
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.characterStatusEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    
                    // ğŸ”¥ã€æ–°å¢ã€‘æ§åˆ¶çŠ¶æ€æ›´æ–°é¢‘ç‡è®¾ç½®çš„æ˜¾ç¤º
                    const statusFrequencySetting = document.getElementById('status-frequency-setting');
                    if (statusFrequencySetting) {
                        statusFrequencySetting.style.display = this.checked ? 'flex' : 'none';
                    }
                    
                    // é‡æ–°æ¸²æŸ“èŠå¤©ç•Œé¢ä»¥æ˜¾ç¤º/éšè—çŠ¶æ€
                    if (currentChatCharacter) {
                        renderChatMessages(currentChatCharacter.id);
                        // æ›´æ–°èŠå¤©æ ‡é¢˜åŒºåŸŸçš„çŠ¶æ€æ˜¾ç¤º
                        const headerContainer = document.querySelector('#api-chat-screen .header');
                        if (headerContainer) {
                            renderCharacterStatus(currentChatCharacter.id, headerContainer);
                        }
                    }
                    
                    // ğŸ”¥ã€æ–°å¢ã€‘é‡å¯çŠ¶æ€æ›´æ–°å®šæ—¶å™¨ä»¥åº”ç”¨æ–°è®¾ç½®
                    restartCharacterStatusTimer();
                    
                    showToast(`è§’è‰²çŠ¶æ€æ˜¾ç¤ºå·²${this.checked ? 'å¼€å¯' : 'å…³é—­'}`, 'success');
                };
            } else {
                console.warn('æ‰¾ä¸åˆ°character-status-enabledå…ƒç´ ');
            }
            
            // ğŸ”¥ã€ä¿®å¤ã€‘çŠ¶æ€æ›´æ–°é¢‘ç‡è®¾ç½® - ä¿å­˜ä¸ºå…¨å±€è®¾ç½®
            const statusUpdateFrequencySelect = document.getElementById('status-update-frequency');
            if (statusUpdateFrequencySelect) {
                statusUpdateFrequencySelect.onchange = async function() {
                    // ğŸ”¥ã€ä¿®å¤ã€‘ä¿å­˜ä¸ºå…¨å±€è®¾ç½®ï¼Œè€Œä¸æ˜¯è§’è‰²ä¸“å±è®¾ç½®
                    localStorage.setItem('globalStatusUpdateFrequency', this.value);

                    // åŒæ—¶æ›´æ–°å½“å‰è§’è‰²çš„è®¾ç½®ä»¥ä¿æŒä¸€è‡´æ€§
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.statusUpdateFrequency = this.value;
                    await saveCurrentChatSettings(chatSettings);

                    // é‡å¯çŠ¶æ€æ›´æ–°å®šæ—¶å™¨ä»¥åº”ç”¨æ–°é¢‘ç‡
                    restartCharacterStatusTimer();

                    const frequencyNames = {
                        'high': 'é«˜é¢‘',
                        'medium-high': 'ä¸­é«˜é¢‘',
                        'medium': 'ä¸­é¢‘',
                        'medium-low': 'ä¸­ä½é¢‘',
                        'low': 'ä½é¢‘'
                    };

                    showToast(`çŠ¶æ€æ›´æ–°é¢‘ç‡å·²è®¾ç½®ä¸º${frequencyNames[this.value]}`, 'success');
                };
            }
        }

        // åˆå§‹åŒ–èŠå¤©è®¾ç½®ç•Œé¢
        async function initializeChatSettings() {
            console.log("å¼€å§‹åˆå§‹åŒ–èŠå¤©è®¾ç½®ç•Œé¢");
            
            // åˆå§‹åŒ–UIç›¸å…³äº‹ä»¶
            initChatSettingsUIEvents();
            
            // å¦‚æœæ²¡æœ‰currentChatCharacterï¼Œåªåˆå§‹åŒ–UIäº‹ä»¶ï¼Œä¸åŠ è½½è®¾ç½®
            if (!currentChatCharacter) {
                console.log("åˆå§‹åŒ–èŠå¤©è®¾ç½®ç•Œé¢ï¼šæ— å½“å‰èŠå¤©è§’è‰²ï¼Œåªåˆå§‹åŒ–UIäº‹ä»¶");
                return;
            }
            
            // æ›´æ–°èº«ä»½æ˜¾ç¤º
            await updateChatIdentityDisplay();
            
            // æ›´æ–°æ°”æ³¡æ ·å¼æ˜¾ç¤º
            await updateBubbleStyleDisplay();
            
            // æ›´æ–°æ‰€æœ‰è®¾ç½®æ˜¾ç¤ºçŠ¶æ€
            await updateChatSettingsDisplay();
            
            // åŠ è½½å½“å‰èŠå¤©çš„è®¾ç½®
            if (currentChatCharacter) {
                const chatSettings = await getAsyncChatSettings();
            }
        }

        // åˆå§‹åŒ–èŠå¤©è®¾ç½®UIç›¸å…³äº‹ä»¶
        function initChatSettingsUIEvents() {
            

            
            // ğŸ”¥ã€ä¿®å¤ã€‘ç»‘å®šåå°äº’åŠ¨å¼€å…³äº‹ä»¶ - è¿™é‡Œåªå¤„ç†UIæ˜¾ç¤ºï¼Œå®é™…ä¿å­˜åœ¨å¦ä¸€ä¸ªåœ°æ–¹å¤„ç†
            const backgroundInteractionCheckbox = document.getElementById('background-interaction-enabled');
            if (backgroundInteractionCheckbox) {
                backgroundInteractionCheckbox.addEventListener('change', function() {
                    const backgroundSettings = document.getElementById('background-interaction-settings');
                    if (backgroundSettings) {
                        backgroundSettings.style.display = this.checked ? 'block' : 'none';
                    }

                    // ğŸ”¥ã€ä¿®å¤ã€‘å½“æ€»å¼€å…³å…³é—­æ—¶ï¼ŒåŒæ—¶éšè—æ‰€æœ‰å­åŠŸèƒ½çš„è®¾ç½®
                    if (!this.checked) {
                        const chatFrequencySetting = document.getElementById('chat-frequency-setting');
                        const momentsFrequencySetting = document.getElementById('moments-frequency-setting');
                        const scheduledMomentsSetting = document.getElementById('scheduled-moments-setting');
                        const testPublishSetting = document.getElementById('test-publish-setting');

                        if (chatFrequencySetting) chatFrequencySetting.style.display = 'none';
                        if (momentsFrequencySetting) momentsFrequencySetting.style.display = 'none';
                        if (scheduledMomentsSetting) scheduledMomentsSetting.style.display = 'none';
                        if (testPublishSetting) testPublishSetting.style.display = 'none';

                        clearAllBackgroundTimers();
                    } else {
                        // å¦‚æœå¼€å¯åå°äº’åŠ¨ï¼Œé‡æ–°åˆå§‹åŒ–ç³»ç»Ÿ
                        initBackgroundInteractionSystem();
                    }
                });
            }
            
            // ğŸ”¥ã€ä¿®å¤ã€‘ç»‘å®šä¸»åŠ¨èŠå¤©å¼€å…³äº‹ä»¶ - è¿™é‡Œåªå¤„ç†UIæ˜¾ç¤ºï¼Œå®é™…ä¿å­˜åœ¨å¦ä¸€ä¸ªåœ°æ–¹å¤„ç†
            const backgroundChatCheckbox = document.getElementById('background-chat-enabled');
            if (backgroundChatCheckbox) {
                backgroundChatCheckbox.addEventListener('change', function() {
                    // ğŸ”¥ã€ä¿®å¤ã€‘éœ€è¦æ£€æŸ¥æ€»å¼€å…³çŠ¶æ€
                    const backgroundInteractionCheckbox = document.getElementById('background-interaction-enabled');
                    const totalSwitchEnabled = backgroundInteractionCheckbox ? backgroundInteractionCheckbox.checked : false;

                    const frequencySetting = document.getElementById('chat-frequency-setting');
                    if (frequencySetting) {
                        const showSetting = (totalSwitchEnabled && this.checked);
                        frequencySetting.style.display = showSetting ? 'block' : 'none';
                    }

                    // é‡æ–°åˆå§‹åŒ–åå°äº’åŠ¨ç³»ç»Ÿ
                    if (currentChatCharacter) {
                        initBackgroundInteractionSystem();
                    }
                });
            }
            
            // ğŸ”¥ã€ä¿®å¤ã€‘ç»‘å®šä¸»åŠ¨å‘åŠ¨æ€å¼€å…³äº‹ä»¶ - è¿™é‡Œåªå¤„ç†UIæ˜¾ç¤ºï¼Œå®é™…ä¿å­˜åœ¨å¦ä¸€ä¸ªåœ°æ–¹å¤„ç†
            const backgroundMomentsCheckbox = document.getElementById('background-moments-enabled');
            if (backgroundMomentsCheckbox) {
                backgroundMomentsCheckbox.addEventListener('change', function() {
                    // ğŸ”¥ã€ä¿®å¤ã€‘éœ€è¦æ£€æŸ¥æ€»å¼€å…³çŠ¶æ€
                    const backgroundInteractionCheckbox = document.getElementById('background-interaction-enabled');
                    const totalSwitchEnabled = backgroundInteractionCheckbox ? backgroundInteractionCheckbox.checked : false;

                    const showSettings = (totalSwitchEnabled && this.checked);

                    const frequencySetting = document.getElementById('moments-frequency-setting');
                    const scheduledMomentsSetting = document.getElementById('scheduled-moments-setting');
                    const testPublishSetting = document.getElementById('test-publish-setting');

                    if (frequencySetting) frequencySetting.style.display = showSettings ? 'flex' : 'none';
                    if (scheduledMomentsSetting) scheduledMomentsSetting.style.display = showSettings ? 'flex' : 'none';
                    if (testPublishSetting) testPublishSetting.style.display = showSettings ? 'flex' : 'none';

                    // é‡æ–°åˆå§‹åŒ–åå°äº’åŠ¨ç³»ç»Ÿ
                    if (currentChatCharacter) {
                        initBackgroundInteractionSystem();
                    }
                });
            }
            
            // ä¸»åŠ¨æ‹¨æ‰“ç”µè¯å¼€å…³äº‹ä»¶å·²åœ¨ä¸Šé¢çš„ initChatSettingsUIEvents ä¸­å¤„ç†
            
            // ç»‘å®šæˆ³ä¸€æˆ³åŠŸèƒ½å¼€å…³äº‹ä»¶
            const pokeEnabledCheckbox = document.getElementById('poke-enabled');
            if (pokeEnabledCheckbox) {
                pokeEnabledCheckbox.addEventListener('change', function() {
                    const pokeSuffixSettings = document.getElementById('poke-suffix-settings');
                    if (pokeSuffixSettings) {
                        pokeSuffixSettings.style.display = this.checked ? 'block' : 'none';
                    }
                });
            }
            
            // ç»‘å®šé€‰æ‹©æ¨¡å¼æŒ‰é’®äº‹ä»¶
            const selectionCancelBtn = document.getElementById('selection-cancel-btn');
            const selectionDeleteBtn = document.getElementById('selection-delete-btn');
            
            if (selectionCancelBtn) {
                selectionCancelBtn.addEventListener('click', exitMessageSelectionMode);
            }
            
            if (selectionDeleteBtn) {
                selectionDeleteBtn.addEventListener('click', function() {
                    if (selectedMessages.size === 0) return;
                    
                    deleteSelectedMessages();
                });
            }
        }
        
        // æˆ³ä¸€æˆ³åŠŸèƒ½
        function pokeCharacter(characterId) {
            if (!currentChatCharacter || currentChatCharacter.id !== characterId) {
                return;
            }
            
            const chatSettings = getCurrentChatSettings();
            const pokeSuffix = chatSettings.myPokeSuffix || '';
            const characterName = chatSettings.aiChatNickname || currentChatCharacter.name;
            
            // åˆ›å»ºæˆ³ä¸€æˆ³ç³»ç»Ÿæ¶ˆæ¯
            const pokeMessage = {
                id: Date.now().toString(),
                sender: 'system',
                content: `ä½ æˆ³äº†æˆ³${characterName}${pokeSuffix}`,
                timestamp: Date.now(),
                isPoke: true
            };
            
            // æ·»åŠ åˆ°èŠå¤©è®°å½•
            if (!chatMessages[characterId]) {
                chatMessages[characterId] = [];
            }
            
            chatMessages[characterId].push(pokeMessage);
            saveChatMessages();
            
            // æ¸²æŸ“æ¶ˆæ¯
            renderChatMessages(characterId);
            
            // æ¨¡æ‹Ÿè§’è‰²å›åº”ï¼ˆ40%æ¦‚ç‡ï¼‰
            if (Math.random() < 0.4) {
                setTimeout(() => {
                    const aiPokeSuffix = chatSettings.aiPokeSuffix || '';
                    const aiPokeMessage = {
                        id: Date.now().toString(),
                        sender: 'system',
                        content: `${characterName}æˆ³äº†æˆ³ä½ ${aiPokeSuffix}`,
                        timestamp: Date.now(),
                        isPoke: true
                    };
                    
                    chatMessages[characterId].push(aiPokeMessage);
                    saveChatMessages();
                    renderChatMessages(characterId);
                }, 1000 + Math.random() * 2000);
            }
        }
        
        // æ˜¾ç¤ºèŠå¤©é€‰é¡¹
        function showChatOptions() {
            showModal('chat-options-modal');
        }
        
        // æ˜¾ç¤ºå•èŠèº«ä»½é€‰æ‹©ï¼ˆç¬¬ä¸€æ­¥ï¼‰
        function showSingleChatSelector() {
            hideModal('chat-options-modal');
            showPersonaSelectionForSingleChat();
        }
        
        // æ˜¾ç¤ºå•èŠèº«ä»½é€‰æ‹©
        function showPersonaSelectionForSingleChat() {
            const modalHTML = `
                <div class="modal" id="persona-selection-modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 class="modal-title">é€‰æ‹©èº«ä»½</h3>
                            <button class="modal-close" onclick="hidePersonaSelectionModal()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p class="selection-description">è¯·é€‰æ‹©ä½ åœ¨è¿™æ¬¡å¯¹è¯ä¸­ä½¿ç”¨çš„èº«ä»½é¢å…·</p>
                            <div class="persona-selection-list" id="persona-selection-list">
                                ${personas.map(persona => `
                                    <div class="persona-selection-item" data-persona-id="${persona.id}">
                                        <div class="persona-selection-avatar" style="${persona.avatarUrl ? `background-image: url(${persona.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                                            ${persona.avatarUrl ? '' : persona.name.charAt(0)}
                                        </div>
                                        <div class="persona-selection-info">
                                            <div class="persona-selection-name">${persona.name}</div>
                                            <div class="persona-selection-desc">${truncateText(persona.description || 'æš‚æ— æè¿°', 100)}</div>
                                        </div>
                                        <div class="persona-selection-check">
                                            <i class="fas fa-check"></i>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-secondary" onclick="hidePersonaSelectionModal()">å–æ¶ˆ</button>
                            <button class="modal-primary" id="confirm-persona-btn" onclick="confirmPersonaAndShowCharacters()" disabled>ä¸‹ä¸€æ­¥ï¼šé€‰æ‹©è§’è‰²</button>
                        </div>
                    </div>
                </div>
            `;
            
            // ç§»é™¤å·²å­˜åœ¨çš„æ¨¡æ€æ¡†
            const existingModal = document.getElementById('persona-selection-modal');
            if (existingModal) {
                existingModal.remove();
            }
            
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            
            // ç»‘å®šç‚¹å‡»äº‹ä»¶
            document.querySelectorAll('.persona-selection-item').forEach(item => {
                item.addEventListener('click', function() {
                    document.querySelectorAll('.persona-selection-item').forEach(i => i.classList.remove('selected'));
                    this.classList.add('selected');
                    window.selectedPersonaForChat = this.dataset.personaId;
                    document.getElementById('confirm-persona-btn').disabled = false;
                });
            });
        }
        
        // éšè—èº«ä»½é€‰æ‹©æ¨¡æ€æ¡†
        function hidePersonaSelectionModal() {
            const modal = document.getElementById('persona-selection-modal');
            if (modal) {
                modal.remove();
            }
            window.selectedPersonaForChat = null;
        }
        
        // ç¡®è®¤èº«ä»½é€‰æ‹©å¹¶æ˜¾ç¤ºè§’è‰²é€‰æ‹©
        function confirmPersonaAndShowCharacters() {
            if (!window.selectedPersonaForChat) return;
            
            hidePersonaSelectionModal();
            showCharacterSelectionForSingleChat();
        }
        
        // æ˜¾ç¤ºå•èŠè§’è‰²é€‰æ‹©ï¼ˆç¬¬äºŒæ­¥ï¼‰
        function showCharacterSelectionForSingleChat() {
            // ğŸ”¥ã€ä¿®å¤ã€‘ä¿å­˜å½“å‰é€‰ä¸­çš„èº«ä»½IDï¼Œé˜²æ­¢åœ¨åç»­æµç¨‹ä¸­ä¸¢å¤±
            const savedPersonaId = window.selectedPersonaForChat;
            console.log('=== showCharacterSelectionForSingleChat ===');
            console.log('ä¿å­˜çš„èº«ä»½ID:', savedPersonaId);
            
            const modalBody = document.getElementById('single-chat-body');
            modalBody.innerHTML = '';
            
            if (characters.length === 0) {
                modalBody.innerHTML = '<p class="empty-mount-chats">è¿˜æ²¡æœ‰è§’è‰²ï¼Œè¯·å…ˆåˆ›å»ºè§’è‰²</p>';
            } else {
                characters.forEach(character => {
                    const chatOption = document.createElement('div');
                    // ğŸ”¥ã€æ–°å¢ã€‘æ£€æŸ¥è§’è‰²æ˜¯å¦å·²å­˜åœ¨å¯¹è¯ï¼Œæ·»åŠ ä¸åŒçš„CSSç±»
                    const hasExistingChat = contacts.includes(character.id);
                    chatOption.className = `chat-option-item ${hasExistingChat ? 'has-existing-chat' : ''}`;
                    
                    chatOption.onclick = () => {
                        // ğŸ”¥ã€ä¿®å¤ã€‘ä½¿ç”¨ä¿å­˜çš„èº«ä»½IDè€Œä¸æ˜¯å…¨å±€å˜é‡
                        console.log('=== è§’è‰²é€‰æ‹©ç‚¹å‡»äº‹ä»¶ ===');
                        console.log('é€‰ä¸­çš„è§’è‰²:', character.name);
                        console.log('ä½¿ç”¨çš„èº«ä»½ID:', savedPersonaId);
                        
                        hideModal('single-chat-modal');
                        // è®¾ç½®é€‰æ‹©çš„èº«ä»½å¹¶å¼€å§‹èŠå¤©
                        startChatWithPersona(character, savedPersonaId);
                        
                        // æ¸…ç†ä¸´æ—¶å˜é‡
                        window.selectedPersonaForChat = null;
                    };
                    
                    // ğŸ”¥ã€æ–°å¢ã€‘ä¸ºå·²å­˜åœ¨å¯¹è¯çš„è§’è‰²æ·»åŠ çŠ¶æ€æç¤º
                    const statusIndicator = hasExistingChat ? `
                        <div class="chat-status-indicator">
                            <i class="fas fa-comments"></i>
                            <span>å·²æœ‰å¯¹è¯</span>
                        </div>
                    ` : '';
                    
                    chatOption.innerHTML = `
                        <div class="chat-option-icon" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                            ${character.avatarUrl ? '' : character.name.charAt(0)}
                        </div>
                        <div class="chat-option-text">
                            <div class="chat-option-title">${character.name}${hasExistingChat ? ' <span class="chat-exists-badge">å·²æœ‰å¯¹è¯</span>' : ''}</div>
                            <div class="chat-option-desc">${truncateText(character.bio || 'æš‚æ— æè¿°', 80)}</div>
                        </div>
                        ${statusIndicator}
                    `;
                    
                    modalBody.appendChild(chatOption);
                });
            }
            
            showModal('single-chat-modal');
        }
        
        async function startChatWithPersona(character, personaId) {
            console.log('âœ…[ä¿®å¤] startChatWithPersona è¢«è°ƒç”¨');
            
            // ğŸ”¥ã€æ–°å¢ã€‘æ£€æŸ¥è¯¥è§’è‰²æ˜¯å¦å·²å­˜åœ¨å¯¹è¯
            if (contacts.includes(character.id)) {
                // è§’è‰²å·²å­˜åœ¨å¯¹è¯ï¼Œè¯¢é—®ç”¨æˆ·æ˜¯å¦è¦ç»§ç»­æˆ–å–æ¶ˆ
                const existingSettings = chatSettings[character.id] || {};
                const existingPersona = personas.find(p => p.id === existingSettings.selectedIdentityId);
                const existingIdentityName = existingPersona ? existingPersona.name : 'æœªçŸ¥èº«ä»½';
                
                const confirmed = confirm(
                    `è§’è‰²ã€Œ${character.name}ã€å·²å­˜åœ¨å¯¹è¯ï¼\n` +
                    `å½“å‰å¯¹è¯ä½¿ç”¨çš„èº«ä»½ï¼š${existingIdentityName}\n\n` +
                    `é€‰æ‹©ã€Œç¡®å®šã€ï¼šç»§ç»­ä½¿ç”¨ç°æœ‰å¯¹è¯\n` +
                    `é€‰æ‹©ã€Œå–æ¶ˆã€ï¼šæ”¾å¼ƒæœ¬æ¬¡æ“ä½œ`
                );
                
                if (confirmed) {
                    // ç”¨æˆ·é€‰æ‹©ç»§ç»­ä½¿ç”¨ç°æœ‰å¯¹è¯ï¼Œç›´æ¥å¼€å§‹èŠå¤©
                    startChat(character);
                    return;
                } else {
                    // ç”¨æˆ·é€‰æ‹©å–æ¶ˆï¼Œä¸è¿›è¡Œä»»ä½•æ“ä½œ
                    return;
                }
            }
            
            // ğŸ”¥ã€æ–°å¢èº«ä»½è®¾ç½®é€»è¾‘ã€‘è§’è‰²ä¸å­˜åœ¨å¯¹è¯ï¼Œåˆ›å»ºæ–°å¯¹è¯å¹¶è®¾ç½®èº«ä»½
            if (personaId) {
                // è·å–æˆ–åˆ›å»ºæ­¤èŠå¤©çš„ä¸“å±è®¾ç½®
                let settings = chatSettings[character.id] || {};
                settings.selectedIdentityId = personaId;
                const selectedPersona = personas.find(p => p.id === personaId);
                if (selectedPersona) {
                    settings.myChatAvatar = selectedPersona.avatarUrl || '';
                    settings.myChatNickname = selectedPersona.name || '';
                    chatSettings[character.id] = settings;
                    await saveCurrentChatSettings(settings);
                }
            }
            
            // æ·»åŠ åˆ°è”ç³»äººåˆ—è¡¨
            console.log('âœ…[ä¿®å¤] å‘ç°æ–°è”ç³»äººï¼Œæ­£åœ¨åŒæ­¥ä¿å­˜...');
            contacts.push(character.id);
            // ä½¿ç”¨ await ç¡®ä¿ä¿å­˜æ“ä½œå®Œæˆåå†ç»§ç»­
            await saveContacts();
            console.log('âœ…[ä¿®å¤] æ–°è”ç³»äººä¿å­˜æˆåŠŸï¼Œå†…å­˜ä¸­çš„ contacts åˆ—è¡¨:', contacts);
            // ä¿å­˜æˆåŠŸåï¼Œç«‹å³åˆ·æ–°ä¸€æ¬¡æ¶ˆæ¯åˆ—è¡¨çš„åå°æ•°æ®
            renderMessageList();
            
            // å¼€å§‹èŠå¤©
            startChat(character);
        }
        
        
        // åˆ‡æ¢ç¾¤èŠæˆå‘˜é€‰æ‹©
        function toggleGroupMemberSelection(characterId) {
            const index = selectedGroupMembers.indexOf(characterId);
            const checkbox = document.getElementById(`checkbox-${characterId}`);
            const memberItem = checkbox.closest('.group-member-item');
            
            if (index > -1) {
                selectedGroupMembers.splice(index, 1);
                checkbox.classList.remove('checked');
                checkbox.innerHTML = '';
                memberItem.classList.remove('selected');
            } else {
                if (selectedGroupMembers.length >= 20) {
                    alert('æœ€å¤šåªèƒ½é€‰æ‹©20ä¸ªæˆå‘˜');
                    return;
                }
                selectedGroupMembers.push(characterId);
                checkbox.classList.add('checked');
                checkbox.innerHTML = '<i class="fas fa-check"></i>';
                memberItem.classList.add('selected');
            }
        }
        
 // --- è¯·ä»è¿™é‡Œå¼€å§‹ï¼Œå®Œæ•´å¤åˆ¶æ‰€æœ‰ä»£ç  ---

// 1. æ˜¾ç¤ºèŠå¤©é€‰é¡¹ï¼ˆå…¥å£å‡½æ•°ï¼Œä¿æŒä¸å˜ï¼‰
        function showGroupChatSelector() {
            hideModal('chat-options-modal');
            showPersonaSelectionForGroupChat();
        }
        
// 2. æ˜¾ç¤ºç¾¤èŠèº«ä»½é€‰æ‹©
        function showPersonaSelectionForGroupChat() {
            const modalHTML = `
                <div class="modal" id="persona-selection-group-modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 class="modal-title">é€‰æ‹©èº«ä»½</h3>
                            <button class="modal-close" onclick="hidePersonaSelectionGroupModal()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p class="selection-description">è¯·é€‰æ‹©ä½ åœ¨è¿™ä¸ªç¾¤èŠä¸­ä½¿ç”¨çš„èº«ä»½é¢å…·</p>
                            <div class="persona-selection-list" id="persona-selection-group-list">
                                ${personas.map(persona => `
                                    <div class="persona-selection-item" data-persona-id="${persona.id}">
                                <div class="persona-selection-avatar" style="${persona.avatarUrl ? `background-image: url('${persona.avatarUrl}'); background-size: cover; background-position: center;` : ''}">
                                            ${persona.avatarUrl ? '' : persona.name.charAt(0)}
                                        </div>
                                        <div class="persona-selection-info">
                                            <div class="persona-selection-name">${persona.name}</div>
                                            <div class="persona-selection-desc">${truncateText(persona.description || 'æš‚æ— æè¿°', 100)}</div>
                                        </div>
                                <div class="persona-selection-check"><i class="fas fa-check"></i></div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-secondary" onclick="hidePersonaSelectionGroupModal()">å–æ¶ˆ</button>
                    <button class="modal-primary" id="confirm-group-persona-btn" disabled>ä¸‹ä¸€æ­¥ï¼šè®¾ç½®ç¾¤èŠ</button>
                        </div>
                    </div>
                </div>
            `;
            
            const existingModal = document.getElementById('persona-selection-group-modal');
    if (existingModal) existingModal.remove();
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            
    let selectedPersonaId = null;

            document.querySelectorAll('#persona-selection-group-modal .persona-selection-item').forEach(item => {
                item.addEventListener('click', function() {
                    document.querySelectorAll('#persona-selection-group-modal .persona-selection-item').forEach(i => i.classList.remove('selected'));
                    this.classList.add('selected');
            selectedPersonaId = this.dataset.personaId;
                    document.getElementById('confirm-group-persona-btn').disabled = false;
                    console.log('âœ… é€‰æ‹©äº†èº«ä»½:', selectedPersonaId, 'èº«ä»½åç§°:', this.querySelector('.persona-selection-name').textContent);
                });
            });

    // å…³é”®ä¿®å¤ï¼šè®©â€œä¸‹ä¸€æ­¥â€æŒ‰é’®çš„ç‚¹å‡»äº‹ä»¶ç›´æ¥è°ƒç”¨ä¸‹ä¸€æ­¥å‡½æ•°ï¼Œå¹¶æŠŠIDä¼ è¿‡å»
    document.getElementById('confirm-group-persona-btn').onclick = () => {
        console.log('âœ… ç‚¹å‡»ä¸‹ä¸€æ­¥æŒ‰é’®ï¼Œå½“å‰selectedPersonaIdå€¼ä¸º:', selectedPersonaId);
        if (selectedPersonaId) {
            console.log('âœ… å‡†å¤‡è°ƒç”¨confirmPersonaAndShowGroupSettingsï¼Œä¼ é€’ID:', selectedPersonaId);
            confirmPersonaAndShowGroupSettings(selectedPersonaId);
        } else {
            console.error('âŒ æœªé€‰æ‹©èº«ä»½å°±ç‚¹å‡»äº†ä¸‹ä¸€æ­¥');
            alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèº«ä»½é¢å…·');
        }
    };
}

// 3. éšè—èº«ä»½é€‰æ‹©æ¨¡æ€æ¡†çš„å‡½æ•°
        function hidePersonaSelectionGroupModal() {
            const modal = document.getElementById('persona-selection-group-modal');
    if (modal) modal.remove();
}

// 4. ç¡®è®¤èº«ä»½å¹¶æ˜¾ç¤ºç¾¤æˆå‘˜é€‰æ‹©
function confirmPersonaAndShowGroupSettings(personaId) {
    console.log('âœ… confirmPersonaAndShowGroupSettingsè¢«è°ƒç”¨ï¼Œæ¥æ”¶åˆ°çš„personaId:', personaId);
            hidePersonaSelectionGroupModal();
    showGroupChatMemberSelection(personaId); // å°†é€‰æ‹©çš„IDä½œä¸ºå‚æ•°ä¼ é€’ç»™ä¸‹ä¸€æ­¥
        }
        
// 5. æ˜¾ç¤ºç¾¤æˆå‘˜é€‰æ‹© (å·²æ¢å¤ç®€ä»‹æ˜¾ç¤º)
function showGroupChatMemberSelection(personaId) {
    console.log('âœ… showGroupChatMemberSelectionè¢«è°ƒç”¨ï¼Œæ¥æ”¶åˆ°çš„personaId:', personaId);
    
    // ç«‹å³å°†personaIdå­˜å‚¨åˆ°å…¨å±€å˜é‡ä¸­ï¼Œç¡®ä¿ä¸ä¼šä¸¢å¤±
    window.currentGroupPersonaId = personaId;
            document.getElementById('group-chat-name').value = '';
            selectedGroupMembers = [];
            
            const membersContainer = document.getElementById('group-chat-members');
            membersContainer.innerHTML = '';
            
            if (characters.length < 2) {
                membersContainer.innerHTML = '<p class="empty-mount-chats">è‡³å°‘éœ€è¦2ä¸ªè§’è‰²æ‰èƒ½åˆ›å»ºç¾¤èŠ</p>';
            } else {
                characters.forEach(character => {
                    const memberItem = document.createElement('div');
                    memberItem.className = 'group-member-item';
                    memberItem.onclick = () => toggleGroupMemberSelection(character.id);
            // å…³é”®ä¿®å¤ï¼šæ¢å¤äº†æ˜¾ç¤ºè§’è‰²ç®€ä»‹çš„HTMLä»£ç 
                    memberItem.innerHTML = `
                <div class="group-member-checkbox" id="checkbox-${character.id}"></div>
                <div class="message-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url('${character.avatarUrl}');` : ''}">
                            ${character.avatarUrl ? '' : character.name.charAt(0)}
                        </div>
                        <div class="chat-option-text">
                            <div class="chat-option-title">${character.name}</div>
                    <div class="chat-option-desc">${truncateText(character.bio || 'æš‚æ— ç®€ä»‹', 80)}</div>
                </div>`;
                    membersContainer.appendChild(memberItem);
                });
            }

    // å…³é”®ä¿®å¤ï¼šå°† personaId ç»‘å®šåˆ°æœ€ç»ˆçš„â€œåˆ›å»ºç¾¤èŠâ€æŒ‰é’®ä¸Š
    console.log('âœ… åœ¨ç¬¬ä¸€ä¸ªä½ç½®ç»‘å®šåˆ›å»ºæŒ‰é’®ï¼ŒpersonaId:', personaId);
    const createBtn = document.getElementById('group-chat-modal').querySelector('.modal-primary');
    createBtn.onclick = () => {
        console.log('âœ… ç¬¬ä¸€ä¸ªä½ç½®çš„åˆ›å»ºç¾¤èŠæŒ‰é’®è¢«ç‚¹å‡»ï¼Œç›´æ¥ä½¿ç”¨å‚æ•°personaId:', personaId);
        createGroupChat(personaId);
    }; // ç»‘å®šå¸¦å‚æ•°çš„åˆ›å»ºå‡½æ•°
            
            showModal('group-chat-modal');
        }
        
// 6. åˆ‡æ¢ç¾¤æˆå‘˜é€‰æ‹©çŠ¶æ€ (æ— ä¿®æ”¹ï¼Œä½†ä¸ºäº†å®Œæ•´æ€§åŒ…å«åœ¨æ­¤)
        function toggleGroupMemberSelection(characterId) {
            const index = selectedGroupMembers.indexOf(characterId);
            const checkbox = document.getElementById(`checkbox-${characterId}`);
            const memberItem = checkbox.closest('.group-member-item');
            
            if (index > -1) {
                selectedGroupMembers.splice(index, 1);
                checkbox.classList.remove('checked');
                checkbox.innerHTML = '';
                memberItem.classList.remove('selected');
            } else {
                if (selectedGroupMembers.length >= 20) {
                    alert('æœ€å¤šåªèƒ½é€‰æ‹©20ä¸ªæˆå‘˜');
                    return;
                }
                selectedGroupMembers.push(characterId);
                checkbox.classList.add('checked');
                checkbox.innerHTML = '<i class="fas fa-check"></i>';
                memberItem.classList.add('selected');
            }
        }
        

// 7. åˆ›å»ºç¾¤èŠï¼ˆæœ€ç»ˆç‰ˆæœ¬ï¼‰
async function createGroupChat(personaId) {
    console.log(`âœ… createGroupChatè¢«è°ƒç”¨ï¼Œèº«ä»½ID: ${personaId}`);

    const groupName = document.getElementById('group-chat-name').value.trim();
    if (!groupName) return alert('è¯·è¾“å…¥ç¾¤èŠåç§°');
    if (selectedGroupMembers.length < 2) return alert('è‡³å°‘éœ€è¦é€‰æ‹©2ä¸ªæˆå‘˜');

    // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘è½¬æ¢ä¸ºzhangyu.htmlæ ¼å¼çš„æ•°æ®ç»“æ„
    const memberDetails = selectedGroupMembers.map(memberId => {
        const character = characters.find(c => c.id === memberId);
        return {
            id: character.id,
            name: character.name,
            persona: character.bio,  // ğŸ”¥ã€å…³é”®ã€‘ä½¿ç”¨personaå­—æ®µè€Œä¸æ˜¯bio
            avatarUrl: character.avatarUrl,
            color: character.color
        };
    });

    // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘æ„å»ºzhangyu.htmlå…¼å®¹çš„ç¾¤èŠå¯¹è±¡
    const groupChat = {
        id: 'group_' + Date.now().toString(),
        name: groupName,
        members: memberDetails,
        isGroup: true,
        createdAt: new Date().toISOString(),
        // ğŸ”¥ã€æ–°å¢ã€‘æ·»åŠ zhangyu.htmlé£æ ¼çš„è®¾ç½®ç»“æ„
        settings: {
            myPersona: '', // å°†åœ¨ä¸‹é¢è®¾ç½®
            myNickname: 'æˆ‘' // é»˜è®¤æ˜µç§°
        }
    };

    // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘ä¿å­˜ç”¨æˆ·èº«ä»½è®¾ç½®ï¼ŒåŒæ—¶å…¼å®¹ä¸¤ç§æ ¼å¼
    if (personaId) {
        const selectedPersona = personas.find(p => p.id === personaId);
        if (selectedPersona) {
            // è®¾ç½®ç¾¤èŠå†…éƒ¨çš„ç”¨æˆ·äººè®¾ï¼ˆzhangyu.htmlæ ¼å¼ï¼‰
            groupChat.settings.myPersona = selectedPersona.description || selectedPersona.name;
            groupChat.settings.myNickname = selectedPersona.name;

            // åŒæ—¶ä¿æŒåŸæœ‰çš„chatSettingsæ ¼å¼ï¼ˆindex.htmlå…¼å®¹æ€§ï¼‰
            const chatSettings = {
                selectedIdentityId: personaId,
                myChatAvatar: selectedPersona.avatarUrl,
                myChatNickname: selectedPersona.name,
                selectedPersonaData: { ...selectedPersona },
                // ğŸ”¥ã€æ–°å¢ã€‘æ·»åŠ zhangyu.htmlå…¼å®¹å­—æ®µ
                myPersona: selectedPersona.description || selectedPersona.name
            };

            // ç¡®ä¿ window.chatSettings å·²åˆå§‹åŒ–
            if (!window.chatSettings) {
                window.chatSettings = {};
            }
            window.chatSettings[groupChat.id] = chatSettings;
            await db.chatSettings.put({ id: groupChat.id, chatId: groupChat.id, settings: chatSettings });
            console.log('âœ… ç¾¤èŠèº«ä»½è®¾ç½®å·²æˆåŠŸä¿å­˜ï¼ˆåŒæ ¼å¼å…¼å®¹ï¼‰');
        } else {
            console.error('âŒ åˆ›å»ºç¾¤èŠæ—¶æœªæ‰¾åˆ°IDä¸º ' + personaId + ' çš„èº«ä»½ã€‚');
        }
    }

    if (!groupChats) groupChats = [];
    groupChats.push(groupChat);
    await saveGroupChats();
    hideModal('group-chat-modal');
    renderMessageList();
    alert(`ç¾¤èŠ"${groupName}"åˆ›å»ºæˆåŠŸï¼`);
}

// --- è¯·å¤åˆ¶åˆ°è¿™é‡Œç»“æŸ ---
        
        // ä¿å­˜ç¾¤èŠæ•°æ® - ä½¿ç”¨IndexedDB
        async function saveGroupChats() {
            try {
                console.log('ä¿å­˜ç¾¤èŠæ•°æ®åˆ°IndexedDB:', groupChats);
                
                // æ£€æŸ¥æ•°æ®å®Œæ•´æ€§
                if (!groupChats || !Array.isArray(groupChats)) {
                    console.error('ç¾¤èŠæ•°æ®æ— æ•ˆ:', groupChats);
                    groupChats = [];
                }
                
                // éªŒè¯æ¯ä¸ªç¾¤èŠå¯¹è±¡çš„å®Œæ•´æ€§
                const validGroupChats = groupChats.filter(chat => {
                    if (!chat || !chat.id || !chat.name) {
                        console.warn('å‘ç°æ— æ•ˆçš„ç¾¤èŠå¯¹è±¡:', chat);
                        return false;
                    }
                    return true;
                });
                
                // å¦‚æœæœ‰æ— æ•ˆæ•°æ®ï¼Œæ›´æ–°æ•°ç»„
                if (validGroupChats.length !== groupChats.length) {
                    groupChats = validGroupChats;
                    console.log('å·²è¿‡æ»¤æ— æ•ˆæ•°æ®ï¼Œæœ‰æ•ˆç¾¤èŠæ•°é‡:', groupChats.length);
                }
                
                // ä½¿ç”¨äº‹åŠ¡æ¥ç¡®ä¿æ•°æ®ä¸€è‡´æ€§
                await db.transaction('rw', db.groupChats, async () => {
                // æ¸…ç©ºç°æœ‰æ•°æ®
                await db.groupChats.clear();
                
                    // é€ä¸ªæ’å…¥æ•°æ®ä»¥é¿å…æ‰¹é‡æ’å…¥çš„IDå†²çªé—®é¢˜
                    for (const chat of groupChats) {
                        try {
                            await db.groupChats.add(chat);
                        } catch (addError) {
                            console.warn('æ’å…¥ç¾¤èŠå¤±è´¥ï¼Œå°è¯•æ›´æ–°:', chat.id, addError);
                            // å¦‚æœæ·»åŠ å¤±è´¥ï¼Œå°è¯•æ›´æ–°
                            await db.groupChats.put(chat);
                        }
                    }
                });
                
                console.log('ç¾¤èŠæ•°æ®ä¿å­˜æˆåŠŸåˆ°IndexedDB');

                // ğŸ”¥ã€ä¼˜åŒ–ã€‘æ™ºèƒ½localStorageå¤‡ä»½ç­–ç•¥ - åªåœ¨æ•°æ®é‡å°æ—¶å¤‡ä»½
                try {
                    const dataSize = JSON.stringify(groupChats).length;
                    const maxLocalStorageSize = 1024 * 1024; // 1MBé™åˆ¶ï¼Œä¸ºå…¶ä»–æ•°æ®ç•™ç©ºé—´

                    if (dataSize < maxLocalStorageSize) {
                        localStorage.setItem('groupChats', JSON.stringify(groupChats));
                        console.log(`ç¾¤èŠæ•°æ®å¤‡ä»½åˆ°localStorageæˆåŠŸ (${(dataSize/1024).toFixed(1)}KB)`);
                    } else {
                        // æ•°æ®å¤ªå¤§ï¼Œç§»é™¤localStorageå¤‡ä»½
                        localStorage.removeItem('groupChats');
                        console.log(`ç¾¤èŠæ•°æ®è¿‡å¤§ (${(dataSize/1024/1024).toFixed(1)}MB)ï¼Œè·³è¿‡localStorageå¤‡ä»½ï¼Œä»…ä½¿ç”¨IndexedDB`);
                    }
                } catch (storageError) {
                    console.warn('localStorageå¤‡ä»½å¤±è´¥:', storageError);
                    // å¦‚æœæ˜¯å®¹é‡ä¸è¶³ï¼Œæ¸…ç†localStorageå¤‡ä»½
                    if (storageError.name === 'QuotaExceededError') {
                        try {
                            localStorage.removeItem('groupChats');
                            console.log('localStorageå®¹é‡ä¸è¶³ï¼Œå·²æ¸…ç†ç¾¤èŠå¤‡ä»½');
                        } catch (e) {
                            console.warn('æ¸…ç†localStorageå¤±è´¥:', e);
                        }
                    }
                }
                
            } catch (error) {
                console.error('ä¿å­˜ç¾¤èŠåˆ°IndexedDBå¤±è´¥:', error);
                console.error('é”™è¯¯è¯¦æƒ…:', error.name, error.message);
                
                // å¦‚æœIndexedDBå¤±è´¥ï¼Œå›é€€åˆ°localStorage
                try {
                    localStorage.setItem('groupChats', JSON.stringify(groupChats || []));
                    console.log('ç¾¤èŠæ•°æ®å›é€€ä¿å­˜åˆ°localStorageæˆåŠŸ');
                    showToast('ç¾¤èŠå·²ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨', 'info');
                } catch (localError) {
                    console.error('localStorageä¿å­˜ä¹Ÿå¤±è´¥:', localError);
                    console.error('localStorageé”™è¯¯è¯¦æƒ…:', localError.name, localError.message);
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯å­˜å‚¨ç©ºé—´ä¸è¶³
                    if (localError.name === 'QuotaExceededError') {
                        alert('å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œè¯·æ¸…ç†ä¸€äº›æ•°æ®åé‡è¯•');
                    } else {
                        alert('ä¿å­˜ç¾¤èŠå¤±è´¥ï¼Œè¯·å°è¯•åˆ·æ–°é¡µé¢é‡æ–°æ“ä½œ');
                    }
                    
                    // æ¢å¤åˆ°ä¹‹å‰çš„çŠ¶æ€
                    groupChats.pop(); // ç§»é™¤åˆšæ·»åŠ çš„ç¾¤èŠ
                    throw localError;
                }
            }
        }
        
        // æ¸²æŸ“å®šæ—¶å‘å¸ƒæ—¶é—´ç‚¹
        function renderScheduleTimes() {
            const container = document.getElementById('schedule-times-container');
            if (!container) return;
            
            const chatSettings = getCurrentChatSettings();
            const scheduleTimes = chatSettings.scheduleTimes || [];
            
            container.innerHTML = '';
            
            scheduleTimes.forEach((time, index) => {
                const timeItem = document.createElement('div');
                timeItem.className = 'schedule-time-item';
                timeItem.innerHTML = `
                    <input type="time" value="${time}" onchange="updateScheduleTime(${index}, this.value)">
                    <button onclick="removeScheduleTime(${index})">Ã—</button>
                `;
                container.appendChild(timeItem);
            });
        }
        
        // æ·»åŠ å®šæ—¶å‘å¸ƒæ—¶é—´ç‚¹
        async function addScheduleTime() {
            const chatSettings = getCurrentChatSettings();
            if (!chatSettings.scheduleTimes) {
                chatSettings.scheduleTimes = [];
            }
            
            if (chatSettings.scheduleTimes.length >= 10) {
                alert('æœ€å¤šåªèƒ½è®¾ç½®10ä¸ªæ—¶é—´ç‚¹');
                return;
            }
            
            chatSettings.scheduleTimes.push('09:00');
            await saveCurrentChatSettings(chatSettings);
            renderScheduleTimes();
        }
        
        // æ›´æ–°å®šæ—¶å‘å¸ƒæ—¶é—´ç‚¹
        async function updateScheduleTime(index, newTime) {
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.scheduleTimes && chatSettings.scheduleTimes[index] !== undefined) {
                chatSettings.scheduleTimes[index] = newTime;
                await saveCurrentChatSettings(chatSettings);
            }
        }
        
        // ç§»é™¤å®šæ—¶å‘å¸ƒæ—¶é—´ç‚¹
        async function removeScheduleTime(index) {
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.scheduleTimes && chatSettings.scheduleTimes[index] !== undefined) {
                chatSettings.scheduleTimes.splice(index, 1);
                await saveCurrentChatSettings(chatSettings);
                renderScheduleTimes();
            }
        }
        
        // ä¿å­˜å®šæ—¶å‘å¸ƒè®¾ç½®
        async function saveScheduleSettings() {
            const chatSettings = getCurrentChatSettings();
            chatSettings.scheduleEnabled = document.getElementById('schedule-enabled').checked;
            
            await saveCurrentChatSettings(chatSettings);
            hideModal('schedule-settings-modal');
            showToast('å®šæ—¶å‘å¸ƒè®¾ç½®å·²ä¿å­˜', 'success');
        }
        
        // æ˜¾ç¤ºä¸–ç•Œä¹¦æŒ‚è½½è®¾ç½®
        function showWorldbookMountSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // åŠ è½½å½“å‰è®¾ç½®
            document.getElementById('worldbook-mount-enabled').checked = chatSettings.worldbookMountEnabled || false;
            
            // æ§åˆ¶è¯¦ç»†è®¾ç½®çš„æ˜¾ç¤º
            toggleWorldbookMountDetails();
            
            // ç»‘å®šäº‹ä»¶
            document.getElementById('worldbook-mount-enabled').onchange = toggleWorldbookMountDetails;
            
            // æ¸²æŸ“ä¸–ç•Œä¹¦åˆ—è¡¨
            renderWorldbookMountList();
            
            showModal('worldbook-mount-modal');
        }
        
        // åˆ‡æ¢ä¸–ç•Œä¹¦æŒ‚è½½è¯¦ç»†è®¾ç½®æ˜¾ç¤º
        function toggleWorldbookMountDetails() {
            const enabled = document.getElementById('worldbook-mount-enabled').checked;
            document.getElementById('worldbook-mount-details').style.display = enabled ? 'block' : 'none';
            
            // æ›´æ–°ä¸»è®¾ç½®ç•Œé¢æ˜¾ç¤º
            updateWorldbookMountDisplay();
        }
        
        // æ›´æ–°ä¸–ç•Œä¹¦æŒ‚è½½æ˜¾ç¤ºçŠ¶æ€
        function updateWorldbookMountDisplay() {
            // å¦‚æœæ²¡æœ‰å½“å‰èŠå¤©è§’è‰²ï¼Œè·³è¿‡
            if (!currentChatCharacter) {
                console.log("æ›´æ–°ä¸–ç•Œä¹¦æŒ‚è½½æ˜¾ç¤ºï¼šæ— å½“å‰èŠå¤©è§’è‰²ï¼Œè·³è¿‡æ“ä½œ");
                return;
            }
            
            const chatSettings = getCurrentChatSettings();
            const displayElement = document.getElementById('current-worldbook-mount');
            
            if (!displayElement) {
                console.log("æ›´æ–°ä¸–ç•Œä¹¦æŒ‚è½½æ˜¾ç¤ºï¼šæ— æ˜¾ç¤ºå…ƒç´ ï¼Œè·³è¿‡æ“ä½œ");
                return;
            }
            
            if (!chatSettings.worldbookMountEnabled) {
                displayElement.textContent = 'æœªæŒ‚è½½';
                return;
            }
            
            const selectedWorldbooks = chatSettings.selectedWorldbooks || [];
            if (selectedWorldbooks.length === 0) {
                displayElement.textContent = 'å·²å¯ç”¨ä½†æœªé€‰æ‹©';
            } else if (selectedWorldbooks.length === 1) {
                const worldbook = worldbooks.find(w => w.id === selectedWorldbooks[0]);
                displayElement.textContent = worldbook ? `å·²æŒ‚è½½: ${worldbook.title}` : 'å·²æŒ‚è½½: 1ä¸ª';
            } else {
                displayElement.textContent = `å·²æŒ‚è½½: ${selectedWorldbooks.length}ä¸ª`;
            }
        }
        
        // æ¸²æŸ“ä¸–ç•Œä¹¦æŒ‚è½½åˆ—è¡¨
        function renderWorldbookMountList() {
            const container = document.getElementById('worldbook-mount-list');
            container.innerHTML = '';
            
            // è¿‡æ»¤æ‰å…¨å±€ä¸–ç•Œä¹¦ï¼Œåªæ˜¾ç¤ºå±€éƒ¨ä¸–ç•Œä¹¦
            const localWorldbooks = worldbooks.filter(w => !w.isGlobal);
            
            if (localWorldbooks.length === 0) {
                container.innerHTML = '<p class="empty-mount-chats">æš‚æ— å±€éƒ¨ä¸–ç•Œä¹¦ï¼Œè¯·å…ˆåœ¨ä¸–ç•Œä¹¦åº”ç”¨ä¸­åˆ›å»º</p>';
                return;
            }
            
            const chatSettings = getCurrentChatSettings();
            const selectedWorldbooks = chatSettings.selectedWorldbooks || [];
            
            localWorldbooks.forEach(worldbook => {
                const item = document.createElement('div');
                item.className = 'mount-item worldbook-mount-item';
                
                const isSelected = selectedWorldbooks.includes(worldbook.id);
                
                item.innerHTML = `
                    <input type="checkbox" id="worldbook-${worldbook.id}" value="${worldbook.id}" ${isSelected ? 'checked' : ''} class="worldbook-checkbox">
                    <div class="worldbook-content-flex">
                        <div class="worldbook-title-text">
                            ${worldbook.title}
                        </div>
                        <div class="worldbook-desc-text">
                            ${worldbook.content.length > 100 ? worldbook.content.substring(0, 100) + '...' : worldbook.content}
                        </div>
                        <div class="worldbook-date-text">
                            åˆ›å»ºäº: ${new Date(worldbook.createdAt).toLocaleDateString('zh-CN')} | 
                            å­—æ•°: ${worldbook.content.length}
                        </div>
                    </div>
                `;
                
                // ç‚¹å‡»æ•´ä¸ªæ¡ç›®ä¹Ÿèƒ½åˆ‡æ¢é€‰æ‹©çŠ¶æ€
                item.onclick = (e) => {
                    if (e.target.type !== 'checkbox') {
                        const checkbox = item.querySelector('input[type="checkbox"]');
                        checkbox.checked = !checkbox.checked;
                    }
                };
                
                container.appendChild(item);
            });
            
            // æ·»åŠ æç¤ºè¯´æ˜å…¨å±€ä¸–ç•Œä¹¦è‡ªåŠ¨åº”ç”¨
            const globalInfo = document.createElement('div');
            globalInfo.className = 'worldbook-global-info';
            globalInfo.innerHTML = '<p class="global-worldbook-note">æ³¨æ„ï¼šå…¨å±€ä¸–ç•Œä¹¦å·²è‡ªåŠ¨åº”ç”¨äºæ‰€æœ‰èŠå¤©ï¼Œæ— éœ€æ‰‹åŠ¨æŒ‚è½½ã€‚</p>';
            container.appendChild(globalInfo);
        }
        
        // ä¿å­˜ä¸–ç•Œä¹¦æŒ‚è½½è®¾ç½®
        function saveWorldbookMountSettings() {
            const chatSettings = getCurrentChatSettings();
            
            chatSettings.worldbookMountEnabled = document.getElementById('worldbook-mount-enabled').checked;
            
            // è·å–é€‰ä¸­çš„ä¸–ç•Œä¹¦
            const checkboxes = document.querySelectorAll('#worldbook-mount-list input[type="checkbox"]:checked');
            chatSettings.selectedWorldbooks = Array.from(checkboxes).map(cb => cb.value);
            
            saveCurrentChatSettings(chatSettings);
            updateWorldbookMountDisplay();
            hideModal('worldbook-mount-modal');
            
            const selectedCount = chatSettings.selectedWorldbooks ? chatSettings.selectedWorldbooks.length : 0;
            if (chatSettings.worldbookMountEnabled && selectedCount > 0) {
                showToast(`ä¸–ç•Œä¹¦æŒ‚è½½è®¾ç½®å·²ä¿å­˜ï¼Œå·²æŒ‚è½½ ${selectedCount} ä¸ªä¸–ç•Œä¹¦`, 'success');
            } else if (chatSettings.worldbookMountEnabled) {
                showToast('ä¸–ç•Œä¹¦æŒ‚è½½å·²å¯ç”¨ï¼Œä½†æœªé€‰æ‹©ä»»ä½•ä¸–ç•Œä¹¦', 'info');
            } else {
                showToast('ä¸–ç•Œä¹¦æŒ‚è½½å·²å…³é—­', 'info');
            }
        }
        
        // èº«ä»½é€‰æ‹©å™¨åŠŸèƒ½å·²ç§»é™¤ï¼Œèº«ä»½åœ¨åˆ›å»ºå¯¹è¯æ—¶é€‰æ‹©
        
        // å‹ç¼©å›¾ç‰‡ä»¥å‡å°‘å­˜å‚¨ç©ºé—´
        function compressImage(dataUrl, maxWidth = 300, quality = 0.8) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // è®¡ç®—æ–°çš„å°ºå¯¸ï¼Œä¿æŒå®½é«˜æ¯”
                    let { width, height } = img;
                    if (width > height) {
                        if (width > maxWidth) {
                            height = (height * maxWidth) / width;
                            width = maxWidth;
                        }
                    } else {
                        if (height > maxWidth) {
                            width = (width * maxWidth) / height;
                            height = maxWidth;
                        }
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    // ç»˜åˆ¶å¹¶å‹ç¼©
                    ctx.drawImage(img, 0, 0, width, height);
                    const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                    
                    console.log(`å›¾ç‰‡å‹ç¼©ï¼š${Math.round(dataUrl.length/1024)}KB -> ${Math.round(compressedDataUrl.length/1024)}KB`);
                    resolve(compressedDataUrl);
                };
                img.src = dataUrl;
            });
        }
        

        
        // ğŸ”¥ã€ç´§æ€¥ä¿®å¤ã€‘æ¢å¤è®¾ç½®å¹¶åˆ·æ–°ç•Œé¢
        function recoverAndRefreshSettings() {
            if (!currentChatCharacter) {
                showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠå¤©çª—å£', 'warning');
                return;
            }
            
            const chatId = currentChatCharacter.id;
            console.log(`å¼€å§‹æ¢å¤èŠå¤©è®¾ç½®: ${chatId}`);
            console.log('å½“å‰è®¾ç½®çŠ¶æ€:', JSON.stringify(chatSettings[chatId], null, 2));
            
            // æ˜¾ç¤ºæ¢å¤è¿›åº¦
            showToast('æ­£åœ¨å°è¯•æ¢å¤è®¾ç½®...', 'info');
            
            // ğŸ”¥ã€ç›´æ¥æ¢å¤æ–¹æ³•ã€‘å¼ºåˆ¶ä»localStorageæ¢å¤ï¼Œä¸é€šè¿‡getCurrentChatSettings
            const savedLocalStorage = localStorage.getItem(`chatSettings_${chatId}`);
            if (savedLocalStorage) {
                try {
                    const recoveredSettings = JSON.parse(savedLocalStorage);
                    console.log('ä»localStorageæ¢å¤çš„è®¾ç½®:', JSON.stringify(recoveredSettings, null, 2));
                    
                    // ç›´æ¥è¦†ç›–å…¨å±€è®¾ç½®
                    chatSettings[chatId] = recoveredSettings;
                    
                    // ç«‹å³åˆ·æ–°å½“å‰ç•Œé¢çš„æ˜¾ç¤ºï¼ˆå¦‚æœåœ¨è®¾ç½®ç•Œé¢ï¼‰
                    if (document.getElementById('api-chat-settings-screen').style.display !== 'none') {
                        updateChatSettingsDisplay();
                    }
                    
                    // åˆ·æ–°èŠå¤©æ¶ˆæ¯ç•Œé¢
                    if (currentChatCharacter) {
                        renderChatMessages(currentChatCharacter.id);
                    }
                    
                    showToast('è®¾ç½®æ¢å¤æˆåŠŸï¼', 'success');
                    console.log('è®¾ç½®æ¢å¤å®Œæˆï¼Œå½“å‰è®¾ç½®:', JSON.stringify(chatSettings[chatId], null, 2));
                    return;
                } catch (error) {
                    console.error('è§£ælocalStorageè®¾ç½®å¤±è´¥:', error);
                }
            }
            
            // å¦‚æœlocalStorageå¤±è´¥ï¼Œå°è¯•ä»IndexedDBæ¢å¤
            db.chatSettings.get(chatId).then(dbSettings => {
                if (dbSettings && dbSettings.settings) {
                    console.log('ä»IndexedDBæ¢å¤çš„è®¾ç½®:', JSON.stringify(dbSettings.settings, null, 2));
                    
                    // ç›´æ¥è¦†ç›–å…¨å±€è®¾ç½®
                    chatSettings[chatId] = dbSettings.settings;
                    
                    // åŒæ­¥åˆ°localStorage
                    localStorage.setItem(`chatSettings_${chatId}`, JSON.stringify(dbSettings.settings));
                    
                    // ç«‹å³åˆ·æ–°ç•Œé¢
                    if (document.getElementById('api-chat-settings-screen').style.display !== 'none') {
                        updateChatSettingsDisplay();
                    }
                    
                    if (currentChatCharacter) {
                        renderChatMessages(currentChatCharacter.id);
                    }
                    
                    showToast('ä»å¤‡ä»½æ•°æ®æ¢å¤è®¾ç½®æˆåŠŸï¼', 'success');
                    console.log('ä»IndexedDBæ¢å¤è®¾ç½®æˆåŠŸ:', JSON.stringify(dbSettings.settings, null, 2));
                } else {
                    showToast('æœªæ‰¾åˆ°å¤‡ä»½æ•°æ®ï¼Œè®¾ç½®å¯èƒ½å·²æ°¸ä¹…ä¸¢å¤±', 'error');
                    console.log('æœªæ‰¾åˆ°ä»»ä½•å¤‡ä»½æ•°æ®');
                }
            }).catch(error => {
                console.error('ä»IndexedDBæ¢å¤è®¾ç½®å¤±è´¥:', error);
                showToast('æ¢å¤è®¾ç½®å¤±è´¥ï¼Œè¯·è”ç³»æŠ€æœ¯æ”¯æŒ', 'error');
            });
        }
        
        // ğŸ”¥ã€ç´§æ€¥ä¿®å¤ã€‘å°è¯•æ¢å¤è¢«è¦†ç›–çš„èŠå¤©è®¾ç½®
        function recoverChatSettings() {
            if (!currentChatCharacter) return false;
            
            const chatId = currentChatCharacter.id;
            console.log('å°è¯•æ¢å¤èŠå¤©è®¾ç½®...');
            
            // å°è¯•ä»localStorageæ¢å¤
            const savedSettings = localStorage.getItem(`chatSettings_${chatId}`);
            if (savedSettings) {
                try {
                    const userSettings = JSON.parse(savedSettings);
                    chatSettings[chatId] = userSettings;
                    console.log('ä»localStorageæ¢å¤èŠå¤©è®¾ç½®æˆåŠŸ:', userSettings);
                    return true;
                } catch (error) {
                    console.error('ä»localStorageæ¢å¤è®¾ç½®å¤±è´¥:', error);
                }
            }
            
            // å°è¯•ä»IndexedDBæ¢å¤
            db.chatSettings.get(chatId).then(dbSettings => {
                if (dbSettings && dbSettings.settings) {
                    chatSettings[chatId] = dbSettings.settings;
                    console.log('ä»IndexedDBæ¢å¤èŠå¤©è®¾ç½®æˆåŠŸ:', dbSettings.settings);
                    // åŒæ­¥åˆ°localStorage
                    localStorage.setItem(`chatSettings_${chatId}`, JSON.stringify(dbSettings.settings));
                    return true;
                }
            }).catch(error => {
                console.error('ä»IndexedDBæ¢å¤è®¾ç½®å¤±è´¥:', error);
            });
            
            return false;
        }
        
        // å¼ºåˆ¶åˆ·æ–°æ‰€æœ‰å¤´åƒæ˜¾ç¤º
        function forceRefreshAvatars() {
            const chatSettings = getCurrentChatSettings();
            const currentAvatar = chatSettings.aiDynamicAvatar || chatSettings.aiChatAvatar || currentChatCharacter.avatarUrl;
            
            console.log('å¼ºåˆ¶åˆ·æ–°å¤´åƒæ˜¾ç¤ºï¼Œå½“å‰å¤´åƒ:', currentAvatar ? currentAvatar.substring(0, 50) + '...' : 'æ— å¤´åƒ');
            
            // åˆ·æ–°èŠå¤©ç•Œé¢ä¸­æ‰€æœ‰è§’è‰²å¤´åƒ
            const messageAvatars = document.querySelectorAll('.message-avatar');
            messageAvatars.forEach(avatar => {
                // æ£€æŸ¥æ˜¯å¦æ˜¯å½“å‰è§’è‰²çš„å¤´åƒï¼ˆé€šè¿‡ç‚¹å‡»äº‹ä»¶åˆ¤æ–­ï¼‰
                const onclickAttr = avatar.getAttribute('onclick');
                if (onclickAttr && onclickAttr.includes(`'${currentChatCharacter.id}'`)) {
                    if (currentAvatar && currentAvatar !== 'undefined') {
                        avatar.style.backgroundImage = `url(${currentAvatar})`;
                        avatar.style.backgroundSize = 'cover';
                        avatar.style.backgroundPosition = 'center';
                        avatar.innerHTML = '';
                    } else {
                        avatar.style.backgroundImage = 'none';
                        avatar.innerHTML = currentChatCharacter.name.charAt(0);
                    }
                }
            });
            
            // å¦‚æœå½“å‰åœ¨å¤´åƒè®¾ç½®ç•Œé¢ï¼Œä¹Ÿåˆ·æ–°é¢„è§ˆ
            const aiAvatarPreview = document.getElementById('ai-chat-avatar-preview');
            if (aiAvatarPreview && currentAvatar && currentAvatar !== 'undefined') {
                aiAvatarPreview.style.backgroundImage = `url(${currentAvatar})`;
                aiAvatarPreview.style.backgroundSize = 'cover';
                aiAvatarPreview.style.backgroundPosition = 'center';
                aiAvatarPreview.innerHTML = '';
                
                // æ›´æ–°æç¤ºä¿¡æ¯
                if (chatSettings.aiDynamicAvatar) {
                    aiAvatarPreview.title = 'å½“å‰æ˜¾ç¤ºåŠ¨æ€å¤´åƒï¼ˆè§’è‰²åœ¨èŠå¤©ä¸­æ›´æ¢çš„ï¼‰';
                } else {
                    aiAvatarPreview.title = 'å½“å‰æ˜¾ç¤ºèŠå¤©è®¾ç½®å¤´åƒ';
                }
            }
        }
        
        // ğŸ“Š è®¡ç®—å­˜å‚¨ç©ºé—´ä½¿ç”¨æƒ…å†µ
        async function calculateStorageUsage() {
            try {
                let chatSize = 0;
                let characterSize = 0;
                let settingsSize = 0;
                let emojiSize = 0;

                // è®¡ç®—èŠå¤©è®°å½•å¤§å°
                const chatMessagesData = await db.chatMessages.toArray();
                chatSize = JSON.stringify(chatMessagesData).length;

                // è®¡ç®—è§’è‰²æ•°æ®å¤§å°
                const charactersData = await db.characters.toArray();
                characterSize = JSON.stringify(charactersData).length;

                // è®¡ç®—èŠå¤©è®¾ç½®å¤§å°
                const chatSettingsData = await db.chatSettings.toArray();
                settingsSize = JSON.stringify(chatSettingsData).length;

                // è®¡ç®—è¡¨æƒ…åŒ…å¤§å°
                const emojisData = await db.customEmojis.toArray();
                emojiSize = JSON.stringify(emojisData).length;

                const total = chatSize + characterSize + settingsSize + emojiSize;

                // æ›´æ–°æ˜¾ç¤º
                document.getElementById('chat-storage-size').textContent = formatBytes(chatSize);
                document.getElementById('character-storage-size').textContent = formatBytes(characterSize);
                document.getElementById('settings-storage-size').textContent = formatBytes(settingsSize);
                document.getElementById('emoji-storage-size').textContent = formatBytes(emojiSize);
                document.getElementById('total-storage-size').textContent = formatBytes(total);

                return { chatSize, characterSize, settingsSize, emojiSize, total };
            } catch (error) {
                console.error('è®¡ç®—å­˜å‚¨ä½¿ç”¨æƒ…å†µå¤±è´¥:', error);
                return null;
            }
        }

        // æ ¼å¼åŒ–å­—èŠ‚æ•°ä¸ºå¯è¯»æ ¼å¼
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // ğŸ§¹ å‹ç¼©æ‰€æœ‰å›¾ç‰‡
        async function compressAllImages() {
            if (!confirm('å°†å‹ç¼©æ‰€æœ‰å¤´åƒå’ŒèƒŒæ™¯å›¾ç‰‡ï¼Œè¿™å¯èƒ½éœ€è¦ä¸€äº›æ—¶é—´ã€‚ç¡®å®šç»§ç»­å—ï¼Ÿ')) {
                return;
            }

            showToast('æ­£åœ¨å‹ç¼©å›¾ç‰‡...', 'info');
            let compressedCount = 0;

            try {
                // å‹ç¼©è§’è‰²å¤´åƒ
                for (const character of characters) {
                    if (character.avatarUrl && character.avatarUrl.length > 50000) {
                        character.avatarUrl = await compressImage(character.avatarUrl, 150, 0.6);
                        compressedCount++;
                    }
                }
                await saveCharacters();

                // å‹ç¼©èŠå¤©è®¾ç½®ä¸­çš„å¤´åƒ
                for (const chatId of Object.keys(chatSettings)) {
                    const settings = chatSettings[chatId];
                    if (settings) {
                        if (settings.aiChatAvatar && settings.aiChatAvatar.length > 50000) {
                            settings.aiChatAvatar = await compressImage(settings.aiChatAvatar, 150, 0.6);
                            compressedCount++;
                        }
                        if (settings.myChatAvatar && settings.myChatAvatar.length > 50000) {
                            settings.myChatAvatar = await compressImage(settings.myChatAvatar, 150, 0.6);
                            compressedCount++;
                        }
                        if (settings.chatBackground && settings.chatBackground.length > 100000) {
                            settings.chatBackground = await compressImage(settings.chatBackground, 800, 0.7);
                            compressedCount++;
                        }
                    }
                }
                await saveChatSettings();

                // æ›´æ–°å­˜å‚¨ä½¿ç”¨æƒ…å†µ
                calculateStorageUsage();

                showToast(`å›¾ç‰‡å‹ç¼©å®Œæˆï¼å…±å¤„ç†äº† ${compressedCount} å¼ å›¾ç‰‡`, 'success');
            } catch (error) {
                console.error('å‹ç¼©å›¾ç‰‡å¤±è´¥:', error);
                showToast('å‹ç¼©è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯', 'error');
            }
        }

        // ğŸ§¹ æ—§ç‰ˆæ¸…ç†å­˜å‚¨ç©ºé—´ï¼ˆä¿ç•™å…¼å®¹æ€§ï¼‰
        async function cleanupStorageSpace() {
            if (!confirm('å°†æ¸…ç†ä»¥ä¸‹æ•°æ®ä»¥é‡Šæ”¾å­˜å‚¨ç©ºé—´ï¼š\n\nâ€¢ æ‰€æœ‰è§’è‰²çš„åŠ¨æ€å¤´åƒ\nâ€¢ localStorageä¸­çš„è¿‡æœŸæ•°æ®\nâ€¢ å‹ç¼©ç°æœ‰å¤´åƒæ•°æ®\n\nç¡®å®šè¦ç»§ç»­å—ï¼Ÿ')) {
                return;
            }
            
            showToast('æ­£åœ¨æ¸…ç†å­˜å‚¨ç©ºé—´...', 'info');
            let cleanedSize = 0;
            let cleanedItems = 0;
            
            try {
                // 1. æ¸…é™¤æ‰€æœ‰åŠ¨æ€å¤´åƒ
                Object.keys(chatSettings).forEach(chatId => {
                    if (chatSettings[chatId] && chatSettings[chatId].aiDynamicAvatar) {
                        delete chatSettings[chatId].aiDynamicAvatar;
                        cleanedItems++;
                    }
                });
                
                // 2. æ¸…ç†localStorageä¸­çš„è¿‡æœŸchatSettings
                for (let i = localStorage.length - 1; i >= 0; i--) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('chatSettings_')) {
                        const value = localStorage.getItem(key);
                        if (value) {
                            cleanedSize += value.length;
                            localStorage.removeItem(key);
                            cleanedItems++;
                        }
                    }
                }
                
                // 3. å‹ç¼©æ‰€æœ‰ç°æœ‰å¤´åƒæ•°æ®
                for (const chatId of Object.keys(chatSettings)) {
                    const settings = chatSettings[chatId];
                    if (settings) {
                        if (settings.aiChatAvatar && settings.aiChatAvatar.length > 50000) {
                            settings.aiChatAvatar = await compressImage(settings.aiChatAvatar, 150, 0.6);
                            cleanedItems++;
                        }
                        if (settings.myChatAvatar && settings.myChatAvatar.length > 50000) {
                            settings.myChatAvatar = await compressImage(settings.myChatAvatar, 150, 0.6);
                            cleanedItems++;
                        }
                    }
                }
                
                // 4. é‡æ–°ä¿å­˜å‹ç¼©åçš„è®¾ç½®åˆ°IndexedDB
                await saveChatSettings();
                
                // 5. åˆ·æ–°å½“å‰ç•Œé¢
                if (currentChatCharacter) {
                    renderChatMessages(currentChatCharacter.id);
                }
                
                const sizeKB = Math.round(cleanedSize / 1024);
                showToast(`æ¸…ç†å®Œæˆï¼é‡Šæ”¾äº†çº¦ ${sizeKB}KB ç©ºé—´ï¼Œå¤„ç†äº† ${cleanedItems} é¡¹æ•°æ®`, 'success');
                
            } catch (error) {
                console.error('æ¸…ç†å­˜å‚¨ç©ºé—´å¤±è´¥:', error);
                showToast('æ¸…ç†è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ï¼Œè¯·é‡è¯•', 'error');
            }
        }
        
        // æ¸…é™¤AIåŠ¨æ€å¤´åƒ
        function clearAiDynamicAvatar() {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.aiDynamicAvatar) {
                delete chatSettings.aiDynamicAvatar;
                saveCurrentChatSettings(chatSettings);
                
                // åˆ·æ–°èŠå¤©ç•Œé¢
                if (currentChatCharacter) {
                    renderChatMessages(currentChatCharacter.id);
                }
                
                showToast('åŠ¨æ€å¤´åƒå·²æ¸…é™¤ï¼Œæ¢å¤ä¸ºèŠå¤©è®¾ç½®å¤´åƒ', 'success');
            } else {
                showToast('å½“å‰æ²¡æœ‰åŠ¨æ€å¤´åƒ', 'info');
            }
        }
        
        // ä¿å­˜èŠå¤©èº«ä»½é€‰æ‹©
        function saveChatIdentity() {
            if (!window.selectedChatIdentityId) {
                alert('è¯·é€‰æ‹©ä¸€ä¸ªèº«ä»½');
                return;
            }
            
            const chatSettings = getCurrentChatSettings();
            const selectedPersona = personas.find(p => p.id === window.selectedChatIdentityId);
            
            if (selectedPersona) {
                chatSettings.selectedIdentityId = selectedPersona.id;
                
                // å¦‚æœé€‰ä¸­çš„èº«ä»½æœ‰å¤´åƒï¼Œè‡ªåŠ¨è®¾ç½®ä¸ºèŠå¤©å¤´åƒï¼ˆå¦‚æœå½“å‰æ²¡æœ‰è®¾ç½®çš„è¯ï¼‰
                if (selectedPersona.avatarUrl && !chatSettings.myChatAvatar) {
                    chatSettings.myChatAvatar = selectedPersona.avatarUrl;
                }
                
                // å¦‚æœé€‰ä¸­çš„èº«ä»½æœ‰åç§°ï¼Œè‡ªåŠ¨è®¾ç½®ä¸ºèŠå¤©æ˜µç§°ï¼ˆå¦‚æœå½“å‰æ²¡æœ‰è®¾ç½®çš„è¯ï¼‰
                if (selectedPersona.name && !chatSettings.myChatNickname) {
                    chatSettings.myChatNickname = selectedPersona.name;
                }
                
                saveCurrentChatSettings(chatSettings);
                
                // æ›´æ–°æ˜¾ç¤º
                updateChatIdentityDisplay();
                
                // åˆ·æ–°èŠå¤©ç•Œé¢
                if (currentChatCharacter) {
                    renderChatMessages(currentChatCharacter.id);
                }
                
                hideModal('identity-selector-modal');
                showToast(`å·²é€‰æ‹©èº«ä»½"${selectedPersona.name}"`, 'success');
            }
        }
        
        // æ›´æ–°èŠå¤©èº«ä»½æ˜¾ç¤º
        async function updateChatIdentityDisplay() {
            // å¦‚æœæ²¡æœ‰å½“å‰èŠå¤©è§’è‰²ï¼Œå°±ä¸æ‰§è¡Œåç»­æ“ä½œ
            if (!currentChatCharacter) {
                console.log("æ›´æ–°èŠå¤©èº«ä»½æ˜¾ç¤ºï¼šæ— å½“å‰èŠå¤©è§’è‰²ï¼Œè·³è¿‡æ“ä½œ");
                return;
            }
            
            const chatSettings = await getAsyncChatSettings();
            const selectedIdentityId = chatSettings.selectedIdentityId || 'default';
            const selectedPersona = personas.find(p => p.id === selectedIdentityId);
            
            const displayElement = document.getElementById('current-chat-identity');
            if (displayElement && selectedPersona) {
                displayElement.textContent = selectedPersona.name;
            }
        }
        
        // æ›´æ–°æ°”æ³¡æ ·å¼æ˜¾ç¤º
        async function updateBubbleStyleDisplay() {
            // å¦‚æœæ²¡æœ‰å½“å‰èŠå¤©è§’è‰²ï¼Œå°±ä¸æ‰§è¡Œåç»­æ“ä½œ
            if (!currentChatCharacter) {
                console.log("æ›´æ–°æ°”æ³¡æ ·å¼æ˜¾ç¤ºï¼šæ— å½“å‰èŠå¤©è§’è‰²ï¼Œè·³è¿‡æ“ä½œ");
                return;
            }
            
            const chatSettings = await getAsyncChatSettings();
            const styleNames = {
                'default': 'é»˜è®¤æ ·å¼',
                'glass': 'æ¯›ç»ç’ƒ',
                'shadow': 'ç»å…¸é˜´å½±',
                'tail': 'ç»å…¸æ°”æ³¡',
                'gradient': 'æ¸å˜æ ·å¼',
                'minimal': 'æç®€æ ·å¼',
                'neon': 'éœ“è™¹æ ·å¼',
                'paper': 'çº¸å¼ æ ·å¼'
            };
            
            const displayElement = document.getElementById('current-bubble-style');
            if (displayElement) {
                const currentStyle = chatSettings.bubbleStyle || 'default';
                displayElement.textContent = styleNames[currentStyle] || 'é»˜è®¤æ ·å¼';
            }
        }
        
        // å…¨å±€å¤´åƒä¸Šä¼ å¤„ç†å‡½æ•°
        function handleAvatarUploadClick() {
            console.log('ç‚¹å‡»äº†ä¸Šä¼ å¤´åƒæŒ‰é’®');
            const input = document.getElementById('avatar-upload');
            if (input) {
                console.log('æ‰¾åˆ°äº†inputå…ƒç´ ï¼Œå‡†å¤‡è§¦å‘ç‚¹å‡»');
                input.click();
            } else {
                console.error('æ‰¾ä¸åˆ°avatar-uploadå…ƒç´ ');
                alert('æ‰¾ä¸åˆ°æ–‡ä»¶ä¸Šä¼ å…ƒç´ ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
            }
        }
        
        // è¯¥å‡½æ•°å·²è¢«åˆ é™¤ï¼Œä½¿ç”¨ä¸Šé¢çš„å¼‚æ­¥IndexedDBç‰ˆæœ¬
        
        // ğŸ”¥ã€ä¿®å¤ã€‘æ·»åŠ æ¶ˆæ¯é•¿æŒ‰ç›‘å¬å™¨ - æ”¯æŒæ‰‹æœºç«¯èœå•æ“ä½œ
        function addMessageLongPressListener(messageContainer, messageId) {
            let pressTimer = null;
            let isLongPress = false;
            
            // æ£€æµ‹æ˜¯å¦ä¸ºç§»åŠ¨è®¾å¤‡
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                             'ontouchstart' in window || 
                             navigator.maxTouchPoints > 0;
            
            const startLongPress = (e) => {
                if (isMessageSelectionMode) {
                    // åœ¨é€‰æ‹©æ¨¡å¼ä¸‹ï¼Œåªå¤„ç†ç‚¹å‡»é€‰æ‹©ï¼Œä¸å¤„ç†é•¿æŒ‰
                    return;
                }

                isLongPress = false;
                pressTimer = setTimeout(() => {
                    isLongPress = true;

                    // ğŸ”¥ã€ä¿®å¤ã€‘åªåœ¨é•¿æŒ‰è§¦å‘æ—¶é˜»æ­¢é»˜è®¤è¡Œä¸º
                    e.preventDefault();
                    e.stopPropagation();

                    // ğŸ”¥ã€æ–°å¢ã€‘æ‰‹æœºç«¯æ˜¾ç¤ºæ“ä½œèœå•ï¼Œæ¡Œé¢ç«¯è¿›å…¥å¤šé€‰æ¨¡å¼
                    if (isMobile) {
                        showMobileMessageMenu(messageId, e);
                    } else {
                    enterMessageSelectionMode(messageId);
                    }
                }, 500);
            };
            
            const cancelLongPress = () => {
                clearTimeout(pressTimer);
                // é‡ç½®é•¿æŒ‰æ ‡è®°ï¼Œå»¶è¿Ÿé‡ç½®ä»¥é¿å…ç«‹å³è§¦å‘ç‚¹å‡»
                setTimeout(() => {
                    isLongPress = false;
                }, 50);
            };
            
            const handleClick = (e) => {
                // åœ¨é€‰æ‹©æ¨¡å¼ä¸‹ï¼Œæ‰€æœ‰æ¶ˆæ¯éƒ½å¯ä»¥ç‚¹å‡»åˆ‡æ¢é€‰æ‹©çŠ¶æ€
                if (isMessageSelectionMode) {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleMessageSelection(messageId);
                    return;
                }
                
                // å¦‚æœæ˜¯é•¿æŒ‰è§¦å‘åçš„ç‚¹å‡»ï¼Œä¸å¤„ç†
                if (isLongPress) {
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }
            };
            
            // è§¦æ‘¸äº‹ä»¶
            messageContainer.addEventListener('touchstart', startLongPress, { passive: false });
            messageContainer.addEventListener('touchend', cancelLongPress);
            messageContainer.addEventListener('touchmove', cancelLongPress);
            
            // é¼ æ ‡äº‹ä»¶ï¼ˆç”¨äºæ¡Œé¢ç«¯æµ‹è¯•ï¼‰
            messageContainer.addEventListener('mousedown', startLongPress);
            messageContainer.addEventListener('mouseup', cancelLongPress);
            messageContainer.addEventListener('mouseleave', cancelLongPress);
            
            // ç‚¹å‡»äº‹ä»¶ - ä½¿ç”¨æ•è·é˜¶æ®µç¡®ä¿ä¼˜å…ˆå¤„ç†
            messageContainer.addEventListener('click', handleClick, true);
        }
        
        // ğŸ”¥ã€é‡æ–°è®¾è®¡ã€‘æ˜¾ç¤ºæ¶ˆæ¯ä¸Šæ–¹æŒ‰é’®æ¡
        function showMobileMessageMenu(messageId, event) {
            console.log('ç§»åŠ¨ç«¯é•¿æŒ‰èœå•ï¼ŒmessageId:', messageId);
            selectedMessageId = messageId;

            // æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦æ˜¯ç”¨æˆ·å‘é€çš„
            const messages = chatMessages[currentChatCharacter.id] || [];
            const message = messages.find(msg => msg.id === messageId);
            const isUserMessage = message && message.sender === 'sent';

            // éšè—å·²å­˜åœ¨çš„æŒ‰é’®æ¡
            hideMessageActionBar();

            // æ‰¾åˆ°å¯¹åº”çš„æ¶ˆæ¯å®¹å™¨
            const messageContainer = document.querySelector(`[data-message-id="${messageId}"]`);
            if (!messageContainer) {
                console.log('é”™è¯¯ï¼šæ‰¾ä¸åˆ°æ¶ˆæ¯å®¹å™¨');
                return;
            }
            console.log('æ‰¾åˆ°æ¶ˆæ¯å®¹å™¨:', messageContainer);

            // åˆ›å»ºæŒ‰é’®æ¡
            const actionBar = document.createElement('div');
            actionBar.className = 'message-action-bar';
            actionBar.id = 'message-action-bar';

            // æ„å»ºæŒ‰é’®åˆ—è¡¨
            const buttons = ['å¼•ç”¨', 'å¤åˆ¶'];

            // ğŸ”¥ã€æ–°å¢ã€‘åªæœ‰AIè§’è‰²æ¶ˆæ¯æ‰æ˜¾ç¤ºå¿ƒå£°é€‰é¡¹
            if (!isUserMessage) {
                buttons.push('å¿ƒå£°');
            }

            if (isUserMessage) {
                buttons.push('ç¼–è¾‘', 'æ’¤å›');
            }
            buttons.push('å¤šé€‰');

            actionBar.innerHTML = buttons.map(text => {
                let action = '';
                switch(text) {
                    case 'å¼•ç”¨': action = `replyToMessage('${messageId}')`; break;
                    case 'å¤åˆ¶': action = `copyMessage('${messageId}')`; break;
                    case 'å¿ƒå£°': action = `showInnerThoughtsModal('${messageId}')`; break;
                    case 'ç¼–è¾‘': action = `showEditMessageModal('${messageId}')`; break;
                    case 'æ’¤å›': action = `deleteMessage('${messageId}')`; break;
                    case 'å¤šé€‰': action = `enterMessageSelectionMode('${messageId}')`; break;
                }
                return `<button class="message-action-btn" onclick="${action}; hideMessageActionBar();">${text}</button>`;
            }).join('');

            // æ·»åŠ åˆ°æ¶ˆæ¯å®¹å™¨
            messageContainer.appendChild(actionBar);

            // æ˜¾ç¤ºåŠ¨ç”»
            setTimeout(() => {
                actionBar.classList.add('show');
            }, 10);

            // æ·»åŠ å…¨å±€ç‚¹å‡»ç›‘å¬å™¨
            setTimeout(() => {
                document.addEventListener('click', hideMessageActionBarOnClickOutside);
                document.addEventListener('touchstart', hideMessageActionBarOnClickOutside);
            }, 100);
        }
        
        // ğŸ”¥ã€é‡æ–°è®¾è®¡ã€‘éšè—æ¶ˆæ¯æŒ‰é’®æ¡
        function hideMessageActionBar() {
            const actionBar = document.getElementById('message-action-bar');
            if (actionBar) {
                actionBar.classList.remove('show');
                setTimeout(() => {
                    if (actionBar.parentNode) {
                        actionBar.parentNode.removeChild(actionBar);
                    }
                }, 300);
            }
            selectedMessageId = null;

            // ç§»é™¤å…¨å±€ç‚¹å‡»ç›‘å¬å™¨
            document.removeEventListener('click', hideMessageActionBarOnClickOutside);
            document.removeEventListener('touchstart', hideMessageActionBarOnClickOutside);
        }

        // ğŸ”¥ã€æ–°å¢ã€‘ç‚¹å‡»å¤–éƒ¨éšè—æŒ‰é’®æ¡
        function hideMessageActionBarOnClickOutside(event) {
            const actionBar = document.getElementById('message-action-bar');
            if (actionBar && !actionBar.contains(event.target)) {
                hideMessageActionBar();
            }
        }

        // ğŸ”¥ã€å…¼å®¹ã€‘ä¿æŒæ—§å‡½æ•°å
        function hideMobileMessageMenu() {
            hideMessageActionBar();
        }
        
        // è¿›å…¥æ¶ˆæ¯é€‰æ‹©æ¨¡å¼
        function enterMessageSelectionMode(initialMessageId) {
            if (isMessageSelectionMode) {
                return;
            }
            
            isMessageSelectionMode = true;
            selectedMessages.clear();
            selectedMessages.add(initialMessageId);
            
            // æ·»åŠ é€‰æ‹©æ¨¡å¼CSSç±»
            const chatScreen = document.getElementById('api-chat-screen');
            if (chatScreen) {
                chatScreen.classList.add('selection-mode');
            }
            
            updateMessageSelectionUI();
        }
        
        // åˆ‡æ¢æ¶ˆæ¯é€‰æ‹©çŠ¶æ€
        function toggleMessageSelection(messageId) {
            if (!isMessageSelectionMode) return;
            
            if (selectedMessages.has(messageId)) {
                selectedMessages.delete(messageId);
            } else {
                selectedMessages.add(messageId);
            }
            
            updateMessageSelectionUI();
            
            // å¦‚æœæ²¡æœ‰é€‰ä¸­çš„æ¶ˆæ¯ï¼Œé€€å‡ºé€‰æ‹©æ¨¡å¼
            if (selectedMessages.size === 0) {
                exitMessageSelectionMode();
            }
        }
        
        // é€€å‡ºæ¶ˆæ¯é€‰æ‹©æ¨¡å¼
        function exitMessageSelectionMode() {
            if (!isMessageSelectionMode) return;
            
            isMessageSelectionMode = false;
            
            // ç§»é™¤é€‰æ‹©æ¨¡å¼CSSç±»
            const chatScreen = document.getElementById('api-chat-screen');
            if (chatScreen) {
                chatScreen.classList.remove('selection-mode');
            }
            
            // ğŸ”¥ã€ä¿®å¤ã€‘æ¸…é™¤æ‰€æœ‰é€‰ä¸­çŠ¶æ€ï¼ŒåŒ…æ‹¬æ’¤å›æ¶ˆæ¯
            const selectedContainers = document.querySelectorAll('[data-message-id].selected');
            selectedContainers.forEach(container => {
                container.classList.remove('selected');
            });
            
            selectedMessages.clear();
            updateMessageSelectionUI();
        }
        

        
        // æ›´æ–°æ¶ˆæ¯é€‰æ‹©UI
        function updateMessageSelectionUI() {
            // ğŸ”¥ã€ä¿®å¤ã€‘æŸ¥æ‰¾æ‰€æœ‰å¸¦æœ‰messageIdçš„å®¹å™¨ï¼ŒåŒ…æ‹¬æ’¤å›æ¶ˆæ¯
            const allContainers = document.querySelectorAll('[data-message-id]');
            
            allContainers.forEach(container => {
                const messageId = container.dataset.messageId;
                if (messageId) {
                    if (selectedMessages.has(messageId)) {
                        container.classList.add('selected');
                    } else {
                        container.classList.remove('selected');
                    }
                }
            });
            
            // æ›´æ–°é€‰æ‹©è®¡æ•°æ˜¾ç¤º
            const countElement = document.getElementById('selection-count');
            if (countElement) {
                countElement.textContent = `å·²é€‰ ${selectedMessages.size} æ¡`;
            }
        }
        
        // ğŸ”¥ã€ä¿®å¤ã€‘é˜²æ­¢é‡å¤åˆ é™¤æ“ä½œçš„æ ‡å¿—
        let isDeletingMessages = false;

        // åˆ é™¤é€‰ä¸­çš„æ¶ˆæ¯
        async function deleteSelectedMessages() {
            // é˜²æ­¢é‡å¤æ“ä½œ
            if (isDeletingMessages) {
                console.log('åˆ é™¤æ“ä½œæ­£åœ¨è¿›è¡Œä¸­ï¼Œè¯·ç¨å€™...');
                return;
            }
            if (selectedMessages.size === 0) return;
            
            if (!currentChatCharacter) return;
            
            if (confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedMessages.size} æ¡æ¶ˆæ¯å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼`)) {
                isDeletingMessages = true; // è®¾ç½®åˆ é™¤æ ‡å¿—
                const characterId = currentChatCharacter.id;

                if (chatMessages[characterId]) {
                    // ğŸ”¥ã€æ–°å¢ã€‘åˆ é™¤é€‰ä¸­æ¶ˆæ¯çš„æ—¶é—´çº¿è®°å½•
                    const messagesToDelete = [];
                    chatMessages[characterId].forEach(message => {
                        if (selectedMessages.has(message.id)) {
                            messagesToDelete.push(message);
                        }
                    });

                    // æ¸…ç†æ¯æ¡è¢«åˆ é™¤æ¶ˆæ¯çš„æ—¶é—´çº¿è®°å½•
                    for (const message of messagesToDelete) {
                        try {
                            await deleteRelatedTimelineEvents(message);
                            console.log(`ğŸ—‘ï¸ å·²æ¸…ç†æ¶ˆæ¯çš„æ—¶é—´çº¿è®°å½•: ${message.content?.substring(0, 30)}...`);
                        } catch (error) {
                            console.error('æ¸…ç†æ—¶é—´çº¿è®°å½•å¤±è´¥:', error);
                        }
                    }

                    // æŸ¥æ‰¾æ‰€æœ‰è¦åˆ é™¤çš„æ¶ˆæ¯å†…å®¹ï¼Œç”¨äºåŒ¹é…ç›¸å…³çš„æ’¤å›æç¤º
                    const deleteContentSet = new Set();
                    messagesToDelete.forEach(message => {
                        if (message.content) {
                            deleteContentSet.add(message.content);
                        }
                    });
                    
                    // è¿‡æ»¤æ¶ˆæ¯ï¼šåˆ é™¤é€‰ä¸­æ¶ˆæ¯ + ç›¸å…³çš„æ’¤å›æç¤º
                    chatMessages[characterId] = chatMessages[characterId].filter(message => {
                        // åˆ é™¤é€‰ä¸­çš„æ¶ˆæ¯
                        if (selectedMessages.has(message.id)) {
                            return false;
                        }
                        
                        // åˆ é™¤ç›¸å…³çš„æ’¤å›æç¤ºï¼ˆç³»ç»Ÿæ¶ˆæ¯ç±»å‹ï¼Œä¸”åŸæ–‡åŒ¹é…è¦åˆ é™¤çš„æ¶ˆæ¯ï¼‰
                        if (message.sender === 'system' && message.type === 'recalled_message' && message.originalContent) {
                            if (deleteContentSet.has(message.originalContent)) {
                                console.log('åˆ é™¤ç›¸å…³çš„æ’¤å›æç¤º:', message.content);
                                return false;
                            }
                        }
                        
                        return true;
                    });
                    
                    saveChatMessages();
                    renderChatMessages(characterId);
                    renderMessageList(); // æ›´æ–°æ¶ˆæ¯åˆ—è¡¨
                }
                
                // é€€å‡ºé€‰æ‹©æ¨¡å¼
                exitMessageSelectionMode();

                // ğŸ”¥ã€ä¿®å¤ã€‘é‡ç½®åˆ é™¤æ ‡å¿—ï¼Œå…è®¸åç»­åˆ é™¤æ“ä½œ
                isDeletingMessages = false;
            } else {
                // ğŸ”¥ã€ä¿®å¤ã€‘ç”¨æˆ·å–æ¶ˆåˆ é™¤æ—¶ä¹Ÿè¦é‡ç½®æ ‡å¿—
                isDeletingMessages = false;
            }
        }

        // æ‚¬æµ®æŒ‰é’®åŠŸèƒ½
        // å˜é‡æ§åˆ¶ç­‰å¾…å›å¤çŠ¶æ€
        let isWaitingForReply = false;
        let pendingUserMessage = null;

      // ç”¨è¿™æ®µæ–°ä»£ç ï¼Œå®Œæ•´æ›¿æ¢æ‰æ—§çš„ regenerateLastResponse å‡½æ•°
        async function regenerateLastResponse() {
            if (!currentChatCharacter) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè§’è‰²');
                return;
            }

            // é˜²æ­¢é‡å¤è°ƒç”¨
            if (window._isRegenerating) {
                console.log('é‡æ–°ç”Ÿæˆæ­£åœ¨è¿›è¡Œä¸­ï¼Œå¿½ç•¥é‡å¤è°ƒç”¨');
                return;
            }
            window._isRegenerating = true;

            const characterId = currentChatCharacter.id;
            const messages = chatMessages[characterId] || [];
            
            // æ‰¾åˆ°æœ€åä¸€æ¡AIæ¶ˆæ¯åŠå…¶å¯¹åº”çš„ç”¨æˆ·æ¶ˆæ¯
            let lastAiMessageIndex = -1;
            let lastUserMessageIndex = -1;
            
            for (let i = messages.length - 1; i >= 0; i--) {
                if (messages[i].sender === 'received' && lastAiMessageIndex === -1) {
                    lastAiMessageIndex = i;
                }
                if (lastAiMessageIndex !== -1 && messages[i].sender === 'sent' && lastUserMessageIndex === -1) {
                    lastUserMessageIndex = i;
                    break;
                }
            }
            
            if (lastAiMessageIndex === -1) {
                alert('æ²¡æœ‰æ‰¾åˆ°AIå›å¤å¯ä»¥é‡æ–°ç”Ÿæˆ');
                return;
            }
            
            if (lastUserMessageIndex === -1) {
                alert('æ²¡æœ‰æ‰¾åˆ°å¯¹åº”çš„ç”¨æˆ·æ¶ˆæ¯');
                return;
            }

            const userMessage = messages[lastUserMessageIndex];
            
            // åˆ é™¤ä»æœ€åä¸€æ¡ç”¨æˆ·æ¶ˆæ¯åçš„æ‰€æœ‰AIæ¶ˆæ¯
            chatMessages[characterId] = messages.slice(0, lastUserMessageIndex + 1);
    await saveChatMessages(); // ä½¿ç”¨ await ç¡®ä¿ä¿å­˜å®Œæˆ
            await renderChatMessagesAsync(characterId);

            // ğŸ”¥ã€ä¿®å¤ã€‘ç¡®ä¿åœ¨renderChatMessageså®Œæˆåå†æ˜¾ç¤ºtyping-indicator
            console.log('ğŸ”§ [regenerateLastResponse] å‡†å¤‡æ˜¾ç¤ºtyping-indicator');
            // æ·»åŠ å°å»¶è¿Ÿç¡®ä¿DOMæ›´æ–°å®Œæˆ
            await new Promise(resolve => {
                setTimeout(() => {
                    showTypingIndicator();
                    resolve();
                }, 100);
            });
            
            const delay = Math.random() * 2000 + 1000;
            await new Promise(resolve => setTimeout(resolve, delay));
            
            try {
                let response;
                
                // ğŸ”¥ã€æ ¸å¿ƒä¿®å¤ã€‘ä½¿ç”¨æ–°çš„å¤šæ¨¡æ€å¤„ç†é€»è¾‘
                if (Array.isArray(userMessage.content)) {
                    // è¿™æ˜¯å¤šæ¨¡æ€æ¶ˆæ¯ï¼ˆå›¾æ–‡ï¼‰
                    response = await callChatAPI(userMessage.content, currentChatCharacter);
                } else if (userMessage.image) {
                    // å…¼å®¹æ—§çš„å›¾ç‰‡æ¶ˆæ¯æ ¼å¼
                    const messageContent = [
                        { type: 'text', text: userMessage.content || "" },
                        { type: 'image_url', image_url: { url: userMessage.image } }
                    ];
                    response = await callChatAPI(messageContent, currentChatCharacter);
                } else if (userMessage.type === 'transfer') {
                    // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘è½¬è´¦æ¶ˆæ¯ç‰¹æ®Šå¤„ç† - æ„é€ è½¬è´¦æç¤ºæ–‡æœ¬
                    const transferPrompt = `[ç”¨æˆ·å‘èµ·äº†è½¬è´¦ï¼š${userMessage.amount}å…ƒï¼Œå¤‡æ³¨ï¼š${userMessage.note || 'æ— '}]`;
                    response = await callChatAPI(transferPrompt, currentChatCharacter);
                } else {
                    // æ™®é€šæ–‡æœ¬æ¶ˆæ¯
                    let finalPrompt = userMessage.content; // é»˜è®¤ä½¿ç”¨åŸå§‹æ¶ˆæ¯å†…å®¹

                    // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘æ£€æŸ¥ç”¨æˆ·æ¶ˆæ¯æ˜¯å¦ä¸ºå¼•ç”¨å›å¤
                    if (userMessage.replyTo) {
                        const quoteText = summarizeLastMessage({ content: userMessage.replyTo.content });
                        finalPrompt = `[å›å¤ ${userMessage.replyTo.senderName} çš„æ¶ˆæ¯: "${quoteText}"] ${userMessage.content}`;
                        console.log('âœ… [é‡æ–°ç”Ÿæˆ] æ„å»ºç”¨æˆ·å¼•ç”¨æç¤º:', finalPrompt);
                    }

                    response = await callChatAPI(finalPrompt, currentChatCharacter);
                }
                const aiMessages = parseAiResponse(response);

                // ğŸ”¥ã€ä¿®å¤ã€‘ä¸è¦åœ¨è¿™é‡Œç«‹å³éšè—"æ­£åœ¨è¾“å…¥ä¸­"ï¼Œè®©æ¯æ¡æ¶ˆæ¯å¤„ç†æ—¶æ§åˆ¶

                for (let i = 0; i < aiMessages.length; i++) {
                    const msgData = aiMessages[i];
                    let aiMessage;
                    
            if (typeof msgData === 'object' && msgData !== null) {
                if (msgData.type === 'voice_message') {
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', type: 'voice_message', content: msgData.content, timestamp: Date.now() + i * 100 };
                } else if (msgData.type === 'ai_image') {
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', type: 'ai_image', content: msgData.description || 'AIæè¿°çš„å›¾ç‰‡', imageDescription: msgData.description, timestamp: Date.now() + i * 100 };

                    // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘å¦‚æœæ˜¯ç¾¤èŠæ¶ˆæ¯ï¼Œæ·»åŠ å‘é€è€…ä¿¡æ¯
                    if (msgData.name) {
                        console.log('ğŸ” [callChatAPI-AIå›¾ç‰‡] æ£€æµ‹åˆ°ç¾¤èŠæ¶ˆæ¯ï¼Œå‘é€è€…:', msgData.name);
                        aiMessage.name = msgData.name;
                        // æŸ¥æ‰¾å¯¹åº”çš„ç¾¤æˆå‘˜ID
                        if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                            const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                            if (member) {
                                aiMessage.senderId = member.id;
                                console.log('ğŸ” [callChatAPI-AIå›¾ç‰‡] æ‰¾åˆ°ç¾¤æˆå‘˜ID:', member.id);
                            } else {
                                console.log('ğŸ” [callChatAPI-AIå›¾ç‰‡] æœªæ‰¾åˆ°ç¾¤æˆå‘˜:', msgData.name);
                            }
                        }
                    }
                } else if (msgData.type === 'transfer') {
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', type: 'transfer', amount: msgData.amount, note: msgData.note, timestamp: Date.now() + i * 100 };
                } else if (msgData.type === 'emoji' && !msgData.name) {
                    // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘å¤„ç†è¡¨æƒ…åŒ…æ¶ˆæ¯ - ä»…å¤„ç†æ²¡æœ‰nameå­—æ®µçš„è¡¨æƒ…åŒ…ï¼ˆéç¾¤èŠæ ¼å¼ï¼‰
                    const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.description);
                    if (matchingEmoji) {
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: '',
                            image: matchingEmoji.url,
                            isEmoji: true,
                            emojiDescription: matchingEmoji.description,
                            timestamp: Date.now() + i * 100
                        };

                        addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                    } else {
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: `[è¡¨æƒ…åŒ…"${msgData.description}"ä¸å­˜åœ¨]`,
                            timestamp: Date.now() + i * 100
                        };
                    }
                } else if (msgData.type === 'recall_previous') {
                    // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†AIæ’¤å›ä¸Šä¸€æ¡æ¶ˆæ¯
                    console.log('ğŸ”¥ AIè¯·æ±‚æ’¤å›ä¸Šä¸€æ¡æ¶ˆæ¯:', msgData);

                    // æŸ¥æ‰¾ä¸Šä¸€æ¡AIæ¶ˆæ¯
                    const allMessages = chatMessages[currentChatCharacter.id] || [];
                    let lastAIMessageIndex = -1;

                    for (let j = allMessages.length - 1; j >= 0; j--) {
                        if (allMessages[j].sender === 'received') {
                            lastAIMessageIndex = j;
                            break;
                        }
                    }

                    if (lastAIMessageIndex !== -1) {
                        const messageToRecall = allMessages[lastAIMessageIndex];
                        console.log('ğŸ”¥ æ‰¾åˆ°è¦æ’¤å›çš„æ¶ˆæ¯:', messageToRecall);

                        // è°ƒç”¨æ’¤å›æ¶ˆæ¯å¤„ç†å‡½æ•°
                        await handleRecalledMessage(messageToRecall.content, messageToRecall.id);
                    } else {
                        console.warn('ğŸ”¥ æ²¡æœ‰æ‰¾åˆ°å¯æ’¤å›çš„AIæ¶ˆæ¯');
                        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ¶ˆæ¯ï¼Œæ˜¾ç¤ºä¸€æ¡æç¤º
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: '[AIæ’¤å›äº†ä¸Šä¸€æ¡æ¶ˆæ¯]',
                            timestamp: Date.now() + i * 100
                        };
                    }
                    continue; // è·³è¿‡æ­£å¸¸çš„æ¶ˆæ¯å¤„ç†æµç¨‹
                } else if (msgData.type === 'change_avatar') {
                        if (msgData.avatar_url) {
                            // ğŸ”¥ã€ä¿®å¤ã€‘å…ˆå¤„ç†å ä½ç¬¦æ›¿æ¢ï¼Œå†éªŒè¯å’Œæ‰§è¡Œå¤´åƒæ›´æ¢
                            let actualAvatarUrl = msgData.avatar_url;
                            if (msgData.avatar_url === 'CURRENT_USER_IMAGE' ||
                                msgData.avatar_url === 'CURRENT_USER_IMAGE' ||
                                msgData.avatar_url === 'ç”¨æˆ·å‘é€çš„å›¾ç‰‡URL' ||
                                msgData.avatar_url === 'å›¾ç‰‡URL') {
                                const recentUserImage = getRecentUserImage();
                                if (recentUserImage) {
                                    actualAvatarUrl = recentUserImage;
                                } else {
                                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[æ— æ³•æ›´æ¢å¤´åƒï¼Œæ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„å›¾ç‰‡]', timestamp: Date.now() + i * 100 };
                                    continue;
                                }
                            }

                            const isValidAvatar = await validateAvatarSource(actualAvatarUrl);
                            if (isValidAvatar) {
                                const success = await changeCharacterAvatarByAI(actualAvatarUrl, msgData.reason || 'å¿ƒæƒ…å˜åŒ–');
                            if (success) continue;
                            else aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[å¤´åƒæ›´æ¢å¤±è´¥]', timestamp: Date.now() + i * 100 };
                                } else {
                            aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[æ— æ•ˆçš„å¤´åƒæ¥æºï¼Œå¤´åƒæ›´æ¢å¤±è´¥]', timestamp: Date.now() + i * 100 };
                                }
                            } else {
                        continue;
                    }
                } else if (msgData.type === 'reply_to') {
                    // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†AIå¼•ç”¨å›å¤
                    // æŸ¥æ‰¾è¢«å¼•ç”¨çš„æ¶ˆæ¯
                    const referencedMessage = findMessageById(msgData.message_id);

                    if (referencedMessage) {
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: msgData.content,
                            replyTo: {
                                id: referencedMessage.id,
                                content: referencedMessage.content,
                                senderName: referencedMessage.sender === 'sent' ? (getCurrentPersonaName() || 'ç”¨æˆ·') : (currentChatCharacter.name || 'AI')
                            },
                            timestamp: Date.now() + i * 100
                        };
                    } else {
                        // å¦‚æœæ‰¾ä¸åˆ°è¢«å¼•ç”¨çš„æ¶ˆæ¯ï¼Œå‘é€æ™®é€šæ¶ˆæ¯
                        console.warn('æ‰¾ä¸åˆ°è¢«å¼•ç”¨çš„æ¶ˆæ¯ID:', msgData.message_id);
                        aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: msgData.content, timestamp: Date.now() + i * 100 };
                    }
                } else if (msgData.name && msgData.type === 'emoji') {
                    // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†ç›´æ¥çš„ç¾¤èŠè¡¨æƒ…åŒ…æ ¼å¼ {"name": "è§’è‰²å", "type": "emoji", "description": "è¡¨æƒ…åŒ…æè¿°"}
                    console.log('ğŸ” [ç¾¤èŠè¡¨æƒ…åŒ…-ç›´æ¥æ ¼å¼] æ£€æµ‹åˆ°ç›´æ¥æ ¼å¼çš„ç¾¤èŠè¡¨æƒ…åŒ…:', msgData);

                    let senderId = null;
                    if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                        console.log('ğŸ” [ç¾¤èŠè¡¨æƒ…åŒ…-ç›´æ¥æ ¼å¼] æŸ¥æ‰¾æˆå‘˜è¯¦æƒ…:', {
                            targetName: msgData.name,
                            allMembers: currentChatCharacter.members,
                            memberNames: currentChatCharacter.members.map(m => m.name)
                        });

                        const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                        if (member) {
                            senderId = member.id;
                            console.log('ğŸ” [ç¾¤èŠè¡¨æƒ…åŒ…-ç›´æ¥æ ¼å¼] æ‰¾åˆ°æˆå‘˜:', member, 'senderId:', senderId);
                        } else {
                            console.warn('ğŸ” [ç¾¤èŠè¡¨æƒ…åŒ…-ç›´æ¥æ ¼å¼] æœªæ‰¾åˆ°æˆå‘˜:', msgData.name);
                            console.warn('ğŸ” [ç¾¤èŠè¡¨æƒ…åŒ…-ç›´æ¥æ ¼å¼] å¯ç”¨æˆå‘˜åç§°:', currentChatCharacter.members.map(m => m.name));
                        }
                    }

                    const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.description);
                    if (matchingEmoji) {
                        console.log('ğŸ” [ç¾¤èŠè¡¨æƒ…åŒ…-ç›´æ¥æ ¼å¼] æ‰¾åˆ°åŒ¹é…çš„è¡¨æƒ…åŒ…:', matchingEmoji);

                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            name: msgData.name,
                            senderId: senderId,
                            content: '', // è¡¨æƒ…åŒ…æ¶ˆæ¯ä¸æ˜¾ç¤ºæ–‡å­—å†…å®¹
                            image: matchingEmoji.url,
                            isEmoji: true,
                            emojiDescription: matchingEmoji.description,
                            timestamp: Date.now() + i * 100
                        };

                        console.log('ğŸ” [ç¾¤èŠè¡¨æƒ…åŒ…-ç›´æ¥æ ¼å¼] åˆ›å»ºçš„æ¶ˆæ¯å¯¹è±¡:', aiMessage);
                        addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                    } else {
                        console.warn('ğŸ” [ç¾¤èŠè¡¨æƒ…åŒ…-ç›´æ¥æ ¼å¼] æ‰¾ä¸åˆ°åŒ¹é…çš„è¡¨æƒ…åŒ…:', msgData.description);

                        // å¦‚æœæ‰¾ä¸åˆ°åŒ¹é…çš„è¡¨æƒ…åŒ…ï¼Œå‘é€é”™è¯¯æ¶ˆæ¯
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            name: msgData.name,
                            senderId: senderId,
                            content: `[è¡¨æƒ…åŒ…"${msgData.description}"ä¸å­˜åœ¨]`,
                            timestamp: Date.now() + i * 100
                        };
                    }
                } else if (msgData.name && msgData.message) {
                    // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘è¿™æ˜¯ç¾¤èŠçš„ç‰¹æ®Šæ ¼å¼ï¼Œä½¿ç”¨zhangyu.htmlå…¼å®¹å¤„ç†
                    console.log('ğŸ” [ç¾¤èŠæ¶ˆæ¯] å¤„ç†ç¾¤èŠæ¶ˆæ¯:', msgData);
                    console.log('ğŸ” [ç¾¤èŠæ¶ˆæ¯] msgData.messageç±»å‹:', typeof msgData.message, 'msgData.message:', msgData.message);

                    let senderId = null;
                    if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                        // ğŸ”¥ã€ä¿®å¤ã€‘ä¼˜å…ˆä½¿ç”¨personaå­—æ®µæŸ¥æ‰¾æˆå‘˜
                        console.log('ğŸ” [ç¾¤èŠèº«ä»½] æŸ¥æ‰¾æˆå‘˜:', msgData.name, 'åœ¨ç¾¤èŠ:', currentChatCharacter.name);
                        console.log('ğŸ” [ç¾¤èŠèº«ä»½] ç¾¤æˆå‘˜åˆ—è¡¨:', currentChatCharacter.members);

                        const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                        if (member) {
                            senderId = member.id;
                            console.log('ğŸ” [ç¾¤èŠèº«ä»½] æ‰¾åˆ°æˆå‘˜:', member, 'senderId:', senderId);
                        } else {
                            console.warn('ğŸ” [ç¾¤èŠèº«ä»½] æœªæ‰¾åˆ°æˆå‘˜:', msgData.name);
                        }
                    }

                    // --- å…³é”®ä¿®å¤ï¼šæ£€æŸ¥ç¾¤èŠæ¶ˆæ¯å†…å®¹æ˜¯å¦ä¸ºç‰¹æ®Šç±»å‹ ---
                    if (typeof msgData.message === 'object' && msgData.message.type === 'voice_message') {
                        // å¦‚æœæ¶ˆæ¯å†…å®¹æ˜¯ä¸€ä¸ªè¯­éŸ³æ¶ˆæ¯å¯¹è±¡
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'voice_message', // åœ¨å¤–å±‚æ¶ˆæ¯ä¸Šè®¾ç½®æ­£ç¡®çš„ç±»å‹
                            name: msgData.name,
                            senderId: senderId,
                            content: msgData.message.content, // æå–çœŸæ­£çš„è¯­éŸ³æ–‡å­—å†…å®¹
                            timestamp: Date.now() + i * 100
                        };
                    } else if (typeof msgData.message === 'object' && msgData.message.type === 'reply_to') {
                        // ğŸ”¥ã€æ–°å¢ã€‘ç¾¤èŠä¸­çš„å¼•ç”¨å›å¤
                        const referencedMessage = findMessageById(msgData.message.message_id);
                        if (referencedMessage) {
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                name: msgData.name,
                                senderId: senderId,
                                content: msgData.message.content,
                                replyTo: {
                                    id: referencedMessage.id,
                                    content: referencedMessage.content,
                                    senderName: referencedMessage.sender === 'sent' ? (getCurrentPersonaName() || 'ç”¨æˆ·') : (referencedMessage.name || referencedMessage.senderName || 'AI')
                                },
                                timestamp: Date.now() + i * 100
                            };
                        } else {
                            // å¦‚æœæ‰¾ä¸åˆ°è¢«å¼•ç”¨çš„æ¶ˆæ¯ï¼Œå‘é€æ™®é€šç¾¤èŠæ¶ˆæ¯
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                name: msgData.name,
                                senderId: senderId,
                                content: msgData.message.content,
                                timestamp: Date.now() + i * 100
                            };
                        }
                    } else if (typeof msgData.message === 'object' && msgData.message.type === 'emoji') {
                        // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘å¦‚æœæ¶ˆæ¯å†…å®¹æ˜¯ä¸€ä¸ªè¡¨æƒ…åŒ…å¯¹è±¡
                        console.log('ğŸ” [ç¾¤èŠè¡¨æƒ…åŒ…] æ£€æµ‹åˆ°ç¾¤èŠè¡¨æƒ…åŒ…æ¶ˆæ¯:', msgData);

                        const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.message.description);
                        if (matchingEmoji) {
                            console.log('ğŸ” [ç¾¤èŠè¡¨æƒ…åŒ…] æ‰¾åˆ°åŒ¹é…çš„è¡¨æƒ…åŒ…:', matchingEmoji);

                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                name: msgData.name,
                                senderId: senderId,
                                content: '', // è¡¨æƒ…åŒ…æ¶ˆæ¯ä¸æ˜¾ç¤ºæ–‡å­—å†…å®¹
                                image: matchingEmoji.url,
                                isEmoji: true,
                                emojiDescription: matchingEmoji.description,
                                timestamp: Date.now() + i * 100
                            };

                            console.log('ğŸ” [ç¾¤èŠè¡¨æƒ…åŒ…] åˆ›å»ºçš„æ¶ˆæ¯å¯¹è±¡:', aiMessage);
                            console.log('ğŸ” [ç¾¤èŠè¡¨æƒ…åŒ…] senderIdè®¾ç½®ä¸º:', senderId, 'nameè®¾ç½®ä¸º:', msgData.name);

                            addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                        } else {
                            console.warn('ğŸ” [ç¾¤èŠè¡¨æƒ…åŒ…] æ‰¾ä¸åˆ°åŒ¹é…çš„è¡¨æƒ…åŒ…:', msgData.message.description);

                            // å¦‚æœæ‰¾ä¸åˆ°åŒ¹é…çš„è¡¨æƒ…åŒ…ï¼Œå‘é€é”™è¯¯æ¶ˆæ¯
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                name: msgData.name,
                                senderId: senderId,
                                content: `[è¡¨æƒ…åŒ…"${msgData.message.description}"ä¸å­˜åœ¨]`,
                                timestamp: Date.now() + i * 100
                            };
                        }
                    } else if (typeof msgData.message === 'object' && msgData.message.type === 'transfer') {
                        // ğŸ”¥ã€ä¿®å¤ã€‘å¦‚æœæ¶ˆæ¯å†…å®¹æ˜¯ä¸€ä¸ªè½¬è´¦å¯¹è±¡
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'transfer', // åœ¨å¤–å±‚æ¶ˆæ¯ä¸Šè®¾ç½®æ­£ç¡®çš„ç±»å‹
                            name: msgData.name,
                            senderId: senderId,
                            amount: msgData.message.amount, // æå–è½¬è´¦é‡‘é¢
                            note: msgData.message.note, // æå–è½¬è´¦å¤‡æ³¨
                            timestamp: Date.now() + i * 100
                        };
                    } else if (typeof msgData.message === 'object' && msgData.message.type === 'friend_request') {
                        // ğŸ”¥ã€æ–°å¢ã€‘å¦‚æœæ¶ˆæ¯å†…å®¹æ˜¯ä¸€ä¸ªå¥½å‹ç”³è¯·å¯¹è±¡
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'friend_request', // åœ¨å¤–å±‚æ¶ˆæ¯ä¸Šè®¾ç½®æ­£ç¡®çš„ç±»å‹
                            name: msgData.name,
                            senderId: senderId,
                            message: msgData.message.message, // æå–å¥½å‹ç”³è¯·æ¶ˆæ¯
                            timestamp: Date.now() + i * 100
                        };
                    } else {
                        // å¯¹äºæ™®é€šçš„æ–‡æœ¬æ¶ˆæ¯
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            name: msgData.name,
                            senderId: senderId,
                            content: msgData.message, // å†…å®¹æœ¬èº«æ˜¯å­—ç¬¦ä¸²
                            timestamp: Date.now() + i * 100
                        };
                    }
                    // --- ä¿®å¤ç»“æŸ ---
                        } else {
                    // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘æ£€æŸ¥æ˜¯å¦æ˜¯ç‰¹æ®Šç±»å‹å¯¹è±¡ä½†æœªè¢«ä¸Šé¢çš„æ¡ä»¶æ•è·
                    if (typeof msgData === 'object' && msgData !== null) {
                        if (msgData.type === 'transfer') {
                            // è½¬è´¦å¯¹è±¡è¢«é—æ¼äº†ï¼Œé‡æ–°å¤„ç†
                            aiMessage = { 
                                id: (Date.now() + i).toString(), 
                                sender: 'received', 
                                type: 'transfer', 
                                amount: msgData.amount, 
                                note: msgData.note, 
                                timestamp: Date.now() + i * 100 
                            };
                        } else if (msgData.type === 'voice_message') {
                            // è¯­éŸ³æ¶ˆæ¯å¯¹è±¡è¢«é—æ¼äº†ï¼Œé‡æ–°å¤„ç†
                            aiMessage = { 
                                id: (Date.now() + i).toString(), 
                                sender: 'received', 
                                type: 'voice_message', 
                                content: msgData.content, 
                                timestamp: Date.now() + i * 100 
                            };
                        } else if (msgData.type === 'ai_image') {
                            // AIå›¾ç‰‡å¯¹è±¡è¢«é—æ¼äº†ï¼Œé‡æ–°å¤„ç†
                            aiMessage = { 
                                id: (Date.now() + i).toString(), 
                                sender: 'received', 
                                type: 'ai_image', 
                                content: '', 
                                image: `data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="200" height="150" viewBox="0 0 200 150"><rect width="200" height="150" fill="#f0f0f0"/><text x="100" y="75" text-anchor="middle" font-family="Arial" font-size="12" fill="#666">[AIæè¿°çš„å›¾ç‰‡]</text></svg>')}`, 
                                imageDescription: msgData.description, 
                                timestamp: Date.now() + i * 100 
                            };
                        } else if (msgData.type === 'emoji') {
                            // ğŸ”¥ã€ä¿®å¤ã€‘è¡¨æƒ…åŒ…å¯¹è±¡è¢«é—æ¼äº†ï¼Œé‡æ–°å¤„ç† - æ”¯æŒç¾¤èŠ
                            console.log('ğŸ” [é—æ¼è¡¨æƒ…åŒ…] æ£€æµ‹åˆ°é—æ¼çš„è¡¨æƒ…åŒ…å¯¹è±¡:', msgData);

                            const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.description);
                            if (matchingEmoji) {
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    content: '',
                                    image: matchingEmoji.url,
                                    isEmoji: true,
                                    emojiDescription: matchingEmoji.description,
                                    timestamp: Date.now() + i * 100
                                };

                                // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘å¦‚æœæ˜¯ç¾¤èŠï¼Œéœ€è¦è®¾ç½®å‘é€è€…ä¿¡æ¯
                                if (currentChatCharacter && currentChatCharacter.isGroup) {
                                    // å¯¹äºç¾¤èŠä¸­çš„è¡¨æƒ…åŒ…ï¼Œéœ€è¦æŒ‡å®šæ˜¯å“ªä¸ªè§’è‰²å‘é€çš„
                                    // ç”±äºè¿™æ˜¯åœ¨å¤„ç†é—æ¼çš„è¡¨æƒ…åŒ…å¯¹è±¡ï¼Œæˆ‘ä»¬éœ€è¦ä»å½“å‰ç¾¤èŠä¸­é€‰æ‹©ä¸€ä¸ªé»˜è®¤è§’è‰²
                                    if (currentChatCharacter.members && currentChatCharacter.members.length > 0) {
                                        const defaultMember = currentChatCharacter.members[0];
                                        aiMessage.name = defaultMember.name;
                                        aiMessage.senderId = defaultMember.id;
                                        console.log('ğŸ” [é—æ¼è¡¨æƒ…åŒ…] è®¾ç½®é»˜è®¤å‘é€è€…:', defaultMember.name, 'ID:', defaultMember.id);
                                    }
                                }

                                console.log('ğŸ” [é—æ¼è¡¨æƒ…åŒ…] åˆ›å»ºçš„æ¶ˆæ¯å¯¹è±¡:', aiMessage);

                                addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                            } else {
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    content: `[è¡¨æƒ…åŒ…"${msgData.description}"ä¸å­˜åœ¨]`,
                                    timestamp: Date.now() + i * 100
                                };

                                // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘é”™è¯¯æ¶ˆæ¯ä¹Ÿéœ€è¦ç¾¤èŠå‘é€è€…ä¿¡æ¯
                                if (currentChatCharacter && currentChatCharacter.isGroup) {
                                    if (currentChatCharacter.members && currentChatCharacter.members.length > 0) {
                                        const defaultMember = currentChatCharacter.members[0];
                                        aiMessage.name = defaultMember.name;
                                        aiMessage.senderId = defaultMember.id;
                                    }
                                }
                            }
                        } else {
                            // å…¶ä»–å¯¹è±¡ç±»å‹ï¼Œå°è¯•æå–æ–‡æœ¬å†…å®¹
                            const displayContent = msgData.content || msgData.message || msgData.text || msgData.reply || '[ä¸æ”¯æŒçš„æ¶ˆæ¯æ ¼å¼]';
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: displayContent, timestamp: Date.now() + i * 100 };
                        }
                                            } else {
                        // æ™®é€šå­—ç¬¦ä¸²æˆ–å…¶ä»–åŸºæœ¬ç±»å‹
                        const displayContent = String(msgData);
                        aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: displayContent, timestamp: Date.now() + i * 100 };
                    }
                        }
                                            } else {
                // ğŸ”¥ã€å…³é”®ä¿®å¤ - regenerateLastResponseç‰ˆæœ¬ã€‘æ£€æŸ¥æ˜¯å¦æ˜¯ç‰¹æ®Šç±»å‹å¯¹è±¡ä½†æœªè¢«ä¸Šé¢çš„æ¡ä»¶æ•è·
                if (typeof msgData === 'object' && msgData !== null) {
                    if (msgData.type === 'transfer') {
                        // è½¬è´¦å¯¹è±¡è¢«é—æ¼äº†ï¼Œé‡æ–°å¤„ç†
                        aiMessage = { 
                            id: (Date.now() + i).toString(), 
                            sender: 'received', 
                            type: 'transfer', 
                            amount: msgData.amount, 
                            note: msgData.note, 
                            timestamp: Date.now() + i * 100 
                        };
                    } else if (msgData.type === 'voice_message') {
                        // è¯­éŸ³æ¶ˆæ¯å¯¹è±¡è¢«é—æ¼äº†ï¼Œé‡æ–°å¤„ç†
                        aiMessage = { 
                            id: (Date.now() + i).toString(), 
                            sender: 'received', 
                            type: 'voice_message', 
                            content: msgData.content, 
                            timestamp: Date.now() + i * 100 
                        };
                    } else if (msgData.type === 'ai_image') {
                        // AIå›¾ç‰‡å¯¹è±¡è¢«é—æ¼äº†ï¼Œé‡æ–°å¤„ç†
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'ai_image',
                            content: msgData.description || 'AIæè¿°çš„å›¾ç‰‡',
                            imageDescription: msgData.description,
                            timestamp: Date.now() + i * 100
                        };

                        // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘å¦‚æœæ˜¯ç¾¤èŠæ¶ˆæ¯ï¼Œæ·»åŠ å‘é€è€…ä¿¡æ¯
                        if (msgData.name) {
                            console.log('ğŸ” [ç¬¬å››å¤„-AIå›¾ç‰‡] æ£€æµ‹åˆ°ç¾¤èŠæ¶ˆæ¯ï¼Œå‘é€è€…:', msgData.name);
                            aiMessage.name = msgData.name;
                            // æŸ¥æ‰¾å¯¹åº”çš„ç¾¤æˆå‘˜ID
                            if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                                const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                                if (member) {
                                    aiMessage.senderId = member.id;
                                    console.log('ğŸ” [ç¬¬å››å¤„-AIå›¾ç‰‡] æ‰¾åˆ°ç¾¤æˆå‘˜ID:', member.id);
                                } else {
                                    console.log('ğŸ” [ç¬¬å››å¤„-AIå›¾ç‰‡] æœªæ‰¾åˆ°ç¾¤æˆå‘˜:', msgData.name);
                                }
                            }
                        }
                    } else if (msgData.type === 'emoji') {
                        // è¡¨æƒ…åŒ…å¯¹è±¡è¢«é—æ¼äº†ï¼Œé‡æ–°å¤„ç†
                        const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.description);
                        if (matchingEmoji) {
                            aiMessage = { 
                                id: (Date.now() + i).toString(), 
                                sender: 'received', 
                                content: '', 
                                image: matchingEmoji.url, 
                                isEmoji: true, 
                                emojiDescription: matchingEmoji.description, 
                                timestamp: Date.now() + i * 100 
                            };
                            addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                        } else {
                            aiMessage = { 
                                id: (Date.now() + i).toString(), 
                                sender: 'received', 
                                content: `[è¡¨æƒ…åŒ…"${msgData.description}"ä¸å­˜åœ¨]`, 
                                timestamp: Date.now() + i * 100 
                            };
                        }
                    } else {
                        // å…¶ä»–å¯¹è±¡ç±»å‹ï¼Œå°è¯•æå–æ–‡æœ¬å†…å®¹
                        const displayContent = msgData.content || msgData.message || msgData.text || msgData.reply || '[ä¸æ”¯æŒçš„æ¶ˆæ¯æ ¼å¼]';
                        aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: displayContent, timestamp: Date.now() + i * 100 };
                    }
                } else if (typeof msgData === 'string') {
                    // æ™®é€šå­—ç¬¦ä¸²
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: msgData, timestamp: Date.now() + i * 100 };
                } else {
                    // å…¶ä»–åŸºæœ¬ç±»å‹
                aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: String(msgData), timestamp: Date.now() + i * 100 };
                }
                    }
                    
                    chatMessages[characterId].push(aiMessage);
            await saveChatMessages();

            // ğŸ”¥ã€æ–°å¢ã€‘è®°å½•AIå›å¤åˆ°å…¨å±€è®°å¿†äº‹ä»¶
            const character = characters.find(c => c.id === characterId);
            if (character) {
                // ğŸ”¥ã€ä¿®å¤ã€‘æ„å»ºå®‰å…¨çš„äº‹ä»¶æ•°æ®ï¼Œé¿å…å¾ªç¯å¼•ç”¨
                const eventData = {
                    sender: characterId,
                    content: aiMessage.content || '[ç‰¹æ®Šæ¶ˆæ¯]',
                    messageType: aiMessage.type || 'text'
                };

                // ğŸ”¥ã€ä¿®å¤ã€‘å¦‚æœæ˜¯å¼•ç”¨æ¶ˆæ¯ï¼Œæ·»åŠ å¼•ç”¨ä¿¡æ¯ä½†é¿å…å¯¹è±¡åµŒå¥—
                if (aiMessage.replyTo) {
                    eventData.replyToId = aiMessage.replyTo.id;
                    eventData.replyToSender = aiMessage.replyTo.senderName;
                    eventData.replyToContent = aiMessage.replyTo.content;
                }

                await recordMemoryEvent(
                    [characterId, 'user'],
                    {
                        type: character.isGroup ? 'group_chat' : 'private_chat',
                        id: characterId
                    },
                    'message',
                    eventData,
                    0.7 // AIæ¶ˆæ¯é‡è¦æ€§
                );
            }

                    // ğŸ”¥ã€ä¿®å¤ã€‘åœ¨ç¬¬ä¸€æ¡æ¶ˆæ¯å¤„ç†å®Œåéšè—"æ­£åœ¨è¾“å…¥ä¸­"
                    if (i === 0) {
                        hideTypingIndicator();
                    }

                    // ğŸ”¥ã€ä¿®å¤ã€‘ä½¿ç”¨addMessageWithAnimationæ·»åŠ å•ä¸ªæ¶ˆæ¯ï¼Œè€Œä¸æ˜¯é‡æ–°æ¸²æŸ“æ•´ä¸ªåˆ—è¡¨
                    addMessageWithAnimation(aiMessage, characterId);

                    // ğŸ”¥ã€ä¿®å¤ã€‘åœ¨æ¶ˆæ¯ä¹‹é—´æ­£ç¡®æ˜¾ç¤º"æ­£åœ¨è¾“å…¥ä¸­"æç¤º
                    if (i < aiMessages.length - 1) {
                        const delay = Math.random() * 1000 + 500;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        showTypingIndicator();
                        await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));
                        hideTypingIndicator();
                    }
                }
            } catch (error) {
                console.error('é‡æ–°ç”Ÿæˆå¤±è´¥:', error);
                hideTypingIndicator();
                const errorMessage = {
                    id: Date.now().toString(),
                    sender: 'received',
                    content: `[é‡æ–°ç”Ÿæˆå¤±è´¥: ${error.message}]`,
                    timestamp: Date.now()
                };
                chatMessages[characterId].push(errorMessage);
        await saveChatMessages();
                renderChatMessages(characterId);
            } finally {
                // ğŸ”¥ã€ä¿®å¤ã€‘åœ¨è¿™é‡Œä¹Ÿæ¸…é™¤å¾…å›å¤æ¶ˆæ¯ï¼Œå¹¶é‡ç½®é‡æ–°ç”Ÿæˆæ ‡å¿—
                pendingUserMessage = null;
                window._isRegenerating = false;
            }
            
            updateFloatingButtonsVisibility();
        }

        // æ™ºèƒ½å›å¤åŠŸèƒ½
        function triggerSmartReply() {
            if (!currentChatCharacter) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè§’è‰²');
                return;
            }

            if (isWaitingForReply) {
                // ğŸ”¥ã€ä¿®å¤ã€‘ä¸ä½¿ç”¨å¼¹çª—ï¼Œæ”¹ä¸ºæ˜¾ç¤ºæŒ‰é’®çŠ¶æ€æç¤º
                return;
            }

            const messages = chatMessages[currentChatCharacter.id] || [];
            
            // æ‰¾åˆ°æœ€åä¸€æ¡ç”¨æˆ·æ¶ˆæ¯
            let lastUserMessage = null;
            let hasUnrepliedUserMessage = false;
            
            for (let i = messages.length - 1; i >= 0; i--) {
                if (messages[i].sender === 'sent') {
                    lastUserMessage = messages[i];
                    
                    // æ£€æŸ¥è¿™æ¡ç”¨æˆ·æ¶ˆæ¯åæ˜¯å¦æœ‰AIå›å¤
                    hasUnrepliedUserMessage = true;
                    for (let j = i + 1; j < messages.length; j++) {
                        if (messages[j].sender === 'received') {
                            hasUnrepliedUserMessage = false;
                            break;
                        }
                    }
                    break;
                }
            }
            
            // æƒ…å†µ1ï¼šæœ‰æœªå›å¤çš„ç”¨æˆ·æ¶ˆæ¯
            if (lastUserMessage && hasUnrepliedUserMessage) {
                pendingUserMessage = lastUserMessage;
            processAIReply();
                return;
            }
            
            // æƒ…å†µ2ï¼šæœ€åçš„ç”¨æˆ·æ¶ˆæ¯å·²æœ‰AIå›å¤ï¼Œéœ€è¦AIç»­å†™
            if (lastUserMessage && !hasUnrepliedUserMessage) {
                // æ£€æŸ¥ä»æœ€åä¸€æ¡ç”¨æˆ·æ¶ˆæ¯åçš„AIå›å¤å›åˆæ•°
                let aiReplyRounds = 0;
                let lastUserMessageIndex = -1;
                
                // æ‰¾åˆ°æœ€åä¸€æ¡ç”¨æˆ·æ¶ˆæ¯çš„ç´¢å¼•
                for (let i = messages.length - 1; i >= 0; i--) {
                    if (messages[i].sender === 'sent') {
                        lastUserMessageIndex = i;
                        break;
                    }
                }
                
                // è®¡ç®—ä»æœ€åä¸€æ¡ç”¨æˆ·æ¶ˆæ¯åçš„AIå›å¤å›åˆæ•°
                // ä¸€å›åˆ = è¿ç»­çš„AIæ¶ˆæ¯ç›´åˆ°ä¸‹ä¸€ä¸ªæ–­ç‚¹
                if (lastUserMessageIndex !== -1) {
                    let inAIReplyRound = false;
                    
                    for (let i = lastUserMessageIndex + 1; i < messages.length; i++) {
                        if (messages[i].sender === 'received') {
                            if (!inAIReplyRound) {
                                // å¼€å§‹æ–°çš„AIå›å¤å›åˆ
                                aiReplyRounds++;
                                inAIReplyRound = true;
                            }
                            // ç»§ç»­å½“å‰å›åˆï¼ˆå¤šæ¡è¿ç»­AIæ¶ˆæ¯ç®—ä¸€å›åˆï¼‰
                        } else {
                            // å¦‚æœæœ‰å…¶ä»–ç±»å‹æ¶ˆæ¯ï¼Œç»“æŸå½“å‰å›åˆ
                            inAIReplyRound = false;
                        }
                    }
                }
                
                // AIå›å¤é€»è¾‘ï¼š
                // aiReplyRounds = 0: æ²¡æœ‰å›å¤ç”¨æˆ·æ¶ˆæ¯ï¼Œä¸åº”è¯¥åˆ°è¿™é‡Œ
                // aiReplyRounds = 1: å·²å›å¤ç”¨æˆ·æ¶ˆæ¯1å›åˆï¼Œç°åœ¨æ˜¯ç¬¬1æ¬¡ç»­å†™ï¼ˆç¬¬2å›åˆï¼‰
                // aiReplyRounds = 2: å·²å›å¤+ç»­å†™1å›åˆï¼Œç°åœ¨æ˜¯ç¬¬2æ¬¡ç»­å†™ï¼ˆç¬¬3å›åˆï¼‰
                // aiReplyRounds >= 3: å·²å›å¤+ç»­å†™2å›åˆï¼Œæç¤ºç”¨æˆ·å‘æ¶ˆæ¯
                
                if (aiReplyRounds >= 3) {
                    const characterName = currentChatCharacter.name;
                    alert(`${characterName}å·²ç»è¯´äº†å¾ˆå¤šè¯äº†ï¼Œå…ˆå’Œ${characterName}è¯´è¯´è¯å§~`);
                    return;
                }
                
                // ğŸ”¥ã€ä¿®å¤ã€‘åœ¨ç»­å†™å‰ä¹Ÿè¦æ£€æŸ¥æ˜¯å¦æœ‰æœªå¤„ç†çš„è½¬è´¦
                const lastUserTransfer = messages.slice().reverse().find(msg => 
                    msg.sender === 'sent' && msg.type === 'transfer' && !msg.status);
                if (lastUserTransfer) {
                    // å¦‚æœæœ‰æœªå¤„ç†çš„è½¬è´¦ï¼Œå…ˆè®¾ç½®ä¸ºå¾…å¤„ç†ï¼Œç„¶åå¤„ç†å›å¤
                    pendingUserMessage = lastUserTransfer;
                    processAIReply();
                    return;
                }
                
                // AIç»­å†™å¯¹è¯ï¼ˆç¬¬1æ¬¡æˆ–ç¬¬2æ¬¡ç»­å†™ï¼‰
                processAIContinuation();
                return;
            }
            
            // æƒ…å†µ3ï¼šæ²¡æœ‰ç”¨æˆ·æ¶ˆæ¯
            alert('è¯·å…ˆå‘é€ä¸€æ¡æ¶ˆæ¯ï¼Œç„¶åç‚¹å‡»æ­¤æŒ‰é’®æ¥è·å–AIå›å¤');
        }

                // å¤„ç†AIç»­å†™å¯¹è¯
        async function processAIContinuation() {
            if (!currentChatCharacter) return;
            
            // é˜²æ­¢é‡å¤è°ƒç”¨
            if (isWaitingForReply) {
                console.log('AIæ­£åœ¨ç»­å†™ä¸­ï¼Œå¿½ç•¥é‡å¤è°ƒç”¨');
                return;
            }
            
            // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘è®°å½•å½“å‰èŠå¤©è§’è‰²IDï¼Œç¡®ä¿AIç»­å†™æ¶ˆæ¯å½’å±åˆ°æ­£ç¡®çš„èŠå¤©çª—å£
            const continuingCharacterId = currentChatCharacter.id;

            isWaitingForReply = true;
            
            // æ›´æ–°æ™ºèƒ½å›å¤æŒ‰é’®çŠ¶æ€
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.disabled = true;
                smartReplyBtn.style.opacity = '0.65';
                smartReplyBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            }

            // æ˜¾ç¤ºæ­£åœ¨è¾“å…¥æç¤º
            showTypingIndicator();
            
            // æ·»åŠ éšæœºå»¶è¿Ÿ
            const delay = Math.random() * 2000 + 1000;
            await new Promise(resolve => setTimeout(resolve, delay));

            try {
                // è·å–AIæœ€åçš„æ¶ˆæ¯å†…å®¹ï¼Œä»¥ä¾¿åŸºäºæ­¤ç»­å†™
                const messages = chatMessages[continuingCharacterId] || [];
                let lastAIMessage = "";
                
                // æ‰¾åˆ°æœ€åä¸€æ¡AIæ¶ˆæ¯
                for (let i = messages.length - 1; i >= 0; i--) {
                    if (messages[i].sender === 'received') {
                        lastAIMessage = messages[i].content || "";
                        break;
                    }
                }
                
                // æ„å»ºç»­å†™æç¤ºè¯ï¼ŒåŸºäºAIè‡ªå·±æœ€åçš„è¯æ¥ç»­å†™
                let continuationPrompt = "ä½ åˆšæ‰è¯´äº†ï¼š\"" + lastAIMessage + "\"\n\n";
                continuationPrompt += "ç°åœ¨è¯·åŸºäºä½ åˆšæ‰è¯´çš„è¯ï¼Œä¸»åŠ¨ç»§ç»­è¿™ä¸ªè¯é¢˜æˆ–è€…è‡ªç„¶åœ°è½¬åˆ°ç›¸å…³è¯é¢˜ã€‚å°±åƒçœŸå®èŠå¤©ä¸­ï¼Œä½ æƒ³è¦ç»§ç»­è¡¨è¾¾æ›´å¤šæƒ³æ³•ï¼Œæˆ–è€…è¯¢é—®å¯¹æ–¹çš„çœ‹æ³•ï¼Œæˆ–è€…åˆ†äº«ç›¸å…³çš„å†…å®¹ã€‚è¯·è‡ªç„¶åœ°ç»§ç»­å¯¹è¯ï¼Œä¸è¦é‡å¤ä¹‹å‰è¯´è¿‡çš„è¯ã€‚";
                continuationPrompt += "\n\nğŸš¨ é‡è¦æé†’ï¼šè¯·ä¸¥æ ¼éµå®ˆJSONæ ¼å¼ï¼Œæ¯æ¡æ¶ˆæ¯å¿…é¡»åˆ†å¼€å‘é€ï¼Œç»å¯¹ä¸èƒ½å°†å¤šæ¡æ¶ˆæ¯åˆå¹¶åœ¨ä¸€ä¸ªå…ƒç´ ä¸­ï¼æ­£ç¡®æ ¼å¼ï¼š[\"æ¶ˆæ¯1\", \"æ¶ˆæ¯2\"]ï¼Œé”™è¯¯æ ¼å¼ï¼š[\"æ¶ˆæ¯1\\næ¶ˆæ¯2\"]";
                
                const response = await callChatAPI(continuationPrompt, currentChatCharacter);
                const aiMessages = parseAiResponse(response);
                
                // ğŸ”¥ã€ä¿®å¤ã€‘åœ¨ç»­å†™æ—¶ä¹Ÿè¦æ£€æŸ¥æ˜¯å¦æœ‰è½¬è´¦éœ€è¦å¤„ç†
                const chatHistory = chatMessages[continuingCharacterId] || [];
                const lastUserMessage = chatHistory.slice().reverse().find(msg => 
                    msg.sender === 'sent' && msg.type === 'transfer' && !msg.status);
                if (lastUserMessage) {
                    console.log('ğŸ”¥ [ç»­å†™] æ£€æµ‹åˆ°ç”¨æˆ·è½¬è´¦æ¶ˆæ¯ï¼Œå¼€å§‹å¤„ç†è½¬è´¦:', {
                        lastUserMessage,
                        aiMessages,
                        characterName: currentChatCharacter?.name
                    });
                    await processUserTransfer(lastUserMessage, aiMessages);
                }
                
                hideTypingIndicator();
                
                // é€æ¡å‘é€æ¶ˆæ¯
                for (let i = 0; i < aiMessages.length; i++) {
                    const msgData = aiMessages[i];
                    let aiMessage;
                    
                    if (typeof msgData === 'object' && msgData.type === 'recall_previous') {
                        // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†AIæ’¤å›ä¸Šä¸€æ¡æ¶ˆæ¯
                        console.log('ğŸ”¥ [ç»­å†™] AIè¯·æ±‚æ’¤å›ä¸Šä¸€æ¡æ¶ˆæ¯:', msgData);

                        // æŸ¥æ‰¾ä¸Šä¸€æ¡AIæ¶ˆæ¯
                        const allMessages = chatMessages[continuingCharacterId] || [];
                        let lastAIMessageIndex = -1;

                        for (let j = allMessages.length - 1; j >= 0; j--) {
                            if (allMessages[j].sender === 'received') {
                                lastAIMessageIndex = j;
                                break;
                            }
                        }

                        if (lastAIMessageIndex !== -1) {
                            const messageToRecall = allMessages[lastAIMessageIndex];
                            console.log('ğŸ”¥ [ç»­å†™] æ‰¾åˆ°è¦æ’¤å›çš„æ¶ˆæ¯:', messageToRecall);

                            // è°ƒç”¨æ’¤å›æ¶ˆæ¯å¤„ç†å‡½æ•°
                            await handleRecalledMessage(messageToRecall.content, messageToRecall.id);
                        } else {
                            console.warn('ğŸ”¥ [ç»­å†™] æ²¡æœ‰æ‰¾åˆ°å¯æ’¤å›çš„AIæ¶ˆæ¯');
                        }
                        continue; // è·³è¿‡æ­£å¸¸çš„æ¶ˆæ¯å¤„ç†æµç¨‹
                    } else if (typeof msgData === 'object' && msgData.type === 'voice_message') {
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'voice_message',
                            content: msgData.content,
                            timestamp: Date.now() + i * 100
                        };
                    } else if (typeof msgData === 'object' && msgData.type === 'ai_image') {
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'ai_image',
                            content: msgData.description || 'AIæè¿°çš„å›¾ç‰‡',
                            imageDescription: msgData.description,
                            timestamp: Date.now() + i * 100
                        };

                        // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘å¦‚æœæ˜¯ç¾¤èŠæ¶ˆæ¯ï¼Œæ·»åŠ å‘é€è€…ä¿¡æ¯
                        if (msgData.name) {
                            console.log('ğŸ” [ç¬¬ä¸‰å¤„-AIå›¾ç‰‡] æ£€æµ‹åˆ°ç¾¤èŠæ¶ˆæ¯ï¼Œå‘é€è€…:', msgData.name);
                            aiMessage.name = msgData.name;
                            // æŸ¥æ‰¾å¯¹åº”çš„ç¾¤æˆå‘˜ID
                            if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                                const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                                if (member) {
                                    aiMessage.senderId = member.id;
                                    console.log('ğŸ” [ç¬¬ä¸‰å¤„-AIå›¾ç‰‡] æ‰¾åˆ°ç¾¤æˆå‘˜ID:', member.id);
                                } else {
                                    console.log('ğŸ” [ç¬¬ä¸‰å¤„-AIå›¾ç‰‡] æœªæ‰¾åˆ°ç¾¤æˆå‘˜:', msgData.name);
                                }
                            }
                        }
                    } else if (typeof msgData === 'object' && msgData.type === 'transfer') {
                        aiMessage = { 
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'transfer', 
                            amount: msgData.amount, 
                            note: msgData.note, 
                            timestamp: Date.now() + i * 100
                        };
                    } else if (typeof msgData === 'object' && msgData.type === 'emoji') {
                        // å¤„ç†AIå‘é€çš„è¡¨æƒ…åŒ… - ä»æœ¬åœ°è¡¨æƒ…åŒ…åº“ä¸­æŸ¥æ‰¾
                        const matchingEmoji = customEmojis.find(emoji => 
                            emoji.description === msgData.description
                        );
                        
                        if (matchingEmoji) {
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                content: '',
                                image: matchingEmoji.url,
                                isEmoji: true,
                                emojiDescription: matchingEmoji.description,
                                timestamp: Date.now() + i * 100
                            };

                            // ğŸ”¥ã€ä¿®å¤ã€‘å¦‚æœæ˜¯ç¾¤èŠæ¶ˆæ¯ï¼Œæ·»åŠ å‘é€è€…ä¿¡æ¯
                            if (msgData.name) {
                                aiMessage.name = msgData.name;
                                // æŸ¥æ‰¾å¯¹åº”çš„ç¾¤æˆå‘˜ID
                                if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                                    const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                                    if (member) {
                                        aiMessage.senderId = member.id;
                                    }
                                }
                            }

                            // å°†è¡¨æƒ…åŒ…æ·»åŠ åˆ°æœ€è¿‘ä½¿ç”¨
                            addToRecentEmojis({
                                id: matchingEmoji.id,
                                url: matchingEmoji.url,
                                description: matchingEmoji.description
                            });
                        } else {
                            // å¦‚æœæ‰¾ä¸åˆ°è¡¨æƒ…åŒ…ï¼Œæ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
                            aiMessage = { 
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                content: `[è¡¨æƒ…åŒ…"${msgData.description}"ä¸å­˜åœ¨]`,
                                timestamp: Date.now() + i * 100
                            };
                        }
                    } else if (typeof msgData === 'object' && msgData.type === 'change_avatar') {
                        // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†å¤´åƒæ›´æ¢å¯¹è±¡
                        console.log('å¤„ç†å¤´åƒæ›´æ¢æ¶ˆæ¯(ç»­å†™):', msgData);
                        if (msgData.avatar_url) {
                            // ğŸ”¥ã€ä¿®å¤ã€‘å…ˆå¤„ç†å ä½ç¬¦æ›¿æ¢ï¼Œå†éªŒè¯å’Œæ‰§è¡Œå¤´åƒæ›´æ¢
                            let actualAvatarUrl = msgData.avatar_url;
                            if (msgData.avatar_url === 'CURRENT_USER_IMAGE' ||
                                msgData.avatar_url === 'CURRENT_USER_IMAGE' ||
                                msgData.avatar_url === 'ç”¨æˆ·å‘é€çš„å›¾ç‰‡URL' ||
                                msgData.avatar_url === 'å›¾ç‰‡URL') {
                                const recentUserImage = getRecentUserImage();
                                if (recentUserImage) {
                                    actualAvatarUrl = recentUserImage;
                                } else {
                                    aiMessage = {
                                        id: (Date.now() + i).toString(),
                                        sender: 'received',
                                        content: '[æ— æ³•æ›´æ¢å¤´åƒï¼Œæ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„å›¾ç‰‡]',
                                        timestamp: Date.now() + i * 100
                                    };
                                    continue;
                                }
                            }

                            // éªŒè¯å¤´åƒURLæ˜¯å¦æ¥è‡ªç”¨æˆ·å‘é€çš„å›¾ç‰‡æˆ–ä¸–ç•Œä¹¦ä¸­çš„URL
                            const isValidAvatar = await validateAvatarSource(actualAvatarUrl);
                            console.log('å¤´åƒæ¥æºéªŒè¯ç»“æœ(ç»­å†™):', isValidAvatar, 'å¤´åƒURL:', actualAvatarUrl);

                            if (isValidAvatar) {
                                // æ‰§è¡Œå¤´åƒæ›´æ¢
                                const success = await changeCharacterAvatarByAI(actualAvatarUrl, msgData.reason || 'å¿ƒæƒ…å˜åŒ–');
                                console.log('å¤´åƒæ›´æ¢æ‰§è¡Œç»“æœ(ç»­å†™):', success);
                                if (success) {
                                    // è·³è¿‡è¿™æ¡æ¶ˆæ¯ï¼Œåªæ‰§è¡Œå¤´åƒæ›´æ¢ï¼Œç³»ç»Ÿæ¶ˆæ¯å·²åœ¨changeCharacterAvatarByAIä¸­æ·»åŠ 
                                    continue;
                                } else {
                                    aiMessage = {
                                        id: (Date.now() + i).toString(),
                                        sender: 'received',
                                        content: '[å¤´åƒæ›´æ¢å¤±è´¥]',
                                        timestamp: Date.now() + i * 100
                                    };
                                }
                            } else {
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    content: '[æ— æ•ˆçš„å¤´åƒæ¥æºï¼Œå¤´åƒæ›´æ¢å¤±è´¥]',
                                    timestamp: Date.now() + i * 100
                                };
                            }
                        } else {
                            console.log('å¤´åƒæ›´æ¢æ¶ˆæ¯ç¼ºå°‘avatar_url(ç»­å†™)');
                            continue; // å¦‚æœæ²¡æœ‰æœ‰æ•ˆçš„å¤´åƒURLï¼Œè·³è¿‡æ­¤æ¶ˆæ¯
                        }
                    } else if (typeof msgData === 'object' && msgData !== null && msgData.name && msgData.message) {
                        // ğŸ”¥ã€ç¾¤èŠæ¶ˆæ¯å…³é”®ä¿®å¤ã€‘ç¾¤èŠæ¶ˆæ¯æ ¼å¼: {name: "è§’è‰²å", message: "æ¶ˆæ¯å†…å®¹"}
                        console.log('ğŸ”¥ [ä¿®å¤continuation] å‘ç°ç¾¤èŠæ¶ˆæ¯:', msgData);
                        
                        // æŸ¥æ‰¾ç¾¤æˆå‘˜ID
                        let senderId = null;
                        if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                            const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                            if (member) {
                                senderId = member.id;
                            }
                        }
                        
                        // --- å…³é”®ä¿®å¤ï¼šæ£€æŸ¥ç¾¤èŠæ¶ˆæ¯å†…å®¹æ˜¯å¦ä¸ºç‰¹æ®Šç±»å‹ ---
                        if (typeof msgData.message === 'object' && msgData.message.type === 'voice_message') {
                            // å¦‚æœæ¶ˆæ¯å†…å®¹æ˜¯ä¸€ä¸ªè¯­éŸ³æ¶ˆæ¯å¯¹è±¡
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                type: 'voice_message', // åœ¨å¤–å±‚æ¶ˆæ¯ä¸Šè®¾ç½®æ­£ç¡®çš„ç±»å‹
                                name: msgData.name,
                                senderId: senderId,
                                content: msgData.message.content, // æå–çœŸæ­£çš„è¯­éŸ³æ–‡å­—å†…å®¹
                                timestamp: Date.now() + i * 100
                            };
                        } else {
                            // å¯¹äºæ™®é€šçš„æ–‡æœ¬æ¶ˆæ¯
                        aiMessage = { 
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            name: msgData.name,          // ä¿å­˜å‘è¨€è€…åå­—
                            senderId: senderId,          // ä¿å­˜å‘è¨€è€…ID
                            content: msgData.message,    // ä½¿ç”¨messageå­—æ®µä½œä¸ºå†…å®¹
                            timestamp: Date.now() + i * 100
                        };
                        }
                        // --- ä¿®å¤ç»“æŸ ---
                        console.log('âœ… [ä¿®å¤continuation] ç¾¤èŠæ¶ˆæ¯å·²æ­£ç¡®è§£æ:', aiMessage);
                                            } else {
                        // ğŸ”¥ã€å…³é”®ä¿®å¤ - ç»­å†™ç‰ˆæœ¬ã€‘æ£€æŸ¥æ˜¯å¦æ˜¯ç‰¹æ®Šç±»å‹å¯¹è±¡ä½†æœªè¢«ä¸Šé¢çš„æ¡ä»¶æ•è·
                        if (typeof msgData === 'object' && msgData !== null) {
                            if (msgData.type === 'transfer') {
                                // è½¬è´¦å¯¹è±¡è¢«é—æ¼äº†ï¼Œé‡æ–°å¤„ç†
                                aiMessage = { 
                                    id: (Date.now() + i).toString(), 
                                    sender: 'received', 
                                    type: 'transfer', 
                                    amount: msgData.amount, 
                                    note: msgData.note, 
                                    timestamp: Date.now() + i * 100 
                                };
                            } else if (msgData.type === 'voice_message') {
                                // è¯­éŸ³æ¶ˆæ¯å¯¹è±¡è¢«é—æ¼äº†ï¼Œé‡æ–°å¤„ç†
                                aiMessage = { 
                                    id: (Date.now() + i).toString(), 
                                    sender: 'received', 
                                    type: 'voice_message', 
                                    content: msgData.content, 
                                    timestamp: Date.now() + i * 100 
                                };
                            } else if (msgData.type === 'ai_image') {
                                // AIå›¾ç‰‡å¯¹è±¡è¢«é—æ¼äº†ï¼Œé‡æ–°å¤„ç†
                                aiMessage = {
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    type: 'ai_image',
                                    content: msgData.description || 'AIæè¿°çš„å›¾ç‰‡',
                                    imageDescription: msgData.description,
                                    timestamp: Date.now() + i * 100
                                };

                                // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘å¦‚æœæ˜¯ç¾¤èŠæ¶ˆæ¯ï¼Œæ·»åŠ å‘é€è€…ä¿¡æ¯
                                if (msgData.name) {
                                    console.log('ğŸ” [ç¬¬äº”å¤„-AIå›¾ç‰‡] æ£€æµ‹åˆ°ç¾¤èŠæ¶ˆæ¯ï¼Œå‘é€è€…:', msgData.name);
                                    aiMessage.name = msgData.name;
                                    // æŸ¥æ‰¾å¯¹åº”çš„ç¾¤æˆå‘˜ID
                                    if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                                        const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                                        if (member) {
                                            aiMessage.senderId = member.id;
                                            console.log('ğŸ” [ç¬¬äº”å¤„-AIå›¾ç‰‡] æ‰¾åˆ°ç¾¤æˆå‘˜ID:', member.id);
                                        } else {
                                            console.log('ğŸ” [ç¬¬äº”å¤„-AIå›¾ç‰‡] æœªæ‰¾åˆ°ç¾¤æˆå‘˜:', msgData.name);
                                        }
                                    }
                                }
                            } else if (msgData.type === 'emoji') {
                                // è¡¨æƒ…åŒ…å¯¹è±¡è¢«é—æ¼äº†ï¼Œé‡æ–°å¤„ç†
                                const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.description);
                                if (matchingEmoji) {
                                    aiMessage = {
                                        id: (Date.now() + i).toString(),
                                        sender: 'received',
                                        content: '',
                                        image: matchingEmoji.url,
                                        isEmoji: true,
                                        emojiDescription: matchingEmoji.description,
                                        timestamp: Date.now() + i * 100
                                    };

                                    // ğŸ”¥ã€ä¿®å¤ã€‘å¦‚æœæ˜¯ç¾¤èŠæ¶ˆæ¯ï¼Œæ·»åŠ å‘é€è€…ä¿¡æ¯
                                    if (msgData.name) {
                                        aiMessage.name = msgData.name;
                                        // æŸ¥æ‰¾å¯¹åº”çš„ç¾¤æˆå‘˜ID
                                        if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                                            const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                                            if (member) {
                                                aiMessage.senderId = member.id;
                                            }
                                        }
                                    }

                                    addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                                } else {
                                    aiMessage = { 
                                        id: (Date.now() + i).toString(), 
                                        sender: 'received', 
                                        content: `[è¡¨æƒ…åŒ…"${msgData.description}"ä¸å­˜åœ¨]`, 
                                        timestamp: Date.now() + i * 100 
                                    };
                                }
                            } else {
                                // å…¶ä»–å¯¹è±¡ç±»å‹ï¼Œå°è¯•æå–æ–‡æœ¬å†…å®¹
                                const displayContent = msgData.content || msgData.message || msgData.text || msgData.reply || '[ä¸æ”¯æŒçš„æ¶ˆæ¯æ ¼å¼]';
                                aiMessage = { 
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    content: displayContent, 
                                    timestamp: Date.now() + i * 100
                                };
                            }
                        } else if (typeof msgData === 'string') {
                            // æ™®é€šå­—ç¬¦ä¸²
                            aiMessage = { 
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                content: msgData, 
                                timestamp: Date.now() + i * 100
                            };
                        } else {
                            // å…¶ä»–åŸºæœ¬ç±»å‹
                        aiMessage = { 
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: String(msgData), 
                            timestamp: Date.now() + i * 100
                        };
                        }
                    }
                    
                    chatMessages[continuingCharacterId].push(aiMessage);
                    saveChatMessages();
                    addMessageWithAnimation(aiMessage, continuingCharacterId);
                    
                    // ğŸ”¥ã€ä¿®å¤ã€‘ä¸ºç»­å†™çš„æ¯æ¡æ¶ˆæ¯åˆ›å»ºæ¨é€é€šçŸ¥ - ä½¿ç”¨æ­£ç¡®çš„è§’è‰²å¯¹è±¡
                    if (typeof msgData === 'string' ||
                        (typeof msgData === 'object' && (msgData.type || (msgData.name && msgData.message)))) {
                        console.log('ğŸ”¥ [æ¨é€é€šçŸ¥] ç»­å†™æ¶ˆæ¯ï¼Œåˆ›å»ºæ¨é€é€šçŸ¥:', msgData);
                        // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘è·å–æ­£åœ¨ç»­å†™çš„è§’è‰²å¯¹è±¡ï¼Œè€Œä¸æ˜¯å½“å‰èŠå¤©è§’è‰²
                        const continuingCharacter = characters.find(c => c.id === continuingCharacterId);
                        if (continuingCharacter) {
                            createPushNotification(continuingCharacter, msgData, i * 500);
                        }
                    }
                    
                    if (i < aiMessages.length - 1) {
                        const delay = Math.random() * 1000 + 500;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        
                        if (i < aiMessages.length - 1) {
                            showTypingIndicator();
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));
                            hideTypingIndicator();
                        }
                    }
                }

                // ğŸ”¥ã€ä¿®å¤ã€‘AIç»­å†™å®Œæˆåæ›´æ–°æ¶ˆæ¯åˆ—è¡¨ï¼Œç¡®ä¿æœªè¯»æ¶ˆæ¯è®¡æ•°æ­£ç¡®
                renderMessageList();
            } catch (error) {
                console.error('AIç»­å†™å¤±è´¥:', error);
                hideTypingIndicator();

                const errorMessage = {
                    id: Date.now().toString(),
                    sender: 'received',
                    content: `[ç»­å†™å¤±è´¥: ${error.message}]`,
                    timestamp: Date.now()
                };

                chatMessages[continuingCharacterId].push(errorMessage);
                saveChatMessages();
                addMessageWithAnimation(errorMessage, continuingCharacterId);

                // ğŸ”¥ã€ä¿®å¤ã€‘é”™è¯¯æ¶ˆæ¯ä¹Ÿéœ€è¦æ›´æ–°æ¶ˆæ¯åˆ—è¡¨
                renderMessageList();
            } finally {
                // é‡ç½®çŠ¶æ€
                isWaitingForReply = false;
                pendingUserMessage = null;

                // æ¢å¤æ™ºèƒ½å›å¤æŒ‰é’®
                if (smartReplyBtn) {
                    smartReplyBtn.disabled = false;
                    smartReplyBtn.style.opacity = '';
                    smartReplyBtn.style.animation = 'none';
                    smartReplyBtn.classList.remove('waiting');
                    smartReplyBtn.innerHTML = '<i class="fas fa-comment-dots"></i>';
                    smartReplyBtn.title = 'è·å–AIå›å¤';
                }

                // æ›´æ–°æŒ‰é’®æ˜¾ç¤ºçŠ¶æ€
                updateFloatingButtonsVisibility();
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘ç»Ÿä¸€çš„æ¶ˆæ¯åˆ›å»ºå‡½æ•°ï¼Œå‡å°‘é‡å¤ä»£ç 
        function createAIMessage(msgData, index = 0) {
            const baseMessage = {
                id: (Date.now() + index).toString(),
                sender: 'received',
                timestamp: Date.now() + index * 100
            };

            // å¤„ç†ç¾¤èŠå‘é€è€…ä¿¡æ¯
            if (msgData.name && currentChatCharacter?.isGroup && currentChatCharacter.members) {
                const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                if (member) {
                    baseMessage.name = msgData.name;
                    baseMessage.senderId = member.id;
                    console.log(`ğŸ” [createAIMessage] è®¾ç½®ç¾¤èŠå‘é€è€…: ${msgData.name} (ID: ${member.id})`);
                } else {
                    console.warn(`ğŸ” [createAIMessage] æœªæ‰¾åˆ°ç¾¤æˆå‘˜: ${msgData.name}`);
                }
            }

            // æ ¹æ®æ¶ˆæ¯ç±»å‹è®¾ç½®ç‰¹å®šå­—æ®µ
            switch (msgData.type) {
                case 'ai_image':
                    return {
                        ...baseMessage,
                        type: 'ai_image',
                        content: msgData.description || 'AIæè¿°çš„å›¾ç‰‡',
                        imageDescription: msgData.description
                    };
                case 'voice_message':
                    return {
                        ...baseMessage,
                        type: 'voice_message',
                        content: msgData.content
                    };
                case 'transfer':
                    return {
                        ...baseMessage,
                        type: 'transfer',
                        amount: msgData.amount,
                        note: msgData.note
                    };
                case 'emoji':
                    const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.description);
                    if (matchingEmoji) {
                        const emojiMessage = {
                            ...baseMessage,
                            content: '',
                            image: matchingEmoji.url,
                            isEmoji: true,
                            emojiDescription: matchingEmoji.description
                        };
                        addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                        return emojiMessage;
                    } else {
                        return {
                            ...baseMessage,
                            content: `[è¡¨æƒ…åŒ…"${msgData.description}"ä¸å­˜åœ¨]`
                        };
                    }
                default:
                    return {
                        ...baseMessage,
                        content: msgData.content || msgData.message || ''
                    };
            }
        }

        // å¤„ç†AIå›å¤
        async function processAIReply() {
            if (!currentChatCharacter) return;
            
            // é˜²æ­¢é‡å¤è°ƒç”¨
            if (isWaitingForReply) {
                console.log('AIæ­£åœ¨å›å¤ä¸­ï¼Œå¿½ç•¥é‡å¤è°ƒç”¨');
                return;
            }
            
            // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘è®°å½•å½“å‰èŠå¤©è§’è‰²IDï¼Œç¡®ä¿AIå›å¤å½’å±åˆ°æ­£ç¡®çš„èŠå¤©çª—å£
            const replyingCharacterId = currentChatCharacter.id;
            
            // æ™ºèƒ½é€‰æ‹©æœ€ä½³çš„ç”¨æˆ·æ¶ˆæ¯ï¼ˆä¼˜å…ˆå›¾ç‰‡æ¶ˆæ¯ï¼‰
            const messages = chatMessages[replyingCharacterId] || [];
            const userMessages = messages.filter(msg => msg.sender === 'sent');
            
            // ä¼˜å…ˆæŸ¥æ‰¾æœ€è¿‘çš„åŒ…å«å›¾ç‰‡çš„æ¶ˆæ¯ï¼ˆ5æ¡æ¶ˆæ¯å†…ï¼‰
            const recentMessages = userMessages.slice(-5);
            const imageMessage = recentMessages.reverse().find(msg => 
                Array.isArray(msg.content) || msg.image
            );
            
            if (imageMessage) {
                pendingUserMessage = imageMessage;
            } else if (!pendingUserMessage) {
                // å¦‚æœæ²¡æœ‰å›¾ç‰‡æ¶ˆæ¯ä¸”æ²¡æœ‰å¾…å›å¤æ¶ˆæ¯ï¼Œä½¿ç”¨æœ€åä¸€æ¡ç”¨æˆ·æ¶ˆæ¯
                const lastUserMessage = userMessages.pop();
                if (lastUserMessage) {
                    pendingUserMessage = lastUserMessage;
                } else {
                    return;
                }
            }

            isWaitingForReply = true;
            
            // æ›´æ–°æ™ºèƒ½å›å¤æŒ‰é’®çŠ¶æ€
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.disabled = true;
                smartReplyBtn.style.opacity = '0.65';
                smartReplyBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            }

            // æ˜¾ç¤ºæ­£åœ¨è¾“å…¥æç¤º
            showTypingIndicator();
            
            // æ·»åŠ éšæœºå»¶è¿Ÿ
            const delay = Math.random() * 2000 + 1000;
            await new Promise(resolve => setTimeout(resolve, delay));

            try {
                // è°ƒç”¨APIï¼Œæ”¯æŒå›¾ç‰‡å’Œè¡¨æƒ…åŒ…
                // ğŸ”¥ã€æ ¸å¿ƒä¿®å¤ã€‘æ­£ç¡®å¤„ç†å¤šæ¨¡æ€æ¶ˆæ¯
                let response;
                

                
                // æ ¸å¿ƒä¿®å¤ï¼šç›´æ¥å°† pendingUserMessage.content (å¯èƒ½æ˜¯æ•°ç»„) ä¼ é€’ç»™ callChatAPI
                if (Array.isArray(pendingUserMessage.content)) {
                    // è¿™æ˜¯å¤šæ¨¡æ€æ¶ˆæ¯ï¼ˆå›¾æ–‡ï¼‰
                    response = await callChatAPI(pendingUserMessage.content, currentChatCharacter);
                } else if (pendingUserMessage.image) {
                    // å…¼å®¹æ—§çš„å›¾ç‰‡æ¶ˆæ¯æ ¼å¼
                    const messageContent = [
                        { type: 'text', text: pendingUserMessage.content || "" },
                        { type: 'image_url', image_url: { url: pendingUserMessage.image } }
                    ];
                    response = await callChatAPI(messageContent, currentChatCharacter);
                } else if (pendingUserMessage.type === 'transfer') {
                    // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘è½¬è´¦æ¶ˆæ¯ç‰¹æ®Šå¤„ç† - æ„é€ è½¬è´¦æç¤ºæ–‡æœ¬
                    const transferPrompt = `[ç”¨æˆ·å‘èµ·äº†è½¬è´¦ï¼š${pendingUserMessage.amount}å…ƒï¼Œå¤‡æ³¨ï¼š${pendingUserMessage.note || 'æ— '}]`;
                    response = await callChatAPI(transferPrompt, currentChatCharacter);
                } else {
                    // æ™®é€šæ–‡æœ¬æ¶ˆæ¯ã€ä½ç½®æ¶ˆæ¯ã€è¯­éŸ³æ¶ˆæ¯ç­‰
                    let finalPrompt = pendingUserMessage.content; // é»˜è®¤ä½¿ç”¨åŸå§‹æ¶ˆæ¯å†…å®¹

                    // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘æ£€æŸ¥å½“å‰ç”¨æˆ·æ¶ˆæ¯æ˜¯å¦ä¸ºå¼•ç”¨å›å¤
                    if (pendingUserMessage.replyTo) {
                        // ä½¿ç”¨ summarizeLastMessage å‡½æ•°æ¥æˆªæ–­è¢«å¼•ç”¨çš„æ¶ˆæ¯å†…å®¹
                        const quoteText = summarizeLastMessage({ content: pendingUserMessage.replyTo.content });

                        // æ„å»ºå¸¦æœ‰å¼•ç”¨ä¸Šä¸‹æ–‡çš„æç¤ºå­—ç¬¦ä¸²
                        // ä¾‹å¦‚: [å›å¤ AIçš„æ˜µç§° çš„æ¶ˆæ¯: "ä½ å¥½å‘€"]: æˆ‘ä¹Ÿå¾ˆå¥½
                        finalPrompt = `[å›å¤ ${pendingUserMessage.replyTo.senderName} çš„æ¶ˆæ¯: "${quoteText}"] ${pendingUserMessage.content}`;
                        console.log('âœ… æ„å»ºç”¨æˆ·å¼•ç”¨æç¤º:', finalPrompt);
                    }

                    response = await callChatAPI(finalPrompt, currentChatCharacter);
                }
                
                const aiMessages = parseAiResponse(response);
                
                for (const msgData of aiMessages) {
    // æ£€æŸ¥æ˜¯å¦æ˜¯æ‹‰é»‘æŒ‡ä»¤å¯¹è±¡
    if (typeof msgData === 'object' && msgData !== null && msgData.type === 'block_user') {
        console.log('ğŸš« æ£€æµ‹åˆ°AIæ‹‰é»‘æŒ‡ä»¤å¯¹è±¡:', msgData);
        // ä½¿ç”¨æŒ‡ä»¤ä¸­çš„ reason ä½œä¸ºæ‹‰é»‘ç†ç”±
        await aiBlockUser(currentChatCharacter.id, msgData.reason || 'å¯¹æ–¹æœªè¯´æ˜ç†ç”±');
        // æ‹‰é»‘åï¼Œé€šå¸¸ä¸éœ€è¦å†æ˜¾ç¤ºåç»­æ¶ˆæ¯ï¼Œç›´æ¥è·³å‡ºå¾ªç¯
        break; 
    }
}
                
                // ğŸ”¥ã€ä¿®å¤è½¬è´¦å¤„ç†ã€‘å¦‚æœç”¨æˆ·å‘çš„æ˜¯è½¬è´¦æ¶ˆæ¯ï¼Œéœ€è¦åˆ†æAIçš„å›å¤æ¥å¤„ç†è½¬è´¦
                if (pendingUserMessage && pendingUserMessage.type === 'transfer') {
                    console.log('ğŸ”¥ æ£€æµ‹åˆ°ç”¨æˆ·è½¬è´¦æ¶ˆæ¯ï¼Œå¼€å§‹å¤„ç†è½¬è´¦:', {
                        pendingUserMessage,
                        aiMessages,
                        characterName: currentChatCharacter?.name
                    });
                    await processUserTransfer(pendingUserMessage, aiMessages);
                }
                
                // ğŸ”¥ã€ç´§æ€¥ä¿®å¤ã€‘æ— è®ºå¦‚ä½•ï¼Œæ¯æ¬¡AIå›å¤åéƒ½æ£€æŸ¥æ˜¯å¦æœ‰æœªå¤„ç†çš„è½¬è´¦
                console.log('ğŸ”¥ [ç´§æ€¥ä¿®å¤] AIå›å¤å®Œæˆï¼Œæ£€æŸ¥æœªå¤„ç†è½¬è´¦');
                const allMessages = chatMessages[replyingCharacterId] || [];
                const unprocessedTransfer = allMessages.slice().reverse().find(msg => 
                    msg.sender === 'sent' && msg.type === 'transfer' && !msg.status);
                if (unprocessedTransfer) {
                    console.log('ğŸ”¥ [ç´§æ€¥ä¿®å¤] å‘ç°æœªå¤„ç†è½¬è´¦ï¼Œç«‹å³å¤„ç†:', unprocessedTransfer);
                    await processUserTransfer(unprocessedTransfer, aiMessages);
                }
                
                // ğŸ”¥ã€ç§»é™¤å…³é”®è¯è§¦å‘æœºåˆ¶ã€‘ç°åœ¨AIä¼šæ ¹æ®è‡ªå·±çš„åˆ¤æ–­ä¸»åŠ¨å‘èµ·é€šè¯ï¼Œä¸å†éœ€è¦å¤–éƒ¨è§¦å‘é€»è¾‘
                
                // ğŸ”¥ã€ä¿®å¤ã€‘ä¸ºAIçš„æ¯æ¡å›å¤åˆ›å»ºæ¨é€é€šçŸ¥ - ä½¿ç”¨æ­£ç¡®çš„è§’è‰²å¯¹è±¡
                console.log('ğŸ”” [æ¨é€é€šçŸ¥] AIå›å¤å®Œæˆï¼Œå‡†å¤‡åˆ›å»ºæ¨é€é€šçŸ¥ï¼Œæ¶ˆæ¯æ•°é‡:', aiMessages.length);
                // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘è·å–æ­£åœ¨å›å¤çš„è§’è‰²å¯¹è±¡ï¼Œè€Œä¸æ˜¯å½“å‰èŠå¤©è§’è‰²
                const replyingCharacter = characters.find(c => c.id === replyingCharacterId);
                if (replyingCharacter) {
                    for (let i = 0; i < aiMessages.length; i++) {
                        const msgData = aiMessages[i];
                        console.log('ğŸ”” [æ¨é€é€šçŸ¥] å¤„ç†æ¶ˆæ¯', i, ':', msgData);
                        if (typeof msgData === 'string' ||
                            (typeof msgData === 'object' && (msgData.type || (msgData.name && msgData.message)))) {
                            createPushNotification(replyingCharacter, msgData, i * 500);
                        }
                    }
                } else {
                    console.warn('ğŸ”” [æ¨é€é€šçŸ¥] æ‰¾ä¸åˆ°å›å¤è§’è‰²ï¼Œè·³è¿‡æ¨é€é€šçŸ¥åˆ›å»º');
                }

                // ğŸ”¥ã€ç§»é™¤é‡å¤è®°å½•ã€‘è¿™é‡Œçš„æ—¶é—´çº¿è®°å½•é€»è¾‘å·²ç§»åŠ¨åˆ°ä¸‹é¢çš„å•æ¡æ¶ˆæ¯å¤„ç†ä¸­ï¼Œé¿å…é‡å¤è®°å½•
                
// --- è¯·ç”¨è¿™æ®µå…¨æ–°çš„ä»£ç æ›¿æ¢ ---
                hideTypingIndicator();
                
                for (let i = 0; i < aiMessages.length; i++) {
                    const msgData = aiMessages[i];
    let aiMessage; // å…ˆå£°æ˜å˜é‡

    // ğŸ”¥ã€ä¿®å¤ã€‘è·³è¿‡æ‹‰é»‘æŒ‡ä»¤å¯¹è±¡ï¼Œé¿å…æ˜¾ç¤º"ä¸æ”¯æŒçš„æ¶ˆæ¯æ ¼å¼"
    if (typeof msgData === 'object' && msgData !== null && msgData.type === 'block_user') {
        console.log('ğŸš« è·³è¿‡æ‹‰é»‘æŒ‡ä»¤å¯¹è±¡ï¼Œä¸æ˜¾ç¤ºä¸ºæ¶ˆæ¯:', msgData);
        continue;
    }

    if (typeof msgData === 'object' && msgData !== null) {
        if (msgData.type === 'voice_message') {
            aiMessage = createAIMessage(msgData, i);
        } else if (msgData.type === 'ai_image') {
            aiMessage = createAIMessage(msgData, i);
        } else if (msgData.type === 'transfer') {
            aiMessage = createAIMessage(msgData, i);
        } else if (msgData.type === 'emoji') {
            aiMessage = createAIMessage(msgData, i);
        } else if (msgData.type === 'ai_photo') {
            // è§’è‰²å‘é€çš„"ä¼ªç…§ç‰‡"
            console.log('å¤„ç†è§’è‰²ç…§ç‰‡æ¶ˆæ¯:', msgData);
            // ç¡®ä¿æˆ‘ä»¬æœ‰ä¸€ä¸ªæœ‰æ•ˆçš„æè¿°
            const photoDesc = msgData.description || msgData.content || msgData.photoDescription || 'è§’è‰²å‘é€çš„ç…§ç‰‡';
            console.log('ç…§ç‰‡æè¿°:', photoDesc);
            aiMessage = { 
                id: (Date.now() + i).toString(), 
                sender: 'received', 
                type: 'user_photo', // ä½¿ç”¨ä¸ç”¨æˆ·ç…§ç‰‡ç›¸åŒçš„ç±»å‹ä»¥ä¾¿å¤ç”¨æ¸²æŸ“é€»è¾‘
                content: photoDesc,
                photoDescription: photoDesc,
                timestamp: Date.now() + i * 100 
            };
        } else if (msgData.type === 'location') {
            // è§’è‰²å‘é€çš„ä½ç½®ä¿¡æ¯
            console.log('å¤„ç†è§’è‰²ä½ç½®æ¶ˆæ¯:', msgData);
            // ç¡®ä¿æˆ‘ä»¬æœ‰ä¸€ä¸ªæœ‰æ•ˆçš„ä½ç½®åç§°
            const locationName = msgData.name || msgData.locationName || 'æœªçŸ¥ä½ç½®';
            console.log('ä½ç½®åç§°:', locationName, 'åæ ‡:', msgData.coordinates || 'æœªçŸ¥åæ ‡');
            aiMessage = { 
                id: (Date.now() + i).toString(), 
                sender: 'received', 
                type: 'location', // ä¿æŒç±»å‹ä¸ºlocation
                locationName: locationName,
                coordinates: msgData.coordinates || 'æœªçŸ¥åæ ‡',
                content: `[è§’è‰²åˆ†äº«äº†ä½ç½®ä¿¡æ¯ï¼š${locationName}]`,
                timestamp: Date.now() + i * 100 
            };
        } else if (msgData.type === 'transfer') {
            aiMessage = { id: (Date.now() + i).toString(), sender: 'received', type: 'transfer', amount: msgData.amount, note: msgData.note, timestamp: Date.now() + i * 100 };
        } else if (msgData.type === 'emoji') {
            console.log('ğŸ” [processAIReply-è¡¨æƒ…åŒ…] åŸå§‹msgData:', msgData);
            const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.description);
                        if (matchingEmoji) {
                // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘ä¸ºè¡¨æƒ…åŒ…æ¶ˆæ¯æ·»åŠ ç¾¤èŠå‘é€è€…ä¿¡æ¯
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    content: '',
                    image: matchingEmoji.url,
                    isEmoji: true,
                    emojiDescription: matchingEmoji.description,
                    timestamp: Date.now() + i * 100
                };

                // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘å¦‚æœæ˜¯ç¾¤èŠæ¶ˆæ¯ï¼Œæ·»åŠ å‘é€è€…ä¿¡æ¯
                if (msgData.name) {
                    console.log('ğŸ” [processAIReply-è¡¨æƒ…åŒ…] æ£€æµ‹åˆ°ç¾¤èŠæ¶ˆæ¯ï¼Œå‘é€è€…:', msgData.name);
                    aiMessage.name = msgData.name;
                    // æŸ¥æ‰¾å¯¹åº”çš„ç¾¤æˆå‘˜ID
                    if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                        const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                        if (member) {
                            aiMessage.senderId = member.id;
                            console.log('ğŸ” [processAIReply-è¡¨æƒ…åŒ…] æ‰¾åˆ°ç¾¤æˆå‘˜ID:', member.id);
                        } else {
                            console.log('ğŸ” [processAIReply-è¡¨æƒ…åŒ…] æœªæ‰¾åˆ°ç¾¤æˆå‘˜:', msgData.name);
                        }
                    }
                } else {
                    console.log('ğŸ” [processAIReply-è¡¨æƒ…åŒ…] msgData.name ä¸å­˜åœ¨ï¼Œå¯èƒ½æ˜¯å•èŠ');
                }

                console.log('ğŸ” [processAIReply-è¡¨æƒ…åŒ…] åˆ›å»ºçš„è¡¨æƒ…åŒ…æ¶ˆæ¯:', aiMessage);
                addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                        } else {
                aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: `[è¡¨æƒ…åŒ…"${msgData.description}"ä¸å­˜åœ¨]`, timestamp: Date.now() + i * 100 };
            }
        } else if (msgData.type === 'change_avatar') {
                        if (msgData.avatar_url) {
                            // ğŸ”¥ã€ä¿®å¤ã€‘å…ˆå¤„ç†å ä½ç¬¦æ›¿æ¢ï¼Œå†éªŒè¯å’Œæ‰§è¡Œå¤´åƒæ›´æ¢
                            let actualAvatarUrl = msgData.avatar_url;
                            if (msgData.avatar_url === 'CURRENT_USER_IMAGE' ||
                                msgData.avatar_url === 'CURRENT_USER_IMAGE' ||
                                msgData.avatar_url === 'ç”¨æˆ·å‘é€çš„å›¾ç‰‡URL' ||
                                msgData.avatar_url === 'å›¾ç‰‡URL') {
                                const recentUserImage = getRecentUserImage();
                                if (recentUserImage) {
                                    actualAvatarUrl = recentUserImage;
                                } else {
                                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[æ— æ³•æ›´æ¢å¤´åƒï¼Œæ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„å›¾ç‰‡]', timestamp: Date.now() + i * 100 };
                                    continue;
                                }
                            }

                            const isValidAvatar = await validateAvatarSource(actualAvatarUrl);
                            if (isValidAvatar) {
                                const success = await changeCharacterAvatarByAI(actualAvatarUrl, msgData.reason || 'å¿ƒæƒ…å˜åŒ–');
                                if (success) continue;
                                else aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[å¤´åƒæ›´æ¢å¤±è´¥]', timestamp: Date.now() + i * 100 };
                            } else {
                                aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[æ— æ•ˆçš„å¤´åƒæ¥æºï¼Œå¤´åƒæ›´æ¢å¤±è´¥]', timestamp: Date.now() + i * 100 };
                            }
                        } else {
                            continue;
                        }
        } else if (msgData.type === 'reply_to') {
            // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†AIå¼•ç”¨å›å¤æ¶ˆæ¯

            // æŸ¥æ‰¾è¢«å¼•ç”¨çš„æ¶ˆæ¯
            const allMessages = chatMessages[replyingCharacterId] || [];
            const referencedMessage = allMessages.find(msg => msg.id === msgData.message_id);

            if (referencedMessage) {
                // æ„å»ºå¼•ç”¨ä¿¡æ¯
                const replyToInfo = {
                    id: referencedMessage.id,
                    content: referencedMessage.content || '',
                    senderName: referencedMessage.sender === 'sent' ? 'ä½ ' : (referencedMessage.name || currentChatCharacter?.name || 'å¯¹æ–¹')
                };

                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    content: msgData.content || '',
                    replyTo: replyToInfo,
                    timestamp: Date.now() + i * 100
                };

            } else {
                console.warn('ğŸ”¥ æ‰¾ä¸åˆ°è¢«å¼•ç”¨çš„æ¶ˆæ¯ID:', msgData.message_id);
                // å¦‚æœæ‰¾ä¸åˆ°è¢«å¼•ç”¨çš„æ¶ˆæ¯ï¼Œå°±å½“ä½œæ™®é€šæ¶ˆæ¯å¤„ç†
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    content: msgData.content || '',
                    timestamp: Date.now() + i * 100
                };
            }
        } else if (msgData.type === 'recall_previous') {
            // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†AIæ’¤å›ä¸Šä¸€æ¡æ¶ˆæ¯
            console.log('ğŸ”¥ AIè¯·æ±‚æ’¤å›ä¸Šä¸€æ¡æ¶ˆæ¯:', msgData);

            // æŸ¥æ‰¾ä¸Šä¸€æ¡AIæ¶ˆæ¯
            const allMessages = chatMessages[replyingCharacterId] || [];
            let lastAIMessageIndex = -1;

            for (let j = allMessages.length - 1; j >= 0; j--) {
                if (allMessages[j].sender === 'received') {
                    lastAIMessageIndex = j;
                    break;
                }
            }

            if (lastAIMessageIndex !== -1) {
                const messageToRecall = allMessages[lastAIMessageIndex];
                console.log('ğŸ”¥ æ‰¾åˆ°è¦æ’¤å›çš„æ¶ˆæ¯:', messageToRecall);

                // è°ƒç”¨æ’¤å›æ¶ˆæ¯å¤„ç†å‡½æ•°
                await handleRecalledMessage(messageToRecall.content, messageToRecall.id);
            } else {
                console.warn('ğŸ”¥ æ²¡æœ‰æ‰¾åˆ°å¯æ’¤å›çš„AIæ¶ˆæ¯');
                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ¶ˆæ¯ï¼Œæ˜¾ç¤ºä¸€æ¡æç¤º
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    content: '[AIæ’¤å›äº†ä¸Šä¸€æ¡æ¶ˆæ¯]',
                    timestamp: Date.now() + i * 100
                };
            }
            continue; // è·³è¿‡æ­£å¸¸çš„æ¶ˆæ¯å¤„ç†æµç¨‹
        } else if (msgData.type === 'voice_call') {
            // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†AIä¸»åŠ¨å‘èµ·è¯­éŸ³é€šè¯
            console.log('ğŸ”” AIè¯·æ±‚å‘èµ·è¯­éŸ³é€šè¯:', msgData);
            setTimeout(() => {
                initiateAICall(currentChatCharacter, msgData.reason || 'æƒ³å’Œä½ èŠèŠ');
            }, 100 + Math.random() * 200); // è¿›ä¸€æ­¥å‡å°‘å»¶è¿Ÿåˆ°0.1-0.3ç§’
            continue; // è·³è¿‡æ¶ˆæ¯æ˜¾ç¤ºï¼Œå› ä¸ºè¿™æ˜¯ä¸€ä¸ªåŠ¨ä½œæŒ‡ä»¤
        } else if (msgData.name && msgData.message) {
            // è¿™æ˜¯ç¾¤èŠçš„ç‰¹æ®Šæ ¼å¼
            let senderId = null;
            if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                if (member) senderId = member.id;
            }

            // --- å…³é”®ä¿®å¤ï¼šæ£€æŸ¥ç¾¤èŠæ¶ˆæ¯å†…å®¹æ˜¯å¦ä¸ºç‰¹æ®Šç±»å‹ ---
            if (typeof msgData.message === 'object' && msgData.message.type === 'voice_message') {
                // å¦‚æœæ¶ˆæ¯å†…å®¹æ˜¯ä¸€ä¸ªè¯­éŸ³æ¶ˆæ¯å¯¹è±¡
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    type: 'voice_message', // åœ¨å¤–å±‚æ¶ˆæ¯ä¸Šè®¾ç½®æ­£ç¡®çš„ç±»å‹
                    name: msgData.name,
                    senderId: senderId,
                    content: msgData.message.content, // æå–çœŸæ­£çš„è¯­éŸ³æ–‡å­—å†…å®¹
                    timestamp: Date.now() + i * 100
                };
            } else if (typeof msgData.message === 'object' && msgData.message.type === 'transfer') {
                // ğŸ”¥ã€ä¿®å¤ã€‘å¦‚æœæ¶ˆæ¯å†…å®¹æ˜¯ä¸€ä¸ªè½¬è´¦å¯¹è±¡
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    type: 'transfer', // åœ¨å¤–å±‚æ¶ˆæ¯ä¸Šè®¾ç½®æ­£ç¡®çš„ç±»å‹
                    name: msgData.name,
                    senderId: senderId,
                    amount: msgData.message.amount, // æå–è½¬è´¦é‡‘é¢
                    note: msgData.message.note, // æå–è½¬è´¦å¤‡æ³¨
                    timestamp: Date.now() + i * 100
                };
            } else if (typeof msgData.message === 'object' && msgData.message.type === 'friend_request') {
                // ğŸ”¥ã€æ–°å¢ã€‘å¦‚æœæ¶ˆæ¯å†…å®¹æ˜¯ä¸€ä¸ªå¥½å‹ç”³è¯·å¯¹è±¡(ç¬¬äºŒå¤„)
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    type: 'friend_request', // åœ¨å¤–å±‚æ¶ˆæ¯ä¸Šè®¾ç½®æ­£ç¡®çš„ç±»å‹
                    message: msgData.message.message, // æå–å¥½å‹ç”³è¯·æ¶ˆæ¯
                    timestamp: Date.now() + i * 100
                };
            } else {
                // å¯¹äºæ™®é€šçš„æ–‡æœ¬æ¶ˆæ¯
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    name: msgData.name,
                    senderId: senderId,
                    content: msgData.message, // å†…å®¹æœ¬èº«æ˜¯å­—ç¬¦ä¸²
                    timestamp: Date.now() + i * 100
                };
            }
            // --- ä¿®å¤ç»“æŸ ---
                    } else {
            // å…¶ä»–æ‰€æœ‰æœªçŸ¥å¯¹è±¡çš„å¤„ç† - ä¿®å¤[object Object]é—®é¢˜
            let displayContent;
            if (msgData.content && typeof msgData.content === 'string') {
                displayContent = msgData.content;
            } else if (msgData.message && typeof msgData.message === 'string') {
                displayContent = msgData.message;
            } else if (msgData.text && typeof msgData.text === 'string') {
                displayContent = msgData.text;
            } else if (msgData.reply && typeof msgData.reply === 'string') {
                displayContent = msgData.reply;
            } else if (typeof msgData === 'string') {
                displayContent = msgData;
            } else {
                // å¯¹äºå…¶ä»–å¤æ‚å¯¹è±¡ï¼Œæå–æœ‰ç”¨ä¿¡æ¯æˆ–æ˜¾ç¤ºç±»å‹æç¤º
                console.warn('æœªå¤„ç†çš„å¯¹è±¡ç±»å‹:', msgData);
                displayContent = '[ä¸æ”¯æŒçš„æ¶ˆæ¯æ ¼å¼]';
            }
            aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: displayContent, timestamp: Date.now() + i * 100 };
                            }
                        } else if (typeof msgData === 'string') {
                            // æ™®é€šå­—ç¬¦ä¸²
                            aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: msgData, timestamp: Date.now() + i * 100 };
                        } else {
                            // å…¶ä»–ç±»å‹ï¼Œå¼ºåˆ¶è½¬æ¢ä¸ºå­—ç¬¦ä¸²
        aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: String(msgData), timestamp: Date.now() + i * 100 };
                    }
                    
                    chatMessages[replyingCharacterId].push(aiMessage);
    await saveChatMessages();
                    addMessageWithAnimation(aiMessage, replyingCharacterId);
                    
                    // ğŸ”¥ã€æ–°å¢ã€‘è§¦å‘è§’è‰²çŠ¶æ€æ›´æ–°
                    triggerStatusUpdateAfterMessage(replyingCharacterId);

                    // ğŸ”¥ã€ä¿®å¤ã€‘ä¸ºæ¯æ¡AIæ¶ˆæ¯è®°å½•æ—¶é—´çº¿äº‹ä»¶ï¼Œé¿å…é‡å¤è®°å½•
                    setTimeout(async () => {
                        try {
                            // è·å–å½“å‰æ¶ˆæ¯çš„å†…å®¹
                            let eventContent = '';
                            let characterId = replyingCharacterId;

                            if (typeof msgData === 'string') {
                                eventContent = msgData;
                            } else if (typeof msgData === 'object' && msgData.name && msgData.message) {
                                // ç¾¤èŠæ¶ˆæ¯æ ¼å¼
                                eventContent = msgData.message;
                                // æŸ¥æ‰¾ç¾¤æˆå‘˜ID
                                if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                                    const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                                    if (member) characterId = member.id;
                                }
                            } else if (typeof msgData === 'object' && msgData.content) {
                                eventContent = msgData.content;
                            } else if (aiMessage && aiMessage.content) {
                                eventContent = aiMessage.content;
                            }

                            if (eventContent && characterId) {
                                // ğŸ”¥ã€ä¿®å¤ã€‘è®°å½•AIå›å¤çš„æ—¶é—´çº¿äº‹ä»¶ - ç¾¤èŠéœ€è¦ä¸ºæ¯ä¸ªæˆå‘˜è®°å½•
                                if (currentChatCharacter?.isGroup) {
                                    // ç¾¤èŠï¼šä¸ºæ¯ä¸ªç¾¤æˆå‘˜è®°å½•AIå›å¤äº‹ä»¶
                                    for (const member of currentChatCharacter.members || []) {
                                        // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘æ£€æŸ¥è¯¥æˆå‘˜æ˜¯å¦è®¾ç½®äº†ä¸å½“å‰ç¾¤èŠå…±äº«è®°å¿†
                                        const shouldRecord = await shouldRecordGroupMemoryForCharacter(member.id, currentChatCharacter.id);
                                        if (shouldRecord) {
                                            await recordCrossAppEvent(
                                                member.id, // è®°å½•åˆ°æ¯ä¸ªæˆå‘˜çš„æ—¶é—´çº¿ä¸‹
                                                'chat',
                                                'ai_reply',
                                                {
                                                    id: member.id, // ğŸ”¥ã€ä¿®å¤ã€‘ä½¿ç”¨è§’è‰²IDè€Œä¸æ˜¯ç¾¤èŠIDï¼Œç¡®ä¿è®°å¿†å…±äº«æ­£å¸¸å·¥ä½œ
                                                    type: 'group_chat',
                                                    sender: 'ai',
                                                    content: eventContent,
                                                    chatType: 'group',
                                                    groupName: currentChatCharacter.name,
                                                    groupId: currentChatCharacter.id // ğŸ”¥ã€æ–°å¢ã€‘ä¿ç•™ç¾¤èŠIDç”¨äºåŒºåˆ†
                                                },
                                                aiMessage.id
                                            );
                                            console.log(`ğŸ”¥ [ä¿®å¤] å·²è®°å½•AIå›å¤æ—¶é—´çº¿äº‹ä»¶ - è§’è‰²: ${member.id}, å†…å®¹: ${eventContent.substring(0, 50)}...`);
                                        } else {
                                            console.log(`â­ï¸ è·³è¿‡è®°å½• - è§’è‰² ${member.id} æœªä¸ç¾¤èŠ ${currentChatCharacter.id} å…±äº«è®°å¿†`);
                                        }
                                    }
                                } else {
                                    // å•èŠï¼šæ­£å¸¸è®°å½•
                                    await recordCrossAppEvent(
                                        replyingCharacterId,
                                        'chat',
                                        'ai_reply',
                                        {
                                            id: currentChatCharacter.id,
                                            type: 'private_chat',
                                            sender: 'ai',
                                            content: eventContent,
                                            chatType: 'single'
                                        },
                                        aiMessage.id
                                    );
                                    console.log(`ğŸ”¥ [ä¿®å¤] å·²è®°å½•AIå›å¤æ—¶é—´çº¿äº‹ä»¶ - è§’è‰²: ${replyingCharacterId}, å†…å®¹: ${eventContent.substring(0, 50)}...`);
                                }
                            }
                        } catch (error) {
                            console.error('AIå›å¤åè®°å¿†å¤„ç†å¤±è´¥:', error);
                        }
                    }, 1000 + i * 200); // å»¶è¿Ÿæ‰§è¡Œï¼Œæ¯æ¡æ¶ˆæ¯é—´éš”200msï¼Œé¿å…é˜»å¡UI

                    if (i < aiMessages.length - 1) {
                        const delay = Math.random() * 1000 + 500;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        if (i < aiMessages.length - 1) {
                            showTypingIndicator();
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));
                            hideTypingIndicator();
                        }
                    }
                }

                // ğŸ”¥ã€ä¿®å¤ã€‘AIæ¶ˆæ¯å‘é€å®Œæˆåæ›´æ–°æ¶ˆæ¯åˆ—è¡¨ï¼Œç¡®ä¿æœªè¯»æ¶ˆæ¯è®¡æ•°æ­£ç¡®
                renderMessageList();
            } catch (error) {
                console.error('AIå›å¤å¤±è´¥:', error);
                hideTypingIndicator();

                const errorMessage = {
                    id: Date.now().toString(),
                    sender: 'received',
                    content: `[å›å¤å¤±è´¥: ${error.message}]`,
                    timestamp: Date.now()
                };

                chatMessages[replyingCharacterId].push(errorMessage);
                saveChatMessages();
                addMessageWithAnimation(errorMessage, replyingCharacterId);

                // ğŸ”¥ã€ä¿®å¤ã€‘é”™è¯¯æ¶ˆæ¯ä¹Ÿéœ€è¦æ›´æ–°æ¶ˆæ¯åˆ—è¡¨
                renderMessageList();
            } finally {
                // é‡ç½®çŠ¶æ€
                isWaitingForReply = false;
                pendingUserMessage = null;

                // æ¢å¤æ™ºèƒ½å›å¤æŒ‰é’®
                if (smartReplyBtn) {
                    smartReplyBtn.disabled = false;
                    smartReplyBtn.style.opacity = '';
                    smartReplyBtn.style.animation = 'none';
                    smartReplyBtn.classList.remove('waiting');
                    smartReplyBtn.innerHTML = '<i class="fas fa-comment-dots"></i>';
                    smartReplyBtn.title = 'è·å–AIå›å¤';
                }

                // æ›´æ–°æŒ‰é’®æ˜¾ç¤ºçŠ¶æ€
                updateFloatingButtonsVisibility();
            }
        }

        // é‡ç½®æ‚¬æµ®æŒ‰é’®çŠ¶æ€
        function resetFloatingButtonsState() {
            // é‡ç½®å¾…å›å¤æ¶ˆæ¯
            pendingUserMessage = null;
            isWaitingForReply = false;
            
            // é‡ç½®æ™ºèƒ½å›å¤æŒ‰é’®çŠ¶æ€
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.disabled = false;
                smartReplyBtn.style.opacity = '';
                smartReplyBtn.style.animation = 'none';
                smartReplyBtn.innerHTML = '<i class="fas fa-comment-dots"></i>';
                smartReplyBtn.title = 'è·å–AIå›å¤';
                smartReplyBtn.classList.remove('waiting');
            }
            
            // æ›´æ–°æŒ‰é’®æ˜¾ç¤ºçŠ¶æ€
            updateFloatingButtonsVisibility();
        }

        // æ›´æ–°æ‚¬æµ®æŒ‰é’®çš„æ˜¾ç¤ºçŠ¶æ€
        function updateFloatingButtonsVisibility() {
            if (!currentChatCharacter) return;
            
            const regenerateBtn = document.getElementById('regenerate-btn');
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            const messages = chatMessages[currentChatCharacter.id] || [];
            
            // æ£€æŸ¥æ˜¯å¦æœ‰AIæ¶ˆæ¯å¯ä»¥é‡æ–°ç”Ÿæˆ
            const hasAIMessages = messages.some(msg => msg.sender === 'received');
            
            if (regenerateBtn) {
                if (hasAIMessages) {
                    regenerateBtn.classList.remove('hidden');
                } else {
                    regenerateBtn.classList.add('hidden');
                }
            }
            
            if (smartReplyBtn) {
                // æ™ºèƒ½å›å¤æŒ‰é’®æ€»æ˜¯æ˜¾ç¤º
                smartReplyBtn.classList.remove('hidden');
            }
        }

        // @ç¾¤æˆå‘˜åŠŸèƒ½ç›¸å…³å‡½æ•°
        function handleMentionInput(e) {
            const input = e.target;
            const text = input.value;
            const cursorPos = input.selectionStart;

            // æŸ¥æ‰¾æœ€è¿‘çš„@ç¬¦å·ä½ç½®
            let atPos = -1;
            for (let i = cursorPos - 1; i >= 0; i--) {
                if (text[i] === '@') {
                    atPos = i;
                    break;
                } else if (text[i] === ' ' || text[i] === '\n') {
                    break;
                }
            }

            if (atPos !== -1 && isGroupChat()) {
                // æ‰¾åˆ°@ç¬¦å·ï¼Œæ˜¾ç¤ºç¾¤æˆå‘˜åˆ—è¡¨
                const query = text.substring(atPos + 1, cursorPos);
                mentionStartPos = atPos;
                currentMentionQuery = query;
                showMentionDropdown(query);
            } else {
                // æ²¡æœ‰@ç¬¦å·æˆ–ä¸æ˜¯ç¾¤èŠï¼Œéšè—ä¸‹æ‹‰æ¡†
                hideMentionDropdown();
            }
        }

        function handleMentionKeydown(e) {
            const dropdown = document.getElementById('mention-dropdown');
            const items = dropdown.querySelectorAll('.mention-item');

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedMentionIndex = Math.min(selectedMentionIndex + 1, items.length - 1);
                updateMentionSelection(items);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedMentionIndex = Math.max(selectedMentionIndex - 1, 0);
                updateMentionSelection(items);
            } else if (e.key === 'Enter' || e.key === 'Tab') {
                e.preventDefault();
                if (selectedMentionIndex >= 0 && items[selectedMentionIndex]) {
                    selectMention(items[selectedMentionIndex]);
                }
            } else if (e.key === 'Escape') {
                e.preventDefault();
                hideMentionDropdown();
            }
        }

        function isGroupChat() {
            return currentChatCharacter && groupChats.find(g => g.id === currentChatCharacter.id);
        }

        function showMentionDropdown(query) {
            if (!isGroupChat()) return;

            const group = groupChats.find(g => g.id === currentChatCharacter.id);
            if (!group || !group.members) return;

            const dropdown = document.getElementById('mention-dropdown');
            const filteredMembers = group.members.filter(member =>
                member.name.toLowerCase().includes(query.toLowerCase())
            );

            if (filteredMembers.length === 0) {
                hideMentionDropdown();
                return;
            }

            dropdown.innerHTML = '';
            filteredMembers.forEach((member, index) => {
                const item = document.createElement('div');
                item.className = 'mention-item';
                item.innerHTML = `
                    <div class="mention-avatar" style="background-color: ${member.color || '#4CAF50'}; ${member.avatarUrl ? `background-image: url(${member.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                        ${member.avatarUrl ? '' : member.name.charAt(0)}
                    </div>
                    <div class="mention-name">${member.name}</div>
                `;
                item.onclick = () => selectMention(item);
                item.dataset.memberName = member.name;
                item.dataset.memberId = member.id;
                dropdown.appendChild(item);
            });

            selectedMentionIndex = 0;
            updateMentionSelection(dropdown.querySelectorAll('.mention-item'));
            dropdown.style.display = 'block';
            mentionDropdownVisible = true;
        }

        function hideMentionDropdown() {
            const dropdown = document.getElementById('mention-dropdown');
            dropdown.style.display = 'none';
            mentionDropdownVisible = false;
            selectedMentionIndex = -1;
            mentionStartPos = -1;
            currentMentionQuery = '';
        }

        function updateMentionSelection(items) {
            items.forEach((item, index) => {
                if (index === selectedMentionIndex) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
        }

        function selectMention(item) {
            const memberName = item.dataset.memberName;
            const input = document.getElementById('api-chat-input');
            const text = input.value;

            // æ›¿æ¢@æŸ¥è¯¢æ–‡æœ¬ä¸º@æŸäºº
            const beforeMention = text.substring(0, mentionStartPos);
            const afterMention = text.substring(mentionStartPos + 1 + currentMentionQuery.length);
            const newText = beforeMention + `@${memberName} ` + afterMention;

            input.value = newText;

            // è®¾ç½®å…‰æ ‡ä½ç½®åˆ°@æŸäººåé¢
            const newCursorPos = mentionStartPos + memberName.length + 2;
            input.setSelectionRange(newCursorPos, newCursorPos);

            hideMentionDropdown();
            input.focus();
        }

        // å¤„ç†æ¶ˆæ¯ä¸­çš„@å†…å®¹ï¼Œå°†å…¶è½¬æ¢ä¸ºå¸¦æ ·å¼çš„HTML
        function processMentions(content) {
            if (!content || typeof content !== 'string') return content;

            // åŒ¹é…@æŸäººçš„æ¨¡å¼
            return content.replace(/@([^\s@]+)/g, '<span class="mention-text">@$1</span>');
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ„å»ºç¾¤èŠä¸Šä¸‹æ–‡å…³è”è®°å¿†
        async function buildContextualMemoryForGroupChat(groupCharacter, userMessage) {
            try {
                let contextualMemory = '';

                // æ£€æµ‹@æåŠ
                const mentionMatches = userMessage.match(/@([^\s@]+)/g);
                if (mentionMatches) {
                    for (const mention of mentionMatches) {
                        const mentionedName = mention.substring(1); // ç§»é™¤@ç¬¦å·

                        // æŸ¥æ‰¾è¢«@çš„ç¾¤æˆå‘˜
                        const mentionedMember = groupCharacter.members?.find(m => m.name === mentionedName);
                        if (mentionedMember) {
                            // è·å–è¯¥æˆå‘˜çš„å•èŠè®°å¿†
                            const privateChatMemory = await getPrivateChatMemoryForMember(mentionedMember.id, userMessage);
                            if (privateChatMemory) {
                                contextualMemory += `\n\n# ä¸${mentionedName}çš„ç›¸å…³ç§èŠè®°å¿†ï¼š\n${privateChatMemory}`;
                            }
                        }
                    }
                }

                // æ£€æµ‹æ•°å­—æš—å·ï¼ˆ6ä½ä»¥ä¸Šæ•°å­—ï¼‰
                const numberMatches = userMessage.match(/\b\d{6,}\b/g);
                if (numberMatches) {
                    for (const number of numberMatches) {
                        // åœ¨æ‰€æœ‰ç¾¤æˆå‘˜çš„ç§èŠè®°å¿†ä¸­æœç´¢è¿™ä¸ªæ•°å­—
                        for (const member of groupCharacter.members || []) {
                            const numberContext = await searchNumberInPrivateChat(member.id, number);
                            if (numberContext) {
                                contextualMemory += `\n\n# å…³äºæ•°å­—"${number}"çš„ç§èŠè®°å¿†ï¼ˆä¸${member.name}ï¼‰ï¼š\n${numberContext}`;
                                break; // æ‰¾åˆ°ä¸€ä¸ªå°±å¤Ÿäº†
                            }
                        }
                    }
                }

                return contextualMemory;
            } catch (error) {
                console.error('æ„å»ºç¾¤èŠä¸Šä¸‹æ–‡å…³è”è®°å¿†å¤±è´¥:', error);
                return '';
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘è·å–ç¾¤æˆå‘˜çš„ç§èŠè®°å¿†
        async function getPrivateChatMemoryForMember(memberId, currentMessage) {
            try {
                // è·å–æœ€è¿‘çš„ç§èŠè®°å¿†ï¼ˆæœ€è¿‘5æ¡ï¼‰
                const recentPrivateMemories = await db.crossAppTimeline
                    .where('characterId').equals(memberId)
                    .and(event => event.appType === 'chat' &&
                                 event.context?.type === 'private_chat')
                    .reverse()
                    .limit(5)
                    .toArray();

                if (recentPrivateMemories.length === 0) return '';

                let memoryText = '';
                recentPrivateMemories.forEach(memory => {
                    const time = new Date(memory.timestamp).toLocaleString();
                    const content = memory.context?.content || memory.context?.message || '';
                    if (content) {
                        memoryText += `[${time}] ${memory.context?.sender === 'user' ? 'ç”¨æˆ·' : 'AI'}è¯´: ${content.substring(0, 50)}${content.length > 50 ? '...' : ''}\n`;
                    }
                });

                return memoryText;
            } catch (error) {
                console.error('è·å–ç§èŠè®°å¿†å¤±è´¥:', error);
                return '';
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘åœ¨ç§èŠè®°å¿†ä¸­æœç´¢æ•°å­—
        async function searchNumberInPrivateChat(memberId, number) {
            try {
                // æœç´¢åŒ…å«è¯¥æ•°å­—çš„ç§èŠè®°å¿†
                const matchingMemories = await db.crossAppTimeline
                    .where('characterId').equals(memberId)
                    .and(event => event.appType === 'chat' &&
                                 event.context?.type === 'private_chat' &&
                                 (event.context?.content?.includes(number) ||
                                  event.context?.message?.includes(number)))
                    .reverse()
                    .limit(3)
                    .toArray();

                if (matchingMemories.length === 0) return '';

                let contextText = '';
                matchingMemories.forEach(memory => {
                    const time = new Date(memory.timestamp).toLocaleString();
                    const content = memory.context?.content || memory.context?.message || '';
                    if (content) {
                        contextText += `[${time}] ${memory.context?.sender === 'user' ? 'ç”¨æˆ·' : 'AI'}è¯´: ${content}\n`;
                    }
                });

                return contextText;
            } catch (error) {
                console.error('æœç´¢æ•°å­—è®°å¿†å¤±è´¥:', error);
                return '';
            }
        }

        // ä¿®æ”¹åŸæ¥çš„sendApiMessageå‡½æ•°ï¼Œä½¿å…¶åªå‘é€æ¶ˆæ¯åˆ°ç•Œé¢ï¼Œä¸è§¦å‘AIå›å¤
        async function sendApiMessage() {
            const input = document.getElementById('api-chat-input');
            const message = input.value.trim();
            
            if (!message) return;
            
            if (!currentChatCharacter) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè§’è‰²');
                return;
            }

            // ğŸ”¥ã€ä¿®æ”¹ã€‘ç§»é™¤æ‹‰é»‘æ£€æŸ¥ï¼Œå…è®¸æ¶ˆæ¯æ­£å¸¸å‘é€

            // é˜²æ­¢é‡å¤å‘é€
            if (input._isProcessing) return;
            input._isProcessing = true;

            try {
            // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
            const messageId = Date.now().toString();
            const userMessage = {
                id: messageId,
                sender: 'sent',
                content: message,
                timestamp: Date.now(),
                // å¦‚æœæœ‰å¼•ç”¨æ¶ˆæ¯ï¼Œæ·»åŠ å¼•ç”¨ä¿¡æ¯
                replyTo: currentReplyTo ? {
                    id: currentReplyTo.id,
                    content: currentReplyTo.content,
                    senderName: currentReplyTo.senderName
                } : null
            };
            
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            
            chatMessages[currentChatCharacter.id].push(userMessage);
            // ğŸ”¥ã€ä¿®å¤ã€‘ç«‹å³ä¿å­˜æ¶ˆæ¯ï¼Œç¡®ä¿AIèƒ½çœ‹åˆ°æœ€æ–°çš„æ¶ˆæ¯ID
            await saveChatMessagesImmediate();
            
            // æ¸…ç©ºè¾“å…¥æ¡†
            input.value = '';
            
            // æ¸…é™¤å¼•ç”¨çŠ¶æ€
            cancelReply();

            // ğŸ”¥ã€æ–°å¢ã€‘æ¸…é™¤å½“å‰èŠå¤©çš„å¼•ç”¨çŠ¶æ€å­˜å‚¨
            if (currentChatCharacter) {
                delete chatReplyStates[currentChatCharacter.id];
            }
            
            // ğŸ”¥ã€æ–°å¢ã€‘è°ƒæ•´å¿ƒç‡ï¼ˆç”¨æˆ·å‘æ¶ˆæ¯ï¼‰
            adjustHeartrateForMessage(message, true);

            // ğŸ”¥ã€æ–°å¢ã€‘é‡æ–°å®‰æ’ä¸»åŠ¨èŠå¤©å®šæ—¶å™¨
            onUserMessageSent(currentChatCharacter.id);

            // ä½¿ç”¨åŠ¨ç”»æ·»åŠ æ¶ˆæ¯è€Œä¸æ˜¯é‡æ–°æ¸²æŸ“æ•´ä¸ªåˆ—è¡¨
            addMessageWithAnimation(userMessage, currentChatCharacter.id);

            // ğŸ”¥ã€æ–°å¢ã€‘æ£€æŸ¥æ‹‰é»‘çŠ¶æ€å¹¶åˆ›å»ºç³»ç»Ÿæ¶ˆæ¯
            checkAndCreateBlockedSystemMessage(userMessage, currentChatCharacter.id);

            // è®¾ç½®å¾…å›å¤æ¶ˆæ¯
            pendingUserMessage = userMessage;
            
            // æ›´æ–°æ™ºèƒ½å›å¤æŒ‰é’®çŠ¶æ€
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = 'ç‚¹å‡»è·å–AIå›å¤';
                }

            // ğŸ”¥ã€æ–°å¢ã€‘è§¦å‘è®°å¿†å¤„ç†ï¼ˆç®€åŒ–ç‰ˆï¼‰
            setTimeout(async () => {
                try {
                    const messages = chatMessages[currentChatCharacter.id] || [];

                    // ğŸ”¥ã€ä¿®å¤ã€‘è®°å½•èŠå¤©æ—¶é—´çº¿äº‹ä»¶ - ç¾¤èŠéœ€è¦ä¸ºæ¯ä¸ªæˆå‘˜è®°å½•
                    if (currentChatCharacter?.isGroup) {
                        // ç¾¤èŠï¼šä¸ºæ¯ä¸ªç¾¤æˆå‘˜è®°å½•ç”¨æˆ·æ¶ˆæ¯äº‹ä»¶
                        for (const member of currentChatCharacter.members || []) {
                            // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘æ£€æŸ¥è¯¥æˆå‘˜æ˜¯å¦è®¾ç½®äº†ä¸å½“å‰ç¾¤èŠå…±äº«è®°å¿†
                            const shouldRecord = await shouldRecordGroupMemoryForCharacter(member.id, currentChatCharacter.id);
                            if (shouldRecord) {
                                await recordCrossAppEvent(
                                    member.id, // è®°å½•åˆ°æ¯ä¸ªæˆå‘˜çš„æ—¶é—´çº¿ä¸‹
                                    'chat',
                                    'user_message',
                                    {
                                        id: member.id, // ğŸ”¥ã€ä¿®å¤ã€‘ä½¿ç”¨è§’è‰²IDè€Œä¸æ˜¯ç¾¤èŠIDï¼Œç¡®ä¿è®°å¿†å…±äº«æ­£å¸¸å·¥ä½œ
                                        type: 'group_chat',
                                        sender: 'user',
                                        content: message,
                                        chatType: 'group',
                                        groupName: currentChatCharacter.name,
                                        groupId: currentChatCharacter.id // ğŸ”¥ã€æ–°å¢ã€‘ä¿ç•™ç¾¤èŠIDç”¨äºåŒºåˆ†
                                    },
                                    messages[messages.length - 1]?.id
                                );
                            } else {
                                console.log(`â­ï¸ è·³è¿‡è®°å½• - è§’è‰² ${member.id} æœªä¸ç¾¤èŠ ${currentChatCharacter.id} å…±äº«è®°å¿†`);
                            }
                        }
                    } else {
                        // å•èŠï¼šæ­£å¸¸è®°å½•
                        await recordCrossAppEvent(
                            currentChatCharacter.id,
                            'chat',
                            'user_message',
                            {
                                id: currentChatCharacter.id,
                                type: 'private_chat',
                                sender: 'user',
                                content: message,
                                chatType: 'single'
                            },
                            messages[messages.length - 1]?.id
                        );
                    }

                    // AIè®°å¿†æå–ï¼ˆæ ¹æ®ç”¨æˆ·è®¾ç½®çš„é—´éš”ï¼‰
                    if (messages.length % MEMORY_CONFIG.AI_EXTRACT_INTERVAL === 0) {
                        const recentMessages = messages.slice(-MEMORY_CONFIG.AI_EXTRACT_INTERVAL);
                        // ğŸ”¥ã€ä¿®å¤ã€‘ä¼ å…¥ä¸Šä¸‹æ–‡IDç”¨äºè®°å¿†éš”ç¦»
                        await extractMemoriesWithAI(currentChatCharacter.id, recentMessages, currentChatCharacter.id);
                        console.log(`ğŸ§  è§¦å‘è®°å¿†æå– - è§’è‰²: ${currentChatCharacter.name}, æ¶ˆæ¯æ•°: ${messages.length}`);
                    }
                } catch (error) {
                    console.error('è®°å¿†å¤„ç†å¤±è´¥:', error);
                }
            }, 1000); // å»¶è¿Ÿ1ç§’æ‰§è¡Œï¼Œé¿å…é˜»å¡UI

            } finally {
                // ç¡®ä¿å¤„ç†å®Œæˆåé‡ç½®æ ‡å¿—
                setTimeout(() => {
                    input._isProcessing = false;
                }, 100);
            }
        }

        // è¯­éŸ³å½•éŸ³ç›¸å…³å˜é‡
        let isRecording = false;
        let recordingStartTime = 0;

        // å¤„ç†è¯­éŸ³å½•éŸ³
        async function handleVoiceRecording() {
            if (!currentChatCharacter) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè§’è‰²');
                return;
            }

            // ğŸ”¥ã€ä¿®å¤ã€‘ç§»é™¤å¯¹ä¸å­˜åœ¨æŒ‰é’®çš„ä¾èµ–ï¼Œç›´æ¥æ˜¾ç¤ºè¯­éŸ³è¾“å…¥å¯¹è¯æ¡†
                try {
                    const voiceText = await showVoiceInputDialog();
                    if (voiceText && voiceText.trim()) {
                        sendVoiceMessage(voiceText.trim());
                        console.log('è¯­éŸ³æ¶ˆæ¯å‘é€æˆåŠŸ');
                    }
                } catch (error) {
                    // åªæœ‰åœ¨çœŸæ­£å–æ¶ˆæ—¶æ‰æ˜¾ç¤ºå–æ¶ˆæ¶ˆæ¯
                    if (error.message === 'ç”¨æˆ·å–æ¶ˆ') {
                        console.log('ç”¨æˆ·å–æ¶ˆäº†è¯­éŸ³è¾“å…¥');
                    } else {
                        console.error('è¯­éŸ³æ¶ˆæ¯å‘é€å¤±è´¥:', error);
                    }
            }
        }

        // é‡ç½®å½•éŸ³çŠ¶æ€ - ğŸ”¥ã€ä¿®å¤ã€‘ç§»é™¤å¯¹ä¸å­˜åœ¨æŒ‰é’®çš„ä¾èµ–
        function resetRecordingState() {
            isRecording = false;
            // ä¸å†éœ€è¦æ“ä½œæŒ‰é’®çŠ¶æ€ï¼Œå› ä¸ºæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯å·¥å…·é¢æ¿ä¸­çš„è¯­éŸ³æŒ‰é’®
        }

        // æ˜¾ç¤ºè¯­éŸ³è¾“å…¥å¯¹è¯æ¡†
        function showVoiceInputDialog() {
            return new Promise((resolve, reject) => {
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                `;

                const dialog = document.createElement('div');
                dialog.style.cssText = `
                    background: white;
                    border-radius: 12px;
                    padding: 20px;
                    width: 280px;
                    max-width: 90%;
                    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                `;

                dialog.innerHTML = `
                    <div style="text-align: center; margin-bottom: 15px;">
                        <h3 style="margin: 0; color: #333;">è¯­éŸ³è½¬æ–‡å­—</h3>
                        <p style="margin: 8px 0 0 0; color: #666; font-size: 14px;">è¯·è¾“å…¥æ‚¨æƒ³è¯´çš„å†…å®¹ï¼š</p>
                    </div>
                    <textarea id="voice-text-input" placeholder="åœ¨è¿™é‡Œè¾“å…¥è¯­éŸ³å†…å®¹..." style="
                        width: 100%;
                        height: 80px;
                        border: 1px solid #ddd;
                        border-radius: 8px;
                        padding: 10px;
                        font-size: 14px;
                        resize: none;
                        box-sizing: border-box;
                        outline: none;
                    "></textarea>
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button id="voice-cancel-btn" style="
                            flex: 1;
                            padding: 10px;
                            border: 1px solid #ddd;
                            background: white;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 14px;
                        ">å–æ¶ˆ</button>
                        <button id="voice-send-btn" style="
                            flex: 1;
                            padding: 10px;
                            border: none;
                            background: #4a84c1;
                            color: white;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 14px;
                        ">å‘é€</button>
                    </div>
                `;

                overlay.appendChild(dialog);
                document.body.appendChild(overlay);

                const textInput = dialog.querySelector('#voice-text-input');
                const cancelBtn = dialog.querySelector('#voice-cancel-btn');
                const sendBtn = dialog.querySelector('#voice-send-btn');

                // è‡ªåŠ¨èšç„¦åˆ°è¾“å…¥æ¡†
                setTimeout(() => textInput.focus(), 100);

                // å–æ¶ˆæŒ‰é’®
                cancelBtn.onclick = () => {
                    document.body.removeChild(overlay);
                    reject(new Error('ç”¨æˆ·å–æ¶ˆ'));
                };

                // å‘é€æŒ‰é’®
                sendBtn.onclick = () => {
                    const text = textInput.value.trim();
                    if (text) {
                        console.log('è¯­éŸ³è¾“å…¥å¯¹è¯æ¡†ï¼šç”¨æˆ·ç‚¹å‡»å‘é€ï¼Œå†…å®¹:', text);
                        document.body.removeChild(overlay);
                        resolve(text);
                    } else {
                        console.log('è¯­éŸ³è¾“å…¥å¯¹è¯æ¡†ï¼šå†…å®¹ä¸ºç©ºï¼Œèšç„¦è¾“å…¥æ¡†');
                        textInput.focus();
                    }
                };

                // ç‚¹å‡»é®ç½©å…³é—­
                overlay.onclick = (e) => {
                    if (e.target === overlay) {
                        document.body.removeChild(overlay);
                        reject(new Error('ç”¨æˆ·å–æ¶ˆ'));
                    }
                };

                // æ”¯æŒå›è½¦å‘é€
                textInput.onkeydown = (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        console.log('è¯­éŸ³è¾“å…¥æ¡†ï¼šç”¨æˆ·æŒ‰å›è½¦é”®å‘é€');
                        sendBtn.click();
                    }
                };
            });
        }

                 // å‘é€è¯­éŸ³æ¶ˆæ¯
        function sendVoiceMessage(text) {
            console.log('å¼€å§‹å‘é€è¯­éŸ³æ¶ˆæ¯:', text);
            
            // ğŸ”¥ã€ä¿®æ”¹ã€‘ç§»é™¤æ‹‰é»‘æ£€æŸ¥ï¼Œå…è®¸è¯­éŸ³æ¶ˆæ¯æ­£å¸¸å‘é€
            
            const messageId = Date.now().toString();
            const duration = Math.max(1, Math.ceil(text.length / 8)); // æ ¹æ®æ–‡å­—é•¿åº¦è®¡ç®—"è¯­éŸ³"æ—¶é•¿
            
            const voiceMessage = {
                id: messageId,
                sender: 'sent',
                type: 'voice',
                content: text,
                duration: duration,
                timestamp: Date.now()
            };

            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }

            chatMessages[currentChatCharacter.id].push(voiceMessage);
            console.log('è¯­éŸ³æ¶ˆæ¯å·²æ·»åŠ åˆ°èŠå¤©è®°å½•');
            
            saveChatMessages();
            console.log('èŠå¤©è®°å½•å·²ä¿å­˜');

            // ğŸ”¥ã€æ–°å¢ã€‘è°ƒæ•´å¿ƒç‡ï¼ˆç”¨æˆ·å‘è¯­éŸ³æ¶ˆæ¯ï¼‰
            adjustHeartrateForMessage(text, true);

            // ğŸ”¥ã€æ–°å¢ã€‘é‡æ–°å®‰æ’ä¸»åŠ¨èŠå¤©å®šæ—¶å™¨
            onUserMessageSent(currentChatCharacter.id);

            // æ·»åŠ è¯­éŸ³æ¶ˆæ¯åˆ°ç•Œé¢
            addMessageWithAnimation(voiceMessage, currentChatCharacter.id);
            console.log('è¯­éŸ³æ¶ˆæ¯å·²æ·»åŠ åˆ°ç•Œé¢');

            // ğŸ”¥ã€æ–°å¢ã€‘æ£€æŸ¥æ‹‰é»‘çŠ¶æ€å¹¶åˆ›å»ºç³»ç»Ÿæ¶ˆæ¯
            checkAndCreateBlockedSystemMessage(voiceMessage, currentChatCharacter.id);
            
            // ğŸ”¥ã€æ–°å¢ã€‘è§¦å‘è§’è‰²çŠ¶æ€æ›´æ–°
            triggerStatusUpdateAfterMessage(currentChatCharacter.id);

            // è®¾ç½®å¾…å›å¤æ¶ˆæ¯
            pendingUserMessage = voiceMessage;

            // æ›´æ–°æ™ºèƒ½å›å¤æŒ‰é’®çŠ¶æ€
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = 'ç‚¹å‡»è·å–AIå›å¤';
            }
            
            console.log('è¯­éŸ³æ¶ˆæ¯å‘é€æµç¨‹å®Œæˆ');
        }

        // åˆ‡æ¢è¯­éŸ³æ–‡æœ¬æ˜¾ç¤º
        function toggleVoiceText(voiceElement) {
            const container = voiceElement.closest('.voice-message-container') || voiceElement.closest('.message-container');
            if (!container) return;

            const textContent = container.querySelector('.voice-text-content');
            if (!textContent) {
                // å¦‚æœæ²¡æœ‰æ–‡æœ¬å®¹å™¨ï¼Œåˆ›å»ºä¸€ä¸ª
                const text = voiceElement.getAttribute('data-text');
                if (!text) return;

                const newTextContent = document.createElement('div');
                newTextContent.className = 'voice-text-content';
                newTextContent.textContent = text;
                
                // æ ¹æ®æ¶ˆæ¯ç±»å‹å†³å®šæ’å…¥ä½ç½®
                if (container.classList.contains('voice-message-container')) {
                    container.appendChild(newTextContent);
                } else {
                    // ä¸ºæ—§æ ¼å¼åˆ›å»ºè¯­éŸ³å®¹å™¨
                    const voiceContainer = document.createElement('div');
                    voiceContainer.className = container.classList.contains('sent') ? 'voice-message-container sent' : 'voice-message-container received';
                    
                    // ç§»åŠ¨ç°æœ‰çš„æ¶ˆæ¯æ°”æ³¡åˆ°è¯­éŸ³å®¹å™¨ä¸­
                    const bubble = container.querySelector('.message-bubble');
                    if (bubble) {
                        container.removeChild(bubble);
                        voiceContainer.appendChild(bubble);
                        voiceContainer.appendChild(newTextContent);
                        container.appendChild(voiceContainer);
                    }
                }
                
                // æ˜¾ç¤ºæ–‡æœ¬
                setTimeout(() => {
                    newTextContent.classList.add('visible');
                }, 10);
                
                return;
            }

            // åˆ‡æ¢æ–‡æœ¬æ˜¾ç¤º/éšè—
            if (textContent.classList.contains('visible')) {
                textContent.classList.remove('visible');
                setTimeout(() => {
                    textContent.style.display = 'none';
                }, 300);
            } else {
                textContent.style.display = 'block';
                setTimeout(() => {
                    textContent.classList.add('visible');
                }, 10);
            }
        }
        
        // åŠ è½½åŠ¨æ€
        async function loadMoments() {
            try {
                    const momentsList = document.getElementById('moments-list');
                if (!momentsList) return;
                    
                        // æ¸…ç©ºç°æœ‰çš„åŠ¨æ€
                        momentsList.innerHTML = '';
                        
                // ä»æ•°æ®åº“åŠ è½½åŠ¨æ€æ•°æ®
                const momentsData = await db.moments.orderBy('timestamp').reverse().toArray();
                
                if (momentsData.length > 0) {
                    for (const momentData of momentsData) {
                        // è·å–ç‚¹èµæ•°
                        const likesCount = await db.momentLikes.where('momentId').equals(momentData.id).count();
                        
                        // è·å–è¯„è®ºæ•°
                        const commentsCount = await db.momentComments.where('momentId').equals(momentData.id).count();
                        
                        // è·å–è¯„è®ºåˆ—è¡¨
                        const comments = await db.momentComments.where('momentId').equals(momentData.id).toArray();
                        comments.sort((a, b) => a.timestamp - b.timestamp); // æŒ‰æ—¶é—´æˆ³æ’åº
                        
                            // ğŸ”¥ã€ä¿®å¤ã€‘éªŒè¯å¹¶å¤„ç†å¤´åƒ
                            let avatarToUse = null;
                            if (momentData.avatar && isValidAvatarUrl(momentData.avatar)) {
                                avatarToUse = momentData.avatar;
                            } else {
                                // ğŸ”¥ã€ä¿®å¤ã€‘ä½¿ç”¨awaitè·å–é»˜è®¤å¤´åƒ
                                avatarToUse = await getDefaultAvatar();
                                // å¦‚æœæ•°æ®åº“ä¸­å­˜å‚¨çš„å¤´åƒæ— æ•ˆï¼Œæ›´æ–°æ•°æ®åº“è®°å½•
                                if (momentData.avatar && !isValidAvatarUrl(momentData.avatar)) {
                                    console.log(`æ¸…ç†åŠ¨æ€ ${momentData.id} çš„æ— æ•ˆå¤´åƒ`);
                                    try {
                                        await db.moments.update(momentData.id, { avatar: avatarToUse });
                                    } catch (error) {
                                        console.error('æ›´æ–°åŠ¨æ€å¤´åƒå¤±è´¥:', error);
                                    }
                                }
                            }
                        
                            const momentElement = createMomentElement({
                            id: momentData.id,
                                nickname: momentData.nickname,
                                avatar: avatarToUse,
                                text: momentData.text,
                                images: momentData.images || [],
                                time: momentData.time,
                            timestamp: momentData.timestamp,
                            likes: likesCount,
                            comments: comments
                            });
                            
                            // æ·»åŠ åˆ°åŠ¨æ€åˆ—è¡¨
                            momentsList.appendChild(momentElement);
                            
                            // æ›´æ–°ç‚¹èµæ˜¾ç¤º
                        updateMomentLikeDisplay(momentData.id);
                            
                            // æ˜¾ç¤ºå·²æœ‰è¯„è®º
                        if (comments && comments.length > 0) {
                            comments.forEach(comment => {
                                // ç¡®ä¿è¯„è®ºæœ‰timeå­—æ®µï¼Œå¦‚æœæ²¡æœ‰å°±ä»timestampç”Ÿæˆ
                                if (!comment.time && comment.timestamp) {
                                    comment.time = formatTime(new Date(comment.timestamp));
                                }
                                displayCommentUnderMoment(momentData.id, comment);
                                });
                            }
                    }
                        
                        console.log('æˆåŠŸåŠ è½½', momentsData.length, 'æ¡åŠ¨æ€');
                } else {
                    console.log('æ²¡æœ‰æ‰¾åˆ°ä¿å­˜çš„åŠ¨æ€æ•°æ®');
                }
                
                // å¯åŠ¨æ—¶é—´æ›´æ–°
                startTimeUpdater();
            } catch (error) {
                console.error('åŠ è½½åŠ¨æ€å¤±è´¥:', error);
            }
        }
        
        // å‘å¸ƒåŠ¨æ€ç›¸å…³å˜é‡
        let momentImages = [];
        
        // æ˜¾ç¤ºå‘å¸ƒåŠ¨æ€ç•Œé¢
        function showPublishMoment() {
            showApp('publish-moment-screen');
            // é‡ç½®è¡¨å•
            document.getElementById('moment-text').value = '';
            momentImages = [];
            updateMomentImagesGrid();
            
            // é‡ç½®å‘å¸ƒæŒ‰é’®çŠ¶æ€
            const publishBtn = document.querySelector('.publish-btn');
            if (publishBtn) {
                publishBtn.disabled = false;
                publishBtn.textContent = 'å‘è¡¨';
            }
        }
        
        // éšè—å‘å¸ƒåŠ¨æ€ç•Œé¢
        function hidePublishMoment() {
            showApp('chat-screen');
                                    // åˆ‡æ¢å›åŠ¨æ€æ ‡ç­¾
            switchChatTab('moments-page');
            // ä¸éœ€è¦é‡æ–°åŠ è½½ï¼ŒåŠ¨æ€å·²ç»åœ¨æ•°æ®åº“ä¸­
        }
        
        // æ·»åŠ å›¾ç‰‡åˆ°åŠ¨æ€
        function addMomentImage() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*,.jpg,.jpeg,.png,.gif,.webp';
            input.multiple = true;
            input.onchange = function(event) {
                const files = Array.from(event.target.files);
                files.forEach(file => {
                    if (momentImages.length < 9) { // æœ€å¤š9å¼ å›¾ç‰‡
                        const reader = new FileReader();
                        reader.onload = async function(e) {
                            try {
                                // å‹ç¼©å›¾ç‰‡
                                const compressedImage = await compressImage(e.target.result, 800, 0.8);
                                momentImages.push(compressedImage);
                                updateMomentImagesGrid();
                            } catch (error) {
                                showToast("å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•");                                console.error("å‹ç¼©å›¾ç‰‡å¤±è´¥:", error);
                            }
                        };
                        reader.readAsDataURL(file);
                    }
                });
            };
            input.click();
        }
        
        // åˆ é™¤å›¾ç‰‡
        function removeMomentImage(index) {
            momentImages.splice(index, 1);
            updateMomentImagesGrid();
        }
        
        // æ›´æ–°å›¾ç‰‡ç½‘æ ¼æ˜¾ç¤º
        function updateMomentImagesGrid() {
            const grid = document.getElementById('moment-images-grid');
            grid.innerHTML = '';
            
            momentImages.forEach((imageData, index) => {
                const imageItem = document.createElement('div');
                imageItem.className = 'moment-image-item';
                imageItem.innerHTML = `
                    <img src="${imageData}" alt="åŠ¨æ€å›¾ç‰‡">
                    <button class="remove-image-btn" onclick="removeMomentImage(${index})">Ã—</button>
                `;
                grid.appendChild(imageItem);
            });
        }
        
        // å‘å¸ƒåŠ¨æ€
        
        // è·å–é»˜è®¤å¤´åƒ - ä¿®å¤å¼‚æ­¥é—®é¢˜
        async function getDefaultAvatar() {
            try {
                // ğŸ”¥ã€ä¿®å¤ã€‘ä½¿ç”¨awaitè·å–åŠ¨æ€å¤´åƒï¼Œç¡®ä¿å¼‚æ­¥æ“ä½œæ­£ç¡®å®Œæˆ
                const momentsAvatar = await getMomentsImage("avatarImage");
                if (momentsAvatar && isValidAvatarUrl(momentsAvatar)) {
                    console.log('ä½¿ç”¨åŠ¨æ€é¡µé¢è®¾ç½®çš„å¤´åƒ');
                    return momentsAvatar;
                }
                
                // å°è¯•è·å–ç”¨æˆ·å¤´åƒï¼Œä½†è¦éªŒè¯å…¶æœ‰æ•ˆæ€§
                if (window.userAvatar && isValidAvatarUrl(window.userAvatar)) {
                    console.log('ä½¿ç”¨å…¨å±€ç”¨æˆ·å¤´åƒ');
                    return window.userAvatar;
                }
                
                // æ¸…ç†æ— æ•ˆçš„ç”¨æˆ·å¤´åƒæ•°æ®
                if (window.userAvatar && !isValidAvatarUrl(window.userAvatar)) {
                    console.log('æ¸…ç†æ— æ•ˆçš„ç”¨æˆ·å¤´åƒæ•°æ®');
                    window.userAvatar = null;
                }
                
                // æ¸…ç†æ— æ•ˆçš„åŠ¨æ€å¤´åƒæ•°æ®
                if (momentsAvatar && !isValidAvatarUrl(momentsAvatar)) {
                    console.log('æ¸…ç†æ— æ•ˆçš„åŠ¨æ€å¤´åƒæ•°æ®');
                    // è¿™é‡Œéœ€è¦è°ƒç”¨æ¸…ç†å‡½æ•°ï¼Œä½†ç”±äºgetMomentsImageçš„å­˜å‚¨æœºåˆ¶ï¼Œæˆ‘ä»¬å…ˆè·³è¿‡
                }
                
                console.log('ä½¿ç”¨é»˜è®¤ç”Ÿæˆçš„å¤´åƒ');
                // è¿”å›é»˜è®¤å¤´åƒï¼ˆä½¿ç”¨CSSç”Ÿæˆçš„ç®€å•å¤´åƒï¼‰
                return "data:image/svg+xml;base64," + btoa(`<svg width="50" height="50" xmlns="http://www.w3.org/2000/svg"><rect width="50" height="50" fill="#f0f0f0"/><circle cx="25" cy="20" r="8" fill="#999"/><circle cx="25" cy="40" r="12" fill="#999"/></svg>`);
            } catch (error) {
                console.error('è·å–é»˜è®¤å¤´åƒå¤±è´¥:', error);
                return "data:image/svg+xml;base64," + btoa(`<svg width="50" height="50" xmlns="http://www.w3.org/2000/svg"><rect width="50" height="50" fill="#f0f0f0"/><circle cx="25" cy="20" r="8" fill="#999"/><circle cx="25" cy="40" r="12" fill="#999"/></svg>`);
            }
        }        async function publishMoment() {
            const text = document.getElementById('moment-text').value.trim();
            const publishBtn = document.querySelector('.publish-btn');
            
            if (!text && momentImages.length === 0) {
                showToast('è¯·è¾“å…¥æ–‡å­—æˆ–é€‰æ‹©å›¾ç‰‡');
                return;
            }
            
            // ç¦ç”¨å‘å¸ƒæŒ‰é’®ï¼Œé˜²æ­¢é‡å¤æäº¤
            publishBtn.disabled = true;
            publishBtn.textContent = 'å‘å¸ƒä¸­...';
            
            // è·å–å½“å‰ç”¨æˆ·æ˜µç§°
            const nickname = document.getElementById('moments-username')?.textContent || 'æˆ‘';
            
            // ğŸ”¥ã€ä¿®å¤ã€‘ä½¿ç”¨awaitè·å–ç”¨æˆ·å¤´åƒ
            const userAvatar = await getDefaultAvatar();
            
            // åˆ›å»ºæ–°åŠ¨æ€
            const now = new Date();
            const newMoment = {
                id: Date.now(),
                authorId: 'user',
                nickname: nickname,
                avatar: userAvatar,
                text: text,
                images: [...momentImages],
                time: formatTime(now),
                timestamp: now.getTime()
            };
            
            try {
                // ä¿å­˜åˆ°æ•°æ®åº“
                await db.moments.add(newMoment);
                
                // æ¢å¤å‘å¸ƒæŒ‰é’®çŠ¶æ€
                publishBtn.disabled = false;
                publishBtn.textContent = 'å‘è¡¨';
                
                // æ˜¾ç¤ºæˆåŠŸæç¤º
                showToast('å‘å¸ƒæˆåŠŸï¼');
                
                // æ¸…ç©ºè¡¨å•
                document.getElementById('moment-text').value = '';
                momentImages = [];
                updateMomentImagesGrid();
                
                // è¿”å›åŠ¨æ€é¡µé¢
                    hidePublishMoment();
                
                // ç›´æ¥æ·»åŠ åˆ°åŠ¨æ€åˆ—è¡¨ï¼ˆé¿å…é‡æ–°åŠ è½½æ•´ä¸ªåˆ—è¡¨ï¼‰
                addMomentToList(newMoment);
                
                // å¯åŠ¨æ—¶é—´æ›´æ–°å™¨
                startTimeUpdater();
                
                // å»¶è¿Ÿè§¦å‘AIè§’è‰²çš„äº’åŠ¨
                setTimeout(() => {
                    triggerAIInteractions(newMoment.id, 'like');
                }, 1000);
                setTimeout(() => {
                    triggerAIInteractions(newMoment.id, 'comment');
                }, 3000);
                
            } catch (error) {
                console.error('å‘å¸ƒåŠ¨æ€å¤±è´¥:', error);
                showToast('å‘å¸ƒå¤±è´¥ï¼Œè¯·é‡è¯•');
                
                // æ¢å¤å‘å¸ƒæŒ‰é’®
                publishBtn.disabled = false;
                publishBtn.textContent = 'å‘è¡¨';
            }
        }
        
        // æ ¼å¼åŒ–æ—¶é—´
        function formatTime(date) {
            // ç¡®ä¿dateæ˜¯Dateå¯¹è±¡
            if (!date) return 'æœªçŸ¥æ—¶é—´';
            if (!(date instanceof Date)) {
                date = new Date(date);
            }
            if (isNaN(date.getTime())) return 'æ— æ•ˆæ—¶é—´';

            const now = new Date();
            const diff = now - date;

            if (diff < 60000) { // å°äº1åˆ†é’Ÿ
                return 'åˆšåˆš';
            } else if (diff < 3600000) { // å°äº1å°æ—¶
                return Math.floor(diff / 60000) + 'åˆ†é’Ÿå‰';
            } else if (diff < 86400000) { // å°äº1å¤©
                return Math.floor(diff / 3600000) + 'å°æ—¶å‰';
            } else if (diff < 604800000) { // å°äº1å‘¨
                return Math.floor(diff / 86400000) + 'å¤©å‰';
            } else {
                return date.toLocaleDateString();
            }
        }
        
        // æ·»åŠ åŠ¨æ€åˆ°åˆ—è¡¨
        function addMomentToList(moment) {
            const momentsList = document.getElementById('moments-list');
            const momentElement = createMomentElement(moment);
            
            // æ’å…¥åˆ°åˆ—è¡¨æœ€å‰é¢
            if (momentsList.firstChild) {
                momentsList.insertBefore(momentElement, momentsList.firstChild);
            } else {
                momentsList.appendChild(momentElement);
            }
        }
        
        // åˆ›å»ºåŠ¨æ€å…ƒç´ 
        function createMomentElement(moment) {
            const momentDiv = document.createElement('div');
            momentDiv.className = 'moment-item';
            
            // è®¾ç½®åŠ¨æ€IDå’Œæ—¶é—´æˆ³
            momentDiv.setAttribute('data-moment-id', moment.id);
            if (moment.timestamp) {
                momentDiv.setAttribute('data-timestamp', moment.timestamp);
            }
            
            let imagesHtml = '';
            if (moment.images && moment.images.length > 0) {
                imagesHtml = `
                    <div class="moment-images">
                        ${moment.images.map(img => `<img src="${img}" alt="åŠ¨æ€å›¾ç‰‡" onclick="previewImage('${img}')">`).join('')}
                    </div>
                `;
            }
            // ğŸ”¥ã€ä¿®å¤ã€‘æ­£ç¡®è·å–è§’è‰²å¤´åƒ
            let finalAvatar = null;
            if (moment.authorId === 'user') {
                // ç”¨æˆ·åŠ¨æ€ï¼šç›´æ¥ä½¿ç”¨ä¿å­˜çš„å¤´åƒï¼ˆå·²åœ¨å‘å¸ƒæ—¶æ­£ç¡®è®¾ç½®ï¼‰
                finalAvatar = moment.avatar;
            } else {
                // è§’è‰²åŠ¨æ€ï¼šä¼˜å…ˆåŠ¨æ€å¤´åƒï¼Œç„¶åè§’è‰²å¡å¤´åƒ
                finalAvatar = moment.avatar;
                if (!finalAvatar && moment.characterId) {
                    const character = characters.find(c => c.id === moment.characterId);
                    if (character && character.avatarUrl) {
                        finalAvatar = character.avatarUrl;
                    }
                }
            }
            
            momentDiv.innerHTML = `
                <div class="moment-avatar">
                    ${finalAvatar ? 
                        `<img src="${finalAvatar}" alt="å¤´åƒ" style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px;" onerror="this.style.display='none'; this.parentElement.innerHTML='<div style=\\'width: 40px; height: 40px; background-color: #ddd; border-radius: 8px; display: flex; align-items: center; justify-content: center; color: #666; font-size: 14px;\\'>${moment.nickname ? moment.nickname.charAt(0) : '?'}</div>'">` :
                        `<div style="width: 40px; height: 40px; background-color: #ddd; border-radius: 8px; display: flex; align-items: center; justify-content: center; color: #666; font-size: 14px;">${moment.nickname ? moment.nickname.charAt(0) : '?'}</div>`
                    }
                </div>
                <div class="moment-content">
                    <div class="moment-username">${moment.nickname}</div>
                    <div class="moment-text">${formatMomentText(moment.text)}</div>
                    ${imagesHtml}
                    <div class="moment-time-actions" style="margin-top: 8px; padding: 8px 0; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center;">
                        <div class="moment-time">${moment.time}</div>
                        <div class="moment-actions" style="display: flex;">
                        <button class="moment-action-btn" onclick="toggleMomentLike('${moment.id}')" style="margin-right: 8px;">
                            <i class="far fa-heart"></i>
                            <span>${moment.likes || 0}</span>
                        </button>
                        <button class="moment-action-btn" onclick="showMomentComments('${moment.id}')">
                            <i class="far fa-comment"></i>
                            <span>${moment.comments ? moment.comments.length : 0}</span>
                        </button>
                    </div>
                    </div>
                    <div class="moment-footer" style="display: none;">
                    </div>
                </div>
            `;
            
            // æ·»åŠ é•¿æŒ‰ç›‘å¬å™¨
            addLongPressListener(momentDiv, moment.id);
            
            // å¼‚æ­¥æ£€æŸ¥å¹¶è®¾ç½®ç”¨æˆ·ç‚¹èµçŠ¶æ€
            (async () => {
                try {
                    const userLike = await db.momentLikes
                        .where('[momentId+authorId]')
                        .equals([moment.id, 'user'])
                        .first();
                    
                    if (userLike) {
                    const likeBtn = momentDiv.querySelector('.moment-action-btn');
                    const likeIcon = likeBtn.querySelector('i');
                    likeIcon.classList.remove('far');
                    likeIcon.classList.add('fas');
                    likeBtn.classList.add('liked');
                }
                } catch (error) {
                    console.error('æ£€æŸ¥ç”¨æˆ·ç‚¹èµçŠ¶æ€å¤±è´¥:', error);
            }
            })();
            
            return momentDiv;
        }
        
        // é¢„è§ˆå›¾ç‰‡
        function previewImage(imageSrc) {
            // åˆ›å»ºé¢„è§ˆé®ç½©
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.9);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
            `;
            
            const img = document.createElement('img');
            img.src = imageSrc;
            img.style.cssText = `
                max-width: 90%;
                max-height: 90%;
                object-fit: contain;
            `;
            
            overlay.appendChild(img);
            overlay.onclick = () => document.body.removeChild(overlay);
            document.body.appendChild(overlay);
        }
        
        // æ³¨æ„ï¼šsaveMomentsDataå‡½æ•°å·²ç§»é™¤ï¼Œç°åœ¨ä½¿ç”¨Dexieæ•°æ®åº“ç›´æ¥å­˜å‚¨
        // æ›´æ–°æ–‡å­—è®¡æ•°
        function updateTextCount() {
            const textarea = document.getElementById('moment-text');
            const countElement = document.getElementById('text-count');
            
            if (textarea && countElement) {
                const currentLength = textarea.value.length;
                const maxLength = 500;
                
                countElement.textContent = `${currentLength}/${maxLength}`;
                
                // å½“æ¥è¿‘é™åˆ¶æ—¶æ”¹å˜é¢œè‰²
                if (currentLength > maxLength * 0.9) {
                    countElement.style.color = '#ff6b6b';
                } else if (currentLength > maxLength * 0.8) {
                    countElement.style.color = '#ffa500';
                } else {
                    countElement.style.color = '#999';
                }
            }
        }
        
        // æ˜¾ç¤ºæç¤ºæ¶ˆæ¯
        function showToast(message) {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.8);
                color: white;
                padding: 12px 20px;
                border-radius: 6px;
                z-index: 10000;
                font-size: 14px;
            `;
            toast.textContent = message;
            
            document.body.appendChild(toast);
            setTimeout(() => {
                document.body.removeChild(toast);
            }, 2000);
        }
        
        // æ—¶é—´æ›´æ–°å™¨
        let timeUpdateInterval = null;
        
        function startTimeUpdater() {
            // æ¸…é™¤å·²å­˜åœ¨çš„å®šæ—¶å™¨
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
            }
            
            // ç«‹å³æ›´æ–°ä¸€æ¬¡
            updateMomentTimes();
            
            // æ¯åˆ†é’Ÿæ›´æ–°ä¸€æ¬¡æ—¶é—´æ˜¾ç¤º
            timeUpdateInterval = setInterval(updateMomentTimes, 60000);
        }
        
        function stopTimeUpdater() {
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
                timeUpdateInterval = null;
            }
        }
        
        function updateMomentTimes() {
            try {
                // æ›´æ–°åŠ¨æ€æœ¬èº«çš„æ—¶é—´
                const momentItems = document.querySelectorAll('.moment-item[data-timestamp]');

                momentItems.forEach(item => {
                    const timestamp = parseInt(item.getAttribute('data-timestamp'));
                    if (timestamp) {
                        const timeElement = item.querySelector('.moment-time');
                        if (timeElement) {
                            const newTime = formatTime(new Date(timestamp));
                            timeElement.textContent = newTime;
                        }
                    }
                });

                // ğŸ”¥ã€æ–°å¢ã€‘æ›´æ–°è¯„è®ºåŒºçš„æ—¶é—´æ˜¾ç¤º
                const commentElements = document.querySelectorAll('.moment-comment[data-timestamp]');
                commentElements.forEach(commentElement => {
                    const timestamp = parseInt(commentElement.getAttribute('data-timestamp'));
                    if (timestamp) {
                        const timeElement = commentElement.querySelector('.comment-time');
                        if (timeElement) {
                            const newTime = formatTime(new Date(timestamp));
                            timeElement.textContent = newTime;
                        }
                    }
                });
            } catch (error) {
                console.error('æ›´æ–°åŠ¨æ€æ—¶é—´å¤±è´¥:', error);
            }
        }
        
        // åŠ¨æ€é€‰æ‹©æ¨¡å¼ç›¸å…³å˜é‡
        let isSelectionMode = false;
        let selectedMoments = new Set();
        
        // åˆ‡æ¢åŠ¨æ€ç‚¹èµçŠ¶æ€
        async function toggleMomentLike(momentId) {
            if (isSelectionMode) return; // é€‰æ‹©æ¨¡å¼ä¸‹ä¸å“åº”ç‚¹èµ
            
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;
            
            const likeBtn = momentElement.querySelector('.moment-action-btn');
            const likeIcon = likeBtn.querySelector('i');
            
            try {
            // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²ç‚¹èµ
                const existingLike = await db.momentLikes
                    .where('[momentId+authorId]')
                    .equals([parseInt(momentId), 'user'])
                    .first();
            
                if (existingLike) {
                // å–æ¶ˆç‚¹èµ
                likeIcon.classList.remove('fas');
                likeIcon.classList.add('far');
                likeBtn.classList.remove('liked');
                    await db.momentLikes.delete([parseInt(momentId), 'user']);
            } else {
                // ç‚¹èµ
                likeIcon.classList.add('fas');
                likeIcon.classList.remove('far');
                likeBtn.classList.add('liked');
                    await db.momentLikes.add({
                        momentId: parseInt(momentId),
                        authorId: 'user',
                    characterId: 'user',
                    name: document.getElementById('moments-username')?.textContent || 'æˆ‘',
                    timestamp: Date.now()
                });
                
                // è§¦å‘AIè§’è‰²è‡ªåŠ¨ç‚¹èµ
                triggerAIInteractions(momentId, 'like');
            }
            
            // æ›´æ–°æ˜¾ç¤º
            updateMomentLikeDisplay(momentId);
            } catch (error) {
                console.error('ç‚¹èµæ“ä½œå¤±è´¥:', error);
            }
        }
        
        // æ˜¾ç¤ºåŠ¨æ€è¯„è®º
        function showMomentComments(momentId) {
            if (isSelectionMode) return; // é€‰æ‹©æ¨¡å¼ä¸‹ä¸å“åº”è¯„è®º

            // æ˜¾ç¤ºç®€å•è¯„è®ºè¾“å…¥æ¡†
            showSimpleCommentInput(momentId);

            // ğŸ”¥ã€ä¿®å¤ã€‘ç§»é™¤ç”¨æˆ·ç‚¹å‡»è¯„è®ºæ—¶è‡ªåŠ¨è§¦å‘AIè¯„è®ºçš„é€»è¾‘
            // ç”¨æˆ·ç‚¹å‡»è¯„è®ºæŒ‰é’®åªæ˜¯æƒ³è¯„è®ºï¼Œä¸åº”è¯¥è§¦å‘å…¶ä»–AIè§’è‰²ä¹Ÿæ¥è¯„è®º
            // AIè§’è‰²çš„è‡ªåŠ¨è¯„è®ºåº”è¯¥åªåœ¨åŠ¨æ€å‘å¸ƒæ—¶è§¦å‘ï¼Œè€Œä¸æ˜¯åœ¨ç”¨æˆ·è¯„è®ºæ—¶è§¦å‘
        }
        
        // æ˜¾ç¤ºç®€å•è¯„è®ºè¾“å…¥æ¡†
        function showSimpleCommentInput(momentId, replyToNickname = null) {
            // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰è¾“å…¥æ¡†
            if (document.querySelector('.simple-comment-input')) {
                closeSimpleCommentInput();
            }
            
            const placeholder = replyToNickname ? `å›å¤ ${replyToNickname}...` : 'å†™è¯„è®º...';
            
            const input = document.createElement('div');
            input.className = 'simple-comment-input';
            input.innerHTML = `
                <div class="comment-input-container">
                    <input type="text" placeholder="${placeholder}" maxlength="200" id="simple-comment-${momentId}" data-reply-to="${replyToNickname || ''}">
                    <button onclick="submitSimpleComment('${momentId}')">å‘é€</button>
                    <button onclick="closeSimpleCommentInput()" class="cancel-btn">å–æ¶ˆ</button>
                </div>
            `;
            
            input.style.cssText = `
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                background: white;
                border-top: 1px solid #ddd;
                padding: 12px;
                z-index: 1000;
                box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
                max-width: 360px;
                margin: 0 auto;
            `;
            
            const container = input.querySelector('.comment-input-container');
            container.style.cssText = `
                display: flex;
                gap: 8px;
                align-items: center;
                max-width: 360px;
                margin: 0 auto;
            `;
            
            const textInput = input.querySelector('input');
            textInput.style.cssText = `
                flex: 1;
                padding: 8px 12px;
                border: 1px solid #ddd;
                border-radius: 20px;
                font-size: 14px;
            `;
            
            const sendBtn = input.querySelector('button');
            sendBtn.style.cssText = `
                background: #1da1f2;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 16px;
                font-size: 14px;
                cursor: pointer;
            `;
            
            const cancelBtn = input.querySelector('.cancel-btn');
            cancelBtn.style.cssText = `
                background: #f0f0f0;
                color: #666;
                border: none;
                padding: 8px 16px;
                border-radius: 16px;
                font-size: 14px;
                cursor: pointer;
            `;
            
            document.body.appendChild(input);
            
            // è‡ªåŠ¨èšç„¦
            setTimeout(() => textInput.focus(), 100);
            
            // å›è½¦å‘é€
            textInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    submitSimpleComment(momentId);
                }
            });
        }
        
        // å…³é—­ç®€å•è¯„è®ºè¾“å…¥æ¡†
        function closeSimpleCommentInput() {
            const input = document.querySelector('.simple-comment-input');
            if (input) {
                document.body.removeChild(input);
            }
        }
        
        // æäº¤ç®€å•è¯„è®º
        async function submitSimpleComment(momentId) {
            const input = document.getElementById(`simple-comment-${momentId}`);
            const text = input.value.trim();
            const replyTo = input.getAttribute('data-reply-to');
            
            if (!text) {
                showToast('è¯·è¾“å…¥è¯„è®ºå†…å®¹');
                return;
            }
            
            // ğŸ”¥ã€ä¿®å¤ã€‘ä½¿ç”¨awaitè·å–ç”¨æˆ·å¤´åƒ
            const userAvatar = await getDefaultAvatar();
            
            const comment = {
                id: Date.now() + Math.random(),
                nickname: document.getElementById('moments-username')?.textContent || 'æˆ‘',
                avatar: userAvatar,
                text: text,
                time: formatTime(new Date()),
                timestamp: Date.now(),
                replyTo: replyTo || null
            };
            
            // ä¿å­˜è¯„è®ºåˆ°åŠ¨æ€æ•°æ®
            saveCommentToMoment(momentId, comment);
            
            // æ›´æ–°åŠ¨æ€åˆ—è¡¨ä¸­çš„è¯„è®ºæ•°
            updateMomentCommentCount(momentId);
            
            // åœ¨åŠ¨æ€ä¸‹æ–¹æ˜¾ç¤ºæ–°è¯„è®º
            displayCommentUnderMoment(momentId, comment);
            
            // å…³é—­è¾“å…¥æ¡†
            closeSimpleCommentInput();
            
            showToast('è¯„è®ºæˆåŠŸï¼');
            
            // å¦‚æœç”¨æˆ·å›å¤äº†æŸä¸ªAIè§’è‰²ï¼Œæ£€æŸ¥å›åˆæ¬¡å¹¶è§¦å‘è¯¥è§’è‰²çš„å›å¤
            if (replyTo && replyTo !== 'æˆ‘') {
                const conversationKey = `${momentId}-${replyTo}`;
                const currentRounds = commentConversationRounds.get(conversationKey) || 0;
                
                if (currentRounds < 10) {
                    console.log(`ç”¨æˆ·å›å¤äº† ${replyTo}ï¼Œå½“å‰å¯¹è¯å›åˆæ¬¡: ${currentRounds}/10ï¼Œå°†åœ¨2-5ç§’åè§¦å‘AIå›å¤`);
                    
                    // ç”¨æˆ·å›å¤æ—¶ä¹Ÿè¦å¢åŠ å›åˆæ¬¡
                    commentConversationRounds.set(conversationKey, currentRounds + 1);
                    console.log(`ç”¨æˆ·å›å¤åï¼Œ${replyTo} åœ¨åŠ¨æ€ ${momentId} ä¸­çš„å¯¹è¯å›åˆæ¬¡æ›´æ–°ä¸º: ${currentRounds + 1}/10`);
                    
                setTimeout(() => {
                    console.log(`å¼€å§‹è§¦å‘ ${replyTo} å›å¤ç”¨æˆ·è¯„è®º: "${text}"`);
                    triggerAIReplyToUser(momentId, replyTo, text);
                }, Math.random() * 3000 + 2000); // 2-5ç§’åAIå›å¤
                } else {
                    console.log(`${replyTo} åœ¨åŠ¨æ€ ${momentId} ä¸­çš„å¯¹è¯å·²è¾¾åˆ°10å›åˆä¸Šé™ï¼Œä¸å†å›å¤`);
                }
            } else {
                console.log(`ç”¨æˆ·å‘è¡¨äº†è¯„è®ºï¼ŒreplyTo: ${replyTo}`);
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯å¯¹è§’è‰²åŠ¨æ€çš„ç›´æ¥è¯„è®ºï¼ˆä¸æ˜¯å›å¤ï¼‰
                if (!replyTo) {
                    checkAndTriggerCharacterMomentReply(momentId, text);
                }
            }
        }
        
        // æ£€æŸ¥å¹¶è§¦å‘è§’è‰²åŠ¨æ€çš„å›å¤
        async function checkAndTriggerCharacterMomentReply(momentId, userCommentText) {
            try {
                // è·å–åŠ¨æ€ä¿¡æ¯
                const moment = await db.moments.get(parseInt(momentId));
                if (!moment || !moment.characterId || moment.characterId === 'user') {
                    console.log('ä¸æ˜¯è§’è‰²å‘å¸ƒçš„åŠ¨æ€ï¼Œè·³è¿‡è§’è‰²å›å¤');
                    return;
                }
                
                // è·å–å‘å¸ƒåŠ¨æ€çš„è§’è‰²
                const character = characters.find(c => c.id === moment.characterId);
                if (!character) {
                    console.log(`æœªæ‰¾åˆ°åŠ¨æ€å‘å¸ƒè€…è§’è‰²: ${moment.characterId}`);
                    return;
                }
                
                // æ£€æŸ¥å¯¹è¯å›åˆæ¬¡
                const conversationKey = `${momentId}-${character.name}`;
                const currentRounds = commentConversationRounds.get(conversationKey) || 0;
                
                if (currentRounds >= 10) {
                    console.log(`${character.name} åœ¨åŠ¨æ€ ${momentId} ä¸­çš„å¯¹è¯å·²è¾¾åˆ°10å›åˆä¸Šé™ï¼Œä¸å†å›å¤`);
                    return;
                }
                
                console.log(`ç”¨æˆ·è¯„è®ºäº† ${character.name} çš„åŠ¨æ€ï¼Œå½“å‰å¯¹è¯å›åˆæ¬¡: ${currentRounds}/10ï¼Œå°†åœ¨2-5ç§’åè§¦å‘å›å¤`);
                
                // å¢åŠ å¯¹è¯å›åˆæ¬¡
                commentConversationRounds.set(conversationKey, currentRounds + 1);
                console.log(`ç”¨æˆ·è¯„è®ºåï¼Œ${character.name} åœ¨åŠ¨æ€ ${momentId} ä¸­çš„å¯¹è¯å›åˆæ¬¡æ›´æ–°ä¸º: ${currentRounds + 1}/10`);
                
                // å»¶è¿Ÿå›å¤
                setTimeout(() => {
                    console.log(`å¼€å§‹è§¦å‘ ${character.name} å›å¤ç”¨æˆ·å¯¹å…¶åŠ¨æ€çš„è¯„è®º: "${userCommentText}"`);
                    triggerAIReplyToUser(momentId, character.name, userCommentText);
                }, Math.random() * 3000 + 2000); // 2-5ç§’åAIå›å¤
                
            } catch (error) {
                console.error('æ£€æŸ¥è§’è‰²åŠ¨æ€å›å¤å¤±è´¥:', error);
            }
        }
        
        // åœ¨åŠ¨æ€ä¸‹æ–¹æ˜¾ç¤ºè¯„è®º
        function displayCommentUnderMoment(momentId, comment) {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;
            
            // æŸ¥æ‰¾æˆ–åˆ›å»ºè¯„è®ºåŒºåŸŸ
            let commentsSection = momentElement.querySelector('.moment-comments-section');
            if (!commentsSection) {
                commentsSection = document.createElement('div');
                commentsSection.className = 'moment-comments-section';
                
                // æ£€æŸ¥æ˜¯å¦å·²æœ‰ç‚¹èµåŒºåŸŸï¼Œå†³å®šmargin-top
                const likesDisplay = momentElement.querySelector('.likes-display');
                const marginTop = likesDisplay ? '0' : '0';
                
                commentsSection.style.cssText = `
                    margin-top: ${marginTop};
                    padding: 8px 12px;
                    background: #f8f9fa;
                    font-size: 13px;
                `;
                
                // æ’å…¥åˆ°æ­£ç¡®ä½ç½®ï¼šç‚¹èµåŒºåé¢ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ï¼Œå¦åˆ™åœ¨æ—¶é—´æ“ä½œåŒºåé¢
                const momentContent = momentElement.querySelector('.moment-content');
                const momentTimeActions = momentElement.querySelector('.moment-time-actions');
                
                if (momentContent && momentTimeActions) {
                if (likesDisplay) {
                        // å¦‚æœæœ‰ç‚¹èµåŒºï¼Œæ’å…¥åˆ°ç‚¹èµåŒºåé¢
                    likesDisplay.parentNode.insertBefore(commentsSection, likesDisplay.nextSibling);
                    } else {
                        // æ²¡æœ‰ç‚¹èµåŒºï¼Œæ’å…¥åˆ°æ—¶é—´æ“ä½œåŒºåé¢
                    momentTimeActions.parentNode.insertBefore(commentsSection, momentTimeActions.nextSibling);
                    }
                }
            }
            
            // åˆ›å»ºè¯„è®ºå…ƒç´ 
            const commentDiv = document.createElement('div');
            commentDiv.className = 'comment-item moment-comment';
            commentDiv.setAttribute('data-timestamp', comment.timestamp || Date.now());
            commentDiv.style.cssText = `
                display: flex;
                gap: 8px;
                margin-bottom: 8px;
                align-items: flex-start;
            `;
            
            // ğŸ”¥ã€ä¿®å¤ã€‘å¤„ç†å›å¤æ ¼å¼ï¼Œç¡®ä¿è§’è‰²å›å¤ç”¨æˆ·æ—¶æ ¼å¼æ­£å¸¸
            let commentText = comment.text;
            let nameFormat = comment.nickname + 'ï¼š'; // é»˜è®¤æ ¼å¼

            if (comment.replyTo) {
                // æœ‰å›å¤æ—¶ï¼Œè§’è‰²ååä¸åŠ å†’å·ï¼Œå›å¤å†…å®¹åŒ…å«å®Œæ•´æ ¼å¼
                nameFormat = comment.nickname;
                commentText = `å›å¤<span style="margin: 0 2px; color: #576b95; font-weight: 600;">${comment.replyTo}</span>: ${comment.text}`;
            }

            commentDiv.innerHTML = `
                <img src="${comment.avatar}" style="width: 24px; height: 24px; border-radius: 50%; object-fit: cover;">
                <div style="flex: 1; line-height: 1.4; cursor: pointer;" onclick="replyToMomentComment('${momentId}', '${comment.nickname}')">
                    <span style="color: #576b95; font-weight: 600;">${nameFormat}</span><span style="margin-left: 2px; color: #333;">${commentText}</span>
                    <div class="comment-time" style="color: #999; font-size: 11px; margin-top: 2px;">${comment.time}</div>
                </div>
            `;
            
            commentsSection.appendChild(commentDiv);
        }
        
        // å›å¤åŠ¨æ€è¯„è®º
        function replyToMomentComment(momentId, nickname) {
            // æ˜¾ç¤ºè¯„è®ºè¾“å…¥æ¡†ï¼Œå¹¶è®¾ç½®ä¸ºå›å¤æ¨¡å¼
            showSimpleCommentInput(momentId, nickname);
        }
        

        
        // ä¿å­˜è¯„è®ºåˆ°åŠ¨æ€æ•°æ®
        async function saveCommentToMoment(momentId, comment) {
            try {
                const commentData = {
                    id: comment.id,
                    momentId: parseInt(momentId),
                    authorId: comment.characterId || 'user',
                    nickname: comment.nickname,
                    avatar: comment.avatar,
                    text: comment.text,
                    timestamp: comment.timestamp,
                    replyTo: comment.replyTo || null
                };
                
                await db.momentComments.add(commentData);
                console.log('è¯„è®ºå·²ä¿å­˜åˆ°æ•°æ®åº“ï¼ŒåŠ¨æ€ID:', momentId);
            } catch (error) {
                console.error('ä¿å­˜è¯„è®ºå¤±è´¥:', error);
            }
        }
        
        // æ›´æ–°åŠ¨æ€è¯„è®ºæ•°
        async function updateMomentCommentCount(momentId) {
            try {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;
            
                const commentsCount = await db.momentComments.where('momentId').equals(parseInt(momentId)).count();
            
                const commentBtn = momentElement.querySelectorAll('.moment-action-btn')[1];
                const commentCount = commentBtn.querySelector('span');
                commentCount.textContent = commentsCount;
            } catch (error) {
                console.error('æ›´æ–°è¯„è®ºæ•°å¤±è´¥:', error);
            }
        }
        
        // è§¦å‘AIè§’è‰²äº’åŠ¨
        async function triggerAIInteractions(momentId, type) {
            try {
            if (!characters || characters.length === 0) return;

            // è·å–å½“å‰åŠ¨æ€ä¿¡æ¯
                const moment = await db.moments.get(parseInt(momentId));
            if (!moment) return;

                const publisherCharacterId = moment.characterId;

                // å¦‚æœæ˜¯ç”¨æˆ·å‘çš„åŠ¨æ€
                if (!publisherCharacterId || publisherCharacterId === 'user') {
                    console.log('ç”¨æˆ·å‘å¸ƒåŠ¨æ€ï¼Œæ‰€æœ‰è§’è‰²80%æ¦‚ç‡äº’åŠ¨');
                    // ç”¨æˆ·å‘åŠ¨æ€ï¼šæ‰€æœ‰è”ç³»äººè§’è‰²éƒ½æœ‰80%æ¦‚ç‡äº’åŠ¨
            const contactCharacters = characters.filter(char => contacts.includes(char.id));

            if (type === 'like') {
                for (const character of contactCharacters) {
                    if (Math.random() < 0.8) { // 80%æ¦‚ç‡ç‚¹èµ
                                setTimeout(async () => {
                                    await addAILikeWithPersonality(momentId, character, moment);
                                }, Math.random() * 3000 + 1000);
                    }
                }
            } else if (type === 'comment') {
                for (const character of contactCharacters) {
                    if (Math.random() < 0.8) { // 80%æ¦‚ç‡è¯„è®º
                            setTimeout(async () => {
                                await addAICommentWithPersonality(momentId, character, moment);
                                }, Math.random() * 5000 + 2000);
                    }
                }
                    }
                } else {
                    console.log('è§’è‰²å‘å¸ƒåŠ¨æ€ï¼ŒåŒä¸€åˆ†ç»„ä¸‹è§’è‰²60%æ¦‚ç‡äº’åŠ¨');
                    // è§’è‰²å‘åŠ¨æ€ï¼šä½¿ç”¨åˆ†ç»„å…³ç³»è€Œä¸æ˜¯ç¾¤èŠå…³ç³»
                    const publisherCharacter = characters.find(c => c.id === publisherCharacterId);

                    // è·å–ä¸å‘å¸ƒè€…åœ¨åŒä¸€åˆ†ç»„çš„è§’è‰²
                    const sameGroupCharacters = characters.filter(c =>
                        c.id !== publisherCharacterId && c.groupId === publisherCharacter.groupId
                    );

                    if (type === 'like') {
                        for (const character of sameGroupCharacters) {
                            if (Math.random() < 0.6) { // ä¿®å¤ï¼š60%æ¦‚ç‡äº’åŠ¨
                    setTimeout(async () => {
                                    await addAILikeWithPersonality(momentId, character, moment);
                                }, Math.random() * 3000 + 1000);
                            }
                        }
                    } else if (type === 'comment') {
                        console.log('å¼€å§‹å¤„ç†è§’è‰²è¯„è®ºï¼ŒåŒåˆ†ç»„è§’è‰²æ•°é‡:', sameGroupCharacters.length);
                        for (const character of sameGroupCharacters) {
                            const randomValue = Math.random();
                            const willComment = randomValue < 0.6;
                            console.log(`${character.name} è¯„è®ºæ¦‚ç‡æ£€æŸ¥: ${randomValue.toFixed(3)} < 0.6 = ${willComment}`);

                            if (willComment) {
                                setTimeout(async () => {
                                    console.log(`${character.name} å¼€å§‹ç”Ÿæˆè¯„è®º...`);
                                    await addAICommentWithPersonality(momentId, character, moment);
                                }, Math.random() * 5000 + 2000);
                            } else {
                                console.log(`${character.name} å› ä¸ºæ¦‚ç‡æœªé€šè¿‡ï¼Œä¸ä¼šè¯„è®º`);
                            }
                        }

                        // ğŸ”¥ã€ç®€åŒ–ã€‘30ç§’åå‘å¸ƒè€…70%æ¦‚ç‡å›å¤å…¶ä»–è§’è‰²è¯„è®º
                        setTimeout(async () => {
                            console.log(`ğŸ”„ æ£€æŸ¥ ${publisherCharacter.name} æ˜¯å¦éœ€è¦å›å¤å…¶ä»–è§’è‰²çš„è¯„è®º...`);
                            await triggerPublisherReplyToComments(momentId, publisherCharacter);
                        }, 30000);

                        // è§¦å‘åŒåˆ†ç»„è§’è‰²é—´çš„äº’åŠ¨
                        setTimeout(() => {
                            // å°†å‘å¸ƒè€…è§’è‰²ä¹ŸåŠ å…¥åˆ°äº’åŠ¨è§’è‰²åˆ—è¡¨ä¸­
                            const allInteractionCharacters = [...sameGroupCharacters];
                            if (publisherCharacter) {
                                allInteractionCharacters.push(publisherCharacter);
                            }
                            triggerAiToAiInteractionWithPersonality(momentId, allInteractionCharacters);
                        }, Math.random() * 8000 + 5000);
                    }
                }
            } catch (error) {
                console.error('è§¦å‘AIäº’åŠ¨å¤±è´¥:', error);
            }
        }
        
        // è·å–ä¸æŒ‡å®šè§’è‰²åœ¨åŒä¸€ä¸ªç¾¤èŠçš„å…¶ä»–è§’è‰²
        function getCharactersInSameGroups(characterId) {
            const sameGroupCharacters = [];
            
            // éå†æ‰€æœ‰ç¾¤èŠ
            groupChats.forEach(group => {
                if (group.members && group.members.includes(characterId)) {
                    // æ‰¾åˆ°åŒ…å«è¯¥è§’è‰²çš„ç¾¤èŠï¼Œè·å–ç¾¤å†…å…¶ä»–è§’è‰²
                    group.members.forEach(memberId => {
                        if (memberId !== characterId && memberId !== 'user') {
                            const character = characters.find(c => c.id === memberId);
                            if (character && !sameGroupCharacters.find(c => c.id === character.id)) {
                                sameGroupCharacters.push(character);
                            }
                        }
                    });
                }
            });
            
            return sameGroupCharacters;
        }
        
        // AIè§’è‰²ç‚¹èµï¼ˆåŸºäºäººè®¾å’Œè®°å¿†ç³»ç»Ÿï¼‰
        async function addAILikeWithPersonality(momentId, character, moment) {
            try {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;

            // æ£€æŸ¥æ˜¯å¦å·²ç»ç‚¹èµè¿‡
                const existingLike = await db.momentLikes
                    .where('[momentId+authorId]')
                    .equals([parseInt(momentId), character.id])
                    .first();

                if (existingLike) return;

                // åŸºäºè§’è‰²äººè®¾ã€è®°å¿†ç³»ç»Ÿå’Œå…³ç³»å†³å®šæ˜¯å¦ç‚¹èµ
                const shouldLike = await shouldCharacterLikeMomentWithMemory(character, moment);
                if (!shouldLike) {
                    console.log(`${character.name} åŸºäºäººè®¾å’Œè®°å¿†é€‰æ‹©ä¸ç‚¹èµè¿™æ¡åŠ¨æ€`);
                    return;
                }

            // æ·»åŠ ç‚¹èµè®°å½•
                await db.momentLikes.add({
                    momentId: parseInt(momentId),
                    authorId: character.id,
                characterId: character.id,
                name: character.name,
                timestamp: Date.now()
            });

            // æ›´æ–°ç•Œé¢æ˜¾ç¤º
            updateMomentLikeDisplay(momentId);

            // ğŸ”¥ã€ä¿®å¤ã€‘åªæœ‰ç”¨æˆ·çš„åŠ¨æ€è¢«ç‚¹èµæ—¶æ‰æ˜¾ç¤ºtoastå’Œæ¨é€é€šçŸ¥
            if (moment.authorId === 'user') {
                // æ˜¾ç¤ºç‚¹èµæç¤º
                showToast(`${character.name} èµäº†ä½ çš„åŠ¨æ€`);
                // åˆ›å»ºæ¨é€é€šçŸ¥
                createPushNotification(character, `èµäº†ä½ çš„åŠ¨æ€`, 100);
            }

            // è®°å½•åˆ°è·¨åº”ç”¨æ—¶é—´çº¿
            await recordMemoryEvent(
                [character.id],
                {
                    type: 'moments',
                    id: 'moments'
                },
                'moment_like',
                `ç‚¹èµäº†${moment.authorId === 'user' ? 'ç”¨æˆ·' : moment.nickname}çš„åŠ¨æ€`
            );
            } catch (error) {
                console.error('AIç‚¹èµå¤±è´¥:', error);
            }
        }

        // ä¿ç•™åŸæœ‰çš„ç‚¹èµå‡½æ•°ä½œä¸ºå…¼å®¹
        async function addAILike(momentId, character, moment) {
            return await addAILikeWithPersonality(momentId, character, moment);
        }
        
        // åŸºäºäººè®¾å’Œè®°å¿†ç³»ç»Ÿåˆ¤æ–­è§’è‰²æ˜¯å¦ä¼šç‚¹èµè¿™æ¡åŠ¨æ€
        async function shouldCharacterLikeMomentWithMemory(character, moment) {
            try {
                // è·å–è§’è‰²çš„èŠå¤©è®¾ç½®å’Œè®°å¿†
                let chatSettings = null;
                try {
                    chatSettings = await db.chatSettings.get(character.id);
                } catch (error) {
                    console.error('è·å–èŠå¤©è®¾ç½®å¤±è´¥:', error);
                }

                const persona = chatSettings?.aiPersona || character.prompt || character.bio || `ä½ æ˜¯${character.name}ã€‚`;

                // è·å–è§’è‰²ä¸åŠ¨æ€å‘å¸ƒè€…çš„å…³ç³»è®°å¿†
                let relationshipMemory = '';
                if (moment.characterId && moment.characterId !== 'user') {
                    // è·å–ä¸å…¶ä»–è§’è‰²çš„å…³ç³»è®°å¿†
                    const coreMemories = await db.coreMemories
                        .where('characterId')
                        .equals(character.id)
                        .toArray();

                    const relationMemories = coreMemories.filter(memory =>
                        memory.fact && memory.fact.includes(moment.nickname)
                    );

                    if (relationMemories.length > 0) {
                        relationshipMemory = relationMemories.map(m => m.fact).join('ï¼›');
                    }
                }

                // åŸºäºè§’è‰²äººè®¾å’ŒåŠ¨æ€å†…å®¹çš„åˆ¤æ–­
                const characterBio = persona.toLowerCase();
                const momentText = (moment.text || '').toLowerCase();
                const momentAuthor = moment.nickname || 'ç”¨æˆ·';

                // æ£€æŸ¥æ˜¯å¦å­˜åœ¨è´Ÿé¢å…³ç³»è®°å¿†
                if (relationshipMemory) {
                    const negativeKeywords = ['åµæ¶', 'äº‰æ‰§', 'è®¨åŒ', 'ä¸å–œæ¬¢', 'æ•Œå¯¹', 'ç«äº‰', 'æƒ…æ•Œ', 'å†²çª'];
                    const hasNegativeRelation = negativeKeywords.some(keyword =>
                        relationshipMemory.toLowerCase().includes(keyword)
                    );

                    if (hasNegativeRelation) {
                        console.log(`${character.name} ä¸ ${momentAuthor} å­˜åœ¨è´Ÿé¢å…³ç³»è®°å¿†ï¼Œä¸ä¼šç‚¹èµ`);
                        return false;
                    }
                }

                // å¦‚æœè§’è‰²äººè®¾ä¸­åŒ…å«è´Ÿé¢è¯æ±‡ï¼Œé™ä½ç‚¹èµæ¦‚ç‡
                const negativeTraits = ['å†·æ¼ ', 'ä¸¥è‚ƒ', 'ä¸å–„äº¤é™…', 'å†…å‘', 'æ²‰é»˜'];
                const hasNegativeTraits = negativeTraits.some(trait => characterBio.includes(trait));

                if (hasNegativeTraits && Math.random() < 0.7) {
                    return false; // 70%æ¦‚ç‡ä¸ç‚¹èµ
                }

                // å¦‚æœåŠ¨æ€å†…å®¹ä¸è§’è‰²å…´è¶£ç›¸å…³ï¼Œå¢åŠ ç‚¹èµæ¦‚ç‡
                const characterInterests = extractInterestsFromBio(characterBio);
                const hasRelatedContent = characterInterests.some(interest =>
                    momentText.includes(interest)
                );

                if (hasRelatedContent) {
                    return Math.random() < 0.9; // 90%æ¦‚ç‡ç‚¹èµ
                }

                // å¦‚æœæ˜¯ç”¨æˆ·å‘çš„åŠ¨æ€ï¼Œå¢åŠ ç‚¹èµæ¦‚ç‡
                if (!moment.characterId || moment.characterId === 'user') {
                    return Math.random() < 0.8; // 80%æ¦‚ç‡ç‚¹èµ
                }

                // é»˜è®¤æƒ…å†µ
                return Math.random() < 0.7; // 70%æ¦‚ç‡ç‚¹èµ
            } catch (error) {
                console.error('åˆ¤æ–­è§’è‰²ç‚¹èµåå¥½å¤±è´¥:', error);
                return Math.random() < 0.6; // é»˜è®¤60%æ¦‚ç‡
            }
        }

        // ä¿ç•™åŸæœ‰å‡½æ•°ä½œä¸ºå…¼å®¹
        async function shouldCharacterLikeMoment(character, moment) {
            return await shouldCharacterLikeMomentWithMemory(character, moment);
        }
        
        // ä»è§’è‰²äººè®¾ä¸­æå–å…´è¶£å…³é”®è¯
        function extractInterestsFromBio(bio) {
            const interests = [];
            const interestKeywords = [
                'éŸ³ä¹', 'ç”µå½±', 'è¯»ä¹¦', 'è¿åŠ¨', 'æ¸¸æˆ', 'ç¾é£Ÿ', 'æ—…è¡Œ', 'æ‘„å½±',
                'ç»˜ç”»', 'å†™ä½œ', 'ä»£ç ', 'ç§‘æŠ€', 'åŠ¨æ¼«', 'å°è¯´', 'å’–å•¡', 'èŒ¶',
                'å® ç‰©', 'èŠ±', 'æ˜Ÿç©º', 'é›¨å¤©', 'é˜³å…‰', 'å­¦ä¹ ', 'å·¥ä½œ', 'æœ‹å‹'
            ];
            
            interestKeywords.forEach(keyword => {
                if (bio.includes(keyword)) {
                    interests.push(keyword);
                }
            });
            
            return interests;
        }
        
        // æ›´æ–°åŠ¨æ€ç‚¹èµæ˜¾ç¤º
        async function updateMomentLikeDisplay(momentId) {
            try {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;
            
                const momentLikes = await db.momentLikes.where('momentId').equals(parseInt(momentId)).toArray();
            
            // æ›´æ–°ç‚¹èµæŒ‰é’®æ•°å­—
            const likeBtn = momentElement.querySelector('.moment-action-btn[onclick*="toggleMomentLike"]');
            if (likeBtn) {
                const likeCount = likeBtn.querySelector('span');
                if (likeCount) {
                    likeCount.textContent = momentLikes.length;
                }
            }
            
            // æ›´æ–°æˆ–åˆ›å»ºç‚¹èµç”¨æˆ·åç§°æ˜¾ç¤º
            let likesDisplay = momentElement.querySelector('.likes-display');
            
            if (momentLikes.length > 0) {
                if (!likesDisplay) {
                    likesDisplay = document.createElement('div');
                    likesDisplay.className = 'likes-display';
                    
                    // æ£€æŸ¥æ˜¯å¦å·²æœ‰è¯„è®ºåŒºåŸŸï¼Œå¦‚æœæœ‰å°±ä¸è®¾ç½®margin-top
                        const existingCommentsSection = momentElement.querySelector('.moment-comments-section');
                        const marginTop = existingCommentsSection ? '0' : '0';
                    
                    likesDisplay.style.cssText = `
                        margin-top: ${marginTop};
                        padding: 8px 12px;
                        background: #f8f9fa;
                        font-size: 13px;
                        color: #666;
                        line-height: 1.4;
                    `;
                    
                        // æ’å…¥åˆ°æ“ä½œæŒ‰é’®ä¸‹é¢ï¼Œè¯„è®ºåŒºå‰é¢ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ï¼Œå¦åˆ™åœ¨æ—¶é—´æ“ä½œåŒºåé¢
                    const momentContent = momentElement.querySelector('.moment-content');
                    const momentTimeActions = momentElement.querySelector('.moment-time-actions');
                        const commentsSection = momentElement.querySelector('.moment-comments-section');
                        
                    if (momentContent && momentTimeActions) {
                            if (commentsSection) {
                                // å¦‚æœå·²æœ‰è¯„è®ºåŒºï¼Œæ’å…¥åˆ°è¯„è®ºåŒºå‰é¢
                                momentContent.insertBefore(likesDisplay, commentsSection);
                            } else {
                                // æ²¡æœ‰è¯„è®ºåŒºï¼Œæ’å…¥åˆ°æ—¶é—´æ“ä½œåŒºåé¢
                        momentTimeActions.parentNode.insertBefore(likesDisplay, momentTimeActions.nextSibling);
                            }
                    }
                }
                
                // ä½¿ç”¨å’Œç”¨æˆ·æ˜µç§°ç›¸åŒé¢œè‰²çš„ç©ºå¿ƒçˆ±å¿ƒ
                const likeIcon = '<svg width="14" height="14" style="margin-right: 4px; vertical-align: middle;" viewBox="0 0 24 24" fill="none" stroke="#576b95" stroke-width="2"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>';
                const names = momentLikes.map(like => like.name).join('ã€');
                likesDisplay.innerHTML = `${likeIcon}<span style="color: #576b95; font-weight: 600;">${names}</span>`;
                likesDisplay.style.display = 'block';
            } else if (likesDisplay) {
                likesDisplay.style.display = 'none';
                }
            } catch (error) {
                console.error('æ›´æ–°ç‚¹èµæ˜¾ç¤ºå¤±è´¥:', error);
            }
        }
        
        // AIè§’è‰²è¯„è®ºï¼ˆåŸºäºäººè®¾å’Œè®°å¿†ç³»ç»Ÿï¼‰
        async function addAICommentWithPersonality(momentId, character, moment) {
            try {
                // ç”Ÿæˆç¬¦åˆè§’è‰²äººè®¾å’Œè®°å¿†ç³»ç»Ÿçš„è¯„è®º
                const comments = await generateCharacterCommentWithMemory(character, moment);
                if (!comments || comments.length === 0) return;

                const randomComment = comments[Math.floor(Math.random() * comments.length)];

                const comment = {
                    id: Date.now() + Math.random(),
                    nickname: character.name,
                    avatar: character.avatarUrl,
                    text: randomComment,
                    time: formatTime(new Date()),
                    timestamp: Date.now(),
                    characterId: character.id
                };

                // ä¿å­˜è¯„è®º
                saveCommentToMoment(momentId, comment);

                // æ›´æ–°è¯„è®ºæ•°
                updateMomentCommentCount(momentId);

                // åœ¨åŠ¨æ€ä¸‹æ–¹æ˜¾ç¤ºæ–°è¯„è®º
                displayCommentUnderMoment(momentId, comment);

                // ğŸ”¥ã€ä¿®å¤ã€‘åªæœ‰å½“ç”¨æˆ·å‘å¸ƒçš„åŠ¨æ€è¢«è§’è‰²è¯„è®ºæ—¶ï¼Œæ‰æ˜¾ç¤ºè¯„è®ºæç¤ºå’Œå‘é€é€šçŸ¥
                if (moment.authorId === 'user') {
                    showToast(`${character.name} è¯„è®ºäº†ä½ çš„åŠ¨æ€`);
                    createPushNotification(character, `è¯„è®ºäº†ä½ çš„åŠ¨æ€ï¼š${randomComment.length > 15 ? randomComment.substring(0, 15) + '...' : randomComment}`, 200);
                }

                // è®°å½•åˆ°è·¨åº”ç”¨æ—¶é—´çº¿
                await recordMemoryEvent(
                    [character.id],
                    {
                        type: 'moments',
                        id: 'moments'
                    },
                    'moment_comment',
                    `è¯„è®ºäº†${moment.authorId === 'user' ? 'ç”¨æˆ·' : moment.nickname}çš„åŠ¨æ€ï¼š${randomComment}`
                );
            } catch (error) {
                console.error('AIè§’è‰²è¯„è®ºå¤±è´¥:', error);
            }
        }

        // ä¿ç•™åŸæœ‰çš„è¯„è®ºå‡½æ•°ä½œä¸ºå…¼å®¹
        async function addAIComment(momentId, character, moment) {
            return await addAICommentWithPersonality(momentId, character, moment);
        }
        
        // ğŸ”¥ã€æ–°å¢ã€‘åŸºäºäººè®¾å’Œè®°å¿†ç³»ç»Ÿçš„è§’è‰²é—´äº’åŠ¨
        async function triggerAiToAiInteractionWithPersonality(momentId, relatedCharacters) {
            try {
                // è·å–åŠ¨æ€ä¿¡æ¯
                const moment = await db.moments.get(parseInt(momentId));
                if (!moment) return;

                // è·å–è¯¥åŠ¨æ€çš„æ‰€æœ‰è¯„è®º
                const comments = await db.momentComments
                    .where('momentId')
                    .equals(parseInt(momentId))
                    .toArray();

                if (comments.length < 2) return; // è‡³å°‘éœ€è¦2æ¡è¯„è®ºæ‰èƒ½è§¦å‘è§’è‰²é—´äº’åŠ¨

                // è·å–å‚ä¸è¯„è®ºçš„AIè§’è‰²
                const participatingAis = [...new Set(comments
                    .filter(comment => comment.characterId && comment.characterId !== 'user')
                    .map(comment => comment.characterId)
                )];

                // è¿‡æ»¤å‡ºåªæœ‰åœ¨åŒç¾¤çš„AIè§’è‰²
                const sameGroupParticipants = participatingAis.filter(aiId =>
                    relatedCharacters.some(char => char.id === aiId)
                );

                if (sameGroupParticipants.length < 2) {
                    console.log('å‚ä¸è¯„è®ºçš„åŒç¾¤AIè§’è‰²å°‘äº2ä¸ªï¼Œè·³è¿‡è§’è‰²é—´äº’åŠ¨');
                    return;
                }

                console.log(`å‘ç° ${sameGroupParticipants.length} ä¸ªåŒç¾¤AIè§’è‰²å‚ä¸äº†è¯„è®ºï¼Œå¼€å§‹è§’è‰²é—´äº’åŠ¨`);

                // éšæœºé€‰æ‹©ä¸¤ä¸ªåŒç¾¤AIè¿›è¡Œäº’åŠ¨
                const aiA = sameGroupParticipants[Math.floor(Math.random() * sameGroupParticipants.length)];
                let aiB = sameGroupParticipants[Math.floor(Math.random() * sameGroupParticipants.length)];

                // ç¡®ä¿é€‰æ‹©ä¸åŒçš„AI
                while (aiB === aiA && sameGroupParticipants.length > 1) {
                    aiB = sameGroupParticipants[Math.floor(Math.random() * sameGroupParticipants.length)];
                }

                if (aiA === aiB) return;

                // è·å–è§’è‰²ä¿¡æ¯
                const charA = characters.find(c => c.id === aiA);
                const charB = characters.find(c => c.id === aiB);

                if (!charA || !charB) return;

                // æ£€æŸ¥è§’è‰²å…³ç³»å’Œäº’åŠ¨æ¦‚ç‡ï¼ˆåŸºäºè®°å¿†ç³»ç»Ÿï¼‰
                const shouldInteract = await shouldCharactersInteract(charA, charB);
                if (!shouldInteract) {
                    console.log(`${charA.name} å’Œ ${charB.name} åŸºäºå…³ç³»è®°å¿†é€‰æ‹©ä¸äº’åŠ¨`);
                    return;
                }

                // é€‰æ‹©ä¸€ä¸ªç°æœ‰è¯„è®ºä½œä¸ºäº’åŠ¨èµ·ç‚¹
                const targetComment = comments.find(comment =>
                    comment.characterId === aiA || comment.characterId === aiB
                );

                if (!targetComment) return;

                // å†³å®šè°å…ˆå›å¤è°
                const responderCharId = targetComment.characterId === aiA ? aiB : aiA;
                const targetCharId = targetComment.characterId;

                // è·å–è§’è‰²ä¿¡æ¯
                const responderChar = characters.find(c => c.id === responderCharId);
                const targetChar = characters.find(c => c.id === targetCharId);

                if (!responderChar || !targetChar) return;

                console.log(`${responderChar.name} å°†å›å¤ ${targetChar.name} çš„è¯„è®º`);

                // ç”ŸæˆåŸºäºè®°å¿†ç³»ç»Ÿçš„AIé—´äº’åŠ¨å›å¤
                await generateAiToAiReplyWithMemory(momentId, targetComment, responderChar, targetChar);

            } catch (error) {
                console.error('è§’è‰²é—´äº’åŠ¨å¤±è´¥:', error);
            }
        }

        // ä¿ç•™åŸæœ‰çš„è§’è‰²é—´äº’åŠ¨å‡½æ•°ä½œä¸ºå…¼å®¹
        async function triggerAiToAiInteraction(momentId, relatedCharacters) {
            return await triggerAiToAiInteractionWithPersonality(momentId, relatedCharacters);
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ£€æŸ¥ä¸¤ä¸ªè§’è‰²æ˜¯å¦åº”è¯¥äº’åŠ¨ï¼ˆåŸºäºè®°å¿†ç³»ç»Ÿï¼‰
        async function shouldCharactersInteract(charA, charB) {
            try {
                // è·å–è§’è‰²Aå¯¹è§’è‰²Bçš„è®°å¿†
                const memoriesA = await db.coreMemories
                    .where('characterId')
                    .equals(charA.id)
                    .toArray();

                const relationMemoriesA = memoriesA.filter(memory =>
                    memory.fact && memory.fact.includes(charB.name)
                );

                // è·å–è§’è‰²Bå¯¹è§’è‰²Açš„è®°å¿†
                const memoriesB = await db.coreMemories
                    .where('characterId')
                    .equals(charB.id)
                    .toArray();

                const relationMemoriesB = memoriesB.filter(memory =>
                    memory.fact && memory.fact.includes(charA.name)
                );

                // æ£€æŸ¥æ˜¯å¦å­˜åœ¨è´Ÿé¢å…³ç³»è®°å¿†
                const allRelationMemories = [...relationMemoriesA, ...relationMemoriesB];
                const negativeKeywords = ['åµæ¶', 'äº‰æ‰§', 'è®¨åŒ', 'ä¸å–œæ¬¢', 'æ•Œå¯¹', 'ç«äº‰', 'æƒ…æ•Œ', 'å†²çª', 'çŸ›ç›¾'];

                const hasNegativeRelation = allRelationMemories.some(memory =>
                    negativeKeywords.some(keyword =>
                        memory.fact.toLowerCase().includes(keyword)
                    )
                );

                if (hasNegativeRelation) {
                    // å¦‚æœæœ‰è´Ÿé¢å…³ç³»ï¼Œåªæœ‰20%æ¦‚ç‡äº’åŠ¨ï¼ˆå¯èƒ½æ˜¯å†·å˜²çƒ­è®½ï¼‰
                    return Math.random() < 0.2;
                }

                // æ£€æŸ¥æ˜¯å¦æœ‰æ­£é¢å…³ç³»è®°å¿†
                const positiveKeywords = ['æœ‹å‹', 'å–œæ¬¢', 'äº²å¯†', 'åˆä½œ', 'å¸®åŠ©', 'æ”¯æŒ', 'å…³å¿ƒ'];
                const hasPositiveRelation = allRelationMemories.some(memory =>
                    positiveKeywords.some(keyword =>
                        memory.fact.toLowerCase().includes(keyword)
                    )
                );

                if (hasPositiveRelation) {
                    // å¦‚æœæœ‰æ­£é¢å…³ç³»ï¼Œ80%æ¦‚ç‡äº’åŠ¨
                    return Math.random() < 0.8;
                }

                // é»˜è®¤æƒ…å†µï¼Œ40%æ¦‚ç‡äº’åŠ¨
                return Math.random() < 0.4;

            } catch (error) {
                console.error('æ£€æŸ¥è§’è‰²äº’åŠ¨å…³ç³»å¤±è´¥:', error);
                return Math.random() < 0.4; // é»˜è®¤40%æ¦‚ç‡
            }
        }

        // AIè§’è‰²é—´çš„æ¥¼ä¸­æ¥¼äº’åŠ¨ï¼ˆå¥—ç”¨å®Œæˆ.htmlé€»è¾‘ï¼‰
        async function triggerAiToAiInteractionOld(momentId, relatedCharacters) {
            try {
                // è·å–åŠ¨æ€ä¿¡æ¯
                const momentsData = JSON.parse(sessionStorage.getItem('momentsData') || '[]');
                const moment = momentsData.find(m => (m.id == momentId) || (m.timestamp == momentId));
                if (!moment || !moment.comments) return;
                
                const comments = moment.comments;
                if (comments.length < 2) return; // è‡³å°‘éœ€è¦2æ¡è¯„è®ºæ‰èƒ½è§¦å‘è§’è‰²é—´äº’åŠ¨
                
                // è·å–åœ¨åŒç¾¤çš„å‚ä¸è¯„è®ºAIè§’è‰²
                const participatingAis = [...new Set(comments
                    .filter(comment => comment.characterId && comment.characterId !== 'user')
                    .map(comment => comment.characterId)
                )];
                
                // è¿‡æ»¤å‡ºåªæœ‰åœ¨åŒç¾¤çš„AIè§’è‰²
                const sameGroupParticipants = participatingAis.filter(aiId => 
                    relatedCharacters.some(char => char.id === aiId)
                );
                
                if (sameGroupParticipants.length < 2) {
                    console.log('å‚ä¸è¯„è®ºçš„åŒç¾¤AIè§’è‰²å°‘äº2ä¸ªï¼Œè·³è¿‡è§’è‰²é—´äº’åŠ¨');
                    return;
                }
                
                console.log(`å‘ç° ${sameGroupParticipants.length} ä¸ªåŒç¾¤AIè§’è‰²å‚ä¸äº†è¯„è®ºï¼Œå¼€å§‹è§’è‰²é—´äº’åŠ¨`);
                
                // éšæœºé€‰æ‹©ä¸¤ä¸ªåŒç¾¤AIè¿›è¡Œäº’åŠ¨
                const aiA = sameGroupParticipants[Math.floor(Math.random() * sameGroupParticipants.length)];
                let aiB = sameGroupParticipants[Math.floor(Math.random() * sameGroupParticipants.length)];
                
                // ç¡®ä¿é€‰æ‹©ä¸åŒçš„AI
                while (aiB === aiA && sameGroupParticipants.length > 1) {
                    aiB = sameGroupParticipants[Math.floor(Math.random() * sameGroupParticipants.length)];
                }
                
                if (aiA === aiB) return;
                
                // æ£€æŸ¥è§’è‰²å…³ç³»å’Œäº’åŠ¨æ¦‚ç‡ (40%æ¦‚ç‡ï¼Œä¿æŒåŸæœ‰è®¾ç½®æ¦‚ç‡)
                if (Math.random() > 0.4) {
                    console.log('åŸºäºæ¦‚ç‡é€‰æ‹©ä¸è¿›è¡Œè§’è‰²é—´äº’åŠ¨');
                    return;
                }
                
                // é€‰æ‹©ä¸€ä¸ªç°æœ‰è¯„è®ºä½œä¸ºäº’åŠ¨èµ·ç‚¹
                const targetComment = comments.find(comment => 
                    comment.characterId === aiA || comment.characterId === aiB
                );
                
                if (!targetComment) return;
                
                // å†³å®šè°å…ˆå›å¤è°
                const responderCharId = targetComment.characterId === aiA ? aiB : aiA;
                const targetCharId = targetComment.characterId;
                
                // è·å–è§’è‰²ä¿¡æ¯
                const responderChar = characters.find(c => c.id === responderCharId);
                const targetChar = characters.find(c => c.id === targetCharId);
                
                if (!responderChar || !targetChar) return;
                
                console.log(`${responderChar.name} å°†å›å¤ ${targetChar.name} çš„è¯„è®º`);
                
                // ç”ŸæˆAIé—´çš„äº’åŠ¨å›å¤
                await generateAiToAiReply(momentId, targetComment, responderChar, targetChar);
                
            } catch (error) {
                console.error('è§’è‰²é—´äº’åŠ¨å¤±è´¥:', error);
            }
        }
        

        
        // è§’è‰²ä¹‹é—´äº’åŠ¨ï¼ˆä¿ç•™åŸå‡½æ•°ï¼Œä½†ä¸å†ä½¿ç”¨ï¼‰
        function triggerCharacterInteractions(momentId, characters) {
            if (characters.length < 2) return;
            
            // è·å–å·²åœ¨åŒä¸€ç¾¤çš„è§’è‰²å…³ç³»
            const groupRelations = getGroupRelations(characters);
            
            for (let i = 0; i < characters.length - 1; i++) {
                for (let j = i + 1; j < characters.length; j++) {
                    const char1 = characters[i];
                    const char2 = characters[j];
                    
                    // æ£€æŸ¥æ˜¯å¦åœ¨åŒä¸€ä¸ªç¾¤é‡Œ
                    const inSameGroup = groupRelations.some(group => 
                        group.includes(char1.id) && group.includes(char2.id)
                    );
                    
                    if (inSameGroup && Math.random() < 0.6) {
                        addCharacterInteraction(momentId, char1, char2);
                    }
                }
            }
        }
        
        // è·å–åˆ†ç»„å…³ç³» - åŸºäºè§’è‰²åˆ†ç»„è€Œä¸æ˜¯ç¾¤èŠ
        function getGroupRelations(characters) {
            const groups = [];
            
            // æŒ‰åˆ†ç»„IDåˆ†ç»„è§’è‰²
            const groupedCharacters = {};
            characters.forEach(character => {
                const groupId = character.groupId || 'my_friends';
                if (!groupedCharacters[groupId]) {
                    groupedCharacters[groupId] = [];
                }
                groupedCharacters[groupId].push(character.id);
            });
            
            // åªè¿”å›å¯ä»¥äº’åŠ¨çš„åˆ†ç»„ï¼ˆéé»˜è®¤åˆ†ç»„ä¸”å…è®¸äº’åŠ¨ï¼‰
            Object.entries(groupedCharacters).forEach(([groupId, characterIds]) => {
                const group = characterGroups.find(g => g.id === groupId);
                
                // åªæœ‰éé»˜è®¤åˆ†ç»„ä¸”å…è®¸äº’åŠ¨çš„åˆ†ç»„ä¸­çš„è§’è‰²æ‰èƒ½ç›¸äº’äº’åŠ¨
                if (group && !group.isDefault && group.canInteract && characterIds.length >= 2) {
                    groups.push(characterIds);
                }
            });
            
            return groups;
        }
        
        // ğŸ”¥ã€æ–°å¢ã€‘ç”ŸæˆåŸºäºè®°å¿†ç³»ç»Ÿçš„AIé—´å›å¤
        async function generateAiToAiReplyWithMemory(momentId, targetComment, responderChar, targetChar) {
            try {
                // è·å–åŠ¨æ€ä¿¡æ¯
                const moment = await db.moments.get(parseInt(momentId));
                if (!moment) return;

                // è·å–å›å¤è€…çš„èŠå¤©è®¾ç½®å’Œè®°å¿†
                let chatSettings = null;
                try {
                    chatSettings = await db.chatSettings.get(responderChar.id);
                } catch (error) {
                    console.error('è·å–èŠå¤©è®¾ç½®å¤±è´¥:', error);
                }

                const persona = chatSettings?.aiPersona || responderChar.prompt || `ä½ æ˜¯${responderChar.name}ã€‚`;

                // è·å–ä¸ç›®æ ‡è§’è‰²çš„å…³ç³»è®°å¿†
                let relationshipMemory = '';
                const coreMemories = await db.coreMemories
                    .where('characterId')
                    .equals(responderChar.id)
                    .toArray();

                const relationMemories = coreMemories.filter(memory =>
                    memory.fact && memory.fact.includes(targetChar.name)
                );

                if (relationMemories.length > 0) {
                    relationshipMemory = '\n\nä½ ä»¬çš„å…³ç³»è®°å¿†ï¼š\n' + relationMemories.map(m => m.fact).join('ï¼›');
                }

                // è·å–ç»‘å®šçš„ä¸–ç•Œä¹¦å†…å®¹
                let worldBookContent = '';
                if (chatSettings?.linkedWorldBookIds && chatSettings.linkedWorldBookIds.length > 0) {
                    try {
                        const worldBooks = await Promise.all(
                            chatSettings.linkedWorldBookIds.map(id => db.worldbooks.get(id))
                        );
                        const validWorldBooks = worldBooks.filter(book => book && book.content);
                        if (validWorldBooks.length > 0) {
                            worldBookContent = '\n\nä¸–ç•Œä¹¦å†…å®¹ï¼ˆä¾›å‚è€ƒï¼‰ï¼š\n' +
                                validWorldBooks.map(book => `${book.name}ï¼š${book.content}`).join('\n\n');
                        }
                    } catch (error) {
                        console.error('è·å–ä¸–ç•Œä¹¦å†…å®¹å¤±è´¥:', error);
                    }
                }

                const systemPrompt = `ä½ æ˜¯${responderChar.name}ï¼Œä½ çš„äººè®¾å¦‚ä¸‹ï¼š${persona}ã€‚${worldBookContent}${relationshipMemory}

åœ¨ä¸€ä¸ªåŠ¨æ€çš„è¯„è®ºåŒºï¼Œ${targetChar.name} åˆšåˆšè¯„è®ºäº†ï¼š"${targetComment.text}"

åŸåŠ¨æ€å†…å®¹ï¼š${moment.text}

è¯·ä½œä¸º${responderChar.name}ï¼ŒåŸºäºä½ çš„äººè®¾å’Œä¸${targetChar.name}çš„å…³ç³»è®°å¿†ï¼Œå¯¹taçš„è¯„è®ºè¿›è¡Œå›åº”ã€‚

## é‡è¦æé†’ï¼š
- å¦‚æœä½ ä»¬çš„å…³ç³»è®°å¿†ä¸­æœ‰è´Ÿé¢å†…å®¹ï¼ˆå¦‚åµæ¶ã€äº‰æ‰§ã€æƒ…æ•Œç­‰ï¼‰ï¼Œè¯·æ ¹æ®ä½ çš„æ€§æ ¼å†³å®šå›åº”æ–¹å¼
- å¦‚æœå…³ç³»å¾ˆå¥½ï¼Œå¯ä»¥æ›´åŠ äº²å¯†å’Œéšæ„
- å¦‚æœå…³ç³»ä¸å¥½ï¼Œå¯ä»¥å†·æ·¡ã€è®½åˆºæˆ–ç›´æ¥å¿½ç•¥

## å›åº”è¦æ±‚ï¼š
1. ä¸¥æ ¼æŒ‰ç…§ä½ çš„äººè®¾å’Œæ€§æ ¼ç‰¹ç‚¹
2. æ ¹æ®ä½ ä»¬çš„å…³ç³»è®°å¿†è°ƒæ•´è¯­æ°”å’Œæ€åº¦
3. å›å¤è¦ç®€æ´ï¼Œ10-25å­—å·¦å³
4. å¯ä»¥æ˜¯ï¼šèµåŒã€åé©³ã€è°ƒä¾ƒã€è¯¢é—®ã€è¡¥å……ç­‰
5. è¦ç¬¦åˆæœ‹å‹åœˆè¯„è®ºçš„è‡ªç„¶é£æ ¼
6. ä¸è¦ä½¿ç”¨ä¸è§’è‰²æ€§æ ¼ä¸ç¬¦çš„è¡¨æƒ…ç¬¦å·

è¯·ç”Ÿæˆä¸€æ¡è‡ªç„¶çš„å›å¤ï¼š`;

                // è°ƒç”¨AI APIç”Ÿæˆå›å¤
                const { base: proxyUrl, key: apiKey, model } = apiSettings;
                if (!proxyUrl || !apiKey || !model) {
                    console.log('APIé…ç½®ä¸å®Œæ•´ï¼Œè·³è¿‡AIé—´äº’åŠ¨');
                    return;
                }

                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: 'è¯·å›å¤è¿™æ¡è¯„è®ºï¼š' }
                ];

                const requestBody = {
                    model: model,
                    messages: messages,
                    temperature: 0.8,
                    stream: false
                };

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000);

                // æ£€æµ‹æ˜¯å¦æ˜¯Geminiå®˜æ–¹API
                const isGeminiOfficial = proxyUrl.includes('generativelanguage.googleapis.com');

                let response;
                if (isGeminiOfficial) {
                    // ä½¿ç”¨Geminiå®˜æ–¹APIæ ¼å¼
                    const apiUrl = `${proxyUrl}/models/${model}:generateContent?key=${apiKey}`;

                    const geminiMessages = [];
                    if (requestBody.messages[0]?.role === 'system') {
                        geminiMessages.push({
                            role: 'user',
                            parts: [{ text: requestBody.messages[0].content }]
                        });
                        geminiMessages.push({
                            role: 'model',
                            parts: [{ text: 'æˆ‘æ˜ç™½äº†ï¼Œæˆ‘ä¼šæŒ‰ç…§è¿™äº›è¦æ±‚è¿›è¡Œå›å¤ã€‚' }]
                        });
                    }

                    for (let i = 1; i < requestBody.messages.length; i++) {
                        const msg = requestBody.messages[i];
                        if (msg.role === 'system') continue;

                        geminiMessages.push({
                            role: msg.role === 'user' ? 'user' : 'model',
                            parts: [{ text: msg.content }]
                        });
                    }

                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiMessages,
                            generationConfig: {
                                temperature: requestBody.temperature || 0.8
                            }
                        }),
                        signal: controller.signal
                    });
                } else {
                    // ä½¿ç”¨OpenAIæ ¼å¼
                    let apiUrl;
                    if (proxyUrl.endsWith('/v1')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else if (proxyUrl.includes('/v1/')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else {
                        apiUrl = `${proxyUrl}/v1/chat/completions`;
                    }

                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal
                    });
                }

                clearTimeout(timeoutId);

                if (!response.ok) {
                    console.error(`AIé—´äº’åŠ¨APIè°ƒç”¨å¤±è´¥ (${response.status})`);
                    return;
                }

                const data = await response.json();
                let content;

                if (isGeminiOfficial) {
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                } else {
                    content = data.choices?.[0]?.message?.content || data.message || data.text || data.response || data.content || data.result;
                }

                if (content && content.trim().length > 0) {
                    const replyText = content.trim();

                    // åˆ›å»ºå›å¤è¯„è®º
                    const replyComment = {
                        id: Date.now() + Math.random(),
                        nickname: responderChar.name,
                        avatar: responderChar.avatarUrl,
                        text: replyText,
                        time: formatTime(new Date()),
                        timestamp: Date.now(),
                        characterId: responderChar.id,
                        replyTo: targetChar.name
                    };

                    // ä¿å­˜å›å¤
                    await saveCommentToMoment(momentId, replyComment);

                    // æ›´æ–°è¯„è®ºæ•°
                    await updateMomentCommentCount(momentId);

                    // åœ¨åŠ¨æ€ä¸‹æ–¹æ˜¾ç¤ºæ–°å›å¤
                    displayCommentUnderMoment(momentId, replyComment);

                    // è®°å½•åˆ°è·¨åº”ç”¨æ—¶é—´çº¿
                    await recordMemoryEvent(
                        [responderChar.id],
                        {
                            type: 'moments',
                            id: 'moments'
                        },
                        'ai_to_ai_reply',
                        `å›å¤äº†${targetChar.name}çš„è¯„è®ºï¼š${replyText}`
                    );

                    console.log(`${responderChar.name} å›å¤äº† ${targetChar.name}ï¼š${replyText}`);
                }

            } catch (error) {
                console.error('ç”ŸæˆAIé—´å›å¤å¤±è´¥:', error);
            }
        }

        // ä¿ç•™åŸæœ‰çš„AIé—´å›å¤å‡½æ•°ä½œä¸ºå…¼å®¹
        async function generateAiToAiReply(momentId, targetComment, responderChar, targetChar) {
            return await generateAiToAiReplyWithMemory(momentId, targetComment, responderChar, targetChar);
        }

        // ç”ŸæˆAIé—´çš„å›å¤ï¼ˆä½¿ç”¨æ–°çš„è®°å¿†ç³»ç»Ÿï¼‰
        async function generateAiToAiReplyOld(momentId, targetComment, responderChar, targetChar) {
            try {
                // è·å–åŠ¨æ€ä¿¡æ¯
                const momentsData = JSON.parse(sessionStorage.getItem('momentsData') || '[]');
                const moment = momentsData.find(m => (m.id == momentId) || (m.timestamp == momentId));
                if (!moment) return;

                const targetPersona = targetChar.prompt || '';
                
                // ğŸ”¥ã€ä¿®å¤ã€‘ä½¿ç”¨æ–°çš„è®°å¿†ç³»ç»Ÿ
                const promptText = `ç°åœ¨åœ¨ä¸€ä¸ªåŠ¨æ€ä¸‹ï¼Œ${targetChar.name}ï¼ˆäººè®¾ï¼š${targetPersona}ï¼‰åˆšåˆšè¯„è®ºäº†ï¼š"${targetComment.text}"ã€‚

åŸåŠ¨æ€å†…å®¹ï¼š${moment.text}

ä½ è¦ä½œä¸º${responderChar.name}ï¼ŒåŸºäºä½ çš„äººè®¾å’Œä¸${targetChar.name}çš„å…³ç³»ï¼Œå¯¹taçš„è¯„è®ºè¿›è¡Œå›åº”ã€‚è¦æ±‚ï¼š
1. ä¸¥æ ¼æŒ‰ç…§ä½ çš„äººè®¾è¿›è¡Œå›å¤ï¼Œä¸èƒ½æ··æ·†è§’è‰²
2. å›å¤è¦è‡ªç„¶ã€ç¬¦åˆæœ‹å‹åœˆè¯„è®ºé£æ ¼
3. å¯ä»¥æ˜¯èµåŒã€ä¸åŒè§‚ç‚¹ã€è¡¥å……ã€æé—®æˆ–å¼€ç©ç¬‘
4. è¦ä½“ç°å‡ºä½ å’Œ${targetChar.name}ä¹‹é—´çš„äº’åŠ¨å…³ç³»
5. å›å¤ç®€çŸ­æœ‰è¶£ï¼Œç¬¦åˆç¤¾äº¤åª’ä½“çš„ç‰¹ç‚¹
6. æ ¹æ®ä½ çš„äººè®¾é€‰æ‹©åˆé€‚çš„è¯­æ°”å’Œç”¨è¯
7. ä¸è¦ä½¿ç”¨ä¸è§’è‰²æ€§æ ¼ä¸ç¬¦çš„è¡¨æƒ…ç¬¦å·

è¯·å›å¤${targetChar.name}çš„è¯„è®ºï¼š`;

                // ğŸ”¥ã€æ–°å¢ã€‘è®°å½•è·¨åº”ç”¨æ—¶é—´çº¿äº‹ä»¶
                await recordCrossAppEvent(
                    responderChar.id,
                    'moments',
                    'ai_to_ai_reply',
                    {
                        targetCharacter: targetChar.name,
                        originalComment: targetComment.text,
                        momentContent: moment.text
                    }
                );

                // ä½¿ç”¨æ–°çš„è®°å¿†ç³»ç»Ÿ
                const response = await callChatAPI(promptText, responderChar);
                const replyText = Array.isArray(response) ? response[0] : response;

                if (replyText && replyText.trim()) {
                    // åˆ›å»ºå›å¤è¯„è®º
                    const replyComment = {
                        id: Date.now() + Math.random(),
                        nickname: responderChar.name,
                        avatar: responderChar.avatarUrl,
                        text: replyText.trim(),
                    time: formatTime(new Date()),
                    timestamp: Date.now(),
                        replyTo: targetChar.name,
                        characterId: responderChar.id
                };
                
                    // ä¿å­˜è¯„è®º
                    saveCommentToMoment(momentId, replyComment);
                
                    // æ›´æ–°è¯„è®ºæ•°
                updateMomentCommentCount(momentId);
                
                    // åœ¨åŠ¨æ€ä¸‹æ–¹æ˜¾ç¤ºæ–°è¯„è®º
                    displayCommentUnderMoment(momentId, replyComment);
                
                    showToast(`${responderChar.name} å›å¤äº† ${targetChar.name}`);
                }

            } catch (error) {
                console.error('ç”ŸæˆAIé—´å›å¤å¤±è´¥:', error);
            }
        }
        
        // AIå›å¤ç”¨æˆ·è¯„è®ºï¼ˆä½¿ç”¨æ–°çš„è®°å¿†ç³»ç»Ÿï¼‰
        async function triggerAIReplyToUser(momentId, aiCharacterName, userCommentText) {
            try {
                console.log(`triggerAIReplyToUserè¢«è°ƒç”¨: momentId=${momentId}, aiCharacterName=${aiCharacterName}, userCommentText="${userCommentText}"`);

                // æ‰¾åˆ°å¯¹åº”çš„AIè§’è‰²
                const character = characters.find(c => c.name === aiCharacterName);
                if (!character) {
                    console.log(`æœªæ‰¾åˆ°è§’è‰² ${aiCharacterName}ï¼Œå¯ç”¨è§’è‰²:`, characters.map(c => c.name));
                    return;
                }

                // è·å–åŠ¨æ€ä¿¡æ¯
                const moment = await db.moments.get(parseInt(momentId));
                if (!moment) {
                    console.log(`æœªæ‰¾åˆ°åŠ¨æ€ ${momentId}`);
                    return;
                }

                // ğŸ”¥ã€ä¿®å¤ã€‘ä½¿ç”¨æ–°çš„è®°å¿†ç³»ç»Ÿï¼Œæ˜ç¡®è¦æ±‚çº¯æ–‡æœ¬è¾“å‡º
                const promptText = `åœ¨ä¸€ä¸ªåŠ¨æ€ä¸‹ï¼Œç”¨æˆ·åˆšåˆšå›å¤äº†ä½ çš„è¯„è®ºï¼š"${userCommentText}"ã€‚

åŸåŠ¨æ€å†…å®¹ï¼š${moment.text}

è¯·ä½œä¸º${character.name}ï¼ŒåŸºäºä½ çš„äººè®¾å¯¹ç”¨æˆ·çš„å›å¤åšå‡ºè‡ªç„¶çš„ååº”ã€‚è¦æ±‚ï¼š
1. ä¸¥æ ¼æŒ‰ç…§ä½ çš„äººè®¾è¿›è¡Œå›å¤ï¼Œä¿æŒè§’è‰²ä¸€è‡´æ€§
2. å›å¤è¦è‡ªç„¶ã€ç¬¦åˆæœ‹å‹åœˆè¯„è®ºé£æ ¼ï¼Œç®€çŸ­æœ‰è¶£
3. å¯ä»¥æ˜¯ç»§ç»­è®¨è®ºã€è¡¨è¾¾æ„Ÿè°¢ã€å¼€ç©ç¬‘æˆ–è€…åˆ†äº«æ›´å¤šæƒ³æ³•
4. ä½“ç°å‡ºä½ å’Œç”¨æˆ·ä¹‹é—´çš„å‹å¥½äº’åŠ¨
5. æ ¹æ®ä½ çš„äººè®¾é€‰æ‹©åˆé€‚çš„è¯­æ°”å’Œç”¨è¯
6. ä¸è¦ä½¿ç”¨ä¸è§’è‰²æ€§æ ¼ä¸ç¬¦çš„è¡¨æƒ…ç¬¦å·

ğŸš¨ **é‡è¦æ ¼å¼è¦æ±‚**ï¼š
- ç›´æ¥è¾“å‡ºä½ çš„å›å¤æ–‡æœ¬ï¼Œä¸è¦ä½¿ç”¨JSONæ ¼å¼
- ä¸è¦åŒ…å«ä»»ä½•ç‰¹æ®Šæ ‡è®°æˆ–æ ¼å¼ç¬¦å·
- åªè¾“å‡ºä½ æƒ³è¯´çš„è¯ï¼Œ10-30å­—å·¦å³

è¯·å›å¤ç”¨æˆ·çš„è¯„è®ºï¼š`;

                // ğŸ”¥ã€æ–°å¢ã€‘è®°å½•è·¨åº”ç”¨æ—¶é—´çº¿äº‹ä»¶
                await recordCrossAppEvent(
                    character.id,
                    'moments',
                    'reply_to_user',
                    {
                        userComment: userCommentText,
                        momentContent: moment.text
                    }
                );

                // ğŸ” ç»Ÿè®¡åŠ¨æ€å›å¤çš„è®°å¿†ä½¿ç”¨æƒ…å†µ
                await logMemoryUsageStats(character, 'moments_reply_to_user');

                // ä½¿ç”¨æ–°çš„è®°å¿†ç³»ç»Ÿ
                const response = await callChatAPI(promptText, character);

                // ğŸ”¥ã€ä¿®å¤ã€‘æ­£ç¡®å¤„ç†AIå›å¤æ ¼å¼ï¼Œé¿å…æ˜¾ç¤ºJSON
                let replyText;
                if (Array.isArray(response)) {
                    const firstItem = response[0];
                    if (typeof firstItem === 'string') {
                        replyText = firstItem;
                    } else if (typeof firstItem === 'object' && firstItem.content) {
                        replyText = firstItem.content;
                    } else if (typeof firstItem === 'object' && firstItem.message) {
                        replyText = firstItem.message;
                    } else {
                        replyText = String(firstItem);
                    }
                } else {
                    replyText = response;
                }

                console.log(`æ‰¾åˆ°è§’è‰² ${character.name}ï¼Œå‡†å¤‡ç”Ÿæˆå›å¤`);

                if (replyText && replyText.trim()) {
                    // åˆ›å»ºAIå›å¤è¯„è®º
                    const replyComment = {
                        id: Date.now() + Math.random(),
                        nickname: character.name,
                        avatar: character.avatarUrl,
                        text: replyText.trim(),
                        time: formatTime(new Date()),
                        timestamp: Date.now(),
                        replyTo: 'æˆ‘', // å›å¤ç”¨æˆ·
                        characterId: character.id
                    };

                    // ä¿å­˜è¯„è®º
                    saveCommentToMoment(momentId, replyComment);

                    // æ›´æ–°è¯„è®ºæ•°
                    updateMomentCommentCount(momentId);

                    // åœ¨åŠ¨æ€ä¸‹æ–¹æ˜¾ç¤ºæ–°è¯„è®º
                    displayCommentUnderMoment(momentId, replyComment);

                    // å¢åŠ å¯¹è¯å›åˆæ¬¡
                    const conversationKey = `${momentId}-${character.name}`;
                    const currentRounds = commentConversationRounds.get(conversationKey) || 0;
                    commentConversationRounds.set(conversationKey, currentRounds + 1);
                    console.log(`${character.name} åœ¨åŠ¨æ€ ${momentId} ä¸­çš„å¯¹è¯å›åˆæ¬¡æ›´æ–°ä¸º: ${currentRounds + 1}/10`);

                    showToast(`${character.name} å›å¤äº†ä½ `);

                    // ğŸ”¥ã€æ–°å¢ã€‘ä¸ºè§’è‰²å›å¤ç”¨æˆ·è¯„è®ºåˆ›å»ºæ¨é€é€šçŸ¥
                    createPushNotification(character, `å›å¤äº†ä½ ï¼š${replyText.trim().length > 15 ? replyText.trim().substring(0, 15) + '...' : replyText.trim()}`, 200);
                }

            } catch (error) {
                console.error('AIå›å¤ç”¨æˆ·å¤±è´¥:', error);
            }
        }
        
        // ç”Ÿæˆç¬¦åˆè§’è‰²äººè®¾å’Œè®°å¿†ç³»ç»Ÿçš„è¯„è®º
        async function generateCharacterCommentWithMemory(character, moment) {
            try {
                console.log(`${character.name} å¼€å§‹ç”Ÿæˆè¯„è®ºï¼ŒåŠ¨æ€å‘å¸ƒè€…: ${moment.nickname || moment.authorId}`);
                // è·å–è§’è‰²å¯¹åº”çš„èŠå¤©è®¾ç½®
                let chatSettings = null;
                try {
                    chatSettings = await db.chatSettings.get(character.id);
                } catch (error) {
                    console.error('è·å–èŠå¤©è®¾ç½®å¤±è´¥:', error);
                }

                const persona = chatSettings?.aiPersona || character.prompt || `ä½ æ˜¯${character.name}ã€‚`;

                // è·å–ç»‘å®šçš„ä¸–ç•Œä¹¦å†…å®¹
                let worldBookContent = '';
                if (chatSettings?.linkedWorldBookIds && chatSettings.linkedWorldBookIds.length > 0) {
                    try {
                    const worldBooks = await Promise.all(
                            chatSettings.linkedWorldBookIds.map(id => db.worldbooks.get(id))
                    );
                    const validWorldBooks = worldBooks.filter(book => book && book.content);
                    if (validWorldBooks.length > 0) {
                        worldBookContent = '\n\nä¸–ç•Œä¹¦å†…å®¹ï¼ˆä¾›å‚è€ƒï¼‰ï¼š\n' +
                            validWorldBooks.map(book => `${book.name}ï¼š${book.content}`).join('\n\n');
                    }
                    } catch (error) {
                        console.error('è·å–ä¸–ç•Œä¹¦å†…å®¹å¤±è´¥:', error);
                    }
                }

                // è·å–åˆ†å±‚è®°å¿†ç³»ç»Ÿå†…å®¹
                let memoryContent = '';
                try {
                    // è·å–æ ¸å¿ƒè®°å¿†
                    const coreMemories = await db.coreMemories
                        .where('characterId')
                        .equals(character.id)
                        .toArray();

                    const recentCoreMemories = coreMemories
                        .filter(m => m.type === 'core')
                        .sort((a, b) => b.importance - a.importance)
                        .slice(0, 5);

                    if (recentCoreMemories.length > 0) {
                        memoryContent += '\n\næ ¸å¿ƒè®°å¿†ï¼ˆé‡è¦çš„é•¿æœŸè®°å¿†ï¼‰ï¼š\n';
                        recentCoreMemories.forEach((memory, index) => {
                            memoryContent += `${index + 1}. ${memory.fact}\n`;
                        });
                    }

                    // è·å–æƒ…æ™¯è®°å¿†
                    const episodicMemories = await db.episodicMemories
                        .where('characterId')
                        .equals(character.id)
                        .toArray();

                    const recentEpisodicMemories = episodicMemories
                        .sort((a, b) => b.timestamp - a.timestamp)
                        .slice(0, 3);

                    if (recentEpisodicMemories.length > 0) {
                        memoryContent += '\n\næƒ…æ™¯è®°å¿†ï¼ˆæœ€è¿‘çš„é‡è¦ç»å†ï¼‰ï¼š\n';
                        recentEpisodicMemories.forEach((memory, index) => {
                            memoryContent += `${index + 1}. ${memory.fact}\n`;
                        });
                    }
                } catch (error) {
                    console.error('è·å–è®°å¿†å†…å®¹å¤±è´¥:', error);
                }

                // è·å–å·¥ä½œè®°å¿†ï¼ˆæœ€è¿‘çš„èŠå¤©è®°å½•ï¼‰
                let chatContext = '';
                const characterMessages = chatMessages[character.id] || [];
                if (characterMessages.length > 0) {
                    const maxMemory = parseInt(chatSettings?.maxMemory) || 10;
                    const recentHistory = characterMessages.slice(-maxMemory);
                    chatContext = '\n\nå·¥ä½œè®°å¿†ï¼ˆæœ€è¿‘çš„èŠå¤©è®°å½•ï¼‰ï¼š\n' +
                        recentHistory.map(msg => {
                            if (msg.role === 'user') return `ç”¨æˆ·ï¼š${msg.content}`;
                            return `${character.name}ï¼š${msg.content}`;
                        }).join('\n');
                }
                
                // åˆ†æåŠ¨æ€å†…å®¹ï¼Œæå–å…³é”®ä¿¡æ¯
                const momentText = moment.text || '';

                // ğŸ”¥ã€ä¿®å¤ã€‘æ­£ç¡®è·å–åŠ¨æ€å‘å¸ƒè€…ä¿¡æ¯
                let momentAuthor = 'ç”¨æˆ·';
                const isUserMoment = !moment.characterId || moment.characterId === 'user' || moment.authorId === 'user';

                if (!isUserMoment) {
                    // å¦‚æœæ˜¯è§’è‰²å‘å¸ƒçš„åŠ¨æ€ï¼ŒæŸ¥æ‰¾è§’è‰²ä¿¡æ¯
                    const publisherCharacter = characters.find(c => c.id === moment.characterId || c.id === moment.authorId);
                    if (publisherCharacter) {
                        momentAuthor = publisherCharacter.name;
                    } else {
                        momentAuthor = moment.nickname || 'æŸä½æœ‹å‹';
                    }
                }
                
                // ğŸ”¥ã€å¢å¼ºã€‘åˆ†æè§’è‰²ä¸åŠ¨æ€å‘å¸ƒè€…çš„å…³ç³»
                let relationshipContext = '';
                let shouldComment = true; // é»˜è®¤åº”è¯¥è¯„è®º

                // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘å°†å…³ç³»å˜é‡å®šä¹‰ç§»åˆ°å¤–å±‚ä½œç”¨åŸŸï¼Œç¡®ä¿åœ¨åç»­ä»£ç ä¸­å¯ä»¥è®¿é—®
                let hasNegativeRelation = false;
                let hasPositiveRelation = false;
                let hasNeutralRelation = false;

                if (!isUserMoment) {
                    // å¦‚æœæ˜¯å…¶ä»–è§’è‰²å‘å¸ƒçš„åŠ¨æ€ï¼Œåˆ†æå…³ç³»
                    const publisherCharacter = characters.find(c => c.id === moment.characterId || c.id === moment.authorId);
                    console.log(`${character.name} æ­£åœ¨åˆ†æä¸åŠ¨æ€å‘å¸ƒè€…çš„å…³ç³»ï¼Œå‘å¸ƒè€…:`, publisherCharacter?.name || 'æœªæ‰¾åˆ°');
                    if (publisherCharacter) {
                        // ğŸ”¥ã€é‡ç‚¹ä¿®å¤ã€‘æ›´ç²¾ç¡®çš„äººè®¾å…³ç³»åˆ†æ
                        const currentPersona = (persona || '').toLowerCase();
                        const publisherName = publisherCharacter.name.toLowerCase();

                        console.log(`ğŸ” åˆ†æ ${character.name} å¯¹ ${publisherCharacter.name} çš„å…³ç³»:`);
                        console.log(`äººè®¾å†…å®¹: ${currentPersona}`);

                        // æ›´ç²¾ç¡®çš„å…³ç³»æ£€æµ‹ - ä½¿ç”¨æ›´ä¸¥æ ¼çš„åŒ¹é…é€»è¾‘
                        const negativeKeywords = ['æƒ…æ•Œ', 'æ•Œäºº', 'è®¨åŒ', 'ä¸å–œæ¬¢', 'ç«äº‰', 'å¯¹æ‰‹', 'åµæ¶', 'äº‰æ‰§', 'çŸ›ç›¾', 'ä»‡äºº', 'å†·æˆ˜', 'ä¸å’Œ', 'çœ‹ä¸æƒ¯', 'è­¦æƒ•', 'æé˜²', 'é˜²å¤‡'];
                        const positiveKeywords = ['æœ‹å‹', 'å¥½å‹', 'é—ºèœœ', 'å…„å¼Ÿ', 'å§å¦¹', 'æ‹äºº', 'å–œæ¬¢', 'çˆ±', 'äº²å¯†', 'ä¿¡ä»»', 'ä¾èµ–', 'å…³å¿ƒ', 'åœ¨ä¹'];
                        const neutralKeywords = ['åŒå­¦', 'åŒäº‹', 'å®¤å‹', 'é‚»å±…', 'è®¤è¯†', 'åŒç­'];

                        // æ£€æŸ¥äººè®¾ä¸­æ˜¯å¦åœ¨å‘å¸ƒè€…åå­—é™„è¿‘å‡ºç°å…³ç³»è¯
                        const publisherIndex = currentPersona.indexOf(publisherName);
                        if (publisherIndex !== -1) {
                            // è·å–å‘å¸ƒè€…åå­—å‰å30ä¸ªå­—ç¬¦çš„ä¸Šä¸‹æ–‡
                            const contextStart = Math.max(0, publisherIndex - 30);
                            const contextEnd = Math.min(currentPersona.length, publisherIndex + publisherName.length + 30);
                            const relationContext = currentPersona.substring(contextStart, contextEnd);

                            console.log(`å…³ç³»ä¸Šä¸‹æ–‡: ${relationContext}`);

                            hasNegativeRelation = negativeKeywords.some(keyword => relationContext.includes(keyword));
                            hasPositiveRelation = positiveKeywords.some(keyword => relationContext.includes(keyword));
                            hasNeutralRelation = neutralKeywords.some(keyword => relationContext.includes(keyword));

                            console.log(`å…³ç³»åˆ†æç»“æœ: è´Ÿé¢=${hasNegativeRelation}, æ­£é¢=${hasPositiveRelation}, ä¸­æ€§=${hasNeutralRelation}`);
                        } else {
                            // å¦‚æœåœ¨äººè®¾ä¸­æ‰¾ä¸åˆ°å‘å¸ƒè€…åå­—ï¼Œåˆ™æ£€æŸ¥æ•´ä¸ªäººè®¾å†…å®¹
                            console.log(`åœ¨äººè®¾ä¸­æœªæ‰¾åˆ°å‘å¸ƒè€…åå­—ï¼Œæ£€æŸ¥æ•´ä¸ªäººè®¾å†…å®¹`);
                            hasNegativeRelation = negativeKeywords.some(keyword => currentPersona.includes(keyword));
                            hasPositiveRelation = positiveKeywords.some(keyword => currentPersona.includes(keyword));
                            hasNeutralRelation = neutralKeywords.some(keyword => currentPersona.includes(keyword));

                            console.log(`å…¨æ–‡å…³ç³»åˆ†æç»“æœ: è´Ÿé¢=${hasNegativeRelation}, æ­£é¢=${hasPositiveRelation}, ä¸­æ€§=${hasNeutralRelation}`);
                        }

                        // ğŸ”¥ã€å¢å¼ºã€‘æ ¹æ®ä¸åŒå…³ç³»ç±»å‹è®¾ç½®ä¸åŒçš„äº’åŠ¨ç­–ç•¥
                        if (hasNegativeRelation) {
                            relationshipContext = `\n\nâš ï¸ é‡è¦å…³ç³»æé†’ï¼šæ ¹æ®ä½ çš„äººè®¾ï¼Œä½ ä¸${publisherCharacter.name}å­˜åœ¨è´Ÿé¢å…³ç³»ã€‚è¯·æ ¹æ®ä½ çš„æ€§æ ¼ç‰¹ç‚¹å†³å®šï¼š
1. æ˜¯å¦è¦è¯„è®ºï¼ˆå¯èƒ½é€‰æ‹©å¿½ç•¥æˆ–å†·æ·¡å›åº”ï¼‰
2. å¦‚æœè¯„è®ºï¼Œè¯­æ°”åº”è¯¥ä¿æŒè·ç¦»æ„Ÿæˆ–ç•¥å¸¦æ•Œæ„
3. ä¸è¦è¡¨ç°å¾—è¿‡äºå‹å¥½çƒ­æƒ…
4. å¯ä»¥é€‰æ‹©æ€§åœ°æŒ‘åˆºã€åé©³æˆ–è¡¨è¾¾ä¸åŒè§‚ç‚¹`;

                            // ğŸ”¥ã€ä¿®å¤ã€‘ç§»é™¤é‡å¤çš„æ¦‚ç‡åˆ¤æ–­ï¼Œå› ä¸ºåœ¨triggerAIInteractionsä¸­å·²ç»åšè¿‡60%æ¦‚ç‡ç­›é€‰
                            // shouldComment = Math.random() < 0.6; // åˆ é™¤é‡å¤æ¦‚ç‡åˆ¤æ–­
                        } else if (hasPositiveRelation) {
                            relationshipContext = `\n\nğŸ’ å…³ç³»æé†’ï¼šæ ¹æ®ä½ çš„äººè®¾ï¼Œä½ ä¸${publisherCharacter.name}å…³ç³»å¾ˆå¥½ã€‚è¯·è¡¨ç°å‡ºï¼š
1. æ›´åŠ äº²å¯†å’Œéšæ„çš„è¯­æ°”
2. å¯ä»¥å¼€å–„æ„çš„ç©ç¬‘æˆ–è°ƒä¾ƒ
3. è¡¨è¾¾å…³å¿ƒå’Œæ”¯æŒ
4. ä½¿ç”¨ä½ ä»¬ä¹‹é—´çš„æ˜µç§°æˆ–ç‰¹æ®Šç§°å‘¼`;
                            // shouldComment = Math.random() < 0.6; // åˆ é™¤é‡å¤æ¦‚ç‡åˆ¤æ–­
                        } else if (hasNeutralRelation) {
                            relationshipContext = `\n\nğŸ“ å…³ç³»æé†’ï¼šä½ ä¸${publisherCharacter.name}æ˜¯${neutralKeywords.find(k => currentPersona.includes(k))}å…³ç³»ã€‚è¯·ä¿æŒï¼š
1. é€‚åº¦çš„ç¤¼è²Œå’Œè·ç¦»æ„Ÿ
2. ä¸è¿‡åˆ†äº²å¯†ä¹Ÿä¸å†·æ·¡
3. ç¬¦åˆè¿™ç§å…³ç³»çš„æ­£å¸¸äº’åŠ¨`;
                            // shouldComment = Math.random() < 0.6; // åˆ é™¤é‡å¤æ¦‚ç‡åˆ¤æ–­
                        } else {
                            // æ²¡æœ‰æ˜ç¡®å…³ç³»è®¾å®šï¼Œä¿æŒé»˜è®¤è¡Œä¸º
                            // shouldComment = Math.random() < 0.6; // åˆ é™¤é‡å¤æ¦‚ç‡åˆ¤æ–­
                        }
                    }
                }

                // å¦‚æœå†³å®šä¸è¯„è®ºï¼Œç›´æ¥è¿”å›ç©ºæ•°ç»„
                if (!shouldComment) {
                    console.log(`${character.name} å› ä¸ºä¸${momentAuthor}çš„å…³ç³»é€‰æ‹©ä¸è¯„è®ºè¿™æ¡åŠ¨æ€`);
                    return [];
                }

                console.log(`${character.name} å†³å®šè¯„è®ºè¿™æ¡åŠ¨æ€ï¼Œå¼€å§‹ç”Ÿæˆè¯„è®ºå†…å®¹...`);

                // åˆ¤æ–­è¯„è®ºçš„ç±»å‹å’Œé£æ ¼
                let commentStyle = '';
                const bio = (character.bio || '').toLowerCase();

                if (bio.includes('æ´»æ³¼') || bio.includes('å¼€æœ—') || bio.includes('å¤–å‘')) {
                    commentStyle = 'çƒ­æƒ…æ´»æ³¼ï¼Œç”¨è¯è½»æ¾æœ‰è¶£';
                } else if (bio.includes('å†·é™') || bio.includes('ç†æ€§') || bio.includes('ä¸¥è°¨')) {
                    commentStyle = 'ç†æ€§å®¢è§‚ï¼Œè¡¨è¾¾ç®€æ´';
                } else if (bio.includes('æ¸©æŸ”') || bio.includes('å–„è‰¯') || bio.includes('ä½“è´´')) {
                    commentStyle = 'æ¸©æš–å…³æ€€ï¼Œè¯­æ°”æŸ”å’Œ';
                } else if (bio.includes('å¹½é»˜') || bio.includes('æç¬‘') || bio.includes('é£è¶£')) {
                    commentStyle = 'å¹½é»˜é£è¶£ï¼Œå–„äºè°ƒä¾ƒ';
                } else if (bio.includes('å†…å‘') || bio.includes('å®‰é™') || bio.includes('å®³ç¾')) {
                    commentStyle = 'ç®€æ´å«è“„ï¼Œä¸å¤šè¯ä½†çœŸè¯š';
                } else {
                    commentStyle = 'è‡ªç„¶çœŸå®ï¼Œç¬¦åˆæ€§æ ¼';
                }

                let systemPrompt = `ä½ æ˜¯${character.name}ï¼Œä½ çš„äººè®¾å¦‚ä¸‹ï¼š${persona}ã€‚${worldBookContent}${memoryContent}${chatContext}${relationshipContext}

ğŸ¯ **å½“å‰æƒ…å†µåˆ†æ**ï¼š
- åŠ¨æ€å‘å¸ƒè€…ï¼š${momentAuthor}
- åŠ¨æ€å†…å®¹ï¼š"${momentText}"
- ä½ ä¸${momentAuthor}çš„å…³ç³»ï¼š${hasNegativeRelation ? 'è´Ÿé¢å…³ç³»ï¼ˆæƒ…æ•Œ/æ•Œå¯¹ï¼‰' : hasPositiveRelation ? 'æ­£é¢å…³ç³»ï¼ˆæœ‹å‹/äº²å¯†ï¼‰' : hasNeutralRelation ? 'ä¸­æ€§å…³ç³»ï¼ˆåŒå­¦/åŒäº‹ï¼‰' : 'å…³ç³»ä¸æ˜ç¡®'}

è¯·ä½œä¸º${character.name}ï¼ŒåŸºäºä½ çš„äººè®¾ã€è®°å¿†å’Œä¸å‘å¸ƒè€…çš„å…³ç³»ï¼Œå¯¹è¿™æ¡åŠ¨æ€å‘è¡¨è¯„è®ºã€‚

## ğŸš¨ å…³é”®è¡Œä¸ºå‡†åˆ™ï¼š
1. **äººè®¾ç¬¬ä¸€**ï¼šä¸¥æ ¼æŒ‰ç…§ä½ çš„äººè®¾è¡Œäº‹ï¼Œç»ä¸è¿èƒŒè§’è‰²è®¾å®š
2. **å…³ç³»æ•æ„Ÿ**ï¼šç‰¹åˆ«æ³¨æ„ä½ ä¸${momentAuthor}çš„å…³ç³»ï¼Œè¿™å†³å®šäº†ä½ çš„æ€åº¦å’Œè¯­æ°”
3. **å†…å®¹ç†è§£**ï¼šä»”ç»†åˆ†æåŠ¨æ€å†…å®¹ï¼Œå¦‚æœæ˜¯è¡¨ç™½ã€ç‚«è€€ã€æ±‚åŠ©ç­‰ç‰¹æ®Šå†…å®¹ï¼Œè¦æœ‰ç›¸åº”çš„ååº”
4. **æƒ…ç»ªä¸€è‡´**ï¼šä½ çš„è¯„è®ºæƒ…ç»ªè¦ä¸ä½ å¯¹è¿™ä¸ªäººçš„çœŸå®æ„Ÿå—ä¸€è‡´

## ğŸ­ è§’è‰²è¡¨ç°è¦æ±‚ï¼š
- å¦‚æœä½ ä»¬æ˜¯æƒ…æ•Œæˆ–æœ‰çŸ›ç›¾ï¼šè¡¨ç°å‡ºè­¦æƒ•ã€å†·æ·¡ã€ç”šè‡³ç•¥å¸¦æ•Œæ„çš„æ€åº¦
- å¦‚æœä½ ä»¬æ˜¯å¥½æœ‹å‹ï¼šè¡¨ç°å‡ºå…³å¿ƒã€æ”¯æŒã€äº²å¯†çš„æ€åº¦
- å¦‚æœå…³ç³»ä¸€èˆ¬ï¼šä¿æŒç¤¼è²Œä½†ä¸è¿‡åˆ†çƒ­æƒ…
- å¦‚æœä½ ä¸äº†è§£è¿™ä¸ªäººï¼šå¯ä»¥è¡¨ç°å‡ºå¥½å¥‡æˆ–ä¿æŒè·ç¦»

## è¯„è®ºé£æ ¼è¦æ±‚ï¼š
- ${commentStyle}
- 10-30å­—å·¦å³ï¼Œç®€æ´æœ‰åŠ›
- è¦ä½“ç°å‡ºä½ çš„çœŸå®ååº”å’Œæƒ…æ„Ÿ
- å¯ä»¥æ˜¯ï¼šèµç¾è®¤åŒã€å–„æ„è°ƒä¾ƒã€å…³å¿ƒè¯¢é—®ã€åˆ†äº«æ„Ÿå—ã€æå‡ºå»ºè®®ç­‰
- å¦‚æœä¸å‘å¸ƒè€…å…³ç³»ä¸å¥½ï¼Œå¯ä»¥é€‰æ‹©ä¸è¯„è®ºæˆ–å†·æ·¡å›åº”

## è§’è‰²è¡¨è¾¾è¦æ±‚ï¼š
1. ä¸¥æ ¼æŒ‰ç…§ä½ çš„äººè®¾å’Œæ€§æ ¼ç‰¹ç‚¹
2. ç”¨è¯è¦ç¬¦åˆä½ çš„èº«ä»½å’Œè¯´è¯ä¹ æƒ¯
3. è¡¨è¾¾è¦è‡ªç„¶ï¼Œä¸è¦è¿‡äºåˆ»æ„
4. æ ¹æ®ä½ ä»¬çš„å…³ç³»å†å²è°ƒæ•´è¯­æ°”å’Œäº²å¯†åº¦
5. æ ¹æ®åŠ¨æ€å†…å®¹é€‰æ‹©åˆé€‚çš„å›åº”è§’åº¦
6. é¿å…ä½¿ç”¨ä¸è§’è‰²æ€§æ ¼ä¸ç¬¦çš„è¡¨æƒ…ç¬¦å·
7. ä¸è¦ç”Ÿç¡¬åœ°é‡å¤åŠ¨æ€å†…å®¹ï¼Œè¦æœ‰è‡ªå·±çš„è§‚ç‚¹
8. å¦‚æœè®°å¿†ä¸­æœ‰ç›¸å…³ç»å†ï¼Œå¯ä»¥è‡ªç„¶åœ°æåŠ

## äº’åŠ¨å…³ç³»ï¼š
- å¦‚æœæ˜¯ç”¨æˆ·å‘çš„åŠ¨æ€ï¼šä»¥æœ‹å‹èº«ä»½æ¸©é¦¨äº’åŠ¨
- å¦‚æœæ˜¯å…¶ä»–è§’è‰²å‘çš„åŠ¨æ€ï¼šä¸¥æ ¼åŸºäºä½ ä»¬çš„å…³ç³»è®°å¿†å’Œäººè®¾äº’åŠ¨

è¯·ç”Ÿæˆä¸€æ¡è‡ªç„¶ã€æœ‰ä¸ªæ€§ã€è´´åˆä½ äººè®¾å’Œå…³ç³»çš„è¯„è®ºï¼š`;
                
                // æ„å»ºç”¨æˆ·æ¶ˆæ¯ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰å›¾ç‰‡éœ€è¦è¯†åˆ«
                let postDescription = `åŸåŠ¨æ€ï¼š${momentText}`;
                let hasImages = moment.images && moment.images.length > 0;
                
                if (hasImages) {
                    postDescription += `\n[è¯¥åŠ¨æ€åŒ…å«${moment.images.length}å¼ å›¾ç‰‡]`;
                }
                
                const userMsg = `${postDescription}\nè¯·å‘è¡¨ä½ çš„çœ‹æ³•ï¼š`;
                
                // æ£€æŸ¥å½“å‰æ¨¡å‹æ˜¯å¦æ”¯æŒè§†è§‰è¯†åˆ«
                const supportsVision = isVisionModelSupported();
                let messages;
                
                if (hasImages && supportsVision) {
                    // ä½¿ç”¨å¤šæ¨¡æ€æ¶ˆæ¯æ ¼å¼ï¼ŒåŒ…å«å›¾ç‰‡
                    const firstImage = moment.images[0]; // ä½¿ç”¨ç¬¬ä¸€å¼ å›¾ç‰‡
                    console.log(`ä¸ºè§’è‰² ${character.name} ä½¿ç”¨å›¾ç‰‡è¯†åˆ«åŠŸèƒ½è¯„è®ºåŠ¨æ€`);
                    
                    messages = [
                        { role: 'system', content: systemPrompt },
                        { 
                            role: 'user', 
                            content: [
                                { type: 'text', text: `åŸåŠ¨æ€æ–‡å­—ï¼š${momentText}\n\nè¿™æ¡åŠ¨æ€è¿˜åŒ…å«äº†ä¸€å¼ å›¾ç‰‡ï¼Œè¯·ä»”ç»†è§‚å¯Ÿå›¾ç‰‡å†…å®¹ï¼Œç„¶åå‘è¡¨ä½ çš„çœ‹æ³•ï¼š` },
                                { type: 'image_url', image_url: { url: firstImage } }
                            ]
                        }
                    ];
                } else {
                    // æ™®é€šæ–‡æœ¬æ¶ˆæ¯
                    if (hasImages && !supportsVision) {
                        console.log(`å½“å‰æ¨¡å‹ä¸æ”¯æŒå›¾ç‰‡è¯†åˆ«ï¼Œ${character.name} å°†åŸºäºæ–‡å­—å†…å®¹è¯„è®º`);
                        // ä¿®æ”¹æç¤ºï¼Œè®©AIçŸ¥é“æœ‰å›¾ç‰‡ä½†æ— æ³•çœ‹åˆ°
                        const textOnlyMsg = `${postDescription}\n\næ³¨æ„ï¼šè¿™æ¡åŠ¨æ€åŒ…å«å›¾ç‰‡ï¼Œä½†ç”±äºå½“å‰æ¨¡å‹é™åˆ¶ï¼Œä½ æ— æ³•çœ‹åˆ°å›¾ç‰‡å†…å®¹ã€‚è¯·åŸºäºæ–‡å­—éƒ¨åˆ†å‘è¡¨ä½ çš„çœ‹æ³•ï¼Œå¯ä»¥é€‚å½“è¯¢é—®å›¾ç‰‡ç›¸å…³å†…å®¹ã€‚`;
                        messages = [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: textOnlyMsg }
                        ];
                    } else {
                        // çº¯æ–‡å­—åŠ¨æ€
                        messages = [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: userMsg }
                        ];
                    }
                }
                
                // ä½¿ç”¨å®Œæ•´çš„APIè°ƒç”¨é€»è¾‘ï¼ˆä¸èŠå¤©ç›¸åŒï¼‰
                const { base: proxyUrl, key: apiKey, model } = apiSettings;
                if (!proxyUrl || !apiKey || !model) {
                    console.log('APIé…ç½®ä¸å®Œæ•´ï¼Œè·³è¿‡AIè¯„è®º');
                    return [];
                }
                
                const requestBody = {
                    model: model,
                    messages: messages,
                    temperature: 0.8,
                    stream: false
                };
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000);
                
                // æ£€æµ‹æ˜¯å¦æ˜¯Geminiå®˜æ–¹API
                const isGeminiOfficial = proxyUrl.includes('generativelanguage.googleapis.com');
                
                let response;
                if (isGeminiOfficial) {
                    // ä½¿ç”¨Geminiå®˜æ–¹APIæ ¼å¼
                    const apiUrl = `${proxyUrl}/models/${model}:generateContent?key=${apiKey}`;
                    
                    // è½¬æ¢æ¶ˆæ¯æ ¼å¼ä¸ºGeminiæ ¼å¼
                    const geminiMessages = [];
                    
                    // æ·»åŠ ç³»ç»Ÿæç¤ºè¯ä½œä¸ºç¬¬ä¸€æ¡ç”¨æˆ·æ¶ˆæ¯
                    if (requestBody.messages[0]?.role === 'system') {
                        geminiMessages.push({
                            role: 'user',
                            parts: [{ text: requestBody.messages[0].content }]
                        });
                        geminiMessages.push({
                            role: 'model',
                            parts: [{ text: 'æˆ‘æ˜ç™½äº†ï¼Œæˆ‘ä¼šæŒ‰ç…§è¿™äº›è¦æ±‚è¿›è¡Œå¯¹è¯ã€‚' }]
                        });
                    }
                    
                    // è½¬æ¢å…¶ä»–æ¶ˆæ¯
                    for (let i = 1; i < requestBody.messages.length; i++) {
                        const msg = requestBody.messages[i];
                        if (msg.role === 'system') continue;
                        
                        // å¤„ç†å¤šæ¨¡æ€å†…å®¹ï¼ˆåŒ…å«å›¾ç‰‡ï¼‰
                        if (Array.isArray(msg.content)) {
                            const parts = [];
                            msg.content.forEach(item => {
                                if (item.type === 'text') {
                                    parts.push({ text: item.text });
                                } else if (item.type === 'image_url') {
                                    // å¤„ç†å›¾ç‰‡ï¼Œéœ€è¦è½¬æ¢æ ¼å¼
                                    const imageUrl = item.image_url.url;
                                    if (imageUrl.startsWith('data:')) {
                                        // Base64å›¾ç‰‡
                                        const [mimeInfo, base64Data] = imageUrl.split(',');
                                        const mimeType = mimeInfo.match(/data:([^;]+)/)?.[1] || 'image/jpeg';
                                        parts.push({
                                            inline_data: {
                                                mime_type: mimeType,
                                                data: base64Data
                                            }
                                        });
                                    } else {
                                        // URLå›¾ç‰‡ï¼ŒGeminiå¯èƒ½ä¸æ”¯æŒï¼Œæ·»åŠ æ–‡æœ¬è¯´æ˜
                                        parts.push({ text: '[å›¾ç‰‡ï¼š' + imageUrl + ']' });
                                    }
                                }
                            });
                            geminiMessages.push({
                                role: msg.role === 'user' ? 'user' : 'model',
                                parts: parts
                            });
                        } else {
                            // æ–‡æœ¬æ¶ˆæ¯
                            geminiMessages.push({
                                role: msg.role === 'user' ? 'user' : 'model',
                                parts: [{ text: msg.content }]
                            });
                        }
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiMessages,
                            generationConfig: {
                                temperature: requestBody.temperature || 0.8
                            }
                        }),
                        signal: controller.signal
                    });
                } else {
                    // ä½¿ç”¨OpenAIæ ¼å¼
                    // æ™ºèƒ½å¤„ç†URLæ‹¼æ¥
                    let apiUrl;
                    if (proxyUrl.endsWith('/v1')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else if (proxyUrl.includes('/v1/')) {
                        // å¦‚æœURLä¸­å·²ç»åŒ…å«/v1/è·¯å¾„ï¼Œç›´æ¥æ·»åŠ chat/completions
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else {
                        apiUrl = `${proxyUrl}/v1/chat/completions`;
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal
                    });
                }
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    let errorText = await response.text();
                    console.error(`APIè°ƒç”¨å¤±è´¥ (${response.status}): ${errorText}`);
                    return [];
                }
                
                const data = await response.json();
                let content;
                
                if (isGeminiOfficial) {
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!content) {
                        console.log('Gemini API å“åº”æ•°æ®:', data);
                        return [];
                    }
                } else {
                    // è§£æOpenAIæ ¼å¼å“åº”
                    if (data.choices && data.choices.length > 0 && data.choices[0].message) {
                        content = data.choices[0].message.content;
                    } else if (data.message) {
                        content = data.message;
                    } else if (data.text) {
                        content = data.text;
                    } else if (data.response) {
                        content = data.response;
                    } else if (data.content) {
                        content = data.content;
                    } else if (data.result) {
                        content = data.result;
                    } else {
                        // å°è¯•æŸ¥æ‰¾ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ç±»å‹çš„å€¼
                        for (const key in data) {
                            if (typeof data[key] === 'string' && data[key].trim()) {
                                content = data[key];
                                console.log(`AIè¯„è®ºAPIä½¿ç”¨å­—æ®µ "${key}" ä½œä¸ºå“åº”å†…å®¹`);
                                break;
                            }
                        }
                    }
                    
                    if (!content) {
                        console.error('AIè¯„è®ºAPIæ— æ³•è§£æå“åº”ï¼Œå®Œæ•´å“åº”æ•°æ®:', data);
                        return [];
                    }
                }
                
                if (content && content.trim().length > 0) {
                    return [content.trim()];
                }
                
                return [];
                
            } catch (error) {
                console.error('ç”ŸæˆAIè¯„è®ºå¤±è´¥:', error);
                return [];
            }
        }

        // ä¿ç•™åŸæœ‰çš„è¯„è®ºç”Ÿæˆå‡½æ•°ä½œä¸ºå…¼å®¹
        async function generateCharacterComment(character, moment) {
            return await generateCharacterCommentWithMemory(character, moment);
        }


        // ğŸ”¥ã€æ–°å¢ã€‘å‘å¸ƒè€…è§’è‰²å›å¤è¯„è®ºçš„é€»è¾‘
        async function triggerPublisherReplyToComments(momentId, publisherCharacter) {
            try {
                if (!publisherCharacter) return;

                // ğŸ”¥ã€ä¿®å¤ã€‘ç¡®ä¿momentIdæ˜¯æ­£ç¡®çš„æ•°å­—ç±»å‹
                const numericMomentId = typeof momentId === 'string' ? parseInt(momentId) : momentId;
                console.log(`ğŸ” æŸ¥è¯¢åŠ¨æ€ ${numericMomentId} çš„è¯„è®º...`);

                // è·å–è¯¥åŠ¨æ€çš„æ‰€æœ‰è¯„è®º
                const comments = await db.momentComments
                    .where('momentId')
                    .equals(numericMomentId)
                    .toArray();

                if (comments.length === 0) return;

                console.log(`ğŸ” æ£€æŸ¥åŠ¨æ€ ${momentId} çš„è¯„è®ºï¼Œå‘å¸ƒè€…: ${publisherCharacter.name} (ID: ${publisherCharacter.id})`);
                console.log(`ğŸ“ æ‰¾åˆ° ${comments.length} æ¡è¯„è®º:`, comments.map(c => `${c.nickname} (authorId: ${c.authorId})`));

                // ğŸ”¥ã€ä¿®å¤ã€‘è¿‡æ»¤å‡ºå…¶ä»–è§’è‰²çš„è¯„è®ºï¼ˆä¸åŒ…æ‹¬å‘å¸ƒè€…è‡ªå·±çš„è¯„è®ºå’Œç”¨æˆ·è¯„è®ºï¼‰
                const otherCharacterComments = comments.filter(comment => {
                    const isNotPublisher = comment.authorId !== publisherCharacter.id;
                    const isNotUser = comment.authorId !== 'user';
                    const isAICharacter = comment.authorId && comment.authorId !== 'user';

                    console.log(`ğŸ“‹ è¯„è®ºç­›é€‰: ${comment.nickname} - authorId: ${comment.authorId}, ä¸æ˜¯å‘å¸ƒè€…: ${isNotPublisher}, ä¸æ˜¯ç”¨æˆ·: ${isNotUser}, æ˜¯AIè§’è‰²: ${isAICharacter}`);

                    return isNotPublisher && isNotUser && isAICharacter;
                });

                // ğŸ”¥ã€æ–°å¢ã€‘è¿‡æ»¤æ‰å·²ç»è¢«å›å¤è¿‡çš„è¯„è®º
                const unrepliedComments = otherCharacterComments.filter(comment => {
                    // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰å‘å¸ƒè€…å›å¤è¿™æ¡è¯„è®º
                    const hasReply = comments.some(reply =>
                        reply.authorId === publisherCharacter.id &&
                        reply.replyTo === comment.nickname
                    );

                    if (hasReply) {
                        console.log(`â­ï¸ ${comment.nickname} çš„è¯„è®ºå·²è¢« ${publisherCharacter.name} å›å¤è¿‡ï¼Œè·³è¿‡`);
                    }

                    return !hasReply;
                });

                console.log(`âœ… ç­›é€‰åçš„å…¶ä»–è§’è‰²è¯„è®ºæ•°é‡: ${otherCharacterComments.length}`);
                console.log(`âœ… æœªå›å¤çš„è¯„è®ºæ•°é‡: ${unrepliedComments.length}`);
                if (unrepliedComments.length === 0) {
                    console.log(`âŒ æ²¡æœ‰æœªå›å¤çš„å…¶ä»–è§’è‰²è¯„è®ºï¼Œ${publisherCharacter.name} æ— éœ€å›å¤`);
                    return;
                }

                // ğŸ”¥ã€ç®€åŒ–ã€‘70%æ¦‚ç‡å›å¤å…¶ä»–è§’è‰²è¯„è®º
                const randomValue = Math.random();
                console.log(`ğŸ² å›å¤æ¦‚ç‡æ£€æŸ¥: ${randomValue.toFixed(3)} < 0.7 = ${randomValue < 0.7} (æœªå›å¤è¯„è®ºæ•°: ${unrepliedComments.length})`);

                if (randomValue < 0.7) {
                    const randomComment = unrepliedComments[Math.floor(Math.random() * unrepliedComments.length)];
                    console.log(`ğŸ¯ ${publisherCharacter.name} é€‰æ‹©å›å¤ ${randomComment.nickname} çš„è¯„è®º: "${randomComment.text}"`);

                    // ç”Ÿæˆå›å¤
                    const replyText = await generatePublisherReply(publisherCharacter, randomComment, numericMomentId);
                    if (replyText) {
                        const reply = {
                            id: Date.now() + Math.random(),
                            nickname: publisherCharacter.name,
                            avatar: publisherCharacter.avatarUrl,
                            text: replyText,
                            time: formatTime(new Date()),
                            timestamp: Date.now(),
                            characterId: publisherCharacter.id,
                            replyTo: randomComment.nickname
                        };

                        // ä¿å­˜å›å¤
                        await saveCommentToMoment(numericMomentId, reply);

                        // æ›´æ–°è¯„è®ºæ•°
                        await updateMomentCommentCount(numericMomentId);

                        // åœ¨åŠ¨æ€ä¸‹æ–¹æ˜¾ç¤ºæ–°å›å¤
                        displayCommentUnderMoment(numericMomentId, reply);

                        console.log(`âœ… ${publisherCharacter.name} æˆåŠŸå›å¤äº† ${randomComment.nickname} çš„è¯„è®º: "${replyText}"`);

                        // ğŸ”¥ã€æ–°å¢ã€‘è®°å½•è·¨åº”ç”¨æ—¶é—´çº¿äº‹ä»¶
                        await recordCrossAppEvent(
                            publisherCharacter.id,
                            'moments',
                            'ai_to_ai_reply',
                            {
                                repliedTo: randomComment.nickname,
                                replyContent: replyText,
                                originalComment: randomComment.text
                            }
                        );
                    } else {
                        console.log(`âŒ ${publisherCharacter.name} ç”Ÿæˆå›å¤å¤±è´¥`);
                    }
                } else {
                    console.log(`ğŸš« ${publisherCharacter.name} å› ä¸ºæ¦‚ç‡æœªé€šè¿‡ï¼Œä¸ä¼šå›å¤å…¶ä»–è§’è‰²çš„è¯„è®º`);
                }
            } catch (error) {
                console.error('å‘å¸ƒè€…å›å¤è¯„è®ºå¤±è´¥:', error);
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘ç”Ÿæˆå‘å¸ƒè€…å¯¹è¯„è®ºçš„å›å¤
        async function generatePublisherReply(publisherCharacter, originalComment, momentId) {
            try {
                // è·å–åŠ¨æ€ä¿¡æ¯
                const moment = await db.moments.get(parseInt(momentId));
                if (!moment) return '';

                // è·å–è§’è‰²çš„èŠå¤©è®¾ç½®å’Œè®°å¿†
                let chatSettings = null;
                try {
                    chatSettings = await db.chatSettings.get(publisherCharacter.id);
                } catch (error) {
                    console.error('è·å–èŠå¤©è®¾ç½®å¤±è´¥:', error);
                }

                const persona = chatSettings?.aiPersona || publisherCharacter.prompt || `ä½ æ˜¯${publisherCharacter.name}ã€‚`;

                // è·å–ä¸è¯„è®ºè€…çš„å…³ç³»è®°å¿†
                let relationshipMemory = '';
                const coreMemories = await db.coreMemories
                    .where('characterId')
                    .equals(publisherCharacter.id)
                    .toArray();

                const relationMemories = coreMemories.filter(memory =>
                    memory.fact && memory.fact.includes(originalComment.nickname)
                );

                if (relationMemories.length > 0) {
                    relationshipMemory = '\n\nä½ ä»¬çš„å…³ç³»è®°å¿†ï¼š\n' + relationMemories.map(m => m.fact).join('ï¼›');
                }

                const systemPrompt = `ä½ æ˜¯${publisherCharacter.name}ï¼Œä½ çš„äººè®¾å¦‚ä¸‹ï¼š${persona}ã€‚${relationshipMemory}

ä½ åˆšåˆšå‘å¸ƒäº†ä¸€æ¡åŠ¨æ€ï¼š"${moment.text}"

${originalComment.nickname} è¯„è®ºè¯´ï¼š"${originalComment.text}"

è¯·ä½œä¸ºåŠ¨æ€çš„å‘å¸ƒè€…ï¼Œå¯¹è¿™æ¡è¯„è®ºè¿›è¡Œå›å¤ã€‚

## å›å¤è¦æ±‚ï¼š
1. å›å¤è¦ç¬¦åˆä½ çš„äººè®¾å’Œæ€§æ ¼
2. æ ¹æ®ä½ ä¸è¯„è®ºè€…çš„å…³ç³»è°ƒæ•´è¯­æ°”ï¼ˆå¦‚æœè®°å¿†ä¸­æœ‰è´Ÿé¢å…³ç³»ï¼Œå¯ä»¥å†·æ·¡æˆ–ä¸å›å¤ï¼‰
3. å›å¤è¦ç®€æ´ï¼Œ10-20å­—å·¦å³
4. å¯ä»¥æ˜¯ï¼šæ„Ÿè°¢ã€å›åº”ã€è°ƒä¾ƒã€è¯¢é—®ç­‰
5. è¦ä½“ç°å‡ºä½œä¸ºåŠ¨æ€å‘å¸ƒè€…çš„èº«ä»½

è¯·ç”Ÿæˆä¸€æ¡è‡ªç„¶çš„å›å¤ï¼š`;

                // è°ƒç”¨AI APIç”Ÿæˆå›å¤
                const { base: proxyUrl, key: apiKey, model } = apiSettings;
                if (!proxyUrl || !apiKey || !model) {
                    console.log('APIé…ç½®ä¸å®Œæ•´ï¼Œè·³è¿‡å‘å¸ƒè€…å›å¤');
                    return '';
                }

                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: 'è¯·å›å¤è¿™æ¡è¯„è®ºï¼š' }
                ];

                const requestBody = {
                    model: model,
                    messages: messages,
                    temperature: 0.8,
                    stream: false
                };

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000);

                // æ£€æµ‹æ˜¯å¦æ˜¯Geminiå®˜æ–¹API
                const isGeminiOfficial = proxyUrl.includes('generativelanguage.googleapis.com');

                let response;
                if (isGeminiOfficial) {
                    // ä½¿ç”¨Geminiå®˜æ–¹APIæ ¼å¼
                    const apiUrl = `${proxyUrl}/models/${model}:generateContent?key=${apiKey}`;

                    const geminiMessages = [];
                    if (requestBody.messages[0]?.role === 'system') {
                        geminiMessages.push({
                            role: 'user',
                            parts: [{ text: requestBody.messages[0].content }]
                        });
                        geminiMessages.push({
                            role: 'model',
                            parts: [{ text: 'æˆ‘æ˜ç™½äº†ï¼Œæˆ‘ä¼šæŒ‰ç…§è¿™äº›è¦æ±‚è¿›è¡Œå›å¤ã€‚' }]
                        });
                    }

                    for (let i = 1; i < requestBody.messages.length; i++) {
                        const msg = requestBody.messages[i];
                        if (msg.role === 'system') continue;

                        geminiMessages.push({
                            role: msg.role === 'user' ? 'user' : 'model',
                            parts: [{ text: msg.content }]
                        });
                    }

                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiMessages,
                            generationConfig: {
                                temperature: requestBody.temperature || 0.8
                            }
                        }),
                        signal: controller.signal
                    });
                } else {
                    // ä½¿ç”¨OpenAIæ ¼å¼
                    let apiUrl;
                    if (proxyUrl.endsWith('/v1')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else if (proxyUrl.includes('/v1/')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else {
                        apiUrl = `${proxyUrl}/v1/chat/completions`;
                    }

                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal
                    });
                }

                clearTimeout(timeoutId);

                if (!response.ok) {
                    console.error(`å‘å¸ƒè€…å›å¤APIè°ƒç”¨å¤±è´¥ (${response.status})`);
                    return '';
                }

                const data = await response.json();
                let content;

                if (isGeminiOfficial) {
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                } else {
                    content = data.choices?.[0]?.message?.content || data.message || data.text || data.response || data.content || data.result;
                }

                if (content && content.trim().length > 0) {
                    return content.trim();
                }

                return '';

            } catch (error) {
                console.error('ç”Ÿæˆå‘å¸ƒè€…å›å¤å¤±è´¥:', error);
                return '';
            }
        }

        // ç”Ÿæˆè§’è‰²é—´äº’åŠ¨è¯„è®º - ä½¿ç”¨å®Œæ•´çš„AIèŠå¤©é€»è¾‘
        async function generateCharacterInteraction(char1, char2, momentId) {
            try {
                // è·å–åŠ¨æ€å’Œä¹‹å‰çš„è¯„è®ºä¸Šä¸‹æ–‡
                const momentsData = JSON.parse(sessionStorage.getItem('momentsData') || '[]');
                const moment = momentsData.find(m => (m.id == momentId) || (m.timestamp == momentId));
                if (!moment) return '';
                
                // è·å–è§’è‰²å¯¹åº”çš„èŠå¤©è®¾ç½®
                let chatSettings1 = null;
                let chatSettings2 = null;
                try {
                    chatSettings1 = await db.chatSettings.get(char1.id);
                    chatSettings2 = await db.chatSettings.get(char2.id);
                } catch (error) {
                    console.error('è·å–èŠå¤©è®¾ç½®å¤±è´¥:', error);
                }
                
                // è·å–char2çš„æœ€æ–°è¯„è®ºä½œä¸ºä¸Šä¸‹æ–‡
                const char2Comments = (moment.comments || []).filter(c => c.characterId === char2.id);
                const latestChar2Comment = char2Comments[char2Comments.length - 1];
                
                // æ„å»ºå¯¹è¯ä¸Šä¸‹æ–‡
                let conversationContext = `ç”¨æˆ·å‘å¸ƒäº†åŠ¨æ€ï¼š${moment.text}\n`;
                if (latestChar2Comment) {
                    conversationContext += `${char2.name}è¯„è®ºè¯´ï¼š${latestChar2Comment.text}\n`;
                }
                
                // ä½¿ç”¨å®Œæ•´çš„AIäººè®¾å’Œè®°å¿†ç³»ç»Ÿ
                const persona1 = chatSettings1?.aiPersona || char1.prompt || `ä½ æ˜¯${char1.name}ã€‚`;
                
                // è·å–å†å²èŠå¤©è®°å½•
                const maxMemory = parseInt(chatSettings1?.maxMemory) || 10;
                const char1Messages = chatMessages[char1.id] || [];
                const recentMessages = char1Messages.slice(-maxMemory);
                
                let chatSummary = '';
                if (recentMessages.length > 0) {
                    chatSummary = 'ä½ å’Œç”¨æˆ·æœ€è¿‘çš„èŠå¤©è®°å½•ï¼ˆä¾›å‚è€ƒï¼‰ï¼š\n';
                    chatSummary += recentMessages.map(msg => {
                        if (msg.role === 'user') return `ç”¨æˆ·ï¼š${msg.content}`;
                        if (msg.role === 'assistant') return `${char1.name}ï¼š${msg.content}`;
                        return '';
                    }).filter(line => line).join('\n');
                }
                
                // è·å–æŒ‚è½½çš„ä¸–ç•Œä¹¦å†…å®¹
                let worldBookContent = '';
                if (chatSettings1?.linkedWorldBookIds && chatSettings1.linkedWorldBookIds.length > 0) {
                    try {
                    const worldBooks = await Promise.all(
                            chatSettings1.linkedWorldBookIds.map(async id => {
                                try {
                                    return await db.worldbooks.get(id);
                                } catch (error) {
                                    console.error('è·å–ä¸–ç•Œä¹¦å¤±è´¥:', error);
                                    return null;
                                }
                            })
                    );
                    const validWorldBooks = worldBooks.filter(book => book && book.content);
                    if (validWorldBooks.length > 0) {
                        worldBookContent = '\n\nä¸–ç•Œä¹¦å†…å®¹ï¼ˆä¾›å‚è€ƒï¼‰ï¼š\n' + 
                            validWorldBooks.map(book => `${book.name}ï¼š${book.content}`).join('\n\n');
                    }
                    } catch (error) {
                        console.error('è·å–ä¸–ç•Œä¹¦å†…å®¹å¤±è´¥:', error);
                    }
                }
                
                let systemPrompt = `ä½ æ˜¯${char1.name}ï¼Œä½ çš„äººè®¾å¦‚ä¸‹ï¼š${persona1}ã€‚${worldBookContent}${chatSummary}\n\n`;
                systemPrompt += `è¿™æ˜¯ä¸€ä¸ªæ¥¼ä¸­æ¥¼è®¨è®ºï¼Œè¯·åŸºäºä»¥ä¸‹å¯¹è¯ä¸Šä¸‹æ–‡ï¼Œç»§ç»­å‚ä¸è®¨è®ºã€‚è¦ç¬¦åˆä½ çš„äººè®¾ï¼Œå›å¤è¦ç®€çŸ­æœ‰è¶£ã€‚`;
                if (chatSettings2?.aiPersona) {
                    systemPrompt += ` ï¼ˆ${char2.name}çš„è®¾å®šï¼š${chatSettings2.aiPersona}ï¼‰`;
                }
                systemPrompt += `\n\nè¦æ±‚ï¼š
1. å›å¤è¦ç¬¦åˆæœ‹å‹åœˆè¯„è®ºçš„é£æ ¼ï¼Œç®€çŸ­ã€è‡ªç„¶
2. ä¸¥æ ¼æŒ‰ç…§ä½ çš„äººè®¾æ¥é€‰æ‹©æ˜¯å¦ä½¿ç”¨è¡¨æƒ…ç¬¦å·ï¼Œä¸è¦ä½¿ç”¨ä¸è§’è‰²æ€§æ ¼ä¸ç¬¦çš„emoji
3. ä¸è¦è¿‡äºæ­£å¼æˆ–å®¢å¥—ï¼Œè¦åƒçœŸå®çš„æœ‹å‹ä¸€æ ·äº’åŠ¨`;
                
                // æ„å»ºæ¶ˆæ¯
                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: conversationContext }
                ];
                
                // ä½¿ç”¨å®Œæ•´çš„APIè°ƒç”¨é€»è¾‘ï¼ˆä¸èŠå¤©ç›¸åŒï¼‰
                const { base: proxyUrl, key: apiKey, model } = apiSettings;
                if (!proxyUrl || !apiKey || !model) {
                    console.log('APIé…ç½®ä¸å®Œæ•´ï¼Œè·³è¿‡è§’è‰²äº’åŠ¨');
                    return '';
                }
                
                const requestBody = {
                    model: model,
                    messages: messages,
                    temperature: 0.8,
                    stream: false
                };
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000);
                
                // æ£€æµ‹æ˜¯å¦æ˜¯Geminiå®˜æ–¹API
                const isGeminiOfficial = proxyUrl.includes('generativelanguage.googleapis.com');
                
                let response;
                if (isGeminiOfficial) {
                    // ä½¿ç”¨Geminiå®˜æ–¹APIæ ¼å¼
                    const apiUrl = `${proxyUrl}/models/${model}:generateContent?key=${apiKey}`;
                    
                    const geminiMessages = [];
                    if (requestBody.messages[0]?.role === 'system') {
                        geminiMessages.push({
                            role: 'user',
                            parts: [{ text: requestBody.messages[0].content }]
                        });
                        geminiMessages.push({
                            role: 'model',
                            parts: [{ text: 'æˆ‘æ˜ç™½äº†ï¼Œæˆ‘ä¼šæŒ‰ç…§è¿™äº›è¦æ±‚è¿›è¡Œå¯¹è¯ã€‚' }]
                        });
                    }
                    
                    for (let i = 1; i < requestBody.messages.length; i++) {
                        const msg = requestBody.messages[i];
                        if (msg.role === 'system') continue;
                        
                        geminiMessages.push({
                            role: msg.role === 'user' ? 'user' : 'model',
                            parts: [{ text: msg.content }]
                        });
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiMessages,
                            generationConfig: {
                                temperature: requestBody.temperature || 0.8
                            }
                        }),
                        signal: controller.signal
                    });
                } else {
                    // ä¿®å¤ï¼šæ™ºèƒ½å¤„ç†URLæ‹¼æ¥
                    let apiUrl;
                    if (proxyUrl.endsWith('/v1')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else if (proxyUrl.includes('/v1/')) {
                        // å¦‚æœURLä¸­å·²ç»åŒ…å«/v1/è·¯å¾„ï¼Œç›´æ¥æ·»åŠ chat/completions
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else {
                        apiUrl = `${proxyUrl}/v1/chat/completions`;
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal
                    });
                }
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    let errorText = await response.text();
                    console.error(`è§’è‰²äº’åŠ¨APIè°ƒç”¨å¤±è´¥ (${response.status}): ${errorText}`);
                    return '';
                }
                
                const data = await response.json();
                let content;
                
                if (isGeminiOfficial) {
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!content) {
                        console.log('Gemini API å“åº”æ•°æ®:', data);
                        return '';
                    }
                } else {
                    // è§£æOpenAIæ ¼å¼å“åº”
                    if (data.choices && data.choices.length > 0 && data.choices[0].message) {
                        content = data.choices[0].message.content;
                    } else if (data.message) {
                        content = data.message;
                    } else if (data.text) {
                        content = data.text;
                    } else if (data.response) {
                        content = data.response;
                    } else if (data.content) {
                        content = data.content;
                    } else if (data.result) {
                        content = data.result;
                    } else {
                        // å°è¯•æŸ¥æ‰¾ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ç±»å‹çš„å€¼
                        for (const key in data) {
                            if (typeof data[key] === 'string' && data[key].trim()) {
                                content = data[key];
                                console.log(`è§’è‰²äº’åŠ¨APIä½¿ç”¨å­—æ®µ "${key}" ä½œä¸ºå“åº”å†…å®¹`);
                                break;
                            }
                        }
                    }
                    
                    if (!content) {
                        console.error('è§’è‰²äº’åŠ¨APIæ— æ³•è§£æå“åº”ï¼Œå®Œæ•´å“åº”æ•°æ®:', data);
                return '';
                    }
                }
                
                return content ? content.trim() : '';
                
            } catch (error) {
                console.error('ç”Ÿæˆè§’è‰²äº’åŠ¨å¤±è´¥:', error);
                return '';
            }
        }
        

        
        // é•¿æŒ‰é€‰æ‹©åŠŸèƒ½
        function addLongPressListener(element, momentId) {
            let pressTimer = null;
            let startY = 0;
            let moved = false;
            
            const startPress = (e) => {
                if (isSelectionMode) return;
                
                startY = e.touches ? e.touches[0].clientY : e.clientY;
                moved = false;
                
                pressTimer = setTimeout(() => {
                    if (!moved) {
                        enterSelectionMode();
                        selectMoment(momentId);
                    }
                }, 500); // 500msé•¿æŒ‰
            };
            
            const endPress = () => {
                clearTimeout(pressTimer);
                pressTimer = null;
            };
            
            const movePress = (e) => {
                const currentY = e.touches ? e.touches[0].clientY : e.clientY;
                if (Math.abs(currentY - startY) > 10) {
                    moved = true;
                    endPress();
                }
            };
            
            element.addEventListener('touchstart', startPress);
            element.addEventListener('touchend', endPress);
            element.addEventListener('touchmove', movePress);
            element.addEventListener('mousedown', startPress);
            element.addEventListener('mouseup', endPress);
            element.addEventListener('mousemove', movePress);
        }
        
        // è¿›å…¥é€‰æ‹©æ¨¡å¼
        function enterSelectionMode() {
            isSelectionMode = true;
            selectedMoments.clear();
            
            // æ˜¾ç¤ºé€‰æ‹©æ¨¡å¼UI
            showSelectionModeUI();
            
            // æ·»åŠ é€‰æ‹©æ¡†åˆ°æ‰€æœ‰åŠ¨æ€
            const momentItems = document.querySelectorAll('.moment-item');
            momentItems.forEach(item => {
                const checkbox = document.createElement('div');
                checkbox.className = 'moment-checkbox';
                checkbox.innerHTML = '<i class="far fa-circle"></i>';
                checkbox.onclick = (e) => {
                    e.stopPropagation();
                    const momentId = item.getAttribute('data-moment-id');
                    toggleMomentSelection(momentId);
                };
                item.appendChild(checkbox);
                item.classList.add('selection-mode');
            });
        }
        
        // é€€å‡ºé€‰æ‹©æ¨¡å¼
        function exitSelectionMode() {
            isSelectionMode = false;
            selectedMoments.clear();
            
            // éšè—é€‰æ‹©æ¨¡å¼UI
            hideSelectionModeUI();
            
            // ç§»é™¤é€‰æ‹©æ¡†
            const checkboxes = document.querySelectorAll('.moment-checkbox');
            checkboxes.forEach(checkbox => checkbox.remove());
            
            const momentItems = document.querySelectorAll('.moment-item');
            momentItems.forEach(item => {
                item.classList.remove('selection-mode', 'selected');
            });
        }
        
        // æ˜¾ç¤ºé€‰æ‹©æ¨¡å¼UI
        function showSelectionModeUI() {
            const selectionBar = document.createElement('div');
            selectionBar.className = 'selection-bar';
            selectionBar.innerHTML = `
                <div class="selection-actions">
                    <button class="cancel-btn" data-action="cancel">å–æ¶ˆ</button>
                    <span class="selection-count">å·²é€‰æ‹© 0 æ¡åŠ¨æ€</span>
                    <button class="delete-btn" data-action="delete" disabled>åˆ é™¤</button>
                </div>
            `;

            // ğŸ”¥ã€ä¿®å¤ã€‘ä½¿ç”¨äº‹ä»¶å§”æ‰˜ç»‘å®šç‚¹å‡»äº‹ä»¶ï¼Œé¿å…å†…è”onclické—®é¢˜
            selectionBar.onclick = function(e) {
                const action = e.target.dataset.action;
                if (action === 'cancel') {
                    exitSelectionMode();
                } else if (action === 'delete' && !e.target.disabled) {
                    deleteSelectedMoments();
                }
            };

            const momentsPage = document.getElementById('moments-page');
            momentsPage.insertBefore(selectionBar, momentsPage.firstChild);
        }
        
        // éšè—é€‰æ‹©æ¨¡å¼UI
        function hideSelectionModeUI() {
            const selectionBar = document.querySelector('.selection-bar');
            if (selectionBar) {
                selectionBar.remove();
            }
        }
        
        // åˆ‡æ¢åŠ¨æ€é€‰æ‹©çŠ¶æ€
        function toggleMomentSelection(momentId) {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;
            
            const checkbox = momentElement.querySelector('.moment-checkbox i');
            
            if (selectedMoments.has(momentId)) {
                selectedMoments.delete(momentId);
                checkbox.className = 'far fa-circle';
                momentElement.classList.remove('selected');
            } else {
                selectedMoments.add(momentId);
                checkbox.className = 'fas fa-check-circle';
                momentElement.classList.add('selected');
            }
            
            updateSelectionUI();
        }
        
        // é€‰æ‹©åŠ¨æ€
        function selectMoment(momentId) {
            if (!selectedMoments.has(momentId)) {
                toggleMomentSelection(momentId);
            }
        }
        
        // æ›´æ–°é€‰æ‹©UI
        function updateSelectionUI() {
            const countSpan = document.querySelector('.selection-count');
            const deleteBtn = document.querySelector('.delete-btn');
            
            if (countSpan) {
                countSpan.textContent = `å·²é€‰æ‹© ${selectedMoments.size} æ¡åŠ¨æ€`;
            }
            
            if (deleteBtn) {
                deleteBtn.disabled = selectedMoments.size === 0;
            }
        }
        
        // åˆ é™¤é€‰ä¸­çš„åŠ¨æ€
        async function deleteSelectedMoments() {
            if (selectedMoments.size === 0) return;
            
            if (!confirm(`ç¡®å®šè¦åˆ é™¤ ${selectedMoments.size} æ¡åŠ¨æ€å—ï¼Ÿ`)) {
                return;
            }
            
            try {
                // ä»æ•°æ®åº“ä¸­åˆ é™¤
                for (const momentId of selectedMoments) {
                    try {
                        // å°è¯•å¤šç§IDæ ¼å¼è¿›è¡Œåˆ é™¤
                        let deleted = false;
                        const possibleIds = [momentId, parseInt(momentId), String(momentId), Number(momentId)];
                        
                        for (const id of possibleIds) {
                            try {
                                await db.moments.delete(id);
                                console.log(`âœ“ æˆåŠŸåˆ é™¤åŠ¨æ€ ${id} (ç±»å‹: ${typeof id})`);
                                deleted = true;
                                break;
                            } catch (error) {
                                console.log(`åˆ é™¤ID ${id} (${typeof id}) å¤±è´¥: ${error.message}`);
                            }
                        }
                        
                        if (!deleted) {
                            // å°è¯•ä½¿ç”¨whereæ¡ä»¶åˆ é™¤
                            await db.moments.where('id').equals(momentId).delete();
                            console.log(`âœ“ ä½¿ç”¨whereæ¡ä»¶åˆ é™¤åŠ¨æ€ ${momentId} æˆåŠŸ`);
                        }
                        
                        // åˆ é™¤ç›¸å…³ç‚¹èµï¼ˆå°è¯•ä¸åŒIDæ ¼å¼ï¼‰
                        const numericId = parseInt(momentId);
                        await db.momentLikes.where('momentId').equals(numericId).delete();
                        await db.momentLikes.where('momentId').equals(momentId).delete();
                        
                        // åˆ é™¤ç›¸å…³è¯„è®ºï¼ˆå°è¯•ä¸åŒIDæ ¼å¼ï¼‰
                        await db.momentComments.where('momentId').equals(numericId).delete();
                        await db.momentComments.where('momentId').equals(momentId).delete();
                        
                    } catch (error) {
                        console.error(`åˆ é™¤åŠ¨æ€ ${momentId} å¤±è´¥:`, error);
                        throw error; // é‡æ–°æŠ›å‡ºé”™è¯¯ä»¥ä¾¿ä¸Šå±‚å¤„ç†
                    }
                    
                    // æ¸…ç†å¯¹è¯å›åˆæ¬¡è®°å½•
                    for (const [key, value] of commentConversationRounds.entries()) {
                        if (key.startsWith(`${momentId}-`)) {
                            commentConversationRounds.delete(key);
                        }
                    }
            }
            
            // ä»DOMä¸­ç§»é™¤
            selectedMoments.forEach(momentId => {
                const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
                if (momentElement) {
                    momentElement.remove();
                }
            });
                
                // æ¸…ç†å¯èƒ½å­˜åœ¨çš„sessionStorageç¼“å­˜æ•°æ®
                try {
                    const sessionMomentsData = sessionStorage.getItem('momentsData');
                    if (sessionMomentsData) {
                        const momentsArray = JSON.parse(sessionMomentsData);
                        const filteredMoments = momentsArray.filter(moment => 
                            !selectedMoments.has(moment.id.toString()) && 
                            !selectedMoments.has(moment.timestamp?.toString())
                        );
                        sessionStorage.setItem('momentsData', JSON.stringify(filteredMoments));
                    }
                } catch (error) {
                    console.warn('æ¸…ç†sessionStorageåŠ¨æ€æ•°æ®æ—¶å‡ºé”™:', error);
                }
            
            showToast(`å·²åˆ é™¤ ${selectedMoments.size} æ¡åŠ¨æ€`);
            
            // é€€å‡ºé€‰æ‹©æ¨¡å¼
            exitSelectionMode();
                
                // å¼ºåˆ¶é‡æ–°åŠ è½½åŠ¨æ€åˆ—è¡¨ï¼Œç¡®ä¿åˆ é™¤ç”Ÿæ•ˆ
                setTimeout(() => {
                    loadMoments();
                }, 500);
                
            } catch (error) {
                console.error('åˆ é™¤åŠ¨æ€å¤±è´¥:', error);
                showToast('åˆ é™¤å¤±è´¥ï¼Œè¯·é‡è¯•');
            }
        }
        
        // å¼ºåˆ¶æ¸…ç†æŒ‡å®šåŠ¨æ€çš„æ‰€æœ‰ç›¸å…³æ•°æ®
        async function forceCleanMoment(momentId) {
            try {
                const numericId = parseInt(momentId);
                console.log(`å¼€å§‹å½»åº•æ¸…ç†åŠ¨æ€: ${momentId}`);
                
                // 1. ä»IndexedDBåˆ é™¤ï¼ˆå°è¯•å¤šç§IDæ ¼å¼ï¼‰
                let deleted = false;
                const possibleIds = [momentId, numericId, String(momentId), Number(momentId)];
                
                for (const id of possibleIds) {
                    try {
                        await db.moments.delete(id);
                        console.log(`âœ“ åˆ é™¤åŠ¨æ€æˆåŠŸï¼Œä½¿ç”¨ID: ${id} (ç±»å‹: ${typeof id})`);
                        deleted = true;
                        break;
                    } catch (error) {
                        console.log(`åˆ é™¤ID ${id} å¤±è´¥: ${error.message}`);
                    }
                }
                
                if (!deleted) {
                    await db.moments.where('id').equals(momentId).delete();
                }
                
                // åˆ é™¤ç›¸å…³æ•°æ®ï¼ˆå°è¯•ä¸åŒæ ¼å¼ï¼‰
                await db.momentLikes.where('momentId').equals(numericId).delete();
                await db.momentLikes.where('momentId').equals(momentId).delete();
                await db.momentComments.where('momentId').equals(numericId).delete();
                await db.momentComments.where('momentId').equals(momentId).delete();
                
                // 2. æ¸…ç†å¯¹è¯å›åˆæ¬¡è®°å½•
                for (const [key, value] of commentConversationRounds.entries()) {
                    if (key.startsWith(`${momentId}-`)) {
                        commentConversationRounds.delete(key);
                    }
                }
                
                // 3. ä»DOMç§»é™¤
                const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
                if (momentElement) {
                    momentElement.remove();
                }
                
                // 4. æ¸…ç†sessionStorageç¼“å­˜
                const sessionMomentsData = sessionStorage.getItem('momentsData');
                if (sessionMomentsData) {
                    const momentsArray = JSON.parse(sessionMomentsData);
                    const filteredMoments = momentsArray.filter(moment => 
                        moment.id != momentId && 
                        moment.timestamp != momentId &&
                        moment.id.toString() !== momentId.toString()
                    );
                    sessionStorage.setItem('momentsData', JSON.stringify(filteredMoments));
                }
                
                console.log(`åŠ¨æ€ ${momentId} æ¸…ç†å®Œæˆ`);
                return true;
            } catch (error) {
                console.error('å¼ºåˆ¶æ¸…ç†åŠ¨æ€å¤±è´¥:', error);
                return false;
            }
        }
        
        // æ¸…ç†æ‰€æœ‰æœ‰é—®é¢˜çš„åŠ¨æ€ï¼ˆä¿®å¤å·¥å…·ï¼‰
        async function cleanupCorruptedMoments() {
            if (!confirm('è¿™å°†æ¸…ç†æ‰€æœ‰å¯èƒ½æœ‰é—®é¢˜çš„åŠ¨æ€æ•°æ®ï¼Œç¡®å®šç»§ç»­å—ï¼Ÿ')) {
                return;
            }
            
            try {
                let cleanupCount = 0;
                
                // è·å–æ‰€æœ‰åŠ¨æ€
                const allMoments = await db.moments.toArray();
                
                for (const moment of allMoments) {
                    // æ£€æŸ¥åŠ¨æ€æ˜¯å¦æœ‰æ— æ•ˆçš„å¤´åƒæ•°æ®
                    if (moment.avatar && !isValidAvatarUrl(moment.avatar)) {
                        console.log(`å‘ç°æ— æ•ˆå¤´åƒçš„åŠ¨æ€: ${moment.id}`);
                        
                        // ä¿®å¤å¤´åƒæˆ–åˆ é™¤åŠ¨æ€
                        const shouldDelete = confirm(`åŠ¨æ€ "${moment.text?.substring(0, 30)}..." åŒ…å«æ— æ•ˆå¤´åƒæ•°æ®ï¼Œæ˜¯å¦åˆ é™¤æ­¤åŠ¨æ€ï¼Ÿ\nç‚¹å‡»"å–æ¶ˆ"å°†ä¿®å¤å¤´åƒæ•°æ®ã€‚`);
                        
                        if (shouldDelete) {
                            await forceCleanMoment(moment.id);
                            cleanupCount++;
                        } else {
                            // ä¿®å¤å¤´åƒ
                            await db.moments.update(moment.id, { avatar: getDefaultAvatar() });
                        }
                    }
                }
                
                if (cleanupCount > 0) {
                    showToast(`å·²æ¸…ç† ${cleanupCount} æ¡æœ‰é—®é¢˜çš„åŠ¨æ€`);
                    // é‡æ–°åŠ è½½åŠ¨æ€åˆ—è¡¨
                    loadMoments();
                } else {
                    showToast('æ²¡æœ‰å‘ç°éœ€è¦æ¸…ç†çš„åŠ¨æ€');
                }
                
            } catch (error) {
                console.error('æ¸…ç†æŸååŠ¨æ€å¤±è´¥:', error);
                showToast('æ¸…ç†å¤±è´¥ï¼Œè¯·é‡è¯•');
            }
        }
        
        // æ›´æ¢åŠ¨æ€å°é¢å›¾ç‰‡
        function changeCoverImage() {
            const input = document.createElement("input");
            input.type = "file";
            input.accept = "image/*,.jpg,.jpeg,.png,.gif,.webp";
            input.onchange = async function(e) {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedImage = await compressImage(file, 1200, 0.8);
                        
                        const coverImage = document.getElementById("cover-image");
                        const coverPlaceholder = document.getElementById("cover-placeholder");
                        
                        if (coverImage && coverPlaceholder) {
                            coverImage.src = compressedImage;
                            coverImage.classList.remove("hide");
                            coverPlaceholder.classList.add("hide");
                        }
                        
                        saveMomentsImage("coverImage", compressedImage);
                        showToast("å°é¢å·²æ›´æ–°ï¼", "success");
                    } catch (error) {
                        console.error("å¤„ç†å°é¢å›¾ç‰‡å¤±è´¥:", error);
                        showToast("å°é¢æ›´æ–°å¤±è´¥ï¼", "error");
                    }
                }
            };
            input.click();
        }
        
        // æ›´æ¢åŠ¨æ€å¤´åƒ
        function changeAvatarImage(event) {
            event.stopPropagation();
            
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*,.jpg,.jpeg,.png,.gif,.webp';
            input.onchange = async function(e) {
                const file = e.target.files[0];
                if (file) {
                    try {
                        // å‹ç¼©å¤´åƒå›¾ç‰‡
                        const compressedImage = await compressImage(file, 400, 0.9);
                        
                        const avatar = document.getElementById('moments-avatar');
                        const avatarIcon = avatar.querySelector('.moments-avatar-icon');
                        
                        avatar.style.backgroundImage = `url(${compressedImage})`;
                        avatarIcon.style.display = 'none';
                        
                        // ä¿å­˜å‹ç¼©åçš„å›¾ç‰‡
                        saveMomentsImage('avatarImage', compressedImage);
                        
                        showToast('å¤´åƒå·²æ›´æ–°ï¼', 'success');
                    } catch (error) {
                        console.error('å¤„ç†å¤´åƒå›¾ç‰‡å¤±è´¥:', error);
                        showToast('å¤´åƒæ›´æ–°å¤±è´¥ï¼', 'error');
                    }
                }
            };
            input.click();
        }
        
        // ğŸ”¥ã€ä¿®å¤ã€‘åŠ è½½åŠ¨æ€å›¾ç‰‡è®¾ç½®ï¼ˆå¼‚æ­¥ç‰ˆæœ¬ï¼‰
        async function loadMomentsImages() {
            try {
                // åŠ è½½å°é¢å›¾ç‰‡
                const savedCover = await getMomentsImage('coverImage');
                if (savedCover) {
                    const coverImage = document.getElementById('cover-image');
                    const coverPlaceholder = document.getElementById('cover-placeholder');
                    
                    if (coverImage && coverPlaceholder) {
                        coverImage.src = savedCover;
                        coverImage.classList.remove('hide');
                        coverPlaceholder.classList.add('hide');
                    }
                }
                
                // åŠ è½½å¤´åƒå›¾ç‰‡
                const savedAvatar = await getMomentsImage('avatarImage');
                if (savedAvatar) {
                    const avatar = document.getElementById('moments-avatar');
                    const avatarIcon = avatar?.querySelector('.moments-avatar-icon');
                    
                    if (avatar) {
                        avatar.style.backgroundImage = `url(${savedAvatar})`;
                        if (avatarIcon) {
                            avatarIcon.style.display = 'none';
                        }
                    }
                }
                
                // åŠ è½½ç”¨æˆ·å
                const savedUsername = await getMomentsImage('username');
                if (savedUsername) {
                    const usernameElement = document.getElementById('moments-username');
                    if (usernameElement) {
                        usernameElement.textContent = savedUsername;
                    }
                }
                
                console.log('åŠ¨æ€å›¾ç‰‡åŠ è½½å®Œæˆ');
            } catch (error) {
                console.error('åŠ è½½åŠ¨æ€å›¾ç‰‡å¤±è´¥:', error);
            }
        }
        
        // æ›´æ”¹ç”¨æˆ·å
        function changeUsername(event) {
            event.stopPropagation();
            
            const currentUsername = document.getElementById('moments-username').textContent;
            const newUsername = prompt('è¯·è¾“å…¥æ‚¨çš„æ˜µç§°:', currentUsername);
            
            if (newUsername !== null && newUsername.trim() !== '') {
                const usernameElement = document.getElementById('moments-username');
                usernameElement.textContent = newUsername.trim();
                
                // ä¿å­˜ç”¨æˆ·å
                saveMomentsImage('username', newUsername.trim());
                
                showToast('æ˜µç§°å·²æ›´æ–°ï¼', 'success');
            }
        }
        
        // å‹ç¼©å›¾ç‰‡
        function compressImage(fileOrDataUrl, maxWidth = 800, quality = 0.8) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = function() {
                    // è®¡ç®—å‹ç¼©åçš„å°ºå¯¸
                    let { width, height } = img;
                    if (width > maxWidth) {
                        height = (height * maxWidth) / width;
                        width = maxWidth;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    // ç»˜åˆ¶å‹ç¼©åçš„å›¾ç‰‡
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // è½¬æ¢ä¸ºbase64ï¼Œé™ä½è´¨é‡ä»¥å‡å°‘å¤§å°
                    const compressedData = canvas.toDataURL('image/jpeg', quality);
                    resolve(compressedData);
                };
                
                // åˆ¤æ–­è¾“å…¥ç±»å‹ï¼šFileå¯¹è±¡è¿˜æ˜¯base64å­—ç¬¦ä¸²
                if (typeof fileOrDataUrl === 'string') {
                    // å¦‚æœæ˜¯base64å­—ç¬¦ä¸²ï¼Œç›´æ¥ä½¿ç”¨
                    img.src = fileOrDataUrl;
                } else {
                    // å¦‚æœæ˜¯Fileå¯¹è±¡ï¼Œåˆ›å»ºURL
                    img.src = URL.createObjectURL(fileOrDataUrl);
                }
            });
        }
        
        // ğŸ”¥ã€ä¿®å¤ã€‘ä¿å­˜åŠ¨æ€å›¾ç‰‡ï¼ˆä½¿ç”¨IndexedDBæŒä¹…åŒ–å­˜å‚¨ï¼‰
        async function saveMomentsImage(imageType, imageData) {
            try {
                // å‹ç¼©å›¾ç‰‡æ•°æ®ä»¥èŠ‚çœå­˜å‚¨ç©ºé—´
                let compressedData = imageData;
                if (imageData.startsWith('data:image/')) {
                    try {
                        compressedData = await compressImage(imageData, 800, 0.8);
                    } catch (error) {
                        console.warn('å›¾ç‰‡å‹ç¼©å¤±è´¥ï¼Œä½¿ç”¨åŸå›¾:', error);
                    }
                }
                
                // ä¿å­˜åˆ°IndexedDB
                await db.globalSettings.put({
                    id: `moments_${imageType}`,
                    type: 'moments_setting',
                    data: compressedData
                });
                
                console.log(`åŠ¨æ€å›¾ç‰‡å·²ä¿å­˜åˆ°æ•°æ®åº“: ${imageType}`);
            } catch (error) {
                console.error('ä¿å­˜åŠ¨æ€å›¾ç‰‡å¤±è´¥:', error);
                // å¦‚æœæ•°æ®åº“ä¿å­˜å¤±è´¥ï¼Œå›é€€åˆ°sessionStorage
                try {
                    sessionStorage.setItem(`moments_${imageType}`, imageData);
                    console.log(`åŠ¨æ€å›¾ç‰‡å·²ä¿å­˜åˆ°ä¼šè¯å­˜å‚¨: ${imageType}`);
                } catch (sessionError) {
                    // å¦‚æœsessionStorageä¹Ÿæ»¡äº†ï¼Œåªåœ¨å†…å­˜ä¸­ä¿å­˜
                    window.momentsImages = window.momentsImages || {};
                    window.momentsImages[imageType] = imageData;
                    console.log(`åŠ¨æ€å›¾ç‰‡å·²ä¿å­˜åˆ°å†…å­˜: ${imageType}`);
                }
            }
        }
        
        // ğŸ”¥ã€ä¿®å¤ã€‘è·å–åŠ¨æ€å›¾ç‰‡ï¼ˆä»IndexedDBè·å–ï¼‰
        async function getMomentsImage(imageType) {
            try {
                // å…ˆä»IndexedDBè·å–
                const dbData = await db.globalSettings.get(`moments_${imageType}`);
                if (dbData && dbData.data) {
                    return dbData.data;
                }
                
                // å…¼å®¹æ€§ï¼šä»sessionStorageè·å–
                const sessionData = sessionStorage.getItem(`moments_${imageType}`);
                if (sessionData) {
                    // å¦‚æœä»sessionStorageè·å–åˆ°æ•°æ®ï¼Œè¿ç§»åˆ°IndexedDB
                    await saveMomentsImage(imageType, sessionData);
                    return sessionData;
                }
                
                // æœ€åä»å†…å­˜è·å–
                if (window.momentsImages && window.momentsImages[imageType]) {
                    return window.momentsImages[imageType];
                }
                
                return null;
            } catch (error) {
                console.error('è·å–åŠ¨æ€å›¾ç‰‡å¤±è´¥:', error);
                // å›é€€åˆ°sessionStorage
                try {
                    return sessionStorage.getItem(`moments_${imageType}`);
                } catch (sessionError) {
                    return null;
                }
            }
        }
        
        // ğŸ”¥ã€æ–°å¢ã€‘æ•°æ®å®Œæ•´æ€§æ£€æŸ¥å‡½æ•°
        function validateDataIntegrity(data, dataType) {
            if (!data) return false;

            switch (dataType) {
                case 'characters':
                    return Array.isArray(data) && data.every(char =>
                        char && char.id && char.name &&
                        char.name !== 'å¼ ä¸‰' && char.name !== 'æå››'
                    );
                case 'chatMessages':
                    return Array.isArray(data) && data.every(msg =>
                        msg && msg.id && msg.characterId
                    );
                case 'chatSettings':
                    return Array.isArray(data) && data.every(setting =>
                        setting && setting.id && setting.chatId
                    );
                default:
                    return Array.isArray(data) ? data.length > 0 : !!data;
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘å®‰å…¨çš„æ•°æ®ä¿å­˜å‡½æ•°ï¼Œé˜²æ­¢æ•°æ®ä¸¢å¤±
        async function safeDataSave(tableName, data, operation = 'replace') {
            if (!data || (Array.isArray(data) && data.length === 0)) {
                console.warn(`âš ï¸ ${tableName} æ•°æ®ä¸ºç©ºï¼Œæ‹’ç»ä¿å­˜ä»¥é˜²æ­¢æ•°æ®ä¸¢å¤±`);
                return false;
            }

            // æ•°æ®å®Œæ•´æ€§æ£€æŸ¥
            if (!validateDataIntegrity(data, tableName)) {
                console.error(`âŒ ${tableName} æ•°æ®å®Œæ•´æ€§æ£€æŸ¥å¤±è´¥ï¼Œæ‹’ç»ä¿å­˜`);
                throw new Error(`${tableName} æ•°æ®ä¸å®Œæ•´æˆ–åŒ…å«å¼‚å¸¸æ•°æ®`);
            }

            try {
                const table = db[tableName];
                if (!table) {
                    throw new Error(`è¡¨ ${tableName} ä¸å­˜åœ¨`);
                }

                // ä½¿ç”¨äº‹åŠ¡è¿›è¡ŒåŸå­æ“ä½œ
                await db.transaction('rw', table, async () => {
                    if (operation === 'replace') {
                        await table.clear();
                        if (Array.isArray(data)) {
                            await table.bulkPut(data);
                        } else {
                            await table.put(data);
                        }
                    } else if (operation === 'add') {
                        if (Array.isArray(data)) {
                            await table.bulkAdd(data);
                        } else {
                            await table.add(data);
                        }
                    }
                });

                const count = Array.isArray(data) ? data.length : 1;
                console.log(`âœ… å®‰å…¨ä¿å­˜äº† ${count} æ¡ ${tableName} æ•°æ®`);
                return true;
            } catch (error) {
                console.error(`âŒ ä¿å­˜ ${tableName} æ•°æ®å¤±è´¥:`, error);
                throw error;
            }
        }

        // é‡ç½®æ•°æ®åº“ï¼ˆå¦‚æœå‡ºç°schemaé”™è¯¯ï¼‰
        async function resetDatabase() {
            try {
                await db.delete();
                console.log('æ•°æ®åº“å·²é‡ç½®');
                location.reload(); // é‡æ–°åŠ è½½é¡µé¢
            } catch (error) {
                console.error('é‡ç½®æ•°æ®åº“å¤±è´¥:', error);
            }
        }
        
        // ğŸ®ã€æ–°å¢ã€‘æ¸¸æˆè·¨åº”ç”¨è®°å¿†è®°å½•å‡½æ•°
        async function recordGameEvent(characterId, eventType, gameData) {
            try {
                await recordCrossAppEvent(
                    characterId,
                    'game',
                    eventType,
                    {
                        id: `game_${Date.now()}`,
                        type: 'game_session',
                        gameName: gameData.gameName,
                        action: eventType,
                        result: gameData.result,
                        score: gameData.score,
                        chatContent: gameData.chatContent,
                        timestamp: Date.now()
                    }
                );
                console.log(`ğŸ® å·²è®°å½•æ¸¸æˆäº‹ä»¶: ${eventType} - ${gameData.gameName}`);
            } catch (error) {
                console.error('è®°å½•æ¸¸æˆäº‹ä»¶å¤±è´¥:', error);
            }
        }

        // ğŸ®ã€æ–°å¢ã€‘æ¸¸æˆèŠå¤©è®°å½•å‡½æ•°
        async function recordGameChat(characterId, sender, message, gameContext) {
            try {
                await recordCrossAppEvent(
                    characterId,
                    'game',
                    'game_chat',
                    {
                        id: `game_chat_${Date.now()}`,
                        type: 'game_chat',
                        sender: sender,
                        content: message,
                        gameName: gameContext.gameName,
                        gameState: gameContext.gameState,
                        timestamp: Date.now()
                    }
                );
                console.log(`ğŸ® å·²è®°å½•æ¸¸æˆèŠå¤©: ${sender} - ${message.substring(0, 30)}...`);
            } catch (error) {
                console.error('è®°å½•æ¸¸æˆèŠå¤©å¤±è´¥:', error);
            }
        }

        // å¼€å§‹æ¸¸æˆ
        function startGame(gameName) {
            if (gameName === 'witchPotion') {
                // TODO: å®ç°å¥³å·«çš„è§£è¯æ¸¸æˆ
                alert('å¥³å·«çš„è§£è¯æ¸¸æˆæ­£åœ¨å¼€å‘ä¸­...\n\nè¿™å°†æ˜¯ä¸€ä¸ªä¸AIè§’è‰²äº’åŠ¨çš„è§£è°œæ¸¸æˆï¼\n\nğŸ® æ¸¸æˆåŠŸèƒ½é¢„è§ˆï¼š\n- ä¸AIè§’è‰²ä¸€è¾¹æ¸¸æˆä¸€è¾¹èŠå¤©\n- æ¸¸æˆç»“æœå’ŒèŠå¤©å†…å®¹éƒ½ä¼šè®°å½•åˆ°å·¥ä½œè®°å¿†ä¸­\n- æŒ‰æ—¶é—´é¡ºåºä¸æ™®é€šèŠå¤©è®°å½•åˆå¹¶æ˜¾ç¤º');

                // ğŸ®ã€ç¤ºä¾‹ã€‘è®°å½•æ¸¸æˆå¼€å§‹äº‹ä»¶
                if (currentChatCharacter && !currentChatCharacter.isGroup) {
                    recordGameEvent(currentChatCharacter.id, 'game_start', {
                        gameName: 'å¥³å·«çš„è§£è¯',
                        result: null,
                        score: null,
                        chatContent: null
                    });
                }
            } else {
                alert('æ¸¸æˆåŠŸèƒ½æ­£åœ¨å¼€å‘ä¸­...');
            }
        }
        
                // åˆ‡æ¢æ‰‹æœºè¾¹æ¡†æ˜¾ç¤º
        function togglePhoneBorder() {
            const phoneFrame = document.getElementById('phone-frame');
            const phoneScreen = document.getElementById('phone-screen');
            const toggle = document.getElementById('phone-border-toggle');
            const body = document.body;
            
            if (toggle.checked) {
                // æ˜¾ç¤ºçœŸå®æ‰‹æœºè¾¹æ¡†
                phoneFrame.style.display = 'block';
                phoneFrame.style.padding = '12px';
                phoneFrame.style.backgroundColor = '#fff';
                phoneFrame.style.borderRadius = '50px';
                phoneFrame.style.boxShadow = '0 20px 50px rgba(0,0,0,0.25), inset 0 2px 4px rgba(0,0,0,0.1)';
                phoneScreen.style.borderRadius = '40px';
                phoneScreen.style.border = '2px solid #333';
                body.style.background = 'var(--body-bg, #dcdcdc)';
                body.style.padding = '20px';
            } else {
                // éšè—è¾¹æ¡†ï¼Œä½†ä¿æŒphone-screençš„åœ†è§’å’Œé˜´å½±
                phoneFrame.style.display = 'block';
                phoneFrame.style.padding = '0';
                phoneFrame.style.backgroundColor = 'transparent';
                phoneFrame.style.borderRadius = '0';
                phoneFrame.style.boxShadow = 'none';
                phoneScreen.style.borderRadius = '25px';
                phoneScreen.style.border = 'none';
                phoneScreen.style.boxShadow = 'var(--shadow-phone)';
                body.style.background = 'var(--body-bg, #1a1a1a)';
                body.style.padding = '0';
            }
            
            // ä¿å­˜è®¾ç½®åˆ°localStorage
            localStorage.setItem('phoneBorderEnabled', toggle.checked);
            
            // æ˜¾ç¤ºæç¤º
            const message = toggle.checked ? 'æ‰‹æœºè¾¹æ¡†å·²å¼€å¯ï¼' : 'æ‰‹æœºè¾¹æ¡†å·²å…³é—­ï¼';
            showToast(message, 'success');
        }
        
        // æ˜¾ç¤ºå±å¹•å°ºå¯¸é€‰æ‹©
        function showScreenSizeOptions() {
            showApp('screen-size-screen');
        }
        
        // æ”¹å˜å±å¹•å°ºå¯¸
        function changeScreenSize(width, height, name) {
            const phoneScreen = document.getElementById('phone-screen');
            
            // åº”ç”¨æ–°å°ºå¯¸
            phoneScreen.style.width = width + 'px';
            phoneScreen.style.height = height + 'px';
            
            // æ›´æ–°å¤–è§‚è®¾ç½®ä¸­çš„æ˜¾ç¤ºæ–‡æœ¬
            const currentSizeDesc = document.getElementById('current-screen-size');
            if (currentSizeDesc) {
                currentSizeDesc.textContent = `å½“å‰ï¼š${width}Ã—${height} (${name})`;
            }
            
            // æ›´æ–°é€‰ä¸­çŠ¶æ€
            document.querySelectorAll('.size-option .check-icon').forEach(icon => {
                icon.style.display = 'none';
            });
            document.querySelectorAll('.size-option').forEach(option => {
                option.style.backgroundColor = '';
            });
            
            // æ˜¾ç¤ºå½“å‰é€‰ä¸­é¡¹çš„å‹¾é€‰å›¾æ ‡
            const currentOption = event.target.closest('.size-option');
            if (currentOption) {
                const checkIcon = currentOption.querySelector('.check-icon');
                if (checkIcon) {
                    checkIcon.style.display = 'block';
                } else {
                    // å¦‚æœæ²¡æœ‰å‹¾é€‰å›¾æ ‡ï¼Œåˆ›å»ºä¸€ä¸ª
                    const newCheckIcon = document.createElement('i');
                    newCheckIcon.className = 'fas fa-check check-icon';
                    newCheckIcon.style.display = 'block';
                    currentOption.appendChild(newCheckIcon);
                }
                currentOption.style.backgroundColor = 'rgba(0, 123, 255, 0.1)';
            }
            
            // ä¿å­˜åˆ°localStorage
            localStorage.setItem('screenSize', JSON.stringify({width, height, name}));
            
            // æ˜¾ç¤ºæç¤º
            showToast(`å±å¹•å°ºå¯¸å·²åˆ‡æ¢ä¸º${name}ï¼`, 'success');
            
            // å»¶è¿Ÿä¸€ç‚¹å†è¿”å›ï¼Œè®©ç”¨æˆ·çœ‹åˆ°é€‰æ‹©æ•ˆæœ
            setTimeout(() => {
                showApp('appearance-screen');
            }, 300);
        }
        
        // åŠ è½½å±å¹•å°ºå¯¸è®¾ç½®
        function loadScreenSize() {
            const saved = localStorage.getItem('screenSize');
            if (saved) {
                const {width, height, name} = JSON.parse(saved);
                const phoneScreen = document.getElementById('phone-screen');
                phoneScreen.style.width = width + 'px';
                phoneScreen.style.height = height + 'px';
                
                const currentSizeDesc = document.getElementById('current-screen-size');
                if (currentSizeDesc) {
                    currentSizeDesc.textContent = `å½“å‰ï¼š${width}Ã—${height} (${name})`;
                }
            }
        }

        // æ›´æ–°çŠ¶æ€æ å›¾æ ‡
        function updateStatusIcon() {
            const input = document.getElementById('status-icon-input');
            const icon = input.value.trim() || 'ğŸ¾';

            // æ›´æ–°CSSå˜é‡
            document.documentElement.style.setProperty('--status-icon', `"${icon}"`);

            // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
            localStorage.setItem('statusIcon', icon);
        }

        // é‡ç½®çŠ¶æ€æ å›¾æ ‡
        function resetStatusIcon() {
            const input = document.getElementById('status-icon-input');
            input.value = 'ğŸ¾';
            updateStatusIcon();
        }



        // åŠ è½½çŠ¶æ€æ å›¾æ ‡è®¾ç½®
        function loadStatusIconSetting() {
            const saved = localStorage.getItem('statusIcon');
            const input = document.getElementById('status-icon-input');
            const icon = saved || 'ğŸ¾';

            if (input) {
                input.value = icon;
            }

            // åº”ç”¨è®¾ç½®
            document.documentElement.style.setProperty('--status-icon', `"${icon}"`);
        }

        // åŠ è½½è¾¹æ¡†è®¾ç½®
        function loadPhoneBorderSetting() {
            const saved = localStorage.getItem('phoneBorderEnabled');
            const toggle = document.getElementById('phone-border-toggle');
            
            // é»˜è®¤å…³é—­è¾¹æ¡†
            const enabled = saved !== null ? saved === 'true' : false;
            
            if (toggle) {
                toggle.checked = enabled;
            }
            
            // åº”ç”¨è®¾ç½®
            const phoneFrame = document.getElementById('phone-frame');
            const phoneScreen = document.getElementById('phone-screen');
            const body = document.body;
            
            if (enabled) {
                // æ˜¾ç¤ºçœŸå®æ‰‹æœºè¾¹æ¡†
                phoneFrame.style.display = 'block';
                phoneFrame.style.padding = '12px';
                phoneFrame.style.backgroundColor = '#fff';
                phoneFrame.style.borderRadius = '50px';
                phoneFrame.style.boxShadow = '0 20px 50px rgba(0,0,0,0.25), inset 0 2px 4px rgba(0,0,0,0.1)';
                phoneScreen.style.borderRadius = '40px';
                phoneScreen.style.border = '2px solid #333';
                body.style.background = 'var(--body-bg, #dcdcdc)';
                body.style.padding = '20px';
            } else {
                // éšè—è¾¹æ¡†ï¼Œä½†ä¿æŒphone-screençš„åœ†è§’å’Œé˜´å½±
                phoneFrame.style.display = 'block';
                phoneFrame.style.padding = '0';
                phoneFrame.style.backgroundColor = 'transparent';
                phoneFrame.style.borderRadius = '0';
                phoneFrame.style.boxShadow = 'none';
                phoneScreen.style.borderRadius = '25px';
                phoneScreen.style.border = 'none';
                phoneScreen.style.boxShadow = 'var(--shadow-phone)';
                body.style.background = 'var(--body-bg, #1a1a1a)';
                body.style.padding = '0';
            }
        }
        
        // æ·»åŠ Toastæç¤ºå‡½æ•°
        function showToast(message, type = 'info') {
            // åˆ›å»ºtoastå…ƒç´ 
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background-color: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 500;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                opacity: 0;
                transition: opacity 0.3s ease;
                backdrop-filter: blur(10px);
                -webkit-backdrop-filter: blur(10px);
            `;
            toast.textContent = message;
            
            document.body.appendChild(toast);
            
            // æ˜¾ç¤ºtoast
            setTimeout(() => {
                toast.style.opacity = '1';
            }, 10);
            
            // 3ç§’åè‡ªåŠ¨éšè—
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, 3000);
        }
        
        // æ–‡æœ¬æˆªæ–­å‡½æ•°
        function truncateText(text, maxLength = 50) {
    // --- æ–°å¢çš„å®‰å…¨æ£€æŸ¥ ---
    let textStr = '';
    if (typeof text === 'string') {
        textStr = text;
    } else if (text && typeof text === 'object') {
        // å¦‚æœæ”¶åˆ°äº†ä¸€ä¸ªå¯¹è±¡ï¼Œå¯èƒ½æ˜¯[object Object]é—®é¢˜çš„æ ¹æºï¼Œ
        // æˆ‘ä»¬ä¸å†è®©å®ƒå´©æºƒï¼Œè€Œæ˜¯æ˜¾ç¤ºä¸€ä¸ªé€šç”¨å ä½ç¬¦ã€‚
        console.warn("truncateText å‡½æ•°æ”¶åˆ°äº†ä¸€ä¸ªå¯¹è±¡ï¼Œå·²è‡ªåŠ¨å¤„ç†:", text);
        return '[å¤šåª’ä½“æ¶ˆæ¯]';
    } else {
        // å¯¹äºå…¶ä»–æ„å¤–æƒ…å†µ (å¦‚ null æˆ– undefined)ï¼Œè¿”å›ç©ºå­—ç¬¦ä¸²ã€‚
        return '';
    }
    // --- å®‰å…¨æ£€æŸ¥ç»“æŸ ---

    // ç°åœ¨ textStr ä¿è¯æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œåç»­ä»£ç å¯ä»¥å®‰å…¨æ‰§è¡Œ
            const plainText = textStr.replace(/<[^>]*>/g, '');
            const cleanText = plainText.replace(/\s+/g, ' ').trim();
            
            if (cleanText.length <= maxLength) {
                return cleanText;
            }
            
            return cleanText.substring(0, maxLength) + '...';
        }

        // æ·»åŠ å•ä¸ªæ¶ˆæ¯å¹¶åº”ç”¨åŠ¨ç”»æ•ˆæœ
        function addMessageWithAnimation(message, characterId) {
            const messagesContainer = document.getElementById('api-chat-messages');
            if (!messagesContainer || !currentChatCharacter || characterId !== currentChatCharacter.id) return;
            
            const chatSettings = getCurrentChatSettings();
            const typingIndicator = document.getElementById('typing-indicator');
            
            // å¤„ç†ç³»ç»Ÿæ¶ˆæ¯
            if (message.sender === 'system') {
                // ğŸ”¥ã€ä¿®å¤ã€‘å¤„ç†æ‹‰é»‘ç³»ç»Ÿæ¶ˆæ¯ - æ˜¾ç¤ºä¸ºå±…ä¸­çš„ç³»ç»Ÿæç¤º
                if (message.isBlockedMessage) {
                    const centerContainer = document.createElement('div');
                    centerContainer.style.display = 'flex';
                    centerContainer.style.justifyContent = 'center';
                    centerContainer.style.margin = '4px 0';
                    centerContainer.dataset.messageId = message.id;

                    const systemContainer = document.createElement('div');
                    systemContainer.className = 'system-message';
                    systemContainer.textContent = message.content || 'æ¶ˆæ¯å·²å‘å‡ºï¼Œä½†è¢«å¯¹æ–¹æ‹’æ”¶äº†';

                    centerContainer.appendChild(systemContainer);
                    messagesContainer.insertBefore(centerContainer, typingIndicator);
                    return;
                }

                let systemElement;

                if (message.isPoke) {
                    const systemContainer = document.createElement('div');
                    systemContainer.className = 'poke-system-container';
                    const systemMessage = document.createElement('div');
                    systemMessage.className = 'poke-system-message';
                    systemMessage.textContent = message.content;
                    systemContainer.appendChild(systemMessage);
                    systemElement = systemContainer;
                } else if (message.type === 'recalled_message') {
                    const centerContainer = document.createElement('div');
                    centerContainer.style.display = 'flex';
                    centerContainer.style.justifyContent = 'center';
                    centerContainer.style.margin = '4px 0';
                    centerContainer.dataset.messageId = message.id;
                    
                    const recallElement = document.createElement('div');
                    recallElement.className = 'recalled-message';
                    
                    const lines = message.content.split('\n');
                    const mainText = lines[0];
                    const originalText = lines[1];
                    
                    recallElement.textContent = mainText;
                    
                    if (originalText && originalText.startsWith('åŸæ–‡ï¼š')) {
                        const originalDiv = document.createElement('div');
                        originalDiv.className = 'original-text';
                        originalDiv.textContent = originalText;
                        recallElement.appendChild(originalDiv);
                    }
                    
                    centerContainer.appendChild(recallElement);
                    systemElement = centerContainer;
                    addMessageLongPressListener(centerContainer, message.id);
                } else {
                    const centerContainer = document.createElement('div');
                    centerContainer.style.display = 'flex';
                    centerContainer.style.justifyContent = 'center';
                    centerContainer.style.margin = '4px 0';
                    
                    const systemContainer = document.createElement('div');
                    // ğŸ”¥ã€ç¾åŒ–ã€‘æ£€æŸ¥æ˜¯å¦ä¸ºå¥½å‹æ·»åŠ æˆåŠŸæ¶ˆæ¯ï¼Œåº”ç”¨ç‰¹æ®Šæ ·å¼
                    if (message.isFriendAddedMessage) {
                        systemContainer.className = 'friend-added-system-message';
                    } else {
                        systemContainer.className = 'system-message';
                    }
                    systemContainer.textContent = message.content;
                    
                    centerContainer.appendChild(systemContainer);
                    systemElement = centerContainer;
                }
                
                // ä¸ºç³»ç»Ÿæ¶ˆæ¯æ·»åŠ æ»‘å…¥åŠ¨ç”»
                systemElement.style.opacity = '0';
                systemElement.style.transform = 'translateY(20px)';
                
                messagesContainer.insertBefore(systemElement, typingIndicator);
                
                // è§¦å‘åŠ¨ç”»
                requestAnimationFrame(() => {
                    systemElement.classList.add('message-slide-in');
                });
                
                return;
            }
            
            // åˆ›å»ºæ™®é€šæ¶ˆæ¯å®¹å™¨
            let messageContainer = document.createElement('div');
            const isEmojiOnly = message.isEmoji && !message.content;
            messageContainer.className = `message-container ${message.sender}${chatSettings.hideAvatars ? ' no-avatar' : ''}${isEmojiOnly ? ' emoji-only' : ''}`;
            messageContainer.dataset.messageId = message.id;
            
            if (message.sender === 'received') {
                // ==== ç¾¤èŠæ”¯æŒ ====
                let character = characters.find(c => c.id === characterId);
                let isGroup = false;
                let group = null;
                if (!character) {
                    group = groupChats.find(g => g.id === characterId);
                    if (group) {
                        isGroup = true;
                    }
                }
                
                let displayAvatar = '';
                let displayName = '';
                let color = '#4CAF50';
                
                if (isGroup && group) {
                    // ç¾¤èŠï¼šæ ¹æ®æ¶ˆæ¯çš„senderIdæˆ–nameæŸ¥æ‰¾æˆå‘˜
                    let member = null;
                    console.log('ğŸ” [addMessageWithAnimation] ç¾¤èŠæ¶ˆæ¯å¤„ç† - senderId:', message.senderId, 'name:', message.name);
                    console.log('ğŸ” [addMessageWithAnimation] ç¾¤æˆå‘˜åˆ—è¡¨:', group.members);
                    console.log('ğŸ” [addMessageWithAnimation] å®Œæ•´æ¶ˆæ¯å¯¹è±¡:', message);

                    // ğŸ”¥ã€è°ƒè¯•ã€‘ç‰¹åˆ«æ£€æŸ¥è¡¨æƒ…åŒ…æ¶ˆæ¯
                    if (message.isEmoji) {
                        console.log('ğŸ” [addMessageWithAnimation-è¡¨æƒ…åŒ…] æ£€æµ‹åˆ°è¡¨æƒ…åŒ…æ¶ˆæ¯:', {
                            senderId: message.senderId,
                            name: message.name,
                            image: message.image,
                            emojiDescription: message.emojiDescription
                        });
                    }

                    if (message.senderId) {
                        member = group.members.find(m => m.id === message.senderId);
                        console.log('ğŸ” [addMessageWithAnimation] é€šè¿‡senderIdæ‰¾åˆ°æˆå‘˜:', member);
                    } else if (message.name) {
                        member = group.members.find(m => m.name === message.name);
                        console.log('ğŸ” [addMessageWithAnimation] é€šè¿‡nameæ‰¾åˆ°æˆå‘˜:', member);
                    }

                    // ğŸ”¥ã€ä¿®å¤ã€‘ç¡®ä¿ç¾¤èŠè¡¨æƒ…åŒ…æ¶ˆæ¯æ­£ç¡®æ˜¾ç¤ºå‘é€è€…ï¼ˆaddMessageWithAnimationç‰ˆæœ¬ï¼‰
                    if (member) {
                        displayAvatar = member.avatarUrl || '';
                        displayName = member.name;
                        color = member.color || '#4CAF50';
                    } else {
                        // å¦‚æœæ²¡æ‰¾åˆ°æˆå‘˜ï¼Œä½¿ç”¨æ¶ˆæ¯ä¸­çš„nameä½œä¸ºæ˜¾ç¤ºåç§°
                        displayAvatar = '';
                        displayName = message.name || 'ç¾¤æˆå‘˜';
                        color = '#4CAF50';
                        console.warn('ğŸ” [addMessageWithAnimation] æœªæ‰¾åˆ°ç¾¤æˆå‘˜ï¼Œä½¿ç”¨æ¶ˆæ¯name:', message.name);
                    }

                    console.log('ğŸ” [addMessageWithAnimation] æœ€ç»ˆå¤´åƒ:', displayAvatar, 'æ˜¾ç¤ºå:', displayName);
                } else if (character) {
                    // å•èŠ
                    displayAvatar = chatSettings.aiDynamicAvatar || chatSettings.aiChatAvatar || character.avatarUrl;
                    displayName = chatSettings.aiChatNickname || character.name;
                    color = character.color || '#4CAF50';
                } else {
                    // å…œåº•ï¼Œé˜²æ­¢æŠ¥é”™
                    displayAvatar = '';
                    displayName = 'æœªçŸ¥';
                    color = '#4CAF50';
                }
                
                // ğŸ”¥ã€æ–°å¢ã€‘è·å–æ°”æ³¡æ ·å¼ - ç¾¤èŠä¸­ä½¿ç”¨æˆå‘˜ä¸“å±é¢œè‰²
                let bubbleColor = chatSettings.aiBubbleColor || '#f0f0f0';
                
                // å¦‚æœæ˜¯ç¾¤èŠä¸”æœ‰æˆå‘˜ä¸“å±é¢œè‰²è®¾ç½®ï¼Œä½¿ç”¨æˆå‘˜ä¸“å±é¢œè‰²
                if (isGroup && group && message.senderId && chatSettings.memberBubbleColors) {
                    const memberColor = chatSettings.memberBubbleColors[message.senderId];
                    if (memberColor) {
                        bubbleColor = memberColor;
                    }
                }
                
                const bubbleOpacity = chatSettings.aiBubbleOpacity || '1';
                const textColor = isLightColor(bubbleColor) ? '#333' : '#fff';
                const bubblePadding = chatSettings.bubblePadding || '12';
                
                // å¤„ç†ç‰¹æ®Šæ¶ˆæ¯ç±»å‹
                let messageContent = '';

                if (message.type === 'voice_message') {
                    // AIè¯­éŸ³æ¶ˆæ¯ç›´æ¥åˆ›å»ºvoice-message-containerç»“æ„ï¼Œä¸éœ€è¦åœ¨è¿™é‡Œåˆ›å»ºmessageContent
                    messageContent = '';
                } else if (message.type === 'user_photo') {
                    // ğŸ”¥ã€ä¿®å¤ã€‘è§’è‰²å‘é€çš„"ä¼ªç…§ç‰‡" - ä½¿ç”¨ä¸ç”¨æˆ·ç›¸åŒçš„ç»“æ„
                    const photoDesc = message.photoDescription || message.content || 'è§’è‰²å‘é€çš„ç…§ç‰‡';
                    messageContent = `
                        <div class="dreamy-photo-container" onclick="togglePhotoText(this, '${photoDesc.replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')">
                            <div class="dreamy-photo">
                                <div class="photo-misty-bg"></div>
                                <div class="photo-badge">
                                    <i class="fas fa-image"></i>
                                </div>
                                <div class="sparkle-container">
                                    <div class="sparkle sparkle-1">âœ¨</div>
                                    <div class="sparkle sparkle-2">â­</div>
                                    <div class="sparkle sparkle-3">âœ¨</div>
                                    <div class="sparkle sparkle-4">â­</div>
                                    <div class="sparkle sparkle-5">ğŸ’«</div>
                                </div>
                                <div class="photo-text-overlay" style="display: none;">
                                    <div class="photo-description">${photoDesc}</div>
                                </div>
                            </div>
                        </div>
                    `;
                } else if (message.type === 'ai_image') {
                    // AIç”Ÿæˆçš„å›¾ç‰‡ - ä½¿ç”¨æ˜Ÿæ˜Ÿemojiå¡ç‰‡æ ·å¼
                    const imageDesc = message.imageDescription || message.content || 'AIæè¿°çš„å›¾ç‰‡';
                    messageContent = `
                        <div class="dreamy-photo-container" onclick="togglePhotoText(this, '${imageDesc.replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')">
                            <div class="dreamy-photo">
                                <div class="photo-misty-bg"></div>
                                <div class="photo-badge">
                                    <i class="fas fa-image"></i>
                                </div>
                                <div class="sparkle-container">
                                    <div class="sparkle sparkle-1">âœ¨</div>
                                    <div class="sparkle sparkle-2">â­</div>
                                    <div class="sparkle sparkle-3">âœ¨</div>
                                    <div class="sparkle sparkle-4">â­</div>
                                    <div class="sparkle sparkle-5">ğŸ’«</div>
                                </div>
                                <div class="photo-text-overlay" style="display: none;">
                                    <div class="photo-description">${imageDesc}</div>
                                </div>
                            </div>
                        </div>
                    `;
                } else if (message.type === 'location') {
                    // ğŸ”¥ã€ä¿®å¤ã€‘è§’è‰²å‘é€çš„ä½ç½®æ¶ˆæ¯ - ä½¿ç”¨ä¸ç”¨æˆ·ç›¸åŒçš„ç»“æ„
                    const locationName = message.locationName || message.name || 'æœªçŸ¥ä½ç½®';
                    messageContent = `
                        <div class="location-card" onclick="showLocationDetail('${locationName}')">
                            <div class="location-card-header">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
                                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                </svg>
                                ${locationName}
                            </div>
                            <div class="location-card-map">
                                <div class="map-background"></div>
                                <div class="map-roads">
                                    <div class="road road-horizontal" style="top: 35%; width: 100%;"></div>
                                    <div class="road road-vertical" style="left: 40%; height: 100%;"></div>
                                    <div class="road road-horizontal" style="top: 65%; width: 70%; left: 30%;"></div>
                                </div>
                                <div class="map-buildings">
                                    <div class="building" style="top: 20%; left: 10%; width: 15px; height: 15px;"></div>
                                    <div class="building" style="top: 45%; left: 60%; width: 12px; height: 12px;"></div>
                                    <div class="building" style="top: 70%; left: 15%; width: 18px; height: 18px;"></div>
                                </div>
                                <div class="map-marker" style="top: 50%; left: 50%;"></div>
                            </div>
                        </div>
                    `;
                } else if (message.type === 'transfer') {
                    // è½¬è´¦æ¶ˆæ¯
                    const isUser = message.role === 'user';
                    const heartIcon = isUser ? 'ğŸ’•' : 'ğŸ’–';
                    const titleText = isUser ? 'ä½ å‘èµ·çš„è½¬è´¦' : 'æ”¶åˆ°è½¬è´¦';
                    let cardClass = '';
                    let statusHtml = '';
                    let clickHandler = '';

                    if (message.status === 'accepted') {
                        statusHtml = `<div class="transfer-status">${isUser ? 'å¯¹æ–¹å·²æ”¶æ¬¾' : 'å·²æ”¶æ¬¾'}</div>`;
                        cardClass = 'accepted';
                    } else if (message.status === 'rejected') {
                        statusHtml = `<div class="transfer-status">${isUser ? 'å¯¹æ–¹å·²é€€å›' : 'å·²é€€å›'}</div>`;
                        cardClass = 'rejected';
                    } else if (!isUser) {
                        // AIå‘æ¥çš„è½¬è´¦ä¸”æœªå¤„ç†ï¼Œæ·»åŠ ç‚¹å‡»å¤„ç†
                        clickHandler = `onclick="showTransferConfirmDialog(${JSON.stringify(message).replace(/"/g, '&quot;')})"`;
                    }

                    messageContent = `
                        <div class="transfer-message-container received">
                            <div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}" ${clickHandler}>
                                <div class="transfer-title">${heartIcon} ${titleText}</div>
                                <div class="transfer-amount">Â¥ ${Number(message.amount).toFixed(2)}</div>
                                <div class="transfer-note">${message.note || 'è½¬è´¦'}</div>
                                ${statusHtml}
                            </div>
                        </div>
                    `;
                } else if (message.type === 'friend_request') {
                    // ğŸ”¥ã€æ–°å¢ã€‘AIä¸»åŠ¨å‘é€çš„å¥½å‹ç”³è¯·(ç¬¬ä¸‰å¤„)
                    messageContent = `
                        <div class="friend-request-container">
                            <div class="friend-request-card">
                                <div class="friend-request-icon">ğŸ‘‹</div>
                                <div class="friend-request-title">å¥½å‹ç”³è¯·</div>
                                <div class="friend-request-message">${message.message || 'æƒ³å’Œä½ é‡æ–°åšæœ‹å‹'}</div>
                                <div class="friend-request-actions">
                                    <button class="friend-request-btn accept" onclick="handleAIFriendRequest('${currentChatCharacter?.id}', true, '${message.id}')">åŒæ„</button>
                                    <button class="friend-request-btn reject" onclick="handleAIFriendRequest('${currentChatCharacter?.id}', false, '${message.id}')">æ‹’ç»</button>
                                </div>
                            </div>
                        </div>
                    `;
                } else {
                    const chatMode = chatSettings.chatMode || 'online';
                    let processedContent = message.content;
                    
                    if (chatMode === 'offline') {
                        processedContent = processOfflineContent(message.content);
                    }
                    
                    // å¦‚æœæœ‰å¼•ç”¨æ¶ˆæ¯ï¼Œåœ¨å†…å®¹å‰æ·»åŠ å¼•ç”¨æ˜¾ç¤º
                    if (message.replyTo) {
                        messageContent = generateReplyHTML(message.replyTo) + processedContent;
                    } else {
                    messageContent = processedContent;
                    }
                }
                
                let avatarHtml = '';
                if (!chatSettings.hideAvatars) {
                    avatarHtml = `
                        <div class="message-avatar" style="background-color: ${color}; ${displayAvatar ? `background-image: url(${displayAvatar}); background-size: cover; background-position: center;` : ''}" ${character ? `onclick="pokeCharacter('${character.id}')" title="æˆ³ä¸€æˆ³"` : `title="${displayName}"`}>
                            ${displayAvatar ? '' : displayName.charAt(0)}
                        </div>
                    `;
                }
                
                const transparentBubbleColor = convertColorWithOpacity(bubbleColor, bubbleOpacity);
                
                let bubbleHtml = '';
                if (message.type === 'transfer' || message.type === 'ai_image' || message.type === 'user_photo' || message.type === 'location' || message.type === 'voice_message' || message.type === 'friend_request') {
                    // è½¬è´¦æ¶ˆæ¯ã€AIå›¾ç‰‡æ¶ˆæ¯ã€ç…§ç‰‡å¡ç‰‡ã€ä½ç½®ä¿¡æ¯å’Œè¯­éŸ³æ¶ˆæ¯ä¸éœ€è¦æ°”æ³¡åŒ…è£¹
                    bubbleHtml = messageContent;
                } else {
                    // æ™®é€šæ¶ˆæ¯ç”¨æ°”æ³¡åŒ…è£¹
                    bubbleHtml = `
                    <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                        ${messageContent}
                        ${message.image && (!message.type || message.isEmoji) ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}
                        ${message.edited ? `<div class="message-edited-indicator">å·²ç¼–è¾‘</div>` : ''}
                    </div>
                `;
                }
                
          // ğŸ”¥ã€ä¿®å¤ã€‘ç¾¤èŠæ˜µç§°æ˜¾ç¤º ï¼ˆç¬¬ä¸‰ä¸ªæ¸²æŸ“å‡½æ•°ç‰ˆæœ¬ï¼‰- ç‰¹åˆ«å¤„ç†è¯­éŸ³æ¶ˆæ¯ã€è½¬è´¦æ¶ˆæ¯ã€ç…§ç‰‡å¡ç‰‡å’Œä½ç½®ä¿¡æ¯
          if (isGroup && group && displayName !== 'ç¾¤æˆå‘˜') {
    messageContainer.classList.add('group-message-item');
    const senderNameHtml = `<div class="sender-name">${displayName}</div>`;

    if (message.type === 'voice_message' || message.type === 'transfer' || message.type === 'ai_image' || message.type === 'user_photo' || message.type === 'location' || message.type === 'friend_request') {
        // ğŸ”¥ã€ä¿®å¤ã€‘å¯¹äºè¯­éŸ³æ¶ˆæ¯ã€è½¬è´¦æ¶ˆæ¯ã€AIå›¾ç‰‡æ¶ˆæ¯ã€ç…§ç‰‡å¡ç‰‡å’Œä½ç½®ä¿¡æ¯ï¼Œæ˜µç§°éœ€è¦åœ¨å®¹å™¨å¤–éƒ¨
    messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    } else {
        // æ™®é€šæ¶ˆæ¯çš„å¤„ç†ï¼ˆåŒ…æ‹¬è¡¨æƒ…åŒ…æ¶ˆæ¯ï¼‰
        messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    }
} else {
                messageContainer.innerHTML = avatarHtml + bubbleHtml;
}
                
                // ğŸ”¥ã€ä¿®å¤ã€‘å¦‚æœæ˜¯è¯­éŸ³æ¶ˆæ¯ï¼ŒæŒ‰ç…§renderChatMessagesçš„ç»“æ„åˆ›å»ºï¼Œä½†è¦ä¿ç•™ç¾¤èŠæ˜µç§°
                if (message.type === 'voice_message') {
                    // è¿‡æ»¤æ‰æ‹¬å·ä¸­çš„æè¿°æ€§å†…å®¹ï¼Œä¿ç•™å®é™…è¯´è¯å†…å®¹
                    const cleanVoiceContent = message.content.replace(/\([^)]*\)\s*/g, '').trim();
                    const duration = message.duration || Math.max(1, Math.ceil(cleanVoiceContent.length / 8));
                    const durationFormatted = duration < 60 ? `0:${String(duration).padStart(2, '0')}''` : `${Math.floor(duration/60)}:${String(duration%60).padStart(2, '0')}''`;
                    
                    const voiceMessageHTML = `
                        <div class="voice-message-container received">
                            <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                                <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${cleanVoiceContent}">
                                    <div class="voice-wave">
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                    </div>
                                    <div class="voice-duration">${durationFormatted}</div>
                                    ${message.edited ? `<div class="message-edited-indicator">å·²ç¼–è¾‘</div>` : ""}
                                </div>
                            </div>
                            <div class="voice-text-content">${cleanVoiceContent}</div>
                        </div>
                    `;
                    
                    // ğŸ”¥ã€ä¿®å¤ã€‘ä¿ç•™ç¾¤èŠæ˜µç§°æ˜¾ç¤º
                    if (isGroup && group && displayName !== 'ç¾¤æˆå‘˜') {
                        const senderNameHtml = `<div class="sender-name">${displayName}</div>`;
                        messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${voiceMessageHTML}</div>`;
                    } else {
                    messageContainer.innerHTML = avatarHtml + voiceMessageHTML;
                    }
                }
            } else {
                // ç”¨æˆ·æ¶ˆæ¯
                let myDisplayAvatar = chatSettings.myChatAvatar;
                
                if (!myDisplayAvatar && chatSettings.selectedIdentityId) {
                    const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                    if (selectedPersona && selectedPersona.avatarUrl) {
                        myDisplayAvatar = selectedPersona.avatarUrl;
                    }
                }
                
                const myBubbleColor = chatSettings.myBubbleColor || '#007AFF';
                const myBubbleOpacity = chatSettings.myBubbleOpacity || '1';
                const myTextColor = isLightColor(myBubbleColor) ? '#333' : '#fff';
                const myBubblePadding = chatSettings.bubblePadding || '12';
                
                const transparentMyBubbleColor = convertColorWithOpacity(myBubbleColor, myBubbleOpacity);
                
                let myBubbleHtml = '';
                if (message.type === 'voice') {
                    const duration = message.duration || Math.max(1, Math.ceil(message.content.length / 8));
                    
                    myBubbleHtml = `
                        <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                            <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${message.content}">
                                <div class="voice-wave">
                                    <div class="wave-bar"></div>
                                    <div class="wave-bar"></div>
                                    <div class="wave-bar"></div>
                                    <div class="wave-bar"></div>
                                    <div class="wave-bar"></div>
                                </div>
                                <div class="voice-duration">${duration}"</div>
                            ${message.edited ? `<div class="message-edited-indicator">å·²ç¼–è¾‘</div>` : ""}
                            </div>
                        </div>
                    `;
                } else if (message.type === 'location') {
                    // ä½ç½®æ¶ˆæ¯
                    myBubbleHtml = `
                        <div class="location-card" onclick="showLocationDetail('${message.locationName}')">
                            <div class="location-title">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
                                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                </svg>
                                ${message.locationName}
                            </div>
                            <div class="location-card-map">
                                ${generateRealisticMapHTML()}
                            </div>
                        </div>
                    `;
                } else if (message.type === 'transfer') {
                    // ç”¨æˆ·è½¬è´¦æ¶ˆæ¯
                    let cardClass = '';
                    let statusHtml = '';
                    
                    if (message.status === 'accepted') {
                        statusHtml = `<div class="transfer-status">å¯¹æ–¹å·²æ”¶æ¬¾</div>`;
                        cardClass = 'accepted';
                    } else if (message.status === 'rejected') {
                        statusHtml = `<div class="transfer-status">å¯¹æ–¹å·²é€€å›</div>`;
                        cardClass = 'rejected';
                    }
                    
                    myBubbleHtml = `
                        <div class="transfer-message-container sent">
                            <div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}">
                                <div class="transfer-title">ğŸ’• ä½ å‘èµ·çš„è½¬è´¦</div>
                                <div class="transfer-amount">Â¥ ${Number(message.amount).toFixed(2)}</div>
                                <div class="transfer-note">${message.note || 'è½¬è´¦'}</div>
                                ${statusHtml}
                            </div>
                        </div>
                    `;
                } else if (message.type === 'friend_request') {
                    // ğŸ”¥ã€æ–°å¢ã€‘ç”¨æˆ·å‘é€çš„å¥½å‹ç”³è¯·(ç¦»çº¿æ¨¡å¼)
                    myBubbleHtml = `
                        <div class="friend-request-container">
                            <div class="friend-request-card">
                                <div class="friend-request-icon">ğŸ‘‹</div>
                                <div class="friend-request-title">å¥½å‹ç”³è¯·</div>
                                <div class="friend-request-message">${message.message || 'æƒ³å’Œä½ é‡æ–°åšæœ‹å‹'}</div>
                                <div class="friend-request-status">å·²å‘é€</div>
                            </div>
                        </div>
                    `;
                } else {
                    // ğŸ”¥ã€ä¿®å¤ã€‘å¤„ç†å¤šæ¨¡æ€æ¶ˆæ¯æˆ–æ™®é€šæ–‡æœ¬æ¶ˆæ¯ (ç¬¬ä¸‰ä¸ªæ¸²æŸ“å‡½æ•°ç‰ˆæœ¬)
                    let messageContentStr = '';
                    if (Array.isArray(message.content)) {
                        // æ–°çš„å¤šæ¨¡æ€æ ¼å¼
                        const textPart = message.content.find(p => p.type === 'text');
                        const imagePart = message.content.find(p => p.type === 'image_url');

                        let baseContent = textPart?.text || '';

                        // å¦‚æœæœ‰å¼•ç”¨æ¶ˆæ¯ï¼Œåœ¨å†…å®¹å‰æ·»åŠ å¼•ç”¨æ˜¾ç¤º
                        if (message.replyTo) {
                            messageContentStr = generateReplyHTML(message.replyTo) + baseContent;
                        } else {
                            messageContentStr = baseContent;
                        }

                        // å¦‚æœæœ‰å›¾ç‰‡ï¼Œæ·»åŠ å›¾ç‰‡æ˜¾ç¤º
                        if (imagePart?.image_url?.url) {
                            if (messageContentStr) {
                                messageContentStr += '<br>';
                            }
                            messageContentStr += `<img src="${imagePart.image_url.url}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${imagePart.image_url.url}')">`;
                        }
                    } else {
                        // æ™®é€šæ–‡æœ¬æ¶ˆæ¯æˆ–æ—§æ ¼å¼
                        let baseContent = message.content;

                        // å¦‚æœæœ‰å¼•ç”¨æ¶ˆæ¯ï¼Œåœ¨å†…å®¹å‰æ·»åŠ å¼•ç”¨æ˜¾ç¤º
                        if (message.replyTo) {
                            messageContentStr = generateReplyHTML(message.replyTo) + baseContent;
                        } else {
                            messageContentStr = baseContent;
                        }
                    }
                    
                    myBubbleHtml = `
                    <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                        ${messageContentStr}
                        ${message.image && !Array.isArray(message.content) ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}
                    </div>
                `;
                }
                
                let myAvatarHtml = '';
                if (!chatSettings.hideAvatars) {
                    myAvatarHtml = `
                        <div class="message-avatar" style="background-color: #007AFF; ${myDisplayAvatar ? `background-image: url(${myDisplayAvatar}); background-size: cover; background-position: center;` : ''}">
                            ${myDisplayAvatar ? '' : '<i class="fas fa-user"></i>'}
                        </div>
                    `;
                }
                
                messageContainer.innerHTML = myBubbleHtml + myAvatarHtml;
                
                // å¦‚æœæ˜¯è¯­éŸ³æ¶ˆæ¯ï¼ŒæŒ‰ç…§renderChatMessagesçš„ç»“æ„åˆ›å»º
                if (message.type === 'voice') {
                    // åˆ›å»ºå®Œæ•´çš„è¯­éŸ³æ¶ˆæ¯HTMLï¼Œå’ŒrenderChatMessagesä¿æŒä¸€è‡´
                    const voiceMessageHTML = `
                        <div class="voice-message-container sent">
                            <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                                <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${message.content}">
                                    <div class="voice-wave">
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                    </div>
                                    <div class="voice-duration">${message.duration || Math.max(1, Math.ceil(message.content.length / 8))}"</div>
                                    ${message.edited ? `<div class="message-edited-indicator">å·²ç¼–è¾‘</div>` : ""}
                                </div>
                            </div>
                            <div class="voice-text-content">${message.content}</div>
                        </div>
                    `;
                    
                    messageContainer.innerHTML = voiceMessageHTML + myAvatarHtml;
                }
                
                // å¦‚æœæ˜¯ä½ç½®æ¶ˆæ¯ï¼ŒæŒ‰ç…§renderChatMessagesçš„ç»“æ„åˆ›å»º
                if (message.type === 'location') {
                    // åˆ›å»ºå®Œæ•´çš„ä½ç½®æ¶ˆæ¯HTMLï¼Œç¡®ä¿ä¸è¢«åŒ…è£…åœ¨æ°”æ³¡ä¸­
                    const locationMessageHTML = `
                        <div class="location-card" onclick="showLocationDetail('${message.locationName}')">
                            <div class="location-title">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
                                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                </svg>
                                ${message.locationName}
                            </div>
                            <div class="location-card-map">
                                ${generateRealisticMapHTML()}
                            </div>
                        </div>
                    `;
                    
                    messageContainer.innerHTML = locationMessageHTML + myAvatarHtml;
                }
            }
            
            // æ·»åŠ æ»‘å…¥åŠ¨ç”»æ•ˆæœ - ç®€å•è‡ªç„¶çš„æ»‘å…¥
            messageContainer.style.opacity = '0';
            messageContainer.style.transform = 'translateY(20px)';
            
            messagesContainer.insertBefore(messageContainer, typingIndicator);
            
            // è§¦å‘æ»‘å…¥åŠ¨ç”»
            requestAnimationFrame(() => {
                messageContainer.classList.add('message-slide-in');
            });
            
            // ğŸ”¥ã€æ–°å¢ã€‘æ£€æŸ¥æ‹‰é»‘çŠ¶æ€å¹¶æ·»åŠ æŒ‡ç¤ºå™¨
            addBlockedIndicatorToMessage(messageContainer, message, characterId);

            // æ·»åŠ é•¿æŒ‰ç›‘å¬å™¨
            addMessageLongPressListener(messageContainer, message.id);

            // æ·»åŠ å³é”®èœå•åŠŸèƒ½
            const bubble = messageContainer.querySelector('.message-bubble');
            if (bubble) {
                bubble.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showMessageMenu(message.id, e);
                });

                bubble.onclick = (e) => {
                    if (e.target.tagName === 'IMG' && e.target.classList.contains('message-image')) {
                        showImage(e.target.src);
                    }
                };
            }
            
            // ğŸ”¥ã€æ–°å¢ã€‘å¦‚æœæ˜¯AIæ¶ˆæ¯ï¼Œè°ƒæ•´å¿ƒç‡
            if (message.sender === 'received' && typeof message.content === 'string') {
                adjustHeartrateForMessage(message.content, false);
            }
            
            // æ»šåŠ¨åˆ°åº•éƒ¨
            setTimeout(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }, 100);
        }
        
        // å°†é¢œè‰²å’Œé€æ˜åº¦è½¬æ¢ä¸ºrgbaæ ¼å¼
        function convertColorWithOpacity(color, opacity) {
            // æ£€æŸ¥å‚æ•°æœ‰æ•ˆæ€§
            if (!color || typeof color !== 'string') {
                return 'rgba(0, 0, 0, 0)'; // è¿”å›é€æ˜é»‘è‰²ä½œä¸ºé»˜è®¤å€¼
            }

            // å¦‚æœé¢œè‰²å·²ç»æ˜¯rgbaæ ¼å¼ï¼Œç›´æ¥è¿”å›
            if (color.startsWith('rgba')) {
                return color;
            }
            
            // å¦‚æœæ˜¯åå…­è¿›åˆ¶é¢œè‰²ï¼Œè½¬æ¢ä¸ºrgba
            if (color.startsWith('#')) {
                const hex = color.slice(1);
                const r = parseInt(hex.substring(0, 2), 16);
                const g = parseInt(hex.substring(2, 4), 16);
                const b = parseInt(hex.substring(4, 6), 16);
                return `rgba(${r}, ${g}, ${b}, ${opacity})`;
            }
            
            // å¦‚æœæ˜¯rgbæ ¼å¼ï¼Œè½¬æ¢ä¸ºrgba
            if (color.startsWith('rgb(')) {
                const rgbValues = color.match(/\d+/g);
                return `rgba(${rgbValues[0]}, ${rgbValues[1]}, ${rgbValues[2]}, ${opacity})`;
            }
            
            // å¦‚æœæ˜¯é¢œè‰²åç§°ï¼Œå°è¯•è½¬æ¢ï¼ˆç®€å•å®ç°ï¼‰
            const colorMap = {
                'red': '255, 0, 0',
                'green': '0, 128, 0',
                'blue': '0, 0, 255',
                'white': '255, 255, 255',
                'black': '0, 0, 0',
                'gray': '128, 128, 128',
                'yellow': '255, 255, 0',
                'cyan': '0, 255, 255',
                'magenta': '255, 0, 255'
            };
            
            if (colorMap[color.toLowerCase()]) {
                return `rgba(${colorMap[color.toLowerCase()]}, ${opacity})`;
            }
            
            // å¦‚æœæ— æ³•è¯†åˆ«ï¼Œè¿”å›åŸè‰²åŠ é€æ˜åº¦ï¼ˆä½œä¸ºå¤‡ç”¨ï¼‰
            return color;
        }

        // å­—ä½“å¤§å°è®¾ç½®åŠŸèƒ½
        function changeFontSize(size) {
            const fontSize = parseInt(size);
            
            // æ›´æ–°é¢„è§ˆæ–‡å­—
            const preview = document.getElementById('font-size-preview');
            const valueDisplay = document.getElementById('font-size-value');
            
            if (preview) {
                preview.style.fontSize = fontSize + 'px';
            }
            
            if (valueDisplay) {
                valueDisplay.textContent = fontSize + 'px';
            }
            
            // åˆ›å»ºæˆ–æ›´æ–°å…¨å±€å­—ä½“å¤§å°CSSå˜é‡
            document.documentElement.style.setProperty('--global-font-size', fontSize + 'px');
            
            // åº”ç”¨åˆ°èŠå¤©æ¶ˆæ¯
            applyFontSizeToMessages(fontSize);
            
            // åº”ç”¨åˆ°ç¤¾äº¤åŠ¨æ€
            applyFontSizeToMoments(fontSize);
            
            // å¦‚æœå½“å‰æœ‰èŠå¤©è§’è‰²ï¼Œé‡æ–°æ¸²æŸ“æ¶ˆæ¯ä»¥ç¡®ä¿æ–°å­—ä½“å¤§å°ç”Ÿæ•ˆ
            if (currentChatCharacter && typeof renderChatMessages === 'function') {
                setTimeout(() => {
                    renderChatMessages(currentChatCharacter.id);
                }, 100);
            }
            
            // ä¿å­˜è®¾ç½®
            localStorage.setItem('globalFontSize', fontSize);
            
            // æ˜¾ç¤ºæˆåŠŸæç¤º
            showToast('å­—å·è®¾ç½®å·²ä¿å­˜å¹¶åº”ç”¨ï¼', 'success');
        }
        
        // å­—è·è®¾ç½®åŠŸèƒ½
        function changeLetterSpacing(spacing) {
            const letterSpacing = parseFloat(spacing);
            
            // æ›´æ–°é¢„è§ˆæ–‡å­—
            const preview = document.getElementById('font-size-preview');
            const valueDisplay = document.getElementById('letter-spacing-value');
            
            if (preview) {
                preview.style.letterSpacing = letterSpacing + 'px';
            }
            
            if (valueDisplay) {
                // æ ¹æ®æ•°å€¼æ˜¾ç¤ºå¯¹åº”çš„æ–‡å­—æè¿°
                let description;
                if (letterSpacing < -0.2) {
                    description = 'å¾ˆç´§å‡‘';
                } else if (letterSpacing < 0.2) {
                    description = 'æ ‡å‡†';
                } else if (letterSpacing < 0.8) {
                    description = 'èˆ’é€‚';
                } else if (letterSpacing < 1.5) {
                    description = 'å®½æ¾';
                } else {
                    description = 'å¾ˆå®½æ¾';
                }
                valueDisplay.textContent = `${description} (${letterSpacing}px)`;
            }
            
            // åˆ›å»ºæˆ–æ›´æ–°å…¨å±€å­—è·CSSå˜é‡
            document.documentElement.style.setProperty('--global-letter-spacing', letterSpacing + 'px');
            
            // åº”ç”¨åˆ°èŠå¤©æ¶ˆæ¯
            applyLetterSpacingToMessages(letterSpacing);
            
            // åº”ç”¨åˆ°ç¤¾äº¤åŠ¨æ€
            applyLetterSpacingToMoments(letterSpacing);
            
            // å¦‚æœå½“å‰æœ‰èŠå¤©è§’è‰²ï¼Œé‡æ–°æ¸²æŸ“æ¶ˆæ¯ä»¥ç¡®ä¿æ–°å­—è·ç”Ÿæ•ˆ
            if (currentChatCharacter && typeof renderChatMessages === 'function') {
                setTimeout(() => {
                    renderChatMessages(currentChatCharacter.id);
                }, 100);
            }
            
            // ä¿å­˜è®¾ç½®
            localStorage.setItem('globalLetterSpacing', letterSpacing);
            
            // æ˜¾ç¤ºæˆåŠŸæç¤º
            showToast('å­—è·è®¾ç½®å·²ä¿å­˜å¹¶åº”ç”¨ï¼', 'success');
        }
        
        function applyFontSizeToMessages(fontSize) {
            // åº”ç”¨åˆ°æ‰€æœ‰èŠå¤©æ¶ˆæ¯ï¼Œä½¿ç”¨!importantå¼ºåˆ¶è¦†ç›–å†…è”æ ·å¼
            const messageBubbles = document.querySelectorAll('.message-bubble');
            messageBubbles.forEach(bubble => {
                bubble.style.setProperty('font-size', fontSize + 'px', 'important');
            });
            
            // åº”ç”¨åˆ°èŠå¤©è¾“å…¥æ¡†
            const chatInput = document.getElementById('api-chat-input');
            if (chatInput) {
                chatInput.style.fontSize = fontSize + 'px';
            }
        }
        
        function applyFontSizeToMoments(fontSize) {
            // åº”ç”¨åˆ°å¾®åšåŠ¨æ€å†…å®¹
            const postContents = document.querySelectorAll('.post-content');
            postContents.forEach(content => {
                content.style.fontSize = fontSize + 'px';
            });
            
            // åº”ç”¨åˆ°å¾®åšè¾“å…¥æ¡†
            const weiboTextarea = document.getElementById('weibo-text');
            if (weiboTextarea) {
                weiboTextarea.style.fontSize = fontSize + 'px';
            }
        }
        
        function applyLetterSpacingToMessages(letterSpacing) {
            // åº”ç”¨åˆ°æ‰€æœ‰èŠå¤©æ¶ˆæ¯
            const messageBubbles = document.querySelectorAll('.message-bubble');
            messageBubbles.forEach(bubble => {
                bubble.style.setProperty('letter-spacing', letterSpacing + 'px', 'important');
            });
            
            // åº”ç”¨åˆ°èŠå¤©è¾“å…¥æ¡†
            const chatInput = document.getElementById('api-chat-input');
            if (chatInput) {
                chatInput.style.letterSpacing = letterSpacing + 'px';
            }
        }
        
        function applyLetterSpacingToMoments(letterSpacing) {
            // åº”ç”¨åˆ°å¾®åšåŠ¨æ€å†…å®¹
            const postContents = document.querySelectorAll('.post-content');
            postContents.forEach(content => {
                content.style.letterSpacing = letterSpacing + 'px';
            });
            
            // åº”ç”¨åˆ°å¾®åšè¾“å…¥æ¡†
            const weiboTextarea = document.getElementById('weibo-text');
            if (weiboTextarea) {
                weiboTextarea.style.letterSpacing = letterSpacing + 'px';
            }
        }
        
        function toggleAutoScale() {
            const toggle = document.getElementById('auto-scale-toggle');
            const isEnabled = toggle.checked;
            
            // ä¿å­˜è‡ªåŠ¨ç¼©æ”¾è®¾ç½®
            localStorage.setItem('autoScaleFont', isEnabled);
            
            if (isEnabled) {
                // æ ¹æ®å±å¹•å°ºå¯¸è‡ªåŠ¨è°ƒæ•´å­—ä½“
                autoAdjustFontSize();
                showToast('å­—ä½“è‡ªåŠ¨ç¼©æ”¾å·²å¼€å¯ï¼', 'success');
            } else {
                showToast('å­—ä½“è‡ªåŠ¨ç¼©æ”¾å·²å…³é—­ï¼', 'success');
            }
        }
        
        function autoAdjustFontSize() {
            const phoneScreen = document.getElementById('phone-screen');
            if (!phoneScreen) return;
            
            const screenWidth = parseInt(phoneScreen.style.width) || 350;
            
            // æ ¹æ®å±å¹•å®½åº¦è®¡ç®—æ¨èå­—ä½“å¤§å°
            let recommendedSize = 15; // é»˜è®¤å¤§å°
            
            if (screenWidth <= 320) {
                recommendedSize = 13; // å°å±å¹•ç”¨å°å­—ä½“
            } else if (screenWidth <= 350) {
                recommendedSize = 14;
            } else if (screenWidth <= 375) {
                recommendedSize = 15;
            } else if (screenWidth <= 390) {
                recommendedSize = 16;
            } else {
                recommendedSize = 17; // å¤§å±å¹•ç”¨å¤§å­—ä½“
            }
            
            // æ›´æ–°æ»‘å—å’Œåº”ç”¨å­—ä½“å¤§å°
            const slider = document.getElementById('font-size-slider');
            if (slider) {
                slider.value = recommendedSize;
                changeFontSize(recommendedSize);
            }
        }
        
        function loadFontSizeSettings() {
            // åŠ è½½å­—ä½“å¤§å°è®¾ç½®
            const savedSize = localStorage.getItem('globalFontSize');
            const fontSize = savedSize ? parseInt(savedSize) : 15;
            
            const slider = document.getElementById('font-size-slider');
            const preview = document.getElementById('font-size-preview');
            const valueDisplay = document.getElementById('font-size-value');
            
            if (slider) {
                slider.value = fontSize;
            }
            
            if (preview) {
                preview.style.fontSize = fontSize + 'px';
            }
            
            if (valueDisplay) {
                valueDisplay.textContent = fontSize + 'px';
            }
            
            // åº”ç”¨å­—ä½“å¤§å°
            document.documentElement.style.setProperty('--global-font-size', fontSize + 'px');
            
            // åŠ è½½å­—è·è®¾ç½®
            const savedSpacing = localStorage.getItem('globalLetterSpacing');
            const letterSpacing = savedSpacing ? parseFloat(savedSpacing) : 0;
            
            const spacingSlider = document.getElementById('letter-spacing-slider');
            const spacingValueDisplay = document.getElementById('letter-spacing-value');
            
            if (spacingSlider) {
                spacingSlider.value = letterSpacing;
            }
            
            if (preview) {
                preview.style.letterSpacing = letterSpacing + 'px';
            }
            
            if (spacingValueDisplay) {
                // æ ¹æ®æ•°å€¼æ˜¾ç¤ºå¯¹åº”çš„æ–‡å­—æè¿°
                let description;
                if (letterSpacing < -0.2) {
                    description = 'å¾ˆç´§å‡‘';
                } else if (letterSpacing < 0.2) {
                    description = 'æ ‡å‡†';
                } else if (letterSpacing < 0.8) {
                    description = 'èˆ’é€‚';
                } else if (letterSpacing < 1.5) {
                    description = 'å®½æ¾';
                } else {
                    description = 'å¾ˆå®½æ¾';
                }
                spacingValueDisplay.textContent = `${description} (${letterSpacing}px)`;
            }
            
            // åº”ç”¨å­—è·
            document.documentElement.style.setProperty('--global-letter-spacing', letterSpacing + 'px');
            
            // å»¶è¿Ÿåº”ç”¨ï¼Œç¡®ä¿DOMå…ƒç´ å·²ç»åŠ è½½
            setTimeout(() => {
                applyFontSizeToMessages(fontSize);
                applyFontSizeToMoments(fontSize);
                applyLetterSpacingToMessages(letterSpacing);
                applyLetterSpacingToMoments(letterSpacing);
            }, 500);
            
            // åŠ è½½è‡ªåŠ¨ç¼©æ”¾è®¾ç½®
            const autoScale = localStorage.getItem('autoScaleFont');
            const autoScaleToggle = document.getElementById('auto-scale-toggle');
            if (autoScaleToggle) {
                autoScaleToggle.checked = autoScale === 'true';
            }
        }



        // å·¥å…·æ åŠŸèƒ½
        function triggerVoiceMessage() {
            showToast('è¯­éŸ³åŠŸèƒ½å¼€å‘ä¸­...', 'info');
            // è¿™é‡Œå¯ä»¥æ·»åŠ è¯­éŸ³å½•åˆ¶åŠŸèƒ½
        }

        // èŠå¤©ç•Œé¢æ‹ç…§åŠŸèƒ½ - æ–‡å­—æè¿°å›¾ç‰‡å‘é€ç»™AI
        async function openCamera() {
            if (!currentChatCharacter) {
                showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠå¤©å¯¹è±¡', 'error');
                return;
            }
            
            const description = await showCustomPrompt("å‘é€ç…§ç‰‡", "è¯·ç”¨æ–‡å­—æè¿°æ‚¨è¦å‘é€çš„ç…§ç‰‡ï¼š");
            if (description && description.trim()) {
                const msg = {
                    id: Date.now().toString(),
                    sender: 'sent',
                    type: 'user_photo',
                    content: description.trim(),
                    timestamp: Date.now(),
                    photoDescription: description.trim() // ä¿å­˜åŸå§‹æè¿°ç”¨äºç‚¹å‡»æŸ¥çœ‹
                };
                
                // æ·»åŠ åˆ°èŠå¤©è®°å½•
                if (!chatMessages[currentChatCharacter.id]) {
                    chatMessages[currentChatCharacter.id] = [];
                }
                chatMessages[currentChatCharacter.id].push(msg);
                await saveChatMessages();
                
                // åˆ·æ–°ç•Œé¢
                renderChatMessages(currentChatCharacter.id);
                renderMessageList();
                
                showToast('ç…§ç‰‡å·²å‘é€', 'success');
            }
        }

        function openTransfer() {
            // æ£€æŸ¥æ˜¯å¦æœ‰å½“å‰èŠå¤©è§’è‰²
            if (!currentChatCharacter) {
                showToast('è¯·å…ˆé€‰æ‹©èŠå¤©å¯¹è±¡', 'warning');
                return;
            }
            
            // æ˜¾ç¤ºè½¬è´¦å¯¹è¯æ¡†
            document.getElementById('transfer-modal').classList.add('visible');
        }

        // é€šè¯çŠ¶æ€å˜é‡
        let isInCall = false;
        let callTimer = null;
        let callStartTime = null;
        let callDuration = 0;
        let isMuted = false;
        let isSpeakerOn = false;
        let currentCallCharacter = null;
        
        // ç”Ÿæˆæ¶ˆæ¯IDå‡½æ•°
        function generateMessageId() {
            return Date.now().toString() + Math.floor(Math.random() * 1000).toString();
        }
        
        // æ·»åŠ æ¶ˆæ¯åˆ°èŠå¤©è®°å½•
        function addMessageToChat(message) {
            if (!currentChatCharacter) return;
            
            const characterId = currentChatCharacter.id;
            if (!chatMessages[characterId]) {
                chatMessages[characterId] = [];
            }
            
            chatMessages[characterId].push(message);
            saveChatMessages();
            
            // æ›´æ–°èŠå¤©ç•Œé¢
            renderChatMessages(characterId);
        }

        function makeCall() {
            if (!currentChatCharacter) {
                showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè§’è‰²', 'error');
                return;
            }
            
            // æ£€æŸ¥è§’è‰²ä¸»åŠ¨æ‹¨æ‰“ç”µè¯å¼€å…³ï¼Œç”¨æˆ·ä¸»åŠ¨æ‹¨æ‰“æ—¶ä¸å—æ­¤é™åˆ¶
            const currentChatSettings = getCurrentChatSettings();
            console.log('ğŸ“ ç”¨æˆ·ä¸»åŠ¨æ‹¨æ‰“ç”µè¯ï¼Œå¼€å…³çŠ¶æ€:', currentChatSettings.aiCallEnabled);
            
            currentCallCharacter = currentChatCharacter;
            
            // è®¾ç½®é€šè¯ç•Œé¢
            const avatarSrc = currentCallCharacter.avatar || currentCallCharacter.avatarUrl || 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="50" fill="lightgray"/><text x="50" y="60" font-size="30" text-anchor="middle" fill="gray">å¤´åƒ</text></svg>';
            document.getElementById('call-avatar-img').src = avatarSrc;
            document.getElementById('call-name').textContent = currentCallCharacter.name;
            document.getElementById('call-status').textContent = 'æ­£åœ¨é€šè¯ä¸­...';
            document.getElementById('call-timer').textContent = '00:00';
            
            // æ¸…ç©ºé€šè¯æ¶ˆæ¯å®¹å™¨
            document.getElementById('call-message-container').innerHTML = '';
            
            // æ˜¾ç¤ºé€šè¯ç•Œé¢
            showApp('phone-call-screen');
            
            // å¼€å§‹è®¡æ—¶
            startCallTimer();
            
            // è®¾ç½®é€šè¯çŠ¶æ€
            isInCall = true;
            
            // å‘é€ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©è®°å½•
            const callStartMessage = {
                id: generateMessageId(),
                sender: 'system',
                content: `[è¯­éŸ³é€šè¯] ä¸${currentCallCharacter.name}çš„é€šè¯å·²å¼€å§‹`,
                timestamp: Date.now(),
                type: 'call_record',
                callType: 'outgoing',
                callStatus: 'started'
            };
            
            addMessageToChat(callStartMessage);
            
            // ç”¨æˆ·ä¸»åŠ¨æ‹¨æ‰“ç”µè¯æ—¶ä¸è‡ªåŠ¨æ·»åŠ è§’è‰²å›åº”ï¼Œç­‰å¾…ç”¨æˆ·å…ˆè¯´è¯
            // è®¾ç½®æ ‡å¿—ï¼Œè¡¨æ˜è¿™æ˜¯ç”¨æˆ·ä¸»åŠ¨æ‹¨æ‰“çš„ç”µè¯
            window.isUserInitiatedCall = true;
        }
        
        // è§’è‰²ä¸»åŠ¨æ‹¨æ‰“ç”µè¯
        async function initiateAICall(character, callReason) {
            if (isInCall) return; // å¦‚æœå·²ç»åœ¨é€šè¯ä¸­ï¼Œä¸å†å‘èµ·
            
            currentCallCharacter = character;
            
            // ğŸ”¥ã€æ¢å¤ã€‘å…ˆç”Ÿæˆè§’è‰²çš„å¼€åœºç™½ï¼Œå†æ˜¾ç¤ºæ¥ç”µç•Œé¢
            let characterGreeting = '';
            try {
                const prompt = `ä½ æ˜¯${character.name}ï¼Œåˆšåˆšå†³å®šç»™ç”¨æˆ·æ‰“ç”µè¯ã€‚

è¯·ç”Ÿæˆä¸€å¥ç®€çŸ­è‡ªç„¶çš„å¼€åœºç™½ï¼Œè¯´æ˜ä½ ä¸ºä»€ä¹ˆè¦æ‰“è¿™ä¸ªç”µè¯ï¼š
- è¦ç¬¦åˆä½ çš„æ€§æ ¼ç‰¹ç‚¹
- åƒçœŸå®é€šè¯å¼€å§‹æ—¶çš„è‡ªç„¶è¡¨è¾¾
- 1å¥è¯å³å¯ï¼Œä¸è¦è¶…è¿‡20å­—
- ç›´æ¥è¯´è¯ï¼Œä¸è¦ä»»ä½•æ ¼å¼æ ‡è®°

ä¾‹å¦‚ï¼š
- "æˆ‘æƒ³å’Œä½ èŠèŠä»Šå¤©çš„äº‹æƒ…"
- "æœ‰ä¸ªå¥½æ¶ˆæ¯æƒ³å‘Šè¯‰ä½ "
- "æƒ³å¬å¬ä½ çš„å£°éŸ³"

è¯·åªå›å¤å¼€åœºç™½å†…å®¹ï¼š`;

                const response = await callChatAPI(prompt, character);
                
                // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘ä½¿ç”¨parseAiResponseè§£æå¼€åœºç™½
                const parsedMessages = parseAiResponse(response);
                console.log('ğŸ”” å¼€åœºç™½AIå›å¤è§£æç»“æœ:', parsedMessages);
                
                if (Array.isArray(parsedMessages) && parsedMessages.length > 0) {
                    // æ‰¾åˆ°ç¬¬ä¸€æ¡çº¯æ–‡æœ¬æ¶ˆæ¯
                    const firstTextMessage = parsedMessages.find(msg => typeof msg === 'string');
                    if (firstTextMessage) {
                        characterGreeting = firstTextMessage.trim();
                    } else {
                        // å¦‚æœæ²¡æœ‰çº¯æ–‡æœ¬ï¼Œå°è¯•æå–å¯¹è±¡ä¸­çš„å†…å®¹
                        const firstMessage = parsedMessages[0];
                        if (typeof firstMessage === 'object' && firstMessage.content) {
                            characterGreeting = firstMessage.content.trim();
                        }
                    }
                } else if (typeof response === 'string') {
                    // å¤‡ç”¨ï¼šå¦‚æœè§£æå¤±è´¥ï¼Œæ¸…ç†åŸå§‹å­—ç¬¦ä¸²
                    characterGreeting = cleanCallResponse(response).trim();
                }
                
                if (!characterGreeting || characterGreeting.length > 30) {
                    characterGreeting = callReason || 'æƒ³å’Œä½ é€šè¯...';
                }
            } catch (error) {
                console.error('ç”Ÿæˆè§’è‰²å¼€åœºç™½å¤±è´¥:', error);
                characterGreeting = callReason || 'æƒ³å’Œä½ é€šè¯...';
            }
            
            // è®¾ç½®æ¥ç”µæ˜¾ç¤ºç•Œé¢
            const avatarSrc = character.avatar || character.avatarUrl || 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="50" fill="lightgray"/><text x="50" y="60" font-size="30" text-anchor="middle" fill="gray">å¤´åƒ</text></svg>';
            document.getElementById('incoming-call-avatar').src = avatarSrc;
            document.getElementById('incoming-call-name').textContent = character.name;
            document.getElementById('incoming-call-text').textContent = characterGreeting;
            
            // ğŸ”¥ã€ä¿å­˜å¼€åœºç™½ä¾›æ¥å¬åä½¿ç”¨ã€‘
            window.aiCallGreeting = characterGreeting;
            
            // æ·»åŠ æŒ¯é“ƒåŠ¨ç”»
            document.getElementById('incoming-call-avatar').classList.add('ringing-animation');
            
            // æ˜¾ç¤ºæ¥ç”µç•Œé¢
            showApp('incoming-call-screen');
            
            // æ’­æ”¾æ¥ç”µé“ƒå£°ï¼ˆå¦‚æœéœ€è¦ï¼‰
            // playRingtone();
            
            // å‘é€ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©è®°å½•
            const incomingCallMessage = {
                id: generateMessageId(),
                sender: 'system',
                content: `[è¯­éŸ³é€šè¯] ${character.name}æ­£åœ¨å‘¼å«ä½ `,
                timestamp: Date.now(),
                type: 'call_record',
                callType: 'incoming',
                callStatus: 'ringing'
            };
            
            addMessageToChat(incomingCallMessage);
            
            // å¦‚æœ30ç§’å†…æ²¡æœ‰æ¥å¬ï¼Œè‡ªåŠ¨æŒ‚æ–­
            setTimeout(() => {
                if (document.getElementById('incoming-call-screen').style.display !== 'none') {
                    rejectCall();
                }
            }, 30000);
        }
        
        // æ¥å—æ¥ç”µ
        function acceptCall() {
            // åœæ­¢æŒ¯é“ƒåŠ¨ç”»
            document.getElementById('incoming-call-avatar').classList.remove('ringing-animation');
            
            // éšè—æ¥ç”µç•Œé¢
            hideApp('incoming-call-screen');
            
            // è®¾ç½®é€šè¯ç•Œé¢
            const avatarSrc = currentCallCharacter.avatar || currentCallCharacter.avatarUrl || 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="50" fill="lightgray"/><text x="50" y="60" font-size="30" text-anchor="middle" fill="gray">å¤´åƒ</text></svg>';
            document.getElementById('call-avatar-img').src = avatarSrc;
            document.getElementById('call-name').textContent = currentCallCharacter.name;
            document.getElementById('call-status').textContent = 'æ­£åœ¨é€šè¯ä¸­...';
            document.getElementById('call-timer').textContent = '00:00';
            
            // æ¸…ç©ºé€šè¯æ¶ˆæ¯å®¹å™¨
            document.getElementById('call-message-container').innerHTML = '';
            
            // æ˜¾ç¤ºé€šè¯ç•Œé¢
            showApp('phone-call-screen');
            
            // å¼€å§‹è®¡æ—¶
            startCallTimer();
            
            // è®¾ç½®é€šè¯çŠ¶æ€
            isInCall = true;
            
            // å‘é€ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©è®°å½•
            const callAcceptedMessage = {
                id: generateMessageId(),
                sender: 'system',
                content: `[è¯­éŸ³é€šè¯] å·²æ¥å¬${currentCallCharacter.name}çš„æ¥ç”µ`,
                timestamp: Date.now(),
                type: 'call_record',
                callType: 'incoming',
                callStatus: 'accepted'
            };
            
            addMessageToChat(callAcceptedMessage);
            
            // ğŸ”¥ã€ä¿®å¤ã€‘ä½¿ç”¨AIç”Ÿæˆçš„å¼€åœºç™½æˆ–é»˜è®¤é—®å€™
            setTimeout(() => {
                let initialResponse = window.aiCallGreeting || getRandomCallGreeting(currentCallCharacter.name);
                addCallMessage(initialResponse, 'received');
                // æ¸…ç†å¼€åœºç™½ç¼“å­˜
                window.aiCallGreeting = null;
            }, 1000);
        }
        
        // æ‹’ç»æ¥ç”µ
        function rejectCall() {
            // åœæ­¢æŒ¯é“ƒåŠ¨ç”»
            document.getElementById('incoming-call-avatar').classList.remove('ringing-animation');
            
            // éšè—æ¥ç”µç•Œé¢
            hideApp('incoming-call-screen');
            
            // å‘é€ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©è®°å½•
            const callRejectedMessage = {
                id: generateMessageId(),
                sender: 'system',
                content: `[è¯­éŸ³é€šè¯] å·²æ‹’ç»${currentCallCharacter.name}çš„æ¥ç”µ`,
                timestamp: Date.now(),
                type: 'call_record',
                callType: 'incoming',
                callStatus: 'rejected'
            };
            
            addMessageToChat(callRejectedMessage);
            
            currentCallCharacter = null;
        }
        
        // ç»“æŸé€šè¯
        function endCall() {
            if (!isInCall) return;
            
            // åœæ­¢è®¡æ—¶
            stopCallTimer();
            
            // éšè—é€šè¯ç•Œé¢
            hideApp('phone-call-screen');
            
            // è¿”å›èŠå¤©ç•Œé¢
            showApp('api-chat-screen');
            
            // å‘é€ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©è®°å½•
            const formattedDuration = formatCallDuration(callDuration);
            const callEndedMessage = {
                id: generateMessageId(),
                sender: 'system',
                content: `[è¯­éŸ³é€šè¯] ä¸${currentCallCharacter.name}çš„é€šè¯å·²ç»“æŸ`,
                timestamp: Date.now(),
                type: 'call_record',
                callType: 'ended',
                callStatus: 'completed',
                duration: formattedDuration
            };
            
            addMessageToChat(callEndedMessage);
            
            // é‡ç½®é€šè¯çŠ¶æ€
            isInCall = false;
            isMuted = false;
            isSpeakerOn = false;
            
            currentCallCharacter = null;
        }
        
        // é™éŸ³/å–æ¶ˆé™éŸ³
        function toggleMute() {
            isMuted = !isMuted;
            const muteBtn = document.getElementById('mute-btn');
            
            if (isMuted) {
                muteBtn.classList.add('muted');
                muteBtn.innerHTML = '<i class="fas fa-microphone-slash"></i>';
                showToast('å·²é™éŸ³', 'info');
            } else {
                muteBtn.classList.remove('muted');
                muteBtn.innerHTML = '<i class="fas fa-microphone"></i>';
                showToast('å·²å–æ¶ˆé™éŸ³', 'info');
            }
        }
        
        // æ‰¬å£°å™¨å¼€å…³
        function toggleSpeaker() {
            isSpeakerOn = !isSpeakerOn;
            const speakerBtn = document.getElementById('speaker-btn');
            
            if (isSpeakerOn) {
                speakerBtn.classList.add('active');
                showToast('å·²å¼€å¯æ‰¬å£°å™¨', 'info');
            } else {
                speakerBtn.classList.remove('active');
                showToast('å·²å…³é—­æ‰¬å£°å™¨', 'info');
            }
        }
        
        // å¼€å§‹é€šè¯è®¡æ—¶å™¨
        function startCallTimer() {
            callStartTime = new Date();
            callDuration = 0;
            
            callTimer = setInterval(() => {
                callDuration = Math.floor((new Date() - callStartTime) / 1000);
                document.getElementById('call-timer').textContent = formatCallDuration(callDuration);
            }, 1000);
        }
        
        // åœæ­¢é€šè¯è®¡æ—¶å™¨
        function stopCallTimer() {
            if (callTimer) {
                clearInterval(callTimer);
                callTimer = null;
            }
        }
        
        // æ ¼å¼åŒ–é€šè¯æ—¶é•¿
        function formatCallDuration(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }
        
        // åœ¨é€šè¯ç•Œé¢å‘é€æ¶ˆæ¯
        function sendCallMessage() {
            const input = document.getElementById('call-input');
            if (!input) {
                console.error('æ‰¾ä¸åˆ°é€šè¯è¾“å…¥æ¡†å…ƒç´ ');
                return;
            }
            
            const message = input.value.trim();
            
            if (!message) return;
            
            // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°é€šè¯ç•Œé¢
            addCallMessage(message, 'sent');
            
            // æ¸…ç©ºè¾“å…¥æ¡†
            input.value = '';
            
            // æ˜¾ç¤ºAIæ­£åœ¨è¯´è¯çš„æŒ‡ç¤ºå™¨
            const typingIndicator = showCallTypingIndicator();
            
            // æ ¹æ®é€šè¯ç±»å‹å†³å®šæ˜¯å¦å›å¤
            if (currentCallCharacter) {
                setTimeout(async () => {
                    try {
                        // ğŸ”¥ã€ä¿®å¤ã€‘æ„å»ºæ›´å¥½çš„è¯­éŸ³é€šè¯æç¤ºè¯
                        const prompt = `ä½ æ˜¯${currentCallCharacter.name}ï¼Œæ­£åœ¨ä¸ç”¨æˆ·è¿›è¡Œè¯­éŸ³é€šè¯ã€‚
ç”¨æˆ·åˆšè¯´ï¼š"${message}"

è¯·ç”¨ç®€çŸ­è‡ªç„¶çš„å£è¯­æ–¹å¼å›å¤ï¼Œå°±åƒçœŸå®çš„ç”µè¯å¯¹è¯ä¸€æ ·ï¼š
- ç›´æ¥è¯´è¯ï¼Œä¸è¦ä»»ä½•æè¿°æ€§æ–‡å­—
- ä¿æŒè‡ªç„¶çš„è¯­éŸ³å¯¹è¯é£æ ¼
- å›å¤è¦ç®€æ´ï¼Œ1-2å¥è¯å³å¯
- ç¬¦åˆä½ çš„æ€§æ ¼è®¾å®š

è¯·åªå›å¤å¯¹è¯å†…å®¹ï¼Œä¸è¦JSONæ ¼å¼ï¼Œä¸è¦å…¶ä»–æ ¼å¼ï¼š`;
                        
                        try {
                            const response = await callChatAPI(prompt, currentCallCharacter);
                            
                            // ç§»é™¤è¾“å…¥æŒ‡ç¤ºå™¨
                            hideCallTypingIndicator(typingIndicator);
                            
                            // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘ä½¿ç”¨parseAiResponseè§£æå›å¤ï¼Œæ˜¾ç¤ºæ‰€æœ‰æ–‡æœ¬æ¶ˆæ¯
                            const parsedMessages = parseAiResponse(response);
                            console.log('ğŸ”” é€šè¯AIå›å¤è§£æç»“æœ:', parsedMessages);
                            
                            let hasValidMessage = false;
                            if (Array.isArray(parsedMessages) && parsedMessages.length > 0) {
                                // éå†æ‰€æœ‰æ¶ˆæ¯ï¼Œæ˜¾ç¤ºæ¯ä¸€æ¡æ–‡æœ¬æ¶ˆæ¯
                                for (const msg of parsedMessages) {
                                    let replyText = '';
                                    if (typeof msg === 'string') {
                                        replyText = msg.trim();
                                    } else if (typeof msg === 'object' && msg.content) {
                                        replyText = msg.content.trim();
                                    }
                                    
                                    if (replyText) {
                                        addCallMessage(replyText, 'received');
                                        hasValidMessage = true;
                                        // æ·»åŠ çŸ­æš‚å»¶è¿Ÿï¼Œè®©å¤šæ¡æ¶ˆæ¯åˆ†å¼€æ˜¾ç¤º
                                        await new Promise(resolve => setTimeout(resolve, 300));
                                    }
                                }
                            }
                            
                            // å¦‚æœæ²¡æœ‰æœ‰æ•ˆæ¶ˆæ¯ï¼Œä½¿ç”¨å¤‡ç”¨å›å¤
                            if (!hasValidMessage) {
                                if (typeof response === 'string') {
                                    const cleanedText = cleanCallResponse(response);
                                    if (cleanedText) {
                                        addCallMessage(cleanedText, 'received');
                                    } else {
                                        addCallMessage(getRandomCallResponse(), 'received');
                                    }
                                } else {
                                    addCallMessage(getRandomCallResponse(), 'received');
                                }
                            }
                            
                        } catch (error) {
                            console.error('è·å–AIå›å¤å¤±è´¥:', error);
                            hideCallTypingIndicator(typingIndicator);
                            addCallMessage(getRandomCallResponse(), 'received');
                        }
                        
                    } catch (error) {
                        console.error('é€šè¯å›å¤é”™è¯¯:', error);
                        hideCallTypingIndicator(typingIndicator);
                        addCallMessage('æˆ‘æ˜ç™½äº†', 'received');
                    }
                }, 1000 + Math.random() * 1000);
            }
        }
        
        // æ·»åŠ æ¶ˆæ¯åˆ°é€šè¯ç•Œé¢
        function addCallMessage(message, type) {
            const container = document.getElementById('call-message-container');
            const messageElement = document.createElement('div');
            messageElement.className = `call-message ${type}`;
            messageElement.textContent = message;
            
            container.appendChild(messageElement);
            container.scrollTop = container.scrollHeight;
            
            // ğŸ”¥ã€ä¿®å¤ã€‘åŒæ—¶æ·»åŠ åˆ°èŠå¤©è®°å½•ï¼Œä½†æ ‡è®°ä¸ºé€šè¯æ¶ˆæ¯
            if (currentChatCharacter && currentChatCharacter.id) {
                const callMessage = {
                    id: generateMessageId(),
                    sender: type === 'sent' ? 'sent' : 'received',  // ä¿®å¤ï¼šä½¿ç”¨æ­£ç¡®çš„senderæ ¼å¼
                    content: message,
                    timestamp: Date.now(),
                    isCallMessage: true,
                    type: 'call_message'  // æ·»åŠ ç‰¹æ®Šç±»å‹æ ‡è®°
                };
                
                if (!chatMessages[currentChatCharacter.id]) {
                    chatMessages[currentChatCharacter.id] = [];
                }
                
                chatMessages[currentChatCharacter.id].push(callMessage);
                saveChatMessages();
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ˜¾ç¤ºAIæ­£åœ¨è¯´è¯çš„æŒ‡ç¤ºå™¨
        function showCallTypingIndicator() {
            const container = document.getElementById('call-message-container');
            const typingIndicator = document.createElement('div');
            typingIndicator.className = 'call-typing-indicator';
            typingIndicator.innerHTML = `
                <div class="call-typing-dots">
                    <div class="call-typing-dot"></div>
                    <div class="call-typing-dot"></div>
                    <div class="call-typing-dot"></div>
                </div>
            `;
            
            container.appendChild(typingIndicator);
            container.scrollTop = container.scrollHeight;
            
            return typingIndicator;
        }

        // ğŸ”¥ã€æ–°å¢ã€‘éšè—AIæ­£åœ¨è¯´è¯çš„æŒ‡ç¤ºå™¨
        function hideCallTypingIndicator(indicator) {
            if (indicator && indicator.parentNode) {
                indicator.parentNode.removeChild(indicator);
            }
        }

        // ğŸ”¥ã€ç®€åŒ–ã€‘æ¸…ç†é€šè¯å›å¤æ–‡æœ¬ - å› ä¸ºå·²ç»ç”¨parseAiResponseå¤„ç†JSONæ ¼å¼
        function cleanCallResponse(text) {
            if (!text) return '';
            
            console.log('ğŸ§¹ åŸå§‹æ–‡æœ¬:', text);
            
            // åŸºç¡€æ¸…ç†ï¼šç§»é™¤å¤šä½™ç©ºæ ¼å’Œæ¢è¡Œ
            text = text.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
            
            // ç§»é™¤å¸¸è§çš„æè¿°æ€§å‰ç¼€
            text = text.replace(/^(è§’è‰²è¯´|æˆ‘è¯´|å›å¤|ç­”æ¡ˆ|å›ç­”)[:ï¼š]\s*/i, '');
            
            // ç§»é™¤æ‹¬å·ä¸­çš„æè¿°æ€§å†…å®¹
            text = text.replace(/\([^)]*\)/g, '');
            text = text.replace(/ã€[^ã€‘]*ã€‘/g, '');
            text = text.replace(/\[[^\]]*\]/g, '');
            
            // å¦‚æœæ–‡æœ¬ä»¥æ ‡ç‚¹ç¬¦å·å¼€å¤´ï¼Œç§»é™¤å®ƒ
            text = text.replace(/^[ï¼Œã€‚ï¼ï¼Ÿï¼›ï¼š,.!?;:\s]*/, '');
            
            console.log('ğŸ§¹ æ¸…ç†åæ–‡æœ¬:', text);
            
            // éªŒè¯æ¸…ç†ç»“æœ
            if (!text || text.length < 2) {
                console.log('ğŸ§¹ æ–‡æœ¬æ— æ•ˆï¼Œä½¿ç”¨å¤‡ç”¨å›å¤');
                return getRandomCallResponse();
            }
            
            // å¦‚æœæ–‡æœ¬å¤ªé•¿ï¼Œæˆªå–å‰é¢éƒ¨åˆ†
            if (text.length > 60) {
                text = text.substring(0, 60) + '...';
            }
            
            return text;
        }
        
        // éšæœºé€šè¯é—®å€™è¯­
        function getRandomCallGreeting(characterName) {
            const greetings = [
                `ä½ å¥½ï¼Œæˆ‘æ˜¯${characterName}ï¼Œå¾ˆé«˜å…´èƒ½å’Œä½ é€šè¯ã€‚`,
                `å—¨ï¼Œç»ˆäºèƒ½å¬åˆ°ä½ çš„å£°éŸ³äº†ï¼`,
                `å–‚ï¼Œä½ å¥½å•Šï¼Œå¬å¾—åˆ°æˆ‘è¯´è¯å—ï¼Ÿ`,
                `ä½ å¥½ï¼Œè°¢è°¢ä½ æ¥æˆ‘ç”µè¯ã€‚`,
                `å—¨ï¼Œå¾ˆé«˜å…´èƒ½å’Œä½ é€šè¯ã€‚`
            ];
            
            return greetings[Math.floor(Math.random() * greetings.length)];
        }
        
        // éšæœºé€šè¯å›å¤ï¼ˆå¤‡ç”¨ï¼‰
        function getRandomCallResponse() {
            const responses = [
                'å—¯ï¼Œæˆ‘æ˜ç™½äº†ã€‚',
                'å¥½çš„ï¼Œæˆ‘çŸ¥é“äº†ã€‚',
                'æ˜¯çš„ï¼Œä½ è¯´å¾—å¯¹ã€‚',
                'æˆ‘è§‰å¾—è¿™ä¸ªæƒ³æ³•ä¸é”™ã€‚',
                'å—¯ï¼Œæœ‰é“ç†ã€‚',
                'å“¦ï¼ŒçœŸçš„å—ï¼Ÿ',
                'æˆ‘æ˜ç™½ä½ çš„æ„æ€äº†ã€‚',
                'è¿™æ ·å•Šï¼Œæˆ‘æ‡‚äº†ã€‚',
                'ç¡®å®å¦‚æ­¤ã€‚',
                'æˆ‘åŒæ„ä½ çš„çœ‹æ³•ã€‚'
            ];
            
            return responses[Math.floor(Math.random() * responses.length)];
        }
        
        // æ£€æµ‹æ˜¯å¦åº”è¯¥è§¦å‘AIä¸»åŠ¨æ‹¨æ‰“ç”µè¯
        function checkForAICallTrigger(userMessage, aiResponse) {
            // è·å–å½“å‰èŠå¤©è®¾ç½®
            const currentChatSettings = getCurrentChatSettings();
            
            // å¦‚æœæœªå¯ç”¨AIä¸»åŠ¨æ‹¨æ‰“ç”µè¯åŠŸèƒ½ï¼Œç›´æ¥è¿”å›
            if (!currentChatSettings.aiCallEnabled) {
                console.log('ğŸ”” AIä¸»åŠ¨æ‹¨æ‰“ç”µè¯åŠŸèƒ½æœªå¼€å¯ï¼Œè§’è‰²ä¸ä¼šä¸»åŠ¨æ‹¨æ‰“ç”µè¯');
                return false;
            }
            
            // å¦‚æœå·²ç»åœ¨é€šè¯ä¸­ï¼Œä¸å†è§¦å‘
            if (isInCall) {
                console.log('ğŸ”” å½“å‰æ­£åœ¨é€šè¯ä¸­ï¼Œä¸è§¦å‘æ–°çš„æ¥ç”µ');
                return false;
            }
            
            // ç¡®ä¿æœ‰å½“å‰èŠå¤©è§’è‰²
            if (!currentChatCharacter) {
                console.log('ğŸ”” æ²¡æœ‰å½“å‰èŠå¤©è§’è‰²ï¼Œæ— æ³•è§¦å‘æ¥ç”µ');
                return false;
            }
            
            // é€šè¯å…³é”®è¯
            const callKeywords = ['é€šè¯', 'ç”µè¯', 'è§†é¢‘', 'è¯­éŸ³', 'æ‰“ç»™ä½ ', 'æƒ³å¬', 'æƒ³çœ‹', 'èŠå¤©', 'è¯´è¯', 'æµ‹è¯•', 'è¯•è¯•', 'æ‰“ç”µè¯'];
            
            // æ£€æŸ¥ç”¨æˆ·æ¶ˆæ¯å’ŒAIå›å¤ä¸­æ˜¯å¦åŒ…å«é€šè¯å…³é”®è¯
            const userMessageHasCallKeyword = callKeywords.some(keyword => userMessage.includes(keyword));
            const aiResponseHasCallKeyword = callKeywords.some(keyword => aiResponse.includes(keyword));
            
            console.log('ğŸ”” æ£€æŸ¥AIä¸»åŠ¨æ‹¨æ‰“è§¦å‘æ¡ä»¶:', {
                userMessage,
                aiResponse,
                userHasKeyword: userMessageHasCallKeyword,
                aiHasKeyword: aiResponseHasCallKeyword,
                aiCallEnabled: currentChatSettings.aiCallEnabled
            });
            
            // æ ¹æ®å…³é”®è¯å‡ºç°æƒ…å†µå’Œè§’è‰²æ€§æ ¼å†³å®šè§¦å‘æ¦‚ç‡
            let triggerProbability = 0;
            if (userMessageHasCallKeyword) {
                // åŸºç¡€æ¦‚ç‡ï¼šç”¨æˆ·æåˆ°é€šè¯å…³é”®è¯æ—¶20%
                triggerProbability = 0.2;
                
                // å¦‚æœAIå›å¤ä¹ŸåŒ…å«é€šè¯å…³é”®è¯ï¼Œå¤§å¹…æå‡æ¦‚ç‡åˆ°60%
                if (aiResponseHasCallKeyword) {
                    triggerProbability = 0.6;
                }
                
                // æ ¹æ®è§’è‰²æ€§æ ¼è°ƒæ•´æ¦‚ç‡ï¼ˆå¦‚æœè§’è‰²è®¾å®šä¸­åŒ…å«ä¸»åŠ¨ã€å¤–å‘ç­‰ç‰¹è´¨ï¼‰
                const characterBio = currentChatCharacter.bio || '';
                if (characterBio.includes('ä¸»åŠ¨') || characterBio.includes('å¤–å‘') || characterBio.includes('çƒ­æƒ…')) {
                    triggerProbability += 0.1;
                }
                
                // é™åˆ¶æœ€å¤§æ¦‚ç‡ä¸º70%
                triggerProbability = Math.min(triggerProbability, 0.7);
            }
            
            // å¢åŠ éšæœºå› ç´ ï¼šå³ä½¿æ²¡æœ‰å…³é”®è¯ï¼Œä¹Ÿæœ‰æå°æ¦‚ç‡(2%)è§¦å‘ï¼Œæ¨¡æ‹ŸçœŸå®çš„çªç„¶æ¥ç”µ
            if (triggerProbability === 0 && Math.random() < 0.02) {
                triggerProbability = 0.02;
                console.log('ğŸ”” éšæœºè§¦å‘AIæ¥ç”µï¼ˆæ¨¡æ‹Ÿçªç„¶æƒ³åˆ°è¦æ‰“ç”µè¯ï¼‰');
            }
            
            if (triggerProbability > 0 && Math.random() < triggerProbability) {
                console.log('ğŸ”” AIä¸»åŠ¨æ‹¨æ‰“ç”µè¯è¢«è§¦å‘ï¼æ¦‚ç‡:', triggerProbability);
                
                // ä»AIå›å¤ä¸­æå–ä¸€ä¸ªåˆç†çš„é€šè¯ç†ç”±
                let callReason = extractCallReason(aiResponse);
                
                // å»¶è¿Ÿ2-5ç§’åè§¦å‘æ¥ç”µ
                const delay = 2000 + Math.random() * 3000;
                console.log(`ğŸ”” å°†åœ¨${Math.round(delay/1000)}ç§’åå‘èµ·æ¥ç”µï¼Œç†ç”±: ${callReason}`);
                
                setTimeout(() => {
                    console.log('ğŸ”” å¼€å§‹å‘èµ·AIæ¥ç”µ');
                    initiateAICall(currentChatCharacter, callReason);
                }, delay);
                
                return true;
            } else {
                console.log('ğŸ”” AIä¸»åŠ¨æ‹¨æ‰“æœªè§¦å‘ï¼Œæ¦‚ç‡:', triggerProbability);
            }
            
            return false;
        }
        
        // ä»AIå›å¤ä¸­æå–é€šè¯ç†ç”±
        function extractCallReason(aiResponse) {
            // é»˜è®¤ç†ç”±
            let defaultReasons = [
                'æƒ³å’Œä½ èŠèŠå¤©',
                'æœ‰äº‹æƒ…æƒ³å‘Šè¯‰ä½ ',
                'æƒ³å¬å¬ä½ çš„å£°éŸ³',
                'æƒ³å’Œä½ è¯´è¯´è¯'
            ];
            
            // å°è¯•ä»å›å¤ä¸­æå–ä¸€ä¸ªåˆç†çš„å¥å­ä½œä¸ºç†ç”±
            const sentences = aiResponse.split(/[ã€‚ï¼ï¼Ÿ.!?]/);
            const validSentences = sentences.filter(s => {
                const trimmed = s.trim();
                return trimmed.length > 5 && trimmed.length < 20 && !trimmed.includes('æˆ‘');
            });
            
            if (validSentences.length > 0) {
                return validSentences[Math.floor(Math.random() * validSentences.length)].trim();
            }
            
            return defaultReasons[Math.floor(Math.random() * defaultReasons.length)];
        }

        function openVideoCall() {
            showToast('è§†é¢‘é€šè¯åŠŸèƒ½å¼€å‘ä¸­...', 'info');
            // è¿™é‡Œå¯ä»¥æ·»åŠ è§†é¢‘é€šè¯åŠŸèƒ½
        }

        function shareLocation() {
            if (!currentChatCharacter) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè§’è‰²');
                return;
            }
            
            // é‡ç½®è¾“å…¥æ¡†
            document.getElementById('location-address').value = '';
            document.getElementById('map-location-display').textContent = 'è¯·è¾“å…¥ä½ç½®åç§°';
            
            // éšæœºåŒ–åœ°å›¾æ˜¾ç¤º
            randomizeMapPosition();
            
            // åŠ è½½å†å²è®°å½•
            renderLocationHistory();
            
            // æ˜¾ç¤ºæ¨¡æ€æ¡†
            document.getElementById('location-modal').style.display = 'flex';
        }

        function hideLocationModal() {
            document.getElementById('location-modal').style.display = 'none';
        }

        function setLocationAddress(address) {
            document.getElementById('location-address').value = address;
            document.getElementById('map-location-display').textContent = address;
            
            // ç”Ÿæˆéšæœºåæ ‡
            const lat = (39.8 + Math.random() * 0.4).toFixed(4);
            const lng = (116.2 + Math.random() * 0.4).toFixed(4);
            document.querySelector('.map-coordinates').textContent = `${lng}Â°E, ${lat}Â°N`;
        }

        function randomizeMapPosition() {
            const marker = document.getElementById('location-marker');
            const buildings = document.querySelectorAll('.building');
            
            // éšæœºç§»åŠ¨æ ‡è®°ä½ç½®
            const newTop = 20 + Math.random() * 60; // 20% - 80%
            const newLeft = 20 + Math.random() * 60; // 20% - 80%
            marker.style.top = newTop + '%';
            marker.style.left = newLeft + '%';
            
            // éšæœºç§»åŠ¨å»ºç­‘ç‰©
            buildings.forEach(building => {
                const top = Math.random() * 85; // 0% - 85%
                const left = Math.random() * 85; // 0% - 85%
                building.style.top = top + '%';
                building.style.left = left + '%';
            });
            
            // æ›´æ–°åæ ‡
            const lat = (39.8 + Math.random() * 0.4).toFixed(4);
            const lng = (116.2 + Math.random() * 0.4).toFixed(4);
            document.querySelector('.map-coordinates').textContent = `${lng}Â°E, ${lat}Â°N`;
        }

        // ç”Ÿæˆé€¼çœŸçš„åœ°å›¾HTMLå†…å®¹
        function generateRealisticMapHTML() {
            return `
                <div class="map-background"></div>
                <!-- å¼¯æ›²æ²³æµ -->
                <div class="river" style="top: 5%; left: 60%; width: 20px; height: 3px; transform: rotate(35deg);"></div>
                <div class="river-curve" style="top: 12%; left: 72%; width: 18px; height: 3px; transform: rotate(15deg);"></div>
                <div class="river" style="top: 18%; left: 80%; width: 16px; height: 3px; transform: rotate(-5deg);"></div>
                <div class="river-curve" style="top: 22%; left: 85%; width: 15px; height: 3px; transform: rotate(-25deg);"></div>
                <div class="river" style="top: 55%; left: 2%; width: 22px; height: 3px; transform: rotate(-10deg);"></div>
                <div class="river-curve" style="top: 62%; left: 18%; width: 20px; height: 3px; transform: rotate(8deg);"></div>
                <div class="river" style="top: 68%; left: 32%; width: 18px; height: 3px; transform: rotate(25deg);"></div>
                <!-- å…¬å›­ç»¿åœ° -->
                <div class="park" style="top: 20%; left: 65%; width: 18px; height: 15px;"></div>
                <div class="park" style="top: 45%; left: 10%; width: 22px; height: 18px;"></div>
                <!-- é“è·¯ -->
                <div class="map-roads">
                    <div class="road road-horizontal" style="top: 35%; width: 100%;"></div>
                    <div class="road road-vertical" style="left: 40%; height: 100%;"></div>
                    <div class="road road-horizontal" style="top: 65%; width: 70%; left: 30%;"></div>
                </div>
                <!-- å»ºç­‘ç‰© -->
                <div class="map-buildings">
                    <div class="building house" style="top: 15%; left: 20%; width: 12px; height: 10px;"></div>
                    <div class="building office" style="top: 25%; left: 45%; width: 8px; height: 16px;"></div>
                    <div class="building shop" style="top: 50%; left: 50%; width: 14px; height: 8px;"></div>
                    <div class="building house" style="top: 70%; left: 75%; width: 10px; height: 8px;"></div>
                    <div class="building office" style="top: 8%; left: 85%; width: 6px; height: 12px;"></div>
                </div>
                <!-- æ ‘æœ¨ -->
                <div class="tree big" style="top: 25%; left: 15%; width: 6px; height: 6px;"></div>
                <div class="tree small" style="top: 55%; left: 25%; width: 4px; height: 4px;"></div>
                <div class="tree big" style="top: 10%; left: 70%; width: 5px; height: 5px;"></div>
                <div class="tree small" style="top: 75%; left: 85%; width: 3px; height: 3px;"></div>
                <div class="tree small" style="top: 40%; left: 80%; width: 4px; height: 4px;"></div>
                <!-- ä½ç½®æ ‡è®° -->
                <div class="map-marker">
                    <div class="marker-pin">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                            <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                        </svg>
                    </div>
                </div>
            `;
        }

        // å†å²åœ°ç‚¹ç®¡ç†
        let locationHistory = JSON.parse(localStorage.getItem('locationHistory') || '[]');

        function saveLocationHistory() {
            localStorage.setItem('locationHistory', JSON.stringify(locationHistory));
        }

        function addToLocationHistory(locationName) {
            if (!locationName.trim()) return;
            
            // ç§»é™¤é‡å¤é¡¹
            locationHistory = locationHistory.filter(name => name !== locationName);
            // æ·»åŠ åˆ°å¼€å¤´
            locationHistory.unshift(locationName);
            // é™åˆ¶æœ€å¤šä¿å­˜10ä¸ª
            if (locationHistory.length > 10) {
                locationHistory = locationHistory.slice(0, 10);
            }
            
            saveLocationHistory();
            renderLocationHistory();
        }

        function removeFromLocationHistory(locationName) {
            locationHistory = locationHistory.filter(name => name !== locationName);
            saveLocationHistory();
            renderLocationHistory();
        }

        function renderLocationHistory() {
            const container = document.getElementById('location-history-items');
            if (!container) return;

            if (locationHistory.length === 0) {
                container.innerHTML = '<div class="location-history-empty">æš‚æ— å†å²è®°å½•</div>';
                return;
            }

            container.innerHTML = locationHistory.map(location =>
                `<div class="location-history-item" data-location="${location}">
                    <span class="location-text">${location}</span>
                    <span class="delete-btn" data-location="${location}" title="åˆ é™¤">Ã—</span>
                </div>`
            ).join('');

            // ğŸ”¥ã€ä¿®å¤ã€‘ä½¿ç”¨äº‹ä»¶å§”æ‰˜ç»‘å®šç‚¹å‡»äº‹ä»¶ï¼Œé¿å…å†…è”onclické—®é¢˜
            container.onclick = function(e) {
                const locationItem = e.target.closest('.location-history-item');
                if (!locationItem) return;

                const location = locationItem.dataset.location;

                if (e.target.classList.contains('delete-btn')) {
                    // ç‚¹å‡»åˆ é™¤æŒ‰é’®
                    e.stopPropagation();
                    confirmDeleteLocation(location);
                } else {
                    // ç‚¹å‡»ä½ç½®é¡¹
                    setLocationAddress(location);
                }
            };
        }

        // é•¿æŒ‰åˆ é™¤å¤„ç†
        let touchTimer = null;
        let touchedElement = null;

        function handleLocationTouchStart(event, location) {
            touchedElement = event.target;
            touchTimer = setTimeout(() => {
                confirmDeleteLocation(location);
            }, 800); // 800msé•¿æŒ‰
        }

        function handleLocationTouchEnd(event) {
            if (touchTimer) {
                clearTimeout(touchTimer);
                touchTimer = null;
            }
            if (touchedElement) {
                touchedElement.classList.remove('deleting');
                touchedElement = null;
            }
        }

        function confirmDeleteLocation(location) {
            if (touchedElement) {
                touchedElement.classList.add('deleting');
            }
            
            if (confirm(`ç¡®å®šè¦åˆ é™¤ä½ç½®"${location}"å—ï¼Ÿ`)) {
                removeFromLocationHistory(location);
                showToast('ä½ç½®å·²åˆ é™¤', 'success');
            } else if (touchedElement) {
                touchedElement.classList.remove('deleting');
            }
        }

        function sendLocationMessage() {
            const address = document.getElementById('location-address').value.trim();
            if (!address) {
                alert('è¯·è¾“å…¥ä½ç½®åç§°');
                return;
            }

            // æ·»åŠ åˆ°å†å²è®°å½•
            addToLocationHistory(address);

            // åˆ›å»ºä½ç½®æ¶ˆæ¯
            const locationMessage = {
                id: Date.now().toString(),
                sender: 'sent',
                type: 'location',
                locationName: address,
                coordinates: document.querySelector('.map-coordinates').textContent,
                content: `[ç”¨æˆ·åˆ†äº«äº†ä½ç½®ä¿¡æ¯ï¼š${address}ï¼Œåæ ‡ï¼š${document.querySelector('.map-coordinates').textContent}]`,
                timestamp: Date.now()
            };

            console.log('ğŸ—ºï¸ åˆ›å»ºä½ç½®æ¶ˆæ¯:', locationMessage);
            
            // ğŸ”¥ã€è°ƒè¯•ã€‘æ£€æŸ¥æ¶ˆæ¯æ•°æ®
            if (!locationMessage.locationName || !locationMessage.coordinates) {
                console.error('âŒ ä½ç½®æ¶ˆæ¯æ•°æ®ä¸å®Œæ•´:', {
                    locationName: locationMessage.locationName,
                    coordinates: locationMessage.coordinates
                });
                alert('ä½ç½®ä¿¡æ¯ä¸å®Œæ•´ï¼Œè¯·é‡è¯•');
                return;
            }

            // æ·»åŠ åˆ°èŠå¤©è®°å½•
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            chatMessages[currentChatCharacter.id].push(locationMessage);

            // ä¿å­˜åˆ°æ•°æ®åº“
            saveChatMessages();

            // ä½¿ç”¨åŠ¨ç”»æ·»åŠ æ¶ˆæ¯è€Œä¸æ˜¯é‡æ–°æ¸²æŸ“æ•´ä¸ªåˆ—è¡¨
            addMessageWithAnimation(locationMessage, currentChatCharacter.id);

            // è®¾ç½®ä¸ºå¾…å›å¤æ¶ˆæ¯
            pendingUserMessage = locationMessage;

            // æ›´æ–°æ™ºèƒ½å›å¤æŒ‰é’®çŠ¶æ€
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = 'ç‚¹å‡»è·å–AIå›å¤';
            }

            // æ›´æ–°è”ç³»äººåˆ—è¡¨
            renderMessageList();

            // å…³é—­æ¨¡æ€æ¡†
            hideLocationModal();

            showToast('ä½ç½®å·²åˆ†äº«', 'success');
        }

        // æ›´æ–°å·²å­˜åœ¨çš„ä½ç½®å¡ç‰‡åœ°å›¾
        function updateExistingLocationMaps() {
            const locationMaps = document.querySelectorAll('.location-card-map');
            locationMaps.forEach(mapElement => {
                // æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°ï¼ˆæ²¡æœ‰æ–°çš„åœ°å›¾å…ƒç´ ï¼‰
                if (!mapElement.querySelector('.river')) {
                    mapElement.innerHTML = generateRealisticMapHTML();
                }
            });
        }

        // ç›‘å¬ä½ç½®è¾“å…¥æ¡†çš„å˜åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            const locationInput = document.getElementById('location-address');
            if (locationInput) {
                locationInput.addEventListener('input', function() {
                    const value = this.value.trim();
                    if (value) {
                        document.getElementById('map-location-display').textContent = value;
                        
                        // ç”Ÿæˆéšæœºåæ ‡
                        const lat = (39.8 + Math.random() * 0.4).toFixed(4);
                        const lng = (116.2 + Math.random() * 0.4).toFixed(4);
                        document.querySelector('.map-coordinates').textContent = `${lng}Â°E, ${lat}Â°N`;
                    } else {
                        document.getElementById('map-location-display').textContent = 'è¯·è¾“å…¥ä½ç½®åç§°';
                    }
                });
            }
            
            // ç‚¹å‡»æ¨¡æ€æ¡†èƒŒæ™¯å…³é—­
            document.getElementById('location-modal')?.addEventListener('click', (e) => {
                if (e.target === document.getElementById('location-modal')) {
                    hideLocationModal();
                }
            });

            // å®šæœŸæ›´æ–°ç°æœ‰çš„ä½ç½®å¡ç‰‡åœ°å›¾
            setInterval(updateExistingLocationMaps, 1000);
        });

        // æ˜¾ç¤ºä½ç½®è¯¦æƒ…
        function showLocationDetail(locationName) {
            alert(`ğŸ—ºï¸ ${locationName}`);
        }
 
        // ğŸ“Š æ•°æ®ç®¡ç†ç›¸å…³å‡½æ•°
        
        // è®¡ç®—å­˜å‚¨ç©ºé—´ä½¿ç”¨æƒ…å†µ
        async function calculateStorageUsage() {
            try {
                let chatSize = 0, characterSize = 0, settingsSize = 0, emojiSize = 0;

                const [chatData, charData, settingsData, emojiData] = await Promise.all([
                    db.chatMessages.toArray(),
                    db.characters.toArray(), 
                    db.chatSettings.toArray(),
                    db.customEmojis.toArray()
                ]);

                chatSize = JSON.stringify(chatData).length;
                characterSize = JSON.stringify(charData).length;
                settingsSize = JSON.stringify(settingsData).length;
                emojiSize = JSON.stringify(emojiData).length;
                const total = chatSize + characterSize + settingsSize + emojiSize;

                // æ›´æ–°æ˜¾ç¤º
                const formatBytes = (bytes) => {
                    if (bytes === 0) return '0 B';
                    const k = 1024;
                    const sizes = ['B', 'KB', 'MB', 'GB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                };

                if (document.getElementById('chat-storage-size')) {
                    document.getElementById('chat-storage-size').textContent = formatBytes(chatSize);
                    document.getElementById('character-storage-size').textContent = formatBytes(characterSize);
                    document.getElementById('settings-storage-size').textContent = formatBytes(settingsSize);
                    document.getElementById('emoji-storage-size').textContent = formatBytes(emojiSize);
                    document.getElementById('total-storage-size').textContent = formatBytes(total);
                }
            } catch (error) {
                console.error('è®¡ç®—å­˜å‚¨å¤±è´¥:', error);
            }
        }

        // å¯¼å‡ºæ‰€æœ‰æ•°æ®
        async function exportAllData() {
            try {
                showToast('æ­£åœ¨å¯¼å‡ºæ•°æ®...', 'info');

                // ğŸ”¥ã€è°ƒè¯•ã€‘æ£€æŸ¥æ•°æ®åº“ç‰ˆæœ¬å’Œè¡¨æ˜¯å¦å­˜åœ¨
                console.log('ğŸ” æ•°æ®åº“ç‰ˆæœ¬:', db.verno);
                console.log('ğŸ” æ•°æ®åº“è¡¨åˆ—è¡¨:', db.tables.map(t => t.name));

                // ğŸ”¥ã€å®Œå–„ã€‘å¯¼å‡ºæ‰€æœ‰é‡è¦æ•°æ®è¡¨ï¼Œç¡®ä¿åŒ…å«å…¨éƒ¨åŠŸèƒ½æ•°æ®
                const exportData = {
                    version: '5.0', // æ›´æ–°ç‰ˆæœ¬å·ï¼ŒåŒ…å«å®Œæ•´æ•°æ®
                    exportTime: new Date().toISOString(),
                    // åŸºç¡€æ•°æ®
                    characters: await db.characters.toArray(),
                    chatMessages: await db.chatMessages.toArray(),
                    chatSettings: await db.chatSettings.toArray(),
                    contacts: await db.contacts.toArray(),
                    // ç”¨æˆ·é¢å…·ç³»ç»Ÿ
                    personas: await db.personas.toArray(),
                    // è¡¨æƒ…åŒ…ç³»ç»Ÿ
                    customEmojis: await db.customEmojis.toArray(),
                    recentEmojis: await db.recentEmojis.toArray(),
                    // ä¸–ç•Œä¹¦ç³»ç»Ÿ
                    worldbooks: await db.worldbooks.toArray(),
                    worldbookEntries: await db.worldbookEntries.toArray(),
                    // ç¾¤èŠç³»ç»Ÿ
                    characterGroups: await db.characterGroups.toArray(),
                    groupChats: await db.groupChats.toArray(),
                    groupChatMessages: await db.groupChatMessages.toArray(),
                    groupChatMembers: await db.groupChatMembers.toArray(),
                    // åŠ¨æ€ç³»ç»Ÿ
                    moments: await db.moments.toArray(),
                    momentLikes: await db.momentLikes.toArray(),
                    momentComments: await db.momentComments.toArray(),
                    // è®°å¿†ç³»ç»Ÿ
                    workingMemory: await db.workingMemory.toArray(),
                    episodicMemory: await db.episodicMemory.toArray(),
                    coreMemory: await db.coreMemory.toArray(),
                    crossAppTimeline: await db.crossAppTimeline.toArray(),
                    // æ‹‰é»‘å’Œå¥½å‹ç³»ç»Ÿ
                    blockedCharacters: await db.blockedCharacters.toArray(),
                    friendRequests: await db.friendRequests.toArray(),
                    characterStatus: await db.characterStatus.toArray(),
                    // æ—¥è®°ç³»ç»Ÿ
                    characterDiaries: await db.characterDiaries.toArray(),
                    // çº¿ä¸‹æ¨¡å¼ç³»ç»Ÿ
                    offlineHistoryRecords: await db.offlineHistoryRecords.toArray(),
                    offlineUISettings: await db.offlineUISettings.toArray(),
                    offlinePresets: await db.offlinePresets.toArray(),
                    // éŸ³ä¹æ’­æ”¾å™¨ç³»ç»Ÿ
                    musicPlaylist: await db.musicPlaylist.toArray(),
                    musicCovers: await db.musicCovers.toArray(),
                    // è®¾ç½®å’Œé…ç½®
                    apiSettings: await db.apiSettings.toArray(),
                    globalSettings: await db.globalSettings.toArray(),
                    wallpapers: await db.wallpapers.toArray(),
                    appIcons: await db.appIcons.toArray()
                };

                // æ˜¾ç¤ºå¯¼å‡ºç»Ÿè®¡
                const stats = [];
                // åŸºç¡€æ•°æ®ç»Ÿè®¡
                if (exportData.characters?.length) stats.push(`è§’è‰²: ${exportData.characters.length}ä¸ª`);
                if (exportData.chatMessages?.length) stats.push(`æ¶ˆæ¯: ${exportData.chatMessages.length}æ¡`);
                if (exportData.personas?.length) stats.push(`é¢å…·: ${exportData.personas.length}ä¸ª`);
                if (exportData.contacts?.length) stats.push(`è”ç³»äºº: ${exportData.contacts.length}ä¸ª`);
                // è¡¨æƒ…åŒ…ç³»ç»Ÿ
                if (exportData.customEmojis?.length) stats.push(`è¡¨æƒ…: ${exportData.customEmojis.length}ä¸ª`);
                if (exportData.recentEmojis?.length) stats.push(`æœ€è¿‘è¡¨æƒ…: ${exportData.recentEmojis.length}ä¸ª`);
                // ä¸–ç•Œä¹¦ç³»ç»Ÿ
                if (exportData.worldbooks?.length) stats.push(`ä¸–ç•Œä¹¦: ${exportData.worldbooks.length}ä¸ª`);
                if (exportData.worldbookEntries?.length) stats.push(`ä¸–ç•Œä¹¦æ¡ç›®: ${exportData.worldbookEntries.length}æ¡`);
                // ç¾¤èŠç³»ç»Ÿ
                if (exportData.groupChats?.length) stats.push(`ç¾¤èŠ: ${exportData.groupChats.length}ä¸ª`);
                if (exportData.groupChatMessages?.length) stats.push(`ç¾¤èŠæ¶ˆæ¯: ${exportData.groupChatMessages.length}æ¡`);
                // åŠ¨æ€ç³»ç»Ÿ
                if (exportData.moments?.length) stats.push(`åŠ¨æ€: ${exportData.moments.length}æ¡`);
                if (exportData.momentComments?.length) stats.push(`åŠ¨æ€è¯„è®º: ${exportData.momentComments.length}æ¡`);
                // è®°å¿†ç³»ç»Ÿ
                if (exportData.workingMemory?.length) stats.push(`å·¥ä½œè®°å¿†: ${exportData.workingMemory.length}æ¡`);
                if (exportData.episodicMemory?.length) stats.push(`æƒ…èŠ‚è®°å¿†: ${exportData.episodicMemory.length}æ¡`);
                if (exportData.coreMemory?.length) stats.push(`æ ¸å¿ƒè®°å¿†: ${exportData.coreMemory.length}æ¡`);
                if (exportData.crossAppTimeline?.length) stats.push(`æ—¶é—´çº¿: ${exportData.crossAppTimeline.length}æ¡`);
                // æ—¥è®°ç³»ç»Ÿ
                if (exportData.characterDiaries?.length) stats.push(`æ—¥è®°: ${exportData.characterDiaries.length}æ¡`);
                // çº¿ä¸‹æ¨¡å¼
                if (exportData.offlineHistoryRecords?.length) stats.push(`çº¿ä¸‹è®°å½•: ${exportData.offlineHistoryRecords.length}æ¡`);
                if (exportData.offlinePresets?.length) stats.push(`çº¿ä¸‹é¢„è®¾: ${exportData.offlinePresets.length}ä¸ª`);
                // éŸ³ä¹ç³»ç»Ÿ
                if (exportData.musicPlaylist?.length) stats.push(`éŸ³ä¹: ${exportData.musicPlaylist.length}é¦–`);
                // è®¾ç½®æ•°æ®
                if (exportData.chatSettings?.length) stats.push(`èŠå¤©è®¾ç½®: ${exportData.chatSettings.length}ä¸ª`);
                if (exportData.wallpapers?.length) stats.push(`å£çº¸: ${exportData.wallpapers.length}ä¸ª`);
                
                console.log('å¯¼å‡ºæ•°æ®ç»Ÿè®¡:', stats.join(', '));

                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `å®Œæ•´å¤‡ä»½_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                const statsText = stats.length > 0 ? `\n${stats.join('\n')}` : '';
                showToast(`å¯¼å‡ºæˆåŠŸï¼${statsText}`, 'success');
            } catch (error) {
                console.error('å¯¼å‡ºå¤±è´¥:', error);
                showToast('å¯¼å‡ºå¤±è´¥: ' + error.message, 'error');
            }
        }

        // ğŸ”¥ã€ç»ˆæä¿®å¤ã€‘å¯¼å…¥æ•°æ® - ä¸“é—¨è§£å†³è”ç³»äººå’Œæ¶ˆæ¯æ˜¾ç¤ºé—®é¢˜
        function importDataFromFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async function(e) {
                const file = e.target.files[0];
                if (!file) return;
                try {
                    showToast('æ­£åœ¨å¯¼å…¥...', 'info');
                    const text = await file.text();
                    
                    // å°è¯•è§£æJSON
                    let data;
                    try {
                        data = JSON.parse(text);
                    } catch (parseError) {
                        throw new Error('JSONæ ¼å¼é”™è¯¯ï¼š' + parseError.message);
                    }
                    
                    // æ£€æŸ¥æ•°æ®æ ¼å¼
                    if (!data || typeof data !== 'object') {
                        throw new Error('æ— æ•ˆçš„å¤‡ä»½æ–‡ä»¶æ ¼å¼');
                    }
                    
                    // ğŸ”¥ã€å®Œå–„ã€‘æ˜¾ç¤ºå¯¼å…¥é¢„è§ˆï¼ŒåŒ…æ‹¬æ‰€æœ‰æ•°æ®è¡¨
                    const dataPreview = [];
                    // åŸºç¡€æ•°æ®
                    if (data.characters?.length) dataPreview.push(`è§’è‰²: ${data.characters.length}ä¸ª`);
                    if (data.chatMessages?.length) dataPreview.push(`èŠå¤©æ¶ˆæ¯: ${data.chatMessages.length}æ¡`);
                    if (data.personas?.length) dataPreview.push(`ç”¨æˆ·é¢å…·: ${data.personas.length}ä¸ª`);
                    if (data.contacts?.length) dataPreview.push(`è”ç³»äºº: ${data.contacts.length}ä¸ª`);
                    // è¡¨æƒ…åŒ…ç³»ç»Ÿ
                    if (data.customEmojis?.length) dataPreview.push(`è‡ªå®šä¹‰è¡¨æƒ…: ${data.customEmojis.length}ä¸ª`);
                    if (data.recentEmojis?.length) dataPreview.push(`æœ€è¿‘è¡¨æƒ…: ${data.recentEmojis.length}ä¸ª`);
                    // ä¸–ç•Œä¹¦ç³»ç»Ÿ
                    if (data.worldbooks?.length) dataPreview.push(`ä¸–ç•Œä¹¦: ${data.worldbooks.length}ä¸ª`);
                    if (data.worldbookEntries?.length) dataPreview.push(`ä¸–ç•Œä¹¦æ¡ç›®: ${data.worldbookEntries.length}æ¡`);
                    // ç¾¤èŠç³»ç»Ÿ
                    if (data.groupChats?.length) dataPreview.push(`ç¾¤èŠ: ${data.groupChats.length}ä¸ª`);
                    if (data.groupChatMessages?.length) dataPreview.push(`ç¾¤èŠæ¶ˆæ¯: ${data.groupChatMessages.length}æ¡`);
                    if (data.groupChatMembers?.length) dataPreview.push(`ç¾¤èŠæˆå‘˜: ${data.groupChatMembers.length}ä¸ª`);
                    // åŠ¨æ€ç³»ç»Ÿ
                    if (data.moments?.length) dataPreview.push(`åŠ¨æ€: ${data.moments.length}æ¡`);
                    if (data.momentComments?.length) dataPreview.push(`åŠ¨æ€è¯„è®º: ${data.momentComments.length}æ¡`);
                    if (data.momentLikes?.length) dataPreview.push(`åŠ¨æ€ç‚¹èµ: ${data.momentLikes.length}æ¡`);
                    // è®°å¿†ç³»ç»Ÿ
                    if (data.workingMemory?.length) dataPreview.push(`å·¥ä½œè®°å¿†: ${data.workingMemory.length}æ¡`);
                    if (data.episodicMemory?.length) dataPreview.push(`æƒ…èŠ‚è®°å¿†: ${data.episodicMemory.length}æ¡`);
                    if (data.coreMemory?.length) dataPreview.push(`æ ¸å¿ƒè®°å¿†: ${data.coreMemory.length}æ¡`);
                    if (data.crossAppTimeline?.length) dataPreview.push(`æ—¶é—´çº¿è®°å½•: ${data.crossAppTimeline.length}æ¡`);
                    // æ‹‰é»‘å’Œå¥½å‹ç³»ç»Ÿ
                    if (data.blockedCharacters?.length) dataPreview.push(`æ‹‰é»‘è®°å½•: ${data.blockedCharacters.length}æ¡`);
                    if (data.friendRequests?.length) dataPreview.push(`å¥½å‹ç”³è¯·: ${data.friendRequests.length}æ¡`);
                    if (data.characterStatus?.length) dataPreview.push(`è§’è‰²çŠ¶æ€: ${data.characterStatus.length}æ¡`);
                    // æ—¥è®°ç³»ç»Ÿ
                    if (data.characterDiaries?.length) dataPreview.push(`è§’è‰²æ—¥è®°: ${data.characterDiaries.length}æ¡`);
                    // çº¿ä¸‹æ¨¡å¼
                    if (data.offlineHistoryRecords?.length) dataPreview.push(`çº¿ä¸‹è®°å½•: ${data.offlineHistoryRecords.length}æ¡`);
                    if (data.offlineUISettings?.length) dataPreview.push(`çº¿ä¸‹ç•Œé¢è®¾ç½®: ${data.offlineUISettings.length}ä¸ª`);
                    if (data.offlinePresets?.length) dataPreview.push(`çº¿ä¸‹é¢„è®¾: ${data.offlinePresets.length}ä¸ª`);
                    // éŸ³ä¹ç³»ç»Ÿ
                    if (data.musicPlaylist?.length) dataPreview.push(`éŸ³ä¹: ${data.musicPlaylist.length}é¦–`);
                    if (data.musicCovers?.length) dataPreview.push(`éŸ³ä¹å°é¢: ${data.musicCovers.length}ä¸ª`);
                    // è®¾ç½®æ•°æ®
                    if (data.chatSettings?.length) dataPreview.push(`èŠå¤©è®¾ç½®: ${data.chatSettings.length}ä¸ª`);
                    if (data.apiSettings?.length) dataPreview.push(`APIè®¾ç½®: ${data.apiSettings.length}ä¸ª`);
                    if (data.globalSettings?.length) dataPreview.push(`å…¨å±€è®¾ç½®: ${data.globalSettings.length}ä¸ª`);
                    if (data.wallpapers?.length) dataPreview.push(`å£çº¸: ${data.wallpapers.length}ä¸ª`);
                    if (data.appIcons?.length) dataPreview.push(`åº”ç”¨å›¾æ ‡: ${data.appIcons.length}ä¸ª`);
                    
                    const previewText = dataPreview.length > 0 ? 
                        `å°†å¯¼å…¥ä»¥ä¸‹æ•°æ®ï¼š\n${dataPreview.join('\n')}\n\nå¯¼å…¥å°†è¦†ç›–ç°æœ‰æ•°æ®ï¼Œç¡®å®šç»§ç»­ï¼Ÿ` : 
                        'å¤‡ä»½æ–‡ä»¶ä¸­æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆæ•°æ®ï¼Œç¡®å®šç»§ç»­ï¼Ÿ';
                    
                    if (!confirm(previewText)) return;
                    
                    // ğŸ”¥ã€ä¿®å¤ã€‘ä½¿ç”¨bulkPutä»£æ›¿bulkAddé¿å…ä¸»é”®å†²çª
                    let importedTables = 0;
                    
                    // å¯¼å…¥è§’è‰²æ•°æ®
                    if (data.characters?.length) {
                        try {
                            // ğŸ”¥ã€å®‰å…¨ä¿®å¤ã€‘ç¡®ä¿æ¯ä¸ªè§’è‰²éƒ½æœ‰æœ‰æ•ˆID
                            const validCharacters = data.characters.map(char => ({
                                ...char,
                                id: char.id || `char_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));

                            // ä½¿ç”¨å®‰å…¨ä¿å­˜å‡½æ•°
                            await safeDataSave('characters', validCharacters);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validCharacters.length} ä¸ªè§’è‰²`);
                        } catch (error) {
                            console.error('å¯¼å…¥è§’è‰²å¤±è´¥:', error);
                            showToast('è§’è‰²å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }
                    
                    // ğŸ”¥ã€ä¿®å¤ã€‘å¯¼å…¥èŠå¤©æ¶ˆæ¯ - å¤„ç†æ ¼å¼è½¬æ¢
                    if (data.chatMessages?.length) {
                        try {
                            console.log('ğŸ”„ å¼€å§‹å¯¼å…¥èŠå¤©æ¶ˆæ¯ï¼ŒåŸå§‹æ•°æ®:', data.chatMessages.length, 'æ¡');

                            // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘æ£€æŸ¥æ•°æ®æ ¼å¼å¹¶è½¬æ¢
                            let processedMessages = [];

                            // æ£€æŸ¥æ˜¯å¦æ˜¯æ–°æ ¼å¼ï¼ˆåŒ…å«messageDataå­—æ®µï¼‰
                            const isNewFormat = data.chatMessages.some(msg => msg.messageData);

                            if (isNewFormat) {
                                // æ–°æ ¼å¼ï¼šç›´æ¥ä½¿ç”¨
                                console.log('ğŸ“ æ£€æµ‹åˆ°æ–°æ ¼å¼æ•°æ®ï¼ˆåŒ…å«messageDataï¼‰');
                                processedMessages = data.chatMessages.map(msg => ({
                                    ...msg,
                                    id: msg.id || `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                            } else {
                                // æ—§æ ¼å¼ï¼šéœ€è¦è½¬æ¢ä¸ºæ–°æ ¼å¼
                                console.log('ğŸ“ æ£€æµ‹åˆ°æ—§æ ¼å¼æ•°æ®ï¼Œæ­£åœ¨è½¬æ¢...');

                                // å…ˆé‡å»ºchatMessageså¯¹è±¡ç»“æ„
                                const tempChatMessages = {};
                                for (const msg of data.chatMessages) {
                                    const characterId = msg.characterId;
                                    if (!tempChatMessages[characterId]) {
                                        tempChatMessages[characterId] = [];
                                    }
                                    tempChatMessages[characterId].push(msg);
                                }

                                // ç„¶åè½¬æ¢ä¸ºæ–°æ ¼å¼
                                let globalSequentialId = 0;
                                for (const [characterId, messages] of Object.entries(tempChatMessages)) {
                                    for (let i = 0; i < messages.length; i++) {
                                        const message = messages[i];
                                        processedMessages.push({
                                            id: `${characterId}_${globalSequentialId++}`,
                                            characterId: characterId,
                                            timestamp: message.timestamp,
                                            messageOrder: i,
                                            originalMessageId: message.id,
                                            messageData: message
                                        });
                                    }
                                }
                                console.log(`ğŸ“ æ ¼å¼è½¬æ¢å®Œæˆï¼Œç”Ÿæˆ ${processedMessages.length} æ¡è®°å½•`);
                            }

                            // ğŸ”¥ã€å®‰å…¨ä¿®å¤ã€‘ä½¿ç”¨äº‹åŠ¡ç¡®ä¿åŸå­æ€§
                            await db.transaction('rw', db.chatMessages, async () => {
                                await db.chatMessages.clear();
                                await db.chatMessages.bulkAdd(processedMessages);
                            });

                            importedTables++;
                            console.log(`âœ… æˆåŠŸå¯¼å…¥äº† ${processedMessages.length} æ¡èŠå¤©æ¶ˆæ¯`);
                        } catch (error) {
                            console.error('âŒ å¯¼å…¥èŠå¤©æ¶ˆæ¯å¤±è´¥:', error);
                            showToast('èŠå¤©æ¶ˆæ¯å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }

                    // ğŸ”¥ã€æ¶æ„ä¿®å¤ã€‘ä¸å†éœ€è¦å•ç‹¬å¯¼å…¥è”ç³»äººæ•°æ®ï¼Œå› ä¸ºè”ç³»äººç°åœ¨ä»è§’è‰²åˆ—è¡¨è‡ªåŠ¨ç”Ÿæˆ
                    console.log('â„¹ï¸ è·³è¿‡è”ç³»äººå¯¼å…¥ï¼Œè”ç³»äººå°†ä»è§’è‰²åˆ—è¡¨è‡ªåŠ¨ç”Ÿæˆ');

                    // ğŸ”¥ã€æ–°å¢ã€‘å¯¼å…¥è®°å¿†ç³»ç»Ÿæ•°æ®
                    // å¯¼å…¥æ ¸å¿ƒè®°å¿†
                    if (data.coreMemory?.length || data.coreMemories?.length) {
                        try {
                            const coreMemoryData = data.coreMemory || data.coreMemories || [];
                            console.log('ğŸ”„ å¼€å§‹å¯¼å…¥æ ¸å¿ƒè®°å¿†ï¼ŒåŸå§‹æ•°æ®:', coreMemoryData.length, 'æ¡');
                            await db.coreMemory.clear();
                            if (data.coreMemories?.length) {
                                await db.coreMemories.clear();
                            }

                            const validCoreMemories = coreMemoryData.map(memory => ({
                                ...memory,
                                id: memory.id || `core_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));

                            await db.coreMemory.bulkAdd(validCoreMemories);
                            if (data.coreMemories?.length) {
                                await db.coreMemories.bulkAdd(validCoreMemories);
                            }
                            importedTables++;
                            console.log(`âœ… æˆåŠŸå¯¼å…¥äº† ${validCoreMemories.length} æ¡æ ¸å¿ƒè®°å¿†`);
                        } catch (error) {
                            console.error('âŒ å¯¼å…¥æ ¸å¿ƒè®°å¿†å¤±è´¥:', error);
                            showToast('æ ¸å¿ƒè®°å¿†å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }

                    // å¯¼å…¥æƒ…æ™¯è®°å¿†
                    if (data.episodicMemory?.length || data.episodicMemories?.length || data.memorySummaries?.length) {
                        try {
                            const episodicData = data.episodicMemory || data.episodicMemories || data.memorySummaries || [];
                            console.log('ğŸ”„ å¼€å§‹å¯¼å…¥æƒ…æ™¯è®°å¿†ï¼ŒåŸå§‹æ•°æ®:', episodicData.length, 'æ¡');
                            await db.episodicMemory.clear();
                            if (data.episodicMemories?.length) {
                                await db.episodicMemories.clear();
                            }
                            if (data.memorySummaries?.length) {
                                await db.memorySummaries.clear();
                            }

                            const validEpisodicMemories = episodicData.map(memory => ({
                                ...memory,
                                id: memory.id || `episodic_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));

                            await db.episodicMemory.bulkAdd(validEpisodicMemories);
                            if (data.episodicMemories?.length) {
                                await db.episodicMemories.bulkAdd(validEpisodicMemories);
                            }
                            if (data.memorySummaries?.length) {
                                await db.memorySummaries.bulkAdd(validEpisodicMemories);
                            }
                            importedTables++;
                            console.log(`âœ… æˆåŠŸå¯¼å…¥äº† ${validEpisodicMemories.length} æ¡æƒ…æ™¯è®°å¿†`);
                        } catch (error) {
                            console.error('âŒ å¯¼å…¥æƒ…æ™¯è®°å¿†å¤±è´¥:', error);
                            showToast('æƒ…æ™¯è®°å¿†å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }

                    // å¯¼å…¥å·¥ä½œè®°å¿†
                    if (data.workingMemory?.length) {
                        try {
                            console.log('ğŸ”„ å¼€å§‹å¯¼å…¥å·¥ä½œè®°å¿†ï¼ŒåŸå§‹æ•°æ®:', data.workingMemory.length, 'æ¡');
                            await db.workingMemory.clear();
                            const validWorkingMemories = data.workingMemory.map(memory => ({
                                ...memory,
                                id: memory.id || `working_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.workingMemory.bulkAdd(validWorkingMemories);
                            importedTables++;
                            console.log(`âœ… æˆåŠŸå¯¼å…¥äº† ${validWorkingMemories.length} æ¡å·¥ä½œè®°å¿†`);
                        } catch (error) {
                            console.error('âŒ å¯¼å…¥å·¥ä½œè®°å¿†å¤±è´¥:', error);
                            showToast('å·¥ä½œè®°å¿†å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }

                    // å¯¼å…¥å…¶ä»–å¯èƒ½çš„æ•°æ®
                    if (data.worldbooks?.length) {
                        try {
                            await db.worldbooks.clear();
                            const validWorldbooks = data.worldbooks.map(wb => ({
                                ...wb,
                                id: wb.id || `wb_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.worldbooks.bulkPut(validWorldbooks);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validWorldbooks.length} ä¸ªä¸–ç•Œä¹¦`);
                        } catch (error) {
                            console.error('å¯¼å…¥ä¸–ç•Œä¹¦å¤±è´¥:', error);
                            showToast('ä¸–ç•Œä¹¦å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }
                    
                    // ğŸ”¥ã€ä¿®å¤ã€‘å¯¼å…¥è‡ªå®šä¹‰è¡¨æƒ… - å®‰å…¨çš„å¯¼å…¥æ–¹å¼
                    if (data.customEmojis?.length) {
                        try {
                            // ğŸ”¥ã€å®‰å…¨ä¿®å¤ã€‘ä½¿ç”¨äº‹åŠ¡ç¡®ä¿åŸå­æ€§
                            await db.transaction('rw', db.customEmojis, async () => {
                                await db.customEmojis.clear();

                                const validEmojis = data.customEmojis.map(emoji => ({
                                    ...emoji,
                                    id: emoji.id || `emoji_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));

                                await db.customEmojis.bulkAdd(validEmojis);
                            });

                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${data.customEmojis.length} ä¸ªè‡ªå®šä¹‰è¡¨æƒ…`);
                        } catch (error) {
                            console.error('å¯¼å…¥è‡ªå®šä¹‰è¡¨æƒ…å¤±è´¥:', error);
                            showToast('è‡ªå®šä¹‰è¡¨æƒ…å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }
                    
                    // å¯¼å…¥å£çº¸
                    if (data.wallpapers?.length) {
                        try {
                            await db.wallpapers.clear();
                            const validWallpapers = data.wallpapers.map(wp => ({
                                ...wp,
                                id: wp.id || `wp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.wallpapers.bulkPut(validWallpapers);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validWallpapers.length} ä¸ªå£çº¸`);
                        } catch (error) {
                            console.error('å¯¼å…¥å£çº¸å¤±è´¥:', error);
                            showToast('å£çº¸å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }
                    
                    // å¯¼å…¥è§’è‰²åˆ†ç»„
                    if (data.characterGroups?.length) {
                        try {
                            await db.characterGroups.clear();
                            const validGroups = data.characterGroups.map(group => ({
                                ...group,
                                id: group.id || `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.characterGroups.bulkPut(validGroups);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validGroups.length} ä¸ªè§’è‰²åˆ†ç»„`);
                        } catch (error) {
                            console.error('å¯¼å…¥è§’è‰²åˆ†ç»„å¤±è´¥:', error);
                            showToast('è§’è‰²åˆ†ç»„å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }
                    
                    // å¯¼å…¥ç¾¤èŠ
                    if (data.groupChats?.length) {
                        try {
                            await db.groupChats.clear();
                            const validGroups = data.groupChats.map(chat => ({
                                ...chat,
                                id: chat.id || `chat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.groupChats.bulkPut(validGroups);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validGroups.length} ä¸ªç¾¤èŠ`);
                        } catch (error) {
                            console.error('å¯¼å…¥ç¾¤èŠå¤±è´¥:', error);
                            showToast('ç¾¤èŠå¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }
                    
                    // å¯¼å…¥ç”¨æˆ·é¢å…·
                    if (data.personas?.length) {
                        try {
                            console.log('ğŸ”„ å¼€å§‹å¯¼å…¥ç”¨æˆ·é¢å…·ï¼ŒåŸå§‹æ•°æ®:', data.personas.length, 'ä¸ª');
                            await db.personas.clear();
                            const validPersonas = data.personas.map((persona, index) => {
                                const result = {
                                    ...persona,
                                    id: persona.id || `persona_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                };
                                console.log(`å¤„ç†é¢å…· ${index + 1}:`, result);
                                return result;
                            });
                            await db.personas.bulkPut(validPersonas);
                            importedTables++;
                            console.log(`âœ… æˆåŠŸå¯¼å…¥äº† ${validPersonas.length} ä¸ªç”¨æˆ·é¢å…·`);
                        } catch (error) {
                            console.error('âŒ å¯¼å…¥ç”¨æˆ·é¢å…·å¤±è´¥:', error);
                            console.error('é¢å…·æ•°æ®è¯¦æƒ…:', data.personas);
                            showToast('ç”¨æˆ·é¢å…·å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    } else {
                        console.log('âš ï¸ æ²¡æœ‰æ‰¾åˆ°ç”¨æˆ·é¢å…·æ•°æ®');
                    }
                    
                    // å¯¼å…¥APIè®¾ç½®
                    if (data.apiSettings?.length) {
                        try {
                            await db.apiSettings.clear();
                            const validApiSettings = data.apiSettings.map(setting => ({
                                ...setting,
                                id: setting.id || `api_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.apiSettings.bulkPut(validApiSettings);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validApiSettings.length} ä¸ªAPIè®¾ç½®`);
                        } catch (error) {
                            console.error('å¯¼å…¥APIè®¾ç½®å¤±è´¥:', error);
                            showToast('APIè®¾ç½®å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }
                    
                    // å¯¼å…¥å…¨å±€è®¾ç½®
                    if (data.globalSettings?.length) {
                        try {
                            await db.globalSettings.clear();
                            const validGlobalSettings = data.globalSettings.map(setting => ({
                                ...setting,
                                id: setting.id || `global_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.globalSettings.bulkPut(validGlobalSettings);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validGlobalSettings.length} ä¸ªå…¨å±€è®¾ç½®`);
                        } catch (error) {
                            console.error('å¯¼å…¥å…¨å±€è®¾ç½®å¤±è´¥:', error);
                            showToast('å…¨å±€è®¾ç½®å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }
                    
                    // å¯¼å…¥æœ€è¿‘è¡¨æƒ…
                    if (data.recentEmojis?.length) {
                        try {
                            await db.recentEmojis.clear();
                            const validRecentEmojis = data.recentEmojis.map(emoji => ({
                                ...emoji,
                                id: emoji.id || `recent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.recentEmojis.bulkPut(validRecentEmojis);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validRecentEmojis.length} ä¸ªæœ€è¿‘è¡¨æƒ…`);
                        } catch (error) {
                            console.error('å¯¼å…¥æœ€è¿‘è¡¨æƒ…å¤±è´¥:', error);
                            showToast('æœ€è¿‘è¡¨æƒ…å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }
                    

                    
                    // å¯¼å…¥åº”ç”¨å›¾æ ‡
                    if (data.appIcons?.length) {
                        try {
                            await db.appIcons.clear();
                            const validAppIcons = data.appIcons.map(icon => ({
                                ...icon,
                                id: icon.id || `icon_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.appIcons.bulkPut(validAppIcons);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validAppIcons.length} ä¸ªåº”ç”¨å›¾æ ‡`);
                        } catch (error) {
                            console.error('å¯¼å…¥åº”ç”¨å›¾æ ‡å¤±è´¥:', error);
                            showToast('åº”ç”¨å›¾æ ‡å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }

                    if (data.memorySummaries?.length) {
                        try {
                            await db.memorySummaries.clear();
                            const validMemorySummaries = data.memorySummaries.map(summary => ({
                                ...summary,
                                id: summary.id || `summary_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.memorySummaries.bulkPut(validMemorySummaries);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validMemorySummaries.length} æ¡è®°å¿†æ‘˜è¦`);
                        } catch (error) {
                            console.error('å¯¼å…¥è®°å¿†æ‘˜è¦å¤±è´¥:', error);
                            showToast('è®°å¿†æ‘˜è¦å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }

                    if (data.memoryEvents?.length) {
                        try {
                            await db.memoryEvents.clear();
                            const validMemoryEvents = data.memoryEvents.map(event => ({
                                ...event,
                                id: event.id || `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.memoryEvents.bulkPut(validMemoryEvents);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validMemoryEvents.length} æ¡è®°å¿†äº‹ä»¶`);
                        } catch (error) {
                            console.error('å¯¼å…¥è®°å¿†äº‹ä»¶å¤±è´¥:', error);
                            showToast('è®°å¿†äº‹ä»¶å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }

                    if (data.crossAppTimeline?.length) {
                        try {
                            await db.crossAppTimeline.clear();
                            const validTimeline = data.crossAppTimeline.map(timeline => ({
                                ...timeline,
                                id: timeline.id || `timeline_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.crossAppTimeline.bulkPut(validTimeline);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validTimeline.length} æ¡è·¨åº”ç”¨æ—¶é—´çº¿`);
                        } catch (error) {
                            console.error('å¯¼å…¥è·¨åº”ç”¨æ—¶é—´çº¿å¤±è´¥:', error);
                            showToast('è·¨åº”ç”¨æ—¶é—´çº¿å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }

                    // ğŸ”¥ã€æ–°å¢ã€‘å¯¼å…¥æ‹‰é»‘å’Œå¥½å‹ç³»ç»Ÿè¡¨
                    if (data.blockedCharacters?.length) {
                        try {
                            await db.blockedCharacters.clear();
                            const validBlocked = data.blockedCharacters.map(item => ({
                                ...item,
                                id: item.id || `blocked_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.blockedCharacters.bulkPut(validBlocked);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validBlocked.length} æ¡æ‹‰é»‘è®°å½•`);
                        } catch (error) {
                            console.error('å¯¼å…¥æ‹‰é»‘è®°å½•å¤±è´¥:', error);
                            showToast('æ‹‰é»‘è®°å½•å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }

                    if (data.friendRequests?.length) {
                        try {
                            await db.friendRequests.clear();
                            const validRequests = data.friendRequests.map(req => ({
                                ...req,
                                id: req.id || `request_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.friendRequests.bulkPut(validRequests);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validRequests.length} æ¡å¥½å‹ç”³è¯·`);
                        } catch (error) {
                            console.error('å¯¼å…¥å¥½å‹ç”³è¯·å¤±è´¥:', error);
                            showToast('å¥½å‹ç”³è¯·å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }

                    if (data.characterStatus?.length) {
                        try {
                            await db.characterStatus.clear();
                            const validStatus = data.characterStatus.map(status => ({
                                ...status,
                                id: status.id || `status_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.characterStatus.bulkPut(validStatus);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validStatus.length} æ¡è§’è‰²çŠ¶æ€`);
                        } catch (error) {
                            console.error('å¯¼å…¥è§’è‰²çŠ¶æ€å¤±è´¥:', error);
                            showToast('è§’è‰²çŠ¶æ€å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }

                    // ğŸ”¥ã€æ–°å¢ã€‘å¯¼å…¥åŠ¨æ€ç³»ç»Ÿè¡¨
                    if (data.moments?.length) {
                        try {
                            console.log('ğŸ”„ å¼€å§‹å¯¼å…¥åŠ¨æ€ï¼ŒåŸå§‹æ•°æ®:', data.moments.length, 'æ¡');
                            await db.moments.clear();
                            const validMoments = data.moments.map((moment, index) => {
                                const result = {
                                    ...moment,
                                    id: moment.id || `moment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                };
                                console.log(`å¤„ç†åŠ¨æ€ ${index + 1}:`, result);
                                return result;
                            });
                            await db.moments.bulkPut(validMoments);
                            importedTables++;
                            console.log(`âœ… æˆåŠŸå¯¼å…¥äº† ${validMoments.length} æ¡åŠ¨æ€`);
                        } catch (error) {
                            console.error('âŒ å¯¼å…¥åŠ¨æ€å¤±è´¥:', error);
                            console.error('åŠ¨æ€æ•°æ®è¯¦æƒ…:', data.moments);
                            showToast('åŠ¨æ€å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    } else {
                        console.log('âš ï¸ æ²¡æœ‰æ‰¾åˆ°åŠ¨æ€æ•°æ®');
                    }

                    if (data.momentLikes?.length) {
                        try {
                            await db.momentLikes.clear();
                            await db.momentLikes.bulkPut(data.momentLikes);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${data.momentLikes.length} æ¡åŠ¨æ€ç‚¹èµ`);
                        } catch (error) {
                            console.error('å¯¼å…¥åŠ¨æ€ç‚¹èµå¤±è´¥:', error);
                            showToast('åŠ¨æ€ç‚¹èµå¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }

                    if (data.momentComments?.length) {
                        try {
                            await db.momentComments.clear();
                            const validComments = data.momentComments.map(comment => ({
                                ...comment,
                                id: comment.id || `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.momentComments.bulkPut(validComments);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validComments.length} æ¡åŠ¨æ€è¯„è®º`);
                        } catch (error) {
                            console.error('å¯¼å…¥åŠ¨æ€è¯„è®ºå¤±è´¥:', error);
                            showToast('åŠ¨æ€è¯„è®ºå¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }

                    // ğŸ”¥ã€æ–°å¢ã€‘å¯¼å…¥æ–°è®°å¿†ç³»ç»Ÿè¡¨
                    if (data.workingMemory?.length) {
                        try {
                            await db.workingMemory.clear();
                            const validWorkingMemory = data.workingMemory.map(memory => ({
                                ...memory,
                                id: memory.id || `working_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.workingMemory.bulkPut(validWorkingMemory);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validWorkingMemory.length} æ¡å·¥ä½œè®°å¿†`);
                        } catch (error) {
                            console.error('å¯¼å…¥å·¥ä½œè®°å¿†å¤±è´¥:', error);
                            showToast('å·¥ä½œè®°å¿†å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }

                    if (data.episodicMemory?.length) {
                        try {
                            await db.episodicMemory.clear();
                            const validEpisodicMemory = data.episodicMemory.map(memory => ({
                                ...memory,
                                id: memory.id || `episodic_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.episodicMemory.bulkPut(validEpisodicMemory);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validEpisodicMemory.length} æ¡æƒ…èŠ‚è®°å¿†`);
                        } catch (error) {
                            console.error('å¯¼å…¥æƒ…èŠ‚è®°å¿†å¤±è´¥:', error);
                            showToast('æƒ…èŠ‚è®°å¿†å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }

                    if (data.coreMemory?.length) {
                        try {
                            await db.coreMemory.clear();
                            const validCoreMemory = data.coreMemory.map(memory => ({
                                ...memory,
                                id: memory.id || `core_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.coreMemory.bulkPut(validCoreMemory);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validCoreMemory.length} æ¡æ ¸å¿ƒè®°å¿†`);
                        } catch (error) {
                            console.error('å¯¼å…¥æ ¸å¿ƒè®°å¿†å¤±è´¥:', error);
                            showToast('æ ¸å¿ƒè®°å¿†å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }

                    // ğŸ”¥ã€æ–°å¢ã€‘å¯¼å…¥çº¿ä¸‹æ¨¡å¼ç³»ç»Ÿè¡¨
                    if (data.offlineHistoryRecords?.length) {
                        try {
                            await db.offlineHistoryRecords.clear();
                            const validOfflineHistory = data.offlineHistoryRecords.map(record => ({
                                ...record,
                                id: record.id || `offline_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.offlineHistoryRecords.bulkPut(validOfflineHistory);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validOfflineHistory.length} æ¡çº¿ä¸‹è®°å½•`);
                        } catch (error) {
                            console.error('å¯¼å…¥çº¿ä¸‹è®°å½•å¤±è´¥:', error);
                            showToast('çº¿ä¸‹è®°å½•å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }

                    if (data.offlineUISettings?.length) {
                        try {
                            await db.offlineUISettings.clear();
                            const validOfflineUI = data.offlineUISettings.map(setting => ({
                                ...setting,
                                id: setting.id || `ui_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.offlineUISettings.bulkPut(validOfflineUI);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validOfflineUI.length} æ¡çº¿ä¸‹ç•Œé¢è®¾ç½®`);
                        } catch (error) {
                            console.error('å¯¼å…¥çº¿ä¸‹ç•Œé¢è®¾ç½®å¤±è´¥:', error);
                            showToast('çº¿ä¸‹ç•Œé¢è®¾ç½®å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }

                    if (data.offlinePresets?.length) {
                        try {
                            await db.offlinePresets.clear();
                            const validOfflinePresets = data.offlinePresets.map(preset => ({
                                ...preset,
                                id: preset.id || `preset_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.offlinePresets.bulkPut(validOfflinePresets);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validOfflinePresets.length} æ¡çº¿ä¸‹é¢„è®¾`);
                        } catch (error) {
                            console.error('å¯¼å…¥çº¿ä¸‹é¢„è®¾å¤±è´¥:', error);
                            showToast('çº¿ä¸‹é¢„è®¾å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }

                    // ğŸ”¥ã€æ–°å¢ã€‘å¯¼å…¥éŸ³ä¹æ’­æ”¾å™¨ç³»ç»Ÿè¡¨
                    if (data.musicPlaylist?.length) {
                        try {
                            await db.musicPlaylist.clear();
                            const validMusicPlaylist = data.musicPlaylist.map(song => ({
                                ...song,
                                id: song.id || `song_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.musicPlaylist.bulkPut(validMusicPlaylist);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validMusicPlaylist.length} é¦–éŸ³ä¹`);
                        } catch (error) {
                            console.error('å¯¼å…¥éŸ³ä¹æ’­æ”¾åˆ—è¡¨å¤±è´¥:', error);
                            showToast('éŸ³ä¹æ’­æ”¾åˆ—è¡¨å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }

                    if (data.musicCovers?.length) {
                        try {
                            await db.musicCovers.clear();
                            const validMusicCovers = data.musicCovers.map(cover => ({
                                ...cover,
                                id: cover.id || `cover_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.musicCovers.bulkPut(validMusicCovers);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validMusicCovers.length} ä¸ªéŸ³ä¹å°é¢`);
                        } catch (error) {
                            console.error('å¯¼å…¥éŸ³ä¹å°é¢å¤±è´¥:', error);
                            showToast('éŸ³ä¹å°é¢å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }

                    // ğŸ”¥ã€æ–°å¢ã€‘å¯¼å…¥ä¸–ç•Œä¹¦æ¡ç›®è¡¨
                    if (data.worldbookEntries?.length) {
                        try {
                            await db.worldbookEntries.clear();
                            const validWorldbookEntries = data.worldbookEntries.map(entry => ({
                                ...entry,
                                id: entry.id || `entry_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.worldbookEntries.bulkPut(validWorldbookEntries);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validWorldbookEntries.length} æ¡ä¸–ç•Œä¹¦æ¡ç›®`);
                        } catch (error) {
                            console.error('å¯¼å…¥ä¸–ç•Œä¹¦æ¡ç›®å¤±è´¥:', error);
                            showToast('ä¸–ç•Œä¹¦æ¡ç›®å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }

                    // ğŸ”¥ã€æ–°å¢ã€‘å¯¼å…¥ç¾¤èŠç›¸å…³è¡¨
                    if (data.groupChatMessages?.length) {
                        try {
                            await db.groupChatMessages.clear();
                            const validGroupMessages = data.groupChatMessages.map(msg => ({
                                ...msg,
                                id: msg.id || `gmsg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.groupChatMessages.bulkPut(validGroupMessages);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validGroupMessages.length} æ¡ç¾¤èŠæ¶ˆæ¯`);
                        } catch (error) {
                            console.error('å¯¼å…¥ç¾¤èŠæ¶ˆæ¯å¤±è´¥:', error);
                            showToast('ç¾¤èŠæ¶ˆæ¯å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }

                    if (data.groupChatMembers?.length) {
                        try {
                            await db.groupChatMembers.clear();
                            const validGroupMembers = data.groupChatMembers.map(member => ({
                                ...member,
                                id: member.id || `member_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.groupChatMembers.bulkPut(validGroupMembers);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validGroupMembers.length} æ¡ç¾¤èŠæˆå‘˜`);
                        } catch (error) {
                            console.error('å¯¼å…¥ç¾¤èŠæˆå‘˜å¤±è´¥:', error);
                            showToast('ç¾¤èŠæˆå‘˜å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }

                    // ğŸ”¥ã€æ–°å¢ã€‘å¯¼å…¥è§’è‰²æ—¥è®°æ•°æ®
                    if (data.characterDiaries?.length) {
                        try {
                            await db.characterDiaries.clear();
                            const validDiaries = data.characterDiaries.map(diary => ({
                                ...diary,
                                id: diary.id || `${diary.characterId}_${diary.date}`,
                                timestamp: diary.timestamp || new Date(diary.date).getTime(),
                                weather: diary.weather || 'â˜€ï¸'
                            }));
                            await db.characterDiaries.bulkPut(validDiaries);
                            importedTables++;
                            console.log(`å¯¼å…¥äº† ${validDiaries.length} æ¡è§’è‰²æ—¥è®°`);
                        } catch (error) {
                            console.error('å¯¼å…¥è§’è‰²æ—¥è®°å¤±è´¥:', error);
                            showToast('è§’è‰²æ—¥è®°å¯¼å…¥å¤±è´¥: ' + error.message, 'warning');
                        }
                    }

                    // ğŸ”¥ã€æ¶æ„ä¿®å¤ã€‘æŒ‰æ­£ç¡®é¡ºåºé‡æ–°åŠ è½½æ‰€æœ‰æ•°æ®
                    console.log('ğŸ”„ å¼€å§‹é‡æ–°åŠ è½½æ‰€æœ‰æ•°æ®...');

                    // ç¬¬ä¸€æ­¥ï¼šåŠ è½½åŸºç¡€æ•°æ®
                    await Promise.all([
                        loadCharacterGroups(),
                        loadCharacters(), // å…ˆåŠ è½½è§’è‰²
                        loadChatMessages(),
                        loadChatSettings(),
                        loadPersonas(),
                        loadGroupChats(),
                        loadWallpaper(),
                        loadAppIcons(),
                        loadWorldbooks(),
                        loadMemoryConfig() // åŠ è½½è®°å¿†é…ç½®
                    ]);

                    // ç¬¬äºŒæ­¥ï¼šä»è§’è‰²åˆ—è¡¨ç”Ÿæˆè”ç³»äººï¼ˆå¿…é¡»åœ¨è§’è‰²åŠ è½½å®Œæˆåï¼‰
                    console.log('ğŸ”„ ä»è§’è‰²åˆ—è¡¨é‡æ–°ç”Ÿæˆè”ç³»äºº...');
                    await loadContacts();

                    console.log('âœ… æ‰€æœ‰æ•°æ®é‡æ–°åŠ è½½å®Œæˆ');

                    // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘é‡æ–°æ¸²æŸ“æ‰€æœ‰ç•Œé¢
                    console.log('ğŸ”„ å¼€å§‹é‡æ–°æ¸²æŸ“ç•Œé¢...');
                    renderCharacterList();
                    renderMessageList(); // ğŸ”¥ã€å…³é”®ã€‘è¿™åº”è¯¥ç°åœ¨æ˜¾ç¤ºå¯¹è¯æ¡†äº†
                    renderPersonaList();
                    calculateStorageUsage();
                    console.log('âœ… ç•Œé¢é‡æ–°æ¸²æŸ“å®Œæˆ');
                    
                    showToast(`ğŸ‰ å¯¼å…¥æˆåŠŸï¼å…±å¯¼å…¥ ${importedTables} ä¸ªæ•°æ®è¡¨`, 'success');
                    console.log(`âœ… æ•°æ®å¯¼å…¥å®Œæˆï¼Œå…±å¯¼å…¥ ${importedTables} ä¸ªæ•°æ®è¡¨`);

                    // ğŸ”¥ã€æ–°å¢ã€‘å»¶è¿Ÿåˆ·æ–°é¡µé¢ä»¥ç¡®ä¿æ‰€æœ‰çŠ¶æ€æ›´æ–°
                    setTimeout(() => {
                        console.log('ğŸ”„ å¼ºåˆ¶åˆ·æ–°é¡µé¢ä»¥ç¡®ä¿æ‰€æœ‰çŠ¶æ€æ›´æ–°...');
                        location.reload();
                    }, 2000);
                } catch (error) {
                    console.error('å¯¼å…¥å¤±è´¥:', error);
                    showToast('å¯¼å…¥å¤±è´¥ï¼š' + error.message, 'error');
                }
            };
            input.click();
        }

        // æ˜¾ç¤ºæ¸…ç†é€‰é¡¹
        function showCleanupOptions() {
            const choice = prompt('é€‰æ‹©æ¸…ç†é¡¹ç›®ï¼š\n1. æ¸…é™¤åŠ¨æ€å¤´åƒ\n2. åˆ é™¤ç©ºèŠå¤©è®°å½•\n3. æ¸…ç†localStorage\n4. å‹ç¼©å›¾ç‰‡\n\nè¾“å…¥æ•°å­—ï¼ˆé€—å·åˆ†éš”ï¼‰ï¼š');
            if (choice) executeCleanupOptions(choice);
        }

        // æ‰§è¡Œæ¸…ç†
        async function executeCleanupOptions(choice) {
            const selections = choice.split(',').map(s => parseInt(s.trim())).filter(n => n >= 1 && n <= 4);
            if (!selections.length) return;
            
            showToast('æ¸…ç†ä¸­...', 'info');
            let count = 0;
            
            for (const option of selections) {
                switch (option) {
                    case 1:
                        Object.keys(chatSettings).forEach(id => {
                            if (chatSettings[id]?.aiDynamicAvatar) {
                                delete chatSettings[id].aiDynamicAvatar;
                                count++;
                            }
                        });
                        break;
                    case 2:
                        Object.keys(chatMessages).forEach(id => {
                            if (!chatMessages[id]?.length) {
                                delete chatMessages[id];
                                count++;
                            }
                        });
                        break;
                    case 3:
                        for (let i = localStorage.length - 1; i >= 0; i--) {
                            const key = localStorage.key(i);
                            if (key?.startsWith('chatSettings_')) {
                                localStorage.removeItem(key);
                                count++;
                            }
                        }
                        break;
                    case 4:
                        await compressAllImages();
                        break;
                }
            }
            
            await saveChatSettings();
            await saveChatMessages();
            calculateStorageUsage();
            showToast(`æ¸…ç†å®Œæˆï¼å¤„ç† ${count} é¡¹`, 'success');
        }

        // å‹ç¼©å›¾ç‰‡
        async function compressAllImages() {
            showToast('å‹ç¼©ä¸­...', 'info');
            let count = 0;
            
            // å‹ç¼©è§’è‰²å¤´åƒ
            for (const char of characters) {
                if (char.avatarUrl?.length > 50000) {
                    char.avatarUrl = await compressImage(char.avatarUrl, 150, 0.6);
                    count++;
                }
            }
            await saveCharacters();
            
            // å‹ç¼©è®¾ç½®ä¸­çš„å¤´åƒ
            for (const id of Object.keys(chatSettings)) {
                const settings = chatSettings[id];
                if (settings?.aiChatAvatar?.length > 50000) {
                    settings.aiChatAvatar = await compressImage(settings.aiChatAvatar, 150, 0.6);
                    count++;
                }
                if (settings?.myChatAvatar?.length > 50000) {
                    settings.myChatAvatar = await compressImage(settings.myChatAvatar, 150, 0.6);
                    count++;
                }
            }
            await saveChatSettings();
            calculateStorageUsage();
            showToast(`å‹ç¼©å®Œæˆï¼å¤„ç† ${count} å¼ å›¾ç‰‡`, 'success');
        }

        // è°ƒè¯•ç”¨ï¼šåˆ—å‡ºæ‰€æœ‰è§’è‰²IDå’Œåç§°ï¼Œå¸®åŠ©è¯†åˆ«å¹½çµè§’è‰²
        async function debugListAllCharacters() {
            try {
                console.log('=== æ‰€æœ‰è§’è‰²æ•°æ® ===');
                
                // 1. æ•°æ®åº“ä¸­çš„è§’è‰²
                const dbChars = await db.characters.toArray();
                console.log('æ•°æ®åº“è§’è‰²è¡¨:', dbChars.map(c => `${c.name} (ID: ${c.id})`));
                
                // 2. å†…å­˜ä¸­çš„è§’è‰²
                if (window.characters) {
                    console.log('å†…å­˜è§’è‰²åˆ—è¡¨:', window.characters.map(c => `${c.name} (ID: ${c.id})`));
                }
                
                // 3. è”ç³»äººåˆ—è¡¨
                if (window.contacts) {
                    console.log('è”ç³»äººIDåˆ—è¡¨:', window.contacts);
                }
                
                // 4. åŠ¨æ€è¯„è®ºä¸­çš„è§’è‰²
                const comments = await db.momentComments.toArray();
                const commentAuthors = [...new Set(comments.map(c => `${c.nickname} (ID: ${c.authorId})`))];
                console.log('åŠ¨æ€è¯„è®ºä¸­çš„è§’è‰²:', commentAuthors);
                
                // 5. åŠ¨æ€ç‚¹èµä¸­çš„è§’è‰²
                const likes = await db.momentLikes.toArray();
                const likeAuthors = [...new Set(likes.map(l => `${l.name} (ID: ${l.authorId})`))];
                console.log('åŠ¨æ€ç‚¹èµä¸­çš„è§’è‰²:', likeAuthors);
                
                return {dbChars, comments, likes};
            } catch (error) {
                console.error('è°ƒè¯•å¤±è´¥:', error);
            }
        }
        
        // è°ƒè¯•ç”¨ï¼šç²¾ç¡®åˆ é™¤æŒ‡å®šIDçš„è§’è‰²æ•°æ®
        async function debugDeleteCharacterById(characterId) {
            if (!characterId) {
                console.log('ç”¨æ³•: debugDeleteCharacterById("è§’è‰²ID")');
                return;
            }
            
            try {
                console.log(`å¼€å§‹åˆ é™¤è§’è‰²ID: ${characterId}`);
                let deleteCount = 0;
                
                // 1. ä»åŠ¨æ€è¯„è®ºä¸­åˆ é™¤
                const comments = await db.momentComments.where('authorId').equals(characterId).toArray();
                for (const comment of comments) {
                    await db.momentComments.delete(comment.id);
                    deleteCount++;
                    console.log(`åˆ é™¤è¯„è®º: ${comment.nickname} - ${comment.text}`);
                }
                
                // 2. ä»åŠ¨æ€ç‚¹èµä¸­åˆ é™¤
                const likes = await db.momentLikes.where('authorId').equals(characterId).toArray();
                for (const like of likes) {
                    await db.momentLikes.delete([like.momentId, like.authorId]);
                    deleteCount++;
                    console.log(`åˆ é™¤ç‚¹èµ: ${like.name}`);
                }
                
                // 3. ä»å…¶ä»–è¡¨ä¸­åˆ é™¤
                const chatMsgs = await db.chatMessages.where('characterId').equals(characterId).toArray();
                for (const msg of chatMsgs) {
                    await db.chatMessages.delete(msg.id);
                    deleteCount++;
                }
                
                const chatSets = await db.chatSettings.toArray();
                for (const setting of chatSets) {
                    if (setting.characterId === characterId) {
                        await db.chatSettings.delete(setting.id);
                        deleteCount++;
                    }
                }
                
                await db.characters.delete(characterId);
                deleteCount++;
                
                // 4. ä»å†…å­˜æ•°ç»„ä¸­åˆ é™¤
                if (window.contacts) {
                    window.contacts = window.contacts.filter(id => id !== characterId);
                    await saveContacts();
                }
                if (window.characters) {
                    window.characters = window.characters.filter(char => char.id !== characterId);
                }
                
                console.log(`åˆ é™¤å®Œæˆï¼å…±åˆ é™¤ ${deleteCount} æ¡ç›¸å…³æ•°æ®`);
                
                // åˆ·æ–°ç•Œé¢
                if (window.renderContactList) window.renderContactList();
                if (window.renderMessageList) window.renderMessageList();
                
            } catch (error) {
                console.error('åˆ é™¤å¤±è´¥:', error);
            }
        }
        
        // å¼ºåˆ¶åˆ é™¤æŒ‡å®šè§’è‰²ï¼ˆç”¨äºæ¸…ç†å¹½çµè§’è‰²ï¼‰
        async function forceDeleteCharacter() {
            const characterName = prompt('è¾“å…¥è¦å¼ºåˆ¶åˆ é™¤çš„è§’è‰²åç§°ï¼ˆå¦‚ï¼šæ–¹å›ï¼‰ï¼š');
            if (!characterName || !characterName.trim()) return;
            
            try {
                showToast(`æ­£åœ¨å¼ºåˆ¶åˆ é™¤è§’è‰² "${characterName}"...`, 'info');
                let deleteCount = 0;
                
                // 1. ä»åŠ¨æ€è¯„è®ºä¸­åˆ é™¤
                const comments = await db.momentComments.toArray();
                for (const comment of comments) {
                    if (comment.nickname === characterName || (comment.authorId && comment.authorId.includes(characterName))) {
                        await db.momentComments.delete(comment.id);
                        deleteCount++;
                        console.log(`åˆ é™¤è¯„è®ºï¼š${comment.nickname} - ${comment.text}`);
                    }
                }
                
                // 2. ä»åŠ¨æ€ç‚¹èµä¸­åˆ é™¤
                const likes = await db.momentLikes.toArray();
                for (const like of likes) {
                    if (like.name === characterName || (like.authorId && like.authorId.includes(characterName))) {
                        await db.momentLikes.delete([like.momentId, like.authorId]);
                        deleteCount++;
                        console.log(`åˆ é™¤ç‚¹èµï¼š${like.name}`);
                    }
                }
                
                // 3. ä»èŠå¤©æ¶ˆæ¯ä¸­åˆ é™¤
                const chatMsgs = await db.chatMessages.toArray();
                for (const msg of chatMsgs) {
                    if (msg.characterId && msg.characterId.includes(characterName)) {
                        await db.chatMessages.delete(msg.id);
                        deleteCount++;
                    }
                }
                
                // 4. ä»èŠå¤©è®¾ç½®ä¸­åˆ é™¤
                const chatSets = await db.chatSettings.toArray();
                for (const setting of chatSets) {
                    if (setting.characterId && setting.characterId.includes(characterName)) {
                        await db.chatSettings.delete(setting.id);
                        deleteCount++;
                    }
                }
                
                // 5. ä»charactersè¡¨ä¸­åˆ é™¤
                const chars = await db.characters.toArray();
                for (const char of chars) {
                    if (char.name === characterName || char.id.includes(characterName)) {
                        await db.characters.delete(char.id);
                        deleteCount++;
                        console.log(`åˆ é™¤è§’è‰²ï¼š${char.name} (${char.id})`);
                    }
                }
                
                // 6. ä»è”ç³»äººåˆ—è¡¨ä¸­åˆ é™¤
                if (window.contacts) {
                    window.contacts = window.contacts.filter(id => !id.includes(characterName));
                    await saveContacts();
                }
                
                // 7. æ¸…ç†å†…å­˜ä¸­çš„æ•°æ®
                if (window.characters) {
                    window.characters = window.characters.filter(char => char.name !== characterName);
                }
                if (window.chatMessages) {
                    Object.keys(window.chatMessages).forEach(key => {
                        if (key.includes(characterName)) {
                            delete window.chatMessages[key];
                        }
                    });
                }
                if (window.chatSettings) {
                    Object.keys(window.chatSettings).forEach(key => {
                        if (key.includes(characterName)) {
                            delete window.chatSettings[key];
                        }
                    });
                }
                
                // åˆ·æ–°ç•Œé¢
                if (window.renderContactList) window.renderContactList();
                if (window.renderMessageList) window.renderMessageList();
                
                showToast(`å¼ºåˆ¶åˆ é™¤å®Œæˆï¼å…±åˆ é™¤ ${deleteCount} æ¡ç›¸å…³æ•°æ®`, 'success');
                console.log(`å¼ºåˆ¶åˆ é™¤è§’è‰² "${characterName}" å®Œæˆï¼Œåˆ é™¤äº† ${deleteCount} æ¡è®°å½•`);
                
            } catch (error) {
                console.error('å¼ºåˆ¶åˆ é™¤å¤±è´¥:', error);
                showToast('å¼ºåˆ¶åˆ é™¤å¤±è´¥: ' + error.message, 'error');
            }
        }

        // æ¸…ç†å­¤ç«‹è”ç³»äººå’Œé‡å¤æ•°æ®
        async function cleanupOrphanedContacts() {
            try {
                showToast('æ­£åœ¨æ¸…ç†å­¤ç«‹æ•°æ®...', 'info');
                
                let cleanupCount = 0;
                
                // 1. æ¸…ç†è”ç³»äººåˆ—è¡¨ä¸­ä¸å­˜åœ¨çš„è§’è‰²ID
                const validCharacterIds = characters.map(char => char.id);
                const originalContactsLength = contacts.length;
                contacts = contacts.filter(contactId => {
                    const isValid = validCharacterIds.includes(contactId);
                    if (!isValid) cleanupCount++;
                    return isValid;
                });
                
                // 2. ä»æ•°æ®åº“ä¸­æ¸…ç†å­¤ç«‹çš„è”ç³»äººè®°å½•
                const dbContacts = await db.contacts.toArray();
                for (const contact of dbContacts) {
                    if (!validCharacterIds.includes(contact.characterId)) {
                        await db.contacts.delete(contact.id);
                        cleanupCount++;
                    }
                }
                
                // 3. æ¸…ç†èŠå¤©æ¶ˆæ¯ä¸­ä¸å­˜åœ¨è§’è‰²çš„è®°å½•
                const chatMessageKeys = Object.keys(chatMessages);
                for (const characterId of chatMessageKeys) {
                    if (!validCharacterIds.includes(characterId)) {
                        delete chatMessages[characterId];
                        cleanupCount++;
                    }
                }
                
                // 4. æ¸…ç†æ•°æ®åº“ä¸­å­¤ç«‹çš„èŠå¤©æ¶ˆæ¯
                const dbChatMessages = await db.chatMessages.toArray();
                for (const msgRecord of dbChatMessages) {
                    if (!validCharacterIds.includes(msgRecord.characterId)) {
                        await db.chatMessages.delete(msgRecord.id);
                        cleanupCount++;
                    }
                }
                
                // 5. æ¸…ç†èŠå¤©è®¾ç½®ä¸­ä¸å­˜åœ¨è§’è‰²çš„è®°å½•
                const chatSettingsKeys = Object.keys(chatSettings);
                for (const characterId of chatSettingsKeys) {
                    if (!validCharacterIds.includes(characterId)) {
                        delete chatSettings[characterId];
                        cleanupCount++;
                    }
                }
                
                // 6. æ¸…ç†æ•°æ®åº“ä¸­å­¤ç«‹çš„èŠå¤©è®¾ç½®
                const dbChatSettings = await db.chatSettings.toArray();
                for (const setting of dbChatSettings) {
                    if (!validCharacterIds.includes(setting.characterId)) {
                        await db.chatSettings.delete(setting.id);
                        cleanupCount++;
                    }
                }
                
                // 7. æ¸…ç†åŠ¨æ€è¯„è®ºä¸­ä¸å­˜åœ¨è§’è‰²çš„è®°å½•
                const dbMomentComments = await db.momentComments.toArray();
                for (const comment of dbMomentComments) {
                    // æ¸…ç†authorIdä¸åœ¨è§’è‰²åˆ—è¡¨ä¸­ä¸”ä¸æ˜¯ç”¨æˆ·çš„è¯„è®º
                    if (comment.authorId !== 'user' && !validCharacterIds.includes(comment.authorId)) {
                        await db.momentComments.delete(comment.id);
                        cleanupCount++;
                        console.log(`åˆ é™¤äº†å­¤ç«‹è¯„è®ºï¼š${comment.nickname}(${comment.authorId})`);
                    }
                }
                
                // 8. æ¸…ç†åŠ¨æ€ç‚¹èµä¸­ä¸å­˜åœ¨è§’è‰²çš„è®°å½•
                const dbMomentLikes = await db.momentLikes.toArray();
                for (const like of dbMomentLikes) {
                    // æ¸…ç†authorIdä¸åœ¨è§’è‰²åˆ—è¡¨ä¸­ä¸”ä¸æ˜¯ç”¨æˆ·çš„ç‚¹èµ
                    if (like.authorId !== 'user' && !validCharacterIds.includes(like.authorId)) {
                        await db.momentLikes.delete([like.momentId, like.authorId]);
                        cleanupCount++;
                        console.log(`åˆ é™¤äº†å­¤ç«‹ç‚¹èµï¼š${like.name}(${like.authorId})`);
                    }
                }
                
                // 9. ä¿å­˜æ¸…ç†åçš„æ•°æ®
                await Promise.all([
                    saveContacts(),
                    saveChatMessages(),
                    saveChatSettings()
                ]);
                
                // 10. é‡æ–°æ¸²æŸ“ç•Œé¢
                renderContactList();
                renderMessageList();
                
                showToast(`æ¸…ç†å®Œæˆï¼å…±æ¸…ç†äº† ${cleanupCount} æ¡å­¤ç«‹æ•°æ®`, 'success');
                
                console.log('æ¸…ç†ç»“æœ:', {
                    æœ‰æ•ˆè§’è‰²æ•°: validCharacterIds.length,
                    æ¸…ç†å‰è”ç³»äººæ•°: originalContactsLength,
                    æ¸…ç†åè”ç³»äººæ•°: contacts.length,
                    æ€»æ¸…ç†é¡¹ç›®: cleanupCount
                });
                
            } catch (error) {
                console.error('æ¸…ç†å­¤ç«‹æ•°æ®å¤±è´¥:', error);
                showToast('æ¸…ç†å¤±è´¥: ' + error.message, 'error');
            }
        }
        
        // æ¸…ç©ºæ‰€æœ‰æ•°æ®
        async function clearAllData() {
            const confirm = prompt('è­¦å‘Šï¼šå°†åˆ é™¤æ‰€æœ‰æ•°æ®ä¸”æ— æ³•æ¢å¤ï¼\nè¾“å…¥"æ¸…ç©ºæ‰€æœ‰æ•°æ®"ç¡®è®¤ï¼š');
            if (confirm !== 'æ¸…ç©ºæ‰€æœ‰æ•°æ®') return;
            
            try {
                showToast('æ¸…ç©ºä¸­...', 'info');
                
                // æ¸…ç©ºæ‰€æœ‰æ•°æ®åº“è¡¨
                await Promise.all([
                    db.characters.clear(),
                    db.chatMessages.clear(), 
                    db.chatSettings.clear(),
                    db.customEmojis.clear(),
                    db.worldbooks.clear() // ç¡®ä¿ä¹Ÿæ¸…ç©ºä¸–ç•Œä¹¦æ•°æ®
                ]);
                
                // é‡ç½®å†…å­˜ä¸­çš„å…¨å±€å˜é‡
                characters = [];
                chatMessages = {};
                chatSettings = {};
                customEmojis = [];
                contacts = [];
                groupChats = [];
                currentChatCharacter = null;
                
                // æ¸…ç†localStorageä¸­çš„å¤‡ä»½æ•°æ®
                for (let i = localStorage.length - 1; i >= 0; i--) {
                    const key = localStorage.key(i);
                    // æ¸…é™¤æ‰€æœ‰èŠå¤©è®¾ç½®å’Œå…¶ä»–åº”ç”¨æ•°æ®
                    if (key?.startsWith('chatSettings_') || 
                        key?.startsWith('contacts') || 
                        key?.startsWith('characters') || 
                        key?.startsWith('chatMessages')) {
                        localStorage.removeItem(key);
                    }
                }
                
                // åˆ·æ–°ç•Œé¢
                renderCharacterList();
                renderMessageList();
                renderContactList();
                calculateStorageUsage();
                
                showToast('å·²æ¸…ç©ºæ‰€æœ‰æ•°æ®', 'success');
                console.log('âœ… æ‰€æœ‰æ•°æ®å·²æ¸…ç©ºï¼ŒåŒ…æ‹¬èŠå¤©è®¾ç½®ã€è§’è‰²æ•°æ®ã€èŠå¤©è®°å½•å’Œä¸–ç•Œä¹¦');
                
                // è¿”å›ä¸»ç•Œé¢
                setTimeout(() => {
                    hideApp('data-management-screen');
                    hideApp('settings-screen');
                    showApp('chat-screen');
                }, 2000);
            } catch (error) {
                console.error('æ¸…ç©ºæ•°æ®å¤±è´¥:', error);
                showToast('æ¸…ç©ºå¤±è´¥: ' + error.message, 'error');
            }
        }

        // é‡å¤å‡½æ•°å·²åˆ é™¤

        // è½¬è´¦ç›¸å…³å˜é‡
        let currentTransferMsg = null;
        
        // å¤„ç†ç”¨æˆ·å‘é€ç»™AIçš„è½¬è´¦
        async function processUserTransfer(userTransferMsg, aiMessages) {
            console.log('ğŸš€ processUserTransfer è¢«è°ƒç”¨:', {
                userTransferMsg,
                aiMessages,
                currentCharacter: currentChatCharacter?.name
            });
            
            if (!userTransferMsg || !currentChatCharacter) {
                console.log('âŒ processUserTransfer é€€å‡ºï¼šç¼ºå°‘å¿…è¦å‚æ•°');
                return;
            }
            
            const messages = chatMessages[currentChatCharacter.id] || [];
            
            // åˆ†æAIçš„å›å¤å†…å®¹ï¼Œåˆ¤æ–­æ˜¯å¦æœ‰è½¬è´¦ç›¸å…³æ“ä½œ
            let transferAction = null;
            let transferActionReason = '';
            
            for (const msgData of aiMessages) {
                // æ£€æŸ¥AIæ˜¯å¦åœ¨å›å¤ä¸­æ˜ç¡®å¤„ç†äº†è½¬è´¦
                if (typeof msgData === 'object' && msgData.type === 'transfer_action') {
                    transferAction = msgData.action; // 'accept', 'reject', 'ignore'
                    transferActionReason = msgData.reason || '';
                    break;
                }
                
                // æ£€æŸ¥AIçš„æ™®é€šå›å¤ä¸­æ˜¯å¦åŒ…å«è½¬è´¦å¤„ç†çš„å…³é”®è¯
                if (typeof msgData === 'string') {
                    const content = msgData.toLowerCase();
                    console.log('ğŸ”¥ [è½¬è´¦å¤„ç†] åˆ†æAIå›å¤å†…å®¹:', content);

                    // ğŸ”¥ã€ä¿®å¤ã€‘æ›´ç²¾ç¡®çš„æ”¶æ¬¾å…³é”®è¯æ£€æµ‹ï¼Œé¿å…è¯¯åˆ¤
                    const acceptKeywords = [
                        'æ”¶ä¸‹', 'æ”¶æ¬¾', 'æ¥å—', 'ç¡®è®¤æ”¶æ¬¾', 'å·²æ”¶æ¬¾', 'æ”¶åˆ°äº†',
                        'è°¢è°¢ä½ ', 'æ„Ÿè°¢ä½ ', 'å¤ªå¥½äº†', 'çœŸè´´å¿ƒ', 'å¥½è´´å¿ƒ'
                    ];

                    // ğŸ”¥ã€ä¿®å¤ã€‘æ›´ç²¾ç¡®çš„æ‹’æ”¶å…³é”®è¯æ£€æµ‹ï¼Œé¿å…è¯¯åˆ¤
                    const rejectKeywords = [
                        'é€€å›', 'æ‹’ç»', 'ä¸æ”¶', 'ä¸éœ€è¦', 'ä¸èƒ½æ”¶', 'ä¸è¦ä½ çš„é’±',
                        'æˆ‘ä¸æ”¶', 'é€€ç»™ä½ ', 'ä¸ç”¨ç»™æˆ‘', 'ç®—äº†å§', 'ä¸è¦è¿™æ ·'
                    ];

                    // æ£€æŸ¥æ”¶æ¬¾æ„å›¾
                    const hasAcceptKeyword = acceptKeywords.some(keyword => content.includes(keyword));
                    // æ£€æŸ¥æ‹’æ”¶æ„å›¾
                    const hasRejectKeyword = rejectKeywords.some(keyword => content.includes(keyword));

                    if (hasAcceptKeyword && !hasRejectKeyword) {
                        transferAction = 'accept';
                        transferActionReason = 'è§’è‰²åŒæ„æ”¶æ¬¾';
                        console.log('ğŸ”¥ [è½¬è´¦å¤„ç†] æ£€æµ‹åˆ°æ”¶æ¬¾å…³é”®è¯ï¼Œè®¾ç½®ä¸ºaccept');
                        break;
                    } else if (hasRejectKeyword && !hasAcceptKeyword) {
                        transferAction = 'reject';
                        transferActionReason = 'è§’è‰²æ‹’ç»æ”¶æ¬¾';
                        console.log('ğŸ”¥ [è½¬è´¦å¤„ç†] æ£€æµ‹åˆ°æ‹’ç»å…³é”®è¯ï¼Œè®¾ç½®ä¸ºreject');
                        break;
                    } else if (hasAcceptKeyword && hasRejectKeyword) {
                        // å¦‚æœåŒæ—¶åŒ…å«æ”¶æ¬¾å’Œæ‹’æ”¶å…³é”®è¯ï¼Œéœ€è¦æ›´ä»”ç»†çš„åˆ†æ
                        console.log('ğŸ”¥ [è½¬è´¦å¤„ç†] åŒæ—¶æ£€æµ‹åˆ°æ”¶æ¬¾å’Œæ‹’æ”¶å…³é”®è¯ï¼Œä¿æŒpendingçŠ¶æ€');
                    } else {
                        console.log('ğŸ”¥ [è½¬è´¦å¤„ç†] æœªæ£€æµ‹åˆ°æ˜ç¡®çš„è½¬è´¦å¤„ç†å…³é”®è¯');
                    }
                }
            }
            
            // å¦‚æœAIæ˜ç¡®è¡¨ç¤ºäº†è½¬è´¦å¤„ç†æ„å›¾ï¼Œåˆ™æ‰§è¡Œç›¸åº”æ“ä½œ
            console.log('ğŸ”¥ [è½¬è´¦å¤„ç†] æœ€ç»ˆè½¬è´¦æ“ä½œå†³å®š:', transferAction);
            if (transferAction === 'accept' || transferAction === 'reject') {
                const transferIndex = messages.findIndex(msg => 
                    msg.timestamp === userTransferMsg.timestamp && msg.type === 'transfer' && msg.sender === 'sent');
                    
                if (transferIndex !== -1) {
                    // æ›´æ–°è½¬è´¦çŠ¶æ€
                    const newStatus = transferAction === 'accept' ? 'accepted' : 'rejected';
                    messages[transferIndex].status = newStatus;
                    
                    console.log('âœ… è½¬è´¦çŠ¶æ€å·²æ›´æ–°:', {
                        oldStatus: userTransferMsg.status,
                        newStatus: newStatus,
                        message: messages[transferIndex]
                    });
                    
                    // ä¿å­˜åˆ°æ•°æ®åº“
                    await saveChatMessages();
                    
                    // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
                    const actionText = transferAction === 'accept' ? 'å·²æ”¶æ¬¾' : 'å·²é€€å›';
                    const systemMsg = {
                        id: Date.now().toString(),
                        sender: 'system',
                        content: `${currentChatCharacter.name}${actionText} Â¥${Number(userTransferMsg.amount).toFixed(2)}`,
                        timestamp: Date.now()
                    };
                    
                    messages.push(systemMsg);
                    await saveChatMessages();
                    
                    console.log('ğŸ“± ç³»ç»Ÿæ¶ˆæ¯å·²æ·»åŠ :', systemMsg);
                    
                    // ç«‹å³é‡æ–°æ¸²æŸ“èŠå¤©ç•Œé¢ä»¥æ˜¾ç¤ºæ›´æ–°
                    renderChatMessages(currentChatCharacter.id);
                    
                    // æ˜¾ç¤ºç¡®è®¤æç¤º
                    const toastText = transferAction === 'accept' ? 'è½¬è´¦å·²è¢«æ¥å—' : 'è½¬è´¦å·²è¢«é€€å›';
                    showToast(toastText, 'success');
                    
                    console.log('ğŸ‰ è½¬è´¦å¤„ç†å®Œæˆ');
                } else {
                    console.error('âŒ æœªæ‰¾åˆ°å¯¹åº”çš„è½¬è´¦æ¶ˆæ¯');
                }
            } else {
                console.log('â„¹ï¸ AIæ²¡æœ‰æ˜ç¡®è¡¨æ€ï¼Œè½¬è´¦ä¿æŒpendingçŠ¶æ€');
            }
            // å¦‚æœAIæ²¡æœ‰æ˜ç¡®è¡¨æ€ï¼Œè½¬è´¦ä¿æŒpendingçŠ¶æ€ï¼Œç­‰å¾…ç”¨æˆ·æ‰‹åŠ¨å¤„ç†æˆ–ä¸‹æ¬¡AIå›å¤
        }
        
        // è½¬è´¦ç›¸å…³å‡½æ•°
        function sendTransfer() {
            const amount = parseFloat(document.getElementById('transfer-amount').value);
            const note = document.getElementById('transfer-note').value.trim();
            
            if (!amount || amount <= 0) {
                showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„è½¬è´¦é‡‘é¢', 'warning');
                return;
            }
            
            if (amount > 1000000000) {
                showToast('è½¬è´¦é‡‘é¢ä¸èƒ½è¶…è¿‡10äº¿å…ƒ', 'warning');
                return;
            }
            
            // åˆ›å»ºè½¬è´¦æ¶ˆæ¯ - ä¿®å¤æ•°æ®ç»“æ„å’Œè®¾ç½®pendingUserMessage
            const transferMessage = {
                id: Date.now().toString(),
                sender: 'sent',  // ä¿®å¤ï¼šä½¿ç”¨ sender è€Œä¸æ˜¯ role
                type: 'transfer',
                amount: amount,
                note: note || 'è½¬è´¦',
                timestamp: Date.now()
            };
            
            // æ·»åŠ åˆ°èŠå¤©è®°å½•
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            chatMessages[currentChatCharacter.id].push(transferMessage);
            
            // ä¿å­˜åˆ°æ•°æ®åº“
            saveChatMessages();
            
            // ä½¿ç”¨åŠ¨ç”»æ·»åŠ æ¶ˆæ¯è€Œä¸æ˜¯é‡æ–°æ¸²æŸ“æ•´ä¸ªåˆ—è¡¨
            addMessageWithAnimation(transferMessage, currentChatCharacter.id);
            
            // ğŸ”¥ ã€å…³é”®ä¿®å¤ã€‘è®¾ç½®ä¸ºå¾…å›å¤æ¶ˆæ¯ï¼Œè®©AIèƒ½çœ‹åˆ°è½¬è´¦
            pendingUserMessage = transferMessage;
            
            // æ›´æ–°æ™ºèƒ½å›å¤æŒ‰é’®çŠ¶æ€
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = 'ç‚¹å‡»è·å–AIå›å¤';
            }
            
            // æ›´æ–°è”ç³»äººåˆ—è¡¨
            renderMessageList();
            
            // å…³é—­è½¬è´¦å¯¹è¯æ¡†
            document.getElementById('transfer-modal').classList.remove('visible');
            
            // æ¸…ç©ºè¾“å…¥æ¡†
            document.getElementById('transfer-amount').value = '';
            document.getElementById('transfer-note').value = '';
            
            showToast('è½¬è´¦å·²å‘é€', 'success');
        }
        
        function showTransferConfirmDialog(transferMsg) {
            if (!transferMsg || transferMsg.status) return;
            
            const modal = document.getElementById('transfer-confirm-modal');
            const amountEl = modal.querySelector('.transfer-confirm-amount');
            const noteEl = modal.querySelector('.transfer-confirm-note');
            
            // è®¾ç½®è½¬è´¦ä¿¡æ¯
            amountEl.textContent = `Â¥ ${Number(transferMsg.amount).toFixed(2)}`;
            noteEl.textContent = `å¤‡æ³¨ï¼š${transferMsg.note || 'æ— '}`;
            
            // å­˜å‚¨å½“å‰å¤„ç†çš„è½¬è´¦ä¿¡æ¯
            currentTransferMsg = transferMsg;
            
            // æ˜¾ç¤ºå¯¹è¯æ¡†
            modal.classList.add('visible');
        }
        
        async function acceptTransfer() {
            if (!currentTransferMsg || !currentChatCharacter) return;
            
            // åœ¨èŠå¤©è®°å½•ä¸­æ‰¾åˆ°å¯¹åº”çš„è½¬è´¦æ¶ˆæ¯å¹¶æ›´æ–°çŠ¶æ€
            const messages = chatMessages[currentChatCharacter.id] || [];
            const transferIndex = messages.findIndex(msg => 
                msg.timestamp === currentTransferMsg.timestamp && msg.type === 'transfer');
                
            if (transferIndex !== -1) {
                // æ›´æ–°è½¬è´¦çŠ¶æ€
                messages[transferIndex].status = 'accepted';
                
                // ä¿å­˜åˆ°æ•°æ®åº“
                await saveChatMessages();
                
                // é‡æ–°æ¸²æŸ“èŠå¤©ç•Œé¢
                renderChatMessages(currentChatCharacter.id);
                
                // æ·»åŠ ä¸€æ¡ç³»ç»Ÿæ¶ˆæ¯ï¼Œè¡¨ç¤ºå·²æ”¶æ¬¾
                const systemMsg = {
                    id: Date.now().toString(),
                    sender: 'system',
                    content: `ä½ å·²ç¡®è®¤æ”¶æ¬¾ Â¥${Number(currentTransferMsg.amount).toFixed(2)}`,
                    timestamp: Date.now()
                };
                
                messages.push(systemMsg);
                await saveChatMessages();
                renderChatMessages(currentChatCharacter.id);
            }
            
            // å…³é—­å¯¹è¯æ¡†
            document.getElementById('transfer-confirm-modal').classList.remove('visible');
            currentTransferMsg = null;
            
            showToast('å·²ç¡®è®¤æ”¶æ¬¾', 'success');
        }
        
        async function rejectTransfer() {
            if (!currentTransferMsg || !currentChatCharacter) return;
            
            // åœ¨èŠå¤©è®°å½•ä¸­æ‰¾åˆ°å¯¹åº”çš„è½¬è´¦æ¶ˆæ¯å¹¶æ›´æ–°çŠ¶æ€
            const messages = chatMessages[currentChatCharacter.id] || [];
            const transferIndex = messages.findIndex(msg => 
                msg.timestamp === currentTransferMsg.timestamp && msg.type === 'transfer');
                
            if (transferIndex !== -1) {
                // æ›´æ–°è½¬è´¦çŠ¶æ€
                messages[transferIndex].status = 'rejected';
                
                // ä¿å­˜åˆ°æ•°æ®åº“
                await saveChatMessages();
                
                // é‡æ–°æ¸²æŸ“èŠå¤©ç•Œé¢
                renderChatMessages(currentChatCharacter.id);
                
                // æ·»åŠ ä¸€æ¡ç³»ç»Ÿæ¶ˆæ¯ï¼Œè¡¨ç¤ºå·²é€€å›
                const systemMsg = {
                    id: Date.now().toString(),
                    sender: 'system',
                    content: `ä½ å·²é€€å› Â¥${Number(currentTransferMsg.amount).toFixed(2)}`,
                    timestamp: Date.now()
                };
                
                messages.push(systemMsg);
                await saveChatMessages();
                renderChatMessages(currentChatCharacter.id);
            }
            
            // å…³é—­å¯¹è¯æ¡†
            document.getElementById('transfer-confirm-modal').classList.remove('visible');
            currentTransferMsg = null;
            
            showToast('å·²é€€å›è½¬è´¦', 'success');
        }

        // ç›‘å¬appæ˜¾ç¤ºäº‹ä»¶
        const originalShowApp = window.showApp;
        if (originalShowApp) {
            window.showApp = function(appId) {
                originalShowApp(appId);
                if (appId === 'data-management-screen') calculateStorageUsage();
            };
        }

        // æ˜¾ç¤ºå®šæ—¶å‘å¸ƒæ—¶é—´è®¾ç½®æ¨¡æ€æ¡†
        function showScheduleTimesModal() {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            const scheduleTimes = chatSettings.scheduledMomentsTimes || [];
            
            const container = document.getElementById('schedule-times-modal-container');
            container.innerHTML = '';
            
            // æ¸²æŸ“å·²æœ‰æ—¶é—´ç‚¹
            scheduleTimes.forEach((time, index) => {
                const timeItem = document.createElement('div');
                timeItem.className = 'schedule-time-item';
                timeItem.style.cssText = `
                    display: flex;
                    align-items: center;
                    margin-bottom: 10px;
                    gap: 10px;
                `;
                timeItem.innerHTML = `
                    <input type="time" value="${time}" onchange="updateScheduleTime(${index}, this.value)" 
                           style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 6px;">
                    <button onclick="removeScheduleTime(${index})" 
                            style="padding: 8px 12px; background: #ff3b30; color: white; border: none; border-radius: 6px; cursor: pointer;">Ã—</button>
                `;
                container.appendChild(timeItem);
            });
            
            showModal('schedule-times-modal');
        }
        
        // æ·»åŠ å®šæ—¶å‘å¸ƒæ—¶é—´ç‚¹
        function addScheduleTime() {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            if (!chatSettings.scheduledMomentsTimes) {
                chatSettings.scheduledMomentsTimes = [];
            }
            
            if (chatSettings.scheduledMomentsTimes.length >= 10) {
                alert('æœ€å¤šåªèƒ½è®¾ç½®10ä¸ªæ—¶é—´ç‚¹');
                return;
            }
            
            chatSettings.scheduledMomentsTimes.push('09:00');
            saveCurrentChatSettings(chatSettings);
            showScheduleTimesModal(); // é‡æ–°æ¸²æŸ“
        }
        
        // æ›´æ–°å®šæ—¶å‘å¸ƒæ—¶é—´ç‚¹
        function updateScheduleTime(index, newTime) {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.scheduledMomentsTimes && chatSettings.scheduledMomentsTimes[index] !== undefined) {
                chatSettings.scheduledMomentsTimes[index] = newTime;
                saveCurrentChatSettings(chatSettings);
            }
        }
        
        // ç§»é™¤å®šæ—¶å‘å¸ƒæ—¶é—´ç‚¹
        function removeScheduleTime(index) {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.scheduledMomentsTimes && chatSettings.scheduledMomentsTimes[index] !== undefined) {
                chatSettings.scheduledMomentsTimes.splice(index, 1);
                saveCurrentChatSettings(chatSettings);
                showScheduleTimesModal(); // é‡æ–°æ¸²æŸ“
            }
        }
        
        // ä¿å­˜å®šæ—¶å‘å¸ƒè®¾ç½®
        function saveScheduleTimes() {
            if (!currentChatCharacter) return;
            
            const container = document.getElementById('schedule-times-modal-container');
            const timeInputs = container.querySelectorAll('input[type="time"]');
            const times = Array.from(timeInputs).map(input => input.value).filter(time => time);
            
            const chatSettings = getCurrentChatSettings();
            chatSettings.scheduledMomentsTimes = times;
            saveCurrentChatSettings(chatSettings);
            
            updateScheduleTimesDisplay();
            hideModal('schedule-times-modal');
            
            // é‡æ–°åˆå§‹åŒ–å…¨å±€åŠ¨æ€å‘å¸ƒç³»ç»Ÿä»¥åº”ç”¨æ–°è®¾ç½®
            setTimeout(async () => {
                try {
                    await initGlobalMomentsSystem();
                    console.log('âœ… å®šæ—¶å‘å¸ƒè®¾ç½®å·²æ›´æ–°');
                } catch (error) {
                    console.error('âŒ æ›´æ–°å®šæ—¶å‘å¸ƒè®¾ç½®å¤±è´¥:', error);
                }
            }, 500);
            
            showToast(`å·²ä¿å­˜ ${times.length} ä¸ªå®šæ—¶å‘å¸ƒæ—¶é—´ç‚¹`, 'success');
        }
        
        // æ›´æ–°å®šæ—¶å‘å¸ƒæ—¶é—´æ˜¾ç¤º
        function updateScheduleTimesDisplay() {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            const scheduleTimes = chatSettings.scheduledMomentsTimes || [];
            const displayElement = document.getElementById('schedule-times-display');
            
            if (scheduleTimes.length === 0) {
                displayElement.textContent = 'æœªè®¾ç½®';
            } else if (scheduleTimes.length === 1) {
                displayElement.textContent = `1ä¸ªæ—¶é—´ç‚¹ (${scheduleTimes[0]})`;
            } else {
                displayElement.textContent = `${scheduleTimes.length}ä¸ªæ—¶é—´ç‚¹`;
            }
        }
        
        // æµ‹è¯•å‘å¸ƒåŠ¨æ€
        async function testPublishMoment() {
            if (!currentChatCharacter) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè§’è‰²');
                return;
            }
            
            const button = document.querySelector('button[onclick="testPublishMoment()"]');
            const originalText = button.textContent;
            button.textContent = 'å‘å¸ƒä¸­...';
            button.disabled = true;
            
            try {
                await triggerBackgroundMomentsTest(currentChatCharacter.id);
                showToast('æµ‹è¯•åŠ¨æ€å‘å¸ƒæˆåŠŸï¼', 'success');
            } catch (error) {
                console.error('æµ‹è¯•å‘å¸ƒå¤±è´¥:', error);
                showToast('æµ‹è¯•å‘å¸ƒå¤±è´¥', 'error');
            } finally {
                button.textContent = originalText;
                button.disabled = false;
            }
        }
        
        // åˆå§‹åŒ–å®šæ—¶å‘å¸ƒç³»ç»Ÿ
        function initScheduledMomentsSystem() {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            if (!chatSettings.scheduledMomentsEnabled || !chatSettings.scheduledMomentsTimes?.length) {
                return;
            }
            
            // ä¸ºæ¯ä¸ªè®¾å®šæ—¶é—´åˆ›å»ºå®šæ—¶å™¨
            chatSettings.scheduledMomentsTimes.forEach(time => {
                if (!time) return;
                
                const [hours, minutes] = time.split(':').map(Number);
                const now = new Date();
                const scheduledTime = new Date();
                
                scheduledTime.setHours(hours, minutes, 0, 0);
                
                // å¦‚æœæ—¶é—´å·²è¿‡ï¼Œè®¾ç½®ä¸ºæ˜å¤©
                if (scheduledTime <= now) {
                    scheduledTime.setDate(scheduledTime.getDate() + 1);
                }
                
                const delay = scheduledTime.getTime() - now.getTime();
                
                setTimeout(() => {
                    // æ‰§è¡Œå®šæ—¶å‘å¸ƒ
                    triggerBackgroundMoments(currentChatCharacter.id);
                    
                    // è®¾ç½®æ¯24å°æ—¶é‡å¤æ‰§è¡Œ
                    setInterval(() => {
                        triggerBackgroundMoments(currentChatCharacter.id);
                    }, 24 * 60 * 60 * 1000);
                }, delay);
            });
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ¨é€é€šçŸ¥åŠŸèƒ½
        // ğŸ”¥ã€æ–°å¢ã€‘é€šçŸ¥é˜Ÿåˆ—å’Œå•ä¸ªé€šçŸ¥ç®¡ç†
        let notificationQueue = [];
        let currentNotification = null;
        let isProcessingQueue = false;

        // ğŸ”¥ã€ä¿®å¤ã€‘åˆ›å»ºæ¨é€é€šçŸ¥ - æ”¹ä¸ºé˜Ÿåˆ—æ–¹å¼ï¼Œå•ä¸ªæ˜¾ç¤º
        function createPushNotification(character, messageData, delay = 0) {
            // ğŸ”¥ã€ä¿®å¤ã€‘æ£€æŸ¥ç”¨æˆ·æ˜¯å¦åœ¨å’Œè¯¥è§’è‰²çš„èŠå¤©ç•Œé¢ - æ›´ç²¾ç¡®çš„åˆ¤æ–­

            // æ–¹æ³•1ï¼šæ£€æŸ¥ä¸»å±å¹•æ˜¯å¦å¯è§
            const phoneScreen = document.getElementById('phone-screen');
            const isOnMainScreen = phoneScreen && window.getComputedStyle(phoneScreen).display !== 'none';

            // æ–¹æ³•2ï¼šæ£€æŸ¥èŠå¤©ç•Œé¢æ˜¯å¦å¯è§
            const chatScreen = document.getElementById('api-chat-screen');
            const isChatVisible = chatScreen && window.getComputedStyle(chatScreen).display !== 'none';

            // æ–¹æ³•3ï¼šæ£€æŸ¥ç”¨æˆ·æ˜¯å¦åœ¨å’Œè¯¥è§’è‰²èŠå¤©
            const isChattingWithThisCharacter = isChatVisible && currentChatCharacter && currentChatCharacter.id === character.id;

            console.log('ğŸ”” [æ¨é€é€šçŸ¥] æ£€æŸ¥ç•Œé¢çŠ¶æ€:', {
                mainScreenVisible: isOnMainScreen,
                chatScreenVisible: isChatVisible,
                currentChatCharacter: currentChatCharacter?.name,
                messageFromCharacter: character.name,
                isChattingWithThisCharacter: isChattingWithThisCharacter,
                shouldShowNotification: isOnMainScreen && !isChattingWithThisCharacter
            });

            // ğŸ”¥ã€ä¿®å¤ã€‘åªæœ‰å½“ç”¨æˆ·ä¸åœ¨å’Œè¯¥è§’è‰²çš„èŠå¤©ç•Œé¢æ—¶æ‰æ˜¾ç¤ºæ¨é€
            // ç”¨æˆ·å¯èƒ½åœ¨ä¸»å±å¹•ã€å…¶ä»–åº”ç”¨ã€æˆ–è€…å’Œå…¶ä»–è§’è‰²èŠå¤©ï¼Œè¿™äº›æƒ…å†µéƒ½åº”è¯¥æ˜¾ç¤ºæ¨é€
            if (!isOnMainScreen || isChattingWithThisCharacter) {
                console.log('ğŸ”” [æ¨é€é€šçŸ¥] ç”¨æˆ·ä¸åœ¨ä¸»å±å¹•æˆ–æ­£åœ¨å’Œè¯¥è§’è‰²èŠå¤©ï¼Œä¸æ˜¾ç¤ºæ¨é€');
                return;
            }
            
            // æ·»åŠ åˆ°é˜Ÿåˆ—
            notificationQueue.push({
                character,
                messageData,
                delay
            });
            
            console.log('ğŸ”” [æ¨é€é€šçŸ¥] æ·»åŠ é€šçŸ¥åˆ°é˜Ÿåˆ—ï¼Œå½“å‰é˜Ÿåˆ—é•¿åº¦:', notificationQueue.length);
            
            // å¼€å§‹å¤„ç†é˜Ÿåˆ—
            processNotificationQueue();
        }

        // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†é€šçŸ¥é˜Ÿåˆ—
        function processNotificationQueue() {
            if (isProcessingQueue || notificationQueue.length === 0) {
                return;
            }
            
            isProcessingQueue = true;
            console.log('ğŸ”” [æ¨é€é€šçŸ¥] å¼€å§‹å¤„ç†é˜Ÿåˆ—ï¼Œå‰©ä½™é€šçŸ¥æ•°:', notificationQueue.length);
            
            const processNext = () => {
                if (notificationQueue.length === 0) {
                    isProcessingQueue = false;
                    console.log('ğŸ”” [æ¨é€é€šçŸ¥] é˜Ÿåˆ—å¤„ç†å®Œæˆ');
                    return;
                }
                
                const { character, messageData, delay } = notificationQueue.shift();
                
                setTimeout(() => {
                    showSingleNotification(character, messageData);

                    // ğŸ”¥ã€ä¿®å¤ã€‘å¢åŠ é€šçŸ¥é—´éš”åˆ°2.6ç§’ï¼Œç¡®ä¿ç”¨æˆ·æœ‰è¶³å¤Ÿæ—¶é—´çœ‹å®Œå½“å‰é€šçŸ¥
                    setTimeout(() => {
                        processNext();
                    }, 2600);
                }, delay);
            };
            
            processNext();
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ˜¾ç¤ºå•ä¸ªé€šçŸ¥
        function showSingleNotification(character, messageData) {
            console.log('ğŸ”” [æ¨é€é€šçŸ¥] æ˜¾ç¤ºå•ä¸ªé€šçŸ¥ï¼Œè§’è‰²:', character.name);
            
            const container = document.getElementById('notification-container');
            if (!container) {
                console.error('ğŸ”” [æ¨é€é€šçŸ¥] æ‰¾ä¸åˆ°é€šçŸ¥å®¹å™¨!');
                return;
            }
            
            // å¦‚æœæœ‰ç°æœ‰é€šçŸ¥ï¼Œå…ˆç§»é™¤
            if (currentNotification) {
                hideNotification(currentNotification, true);
            }
            
            // åˆ›å»ºé€šçŸ¥å…ƒç´ 
            const notification = document.createElement('div');
            notification.className = 'push-notification';
            currentNotification = notification;
            
            // ç”Ÿæˆé€šçŸ¥å†…å®¹
            let notificationText = '';
            let notificationType = 'message';
            let senderName = character.name;
            
            if (typeof messageData === 'string') {
                notificationText = messageData;
            } else if (typeof messageData === 'object') {
                // ğŸ”¥ã€ä¿®å¤ã€‘å¤„ç†ç¾¤èŠæ¶ˆæ¯æ ¼å¼
                if (messageData.name && messageData.message) {
                    // ç¾¤èŠæ¶ˆæ¯æ ¼å¼: {name: "è§’è‰²å", message: "æ¶ˆæ¯å†…å®¹"}
                    senderName = messageData.name;
                    
                    if (typeof messageData.message === 'string') {
                        notificationText = messageData.message;
                    } else if (typeof messageData.message === 'object' && messageData.message.type) {
                        // ç¾¤èŠä¸­çš„ç‰¹æ®Šæ¶ˆæ¯ç±»å‹
                        switch (messageData.message.type) {
                            case 'transfer':
                                notificationText = `å‘ä½ è½¬è´¦äº† Â¥${messageData.message.amount}`;
                                notificationType = 'transfer';
                                break;
                            case 'voice_message':
                                notificationText = '[è¯­éŸ³æ¶ˆæ¯]';
                                notificationType = 'voice';
                                break;
                            default:
                                notificationText = messageData.message.content || '[æ¶ˆæ¯]';
                        }
                    } else {
                        notificationText = String(messageData.message);
                    }
                } else if (messageData.type) {
                    // æ™®é€šçš„ç‰¹æ®Šæ¶ˆæ¯ç±»å‹
                    switch (messageData.type) {
                        case 'transfer':
                            notificationText = `å‘ä½ è½¬è´¦äº† Â¥${messageData.amount}`;
                            notificationType = 'transfer';
                            break;
                        case 'voice_message':
                            notificationText = '[è¯­éŸ³æ¶ˆæ¯]';
                            notificationType = 'voice';
                            break;
                        case 'ai_image':
                            notificationText = '[å›¾ç‰‡]';
                            notificationType = 'image';
                            break;
                        case 'emoji':
                            notificationText = `å‘é€äº†è¡¨æƒ…åŒ…ï¼š${messageData.description}`;
                            notificationType = 'emoji';
                            break;
                        default:
                            notificationText = messageData.content || '[æ¶ˆæ¯]';
                    }
                } else {
                    notificationText = messageData.content || messageData.message || '[æ¶ˆæ¯]';
                }
            }
            
            // é™åˆ¶é€šçŸ¥æ–‡æœ¬é•¿åº¦
            if (notificationText.length > 25) {
                notificationText = notificationText.substring(0, 25) + '...';
            }
            
            // ç”Ÿæˆæ—¶é—´
            const now = new Date();
            const timeString = now.toLocaleTimeString('zh-CN', { 
                hour: '2-digit', 
                minute: '2-digit' 
            });
            
            // è®¾ç½®é€šçŸ¥HTML
            notification.innerHTML = `
                <img class="notification-avatar" src="${character.avatarUrl || 'https://via.placeholder.com/28'}" alt="${senderName}">
                <div class="notification-content">
                    <div class="notification-title">${senderName}</div>
                    <div class="notification-message">${notificationText}</div>
                </div>
                <div class="notification-time">${timeString}</div>
            `;
            
            // ç‚¹å‡»é€šçŸ¥æ‰“å¼€èŠå¤©
            notification.onclick = () => {
                console.log('ğŸ”” [æ¨é€é€šçŸ¥] ç”¨æˆ·ç‚¹å‡»äº†æ¨é€é€šçŸ¥ï¼Œè·³è½¬åˆ°èŠå¤©ç•Œé¢');
                
                // å¦‚æœæœ‰è§’è‰²ä¿¡æ¯ï¼Œç¡®ä¿åˆ‡æ¢åˆ°å¯¹åº”è§’è‰²
                if (character && character.id) {
                    console.log('ğŸ”” [æ¨é€é€šçŸ¥] åˆ‡æ¢åˆ°è§’è‰²:', character.name, character.id);
                    // è®¾ç½®å½“å‰èŠå¤©è§’è‰²
                    currentChatCharacter = character;
                    // æ›´æ–°èŠå¤©ç•Œé¢æ ‡é¢˜
                    const chatTitle = document.getElementById('api-chat-title');
                    if (chatTitle) {
                        // ğŸ”¥ã€ä¿®å¤ã€‘ç¾¤èŠæ ‡é¢˜æ˜¾ç¤ºæˆå‘˜æ•°é‡
                        let displayTitle = character.name;
                        if (character.isGroup && character.members) {
                            const memberCount = character.members.length + 1; // +1 åŒ…æ‹¬ç”¨æˆ·è‡ªå·±
                            displayTitle = `${character.name}ï¼ˆ${memberCount}ï¼‰`;
                        }
                        chatTitle.textContent = displayTitle;
                    }
                    // æ¸²æŸ“è¯¥è§’è‰²çš„èŠå¤©è®°å½•
                    renderChatMessages(character.id);
                }
                
                // åˆ‡æ¢åˆ°èŠå¤©ç•Œé¢
                showApp('api-chat-screen');
                
                // ç§»é™¤é€šçŸ¥
                hideNotification(notification);
                
                console.log('ğŸ”” [æ¨é€é€šçŸ¥] è·³è½¬å®Œæˆ');
            };
            
            // æ·»åŠ åˆ°å®¹å™¨
            container.appendChild(notification);
            
            // æ˜¾ç¤ºåŠ¨ç”»
            setTimeout(() => {
                notification.classList.add('show');
            }, 50);
            
            // ğŸ”¥ã€ä¿®å¤ã€‘è‡ªåŠ¨éšè— - å¢åŠ æ˜¾ç¤ºæ—¶é•¿
            setTimeout(() => {
                if (currentNotification === notification) {
                    hideNotification(notification);
                }
            }, 2300);
        }
        
        function hideNotification(notification, immediate = false) {
            if (notification && notification.parentNode) {
                notification.classList.remove('show');
                notification.classList.add('hide');
                
                // å¦‚æœæ˜¯å½“å‰é€šçŸ¥ï¼Œæ¸…é™¤å¼•ç”¨
                if (currentNotification === notification) {
                    currentNotification = null;
                }
                
                const removeDelay = immediate ? 0 : 250;
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, removeDelay);
            }
        }
        
        // ğŸ”¥ã€æ–°å¢ã€‘ä¸ºåŠ¨æ€äº’åŠ¨åˆ›å»ºæ¨é€é€šçŸ¥
        function createMomentInteractionNotification(character, interactionType, momentText) {
            let notificationText = '';
            switch (interactionType) {
                case 'like':
                    notificationText = `èµäº†ä½ çš„åŠ¨æ€`;
                    break;
                case 'comment':
                    notificationText = `è¯„è®ºäº†ä½ çš„åŠ¨æ€`;
                    break;
                default:
                    notificationText = `ä¸ä½ çš„åŠ¨æ€äº’åŠ¨äº†`;
            }
            
            createPushNotification(character, notificationText);
        }

        // ğŸ”¥ã€æ–°å¢ã€‘é¡µé¢å¸è½½æ—¶æ ‡è®°å½“å‰èŠå¤©ä¸ºå·²è¯»
        window.addEventListener('beforeunload', function() {
            // å¦‚æœç”¨æˆ·æ­£åœ¨èŠå¤©ç•Œé¢ï¼Œæ ‡è®°å½“å‰èŠå¤©çš„æ¶ˆæ¯ä¸ºå·²è¯»
            if (currentChatCharacter) {
                markAsRead(currentChatCharacter.id);
                console.log('ğŸ”¥ [é¡µé¢å¸è½½] æ ‡è®°å½“å‰èŠå¤©ä¸ºå·²è¯»:', currentChatCharacter.name);
            } else {
                // ğŸ”¥ã€æ–°å¢ã€‘å¦‚æœcurrentChatCharacterä¸ºç©ºï¼Œå°è¯•ä»sessionStorageæ¢å¤
                const savedChatId = sessionStorage.getItem('currentChatCharacterId');
                if (savedChatId) {
                    markAsRead(savedChatId);
                    console.log('ğŸ”¥ [é¡µé¢å¸è½½] ä»sessionStorageæ¢å¤å¹¶æ ‡è®°èŠå¤©ä¸ºå·²è¯»:', savedChatId);
                }
            }
            // æ¸…é™¤ä¿å­˜çš„èŠå¤©çŠ¶æ€
            sessionStorage.removeItem('currentChatCharacterId');
        });

        // ğŸ”¥ã€æ–°å¢ã€‘é¡µé¢éšè—æ—¶ä¹Ÿæ ‡è®°å½“å‰èŠå¤©ä¸ºå·²è¯»ï¼ˆå¤„ç†ç§»åŠ¨ç«¯åˆ‡æ¢åº”ç”¨çš„æƒ…å†µï¼‰
        document.addEventListener('visibilitychange', function() {
            if (document.hidden && currentChatCharacter) {
                markAsRead(currentChatCharacter.id);
                console.log('ğŸ”¥ [é¡µé¢éšè—] æ ‡è®°å½“å‰èŠå¤©ä¸ºå·²è¯»:', currentChatCharacter.name);
            }
        });

        // ğŸ”¥ã€æ–°å¢ã€‘é¡µé¢å¤±å»ç„¦ç‚¹æ—¶ä¹Ÿæ ‡è®°å½“å‰èŠå¤©ä¸ºå·²è¯»ï¼ˆå¤„ç†åˆ‡æ¢æ ‡ç­¾é¡µçš„æƒ…å†µï¼‰
        window.addEventListener('blur', function() {
            if (currentChatCharacter) {
                markAsRead(currentChatCharacter.id);
                console.log('ğŸ”¥ [é¡µé¢å¤±ç„¦] æ ‡è®°å½“å‰èŠå¤©ä¸ºå·²è¯»:', currentChatCharacter.name);
            }
        });

        // åˆå§‹åŒ–è½¬è´¦åŠŸèƒ½äº‹ä»¶ç›‘å¬å™¨
        document.addEventListener('DOMContentLoaded', function() {
            // æ·»åŠ è½¬è´¦ç›¸å…³äº‹ä»¶ç›‘å¬å™¨
            document.getElementById('transfer-cancel-btn')?.addEventListener('click', () => {
                document.getElementById('transfer-modal').classList.remove('visible');
            });

            document.getElementById('transfer-confirm-btn')?.addEventListener('click', sendTransfer);
            document.getElementById('transfer-accept-btn')?.addEventListener('click', acceptTransfer);
            document.getElementById('transfer-reject-btn')?.addEventListener('click', rejectTransfer);

            // ç‚¹å‡»æ¨¡æ€æ¡†èƒŒæ™¯å…³é—­
            document.getElementById('transfer-modal')?.addEventListener('click', (e) => {
                if (e.target === document.getElementById('transfer-modal')) {
                    document.getElementById('transfer-modal').classList.remove('visible');
                }
            });
            
            document.getElementById('transfer-confirm-modal')?.addEventListener('click', (e) => {
                if (e.target === document.getElementById('transfer-confirm-modal')) {
                    document.getElementById('transfer-confirm-modal').classList.remove('visible');
                    currentTransferMsg = null;
                }
            });
        });

        // ç¾¤èŠç›¸å…³å‡½æ•°
        function updateGroupChatInfo() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            
            // æ›´æ–°ç¾¤èŠå¤´åƒé¢„è§ˆ
            const groupAvatarPreview = document.getElementById('group-avatar-preview');
            if (groupAvatarPreview) {
                if (currentChatCharacter.avatarUrl) {
                    groupAvatarPreview.src = currentChatCharacter.avatarUrl;
                } else {
                    // ä½¿ç”¨é»˜è®¤çš„ç¾¤èŠå¤´åƒ - åˆ›å»ºä¸€ä¸ªç®€å•çš„Canvaså¤´åƒ
                    const canvas = document.createElement('canvas');
                    canvas.width = 40;
                    canvas.height = 40;
                    const ctx = canvas.getContext('2d');
                    
                    // ç»˜åˆ¶è“è‰²åœ†å½¢èƒŒæ™¯
                    ctx.beginPath();
                    ctx.arc(20, 20, 20, 0, 2 * Math.PI);
                    ctx.fillStyle = '#4a84c1';
                    ctx.fill();
                    
                    // ç»˜åˆ¶ç™½è‰²"ç¾¤"å­—
                    ctx.fillStyle = 'white';
                    ctx.font = '18px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('ç¾¤', 20, 20);
                    
                    groupAvatarPreview.src = canvas.toDataURL();
                }
            }
            
            // æ›´æ–°ç¾¤èŠåç§°æ˜¾ç¤º
            const groupNameDisplay = document.getElementById('group-name-display');
            if (groupNameDisplay) {
                groupNameDisplay.textContent = currentChatCharacter.name || 'ç¾¤èŠåç§°';
            }
            
            // æ›´æ–°ç¾¤æˆå‘˜æ•°é‡æ˜¾ç¤º
            const groupMemberCountDisplay = document.getElementById('group-member-count-display');
            if (groupMemberCountDisplay) {
                const memberCount = currentChatCharacter.members ? currentChatCharacter.members.length : 0;
                // ç¾¤æˆå‘˜æ•°é‡ = è§’è‰²æ•°é‡ + 1ä¸ªç”¨æˆ·
                const totalMemberCount = memberCount + 1;
                groupMemberCountDisplay.textContent = `${totalMemberCount}åæˆå‘˜`;
            }
            
            // æ›´æ–°ç¾¤å…¬å‘Šæ˜¾ç¤º
            const groupDescriptionDisplay = document.getElementById('group-description-display');
            if (groupDescriptionDisplay) {
                groupDescriptionDisplay.textContent = currentChatCharacter.description || 'ç¾¤å…¬å‘Šï¼šç‚¹å‡»è®¾ç½®ç¾¤å…¬å‘Š';
            }
            
            // æ›´æ–°æˆ‘åœ¨ç¾¤é‡Œçš„æ˜µç§° - ä½¿ç”¨å½“å‰é€‰æ‹©çš„é¢å…·åç§°ä½œä¸ºé»˜è®¤å€¼
            const currentMyGroupNickname = document.getElementById('current-my-group-nickname');
            if (currentMyGroupNickname) {
                let defaultNickname = 'æœªé€‰æ‹©';
        
        // --- æ–°å¢ä»£ç å¼€å§‹ ---
        const chatSettings = getCurrentChatSettings();
        const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
        // --- æ–°å¢ä»£ç ç»“æŸ ---

                // å¦‚æœç”¨æˆ·é€‰æ‹©äº†é¢å…·ï¼Œä½¿ç”¨é¢å…·åç§°
        if (selectedPersona && selectedPersona.name) { // <--- ä¿®æ”¹è¿™é‡Œ
            defaultNickname = selectedPersona.name;
                }
        
        // ä¼˜å…ˆæ˜¾ç¤ºç”¨æˆ·åœ¨ç¾¤èŠä¸­è‡ªå·±è®¾ç½®çš„æ˜µç§°ï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ™æ˜¾ç¤ºåˆ›å»ºç¾¤èŠæ—¶é€‰æ‹©çš„èº«ä»½æ˜µç§°
        currentMyGroupNickname.textContent = chatSettings.myChatNickname || defaultNickname;
            }
            
            // æ¸²æŸ“ç¾¤æˆå‘˜ç½‘æ ¼
            renderGroupMembersGrid();
        }
        
        function changeGroupAvatar() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            
            const tempInput = document.createElement('input');
            tempInput.type = 'file';
            tempInput.accept = 'image/*,.jpg,.jpeg,.png,.gif,.webp';
            tempInput.style.display = 'none';
            document.body.appendChild(tempInput);
            
            tempInput.onchange = function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = async function(event) {
                        // æ›´æ–°å½“å‰ç¾¤èŠè§’è‰²çš„å¤´åƒ
                        currentChatCharacter.avatarUrl = event.target.result;
                        
                        // å¦‚æœæ˜¯ç¾¤èŠï¼Œéœ€è¦æ›´æ–°ç¾¤èŠæ•°æ®
                        if (groupChats) {
                            const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                            if (groupIndex !== -1) {
                                groupChats[groupIndex].avatarUrl = event.target.result;
                                await saveGroupChats(groupChats);
                            }
                        }
                        
                        // æ›´æ–°UIæ˜¾ç¤º
                        updateGroupChatInfo();

                        // ğŸ”¥ã€ä¿®å¤ã€‘ç¾¤èŠæ ‡é¢˜æ˜¾ç¤ºæˆå‘˜æ•°é‡
                        let displayTitle = currentChatCharacter.name;
                        if (currentChatCharacter.members) {
                            const memberCount = currentChatCharacter.members.length + 1; // +1 åŒ…æ‹¬ç”¨æˆ·è‡ªå·±
                            displayTitle = `${currentChatCharacter.name}ï¼ˆ${memberCount}ï¼‰`;
                        }
                        document.getElementById('api-chat-title').textContent = displayTitle;
                        
                        // æ›´æ–°å¤´åƒæ˜¾ç¤º
                        const chatAvatarElement = document.querySelector('#api-chat-screen .message-avatar img');
                        if (chatAvatarElement) {
                            chatAvatarElement.src = event.target.result;
                        }
                        
                        // æ›´æ–°æ¶ˆæ¯åˆ—è¡¨å’Œè”ç³»äººåˆ—è¡¨ä¸­çš„ç¾¤èŠå¤´åƒ
                        renderContactList();
                        renderMessageList();
                        
                        document.body.removeChild(tempInput);
                    };
                    reader.readAsDataURL(e.target.files[0]);
                } else {
                    document.body.removeChild(tempInput);
                }
            };
            
            tempInput.click();
        }
        
        function changeGroupName() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            
            const newName = prompt('è¯·è¾“å…¥æ–°çš„ç¾¤èŠåç§°:', currentChatCharacter.name);
            if (newName && newName.trim() !== '') {
                const trimmedName = newName.trim();
                
                // æ›´æ–°å½“å‰ç¾¤èŠè§’è‰²çš„åç§°
                currentChatCharacter.name = trimmedName;
                
                // å¦‚æœæ˜¯ç¾¤èŠï¼Œéœ€è¦æ›´æ–°ç¾¤èŠæ•°æ®
                if (groupChats) {
                    const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                    if (groupIndex !== -1) {
                        groupChats[groupIndex].name = trimmedName;
                        saveGroupChats(groupChats);
                    }
                }
                
                // æ›´æ–°UIæ˜¾ç¤º
                updateGroupChatInfo();

                // ğŸ”¥ã€ä¿®å¤ã€‘ç¾¤èŠæ ‡é¢˜æ˜¾ç¤ºæˆå‘˜æ•°é‡
                let displayTitle = trimmedName;
                if (currentChatCharacter.members) {
                    const memberCount = currentChatCharacter.members.length + 1; // +1 åŒ…æ‹¬ç”¨æˆ·è‡ªå·±
                    displayTitle = `${trimmedName}ï¼ˆ${memberCount}ï¼‰`;
                }
                document.getElementById('api-chat-title').textContent = displayTitle;
                renderContactList();
                renderMessageList();
            }
        }
        
// --- è¯·ä»è¿™é‡Œå¼€å§‹å¤åˆ¶ï¼Œæ›¿æ¢æ‰æ—§çš„ showGroupChatMemberSelection å’Œ renderGroupMembersGrid å‡½æ•° ---

// 5. æ˜¾ç¤ºç¾¤æˆå‘˜é€‰æ‹© (å·²ä¿®æ­£ç‰ˆæœ¬)
function showGroupChatMemberSelection(personaId) {
    console.log('âœ… ç¬¬äºŒä¸ªshowGroupChatMemberSelectionè¢«è°ƒç”¨ï¼Œæ¥æ”¶åˆ°çš„personaId:', personaId);
    
    // ç«‹å³å°†personaIdå­˜å‚¨åˆ°å…¨å±€å˜é‡ä¸­ï¼Œç¡®ä¿ä¸ä¼šä¸¢å¤±
    window.currentGroupPersonaId = personaId;
    
    // é‡ç½®è¡¨å•
    document.getElementById('group-chat-name').value = '';
    selectedGroupMembers = [];
    
    const membersContainer = document.getElementById('group-chat-members');
    membersContainer.innerHTML = '';
    
    if (characters.length < 2) {
        membersContainer.innerHTML = '<p class="empty-mount-chats">è‡³å°‘éœ€è¦2ä¸ªè§’è‰²æ‰èƒ½åˆ›å»ºç¾¤èŠ</p>';
    } else {
        characters.forEach(character => {
            const memberItem = document.createElement('div');
            memberItem.className = 'group-member-item';
            memberItem.onclick = () => toggleGroupMemberSelection(character.id);
            // å…³é”®ä¿®å¤ï¼šé‡æ–°æ·»åŠ äº†æ˜¾ç¤ºè§’è‰²ç®€ä»‹çš„HTMLä»£ç 
            memberItem.innerHTML = `
                <div class="group-member-checkbox" id="checkbox-${character.id}"></div>
                <div class="message-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url('${character.avatarUrl}'); background-size: cover; background-position: center;` : ''}">
                    ${character.avatarUrl ? '' : character.name.charAt(0)}
                </div>
                <div class="chat-option-text">
                    <div class="chat-option-title">${character.name}</div>
                    <div class="chat-option-desc">${truncateText(character.bio || 'æš‚æ— ç®€ä»‹', 80)}</div>
                </div>`;
            membersContainer.appendChild(memberItem);
        });
    }

    // å°† personaId é™„åŠ åˆ°åˆ›å»ºæŒ‰é’®ä¸Š
    console.log('âœ… åœ¨ç¬¬äºŒä¸ªä½ç½®ç»‘å®šåˆ›å»ºæŒ‰é’®ï¼ŒpersonaId:', personaId);
    const createBtn = document.getElementById('group-chat-modal').querySelector('.modal-primary');
    createBtn.onclick = () => {
        console.log('âœ… ç¬¬äºŒä¸ªä½ç½®çš„åˆ›å»ºç¾¤èŠæŒ‰é’®è¢«ç‚¹å‡»ï¼Œç›´æ¥ä½¿ç”¨å‚æ•°personaId:', personaId);
        createGroupChat(personaId);
    }; // ç»‘å®šå¸¦å‚æ•°çš„åˆ›å»ºå‡½æ•°

    showModal('group-chat-modal');
}


// æ¸²æŸ“ç¾¤æˆå‘˜ç½‘æ ¼ (å·²ä¿®æ­£ç‰ˆæœ¬)
        function renderGroupMembersGrid() {
            const groupMembersGrid = document.getElementById('group-members-grid');
            if (!groupMembersGrid || !currentChatCharacter || !currentChatCharacter.isGroup) return;
            
            // æ¸…ç©ºç°æœ‰å†…å®¹
            groupMembersGrid.innerHTML = '';
            
    // --- å…³é”®ä¿®å¤ï¼šæ­£ç¡®è·å–å¹¶æ˜¾ç¤ºç”¨æˆ·åœ¨å½“å‰ç¾¤èŠä¸­çš„èº«ä»½ ---
    const chatSettings = getCurrentChatSettings(); // è·å–å½“å‰ç¾¤èŠçš„ä¸“å±è®¾ç½®
    const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
    
            let userName = 'ç”¨æˆ·';
            let userAvatar = '';
            
    if (selectedPersona) {
        // ä¼˜å…ˆä½¿ç”¨ç¾¤èŠè®¾ç½®é‡Œä¸ºâ€œæˆ‘â€å•ç‹¬è®¾ç½®çš„æ˜µç§°å’Œå¤´åƒ
        userName = chatSettings.myChatNickname || selectedPersona.name;
        userAvatar = chatSettings.myChatAvatar || selectedPersona.avatarUrl;
    }
    
    // æ·»åŠ ç”¨æˆ·è‡ªå·±ï¼ˆæ’åœ¨ç¬¬ä¸€ä½ï¼‰
    const userItem = document.createElement('div');
    userItem.className = 'member-item user-member';
    userItem.onclick = () => changeMyGroupAvatar();
            userItem.innerHTML = `
                <img class="member-avatar" src="${userAvatar || createDefaultAvatar(userName)}" alt="${userName}">
                <div class="member-name">${userName}</div>
            `;
            groupMembersGrid.appendChild(userItem);
    // --- ä¿®å¤ç»“æŸ ---
            
            // ç„¶åæ·»åŠ ç¾¤å†…ç°æœ‰è§’è‰²
            if (currentChatCharacter.members && currentChatCharacter.members.length > 0) {
                currentChatCharacter.members.forEach(member => {
                    const memberItem = document.createElement('div');
                    memberItem.className = 'member-item';
                    
                    memberItem.innerHTML = `
                        <div class="member-avatar-wrapper">
                            <img class="member-avatar clickable-avatar" 
                                 src="${member.avatarUrl || createDefaultAvatar(member.name)}" 
                                 alt="${member.name}"
                                 onclick="changeMemberAvatar('${member.id}', event)"
                                 title="ç‚¹å‡»æ›´æ¢${member.name}çš„å¤´åƒ">
                            <div class="avatar-hover-hint">
                                <i class="fas fa-camera"></i>
                            </div>
                        </div>
                        <div class="member-name">${member.name}</div>
                    `;
                    groupMembersGrid.appendChild(memberItem);
                });
            }
            
            // æ·»åŠ é‚€è¯·æŒ‰é’®
            const addMemberBtn = document.createElement('div');
            addMemberBtn.className = 'member-item add-member';
            addMemberBtn.onclick = () => addGroupMember();
            addMemberBtn.innerHTML = `
                <div class="member-avatar add-avatar">
                    <i class="fas fa-plus"></i>
                </div>
                <div class="member-name">é‚€è¯·</div>
            `;
            groupMembersGrid.appendChild(addMemberBtn);
            
            // åªè¦ç¾¤å†…æœ‰è§’è‰²æˆå‘˜å°±æ˜¾ç¤ºç§»é™¤æŒ‰é’®
            if (currentChatCharacter.members && currentChatCharacter.members.length > 0) {
                const removeMemberBtn = document.createElement('div');
                removeMemberBtn.className = 'member-item remove-member';
                removeMemberBtn.onclick = () => removeGroupMember();
                removeMemberBtn.innerHTML = `
                    <div class="member-avatar remove-avatar">
                        <i class="fas fa-minus"></i>
                    </div>
                    <div class="member-name">ç§»é™¤</div>
                `;
                groupMembersGrid.appendChild(removeMemberBtn);
            }
        }

// --- è¯·å¤åˆ¶åˆ°è¿™é‡Œç»“æŸ ---
        
        // æ˜¾ç¤ºæˆå‘˜è¯¦æƒ…
        function showMemberProfile(member) {
            alert(`ğŸ‘¤ ç¾¤æˆå‘˜ä¿¡æ¯\n\næ˜µç§°ï¼š${member.name}\nè§’è‰²IDï¼š${member.id}\n\nç‚¹å‡»å¤´åƒå¯ä»¥æŸ¥çœ‹è§’è‰²è¯¦ç»†ä¿¡æ¯`);
        }
        
        // æ˜¾ç¤ºç”¨æˆ·è‡ªå·±çš„èµ„æ–™
        function showUserProfile() {
            let userName = 'ç”¨æˆ·';
            let userInfo = 'ç¾¤èŠæˆå‘˜';
            
            if (currentPersona) {
                userName = currentPersona.name;
                userInfo = `å½“å‰é¢å…·ï¼š${currentPersona.name}`;
                if (currentPersona.description) {
                    userInfo += `\né¢å…·æè¿°ï¼š${currentPersona.description}`;
                }
            } else if (currentChatCharacter.myNickname) {
                userName = currentChatCharacter.myNickname;
                userInfo = `ç¾¤æ˜µç§°ï¼š${currentChatCharacter.myNickname}`;
            }
            
            alert(`ğŸ‘¤ æˆ‘çš„ä¿¡æ¯\n\næ˜µç§°ï¼š${userName}\nèº«ä»½ï¼š${userInfo}\n\nè¿™æ˜¯ä½ è‡ªå·±åœ¨ç¾¤èŠä¸­çš„ä¿¡æ¯`);
        }
        
        // åˆ›å»ºé»˜è®¤å¤´åƒ
        function createDefaultAvatar(name) {
            const canvas = document.createElement('canvas');
            canvas.width = 50;
            canvas.height = 50;
            const ctx = canvas.getContext('2d');
            
            // éšæœºèƒŒæ™¯é¢œè‰²
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF'];
            const bgColor = colors[name.charCodeAt(0) % colors.length];
            
            // ç»˜åˆ¶åœ†å½¢èƒŒæ™¯
            ctx.beginPath();
            ctx.arc(25, 25, 25, 0, 2 * Math.PI);
            ctx.fillStyle = bgColor;
            ctx.fill();
            
            // ç»˜åˆ¶æ–‡å­—
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(name.charAt(0), 25, 25);
            
            return canvas.toDataURL();
        }
        
        function showGroupMembers() {
            alert('ğŸ‘¥ ç¾¤æˆå‘˜ç®¡ç†åŠŸèƒ½å¼€å‘ä¸­...\n\nå°†æ”¯æŒä»¥ä¸‹åŠŸèƒ½ï¼š\nâ€¢ æŸ¥çœ‹ç¾¤æˆå‘˜åˆ—è¡¨\nâ€¢ è®¾ç½®ç¾¤ç®¡ç†å‘˜\nâ€¢ ç®¡ç†ç¾¤æˆå‘˜æƒé™\nâ€¢ ç¦è¨€/è¸¢å‡ºç¾¤èŠ');
        }
        
        async function changeMyGroupNickname() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            
    const chatSettings = getCurrentChatSettings();
    const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
    
    const currentNickname = chatSettings.myChatNickname || (selectedPersona ? selectedPersona.name : 'ç”¨æˆ·');
    const newNickname = prompt('è¯·è¾“å…¥æˆ‘åœ¨æœ¬ç¾¤çš„æ˜µç§°:', currentNickname);

    if (newNickname && newNickname.trim() !== '' && newNickname.trim() !== currentNickname) {
                const trimmedNickname = newNickname.trim();
                
        // 1. æ›´æ–°å½“å‰ç¾¤èŠè®¾ç½®ä¸­çš„æ˜µç§°
        chatSettings.myChatNickname = trimmedNickname;
        await saveCurrentChatSettings(chatSettings);
        
        // 2. åˆ›å»ºå¹¶æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
        const systemMessage = {
            id: 'system_' + Date.now(),
            sender: 'system',
            content: `ä½ å·²å°†ç¾¤æ˜µç§°ä¿®æ”¹ä¸º "${trimmedNickname}"`,
            timestamp: Date.now()
        };
        
        if (!chatMessages[currentChatCharacter.id]) {
            chatMessages[currentChatCharacter.id] = [];
        }
        chatMessages[currentChatCharacter.id].push(systemMessage);
        await saveChatMessages();
        
        // 3. æ›´æ–°UI
        updateGroupChatInfo(); // è¿™ä¼šåˆ·æ–°è®¾ç½®é¡µé¢çš„æ˜¾ç¤º
        renderChatMessages(currentChatCharacter.id); // åˆ·æ–°èŠå¤©ç•Œé¢æ˜¾ç¤ºç³»ç»Ÿæ¶ˆæ¯

        showToast('ç¾¤æ˜µç§°ä¿®æ”¹æˆåŠŸï¼', 'success');
    }
}
// --- æ–°å¢å‡½æ•° ---
async function changeMyGroupAvatar() {
    if (!currentChatCharacter) return;

    // åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„æ–‡ä»¶è¾“å…¥æ¡†
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*,.jpg,.jpeg,.png,.gif,.webp';
    input.style.display = 'none';

    // å½“ç”¨æˆ·é€‰æ‹©äº†æ–‡ä»¶å
    input.onchange = async (e) => {
        if (!e.target.files || !e.target.files[0]) return;
        
        const file = e.target.files[0];
        const reader = new FileReader();

        reader.onload = async (event) => {
            const newAvatarUrl = event.target.result;

            // 1. æ›´æ–°å½“å‰ç¾¤èŠè®¾ç½®ä¸­çš„å¤´åƒ
            const chatSettings = getCurrentChatSettings();
            chatSettings.myChatAvatar = newAvatarUrl;
            await saveCurrentChatSettings(chatSettings);
            
            // 2. åˆ›å»ºå¹¶æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
            const systemMessage = {
                id: 'system_' + Date.now(),
                sender: 'system',
                content: `ä½ æ›´æ¢äº†æ–°å¤´åƒ`,
                timestamp: Date.now()
            };

            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            chatMessages[currentChatCharacter.id].push(systemMessage);
            await saveChatMessages();

            // 3. æ›´æ–°UI
            updateGroupChatInfo(); // åˆ·æ–°è®¾ç½®é¡µé¢çš„æˆå‘˜åˆ—è¡¨
            renderChatMessages(currentChatCharacter.id); // åˆ·æ–°èŠå¤©ç•Œé¢æ˜¾ç¤ºæ–°å¤´åƒå’Œç³»ç»Ÿæ¶ˆæ¯

            showToast('ç¾¤å¤´åƒæ›´æ¢æˆåŠŸï¼', 'success');
        };
        
        reader.readAsDataURL(file);
        document.body.removeChild(input); // æ¸…ç†ä¸´æ—¶çš„inputå…ƒç´ 
    };

    document.body.appendChild(input);
    input.click(); // å¼¹å‡ºæ–‡ä»¶é€‰æ‹©çª—å£
        }
        
        // ç¼–è¾‘ç¾¤å…¬å‘Š
        function editGroupDescription() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            showGroupNoticeModal();
        }
        
        // æ˜¾ç¤ºç¾¤å…¬å‘Šç¼–è¾‘æ¨¡æ€æ¡†
        function showGroupNoticeModal() {
            const modal = document.getElementById('group-notice-modal');
            const textarea = document.getElementById('group-notice-content');
            const charCount = document.getElementById('notice-char-current');
            
            // è®¾ç½®å½“å‰ç¾¤å…¬å‘Šå†…å®¹
            const currentDescription = currentChatCharacter?.description || '';
            textarea.value = currentDescription;
            charCount.textContent = currentDescription.length;
            
            // ç›‘å¬å­—ç¬¦æ•°å˜åŒ–
            textarea.addEventListener('input', updateNoticeCharCount);
            
            modal.style.display = 'flex';
            setTimeout(() => textarea.focus(), 100);
        }
        
        // éšè—ç¾¤å…¬å‘Šç¼–è¾‘æ¨¡æ€æ¡†
        function hideGroupNoticeModal() {
            const modal = document.getElementById('group-notice-modal');
            const textarea = document.getElementById('group-notice-content');
            
            // ç§»é™¤äº‹ä»¶ç›‘å¬å™¨
            textarea.removeEventListener('input', updateNoticeCharCount);
            
            modal.style.display = 'none';
        }
        
        // æ›´æ–°å­—ç¬¦è®¡æ•°
        function updateNoticeCharCount() {
            const textarea = document.getElementById('group-notice-content');
            const charCount = document.getElementById('notice-char-current');
            charCount.textContent = textarea.value.length;
            
            // å¦‚æœè¶…è¿‡é™åˆ¶ï¼Œå˜è‰²æç¤º
            if (textarea.value.length > 500) {
                charCount.style.color = '#ff3b30';
            } else if (textarea.value.length > 450) {
                charCount.style.color = '#ff9500';
            } else {
                charCount.style.color = '#007AFF';
            }
        }
        
        // ä¿å­˜ç¾¤å…¬å‘Š
        function saveGroupNotice() {
            const textarea = document.getElementById('group-notice-content');
            const newDescription = textarea.value.trim();
            
            if (newDescription.length > 500) {
                alert('ç¾¤å…¬å‘Šå†…å®¹ä¸èƒ½è¶…è¿‡500å­—');
                return;
            }
            
                // æ›´æ–°å½“å‰ç¾¤èŠè§’è‰²çš„æè¿°
            currentChatCharacter.description = newDescription;
                
                // å¦‚æœæ˜¯ç¾¤èŠï¼Œéœ€è¦æ›´æ–°ç¾¤èŠæ•°æ®
                if (groupChats) {
                    const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                    if (groupIndex !== -1) {
                    groupChats[groupIndex].description = newDescription;
                        saveGroupChats(groupChats);
                    }
                }
                
                // æ›´æ–°UIæ˜¾ç¤º
                updateGroupChatInfo();
            hideGroupNoticeModal();
            
            // æ˜¾ç¤ºæˆåŠŸæç¤º
            showToast('âœ… ç¾¤å…¬å‘Šä¿å­˜æˆåŠŸ', 'success');
        }
        
        // æ·»åŠ ç¾¤æˆå‘˜ - ä»ç°æœ‰è§’è‰²ä¸­é€‰æ‹©
        function addGroupMember() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            
            // è·å–æ‰€æœ‰è§’è‰²åˆ—è¡¨
            if (!characters || characters.length === 0) {
                alert('æš‚æ— å¯é‚€è¯·çš„è§’è‰²ï¼Œè¯·å…ˆåˆ›å»ºè§’è‰²');
                return;
            }
            
            // è¿‡æ»¤æ‰å·²ç»åœ¨ç¾¤é‡Œçš„è§’è‰²
            const currentMemberIds = currentChatCharacter.members ? currentChatCharacter.members.map(m => m.id) : [];
            const availableCharacters = characters.filter(char => !currentMemberIds.includes(char.id));
            
            if (availableCharacters.length === 0) {
                alert('æ‰€æœ‰è§’è‰²éƒ½å·²ç»åœ¨ç¾¤é‡Œäº†');
                return;
            }
            
            // åˆ›å»ºç¾è§‚çš„é€‰æ‹©ç•Œé¢
            showCharacterSelectionModal(availableCharacters, 'é‚€è¯·ç¾¤æˆå‘˜', 'è¯·é€‰æ‹©è¦é‚€è¯·è¿›ç¾¤çš„è§’è‰²ï¼š', (selectedCharacter) => {
                // æ·»åŠ åˆ°ç¾¤æˆå‘˜åˆ—è¡¨
                if (!currentChatCharacter.members) {
                    currentChatCharacter.members = [];
                }
                currentChatCharacter.members.push({
                    id: selectedCharacter.id,
                    name: selectedCharacter.name,
                    avatarUrl: selectedCharacter.avatarUrl
                });
                
                // ä¿å­˜ç¾¤èŠæ•°æ®
                if (groupChats) {
                    const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                    if (groupIndex !== -1) {
                        groupChats[groupIndex].members = currentChatCharacter.members;
                        saveGroupChats(groupChats);
                    }
                }
                
                // æ›´æ–°UI
                updateGroupChatInfo();
                renderMessageList(); // æ›´æ–°æ¶ˆæ¯åˆ—è¡¨

                // ğŸ”¥ã€æ–°å¢ã€‘æ›´æ–°èŠå¤©ç•Œé¢æ ‡é¢˜æ˜¾ç¤ºæˆå‘˜æ•°é‡
                const chatTitle = document.getElementById('api-chat-title');
                if (chatTitle) {
                    let displayTitle = currentChatCharacter.name;
                    const memberCount = currentChatCharacter.members.length + 1; // +1 åŒ…æ‹¬ç”¨æˆ·è‡ªå·±
                    displayTitle = `${displayTitle}ï¼ˆ${memberCount}ï¼‰`;
                    chatTitle.textContent = displayTitle;
                }

                showToast(`âœ… ${selectedCharacter.name} å·²åŠ å…¥ç¾¤èŠ`, 'success');
            });
        }
        
        // ç§»é™¤ç¾¤æˆå‘˜
        function removeGroupMember() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup || !currentChatCharacter.members) return;
            
            if (currentChatCharacter.members.length <= 1) {
                alert('ç¾¤èŠè‡³å°‘éœ€è¦ä¿ç•™ä¸€ä¸ªè§’è‰²æˆå‘˜ï¼ˆä¸åŒ…æ‹¬ç”¨æˆ·è‡ªå·±ï¼‰');
                return;
            }
            
            // åˆ›å»ºç¾è§‚çš„é€‰æ‹©ç•Œé¢
            showCharacterSelectionModal(currentChatCharacter.members, 'ç§»é™¤ç¾¤æˆå‘˜', 'è¯·é€‰æ‹©è¦ç§»å‡ºç¾¤èŠçš„æˆå‘˜ï¼š', (selectedMember) => {
                if (confirm(`ç¡®å®šè¦å°† ${selectedMember.name} ç§»å‡ºç¾¤èŠå—ï¼Ÿ`)) {
                    // ä»ç¾¤æˆå‘˜åˆ—è¡¨ä¸­ç§»é™¤
                    const memberIndex = currentChatCharacter.members.findIndex(m => m.id === selectedMember.id);
                    if (memberIndex !== -1) {
                        currentChatCharacter.members.splice(memberIndex, 1);
                        
                        // ä¿å­˜ç¾¤èŠæ•°æ®
                        if (groupChats) {
                            const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                            if (groupIndex !== -1) {
                                groupChats[groupIndex].members = currentChatCharacter.members;
                                saveGroupChats(groupChats);
                            }
                        }
                        
                        // æ›´æ–°UI
                        updateGroupChatInfo();
                        renderMessageList(); // æ›´æ–°æ¶ˆæ¯åˆ—è¡¨

                        // ğŸ”¥ã€æ–°å¢ã€‘æ›´æ–°èŠå¤©ç•Œé¢æ ‡é¢˜æ˜¾ç¤ºæˆå‘˜æ•°é‡
                        const chatTitle = document.getElementById('api-chat-title');
                        if (chatTitle) {
                            let displayTitle = currentChatCharacter.name;
                            const memberCount = currentChatCharacter.members.length + 1; // +1 åŒ…æ‹¬ç”¨æˆ·è‡ªå·±
                            displayTitle = `${displayTitle}ï¼ˆ${memberCount}ï¼‰`;
                            chatTitle.textContent = displayTitle;
                        }

                        showToast(`âœ… ${selectedMember.name} å·²è¢«ç§»å‡ºç¾¤èŠ`, 'success');
                    }
                }
            });
        }
        
        // ç¾¤å…¬å‘ŠåŠŸèƒ½
        function showGroupNotice() {
            const notice = currentChatCharacter?.description || 'æš‚æ— ç¾¤å…¬å‘Š';
            alert(`ğŸ“¢ ç¾¤å…¬å‘Š\n\n${notice}\n\nç‚¹å‡»ç¾¤ä¿¡æ¯å¡ç‰‡çš„å…¬å‘ŠåŒºåŸŸå¯ä»¥ç¼–è¾‘ç¾¤å…¬å‘Š`);
        }
        

        
        // ç¾¤åº”ç”¨åŠŸèƒ½
        function showGroupVote() {
            alert('ğŸ—³ï¸ ç¾¤æŠ•ç¥¨åŠŸèƒ½å¼€å‘ä¸­...\n\nå°†æ”¯æŒä»¥ä¸‹åŠŸèƒ½ï¼š\nâ€¢ åˆ›å»ºæŠ•ç¥¨è¯é¢˜\nâ€¢ è®¾ç½®æŠ•ç¥¨é€‰é¡¹\nâ€¢ å®æ—¶æŠ•ç¥¨ç»“æœ\nâ€¢ æŠ•ç¥¨æˆªæ­¢æ—¶é—´');
        }
        
        function showGroupActivity() {
            alert('ğŸ“… ç¾¤æ´»åŠ¨åŠŸèƒ½å¼€å‘ä¸­...\n\nå°†æ”¯æŒä»¥ä¸‹åŠŸèƒ½ï¼š\nâ€¢ åˆ›å»ºç¾¤æ´»åŠ¨\nâ€¢ æ´»åŠ¨æŠ¥åç»Ÿè®¡\nâ€¢ æ´»åŠ¨æé†’\nâ€¢ æ´»åŠ¨ç­¾åˆ°');
        }
        
        function showGroupTask() {
            alert('âœ… ç¾¤ä»»åŠ¡åŠŸèƒ½å¼€å‘ä¸­...\n\nå°†æ”¯æŒä»¥ä¸‹åŠŸèƒ½ï¼š\nâ€¢ å‘å¸ƒç¾¤ä»»åŠ¡\nâ€¢ ä»»åŠ¡è®¤é¢†\nâ€¢ å®ŒæˆçŠ¶æ€è·Ÿè¸ª\nâ€¢ ç§¯åˆ†å¥–åŠ±ç³»ç»Ÿ');
        }
        
        function showMoreApps() {
            alert('ğŸ”§ æ›´å¤šç¾¤åº”ç”¨\n\nå³å°†æ¨å‡ºï¼š\nâ€¢ ç¾¤ç›´æ’­\nâ€¢ ç¾¤æ¸¸æˆ\nâ€¢ ç¾¤çº¢åŒ…\nâ€¢ ç¾¤æœºå™¨äºº\nâ€¢ ç¾¤æ—¥ç¨‹\nâ€¢ ç¾¤ç¬”è®°');
        }
        
        // æ˜¾ç¤ºè§’è‰²é€‰æ‹©æ¨¡æ€æ¡†
        function showCharacterSelectionModal(characterList, title, description, onSelect) {
            const modalHTML = `
                <div class="modal character-selection-modal" id="character-selection-modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 class="modal-title">${title}</h3>
                            <button class="modal-close" onclick="hideCharacterSelectionModal()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p class="selection-description">${description}</p>
                            <div class="character-selection-grid" id="character-selection-grid">
                                ${characterList.map(char => `
                                    <div class="character-selection-item" data-character-id="${char.id}">
                                        <div class="character-selection-avatar">
                                            <img src="${char.avatarUrl || createDefaultAvatar(char.name)}" alt="${char.name}">
                                        </div>
                                        <div class="character-selection-info">
                                            <div class="character-selection-name">${char.name}</div>
                                            <div class="character-selection-bio">${(char.description || char.bio || 'æš‚æ— ç®€ä»‹').substring(0, 30)}${(char.description || char.bio || '').length > 30 ? '...' : ''}</div>
                                        </div>
                                        <div class="character-selection-check">
                                            <i class="fas fa-check"></i>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-secondary" onclick="hideCharacterSelectionModal()">å–æ¶ˆ</button>
                            <button class="modal-primary" id="confirm-selection-btn" onclick="confirmCharacterSelection()" disabled>ç¡®å®š</button>
                        </div>
                    </div>
                </div>
            `;
            
            const existingModal = document.getElementById('character-selection-modal');
            if (existingModal) {
                existingModal.remove();
            }
            
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            
            window.characterSelectionCallback = onSelect;
            window.selectedCharacterId = null;
            
            document.querySelectorAll('.character-selection-item').forEach(item => {
                item.addEventListener('click', function() {
                    document.querySelectorAll('.character-selection-item').forEach(i => i.classList.remove('selected'));
                    this.classList.add('selected');
                    window.selectedCharacterId = this.dataset.characterId;
                    document.getElementById('confirm-selection-btn').disabled = false;
                });
            });
        }
        
        // éšè—è§’è‰²é€‰æ‹©æ¨¡æ€æ¡†
        function hideCharacterSelectionModal() {
            const modal = document.getElementById('character-selection-modal');
            if (modal) {
                modal.remove();
            }
            window.characterSelectionCallback = null;
            window.selectedCharacterId = null;
        }
        
        // ç¡®è®¤è§’è‰²é€‰æ‹©
        function confirmCharacterSelection() {
            if (!window.selectedCharacterId || !window.characterSelectionCallback) return;
            
            const allCharacters = [...characters, ...(currentChatCharacter.members || [])];
            const selectedCharacter = allCharacters.find(char => char.id === window.selectedCharacterId);
            
            if (selectedCharacter) {
                window.characterSelectionCallback(selectedCharacter);
                hideCharacterSelectionModal();
            }
        }
        
        // ğŸ”¥ã€æ–°å¢ã€‘ç¾¤æˆå‘˜å¤´åƒæ›´æ¢åŠŸèƒ½
        function changeMemberAvatar(memberId, event) {
            event.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡
            
            const member = currentChatCharacter.members.find(m => m.id === memberId);
            if (!member) return;
            
            // æ˜¾ç¤ºå¤´åƒæ›´æ¢æ¨¡æ€æ¡†
            showMemberAvatarModal(member);
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ˜¾ç¤ºç¾¤æˆå‘˜å¤´åƒæ›´æ¢æ¨¡æ€æ¡†
        function showMemberAvatarModal(member) {
            const modal = document.getElementById('member-avatar-modal');
            const preview = document.getElementById('member-avatar-preview');
            const memberName = document.getElementById('member-avatar-name');
            const uploadInput = document.getElementById('member-avatar-upload');
            
            // è®¾ç½®å½“å‰æˆå‘˜ä¿¡æ¯
            window.currentEditingMember = member;
            memberName.textContent = member.name;
            preview.src = member.avatarUrl || createDefaultAvatar(member.name);
            
            // é‡ç½®æ–‡ä»¶è¾“å…¥
            uploadInput.value = '';
            
            modal.style.display = 'flex';
        }

        // ğŸ”¥ã€æ–°å¢ã€‘éšè—ç¾¤æˆå‘˜å¤´åƒæ›´æ¢æ¨¡æ€æ¡†
        function hideMemberAvatarModal() {
            const modal = document.getElementById('member-avatar-modal');
            modal.style.display = 'none';
            window.currentEditingMember = null;
        }

        // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†ç¾¤æˆå‘˜å¤´åƒä¸Šä¼ 
        function handleMemberAvatarUpload() {
            const uploadInput = document.getElementById('member-avatar-upload');
            uploadInput.click();
        }

        // ğŸ”¥ã€æ–°å¢ã€‘ä¿å­˜ç¾¤æˆå‘˜å¤´åƒ
        function saveMemberAvatar() {
            if (!window.currentEditingMember) return;
            
            const preview = document.getElementById('member-avatar-preview');
            const newAvatarUrl = preview.src;
            
            // æ›´æ–°ç¾¤æˆå‘˜å¤´åƒ
            const memberIndex = currentChatCharacter.members.findIndex(m => m.id === window.currentEditingMember.id);
            if (memberIndex !== -1) {
                currentChatCharacter.members[memberIndex].avatarUrl = newAvatarUrl;
                
                // åŒæ—¶æ›´æ–°å…¨å±€è§’è‰²åˆ—è¡¨ä¸­çš„å¤´åƒ
                const characterIndex = characters.findIndex(c => c.id === window.currentEditingMember.id);
                if (characterIndex !== -1) {
                    characters[characterIndex].avatarUrl = newAvatarUrl;
                    saveCharacters(characters);
                }
                
                // ä¿å­˜ç¾¤èŠæ•°æ®
                if (groupChats) {
                    const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                    if (groupIndex !== -1) {
                        groupChats[groupIndex].members = currentChatCharacter.members;
                        saveGroupChats(groupChats);
                    }
                }
                
                // ğŸ”¥ã€æ–°å¢ã€‘åœ¨ç¾¤èŠæ¶ˆæ¯ä¸­æ·»åŠ å¤´åƒæ›´æ¢æç¤º
                addAvatarChangeMessage(window.currentEditingMember.name);
                
                // æ›´æ–°UI
                updateGroupChatInfo();
                renderGroupMembersGrid();
                refreshChatMessages(); // åˆ·æ–°èŠå¤©æ¶ˆæ¯æ˜¾ç¤ºæ–°å¤´åƒ
                
                showToast(`âœ… ${window.currentEditingMember.name} çš„å¤´åƒå·²æ›´æ–°`, 'success');
            }
            
            hideMemberAvatarModal();
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ·»åŠ å¤´åƒæ›´æ¢ç³»ç»Ÿæ¶ˆæ¯
        function addAvatarChangeMessage(memberName) {
            if (!currentChatCharacter || !chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            
            const systemMessage = {
                id: 'system_' + Date.now(),
                sender: 'system',
                content: `${memberName} æ›´æ¢äº†å¤´åƒ`,
                timestamp: Date.now(),
                isSystem: true
            };
            
            chatMessages[currentChatCharacter.id].push(systemMessage);
            saveChatMessages();
            
            // åˆ·æ–°èŠå¤©ç•Œé¢
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘åˆ·æ–°èŠå¤©æ¶ˆæ¯ä»¥æ˜¾ç¤ºæ–°å¤´åƒ
        function refreshChatMessages() {
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘é‡ç½®ç¾¤æˆå‘˜å¤´åƒä¸ºé»˜è®¤
        function resetMemberAvatar() {
            if (!window.currentEditingMember) return;
            
            const preview = document.getElementById('member-avatar-preview');
            const defaultAvatar = createDefaultAvatar(window.currentEditingMember.name);
            preview.src = defaultAvatar;
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ•°æ®æ¢å¤æ£€æŸ¥å’Œä¿®å¤åŠŸèƒ½
        async function checkAndFixChatHistory() {
            try {
                console.log('å¼€å§‹æ£€æŸ¥èŠå¤©å†å²æ•°æ®...');
                
                // æ£€æŸ¥IndexedDBä¸­çš„æ•°æ®
                const dbMessages = await db.chatMessages.toArray();
                const memoryMessages = chatMessages;
                
                console.log('IndexedDBä¸­çš„æ¶ˆæ¯æ•°:', dbMessages.length);
                console.log('å†…å­˜ä¸­çš„èŠå¤©æ•°:', Object.keys(memoryMessages).length);
                
                // æ£€æŸ¥æ˜¯å¦æœ‰localStorageçš„å¤‡ä»½æ•°æ®
                const localStorageBackup = localStorage.getItem('chatMessages');
                if (localStorageBackup) {
                    try {
                        const backupData = JSON.parse(localStorageBackup);
                        console.log('æ‰¾åˆ°localStorageå¤‡ä»½æ•°æ®');
                        
                        // æ¯”è¾ƒæ•°æ®æ—¶é—´æˆ³ï¼Œé€‰æ‹©æœ€æ–°çš„
                        let shouldUseBackup = false;
                        let newerMessagesCount = 0;
                        
                        for (const [characterId, messages] of Object.entries(backupData)) {
                            if (messages && messages.length > 0) {
                                const latestBackupTime = Math.max(...messages.map(m => m.timestamp || 0));
                                const currentMessages = memoryMessages[characterId] || [];
                                const latestCurrentTime = currentMessages.length > 0 ? 
                                    Math.max(...currentMessages.map(m => m.timestamp || 0)) : 0;
                                
                                if (latestBackupTime > latestCurrentTime) {
                                    console.log(`è§’è‰² ${characterId} çš„å¤‡ä»½æ•°æ®æ›´æ–° (å¤‡ä»½:${new Date(latestBackupTime)}, å½“å‰:${new Date(latestCurrentTime)})`);
                                    shouldUseBackup = true;
                                    newerMessagesCount += messages.length - currentMessages.length;
                                }
                            }
                        }
                        
                        if (shouldUseBackup) {
                            const confirmRestore = confirm(`æ£€æµ‹åˆ°localStorageä¸­æœ‰æ›´æ–°çš„èŠå¤©è®°å½•ï¼\n\nå‘ç° ${newerMessagesCount} æ¡æ›´æ–°çš„æ¶ˆæ¯\n\næ˜¯å¦æ¢å¤è¿™äº›æ•°æ®ï¼Ÿ`);
                            if (confirmRestore) {
                                // æ¢å¤æ•°æ®
                                Object.assign(chatMessages, backupData);
                                await saveChatMessages();
                                
                                // é‡æ–°æ¸²æŸ“å½“å‰èŠå¤©
                                if (currentChatCharacter) {
                                    renderChatMessages(currentChatCharacter.id);
                                }
                                
                                showToast(`å·²æ¢å¤ ${newerMessagesCount} æ¡æ¶ˆæ¯ï¼`, 'success');
                                return true;
                            }
                        }
                    } catch (e) {
                        console.error('è§£æå¤‡ä»½æ•°æ®å¤±è´¥:', e);
                    }
                }
                
                // æ£€æŸ¥æ˜¯å¦æœ‰å¼‚å¸¸çš„æ—¶é—´æˆ³ï¼ˆæœªæ¥æ—¶é—´æˆ–è¿‡è€æ—¶é—´ï¼‰
                let fixedCount = 0;
                const now = Date.now();
                const oneWeekAgo = now - (7 * 24 * 60 * 60 * 1000);
                
                for (const [characterId, messages] of Object.entries(chatMessages)) {
                    if (messages && Array.isArray(messages)) {
                        for (let i = 0; i < messages.length; i++) {
                            const msg = messages[i];
                            if (!msg.timestamp || msg.timestamp > now || msg.timestamp < oneWeekAgo) {
                                // ä¿®å¤å¼‚å¸¸æ—¶é—´æˆ³
                                const correctedTime = now - (messages.length - i) * 60000; // æŒ‰é¡ºåºé€’å‡1åˆ†é’Ÿ
                                console.log(`ä¿®å¤æ¶ˆæ¯æ—¶é—´æˆ³: ${msg.timestamp} -> ${correctedTime}`);
                                msg.timestamp = correctedTime;
                                fixedCount++;
                            }
                        }
                        
                        // é‡æ–°æ’åºæ¶ˆæ¯
                        messages.sort((a, b) => a.timestamp - b.timestamp);
                    }
                }
                
                if (fixedCount > 0) {
                    await saveChatMessages();
                    showToast(`ä¿®å¤äº† ${fixedCount} æ¡æ¶ˆæ¯çš„æ—¶é—´æˆ³`, 'info');
                }
                
                return false;
            } catch (error) {
                console.error('æ£€æŸ¥èŠå¤©å†å²å¤±è´¥:', error);
                return false;
            }
        }

        // æ˜¾ç¤ºæç¤ºæ¶ˆæ¯
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.textContent = message;
            
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
                color: white;
                padding: 12px 24px;
                border-radius: 25px;
                font-size: 14px;
                z-index: 10000;
                opacity: 0;
                transition: all 0.3s ease;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            `;
            
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '1';
                toast.style.transform = 'translateX(-50%) translateY(10px)';
            }, 100);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(-50%) translateY(-10px)';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, 3000);
        }

        // æ–‡æœ¬æˆªæ–­å‡½æ•°
        function truncateText(text, maxLength = 80) {
            // ğŸ”¥ã€ä¿®å¤ã€‘ç¡®ä¿textæ˜¯å­—ç¬¦ä¸²ç±»å‹
            if (text === null || text === undefined) {
                return '';
            }
            
            // å¦‚æœä¸æ˜¯å­—ç¬¦ä¸²ï¼Œè½¬æ¢ä¸ºå­—ç¬¦ä¸²
            if (typeof text !== 'string') {
                text = String(text);
            }
            
            if (!text || text.length <= maxLength) return text;
            
            // æŒ‰è¡Œåˆ†å‰²æ–‡æœ¬
            const lines = text.split('\n');
            let result = '';
            let lineCount = 0;
            
            for (const line of lines) {
                // é™åˆ¶æœ€å¤šæ˜¾ç¤º3è¡Œ
                if (lineCount >= 3) break;
                
                if (result.length + line.length + 1 <= maxLength) {
                    result += (result ? '\n' : '') + line;
                    lineCount++;
                } else {
                    // å¦‚æœè¿™ä¸€è¡Œä¼šè¶…å‡ºé•¿åº¦é™åˆ¶ï¼Œæˆªæ–­å¹¶æ·»åŠ çœç•¥å·
                    const remaining = maxLength - result.length - 1;
                    if (remaining > 10) { // ç¡®ä¿æœ‰è¶³å¤Ÿç©ºé—´æ˜¾ç¤ºæœ‰æ„ä¹‰çš„å†…å®¹
                        result += (result ? '\n' : '') + line.substring(0, remaining - 3) + '...';
                    } else if (!result) {
                        // å¦‚æœæ˜¯ç¬¬ä¸€è¡Œå°±è¶…é•¿ï¼Œç›´æ¥æˆªæ–­
                        result = line.substring(0, maxLength - 3) + '...';
                    } else {
                        // å¦åˆ™åœ¨å½“å‰ç»“æœååŠ çœç•¥å·
                        result += '...';
                    }
                    break;
                }
            }
            
            return result;
        }
        
        // ğŸ”¥ã€æ–°å¢ã€‘æ¶ˆæ¯åˆ—è¡¨å¤šé€‰åˆ é™¤åŠŸèƒ½
        
        // è¿›å…¥æ¶ˆæ¯åˆ—è¡¨å¤šé€‰æ¨¡å¼
        function enterMessageListMultiSelectMode(conversationId) {
            console.log('è§¦å‘é•¿æŒ‰å¤šé€‰æ¨¡å¼ï¼Œå¯¹è¯ID:', conversationId); // è°ƒè¯•ä¿¡æ¯
            isMessageListMultiSelectMode = true;
            selectedConversations = [conversationId]; // å°†è§¦å‘é•¿æŒ‰çš„å¯¹è¯æ·»åŠ åˆ°é€‰ä¸­åˆ—è¡¨
            renderMessageList(); // é‡æ–°æ¸²æŸ“åˆ—è¡¨ä»¥æ˜¾ç¤ºå¤šé€‰ç•Œé¢
            showToast('å·²è¿›å…¥å¤šé€‰æ¨¡å¼ï¼Œå¯ä»¥é€‰æ‹©å¤šä¸ªå¯¹è¯è¿›è¡Œåˆ é™¤', 'info');
        }
        
        // é€€å‡ºæ¶ˆæ¯åˆ—è¡¨å¤šé€‰æ¨¡å¼
        function exitMessageListMultiSelectMode() {
            isMessageListMultiSelectMode = false;
            selectedConversations = [];

            renderMessageList(); // é‡æ–°æ¸²æŸ“åˆ—è¡¨æ¢å¤æ­£å¸¸çŠ¶æ€
        }
        
        // åˆ‡æ¢å¯¹è¯é€‰æ‹©çŠ¶æ€
        function toggleConversationSelection(conversationId) {
            const index = selectedConversations.indexOf(conversationId);
            if (index > -1) {
                selectedConversations.splice(index, 1);
            } else {
                selectedConversations.push(conversationId);
            }
            renderMessageList(); // é‡æ–°æ¸²æŸ“ä»¥æ›´æ–°é€‰æ‹©çŠ¶æ€
        }
        
        // åˆ é™¤é€‰ä¸­çš„å¯¹è¯
        async function deleteSelectedConversations() {
            if (selectedConversations.length === 0) {
                showToast('è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„å¯¹è¯', 'error');
                return;
            }
            
            const count = selectedConversations.length;
            const confirmText = `ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${count} ä¸ªå¯¹è¯å—ï¼Ÿ\n\nåˆ é™¤åå°†æ¸…ç©ºå¯¹è¯çš„æ‰€æœ‰èŠå¤©è®°å½•å’Œä¸“å±è®¾ç½®ï¼Œæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`;
            
            if (confirm(confirmText)) {
                try {
                    // ä½¿ç”¨ for...of å¾ªç¯æ¥ç¡®ä¿å¼‚æ­¥æ“ä½œä¸€ä¸ªæ¥ä¸€ä¸ªå®Œæˆ
                    for (const conversationId of selectedConversations) {
                        // 1. åˆ é™¤èŠå¤©æ¶ˆæ¯
                    if (chatMessages[conversationId]) {
                        delete chatMessages[conversationId];
                    }
                    
                        // 2. [æ ¸å¿ƒä¿®å¤] ä»æ•°æ®åº“ä¸­åˆ é™¤æ­¤å¯¹è¯çš„è®¾ç½®
                        await db.chatSettings.delete(conversationId);
                        //    åŒæ—¶ä»å†…å­˜ä¸­ä¹Ÿåˆ é™¤ï¼Œä¿æŒåŒæ­¥
                        if (chatSettings[conversationId]) {
                            delete chatSettings[conversationId];
                        }
                        
                        // 2.1 [é¢å¤–ä¿®å¤] åˆ é™¤localStorageä¸­çš„å¤‡ä»½è®¾ç½®
                        localStorage.removeItem(`chatSettings_${conversationId}`);
                        
                        // 2.2 [å½»åº•ä¿®å¤] åˆ é™¤è§’è‰²å¯¹è±¡ä¸­çš„èƒŒæ™¯è®¾ç½®
                        const character = characters.find(c => c.id === conversationId);
                        if (character) {
                            character.background = null;
                            // è¿™é‡Œä¸éœ€è¦ç«‹å³ä¿å­˜ï¼Œåé¢ä¼šç»Ÿä¸€ä¿å­˜
                        }

                        // 3. ğŸ”¥ã€ä¿®å¤ã€‘åŒºåˆ†å•èŠå’Œç¾¤èŠçš„åˆ é™¤é€»è¾‘
                        const groupIndex = groupChats.findIndex(g => g.id === conversationId);
                        if (groupIndex > -1) {
                            // å¦‚æœæ˜¯ç¾¤èŠï¼Œä»ç¾¤èŠåˆ—è¡¨ä¸­åˆ é™¤
                            groupChats.splice(groupIndex, 1);
                        } else {
                            // å¦‚æœæ˜¯å•èŠï¼Œä»è”ç³»äººåˆ—è¡¨ä¸­ç§»é™¤ (è¿™ä»£è¡¨ç§»é™¤äº†ä¸€ä¸ª"æ´»è·ƒå¯¹è¯")
                            const contactIndex = contacts.indexOf(conversationId);
                            if (contactIndex > -1) {
                                contacts.splice(contactIndex, 1);
                            }
                        }
                    }

                    // 4. å¼‚æ­¥ä¿å­˜æ‰€æœ‰æ›´æ”¹
                    await Promise.all([
                        saveChatMessages(),
                        saveGroupChats(),
                        saveContacts()
                        // ğŸ”¥ã€ä¿®å¤ã€‘ä¸å†éœ€è¦ä¿å­˜ charactersï¼Œå› ä¸ºæˆ‘ä»¬æ²¡æœ‰ä¿®æ”¹è§’è‰²æœ¬èº«
                    ]);

                    // 5. é€€å‡ºå¤šé€‰æ¨¡å¼å¹¶åˆ·æ–°UI
                    exitMessageListMultiSelectMode(); // è¿™ä¸ªå‡½æ•°å†…éƒ¨ä¼šè°ƒç”¨ renderMessageList()
                
                showToast(`âœ… å·²åˆ é™¤ ${count} ä¸ªå¯¹è¯`, 'success');

                } catch (error) {
                    console.error("åˆ é™¤å¯¹è¯æ—¶å‡ºé”™:", error);
                    showToast('åˆ é™¤å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°é”™è¯¯ä¿¡æ¯', 'error');
                }
            }
        }

        // --- è®ºå›åŠŸèƒ½ ---

        let currentForumId = null;

        // æ˜¾ç¤ºåˆ›å»ºè®ºå›ç•Œé¢
        function showCreateForumScreen() {
            hideApp('forum-screen');
            const characterContainer = document.getElementById('forum-character-selection');
            const personaContainer = document.getElementById('forum-persona-selection');

            // æ¸²æŸ“è§’è‰²å’Œèº«ä»½é¢å…·é€‰é¡¹
            characterContainer.innerHTML = characters.map(char => `
                <div class="selection-item" data-id="${char.id}" onclick="toggleSelection(this)">
                    <img src="${char.avatarUrl || createDefaultAvatar(char.name)}" alt="${char.name}">
                    <div class="selection-item-name">${char.name}</div>
                </div>
            `).join('');

            personaContainer.innerHTML = personas.map(p => `
                <div class="selection-item" data-id="${p.id}" onclick="toggleSelection(this, true)">
                    <img src="${p.avatarUrl || createDefaultAvatar(p.name)}" alt="${p.name}">
                    <div class="selection-item-name">${p.name}</div>
                </div>
            `).join('');

            showApp('create-forum-screen');
        }

        // å¤šé€‰/å•é€‰åˆ‡æ¢
        function toggleSelection(element, isSingle = false) {
            const container = element.parentElement;
            if (isSingle) {
                // å•é€‰é€»è¾‘
                const currentlySelected = container.querySelector('.selected');
                if (currentlySelected) {
                    currentlySelected.classList.remove('selected');
                }
            }
            element.classList.toggle('selected');
        }

        // åˆ›å»ºæ–°è®ºå›
        async function createForum() {
            const name = document.getElementById('forum-name-input').value.trim();
            const worldview = document.getElementById('forum-worldview-input').value.trim();

            const selectedCharElements = document.querySelectorAll('#forum-character-selection .selected');
            const selectedPersonaElement = document.querySelector('#forum-persona-selection .selected');

            if (!name) return alert('è¯·è¾“å…¥è®ºå›åç§°');
            if (selectedCharElements.length === 0) return alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªè§’è‰²');
            if (!selectedPersonaElement) return alert('è¯·é€‰æ‹©ä½ çš„èº«ä»½');

            const characterIds = Array.from(selectedCharElements).map(el => el.dataset.id);
            const personaId = selectedPersonaElement.dataset.id;

            try {
                // æ£€æŸ¥è®ºå›åç§°æ˜¯å¦é‡å¤
                const existingForum = await db.forums.where('name').equals(name).first();
                if (existingForum) {
                    alert('è®ºå›åç§°å·²å­˜åœ¨ï¼Œè¯·é€‰æ‹©å…¶ä»–åç§°');
                    return;
                }

                const newForum = {
                    name,
                    characterIds,
                    personaId,
                    worldview,
                    createdAt: Date.now()
                };

                currentForumId = await db.forums.add(newForum);
                showToast(`è®ºå› "${name}" åˆ›å»ºæˆåŠŸï¼æ­£åœ¨ç”Ÿæˆå¸–å­...`, 'success');

                hideApp('create-forum-screen');
                await loadAndDisplayForum(currentForumId, true); // trueè¡¨ç¤ºè¿™æ˜¯ç¬¬ä¸€æ¬¡åŠ è½½ï¼Œéœ€è¦ç”Ÿæˆå¸–å­
            } catch (error) {
                console.error("åˆ›å»ºè®ºå›å¤±è´¥:", error);
                alert("åˆ›å»ºè®ºå›å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚");
            }
        }

        // æ¸²æŸ“è®ºå›å­˜æ¡£åˆ—è¡¨
        async function renderForumArchives() {
            const forums = await db.forums.toArray();
            const listContainer = document.getElementById('forum-archive-list');

            if (forums.length === 0) {
                listContainer.innerHTML = `
                    <div class="forum-empty-state">
                        <i class="fas fa-comments"></i>
                        <p>è¿˜æ²¡æœ‰åˆ›å»ºä»»ä½•è®ºå›</p>
                        <p>ç‚¹å‡»å³ä¸Šè§’ + åˆ›å»ºä½ çš„ç¬¬ä¸€ä¸ªè®ºå›</p>
                    </div>`;
                return;
            }

            listContainer.innerHTML = forums.sort((a, b) => b.createdAt - a.createdAt).map(forum => `
                <div class="forum-archive-item" onclick="loadAndDisplayForum('${forum.id}')">
                    <div class="forum-archive-title">${forum.name}</div>
                    <div class="forum-archive-meta">
                        <span>ğŸ‘¥ ${forum.characterIds.length} ä¸ªè§’è‰²</span>
                        <span>${new Date(forum.createdAt).toLocaleDateString()}</span>
                    </div>
                </div>
            `).join('');
        }

        // åŠ è½½å¹¶æ˜¾ç¤ºä¸€ä¸ªè®ºå›
        async function loadAndDisplayForum(forumId, shouldGeneratePosts = false) {
            currentForumId = forumId;
            const forum = await db.forums.get(parseInt(forumId));
            if (!forum) {
                alert("æ‰¾ä¸åˆ°è¯¥è®ºå›");
                return;
            }

            document.getElementById('forum-view-title').innerText = forum.name;
            hideApp('forum-screen');
            showApp('forum-view-screen');

            if (shouldGeneratePosts) {
                await generateForumPosts(forumId);
            }
            await renderForumPosts(forumId);
        }

        // è¿”å›è®ºå›å­˜æ¡£åˆ—è¡¨
        async function backToForumArchives() {
            // ğŸ”¥ã€ä¿®å¤ã€‘å…ˆæ˜¾ç¤ºè®ºå›ä¸»é¡µï¼Œå†éšè—å½“å‰é¡µé¢ï¼Œé¿å…é—ªç°ä¸»å±å¹•
            await renderForumArchives();
            showApp('forum-screen');
            hideApp('forum-view-screen');
        }

        // ç”Ÿæˆè®ºå›å¸–å­
        async function generateForumPosts(forumId) {
            const forum = await db.forums.get(parseInt(forumId));
            const forumCharacters = characters.filter(c => forum.characterIds.includes(c.id));
            const persona = personas.find(p => p.id === forum.personaId);

            let prompt = `ä½ æ˜¯ä¸€ä¸ªè®ºå›çš„å†…å®¹ç”ŸæˆAIã€‚è¯·ä¸ºä¸€ä¸ªåä¸º "${forum.name}" çš„è®ºå›ç”Ÿæˆ5ä¸ªåˆå§‹å¸–å­ã€‚

ä¸–ç•Œè§‚è®¾å®š:
${forum.worldview || 'æ— è¡¥å……è®¾å®šï¼Œè¯·åŸºäºè§’è‰²äººè®¾è‡ªç”±å‘æŒ¥ã€‚'}

è®ºå›æˆå‘˜:
${forumCharacters.map(c => `- ${c.name}: ${c.bio}`).join('\n')}
- ${persona.name} (ç”¨æˆ·): ${persona.description}

è¯·ç”Ÿæˆ5ä¸ªå¸–å­çš„æ ‡é¢˜å’Œå†…å®¹ï¼Œæ ¼å¼ä¸ºJSONæ•°ç»„ï¼Œæ¯ä¸ªå¸–å­æ˜¯ä¸€ä¸ªå¯¹è±¡:
[
  { "authorName": "è§’è‰²åæˆ–ç”¨æˆ·å", "title": "å¸–å­æ ‡é¢˜", "content": "å¸–å­æ­£æ–‡" },
  ...
]

è¦æ±‚:
- å¸–å­è¦ç”ŸåŠ¨çœŸå®ï¼Œæœ‰ç”Ÿæ´»æ°”æ¯ã€‚
- è¯é¢˜å¯ä»¥å›´ç»•è§’è‰²çš„æ—¥å¸¸ã€çƒ¦æ¼ã€è¶£äº‹ï¼Œä¹Ÿå¯ä»¥æ˜¯å‘ç”¨æˆ·æˆ–å…¶ä»–è§’è‰²æé—®ã€‚
- æ ‡é¢˜è¦å¸å¼•äººï¼Œå†…å®¹è¦æœ‰ç»†èŠ‚ã€‚
- authorName å¿…é¡»æ˜¯ä¸Šé¢åˆ—è¡¨ä¸­çš„åå­—ä¹‹ä¸€ã€‚
`;

            showToast('AIæ­£åœ¨ç”Ÿæˆå¸–å­ï¼Œè¯·ç¨å€™...', 'info');
            try {
                const response = await callChatAPI(prompt, forumCharacters[0]); // ä½¿ç”¨ç¬¬ä¸€ä¸ªè§’è‰²ä½œä¸ºAPIè°ƒç”¨çš„ä¸»ä½“
                const posts = JSON.parse(response);

                for (const post of posts) {
                    const author = characters.find(c => c.name === post.authorName) || personas.find(p => p.name === post.authorName);
                    await db.forumPosts.add({
                        forumId: parseInt(forumId),
                        title: post.title,
                        content: post.content,
                        authorId: author.id,
                        authorName: author.name,
                        authorAvatar: author.avatarUrl,
                        timestamp: Date.now() - Math.random() * 86400000 // éšæœºæ—¶é—´æˆ³ï¼Œçœ‹èµ·æ¥æ›´çœŸå®
                    });
                }
            } catch (error) {
                console.error("ç”Ÿæˆå¸–å­å¤±è´¥:", error);
                alert("AIç”Ÿæˆå¸–å­å¤±è´¥ï¼Œè¯·æ£€æŸ¥APIè®¾ç½®æˆ–åˆ·æ–°é‡è¯•ã€‚");
            }
        }

        // æ¸²æŸ“å¸–å­åˆ—è¡¨
        async function renderForumPosts(forumId) {
            const posts = await db.forumPosts.where('forumId').equals(parseInt(forumId)).reverse().sortBy('timestamp');
            const listContainer = document.getElementById('forum-posts-list');

            if (posts.length === 0) {
                listContainer.innerHTML = `<div class="forum-empty-state"><p>è¿™ä¸ªè®ºå›è¿˜æ²¡æœ‰å¸–å­</p></div>`;
                return;
            }

            listContainer.innerHTML = posts.map(post => `
                <div class="post-item" onclick="showPostView(${post.id})">
                    <div class="post-title">${post.title}</div>
                    <div class="post-meta">
                        <span class="post-author">${post.authorName}</span>
                        <span>${formatTime(post.timestamp)}</span>
                    </div>
                </div>
            `).join('');
        }

        // åˆ·æ–°å¸–å­
        async function refreshPosts() {
            if (!currentForumId) return;
            await generateForumPosts(currentForumId);
            await renderForumPosts(currentForumId);
            showToast("æ–°å¸–å­å·²åˆ·æ–°ï¼", "success");
        }

        // æ˜¾ç¤ºå¸–å­è¯¦æƒ…
        async function showPostView(postId) {
            const post = await db.forumPosts.get(postId);
            if (!post) return;

            window.currentPostId = postId; // å­˜å‚¨å½“å‰å¸–å­ID

            const contentContainer = document.getElementById('post-view-content');
            contentContainer.innerHTML = `
                <div class="post-full-content">
                    <div class="post-full-title">${post.title}</div>
                    <div class="post-full-meta">ç”± ${post.authorName} å‘å¸ƒäº ${new Date(post.timestamp).toLocaleString()}</div>
                    <div class="post-full-body">${post.content.replace(/\n/g, '<br>')}</div>
                </div>
                <div class="replies-section">
                    <h3>å›å¤</h3>
                    <div id="replies-list"></div>
                </div>
            `;

            // æ›´æ–°æ”¶è—æŒ‰é’®çŠ¶æ€
            const isFav = await db.forumFavorites.where('[userId+postId]').equals(['user', postId]).first();
            const favIcon = document.querySelector('#favorite-btn i');
            favIcon.className = isFav ? 'fas fa-star' : 'far fa-star';

            await renderReplies(postId);
            showApp('post-view-screen');
        }

        // æ¸²æŸ“å›å¤
        async function renderReplies(postId) {
            const replies = await db.forumReplies.where('postId').equals(postId).sortBy('timestamp');
            const listContainer = document.getElementById('replies-list');

            listContainer.innerHTML = replies.map(reply => `
                <div class="reply-item">
                    <img class="reply-avatar" src="${reply.authorAvatar || createDefaultAvatar(reply.authorName)}" alt="${reply.authorName}">
                    <div class="reply-body">
                        <div class="reply-author">${reply.authorName}</div>
                        <div class="reply-content">${reply.content.replace(/\n/g, '<br>')}</div>
                    </div>
                </div>
            `).join('');
        }

        // å‘é€å›å¤
        async function sendReply() {
            const input = document.getElementById('reply-input');
            const content = input.value.trim();
            if (!content || !window.currentPostId) return;

            const forum = await db.forums.get(currentForumId);
            const persona = personas.find(p => p.id === forum.personaId);

            const reply = {
                postId: window.currentPostId,
                authorId: 'user',
                authorName: persona.name,
                authorAvatar: persona.avatarUrl,
                content: content,
                timestamp: Date.now()
            };

            await db.forumReplies.add(reply);
            input.value = '';
            await renderReplies(window.currentPostId);

            // è§¦å‘NPCå›å¤
            triggerNpcReply(window.currentPostId);
        }

        // è§¦å‘NPCå›å¤
        async function triggerNpcReply(postId) {
            const post = await db.forumPosts.get(postId);
            const forum = await db.forums.get(post.forumId);
            const replies = await db.forumReplies.where('postId').equals(postId).toArray();
            const forumCharacters = characters.filter(c => forum.characterIds.includes(c.id));
            const persona = personas.find(p => p.id === forum.personaId);

            // éšæœºé€‰æ‹©ä¸€ä¸ªNPCè¿›è¡Œå›å¤
            const replyingChar = forumCharacters[Math.floor(Math.random() * forumCharacters.length)];

            let prompt = `ä½ æ­£åœ¨ä¸€ä¸ªåä¸º "${forum.name}" çš„è®ºå›é‡Œã€‚
ä¸–ç•Œè§‚: ${forum.worldview || 'æ— '}
ä½ çš„èº«ä»½æ˜¯ ${replyingChar.name}ï¼Œäººè®¾: ${replyingChar.bio}

å½“å‰å¸–å­æ ‡é¢˜: "${post.title}"
å¸–å­å†…å®¹: "${post.content}"

ä»¥ä¸‹æ˜¯æœ€è¿‘çš„å‡ æ¡å›å¤:
${replies.slice(-5).map(r => `${r.authorName}: ${r.content}`).join('\n')}

ç°åœ¨è¯·ä½ ä½œä¸º ${replyingChar.name}ï¼Œå¯¹è¿™ä¸ªå¸–å­æˆ–æœ€æ–°çš„å›å¤å‘è¡¨ä½ çš„çœ‹æ³•ã€‚å›å¤è¦è‡ªç„¶ã€ç®€çŸ­ï¼Œç¬¦åˆä½ çš„äººè®¾ã€‚ç›´æ¥è¾“å‡ºå›å¤å†…å®¹ï¼Œä¸è¦ç”¨JSONã€‚`;

            try {
                const response = await callChatAPI(prompt, replyingChar);
                const replyContent = Array.isArray(response) ? response[0] : response;

                if (replyContent) {
                    const npcReply = {
                        postId: postId,
                        authorId: replyingChar.id,
                        authorName: replyingChar.name,
                        authorAvatar: replyingChar.avatarUrl,
                        content: replyContent,
                        timestamp: Date.now()
                    };
                    await db.forumReplies.add(npcReply);
                    await renderReplies(postId);
                }
            } catch (error) {
                console.error("NPCå›å¤å¤±è´¥:", error);
            }
        }

        // æ”¶è—/å–æ¶ˆæ”¶è—å¸–å­
        async function toggleFavoritePost() {
            if (!window.currentPostId) return;

            const postId = window.currentPostId;
            const existingFav = await db.forumFavorites.where('[userId+postId]').equals(['user', postId]).first();
            const favIcon = document.querySelector('#favorite-btn i');

            if (existingFav) {
                await db.forumFavorites.delete(existingFav.id);
                favIcon.className = 'far fa-star';
                showToast('å·²å–æ¶ˆæ”¶è—', 'info');
            } else {
                await db.forumFavorites.add({ userId: 'user', postId: postId, timestamp: Date.now() });
                favIcon.className = 'fas fa-star';
                showToast('æ”¶è—æˆåŠŸï¼', 'success');
            }
        }

        // æ˜¾ç¤ºä¸ªäººä¸»é¡µ
        async function showForumProfile() {
            // ğŸ”¥ã€ä¿®å¤ã€‘å…ˆåŠ è½½æ•°æ®å’Œæ˜¾ç¤ºé¡µé¢ï¼Œå†éšè—å½“å‰é¡µé¢ï¼Œé¿å…é—ªç°ä¸»å±å¹•
            const favoriteRecords = await db.forumFavorites.where('userId').equals('user').toArray();
            const postIds = favoriteRecords.map(fav => fav.postId);
            const favoritePosts = await db.forumPosts.where('id').anyOf(postIds).toArray();

            const listContainer = document.getElementById('favorite-posts-list');
            if (favoritePosts.length === 0) {
                listContainer.innerHTML = `<div class="forum-empty-state"><p>ä½ è¿˜æ²¡æœ‰æ”¶è—ä»»ä½•å¸–å­</p></div>`;
            } else {
                listContainer.innerHTML = favoritePosts.sort((a,b) => b.timestamp - a.timestamp).map(post => `
                    <div class="post-item" onclick="showPostView(${post.id})">
                        <div class="post-title">${post.title}</div>
                        <div class="post-meta">
                            <span class="post-author">${post.authorName}</span>
                            <span>${formatTime(post.timestamp)}</span>
                        </div>
                    </div>
                `).join('');
            }

            showApp('forum-profile-screen');
            hideApp('forum-view-screen');
        }

        // ğŸ”¥ã€æ–°å¢ã€‘ä»ä¸ªäººä¸»é¡µè¿”å›å½“å‰è®ºå›ç¤¾åŒº
        async function backToCurrentForum() {
            if (!currentForumId) {
                // å¦‚æœæ²¡æœ‰å½“å‰è®ºå›IDï¼Œè¿”å›è®ºå›ä¸»é¡µ
                hideApp('forum-profile-screen');
                await renderForumArchives();
                showApp('forum-screen');
                return;
            }

            // è¿”å›å½“å‰è®ºå›ç¤¾åŒºé¡µé¢
            const forum = await db.forums.get(parseInt(currentForumId));
            if (forum) {
                document.getElementById('forum-view-title').innerText = forum.name;
                await renderForumPosts(currentForumId);
                showApp('forum-view-screen');
                hideApp('forum-profile-screen');
            } else {
                // è®ºå›ä¸å­˜åœ¨ï¼Œè¿”å›è®ºå›ä¸»é¡µ
                hideApp('forum-profile-screen');
                await renderForumArchives();
                showApp('forum-screen');
            }
        }

        // åˆå§‹åŒ–è®ºå›åº”ç”¨
        function initializeForumApp() {
            // ç»‘å®šè®ºå›åº”ç”¨å›¾æ ‡ç‚¹å‡»äº‹ä»¶
            const forumAppIcon = document.querySelector('.mini-app[onclick*="forum-screen"]');
            if (forumAppIcon) {
                // ç§»é™¤åŸæœ‰çš„onclickå±æ€§
                forumAppIcon.removeAttribute('onclick');
                // æ·»åŠ æ–°çš„äº‹ä»¶ç›‘å¬å™¨
                forumAppIcon.addEventListener('click', async () => {
                    await renderForumArchives();
                    showApp('forum-screen');
                });
            }
            console.log('âœ… è®ºå›åº”ç”¨åˆå§‹åŒ–å®Œæˆ');
        }

    </script>
    
    <!-- ğŸ”¥ã€æ–°å¢ã€‘ç¾¤æˆå‘˜å¤´åƒæ›´æ¢æ¨¡æ€æ¡† -->
    <div class="modal" id="member-avatar-modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">æ›´æ¢æˆå‘˜å¤´åƒ</h3>
                <button class="modal-close" onclick="hideMemberAvatarModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="member-avatar-form">
                    <div class="current-member-info">
                        <h4 id="member-avatar-name" class="member-name-title">è§’è‰²åç§°</h4>
                        <p class="member-info-desc">ä¸ºè¯¥è§’è‰²è®¾ç½®æ–°çš„å¤´åƒï¼Œå°†åœ¨ç¾¤èŠä¸­ç«‹å³ç”Ÿæ•ˆ</p>
                    </div>
                    
                    <div class="avatar-upload-section">
                        <div class="avatar-preview-large">
                            <img id="member-avatar-preview" src="" alt="å¤´åƒé¢„è§ˆ" class="preview-image">
                        </div>
                        
                        <div class="upload-buttons">
                            <button class="upload-btn primary" onclick="handleMemberAvatarUpload()">
                                <i class="fas fa-upload"></i>
                                é€‰æ‹©æ–°å¤´åƒ
                            </button>
                            <button class="upload-btn secondary" onclick="resetMemberAvatar()">
                                <i class="fas fa-undo"></i>
                                é‡ç½®é»˜è®¤
                            </button>
                        </div>
                        
                        <input type="file" id="member-avatar-upload" accept="image/*" style="display: none;">
                    </div>
                    
                    <div class="avatar-tips">
                        <div class="tips-header">
                            <i class="fas fa-info-circle"></i>
                            <span>å¤´åƒæ›´æ¢è¯´æ˜</span>
                        </div>
                        <div class="tips-content">
                            â€¢ æ”¯æŒJPGã€PNGç­‰å¸¸è§å›¾ç‰‡æ ¼å¼<br>
                            â€¢ å»ºè®®ä½¿ç”¨æ­£æ–¹å½¢å›¾ç‰‡ï¼Œæ•ˆæœæ›´ä½³<br>
                            â€¢ å¤´åƒæ›´æ¢åå°†åœ¨ç¾¤èŠä¸­ç«‹å³æ˜¾ç¤º<br>
                            â€¢ è§’è‰²ä¹Ÿå¯ä»¥åœ¨èŠå¤©æ—¶è‡ªä¸»æ›´æ¢å¤´åƒ
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-button modal-secondary" onclick="hideMemberAvatarModal()">å–æ¶ˆ</button>
                <button class="modal-button modal-primary" onclick="saveMemberAvatar()">ä¿å­˜æ›´æ”¹</button>
            </div>
        </div>
    </div>

    <!-- ç¾¤å…¬å‘Šç¼–è¾‘æ¨¡æ€æ¡† -->
    <div class="modal" id="group-notice-modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">ç¼–è¾‘ç¾¤å…¬å‘Š</h3>
                <button class="modal-close" onclick="hideGroupNoticeModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="group-notice-form">
                    <div class="form-group">
                        <label class="form-label">ç¾¤å…¬å‘Šå†…å®¹</label>
                        <textarea 
                            id="group-notice-content" 
                            class="form-textarea group-notice-textarea" 
                            placeholder="è¾“å…¥ç¾¤å…¬å‘Šå†…å®¹...&#10;&#10;å¯ä»¥åŒ…æ‹¬ï¼š&#10;â€¢ ç¾¤è§„åˆ™è¯´æ˜&#10;â€¢ é‡è¦é€šçŸ¥&#10;â€¢ æ´»åŠ¨å®‰æ’&#10;â€¢ å…¶ä»–äº‹é¡¹"
                            maxlength="500"></textarea>
                        <div class="notice-char-count">
                            <span id="notice-char-current">0</span>/500å­—
                        </div>
                    </div>
                    <div class="notice-tips">
                        <div class="tips-header">
                            <i class="fas fa-lightbulb"></i>
                            <span>å…¬å‘Šå°è´´å£«</span>
                        </div>
                        <div class="tips-content">
                            â€¢ ç®€æ´æ˜äº†ï¼Œçªå‡ºé‡ç‚¹<br>
                            â€¢ ä½¿ç”¨å‹å¥½çš„è¯­è°ƒ<br>
                            â€¢ å®šæœŸæ›´æ–°é‡è¦ä¿¡æ¯<br>
                            â€¢ å¯ä»¥ä½¿ç”¨emojiå¢åŠ è¶£å‘³æ€§
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary" onclick="hideGroupNoticeModal()">å–æ¶ˆ</button>
                <button class="modal-primary" onclick="saveGroupNotice()">ä¿å­˜å…¬å‘Š</button>
            </div>
        </div>
    </div>
    
    <!-- å®šæ—¶å‘å¸ƒæ—¶é—´è®¾ç½®æ¨¡æ€æ¡† -->
    <div class="modal" id="schedule-times-modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">å®šæ—¶å‘å¸ƒæ—¶é—´è®¾ç½®</h3>
                <button class="modal-close" onclick="hideModal('schedule-times-modal')">&times;</button>
            </div>
            <div class="modal-body">
                <p style="color: #666; font-size: 14px; margin-bottom: 15px;">
                    è®¾ç½®è§’è‰²æ¯å¤©è‡ªåŠ¨å‘å¸ƒåŠ¨æ€çš„æ—¶é—´ç‚¹ï¼ˆæœ€å¤š10ä¸ªï¼‰
                </p>
                <div id="schedule-times-modal-container">
                    <!-- æ—¶é—´è¾“å…¥é¡¹å°†åŠ¨æ€ç”Ÿæˆ -->
                </div>
                <button onclick="addScheduleTime()" style="margin-top: 10px; padding: 8px 16px; background: #007AFF; color: white; border: none; border-radius: 6px; cursor: pointer;">
                    + æ·»åŠ æ—¶é—´ç‚¹
                </button>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary" onclick="hideModal('schedule-times-modal')">å–æ¶ˆ</button>
                <button class="modal-primary" onclick="saveScheduleTimes()">ä¿å­˜</button>
            </div>
        </div>
    </div>

    <!-- æ—¥è®°åŠŸèƒ½æ¨¡æ€æ¡† -->
    <div id="diary-menu-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">æ—¥è®°</h3>
                <button class="modal-close" onclick="hideDiaryMenu()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="diary-menu-options">
                    <div class="diary-option" onclick="showTodayDiary()">
                        <div class="diary-option-icon">
                            <i class="fas fa-calendar-day"></i>
                        </div>
                        <div class="diary-option-content">
                            <div class="diary-option-title">ä»Šæ—¥æ—¥è®°</div>
                            <div class="diary-option-desc">æŸ¥çœ‹ä»Šå¤©çš„æ—¥è®°ï¼ˆä¸€å¤©åªèƒ½ä¿ç•™ä¸€ä»½ï¼‰</div>
                        </div>
                    </div>
                    <div class="diary-option" onclick="showPastDiaries()">
                        <div class="diary-option-icon">
                            <i class="fas fa-history"></i>
                        </div>
                        <div class="diary-option-content">
                            <div class="diary-option-title">è¿‡å¾€æ—¥è®°</div>
                            <div class="diary-option-desc">æŸ¥çœ‹å†å²æ—¥è®°è®°å½•</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ä»Šæ—¥æ—¥è®°æ˜¾ç¤ºæ¨¡æ€æ¡† -->
    <div id="today-diary-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">ä»Šæ—¥æ—¥è®°</h3>
                <div class="diary-actions">
                    <button class="diary-action-btn" onclick="generateTodayDiary()" id="generate-diary-btn" title="ç”Ÿæˆæ—¥è®°">
                        <i class="fas fa-sync-alt"></i>
                    </button>
                    <button class="diary-action-btn secondary edit-btn" onclick="editTodayDiary()" id="edit-diary-btn" title="ç¼–è¾‘æ—¥è®°" style="display: none;">
                        <i class="fas fa-pencil-alt"></i>
                    </button>
                </div>
                <button class="modal-close" onclick="hideTodayDiary()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="diary-paper-container">
                    <div id="today-diary-content" class="diary-paper">
                        <!-- æ—¥è®°å†…å®¹å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
                    </div>
                </div>

            </div>
        </div>
    </div>

    <!-- è¿‡å¾€æ—¥è®°åˆ—è¡¨æ¨¡æ€æ¡† -->
    <div id="past-diaries-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">è¿‡å¾€æ—¥è®°</h3>
                <button class="modal-close" onclick="hidePastDiaries()">&times;</button>
            </div>
            <div class="modal-body">
                <div id="past-diaries-list">
                    <!-- è¿‡å¾€æ—¥è®°åˆ—è¡¨å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
                </div>
            </div>
        </div>
    </div>

    <!-- ä½ç½®åˆ†äº«æ¨¡æ€æ¡† -->
    <div id="location-modal" class="modal" style="display: none;">
        <div class="modal-content location-modal-content">
            <div class="modal-header">
                <h3 class="modal-title">åˆ†äº«ä½ç½®</h3>
                <button class="modal-close" onclick="hideLocationModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="location-input-section">
                    <label for="location-address">ä½ç½®åç§°</label>
                    <input type="text" id="location-address" placeholder="è¯·è¾“å…¥ä½ç½®åç§°ï¼Œå¦‚ï¼šå’–å•¡å…ã€å­¦æ ¡ã€å®¶..." maxlength="50">
                    
                    <!-- æœ€è¿‘ä½¿ç”¨å†å²è®°å½• -->
                    <div class="location-history" id="location-history">
                        <div class="location-history-title">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
                                <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                            </svg>
                            æœ€è¿‘ä½¿ç”¨
                        </div>
                        <div class="location-history-items" id="location-history-items">
                            <div class="location-history-empty">æš‚æ— å†å²è®°å½•</div>
                        </div>
                    </div>
                </div>
                <div class="virtual-map-container">
                    <div class="map-header" style="background: linear-gradient(135deg, #f6ffed 0%, #d9f7be 100%);">
                        <div class="map-location-name" id="map-location-display" style="color: #52c41a;">è¯·è¾“å…¥ä½ç½®åç§°</div>
                        <div class="map-coordinates" style="color: #73d13d;">116.4074Â°E, 39.9042Â°N</div>
                    </div>
                    <div class="virtual-map">
                        <div class="map-background"></div>
                        <!-- å¼¯æ›²æ²³æµ -->
                        <div class="river" style="top: 8%; left: 55%; width: 25px; height: 4px; transform: rotate(30deg);"></div>
                        <div class="river-curve" style="top: 18%; left: 68%; width: 22px; height: 4px; transform: rotate(10deg);"></div>
                        <div class="river" style="top: 26%; left: 78%; width: 20px; height: 4px; transform: rotate(-10deg);"></div>
                        <div class="river-curve" style="top: 32%; left: 85%; width: 18px; height: 4px; transform: rotate(-30deg);"></div>
                        <div class="river" style="top: 60%; left: 5%; width: 28px; height: 4px; transform: rotate(-15deg);"></div>
                        <div class="river-curve" style="top: 68%; left: 25%; width: 25px; height: 4px; transform: rotate(5deg);"></div>
                        <div class="river" style="top: 75%; left: 42%; width: 22px; height: 4px; transform: rotate(20deg);"></div>
                        <!-- å…¬å›­ç»¿åœ° -->
                        <div style="position: absolute; top: 25%; left: 65%; width: 25px; height: 20px; background: linear-gradient(135deg, #f6ffed 0%, #d9f7be 50%, #b7eb8f 100%); border-radius: 3px; opacity: 0.6; z-index: 1;"></div>
                        <div style="position: absolute; top: 50%; left: 15%; width: 30px; height: 25px; background: linear-gradient(135deg, #f6ffed 0%, #d9f7be 50%, #b7eb8f 100%); border-radius: 3px; opacity: 0.6; z-index: 1;"></div>
                        <!-- é“è·¯ -->
                        <div class="map-roads">
                            <div class="road road-horizontal" style="top: 30%; left: 0; width: 100%;"></div>
                            <div class="road road-vertical" style="left: 25%; top: 0; height: 100%;"></div>
                            <div class="road road-horizontal" style="top: 70%; left: 0; width: 100%;"></div>
                            <div class="road road-vertical" style="left: 75%; top: 0; height: 100%;"></div>
                        </div>
                        <!-- å»ºç­‘ç‰© -->
                        <div class="map-buildings">
                            <div class="building" style="top: 10%; left: 35%; width: 20px; height: 15px; background: linear-gradient(135deg, #f0f0f0 0%, #d9d9d9 100%); border: 1px solid #bfbfbf; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                            <div class="building" style="top: 15%; left: 55%; width: 25px; height: 20px; background: linear-gradient(135deg, #e6f7ff 0%, #bae7ff 100%); border: 1px solid #91d5ff; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                            <div class="building" style="top: 40%; left: 10%; width: 18px; height: 12px; background: linear-gradient(135deg, #fff1f0 0%, #ffd8d6 100%); border: 1px solid #ffaaa5; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                            <div class="building" style="top: 45%; left: 85%; width: 22px; height: 18px; background: linear-gradient(135deg, #f0f0f0 0%, #d9d9d9 100%); border: 1px solid #bfbfbf; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                            <div class="building" style="top: 75%; left: 40%; width: 30px; height: 20px; background: linear-gradient(135deg, #e6f7ff 0%, #bae7ff 100%); border: 1px solid #91d5ff; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                            <div class="building" style="top: 80%; left: 15%; width: 20px; height: 15px; background: linear-gradient(135deg, #fff1f0 0%, #ffd8d6 100%); border: 1px solid #ffaaa5; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                        </div>
                        <!-- æ ‘æœ¨ -->
                        <div style="position: absolute; top: 35%; left: 20%; width: 8px; height: 8px; background: radial-gradient(circle, #52c41a 0%, #389e0d 70%, #237804 100%); border-radius: 50%; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15); z-index: 3;"></div>
                        <div style="position: absolute; top: 60%; left: 30%; width: 6px; height: 6px; background: radial-gradient(circle, #73d13d 0%, #52c41a 70%, #389e0d 100%); border-radius: 50%; box-shadow: 0 0.5px 1px rgba(0, 0, 0, 0.1); z-index: 3;"></div>
                        <div style="position: absolute; top: 12%; left: 70%; width: 7px; height: 7px; background: radial-gradient(circle, #52c41a 0%, #389e0d 70%, #237804 100%); border-radius: 50%; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15); z-index: 3;"></div>
                        <div style="position: absolute; top: 85%; left: 90%; width: 5px; height: 5px; background: radial-gradient(circle, #73d13d 0%, #52c41a 70%, #389e0d 100%); border-radius: 50%; box-shadow: 0 0.5px 1px rgba(0, 0, 0, 0.1); z-index: 3;"></div>
                        <div style="position: absolute; top: 50%; left: 90%; width: 6px; height: 6px; background: radial-gradient(circle, #73d13d 0%, #52c41a 70%, #389e0d 100%); border-radius: 50%; box-shadow: 0 0.5px 1px rgba(0, 0, 0, 0.1); z-index: 3;"></div>
                        <!-- ä½ç½®æ ‡è®° -->
                        <div class="map-marker" id="location-marker">
                            <div class="marker-pin">
                                <svg width="28" height="28" viewBox="0 0 24 24" fill="none">
                                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" fill="#1890ff"/>
                                </svg>
                            </div>
                        </div>
                        <div class="map-current-location">
                            <div class="current-location-dot"></div>
                        </div>
                    </div>
                    <div class="map-footer">
                        <div class="map-scale">500m</div>
                        <div class="map-controls">
                            <button class="map-control-btn" onclick="randomizeMapPosition()">ğŸ¯ é‡æ–°å®šä½</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary" onclick="hideLocationModal()">å–æ¶ˆ</button>
                <button class="modal-primary" onclick="sendLocationMessage()">å‘é€ä½ç½®</button>
            </div>
        </div>
    </div>
    </div>

    <script>
        // ğŸ”¥ã€æ–°å¢ã€‘ç¾¤æˆå‘˜å¤´åƒä¸Šä¼ äº‹ä»¶ç›‘å¬
        document.addEventListener('DOMContentLoaded', function() {
            const memberAvatarUpload = document.getElementById('member-avatar-upload');
            if (memberAvatarUpload) {
                memberAvatarUpload.addEventListener('change', function(e) {
                    if (e.target.files && e.target.files[0]) {
                        const file = e.target.files[0];
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            const preview = document.getElementById('member-avatar-preview');
                            if (preview) {
                                preview.src = event.target.result;
                            }
                        };
                        reader.readAsDataURL(file);
                    }
                });
            }
        });
    </script>

    <!-- ğŸ”¥ã€æ°¸ä¹…ä¿®å¤ã€‘èº«ä»½é€‰æ‹©åŠŸèƒ½è‡ªåŠ¨ä¿®å¤è„šæœ¬ -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            console.log('ğŸ”§ å¼€å§‹åº”ç”¨èº«ä»½é€‰æ‹©åŠŸèƒ½æ°¸ä¹…ä¿®å¤...');
            
            // ä¿®å¤1: é‡å†™showPersonaSelectionForSingleChatå‡½æ•°
            if (typeof showPersonaSelectionForSingleChat === 'function') {
                const originalShowPersonaSelectionForSingleChat = showPersonaSelectionForSingleChat;
                showPersonaSelectionForSingleChat = function() {
                    originalShowPersonaSelectionForSingleChat();
                    
                    // å»¶è¿Ÿä¿®å¤äº‹ä»¶ç»‘å®šï¼Œç¡®ä¿DOMå·²ç”Ÿæˆ
                    setTimeout(() => {
                        const items = document.querySelectorAll('#persona-selection-modal .persona-selection-item');
                        console.log('ğŸ”§ ä¿®å¤èº«ä»½é€‰æ‹©äº‹ä»¶ç»‘å®šï¼Œæ‰¾åˆ°å…ƒç´ :', items.length);
                        
                        items.forEach(item => {
                            // ç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨
                            item.onclick = null;
                            
                            // æ·»åŠ æ–°çš„ç‚¹å‡»äº‹ä»¶
                            item.addEventListener('click', function() {
                                console.log('èº«ä»½é€‰æ‹©ç‚¹å‡»:', this.dataset.personaId);
                                
                                // ç§»é™¤æ‰€æœ‰é€‰ä¸­çŠ¶æ€
                                document.querySelectorAll('#persona-selection-modal .persona-selection-item').forEach(i => {
                                    i.classList.remove('selected');
                                });
                                
                                // è®¾ç½®å½“å‰å…ƒç´ ä¸ºé€‰ä¸­
                                this.classList.add('selected');
                                
                                // ä¿å­˜èº«ä»½ID
                                window.selectedPersonaForChat = this.dataset.personaId;
                                console.log('è®¾ç½®selectedPersonaForChat:', window.selectedPersonaForChat);
                                
                                // å¯ç”¨ç¡®è®¤æŒ‰é’®
                                const confirmBtn = document.getElementById('confirm-persona-btn');
                                if (confirmBtn) {
                                    confirmBtn.disabled = false;
                                }
                            });
                        });
                    }, 100);
                };
            }
            
            // ä¿®å¤2: é‡å†™confirmPersonaAndShowCharacterså‡½æ•°
            if (typeof confirmPersonaAndShowCharacters === 'function') {
                confirmPersonaAndShowCharacters = function() {
                    console.log('confirmPersonaAndShowCharactersè°ƒç”¨ï¼Œèº«ä»½ID:', window.selectedPersonaForChat);
                    
                    if (!window.selectedPersonaForChat) {
                        console.error('èº«ä»½IDä¸ºç©ºï¼');
                        return;
                    }
                    
                    // ä¿å­˜èº«ä»½ID
                    const savedPersonaId = window.selectedPersonaForChat;
                    
                    // éšè—æ¨¡æ€æ¡†
                    const modal = document.getElementById('persona-selection-modal');
                    if (modal) {
                        modal.remove();
                    }
                    
                    // æ¢å¤èº«ä»½ID
                    window.selectedPersonaForChat = savedPersonaId;
                    console.log('ä¿æŠ¤åçš„èº«ä»½ID:', window.selectedPersonaForChat);
                    
                    showCharacterSelectionForSingleChat();
                };
            }
            
            // ä¿®å¤3: é‡å†™buildCharacterPromptå‡½æ•°
            if (typeof buildCharacterPrompt === 'function') {
                const originalBuildCharacterPrompt = buildCharacterPrompt;
                buildCharacterPrompt = function(character, hasImage = false) {
                    // è°ƒç”¨åŸå‡½æ•°è·å–åŸºç¡€prompt
                    let characterPrompt = originalBuildCharacterPrompt(character, hasImage);
                    
                    // ç§»é™¤åŸæœ‰çš„currentPersonaé€»è¾‘ï¼Œæ›¿æ¢ä¸ºä»èŠå¤©è®¾ç½®è¯»å–
                    const chatSettings = getCurrentChatSettings();
                    if (chatSettings.selectedIdentityId) {
                        const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                        if (selectedPersona) {
                            console.log('ğŸ”§ ä¸ºè§’è‰²', character.name, 'ä½¿ç”¨èº«ä»½:', selectedPersona.name);
                            
                            // ç§»é™¤æ—§çš„èº«ä»½ä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼‰
                            const personaRegex = /\n\n# å¯¹è¯è€…çš„è§’è‰²è®¾å®šï¼š[\s\S]*?è¯·æ ¹æ®ç”¨æˆ·çš„è¿™ä¸ªé¢å…·èº«ä»½æ¥è¿›è¡Œå¯¹è¯ã€‚/;
                            characterPrompt = characterPrompt.replace(personaRegex, '');
                            
                            // æ·»åŠ æ–°çš„èº«ä»½ä¿¡æ¯
                            const personaInfo = `\n\n# å¯¹è¯è€…çš„è§’è‰²è®¾å®šï¼š\nç”¨æˆ·å½“å‰ä½¿ç”¨çš„é¢å…·æ˜¯"${selectedPersona.name}"${selectedPersona.description ? `ï¼š${selectedPersona.description}` : ''}\nè¯·æ ¹æ®ç”¨æˆ·çš„è¿™ä¸ªé¢å…·èº«ä»½æ¥è¿›è¡Œå¯¹è¯ã€‚`;
                            
                            // åœ¨è§’è‰²è®¾å®šåæ’å…¥èº«ä»½ä¿¡æ¯
                            const insertPoint = characterPrompt.indexOf('\n# ğŸ”¥ã€ä¿®å¤ã€‘è¡¨æƒ…åŒ…åº“ä¿¡æ¯');
                            if (insertPoint !== -1) {
                                characterPrompt = characterPrompt.slice(0, insertPoint) + personaInfo + characterPrompt.slice(insertPoint);
                            } else {
                                characterPrompt += personaInfo;
                            }
                        }
                    }
                    
                    return characterPrompt;
                };
            }
            
            console.log('âœ… èº«ä»½é€‰æ‹©åŠŸèƒ½æ°¸ä¹…ä¿®å¤å·²åº”ç”¨');
        });
    </script>

    <!-- ğŸ”§ã€ç®€å•ä¿®å¤ã€‘ç¾¤èŠèº«ä»½è®¾ç½®ç›´æ¥ä¿®å¤ -->
    <script>
        // ç®€å•ç›´æ¥çš„ç¾¤èŠèº«ä»½ä¿®å¤
        document.addEventListener('DOMContentLoaded', function() {
            console.log('ğŸ”§ [ç®€å•ä¿®å¤] ç¾¤èŠèº«ä»½è®¾ç½®ä¿®å¤å¯åŠ¨...');
            
            // é‡å†™createGroupChatå‡½æ•°ï¼Œç¡®ä¿èº«ä»½è®¾ç½®ç«‹å³ç”Ÿæ•ˆ
            if (typeof window.createGroupChat === 'function') {
                const originalCreateGroupChat = window.createGroupChat;
                window.createGroupChat = async function(personaId) {
                    console.log('ğŸ”§ [ä¿®å¤] createGroupChatè¢«è°ƒç”¨ï¼Œèº«ä»½ID:', personaId);
                    
                    // è°ƒç”¨åŸå‡½æ•°ï¼Œä¼ é€’personaIdå‚æ•°
                    await originalCreateGroupChat.call(this, personaId);
                    
                    // å¦‚æœæœ‰é€‰æ‹©èº«ä»½ï¼Œç«‹å³åŠ è½½åˆ°å†…å­˜
                    if (personaId && groupChats && groupChats.length > 0) {
                        const latestGroup = groupChats[groupChats.length - 1];
                        const savedSettings = localStorage.getItem(`chatSettings_${latestGroup.id}`);
                        
                        if (savedSettings) {
                            try {
                                const settings = JSON.parse(savedSettings);
                                window.chatSettings[latestGroup.id] = settings;
                                console.log('ğŸ”§ [ä¿®å¤] ç¾¤èŠèº«ä»½è®¾ç½®å·²åŠ è½½åˆ°å†…å­˜:', settings);
                            } catch (error) {
                                console.error('ğŸ”§ [ä¿®å¤] è§£æç¾¤èŠè®¾ç½®å¤±è´¥:', error);
                            }
                        }
                    }
                };
            }
            
            console.log('ğŸ”§ [ç®€å•ä¿®å¤] ç¾¤èŠèº«ä»½è®¾ç½®ä¿®å¤å®Œæˆ');
        });
    </script>

    <!-- ğŸ“±ã€ç§»åŠ¨ç«¯ä¼˜åŒ–ã€‘è¾“å…¥æ¡†viewportè¡Œä¸ºä¿®å¤ -->
    <script>
        // ç§»åŠ¨ç«¯è¾“å…¥æ¡†ä¼˜åŒ–
        (function() {
            'use strict';
            
            console.log('ğŸ“± [ç§»åŠ¨ç«¯ä¼˜åŒ–] è¾“å…¥æ¡†viewportè¡Œä¸ºä¿®å¤å¯åŠ¨...');
            
            let isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            let isAndroid = /Android/.test(navigator.userAgent);
            let isMobile = isIOS || isAndroid;
            
            if (!isMobile) {
                console.log('ğŸ“± éç§»åŠ¨ç«¯è®¾å¤‡ï¼Œè·³è¿‡ç§»åŠ¨ç«¯ä¼˜åŒ–');
                return;
            }
            
            // è·å–æ‰€æœ‰å¯èƒ½çš„è¾“å…¥æ¡†
            function getAllInputs() {
                return document.querySelectorAll('textarea, input[type="text"], input[type="password"], input[type="email"], input[type="number"]');
            }
            
            // é˜²æ­¢iOS Safariè‡ªåŠ¨ç¼©æ”¾
            function preventZoom() {
                const viewportMeta = document.querySelector('meta[name="viewport"]');
                if (viewportMeta) {
                    viewportMeta.setAttribute('content', 
                        'width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no'
                    );
                }
            }
            
            // æ¢å¤ç¼©æ”¾åŠŸèƒ½
            function restoreZoom() {
                const viewportMeta = document.querySelector('meta[name="viewport"]');
                if (viewportMeta) {
                    viewportMeta.setAttribute('content', 
                        'width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=3.0, user-scalable=yes'
                    );
                }
            }
            
            // è¾“å…¥æ¡†ç„¦ç‚¹å¤„ç†
            function handleInputFocus(e) {
                console.log('ğŸ“± è¾“å…¥æ¡†è·å¾—ç„¦ç‚¹ï¼Œé˜²æ­¢è‡ªåŠ¨ç¼©æ”¾');
                
                // é˜²æ­¢iOSè‡ªåŠ¨ç¼©æ”¾
                if (isIOS) {
                    preventZoom();
                }
                
                // ç¡®ä¿è¾“å…¥æ¡†å¯è§
                setTimeout(() => {
                    e.target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center'
                    });
                }, 300);
            }
            
            // è¾“å…¥æ¡†å¤±ç„¦å¤„ç†
            function handleInputBlur(e) {
                console.log('ğŸ“± è¾“å…¥æ¡†å¤±å»ç„¦ç‚¹ï¼Œæ¢å¤ç¼©æ”¾åŠŸèƒ½');

                // æ¢å¤ç¼©æ”¾åŠŸèƒ½
                if (isIOS) {
                    setTimeout(() => {
                        restoreZoom();
                    }, 100);
                }

                // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘å¼ºåˆ¶é‡æ–°è®¡ç®—å¸ƒå±€ï¼Œé˜²æ­¢é¡µé¢åç§»
                setTimeout(() => {
                    // é‡ç½®æ»šåŠ¨ä½ç½®
                    window.scrollTo(0, 0);
                    document.body.scrollTop = 0;
                    document.documentElement.scrollTop = 0;

                    // å¼ºåˆ¶é‡æ–°è®¡ç®—è™šæ‹Ÿæ‰‹æœºçš„ä½ç½®
                    const phoneScreen = document.getElementById('phone-screen');
                    if (phoneScreen) {
                        // ä¸´æ—¶æ”¹å˜ä¸€ä¸ªæ ·å¼å±æ€§æ¥è§¦å‘é‡æ–°æ¸²æŸ“
                        phoneScreen.style.transform = 'translateZ(0)';
                        setTimeout(() => {
                            phoneScreen.style.transform = '';
                        }, 10);
                    }

                    // ç¡®ä¿bodyå±…ä¸­å¯¹é½
                    document.body.style.display = 'flex';
                    document.body.style.justifyContent = 'center';
                    document.body.style.alignItems = 'center';
                }, 300);
            }
            
            // ç»‘å®šäº‹ä»¶åˆ°æ‰€æœ‰è¾“å…¥æ¡†
            function bindInputEvents() {
                const inputs = getAllInputs();
                console.log(`ğŸ“± æ‰¾åˆ° ${inputs.length} ä¸ªè¾“å…¥æ¡†ï¼Œæ­£åœ¨ç»‘å®šäº‹ä»¶...`);
                
                inputs.forEach(input => {
                    // ç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                    input.removeEventListener('focus', handleInputFocus);
                    input.removeEventListener('blur', handleInputBlur);
                    
                    // æ·»åŠ æ–°çš„äº‹ä»¶ç›‘å¬å™¨
                    input.addEventListener('focus', handleInputFocus, { passive: true });
                    input.addEventListener('blur', handleInputBlur, { passive: true });
                    
                    // ç¡®ä¿è¾“å…¥æ¡†å­—ä½“å¤§å°è‡³å°‘16pxï¼ˆé˜²æ­¢iOSç¼©æ”¾ï¼‰
                    const computedStyle = window.getComputedStyle(input);
                    const fontSize = parseInt(computedStyle.fontSize);
                    if (fontSize < 16) {
                        input.style.fontSize = '16px';
                        console.log('ğŸ“± è°ƒæ•´è¾“å…¥æ¡†å­—ä½“å¤§å°ä¸º16pxï¼Œé˜²æ­¢iOSç¼©æ”¾');
                    }
                });
            }
            
            // ç›‘å¬DOMå˜åŒ–ï¼Œå¤„ç†åŠ¨æ€æ·»åŠ çš„è¾“å…¥æ¡†
            const observer = new MutationObserver(function(mutations) {
                let shouldRebind = false;
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList') {
                        mutation.addedNodes.forEach(function(node) {
                            if (node.nodeType === 1) { // Element node
                                if (node.matches && (node.matches('textarea') || node.matches('input'))) {
                                    shouldRebind = true;
                                } else if (node.querySelector) {
                                    const inputs = node.querySelectorAll('textarea, input');
                                    if (inputs.length > 0) {
                                        shouldRebind = true;
                                    }
                                }
                            }
                        });
                    }
                });
                
                if (shouldRebind) {
                    console.log('ğŸ“± æ£€æµ‹åˆ°æ–°çš„è¾“å…¥æ¡†ï¼Œé‡æ–°ç»‘å®šäº‹ä»¶...');
                    setTimeout(bindInputEvents, 100);
                }
            });
            
            // å¼€å§‹ç›‘å¬DOMå˜åŒ–
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
            
            // é¡µé¢åŠ è½½å®Œæˆåç»‘å®šäº‹ä»¶
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', bindInputEvents);
            } else {
                bindInputEvents();
            }
            
            // é¡µé¢æ˜¾ç¤ºæ—¶é‡æ–°ç»‘å®šï¼ˆå¤„ç†ä»åå°è¿”å›çš„æƒ…å†µï¼‰
            document.addEventListener('visibilitychange', function() {
                if (!document.hidden) {
                    setTimeout(bindInputEvents, 100);
                }
            });
            
            // ğŸ”¥ã€æ–°å¢ã€‘ç›‘å¬viewportå˜åŒ–ï¼Œä¿®å¤è™šæ‹Ÿé”®ç›˜æ”¶èµ·åçš„å¸ƒå±€é—®é¢˜
            let initialViewportHeight = window.innerHeight;
            let isKeyboardOpen = false;

            function handleViewportChange() {
                const currentHeight = window.innerHeight;
                const heightDiff = initialViewportHeight - currentHeight;

                // åˆ¤æ–­è™šæ‹Ÿé”®ç›˜æ˜¯å¦æ‰“å¼€ï¼ˆé«˜åº¦å‡å°‘è¶…è¿‡150pxè®¤ä¸ºæ˜¯é”®ç›˜æ‰“å¼€ï¼‰
                const keyboardWasOpen = isKeyboardOpen;
                isKeyboardOpen = heightDiff > 150;

                console.log(`ğŸ“± Viewportå˜åŒ–: ${currentHeight}px (åˆå§‹: ${initialViewportHeight}px, å·®å€¼: ${heightDiff}px, é”®ç›˜çŠ¶æ€: ${isKeyboardOpen})`);

                // å¦‚æœé”®ç›˜ä»æ‰“å¼€å˜ä¸ºå…³é—­ï¼Œå¼ºåˆ¶ä¿®å¤å¸ƒå±€
                if (keyboardWasOpen && !isKeyboardOpen) {
                    console.log('ğŸ“± æ£€æµ‹åˆ°è™šæ‹Ÿé”®ç›˜å…³é—­ï¼Œä¿®å¤å¸ƒå±€...');
                    setTimeout(() => {
                        // é‡ç½®æ‰€æœ‰æ»šåŠ¨ä½ç½®
                        window.scrollTo(0, 0);
                        document.body.scrollTop = 0;
                        document.documentElement.scrollTop = 0;

                        // å¼ºåˆ¶é‡æ–°æ¸²æŸ“è™šæ‹Ÿæ‰‹æœº
                        const phoneScreen = document.getElementById('phone-screen');
                        if (phoneScreen) {
                            phoneScreen.style.transform = 'translateZ(0)';
                            requestAnimationFrame(() => {
                                phoneScreen.style.transform = '';
                            });
                        }

                        // ç¡®ä¿bodyå¸ƒå±€æ­£ç¡®
                        document.body.style.height = '100%';
                        document.body.style.display = 'flex';
                        document.body.style.justifyContent = 'center';
                        document.body.style.alignItems = 'center';
                    }, 100);
                }
            }

            // ç›‘å¬viewportå˜åŒ–
            window.addEventListener('resize', handleViewportChange, { passive: true });
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    initialViewportHeight = window.innerHeight;
                    handleViewportChange();
                }, 500);
            }, { passive: true });

            console.log('ğŸ“± [ç§»åŠ¨ç«¯ä¼˜åŒ–] è¾“å…¥æ¡†viewportè¡Œä¸ºä¿®å¤å·²å¯åŠ¨');
        })();
    </script>

    <!-- ğŸ’°ã€è½¬è´¦åŠŸèƒ½ä¼˜åŒ–ã€‘è®©AIæ ¹æ®äººè®¾è‡ªç„¶å›åº” -->
    <script>
        // è½¬è´¦åŠŸèƒ½ä¼˜åŒ– - ç§»é™¤è‡ªåŠ¨æ”¶æ¬¾ï¼Œè®©AIæ ¹æ®äººè®¾è‡ªç„¶å›åº”
        (function() {
            'use strict';
            
            console.log('ğŸ’° [è½¬è´¦ä¼˜åŒ–] ç§»é™¤è‡ªåŠ¨æ”¶æ¬¾é€»è¾‘ï¼Œè®©AIæ ¹æ®äººè®¾è‡ªç„¶å›åº”...');
            
            // ğŸ”¥ã€é‡è¦ä¿®æ”¹ã€‘ç§»é™¤è‡ªåŠ¨æ”¶æ¬¾é€»è¾‘ï¼Œè®©AIæ ¹æ®è§’è‰²äººè®¾è‡ªç„¶å†³å®š
            // è½¬è´¦çŠ¶æ€å˜åŒ–åº”è¯¥ç”±AIçš„è‡ªç„¶å›å¤è§¦å‘ï¼Œè€Œä¸æ˜¯è‡ªåŠ¨å¤„ç†
            // AIä¼šæ ¹æ®è‡ªå·±çš„äººè®¾ï¼ˆæ¯”å¦‚é«˜å†·ã€æ¸©æŸ”ã€å‚²å¨‡ç­‰ï¼‰æ¥å†³å®šæ˜¯å¦æ”¶æ¬¾
            
            console.log('ğŸ’° [è½¬è´¦ä¼˜åŒ–] AIå°†æ ¹æ®è§’è‰²äººè®¾è‡ªç„¶å›åº”è½¬è´¦ï¼Œä¸å†è‡ªåŠ¨æ”¶æ¬¾');
        })();
    </script>

    <!-- ğŸš«ã€æ‹‰é»‘ç³»ç»Ÿã€‘æ¨¡æ€æ¡† -->
    <div id="blacklist-settings-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">æ‹‰é»‘ç®¡ç†</h3>
                <button class="modal-close" onclick="hideBlacklistSettings()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="settings-section">
                    <div class="section-header">
                        <i class="fas fa-user-slash section-icon"></i>
                        <span class="section-title">å½“å‰çŠ¶æ€</span>
                    </div>
                    <div class="setting-card">
                        <div class="setting-item" id="current-blacklist-status">
                            <div class="setting-left">
                                <div class="setting-label">æ‹‰é»‘çŠ¶æ€</div>
                                <div class="setting-desc" id="blacklist-status-desc">æ­£å¸¸èŠå¤©ä¸­</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="settings-section">
                    <div class="section-header">
                        <i class="fas fa-cog section-icon"></i>
                        <span class="section-title">æ‹‰é»‘è®¾ç½®</span>
                    </div>

                </div>

                <div class="settings-section">
                    <div class="section-header">
                        <i class="fas fa-exclamation-triangle section-icon danger-section-icon"></i>
                        <span class="section-title danger-section-title">æ“ä½œ</span>
                    </div>
                    <div class="setting-card">
                        <div class="setting-item danger-item" id="block-action-item" onclick="performBlockAction()">
                            <div class="setting-left">
                                <div class="setting-label danger-color" id="block-action-label">æ‹‰é»‘æ­¤è§’è‰²</div>
                                <div class="setting-desc" id="block-action-desc">é˜»æ­¢è¯¥è§’è‰²å‘ä½ å‘é€æ¶ˆæ¯</div>
                            </div>
                            <div class="setting-right">
                                <i class="fas fa-chevron-right danger-color"></i>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary" onclick="hideBlacklistSettings()">å…³é—­</button>
            </div>
        </div>
    </div>

    <!-- ğŸš«ã€å¥½å‹ç”³è¯·ã€‘æ¨¡æ€æ¡† -->
    <div id="friend-request-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">å¥½å‹ç”³è¯·</h3>
                <button class="modal-close" onclick="hideFriendRequestModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">ç”³è¯·ç†ç”±ï¼ˆå¯é€‰ï¼‰</label>
                    <textarea id="friend-request-message" class="form-textarea" placeholder="è¯·è¾“å…¥ç”³è¯·ç†ç”±..." maxlength="200"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary" onclick="hideFriendRequestModal()">å–æ¶ˆ</button>
                <button class="modal-primary" onclick="sendFriendRequestConfirm()">å‘é€ç”³è¯·</button>
            </div>
        </div>
    </div>

    <!-- ğŸ”¥ã€æ–°å¢ã€‘å¿ƒå£°æ¨¡æ€æ¡† -->
    <div id="inner-thoughts-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">
                    <svg class="ear-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 4C7.58 4 4 7.58 4 12C4 16.42 7.58 20 12 20C16.42 20 20 16.42 20 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        <path d="M17 4C17 4 20 4 20 7C20 10 17 10 17 13C17 16 20 16 20 16" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                    </svg>
                    å¿ƒå£°
                </h3>
                <button class="modal-close" onclick="hideInnerThoughtsModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div id="inner-thoughts-content" class="inner-thoughts-content">
                    <div class="inner-thoughts-loading">
                        <div class="loading-spinner"></div>
                        <p>æ­£åœ¨è¯»å–è§’è‰²çš„å†…å¿ƒæƒ³æ³•...</p>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary inner-thoughts-refresh-btn" onclick="refreshInnerThoughts(selectedMessageId)">
                    <i class="fas fa-sync-alt"></i> é‡æ–°ç”Ÿæˆ
                </button>
                <button class="modal-secondary" onclick="hideInnerThoughtsModal()">å…³é—­</button>
            </div>
        </div>
    </div>

    <!-- ğŸš«ã€æ‹‰é»‘ç³»ç»Ÿã€‘JavaScriptæ ¸å¿ƒåŠŸèƒ½ -->
    <script>
        // æ‹‰é»‘ç³»ç»Ÿå…¨å±€å˜é‡ - æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ï¼Œé¿å…é‡å¤å£°æ˜
        if (typeof blacklistData === 'undefined') {
            var blacklistData = [];
            var friendRequestsData = [];
            var characterStatusData = [];
        }

        // åŠ è½½æ‹‰é»‘ç³»ç»Ÿæ•°æ®
        async function loadBlacklistData() {
            try {
                blacklistData = await db.blacklist.orderBy('timestamp').reverse().toArray();
                console.log('æ‹‰é»‘æ•°æ®åŠ è½½å®Œæˆ:', blacklistData);
            } catch (error) {
                console.error('åŠ è½½æ‹‰é»‘æ•°æ®å¤±è´¥:', error);
                blacklistData = [];
            }
        }

        // æ£€æŸ¥æ˜¯å¦è¢«æ‹‰é»‘
        function isBlocked(blockerId, blockedId) {
            return blacklistData.some(record => 
                record.blockerId === blockerId && 
                record.blockedId === blockedId && 
                !record.unblocked
            );
        }



        // æ‹‰é»‘è§’è‰²
        async function blockCharacter(characterId, reason = '') {
            try {
                const now = new Date();

                if (isBlocked('user', characterId)) {
                    showToast('è¯¥è§’è‰²å·²è¢«æ‹‰é»‘', 'warning');
                    return;
                }

                const blockRecord = {
                    id: `block_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    blockerId: 'user',
                    blockedId: characterId,
                    timestamp: now.toISOString(),
                    reason: reason,
                    unblocked: false
                };
                
                blacklistData.unshift(blockRecord);
                await db.blacklist.add(blockRecord);
                
                const character = characters.find(c => c.id === characterId);
                showToast(`å·²æ‹‰é»‘ ${character?.name || 'è§’è‰²'}`, 'success');
                
                // ğŸ”¥ã€æ–°å¢ã€‘é€šçŸ¥è§’è‰²è¢«æ‹‰é»‘äº†
                await notifyCharacterBlocked(characterId, reason);
                
                // ç«‹å³æ›´æ–°èŠå¤©ç•Œé¢æ˜¾ç¤º
                if (currentChatCharacter && currentChatCharacter.id === characterId) {
                    updateChatBlockedStatus();
                }
                
                renderContactList();
                renderMessageList();
                
            } catch (error) {
                console.error('æ‹‰é»‘è§’è‰²å¤±è´¥:', error);
                showToast('æ‹‰é»‘å¤±è´¥', 'error');
            }
        }

        // è§£é™¤æ‹‰é»‘
        async function unblockCharacter(characterId) {
            try {
                const blockRecord = blacklistData.find(r => 
                    r.blockerId === 'user' && 
                    r.blockedId === characterId && 
                    !r.unblocked
                );
                
                if (!blockRecord) {
                    showToast('è¯¥è§’è‰²æœªè¢«æ‹‰é»‘', 'warning');
                    return;
                }
                
                blockRecord.unblocked = true;
                blockRecord.unblockTimestamp = new Date().toISOString();
                
                await db.blacklist.put(blockRecord);
                
                const character = characters.find(c => c.id === characterId);
                showToast(`å·²è§£é™¤å¯¹ ${character?.name || 'è§’è‰²'} çš„æ‹‰é»‘`, 'success');
                
                // ğŸ”¥ã€æ–°å¢ã€‘é€šçŸ¥è§’è‰²è¢«è§£é™¤æ‹‰é»‘äº†
                await notifyCharacterUnblocked(characterId);
                
                // åˆ·æ–°èŠå¤©ç•Œé¢æ˜¾ç¤º
                if (currentChatCharacter && currentChatCharacter.id === characterId) {
                    renderChatMessages(currentChatCharacter.id);
                    updateChatBlockedStatus();
                }
                
                renderContactList();
                renderMessageList();
                
            } catch (error) {
                console.error('è§£é™¤æ‹‰é»‘å¤±è´¥:', error);
                showToast('è§£é™¤æ‹‰é»‘å¤±è´¥', 'error');
            }
        }

        // æ›´æ–°è§’è‰²çŠ¶æ€
        async function updateCharacterStatus(characterId, status, activity = '', location = '') {
            try {
                let statusRecord = characterStatusData.find(s => s.characterId === characterId);

                if (!statusRecord) {
                    statusRecord = {
                        id: `status_${characterId}`,
                        characterId: characterId,
                        status: status,
                        activity: activity,
                        location: location,
                        lastUpdate: new Date().toISOString(),
                        lastChatTime: null // ğŸ”¥ã€æ–°å¢ã€‘ä¿ç•™æœ€åèŠå¤©æ—¶é—´å­—æ®µ
                    };
                    characterStatusData.push(statusRecord);
                } else {
                    // ğŸ”¥ã€ä¿®å¤ã€‘ä¿ç•™ç°æœ‰çš„lastChatTimeå­—æ®µ
                    const existingLastChatTime = statusRecord.lastChatTime;
                    statusRecord.status = status;
                    statusRecord.activity = activity;
                    statusRecord.location = location;
                    statusRecord.lastUpdate = new Date().toISOString();
                    statusRecord.lastChatTime = existingLastChatTime; // ä¿ç•™åŸæœ‰çš„èŠå¤©æ—¶é—´
                }

                await db.characterStatus.put(statusRecord);

            } catch (error) {
                console.error('æ›´æ–°è§’è‰²çŠ¶æ€å¤±è´¥:', error);
            }
        }

        // è·å–è§’è‰²çŠ¶æ€
        function getCharacterStatus(characterId) {
            return characterStatusData.find(s => s.characterId === characterId) || {
                status: 'online',
                activity: 'åœ¨çº¿',
                location: '',
                lastUpdate: new Date().toISOString(),
                lastChatTime: null // ğŸ”¥ã€æ–°å¢ã€‘æœ€åèŠå¤©æ—¶é—´
            };
        }

        // è§’è‰²æ‹‰é»‘ç”¨æˆ·
        async function aiBlockUser(characterId, reason = '') {
            try {
                const now = new Date();
                
                // æ£€æŸ¥æ˜¯å¦å·²ç»æ‹‰é»‘
                if (isBlocked(characterId, 'user')) {
                    return;
                }
                
                const blockRecord = {
                    id: `block_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    blockerId: characterId,
                    blockedId: 'user',
                    timestamp: now.toISOString(),
                    reason: reason,
                    unblocked: false
                };
                
                blacklistData.unshift(blockRecord);
                await db.blacklist.add(blockRecord);
                
                // æ›´æ–°èŠå¤©ç•Œé¢æ˜¾ç¤º
                if (currentChatCharacter && currentChatCharacter.id === characterId) {
                    updateChatBlockedStatus();
                }
                
                const character = characters.find(c => c.id === characterId);
                showToast(`${character?.name || 'è§’è‰²'} å·²å°†ä½ æ‹‰é»‘`, 'warning');
                
            } catch (error) {
                console.error('è§’è‰²æ‹‰é»‘ç”¨æˆ·å¤±è´¥:', error);
            }
        }

        // å‘é€å¥½å‹ç”³è¯·
        async function sendFriendRequest(characterId, message = '') {
            try {
                const request = {
                    id: `request_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    fromId: 'user',
                    toId: characterId,
                    timestamp: new Date().toISOString(),
                    status: 'pending',
                    type: 'friend',
                    message: message
                };
                
                friendRequestsData.unshift(request);
                await db.friendRequests.add(request);
                
                showToast('å¥½å‹ç”³è¯·å·²å‘é€', 'success');
                
            } catch (error) {
                console.error('å‘é€å¥½å‹ç”³è¯·å¤±è´¥:', error);
                showToast('å‘é€ç”³è¯·å¤±è´¥', 'error');
            }
        }

        // ğŸ”¥ã€ä¿®æ”¹ã€‘æ›´æ–°èŠå¤©ç•Œé¢çš„æ‹‰é»‘çŠ¶æ€æ˜¾ç¤º - ç¾¤èŠä¸æ˜¾ç¤ºæ‹‰é»‘æç¤º
        function updateChatBlockedStatus() {
            if (!currentChatCharacter) return;

            const characterId = currentChatCharacter.id;
            const isGroupChat = currentChatCharacter.isGroup;

            // ç§»é™¤ç°æœ‰çš„æ‹‰é»‘æç¤º
            const existingBlockedUI = document.querySelector('.blocked-input-notice');
            if (existingBlockedUI) {
                existingBlockedUI.remove();
            }

            // ç§»é™¤ç°æœ‰çš„è§’è‰²è¢«æ‹‰é»‘æç¤º
            const existingCharacterHint = document.querySelector('.character-blocked-hint');
            if (existingCharacterHint) {
                existingCharacterHint.remove();
            }

            // ğŸ”¥ã€ä¿®æ”¹ã€‘ç¾¤èŠä¸æ˜¾ç¤ºæ‹‰é»‘ç›¸å…³æç¤ºï¼Œåªæœ‰å•èŠæ‰å¤„ç†æ‹‰é»‘çŠ¶æ€
            if (!isGroupChat) {
                const isUserBlocked = isBlocked('user', characterId);
                const isCharacterBlocked = isBlocked(characterId, 'user');

                // å½“ç”¨æˆ·è¢«è§’è‰²æ‹‰é»‘æ—¶ï¼Œåœ¨è¾“å…¥æ¡†ä¸Šæ–¹æ˜¾ç¤ºæç¤º
                if (isCharacterBlocked) {
                    const inputArea = document.querySelector('.chat-input-area');
                    if (inputArea) {
                        const blockedNotice = document.createElement('div');
                        blockedNotice.className = 'blocked-input-notice show';

                        blockedNotice.innerHTML = `
                            <div class="notice-text">ä½ è¢« ${currentChatCharacter.name} æ‹‰é»‘äº†</div>
                            <button class="notice-button" onclick="showFriendRequestModal()">ç”³è¯·æ·»åŠ ä¸ºå¥½å‹</button>
                        `;

                        inputArea.appendChild(blockedNotice);
                    }

                    // ğŸ”¥ã€æ–°å¢ã€‘åœ¨èŠå¤©åŒºåŸŸæ˜¾ç¤ºè§’è‰²ç”³è¯·å¥½å‹çš„æç¤º
                    addCharacterBlockedHint(characterId);
                }

                // é‡æ–°æ¸²æŸ“æ¶ˆæ¯åˆ—è¡¨ä»¥æ˜¾ç¤ºæ‹‰é»‘çŠ¶æ€æŒ‡ç¤ºå™¨
                renderChatMessages(characterId);
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘åœ¨èŠå¤©ç•Œé¢æ˜¾ç¤ºè§’è‰²è¢«æ‹‰é»‘çš„æç¤º
        function addCharacterBlockedHint(characterId) {
            const messagesContainer = document.getElementById('chat-messages');
            if (!messagesContainer) return;

            // ç§»é™¤ç°æœ‰çš„æç¤º
            const existingHint = messagesContainer.querySelector('.character-blocked-hint');
            if (existingHint) {
                existingHint.remove();
            }

            // åˆ›å»ºæç¤ºæ¶ˆæ¯
            const hintContainer = document.createElement('div');
            hintContainer.className = 'character-blocked-hint';
            hintContainer.style.cssText = `
                text-align: center;
                margin: 20px auto;
                padding: 15px 20px;
                background: rgba(255, 193, 7, 0.1);
                border: 1px solid rgba(255, 193, 7, 0.3);
                border-radius: 12px;
                max-width: 320px;
                color: #856404;
                font-size: 13px;
                line-height: 1.4;
            `;

            hintContainer.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 8px;">ğŸ’¡ æç¤º</div>
                <div>${currentChatCharacter.name} è¢«æ‹‰é»‘äº†ï¼Œä½†ä»å¯ä»¥å‘é€æ¶ˆæ¯ã€‚å¦‚æœæƒ³ä¿®å¤å…³ç³»ï¼Œå¯ä»¥å‘é€å¥½å‹ç”³è¯·ã€‚</div>
                <div style="margin-top: 8px; font-size: 12px; color: #6c757d;">
                    å¥½å‹ç”³è¯·æ ¼å¼ï¼š{"type": "friend_request", "message": "é“æ­‰æˆ–è¯·æ±‚ä¿¡æ¯"}
                </div>
            `;

            // å°†æç¤ºæ·»åŠ åˆ°æ¶ˆæ¯å®¹å™¨çš„é¡¶éƒ¨
            messagesContainer.insertBefore(hintContainer, messagesContainer.firstChild);
        }

        // ğŸ”¥ã€ä¿®å¤ã€‘æ£€æŸ¥æ‹‰é»‘çŠ¶æ€å¹¶åˆ›å»ºç³»ç»Ÿæ¶ˆæ¯ï¼ˆåªåœ¨å‘é€æ¶ˆæ¯æ—¶è°ƒç”¨ä¸€æ¬¡ï¼‰
        function checkAndCreateBlockedSystemMessage(userMessage, characterId) {
            if (!currentChatCharacter || currentChatCharacter.isGroup) return; // ç¾¤èŠä¸å¤„ç†æ‹‰é»‘

            // æ£€æŸ¥è§’è‰²æ˜¯å¦æ‹‰é»‘äº†ç”¨æˆ·
            const isCharacterBlocked = isBlocked(characterId, 'user');

            if (isCharacterBlocked) {
                // ğŸ”¥ã€ä¿®å¤ã€‘ä¸ä¿å­˜åˆ°èŠå¤©è®°å½•ï¼Œåªåœ¨ç•Œé¢ä¸Šä¸´æ—¶æ˜¾ç¤ºç³»ç»Ÿæç¤º
                // åˆ›å»ºä¸´æ—¶çš„ç³»ç»Ÿæç¤ºå…ƒç´ 
                const messagesContainer = document.getElementById('api-chat-messages');
                const systemHint = document.createElement('div');
                systemHint.className = 'blocked-message-hint';
                systemHint.style.cssText = `
                    text-align: center;
                    color: #999;
                    font-size: 12px;
                    padding: 4px 8px;
                    margin: 2px 0;
                    background: transparent;
                    border: none;
                    display: block;
                    max-width: 80%;
                    width: fit-content;
                    margin-left: auto;
                    margin-right: auto;
                `;
                systemHint.textContent = 'æ¶ˆæ¯å·²å‘å‡ºï¼Œä½†è¢«å¯¹æ–¹æ‹’æ”¶äº†';

                // æ·»åŠ åˆ°ç•Œé¢
                messagesContainer.appendChild(systemHint);

                // æ»šåŠ¨åˆ°åº•éƒ¨
                setTimeout(() => {
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                }, 100);
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ¸…ç†å·²ä¿å­˜çš„æ‹‰é»‘ç³»ç»Ÿæ¶ˆæ¯
        function cleanupBlockedSystemMessages() {
            let hasChanges = false;

            // éå†æ‰€æœ‰èŠå¤©è®°å½•
            Object.keys(chatMessages).forEach(characterId => {
                const messages = chatMessages[characterId];
                const originalLength = messages.length;

                // è¿‡æ»¤æ‰æ‹‰é»‘ç³»ç»Ÿæ¶ˆæ¯
                chatMessages[characterId] = messages.filter(msg =>
                    !(msg.sender === 'system' && msg.isBlockedMessage)
                );

                if (chatMessages[characterId].length !== originalLength) {
                    hasChanges = true;
                    console.log(`ğŸ§¹ [æ¸…ç†] ä»è§’è‰² ${characterId} çš„èŠå¤©è®°å½•ä¸­ç§»é™¤äº† ${originalLength - chatMessages[characterId].length} æ¡æ‹‰é»‘ç³»ç»Ÿæ¶ˆæ¯`);
                }
            });

            // å¦‚æœæœ‰å˜åŒ–ï¼Œä¿å­˜åˆ°æ•°æ®åº“
            if (hasChanges) {
                saveChatMessages();
                console.log('ğŸ§¹ [æ¸…ç†] æ‹‰é»‘ç³»ç»Ÿæ¶ˆæ¯æ¸…ç†å®Œæˆï¼Œå·²ä¿å­˜åˆ°æ•°æ®åº“');
            }
        }

        // ğŸ”¥ã€ä¿®å¤ã€‘ä¸ºæ¶ˆæ¯æ·»åŠ æ‹‰é»‘çŠ¶æ€æŒ‡ç¤ºå™¨ - æ˜¾ç¤ºçº¢è‰²æ„Ÿå¹å·å’Œç³»ç»Ÿæç¤º
        function addBlockedIndicatorToMessage(messageContainer, message, characterId) {
            if (!currentChatCharacter) return;

            // æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦åœ¨æ‹‰é»‘çŠ¶æ€ä¸‹å‘é€
            const messageTimestamp = message.timestamp;
            let shouldShowIndicator = false;
            let blockTimestamp = null;

            // ğŸ”¥ã€ä¿®å¤ã€‘æŸ¥æ‰¾ç›¸å…³çš„æ‹‰é»‘è®°å½• - å³ä½¿è§£é™¤æ‹‰é»‘åä¹Ÿè¦æ˜¾ç¤ºå†å²æ¶ˆæ¯çš„æŒ‡ç¤ºå™¨
            if (message.sender === 'sent') {
                // ç”¨æˆ·å‘é€çš„æ¶ˆæ¯ï¼Œæ£€æŸ¥è§’è‰²æ˜¯å¦æ›¾ç»æ‹‰é»‘äº†ç”¨æˆ·
                const blockRecord = blacklistData.find(r =>
                    r.blockerId === characterId &&
                    r.blockedId === 'user'
                    // ğŸ”¥ã€ç§»é™¤ã€‘ä¸å†æ£€æŸ¥ !r.unblockedï¼Œè®©å†å²æ¶ˆæ¯ä¿ç•™æŒ‡ç¤ºå™¨
                );
                if (blockRecord) {
                    blockTimestamp = new Date(blockRecord.timestamp).getTime();
                    // ğŸ”¥ã€ä¿®å¤ã€‘å¦‚æœæ¶ˆæ¯æ˜¯åœ¨æ‹‰é»‘æœŸé—´å‘é€çš„ï¼Œå°±æ˜¾ç¤ºæŒ‡ç¤ºå™¨
                    const unblockTimestamp = blockRecord.unblocked && blockRecord.unblockTimestamp
                        ? new Date(blockRecord.unblockTimestamp).getTime()
                        : Date.now();
                    shouldShowIndicator = messageTimestamp >= blockTimestamp &&
                                        (messageTimestamp <= unblockTimestamp || !blockRecord.unblocked);
                }
            } else if (message.sender === 'received') {
                // è§’è‰²å‘é€çš„æ¶ˆæ¯ï¼Œæ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ›¾ç»æ‹‰é»‘äº†è§’è‰²
                const blockRecord = blacklistData.find(r =>
                    r.blockerId === 'user' &&
                    r.blockedId === characterId
                    // ğŸ”¥ã€ç§»é™¤ã€‘ä¸å†æ£€æŸ¥ !r.unblockedï¼Œè®©å†å²æ¶ˆæ¯ä¿ç•™æŒ‡ç¤ºå™¨
                );
                if (blockRecord) {
                    blockTimestamp = new Date(blockRecord.timestamp).getTime();
                    // ğŸ”¥ã€ä¿®å¤ã€‘å¦‚æœæ¶ˆæ¯æ˜¯åœ¨æ‹‰é»‘æœŸé—´å‘é€çš„ï¼Œå°±æ˜¾ç¤ºæŒ‡ç¤ºå™¨
                    const unblockTimestamp = blockRecord.unblocked && blockRecord.unblockTimestamp
                        ? new Date(blockRecord.unblockTimestamp).getTime()
                        : Date.now();
                    shouldShowIndicator = messageTimestamp >= blockTimestamp &&
                                        (messageTimestamp <= unblockTimestamp || !blockRecord.unblocked);
                }
            }

            if (shouldShowIndicator) {
                // ğŸ”¥ã€ä¿®å¤ã€‘æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰æŒ‡ç¤ºå™¨ï¼Œé¿å…é‡å¤æ·»åŠ 
                const existingIndicator = messageContainer.querySelector('.message-blocked-indicator');
                const existingHint = messageContainer.nextElementSibling?.classList.contains('blocked-message-hint-inline');

                if (existingIndicator && existingHint) {
                    return; // å·²ç»æœ‰æŒ‡ç¤ºå™¨å’Œæç¤ºäº†ï¼Œä¸é‡å¤æ·»åŠ 
                }

                // åˆ›å»ºæ‹‰é»‘æŒ‡ç¤ºå™¨ï¼ˆçº¢è‰²æ„Ÿå¹å·ï¼‰
                if (!existingIndicator) {
                    const indicator = document.createElement('div');
                    indicator.className = 'message-blocked-indicator';
                    indicator.innerHTML = '!';
                    indicator.title = 'æ¶ˆæ¯å·²å‘å‡ºï¼Œä½†è¢«å¯¹æ–¹æ‹’æ”¶äº†';

                    // æ·»åŠ æŒ‡ç¤ºå™¨åˆ°æ¶ˆæ¯å®¹å™¨
                    messageContainer.style.position = 'relative';
                    messageContainer.appendChild(indicator);

                    // ğŸ”¥ã€æ–°å¢ã€‘åŠ¨æ€å®šä½æ„Ÿå¹å·åˆ°æ°”æ³¡å¤–ä¾§
                    setTimeout(() => {
                        const bubble = messageContainer.querySelector('.message-bubble');
                        if (bubble) {
                            // è·å–æ°”æ³¡ç›¸å¯¹äºæ¶ˆæ¯å®¹å™¨çš„ä½ç½®
                            const containerRect = messageContainer.getBoundingClientRect();
                            const bubbleRect = bubble.getBoundingClientRect();

                            if (message.sender === 'sent') {
                                // ç”¨æˆ·æ¶ˆæ¯ï¼šæ„Ÿå¹å·åœ¨æ°”æ³¡å·¦è¾¹
                                const bubbleLeftOffset = bubbleRect.left - containerRect.left;
                                indicator.style.left = (bubbleLeftOffset - 20) + 'px'; // 16pxæ„Ÿå¹å·å®½åº¦ + 4pxé—´è·
                                indicator.style.right = 'auto';
                            } else if (message.sender === 'received') {
                                // ğŸ”¥ã€ä¿®å¤ã€‘è§’è‰²æ¶ˆæ¯ï¼šæ„Ÿå¹å·åœ¨æ°”æ³¡å³ä¸‹è§’å¤–ä¾§3pxå¤„
                                const bubbleRightOffset = bubbleRect.right - containerRect.left;
                                indicator.style.left = (bubbleRightOffset + 3) + 'px'; // æ°”æ³¡å³è¾¹ + 3pxé—´è·
                                indicator.style.right = 'auto';
                            }
                        }
                    }, 10);
                }

                // ğŸ”¥ã€æ–°å¢ã€‘åœ¨æ¶ˆæ¯ä¸‹æ–¹æ·»åŠ ç³»ç»Ÿæç¤º
                if (!existingHint) {
                    const systemHint = document.createElement('div');
                    systemHint.className = 'blocked-message-hint-inline';
                    systemHint.style.cssText = `
                        text-align: center;
                        color: #999;
                        font-size: 12px;
                        padding: 2px 8px;
                        margin: 2px 0 8px 0;
                        background: transparent;
                        border: none;
                        display: block;
                        max-width: 80%;
                        width: fit-content;
                        margin-left: auto;
                        margin-right: auto;
                    `;
                    systemHint.textContent = 'æ¶ˆæ¯å·²å‘å‡ºï¼Œä½†è¢«å¯¹æ–¹æ‹’æ”¶äº†';

                    // åœ¨æ¶ˆæ¯å®¹å™¨åé¢æ’å…¥ç³»ç»Ÿæç¤º
                    messageContainer.parentNode.insertBefore(systemHint, messageContainer.nextSibling);
                }
            }
        }

        // ğŸ”¥ã€ä¿®æ”¹ã€‘æ˜¾ç¤ºæ‹‰é»‘/å±è”½è®¾ç½® - åŒºåˆ†å•èŠå’Œç¾¤èŠ
        function showBlacklistSettings() {
            if (!currentChatCharacter) {
                showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè§’è‰²', 'warning');
                return;
            }

            const characterId = currentChatCharacter.id;
            const isGroupChat = currentChatCharacter.isGroup;

            if (isGroupChat) {
                // ğŸ”¥ã€æ–°å¢ã€‘ç¾¤èŠåªèƒ½å±è”½ï¼Œä¸”åªæœ‰ç”¨æˆ·å¯ä»¥å±è”½ç¾¤èŠ
                showGroupMuteSettings(characterId);
            } else {
                // å•èŠä½¿ç”¨åŸæœ‰çš„æ‹‰é»‘é€»è¾‘
                const isUserBlocked = isBlocked('user', characterId);

                const statusDesc = document.getElementById('blacklist-status-desc');
                const actionLabel = document.getElementById('block-action-label');
                const actionDesc = document.getElementById('block-action-desc');

                if (isUserBlocked) {
                    statusDesc.textContent = 'ä½ å·²æ‹‰é»‘æ­¤è§’è‰²';
                    actionLabel.textContent = 'è§£é™¤æ‹‰é»‘';
                    actionDesc.textContent = 'æ¢å¤ä¸è¯¥è§’è‰²çš„æ­£å¸¸èŠå¤©';
                } else {
                    statusDesc.textContent = 'æ­£å¸¸èŠå¤©ä¸­';
                    actionLabel.textContent = 'æ‹‰é»‘æ­¤è§’è‰²';
                    actionDesc.textContent = 'é˜»æ­¢è¯¥è§’è‰²å‘ä½ å‘é€æ¶ˆæ¯';
                }

                document.getElementById('blacklist-settings-modal').style.display = 'flex';
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ›´æ–°è®¾ç½®ç•Œé¢çš„æ‹‰é»‘/å±è”½ç®¡ç†æ–‡æ¡ˆ
        function updateBlockManageLabel(isGroupChat) {
            const labelElement = document.getElementById('block-manage-label');
            const descElement = document.getElementById('block-manage-desc');

            if (labelElement && descElement) {
                if (isGroupChat) {
                    labelElement.textContent = 'å±è”½ç®¡ç†';
                    descElement.textContent = 'å±è”½/å–æ¶ˆå±è”½ç¾¤èŠæ¶ˆæ¯é€šçŸ¥';
                } else {
                    labelElement.textContent = 'æ‹‰é»‘ç®¡ç†';
                    descElement.textContent = 'æ‹‰é»‘/è§£é™¤æ‹‰é»‘ç®¡ç†';
                }
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ˜¾ç¤ºç¾¤èŠå±è”½è®¾ç½®
        function showGroupMuteSettings(groupId) {
            // æ£€æŸ¥æ˜¯å¦å·²å±è”½è¯¥ç¾¤èŠ
            const isMuted = isGroupMuted(groupId);

            const statusDesc = document.getElementById('blacklist-status-desc');
            const actionLabel = document.getElementById('block-action-label');
            const actionDesc = document.getElementById('block-action-desc');

            // ä¿®æ”¹ç•Œé¢æ–‡æ¡ˆä¸ºå±è”½ç›¸å…³
            if (isMuted) {
                statusDesc.textContent = 'ä½ å·²å±è”½æ­¤ç¾¤èŠ';
                actionLabel.textContent = 'å–æ¶ˆå±è”½';
                actionDesc.textContent = 'é‡æ–°æ¥æ”¶è¯¥ç¾¤èŠçš„æ¶ˆæ¯é€šçŸ¥';
            } else {
                statusDesc.textContent = 'æ­£å¸¸æ¥æ”¶ç¾¤èŠæ¶ˆæ¯';
                actionLabel.textContent = 'å±è”½æ­¤ç¾¤èŠ';
                actionDesc.textContent = 'ä¸å†æ¥æ”¶è¯¥ç¾¤èŠçš„æ¶ˆæ¯é€šçŸ¥';
            }

            document.getElementById('blacklist-settings-modal').style.display = 'flex';
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ£€æŸ¥ç¾¤èŠæ˜¯å¦è¢«å±è”½
        function isGroupMuted(groupId) {
            const mutedGroups = JSON.parse(localStorage.getItem('mutedGroups') || '[]');
            return mutedGroups.includes(groupId);
        }

        // ğŸ”¥ã€æ–°å¢ã€‘å±è”½/å–æ¶ˆå±è”½ç¾¤èŠ
        function toggleGroupMute(groupId) {
            const mutedGroups = JSON.parse(localStorage.getItem('mutedGroups') || '[]');
            const isMuted = mutedGroups.includes(groupId);

            if (isMuted) {
                // å–æ¶ˆå±è”½
                const index = mutedGroups.indexOf(groupId);
                if (index > -1) {
                    mutedGroups.splice(index, 1);
                }
                showToast(`å·²å–æ¶ˆå±è”½ ${currentChatCharacter?.name}`, 'success');
            } else {
                // å±è”½ç¾¤èŠ
                mutedGroups.push(groupId);
                showToast(`å·²å±è”½ ${currentChatCharacter?.name}`, 'info');
            }

            localStorage.setItem('mutedGroups', JSON.stringify(mutedGroups));

            // æ›´æ–°ç•Œé¢
            renderContactList();
            hideBlacklistSettings();
        }

        // éšè—æ‹‰é»‘è®¾ç½®
        function hideBlacklistSettings() {
            document.getElementById('blacklist-settings-modal').style.display = 'none';
        }

        // æ˜¾ç¤ºå¥½å‹ç”³è¯·æ¨¡æ€æ¡†
        function showFriendRequestModal() {
            if (!currentChatCharacter) return;

            document.getElementById('friend-request-message').value = '';
            document.getElementById('friend-request-modal').style.display = 'flex';
        }

        // éšè—å¥½å‹ç”³è¯·æ¨¡æ€æ¡†
        function hideFriendRequestModal() {
            document.getElementById('friend-request-modal').style.display = 'none';
        }

        // å‘é€å¥½å‹ç”³è¯·ç¡®è®¤
        async function sendFriendRequestConfirm() {
    if (!currentChatCharacter) return;
    
    const message = document.getElementById('friend-request-message').value.trim();
    const characterId = currentChatCharacter.id;

    // 1. å…ˆåœ¨æ•°æ®åº“ä¸­è®°å½•è¿™ä¸ªç”³è¯·äº‹ä»¶
    await sendFriendRequest(characterId, message);
    hideFriendRequestModal();
    
    // 2. ğŸ”¥ã€æ ¸å¿ƒæ–°å¢ã€‘ç«‹åˆ»è°ƒç”¨APIï¼Œè®©AIå¤„ç†è¿™ä¸ªå¥½å‹ç”³è¯·
    showToast('ç”³è¯·å·²å‘é€ï¼Œç­‰å¾…å¯¹æ–¹å›åº”...', 'info');
    await processAIFriendRequestResponse(characterId, message); 
}

        // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†AIä¸»åŠ¨å‘é€çš„å¥½å‹ç”³è¯·
        async function handleAIFriendRequest(characterId, accepted, messageId) {
            if (!currentChatCharacter || currentChatCharacter.id !== characterId) return;

            try {
                if (accepted) {
                    // ç”¨æˆ·åŒæ„äº†AIçš„å¥½å‹ç”³è¯·ï¼Œè§£é™¤æ‹‰é»‘
                    await unblockCharacter(characterId);
                    showToast(`å·²åŒæ„ ${currentChatCharacter.name} çš„å¥½å‹ç”³è¯·`, 'success');

                    // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯è¡¨ç¤ºå¥½å‹ç”³è¯·è¢«æ¥å—
                    const systemMessage = {
                        id: Date.now().toString(),
                        sender: 'system',
                        content: `ä½ ä»¬å·²æˆåŠŸæ·»åŠ ä¸ºå¥½å‹ï¼Œç°åœ¨å¯ä»¥å¼€å§‹èŠå¤©äº†ï¼`,
                        timestamp: Date.now(),
                        role: 'system'
                    };

                    // ä¿å­˜ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©è®°å½•
                    await saveMessage(characterId, systemMessage);

                    // é‡æ–°æ¸²æŸ“èŠå¤©ç•Œé¢
                    renderChatMessages(characterId);
                    updateChatBlockedStatus();

                } else {
                    // ç”¨æˆ·æ‹’ç»äº†AIçš„å¥½å‹ç”³è¯·
                    showToast(`å·²æ‹’ç» ${currentChatCharacter.name} çš„å¥½å‹ç”³è¯·`, 'info');

                    // å¯ä»¥é€‰æ‹©æ·»åŠ ä¸€ä¸ªç³»ç»Ÿæ¶ˆæ¯è¡¨ç¤ºç”³è¯·è¢«æ‹’ç»
                    const systemMessage = {
                        id: Date.now().toString(),
                        sender: 'system',
                        content: `ä½ æ‹’ç»äº†å¥½å‹ç”³è¯·`,
                        timestamp: Date.now(),
                        role: 'system'
                    };

                    await saveMessage(characterId, systemMessage);
                    renderChatMessages(characterId);
                }

                // æ›´æ–°å¥½å‹ç”³è¯·æ¶ˆæ¯çš„çŠ¶æ€ï¼ˆå¯é€‰ï¼šæ·»åŠ å·²å¤„ç†æ ‡è®°ï¼‰
                // è¿™é‡Œå¯ä»¥æ ¹æ®éœ€è¦æ·»åŠ æ›´å¤šé€»è¾‘

            } catch (error) {
                console.error('å¤„ç†AIå¥½å‹ç”³è¯·å¤±è´¥:', error);
                showToast('å¤„ç†å¥½å‹ç”³è¯·å¤±è´¥', 'error');
            }
        }

        // ğŸ”¥ã€ä¿®æ”¹ã€‘æ‰§è¡Œæ‹‰é»‘/å±è”½æ“ä½œ - åŒºåˆ†å•èŠå’Œç¾¤èŠ
        function performBlockAction() {
            if (!currentChatCharacter) return;

            const characterId = currentChatCharacter.id;
            const isGroupChat = currentChatCharacter.isGroup;

            if (isGroupChat) {
                // ğŸ”¥ã€æ–°å¢ã€‘ç¾¤èŠå±è”½é€»è¾‘
                const isMuted = isGroupMuted(characterId);

                if (isMuted) {
                    if (confirm(`ç¡®å®šè¦å–æ¶ˆå±è”½ ${currentChatCharacter.name} å—ï¼Ÿ`)) {
                        toggleGroupMute(characterId);
                    }
                } else {
                    if (confirm(`ç¡®å®šè¦å±è”½ ${currentChatCharacter.name} å—ï¼Ÿ\n\nå±è”½åå°†ä¸å†æ¥æ”¶è¯¥ç¾¤èŠçš„æ¶ˆæ¯é€šçŸ¥`)) {
                        toggleGroupMute(characterId);
                    }
                }
            } else {
                // å•èŠæ‹‰é»‘é€»è¾‘
                const isUserBlocked = isBlocked('user', characterId);

                if (isUserBlocked) {
                    if (confirm(`ç¡®å®šè¦è§£é™¤å¯¹ ${currentChatCharacter.name} çš„æ‹‰é»‘å—ï¼Ÿ`)) {
                        unblockCharacter(characterId);
                        hideBlacklistSettings();
                    }
                } else {
                    if (confirm(`ç¡®å®šè¦æ‹‰é»‘ ${currentChatCharacter.name} å—ï¼Ÿ`)) {
                        blockCharacter(characterId, '');
                        hideBlacklistSettings();
                    }
                }
            }
        }

        // åœ¨åº”ç”¨åˆå§‹åŒ–æ—¶åŠ è½½æ‹‰é»‘ç³»ç»Ÿæ•°æ®
        document.addEventListener('DOMContentLoaded', async function() {
            setTimeout(async () => {
                try {
                    await Promise.all([
                        loadBlacklistData(),
                        loadFriendRequestsData(),
                        loadCharacterStatusData()
                    ]);
                    console.log('ğŸš« æ‹‰é»‘ç³»ç»Ÿæ•°æ®åŠ è½½å®Œæˆ');
                } catch (error) {
                    console.error('æ‹‰é»‘ç³»ç»Ÿæ•°æ®åŠ è½½å¤±è´¥:', error);
                }
            }, 1000);
        });

        // åŠ è½½å¥½å‹ç”³è¯·æ•°æ®
        async function loadFriendRequestsData() {
            try {
                friendRequestsData = await db.friendRequests.orderBy('timestamp').reverse().toArray();
                console.log('å¥½å‹ç”³è¯·æ•°æ®åŠ è½½å®Œæˆ:', friendRequestsData);
            } catch (error) {
                console.error('åŠ è½½å¥½å‹ç”³è¯·æ•°æ®å¤±è´¥:', error);
                friendRequestsData = [];
            }
        }

        // åŠ è½½è§’è‰²çŠ¶æ€æ•°æ®
        async function loadCharacterStatusData() {
            try {
                characterStatusData = await db.characterStatus.toArray();
                console.log('è§’è‰²çŠ¶æ€æ•°æ®åŠ è½½å®Œæˆ:', characterStatusData);
            } catch (error) {
                console.error('åŠ è½½è§’è‰²çŠ¶æ€æ•°æ®å¤±è´¥:', error);
                characterStatusData = [];
            }
        }

        // ğŸ“±ã€è§’è‰²çŠ¶æ€æ˜¾ç¤ºã€‘ç›¸å…³åŠŸèƒ½
        // æ¸²æŸ“è§’è‰²çŠ¶æ€
        function renderCharacterStatus(characterId, container) {
            const chatSettings = getCurrentChatSettings();
            if (!chatSettings.characterStatusEnabled) {
                // å¦‚æœå…³é—­äº†çŠ¶æ€æ˜¾ç¤ºï¼Œç§»é™¤ç°æœ‰çš„çŠ¶æ€å…ƒç´ 
                if (container) {
                    const existingStatus = container.querySelector('.character-status');
                    if (existingStatus) {
                        existingStatus.remove();
                    }
                }
                return; 
            }
            
            const status = getCharacterStatus(characterId);
            const isUserBlocked = isBlocked('user', characterId);
            const isCharacterBlocked = isBlocked(characterId, 'user');
            
            let statusClass = 'online';
            let statusText = status.activity || 'åœ¨çº¿';
            
            if (isUserBlocked || isCharacterBlocked) {
                statusClass = 'blocked';
                statusText = 'å·²æ‹‰é»‘';
            } else if (status.status === 'busy') {
                statusClass = 'busy';
            }
            
            const statusHtml = `
                <div class="character-status">
                    <div class="status-indicator ${statusClass}"></div>
                    <span class="status-text">${statusText}</span>
                </div>
            `;
            
            // å¦‚æœå®¹å™¨å­˜åœ¨ï¼Œæ·»åŠ çŠ¶æ€æ˜¾ç¤º
            if (container) {
                // å…ˆç§»é™¤ç°æœ‰çš„çŠ¶æ€æ˜¾ç¤º
                const existingStatus = container.querySelector('.character-status');
                if (existingStatus) {
                    existingStatus.remove();
                }
                
                // ğŸ”¥ã€ä¿®å¤ã€‘åˆ¤æ–­å®¹å™¨ç±»å‹ï¼Œä½¿ç”¨ä¸åŒçš„æ’å…¥ç­–ç•¥
                if (container.classList.contains('header')) {
                    // èŠå¤©ç•Œé¢çš„.headerå®¹å™¨ï¼šç›´æ¥æ·»åŠ åˆ°å®¹å™¨ä¸­ï¼Œä½¿ç”¨CSSç»å¯¹å®šä½
                    container.insertAdjacentHTML('beforeend', statusHtml);
                } else if (container.classList.contains('app-header')) {
                    // å…¶ä»–ç•Œé¢çš„.app-headerå®¹å™¨ï¼šæ·»åŠ åˆ°.app-titleå†…éƒ¨
                    const titleElement = container.querySelector('.app-title');
                    if (titleElement) {
                        titleElement.insertAdjacentHTML('afterend', statusHtml);
                    } else {
                        container.insertAdjacentHTML('beforeend', statusHtml);
                    }
                } else {
                    // å…¶ä»–å®¹å™¨ï¼šé»˜è®¤æ·»åŠ åˆ°æœ«å°¾
                    container.insertAdjacentHTML('beforeend', statusHtml);
                }
            }
        }

        // AIç”Ÿæˆè§’è‰²çŠ¶æ€
        async function generateCharacterStatus(characterId) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;
                
                // è·å–èŠå¤©è®¾ç½®å’Œæœ€è¿‘èŠå¤©è®°å½•
                const chatSettings = await getAsyncChatSettings(characterId);
                const messages = chatMessages[characterId] || [];
                const recentMessages = messages.slice(-5); // æœ€è¿‘5æ¡æ¶ˆæ¯
                
                // æ„å»ºä¸Šä¸‹æ–‡ä¿¡æ¯
                let chatContext = '';
                if (recentMessages.length > 0) {
                    // ğŸ”¥ã€ä¿®å¤ã€‘ä½¿ç”¨å®é™…ç”¨æˆ·åè€Œä¸æ˜¯"ç”¨æˆ·"
                    const userName = getCurrentPersonaName();
                    chatContext = 'æœ€è¿‘çš„èŠå¤©è®°å½•ï¼š\n' +
                        recentMessages.map(msg => {
                            if (msg.sender === 'sent') return `${userName}ï¼š${msg.content}`;
                            if (msg.sender === 'received') return `${character.name}ï¼š${msg.content}`;
                            return '';
                        }).filter(Boolean).join('\n') + '\n\n';
                }
                
                // è·å–ä¸–ç•Œä¹¦å†…å®¹ä½œä¸ºèƒŒæ™¯
                let worldBookContext = '';
                if (chatSettings?.linkedWorldBookIds && chatSettings.linkedWorldBookIds.length > 0) {
                    try {
                        const worldBooks = await Promise.all(
                            chatSettings.linkedWorldBookIds.map(id => db.worldbooks.get(id))
                        );
                        const validWorldBooks = worldBooks.filter(book => book && book.content);
                        if (validWorldBooks.length > 0) {
                            worldBookContext = 'èƒŒæ™¯è®¾å®šï¼š\n' + 
                                validWorldBooks.map(book => `${book.name}ï¼š${book.content}`).join('\n\n') + '\n\n';
                        }
                    } catch (error) {
                        console.error('è·å–ä¸–ç•Œä¹¦å†…å®¹å¤±è´¥:', error);
                    }
                }
                
                // éšæœºé€‰æ‹©çŠ¶æ€ç±»å‹ï¼šæ´»åŠ¨æˆ–å¿ƒæƒ…
                const statusType = Math.random() < 0.5 ? 'activity' : 'mood';
                
                let prompt;
                if (statusType === 'activity') {
                    // ç”Ÿæˆæ´»åŠ¨çŠ¶æ€
                    prompt = `ä½ æ˜¯${character.name}ï¼Œäººè®¾å¦‚ä¸‹ï¼š${character.bio}

${worldBookContext}${chatContext}è¯·æ ¹æ®ä½ çš„äººè®¾ã€å½“å‰å‰§æƒ…å’ŒèŠå¤©è®°å½•ï¼Œç”Ÿæˆä¸€ä¸ªç¬¦åˆä½ å½“å‰çŠ¶å†µçš„æ´»åŠ¨çŠ¶æ€ã€‚è¦æ±‚ï¼š
1. 10-20å­—å†…ï¼Œç®€æ´æ˜äº†
2. ç¬¦åˆä½ çš„æ€§æ ¼å’Œèº«ä»½è®¾å®š
3. åŸºäºæœ€è¿‘çš„èŠå¤©å†…å®¹æˆ–å‰§æƒ…å‘å±•
4. æ ¼å¼ï¼šåœ¨[åœ°ç‚¹][åšä»€ä¹ˆ]
5. è¦çœŸå®åæ˜ è§’è‰²å½“ä¸‹å¯èƒ½åœ¨åšçš„äº‹æƒ…
6. å¦‚æœæ²¡æœ‰å…·ä½“èŠå¤©è®°å½•ï¼Œåˆ™æ ¹æ®äººè®¾æ¨æµ‹åˆç†çš„æ—¥å¸¸æ´»åŠ¨

ç¤ºä¾‹æ ¼å¼ï¼šåœ¨å›¾ä¹¦é¦†æ•´ç†èµ„æ–™ã€åœ¨è®­ç»ƒåœºç»ƒä¹ å‰‘æœ¯ã€åœ¨æˆ¿é—´é‡Œæ²‰æ€ã€åœ¨èŠ±å›­ä¸­æ•£æ­¥ç­‰

è¯·ç”Ÿæˆä¸€ä¸ªæ´»åŠ¨çŠ¶æ€ï¼š`;
                } else {
                    // ç”Ÿæˆå¿ƒæƒ…çŠ¶æ€
                    prompt = `ä½ æ˜¯${character.name}ï¼Œäººè®¾å¦‚ä¸‹ï¼š${character.bio}

${worldBookContext}${chatContext}è¯·æ ¹æ®ä½ çš„äººè®¾ã€å½“å‰å‰§æƒ…å’ŒèŠå¤©è®°å½•ï¼Œç”Ÿæˆä¸€ä¸ªç¬¦åˆä½ å½“å‰å¿ƒæƒ…çš„çŠ¶æ€ã€‚è¦æ±‚ï¼š
1. 10-20å­—å†…ï¼Œç®€æ´æ˜äº†ï¼Œç¦æ­¢è¶…è¿‡20ä¸ªå­—
2. ç¬¦åˆä½ çš„æ€§æ ¼ç‰¹ç‚¹
3. åŸºäºæœ€è¿‘çš„å¯¹è¯å†…å®¹æˆ–æƒ…æ„Ÿå˜åŒ–
4. è¡¨è¾¾ä½ å½“ä¸‹çš„çœŸå®æƒ…æ„ŸçŠ¶æ€
5. è¦æœ‰è§’è‰²çš„ä¸ªæ€§è‰²å½©
6. å¦‚æœæ²¡æœ‰å…·ä½“èŠå¤©è®°å½•ï¼Œåˆ™æ ¹æ®äººè®¾æ¨æµ‹åŸºæœ¬å¿ƒæƒ…

ç¤ºä¾‹æ ¼å¼ï¼šå¿ƒæƒ…æ„‰æ‚¦ã€ç•¥æ„Ÿå›°æƒ‘ã€æ­£åœ¨ä¸“æ³¨æ€è€ƒã€æ„Ÿåˆ°æœ‰äº›ç–²æƒ«ã€å¯¹æœªæ¥å……æ»¡æœŸå¾…ç­‰

è¯·ç”Ÿæˆä¸€ä¸ªå¿ƒæƒ…çŠ¶æ€ï¼š`;
                }
                
                // ä½¿ç”¨AIç”ŸæˆçŠ¶æ€
                const statusText = await generateAIResponse(prompt, character);
                
                if (statusText && statusText.trim()) {
                    const cleanStatus = statusText.trim().replace(/^["""''ã€Œã€ã€ã€ã€ã€‘]|["""''ã€Œã€ã€ã€ã€ã€‘]$/g, '');
                    await updateCharacterStatus(characterId, 'online', cleanStatus);
                    console.log(`ä¸º${character.name}ç”Ÿæˆ${statusType === 'activity' ? 'æ´»åŠ¨' : 'å¿ƒæƒ…'}çŠ¶æ€: ${cleanStatus}`);
                } else {
                    // å¦‚æœAIç”Ÿæˆå¤±è´¥ï¼Œä½¿ç”¨åŸºäºäººè®¾çš„é»˜è®¤çŠ¶æ€
                    const fallbackStatus = generateFallbackStatus(character, statusType);
                    await updateCharacterStatus(characterId, 'online', fallbackStatus);
                    console.log(`ä¸º${character.name}ä½¿ç”¨é»˜è®¤${statusType === 'activity' ? 'æ´»åŠ¨' : 'å¿ƒæƒ…'}çŠ¶æ€: ${fallbackStatus}`);
                }
                
            } catch (error) {
                console.error('ç”Ÿæˆè§’è‰²çŠ¶æ€å¤±è´¥:', error);
                // é”™è¯¯æ—¶ä½¿ç”¨ç®€å•çš„é»˜è®¤çŠ¶æ€
                const fallbackStatus = generateFallbackStatus(character, 'activity');
                await updateCharacterStatus(characterId, 'online', fallbackStatus);
            }
        }
        
        // ç”ŸæˆåŸºäºäººè®¾çš„å¤‡ç”¨çŠ¶æ€
        function generateFallbackStatus(character, statusType) {
            const bio = (character.bio || '').toLowerCase();
            
            if (statusType === 'activity') {
                // åŸºäºäººè®¾å…³é”®è¯çš„æ´»åŠ¨çŠ¶æ€
                if (bio.includes('å­¦è€…') || bio.includes('ç ”ç©¶') || bio.includes('ä¹¦')) {
                    return 'åœ¨ä¹¦æˆ¿ç ”è¯»å…¸ç±';
                } else if (bio.includes('æˆ˜å£«') || bio.includes('å‰‘') || bio.includes('æˆ˜æ–—')) {
                    return 'åœ¨è®­ç»ƒåœºç»ƒä¹ ';
                } else if (bio.includes('åŒ»ç”Ÿ') || bio.includes('æ²»ç–—')) {
                    return 'åœ¨è¯Šæ‰€æ•´ç†è¯å“';
                } else if (bio.includes('å•†äºº') || bio.includes('ä¹°å–')) {
                    return 'åœ¨åº—é“ºå¿™ç¢Œ';
                } else if (bio.includes('è‰ºæœ¯') || bio.includes('ç”»') || bio.includes('éŸ³ä¹')) {
                    return 'åœ¨å·¥ä½œå®¤åˆ›ä½œ';
                } else if (bio.includes('å¨') || bio.includes('æ–™ç†')) {
                    return 'åœ¨å¨æˆ¿å‡†å¤‡é£Ÿæ';
                } else {
                    return 'åœ¨æˆ¿é—´é‡Œä¼‘æ¯';
                }
            } else {
                // åŸºäºäººè®¾å…³é”®è¯çš„å¿ƒæƒ…çŠ¶æ€
                if (bio.includes('å¼€æœ—') || bio.includes('æ´»æ³¼') || bio.includes('ä¹è§‚')) {
                    return 'å¿ƒæƒ…æ„‰æ‚¦';
                } else if (bio.includes('å†·é™') || bio.includes('ç†æ€§') || bio.includes('æ²‰ç€')) {
                    return 'å†…å¿ƒå¹³é™';
                } else if (bio.includes('ä¸¥è‚ƒ') || bio.includes('è®¤çœŸ')) {
                    return 'ä¸“æ³¨æ€è€ƒä¸­';
                } else if (bio.includes('æ¸©æŸ”') || bio.includes('å–„è‰¯')) {
                    return 'å¿ƒå¢ƒæ¸©å’Œ';
                } else if (bio.includes('ç¥ç§˜') || bio.includes('æ·±æ²‰')) {
                    return 'è‹¥æœ‰æ‰€æ€';
                } else {
                    return 'çŠ¶æ€è‰¯å¥½';
                }
            }
        }

        // ğŸ”¥ã€ä¿®å¤ã€‘çŠ¶æ€æ›´æ–°å®šæ—¶å™¨ç®¡ç†
        let characterStatusTimer = null;
        
        // è·å–çŠ¶æ€æ›´æ–°é—´éš”æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
        function getStatusUpdateInterval() {
            // ğŸ”¥ã€ä¿®å¤ã€‘ä»localStorageè·å–å…¨å±€çŠ¶æ€æ›´æ–°é¢‘ç‡è®¾ç½®
            let frequency = 'medium'; // é»˜è®¤ä¸­é¢‘

            try {
                // å°è¯•ä»localStorageè·å–å…¨å±€è®¾ç½®
                const globalSettings = localStorage.getItem('globalStatusUpdateFrequency');
                if (globalSettings) {
                    frequency = globalSettings;
                } else {
                    // å¦‚æœæ²¡æœ‰å…¨å±€è®¾ç½®ï¼Œå°è¯•ä»å½“å‰è§’è‰²è®¾ç½®ä¸­è·å–
                    if (currentChatCharacter) {
                        const chatSettings = getCurrentChatSettings();
                        frequency = chatSettings.statusUpdateFrequency || 'medium';
                        // ä¿å­˜ä¸ºå…¨å±€è®¾ç½®
                        localStorage.setItem('globalStatusUpdateFrequency', frequency);
                    }
                }
            } catch (error) {
                console.warn('è·å–çŠ¶æ€æ›´æ–°é¢‘ç‡è®¾ç½®å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼:', error);
            }

            // ğŸ”¥ã€ä¿®å¤ã€‘å°†é¢‘ç‡è½¬æ¢ä¸ºæ¯«ç§’é—´éš” - ä¿®æ­£é«˜é¢‘ä¸º30ç§’
            const intervals = {
                'high': 30000,      // 30ç§’ï¼ˆç›®å‰é¢‘ç‡ï¼‰
                'medium-high': 60000, // 1åˆ†é’Ÿ
                'medium': 180000,   // 3åˆ†é’Ÿ
                'medium-low': 300000, // 5åˆ†é’Ÿ
                'low': 600000       // 10åˆ†é’Ÿ
            };

            return intervals[frequency] || intervals['medium'];
        }
        
        // æ¸…é™¤çŠ¶æ€æ›´æ–°å®šæ—¶å™¨
        function clearCharacterStatusTimer() {
            if (characterStatusTimer) {
                clearInterval(characterStatusTimer);
                characterStatusTimer = null;
                console.log('è§’è‰²çŠ¶æ€æ›´æ–°å®šæ—¶å™¨å·²æ¸…é™¤');
            }
        }
        
        // å¯åŠ¨çŠ¶æ€æ›´æ–°å®šæ—¶å™¨
        async function startCharacterStatusTimer() {
            clearCharacterStatusTimer(); // å…ˆæ¸…é™¤ç°æœ‰å®šæ—¶å™¨

            // ğŸ”¥ã€ä¼˜åŒ–ã€‘é¦–å…ˆæ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•è§’è‰²å¯ç”¨äº†çŠ¶æ€æ˜¾ç¤º
            let hasStatusEnabled = false;
            for (const character of characters) {
                if (contacts.includes(character.id)) {
                    const chatSettings = await getAsyncChatSettings(character.id);
                    if (chatSettings.characterStatusEnabled) {
                        hasStatusEnabled = true;
                        break;
                    }
                }
            }

            // å¦‚æœæ²¡æœ‰ä»»ä½•è§’è‰²å¯ç”¨çŠ¶æ€æ˜¾ç¤ºï¼Œä¸å¯åŠ¨å®šæ—¶å™¨
            if (!hasStatusEnabled) {
                console.log('æ²¡æœ‰è§’è‰²å¯ç”¨çŠ¶æ€æ˜¾ç¤ºï¼Œè·³è¿‡å¯åŠ¨çŠ¶æ€æ›´æ–°å®šæ—¶å™¨');
                return;
            }

            const interval = getStatusUpdateInterval();
            console.log('å¯åŠ¨è§’è‰²çŠ¶æ€æ›´æ–°å®šæ—¶å™¨ï¼Œé—´éš”:', interval / 1000, 'ç§’');

            characterStatusTimer = setInterval(async () => {
                // æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•è§’è‰²å¯ç”¨äº†çŠ¶æ€æ˜¾ç¤º
                let hasStatusEnabled = false;

                for (const character of characters) {
                    if (contacts.includes(character.id)) {
                        // æ£€æŸ¥è¯¥è§’è‰²çš„èŠå¤©è®¾ç½®ä¸­æ˜¯å¦å¯ç”¨äº†çŠ¶æ€æ˜¾ç¤º
                        const chatSettings = await getAsyncChatSettings(character.id);
                        if (chatSettings.characterStatusEnabled) {
                            hasStatusEnabled = true;

                            // æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°çŠ¶æ€
                            const shouldUpdate = await shouldUpdateCharacterStatus(character.id);
                            if (shouldUpdate) {
                                await generateCharacterStatus(character.id);
                            }
                        }
                    }
                }

                // å¦‚æœæ²¡æœ‰ä»»ä½•è§’è‰²å¯ç”¨çŠ¶æ€æ˜¾ç¤ºï¼Œåœæ­¢å®šæ—¶å™¨
                if (!hasStatusEnabled) {
                    console.log('æ²¡æœ‰è§’è‰²å¯ç”¨çŠ¶æ€æ˜¾ç¤ºï¼Œåœæ­¢çŠ¶æ€æ›´æ–°å®šæ—¶å™¨');
                    clearCharacterStatusTimer();
                    return;
                }
                
                // åˆ·æ–°å½“å‰æ˜¾ç¤ºçš„çŠ¶æ€ï¼ˆä»…å½“å½“å‰è§’è‰²å¯ç”¨äº†çŠ¶æ€æ˜¾ç¤ºæ—¶ï¼‰
                if (currentChatCharacter) {
                    const currentChatSettings = getCurrentChatSettings();
                    if (currentChatSettings.characterStatusEnabled) {
                        const headerContainer = document.querySelector('#api-chat-screen .header');
                        if (headerContainer) {
                            renderCharacterStatus(currentChatCharacter.id, headerContainer);
                        }
                    }
                }
            }, interval);
        }
        
        // é‡å¯çŠ¶æ€æ›´æ–°å®šæ—¶å™¨
        function restartCharacterStatusTimer() {
            console.log('é‡å¯è§’è‰²çŠ¶æ€æ›´æ–°å®šæ—¶å™¨');
            startCharacterStatusTimer();
        }
        
        // å‘åå…¼å®¹çš„å‡½æ•°å
        function startStatusUpdateTimer() {
            startCharacterStatusTimer();
        }

        // ================== å…¨å±€è®°å¿†ç³»ç»Ÿ ==================

        // å…¨å±€è®°å¿†æ•°æ®åº“ç»“æ„
        let globalMemoryDB = null;

        // åˆå§‹åŒ–å…¨å±€è®°å¿†æ•°æ®åº“
        async function initGlobalMemoryDB() {
            try {
                // æ‰©å±•ç°æœ‰æ•°æ®åº“ï¼Œæ·»åŠ è®°å¿†ç›¸å…³è¡¨
                if (!db.memorySummaries) {
                    // æƒ…æ™¯è®°å¿†è¡¨ - å­˜å‚¨AIç”Ÿæˆçš„æ—¥è®°æ‘˜è¦
                    db.memorySummaries = db.table('memorySummaries', '++id, characterId, date, summary, context, importance, timestamp');
                }

                if (!db.coreMemories) {
                    // æ ¸å¿ƒè®°å¿†è¡¨ - å­˜å‚¨æ°¸ä¹…é‡è¦ä¿¡æ¯
                    db.coreMemories = db.table('coreMemories', '++id, characterId, fact, category, importance, timestamp, lastAccessed');
                }

                if (!db.memoryEvents) {
                    // ç»Ÿä¸€äº‹ä»¶è¡¨ - è®°å½•æ‰€æœ‰è·¨åœºæ™¯äº‹ä»¶
                    db.memoryEvents = db.table('memoryEvents', '++id, timestamp, characterIds, context, eventType, eventData, importance');
                }

                console.log('âœ… å…¨å±€è®°å¿†æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ');
            } catch (error) {
                console.error('âŒ å…¨å±€è®°å¿†æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥:', error);
            }
        }

        // è®°å½•ç»Ÿä¸€äº‹ä»¶
        async function recordMemoryEvent(characterIds, context, eventType, eventData, importance = 0.5) {
            try {
                // ğŸ”¥ã€ä¿®å¤ã€‘ç¡®ä¿æ‰€æœ‰å‚æ•°éƒ½æ˜¯æœ‰æ•ˆçš„
                if (!characterIds || !eventType || !eventData) {
                    console.warn('âŒ recordMemoryEvent: ç¼ºå°‘å¿…éœ€å‚æ•°', { characterIds, eventType, eventData });
                    return;
                }

                const event = {
                    id: `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, // ğŸ”¥ã€ä¿®å¤ã€‘æä¾›å”¯ä¸€ID
                    timestamp: Date.now(),
                    characterIds: Array.isArray(characterIds) ? characterIds : [characterIds],
                    context: context || { type: 'unknown', id: 'unknown' }, // ğŸ”¥ã€ä¿®å¤ã€‘æä¾›é»˜è®¤context
                    eventType: eventType, // 'message', 'activity_start', 'group_create' ç­‰
                    eventData: eventData,
                    importance: importance || 0.5
                };

                // ğŸ”¥ã€ä¿®å¤ã€‘ç¡®ä¿eventDataæ˜¯å¯åºåˆ—åŒ–çš„å¯¹è±¡
                if (typeof event.eventData === 'object' && event.eventData !== null) {
                    try {
                        JSON.stringify(event.eventData);
                    } catch (e) {
                        console.warn('âŒ eventDataä¸å¯åºåˆ—åŒ–ï¼Œè½¬æ¢ä¸ºå­—ç¬¦ä¸²:', event.eventData);
                        event.eventData = String(event.eventData);
                    }
                }

                await db.memoryEvents.add(event);
                console.log('ğŸ“ è®°å½•äº‹ä»¶:', eventType, characterIds);
            } catch (error) {
                console.error('âŒ è®°å½•äº‹ä»¶å¤±è´¥:', error);
                console.error('âŒ äº‹ä»¶æ•°æ®:', { characterIds, context, eventType, eventData, importance });
            }
        }

        // æ·»åŠ æ ¸å¿ƒè®°å¿†
        async function addCoreMemory(characterId, fact, category = 'general', importance = 0.8) {
            try {
                const coreMemory = {
                    characterId: characterId,
                    fact: fact,
                    category: category, // 'personality', 'relationship', 'preference', 'general'
                    importance: importance,
                    timestamp: Date.now(),
                    lastAccessed: Date.now()
                };

                await db.coreMemories.add(coreMemory);
                console.log('ğŸ§  æ·»åŠ æ ¸å¿ƒè®°å¿†:', fact);
            } catch (error) {
                console.error('âŒ æ·»åŠ æ ¸å¿ƒè®°å¿†å¤±è´¥:', error);
            }
        }

        // ç”Ÿæˆæƒ…æ™¯è®°å¿†æ‘˜è¦
        async function generateMemorySummary(characterId, startTime, endTime, context) {
            try {
                // ğŸ”¥ã€ä¿®å¤ã€‘è·å–æ—¶é—´æ®µå†…çš„è·¨åº”ç”¨æ—¶é—´çº¿äº‹ä»¶ï¼ˆåŒ…æ‹¬èŠå¤©è®°å½•ï¼‰
                const timelineEvents = await db.crossAppTimeline
                    .where('characterId')
                    .equals(characterId)
                    .and(event => event.timestamp >= startTime && event.timestamp < endTime)
                    .toArray();

                // ğŸ”¥ã€ä¿®å¤ã€‘åŒæ—¶è·å–èŠå¤©æ¶ˆæ¯
                const characterMessages = chatMessages[characterId] || [];
                const todayMessages = characterMessages.filter(msg =>
                    msg.timestamp >= startTime && msg.timestamp < endTime
                );

                if (timelineEvents.length === 0 && todayMessages.length === 0) {
                    console.log('ä»Šå¤©æš‚æ— æ´»åŠ¨è®°å½•');
                    return null;
                }

                // ğŸ”¥ã€ä¿®å¤ã€‘æ„å»ºæ›´å…¨é¢çš„æ´»åŠ¨è®°å½•
                let eventsText = '';

                // æ·»åŠ èŠå¤©è®°å½•
                if (todayMessages.length > 0) {
                    eventsText += 'èŠå¤©è®°å½•ï¼š\n';
                    todayMessages.forEach(msg => {
                        const timeStr = new Date(msg.timestamp).toLocaleTimeString();
                        const role = msg.role === 'user' ? 'ç”¨æˆ·' : character.name;
                        eventsText += `[${timeStr}] ${role}: ${msg.content}\n`;
                    });
                }

                // æ·»åŠ è·¨åº”ç”¨äº‹ä»¶
                if (timelineEvents.length > 0) {
                    eventsText += '\nå…¶ä»–æ´»åŠ¨ï¼š\n';
                    timelineEvents.forEach(event => {
                        const timeStr = new Date(event.timestamp).toLocaleTimeString();
                        const actionDesc = getActionDescription(event.action, event.context);
                        eventsText += `[${timeStr}] ${actionDesc}\n`;
                    });
                }

                const character = characters.find(c => c.id === characterId);
                const summaryPrompt = `è¯·ä¸º${character.name}ä»Šå¤©çš„æ´»åŠ¨å†™ä¸€ä»½ç®€çŸ­çš„è®°å¿†æ‘˜è¦ï¼ˆ50-100å­—ï¼‰ï¼š

æ—¶é—´æ®µï¼š${new Date(startTime).toLocaleString()} - ${new Date(endTime).toLocaleString()}
ä»Šæ—¥æ´»åŠ¨ï¼š
${eventsText}

è¯·ç”¨ç¬¬ä¸‰äººç§°å†™ä¸€ä»½ç®€æ´çš„è®°å¿†æ‘˜è¦ï¼Œé‡ç‚¹è®°å½•é‡è¦çš„äº‹ä»¶å’Œæ„Ÿå—ã€‚ä½¿ç”¨"ç”¨æˆ·"æŒ‡ä»£ç”¨æˆ·ï¼Œä½¿ç”¨"${character.name}"æŒ‡ä»£è§’è‰²ï¼Œä¸è¦ä½¿ç”¨"æˆ‘"ã€"ä½ "ç­‰ç¬¬ä¸€ã€ç¬¬äºŒäººç§°ï¼š`;

                // è°ƒç”¨AIç”Ÿæˆæ‘˜è¦
                const response = await callChatAPI(summaryPrompt, character);

                if (response && response.trim()) {
                    const summary = {
                        characterId: characterId,
                        date: new Date(startTime).toISOString().split('T')[0],
                        summary: response.trim(),
                        context: context,
                        importance: calculateSummaryImportance(timelineEvents.concat(todayMessages)),
                        timestamp: Date.now()
                    };

                    await db.memorySummaries.add(summary);
                    console.log('ğŸ“– ç”Ÿæˆè®°å¿†æ‘˜è¦:', summary.summary);
                    return summary;
                }
            } catch (error) {
                console.error('âŒ ç”Ÿæˆè®°å¿†æ‘˜è¦å¤±è´¥:', error);
            }
            return null;
        }

        // ğŸ”¥ã€æ–°å¢ã€‘è·å–åŠ¨ä½œæè¿°çš„è¾…åŠ©å‡½æ•°
        function getActionDescription(action, context) {
            const actionMap = {
                'user_message': 'æ”¶åˆ°ç”¨æˆ·æ¶ˆæ¯',
                'ai_reply': 'å›å¤äº†æ¶ˆæ¯',
                'moment_publish': 'å‘å¸ƒäº†åŠ¨æ€',
                'moment_comment': 'è¯„è®ºäº†åŠ¨æ€',
                'game_start': 'å¼€å§‹æ¸¸æˆ',
                'game_end': 'ç»“æŸæ¸¸æˆ'
            };

            const baseDesc = actionMap[action] || action;
            if (context && context.content) {
                return `${baseDesc}: ${context.content.substring(0, 30)}...`;
            }
            return baseDesc;
        }

        // è®¡ç®—æ‘˜è¦é‡è¦æ€§
        function calculateSummaryImportance(events) {
            if (!events || events.length === 0) return 0.3;

            // ğŸ”¥ã€ä¿®å¤ã€‘é€‚é…ä¸åŒç±»å‹çš„äº‹ä»¶æ•°æ®
            let totalImportance = 0;
            let validEvents = 0;

            events.forEach(event => {
                if (event.importance !== undefined) {
                    totalImportance += event.importance;
                    validEvents++;
                } else {
                    // å¯¹äºèŠå¤©æ¶ˆæ¯ï¼Œç»™äºˆåŸºç¡€é‡è¦æ€§
                    totalImportance += 0.6;
                    validEvents++;
                }
            });

            const avgImportance = validEvents > 0 ? totalImportance / validEvents : 0.5;
            const eventCount = events.length;

            // äº‹ä»¶æ•°é‡å’Œå¹³å‡é‡è¦æ€§çš„ç»¼åˆè¯„åˆ†
            return Math.min(0.9, avgImportance + (eventCount * 0.02));
        }

        // æ™ºèƒ½è®°å¿†æ£€ç´¢ç³»ç»Ÿ
        async function buildGlobalMemoryContext(characterId, currentContext, memoryDays = 7) {
            try {
                let memoryContext = '';

                // ğŸ”¥ã€ä¿®å¤ã€‘æ£€æŸ¥æ˜¯å¦å¯ç”¨è®°å¿†å…±äº« - éœ€è¦è·å–è§’è‰²çš„å•èŠè®¾ç½®
                let sharedGroupIds = [];
                let contextIds = [currentContext.id]; // å½“å‰èŠå¤©çª—å£

                // å¦‚æœå½“å‰åœ¨ç¾¤èŠä¸­ï¼Œéœ€è¦æ£€æŸ¥è¯¥è§’è‰²åœ¨å•èŠä¸­æ˜¯å¦è®¾ç½®äº†è®°å¿†å…±äº«
                if (currentContext.type === 'group_chat') {
                    try {
                        // è·å–è¯¥è§’è‰²çš„å•èŠè®¾ç½®ï¼ˆè§’è‰²IDå°±æ˜¯å•èŠIDï¼‰
                        const characterChatSettings = await getAsyncChatSettings(characterId);
                        sharedGroupIds = characterChatSettings.memorySharedGroupIds || [];

                        // ğŸ”¥ã€è°ƒè¯•ã€‘è¾“å‡ºè¯¦ç»†çš„è®°å¿†å…±äº«æ£€æŸ¥ä¿¡æ¯
                        console.log(`ğŸ” è®°å¿†å…±äº«æ£€æŸ¥ - è§’è‰²: ${characterId}`);
                        console.log(`ğŸ” å½“å‰ç¾¤èŠID: ${currentContext.id}`);
                        console.log(`ğŸ” è§’è‰²è®¾ç½®çš„å…±äº«ç¾¤èŠIDs: ${sharedGroupIds}`);
                        console.log(`ğŸ” æ˜¯å¦åŒ¹é…: ${sharedGroupIds.includes(currentContext.id)}`);

                        // å¦‚æœè§’è‰²è®¾ç½®äº†ä¸å½“å‰ç¾¤èŠå…±äº«è®°å¿†ï¼Œåˆ™åŒ…å«ç§èŠè®°å¿†
                        if (sharedGroupIds.includes(currentContext.id)) {
                            contextIds.push(characterId); // ç§èŠçš„IDå°±æ˜¯è§’è‰²ID
                            console.log('ğŸ”— åœ¨å…±äº«ç¾¤èŠä¸­ï¼ŒåŒ…å«è§’è‰²ç§èŠè®°å¿†:', characterId);
                        } else {
                            console.log('âŒ è®°å¿†å…±äº«æœªå¯ç”¨æˆ–ç¾¤èŠä¸åŒ¹é…ï¼Œåªä½¿ç”¨ç¾¤èŠè®°å¿†');
                        }
                    } catch (error) {
                        console.warn('è·å–è§’è‰²å•èŠè®¾ç½®å¤±è´¥:', error);
                    }
                } else if (currentContext.type === 'private_chat') {
                    // å¦‚æœåœ¨ç§èŠä¸­ï¼Œä½¿ç”¨å½“å‰èŠå¤©è®¾ç½®
                    const chatSettings = getCurrentChatSettings();
                    sharedGroupIds = chatSettings.memorySharedGroupIds || [];

                    // å¦‚æœå¯ç”¨äº†è®°å¿†å…±äº«ï¼Œæ·»åŠ æ‰€æœ‰å…±äº«çš„ç¾¤èŠID
                    if (sharedGroupIds.length > 0) {
                        contextIds.push(...sharedGroupIds);
                        console.log('ğŸ”— å¯ç”¨è®°å¿†å…±äº«ï¼ŒåŒ…å«ç¾¤èŠ:', sharedGroupIds);
                    }
                }

                // 1. æ£€ç´¢æ ¸å¿ƒè®°å¿† - ğŸ”¥ã€ä¿®å¤ã€‘æ·»åŠ ä¸Šä¸‹æ–‡è¿‡æ»¤
                let coreMemories = [];
                for (const contextId of contextIds) {
                    const contextCoreMemories = await db.coreMemories
                        .where('characterId')
                        .equals(characterId)
                        .and(memory => {
                            // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘æŒ‰ä¸Šä¸‹æ–‡è¿‡æ»¤æ ¸å¿ƒè®°å¿†
                            if (!memory.contextId) return true; // å…¼å®¹æ—§æ•°æ®
                            return memory.contextId === contextId;
                        })
                        .toArray();
                    coreMemories = coreMemories.concat(contextCoreMemories);
                }

                // æ‰‹åŠ¨æ’åºå¹¶é™åˆ¶æ•°é‡
                coreMemories.sort((a, b) => (b.importance || 0) - (a.importance || 0));
                const limitedCoreMemories = coreMemories.slice(0, 10);

                if (limitedCoreMemories.length > 0) {
                    memoryContext += '\n# æ ¸å¿ƒè®°å¿†\n';
                    limitedCoreMemories.forEach(memory => {
                        memoryContext += `- ${memory.fact}\n`;
                    });
                }

                // 2. æ£€ç´¢æƒ…æ™¯è®°å¿†ï¼ˆæœ€è¿‘Nå¤©ï¼‰- ğŸ”¥ã€ä¿®å¤ã€‘æ·»åŠ ä¸Šä¸‹æ–‡è¿‡æ»¤
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - memoryDays);
                const cutoffTimestamp = cutoffDate.getTime();

                let episodicMemories = [];
                for (const contextId of contextIds) {
                    const contextEpisodicMemories = await db.episodicMemories
                        .where('characterId')
                        .equals(characterId)
                        .and(memory => {
                            if (memory.timestamp < cutoffTimestamp) return false;
                            // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘æŒ‰ä¸Šä¸‹æ–‡è¿‡æ»¤æƒ…æ™¯è®°å¿†
                            if (!memory.contextId) return true; // å…¼å®¹æ—§æ•°æ®
                            return memory.contextId === contextId;
                        })
                        .toArray();
                    episodicMemories = episodicMemories.concat(contextEpisodicMemories);
                }

                // æ‰‹åŠ¨æ’åºå¹¶é™åˆ¶æ•°é‡
                episodicMemories.sort((a, b) => b.timestamp - a.timestamp);
                const limitedEpisodicMemories = episodicMemories.slice(0, 15);

                if (limitedEpisodicMemories.length > 0) {
                    memoryContext += '\n# æƒ…æ™¯è®°å¿†\n';
                    limitedEpisodicMemories.forEach(memory => {
                        const dateObj = new Date(memory.timestamp || Date.now());
                        const date = isNaN(dateObj.getTime()) ? 'æœªçŸ¥æ—¥æœŸ' : dateObj.toLocaleDateString();
                        memoryContext += `[${date}] ${memory.fact}\n`;
                    });
                }

                // 3. æ£€ç´¢è·¨åº”ç”¨æ—¶é—´çº¿è®°å¿†ï¼ˆæ”¯æŒè®°å¿†å…±äº«ï¼‰
                const timelineCutoff = Date.now() - (memoryDays * 24 * 60 * 60 * 1000);
                let timelineMemories = [];

                for (const contextId of contextIds) {
                    const contextTimeline = await db.crossAppTimeline
                        .where('characterId')
                        .equals(characterId)
                        .and(event => {
                            if (event.timestamp < timelineCutoff) return false;
                            if (!event.context) return false;

                            // ğŸ”¥ã€ä¿®å¤ã€‘çº¿ä¸‹æ¨¡å¼å‰§æƒ…æ€»ç»“ä¹Ÿåº”è¯¥è¢«åŒ…å«
                            if (event.appType === 'offline_mode' && event.action === 'storyline_summary') {
                                return true; // çº¿ä¸‹æ¨¡å¼å‰§æƒ…æ€»ç»“å¯¹æ‰€æœ‰ä¸Šä¸‹æ–‡éƒ½å¯è§
                            }

                            // æ£€æŸ¥ä¸Šä¸‹æ–‡IDåŒ¹é…
                            return event.context.id === contextId ||
                                   (event.context.chatId === contextId) ||
                                   (event.context.groupId === contextId);
                        })
                        .toArray();
                    timelineMemories = timelineMemories.concat(contextTimeline);
                }

                // å»é‡å¹¶æ’åº
                const uniqueTimelineMemories = timelineMemories.filter((memory, index, self) =>
                    index === self.findIndex(m => m.id === memory.id));
                uniqueTimelineMemories.sort((a, b) => b.timestamp - a.timestamp);
                const limitedTimelineMemories = uniqueTimelineMemories.slice(0, 20);

                if (limitedTimelineMemories.length > 0) {
                    memoryContext += '\n# æœ€è¿‘æ´»åŠ¨æ—¶é—´çº¿\n';
                    limitedTimelineMemories.forEach(memory => {
                        const time = new Date(memory.timestamp).toLocaleString();
                        let contextInfo = 'ç§èŠ';
                        if (memory.context?.type === 'group_chat') {
                            contextInfo = 'ç¾¤èŠ';
                        } else if (memory.appType === 'offline_mode') {
                            contextInfo = 'çº¿ä¸‹æ¨¡å¼';
                        }

                        // æ„å»ºæ›´æœ‰æ„ä¹‰çš„äº‹ä»¶æè¿°
                        let eventDescription = '';
                        if (memory.action === 'user_message') {
                            if (memory.context?.content) {
                                eventDescription = `ç”¨æˆ·è¯´: ${memory.context.content.substring(0, 50)}${memory.context.content.length > 50 ? '...' : ''}`;
                            } else {
                                eventDescription = `ç”¨æˆ·å‘é€äº†æ¶ˆæ¯`;
                            }
                        } else if (memory.action === 'ai_message' && memory.context?.content) {
                            eventDescription = `AIå›å¤: ${memory.context.content.substring(0, 50)}${memory.context.content.length > 50 ? '...' : ''}`;
                        } else if (memory.action === 'ai_reply' && memory.context?.content) {
                            eventDescription = `AIå›å¤: ${memory.context.content.substring(0, 50)}${memory.context.content.length > 50 ? '...' : ''}`;
                        } else if (memory.action === 'storyline_summary' && memory.appType === 'offline_mode') {
                            // ğŸ”¥ã€æ–°å¢ã€‘çº¿ä¸‹æ¨¡å¼å‰§æƒ…æ€»ç»“çš„ç‰¹æ®Šæ˜¾ç¤º
                            if (memory.context?.content) {
                                eventDescription = `${memory.context.content.substring(0, 100)}${memory.context.content.length > 100 ? '...' : ''}`;
                            } else {
                                eventDescription = 'çº¿ä¸‹å‰§æƒ…æ¨¡å¼æ€»ç»“';
                            }
                            // ğŸ”¥ã€æ–°å¢ã€‘ä¸ºå‰§æƒ…æ€»ç»“æ·»åŠ ç¼–è¾‘æŒ‰é’®
                            actionButtons = `
                                <button class="memory-action-btn edit-btn" onclick="editStorylineSummary('${memory.id}')" title="ç¼–è¾‘å‰§æƒ…æ€»ç»“">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button class="memory-action-btn view-btn" onclick="viewStorylineSummary('${memory.id}')" title="æŸ¥çœ‹å®Œæ•´å†…å®¹">
                                    <i class="fas fa-eye"></i>
                                </button>
                            `;
                        } else {
                            eventDescription = memory.action || memory.eventType || 'æœªçŸ¥æ´»åŠ¨';
                        }



                        memoryContext += `[${time}] åœ¨${contextInfo}ä¸­: ${eventDescription}\n`;
                    });
                }

                // 4. æ£€ç´¢è®°å¿†æ‘˜è¦ï¼ˆæœ€è¿‘Nå¤©çš„æ‘˜è¦ï¼‰
                const cutoffDateStr = cutoffDate.toISOString().split('T')[0];

                const memorySummaries = await db.memorySummaries
                    .where('characterId')
                    .equals(characterId)
                    .and(summary => summary.date >= cutoffDateStr)
                    .toArray();

                // æ‰‹åŠ¨æ’åºå¹¶é™åˆ¶æ•°é‡
                memorySummaries.sort((a, b) => b.timestamp - a.timestamp);
                const limitedMemorySummaries = memorySummaries.slice(0, 10);

                if (limitedMemorySummaries.length > 0) {
                    memoryContext += '\n# å¯¹è¯æ‘˜è¦\n';
                    limitedMemorySummaries.forEach(summary => {
                        const dateObj = new Date(summary.timestamp || Date.now());
                        const date = isNaN(dateObj.getTime()) ? 'æœªçŸ¥æ—¥æœŸ' : dateObj.toLocaleDateString();
                        memoryContext += `[${date}] ${summary.summary}\n`;
                    });
                }

                // 3. æ£€ç´¢è·¨åœºæ™¯ç›¸å…³äº‹ä»¶ï¼ˆæ”¯æŒè®°å¿†å…±äº«ï¼‰
                const recentEvents = await db.memoryEvents
                    .where('timestamp')
                    .above(Date.now() - (24 * 60 * 60 * 1000)) // æœ€è¿‘24å°æ—¶
                    .and(event => {
                        // æ£€æŸ¥äº‹ä»¶æ˜¯å¦ä¸å½“å‰è§’è‰²ç›¸å…³ï¼Œä¸”å‘ç”Ÿåœ¨ç›¸å…³çš„èŠå¤©çª—å£ä¸­
                        return event.characterIds.includes(characterId) &&
                               contextIds.includes(event.context.id);
                    })
                    .toArray();

                // æ‰‹åŠ¨æ’åºå¹¶é™åˆ¶æ•°é‡
                recentEvents.sort((a, b) => b.timestamp - a.timestamp);
                const limitedRecentEvents = recentEvents.slice(0, 15);

                if (limitedRecentEvents.length > 0) {
                    memoryContext += '\n# æœ€è¿‘æ´»åŠ¨\n';
                    limitedRecentEvents.forEach(event => {
                        const time = new Date(event.timestamp).toLocaleTimeString();
                        const contextInfo = event.context.type === 'private_chat' ? 'ç§èŠ' :
                                          event.context.type === 'group_chat' ? 'ç¾¤èŠ' :
                                          event.context.type === 'music_app' ? 'éŸ³ä¹' : 'å…¶ä»–';

                        // å¦‚æœæ˜¯è·¨åœºæ™¯çš„äº‹ä»¶ï¼Œæ ‡æ˜æ¥æº
                        const sourceInfo = event.context.id !== currentContext.id ? ` (æ¥è‡ª${contextInfo})` : '';
                        memoryContext += `[${time}] åœ¨${contextInfo}ä¸­${sourceInfo}: ${event.eventType}\n`;
                    });
                }

                return memoryContext;
            } catch (error) {
                console.error('âŒ æ„å»ºå…¨å±€è®°å¿†ä¸Šä¸‹æ–‡å¤±è´¥:', error);
                return '';
            }
        }

        // è®°å¿†è®¾ç½®ç®¡ç†
        function showGlobalMemorySettings() {
            if (!currentChatCharacter) {
                showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè§’è‰²', 'error');
                return;
            }

            // åˆ›å»ºè®°å¿†è®¾ç½®æ¨¡æ€æ¡†
            const modalHTML = `
                <div id="global-memory-modal" class="modal phone-modal" style="display: block;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 class="modal-title">å…¨å±€è®°å¿†è®¾ç½®</h3>
                            <button class="modal-close" onclick="hideGlobalMemorySettings()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="setting-section">
                                <h4>è®°å¿†ä¿ç•™æœŸé™</h4>
                                <div class="radio-group">
                                    <label class="radio-option">
                                        <input type="radio" name="memoryDays" value="3">
                                        <span class="radio-custom"></span>
                                        <div class="radio-content">
                                            <div class="radio-title">3å¤©è®°å¿†</div>
                                            <div class="radio-desc">ä¿ç•™æœ€è¿‘3å¤©çš„æƒ…æ™¯è®°å¿†</div>
                                        </div>
                                    </label>
                                    <label class="radio-option">
                                        <input type="radio" name="memoryDays" value="7" checked>
                                        <span class="radio-custom"></span>
                                        <div class="radio-content">
                                            <div class="radio-title">7å¤©è®°å¿†</div>
                                            <div class="radio-desc">ä¿ç•™æœ€è¿‘7å¤©çš„æƒ…æ™¯è®°å¿†ï¼ˆæ¨èï¼‰</div>
                                        </div>
                                    </label>
                                    <label class="radio-option">
                                        <input type="radio" name="memoryDays" value="15">
                                        <span class="radio-custom"></span>
                                        <div class="radio-content">
                                            <div class="radio-title">15å¤©è®°å¿†</div>
                                            <div class="radio-desc">ä¿ç•™æœ€è¿‘15å¤©çš„æƒ…æ™¯è®°å¿†</div>
                                        </div>
                                    </label>
                                    <label class="radio-option">
                                        <input type="radio" name="memoryDays" value="30">
                                        <span class="radio-custom"></span>
                                        <div class="radio-content">
                                            <div class="radio-title">30å¤©è®°å¿†</div>
                                            <div class="radio-desc">ä¿ç•™æœ€è¿‘30å¤©çš„æƒ…æ™¯è®°å¿†</div>
                                        </div>
                                    </label>
                                </div>
                            </div>

                            <div class="setting-section">
                                <h4>è®°å¿†ç®¡ç†</h4>
                                <div class="memory-management-grid">
                                    <button class="memory-action-btn primary" onclick="viewCoreMemories()">
                                        <div class="btn-icon">ğŸ”´</div>
                                        <div class="btn-content">
                                            <div class="btn-title">æŸ¥çœ‹æ ¸å¿ƒè®°å¿†</div>
                                            <div class="btn-desc">æ°¸ä¹…é‡è¦ä¿¡æ¯</div>
                                        </div>
                                    </button>
                                    <button class="memory-action-btn secondary" onclick="viewMemorySummaries()">
                                        <div class="btn-icon">ğŸ“–</div>
                                        <div class="btn-content">
                                            <div class="btn-title">æŸ¥çœ‹è®°å¿†æ‘˜è¦</div>
                                            <div class="btn-desc">å¯¹è¯æ€»ç»“å›é¡¾</div>
                                        </div>
                                    </button>
                                    <button class="memory-action-btn accent" onclick="generateDailySummary()">
                                        <div class="btn-icon">âœ¨</div>
                                        <div class="btn-content">
                                            <div class="btn-title">ç”Ÿæˆä»Šæ—¥æ‘˜è¦</div>
                                            <div class="btn-desc">æ€»ç»“ä»Šå¤©æ´»åŠ¨</div>
                                        </div>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="modal-actions">
                            <button class="modal-button modal-secondary" onclick="hideGlobalMemorySettings()">å–æ¶ˆ</button>
                            <button class="modal-button modal-primary" onclick="saveGlobalMemorySettings()">ä¿å­˜è®¾ç½®</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHTML);

            // åŠ è½½å½“å‰è®¾ç½®
            const currentSettings = getGlobalMemorySettings();
            const radio = document.querySelector(`input[name="memoryDays"][value="${currentSettings.memoryDays}"]`);
            if (radio) radio.checked = true;
        }

        // è·å–å…¨å±€è®°å¿†è®¾ç½®
        function getGlobalMemorySettings() {
            const saved = localStorage.getItem('globalMemorySettings');
            return saved ? JSON.parse(saved) : {
                memoryDays: 7,
                autoSummary: true,
                coreMemoryEnabled: true
            };
        }

        // ä¿å­˜å…¨å±€è®°å¿†è®¾ç½®
        function saveGlobalMemorySettings() {
            const memoryDays = parseInt(document.querySelector('input[name="memoryDays"]:checked').value);

            const settings = {
                memoryDays: memoryDays,
                autoSummary: true,
                coreMemoryEnabled: true
            };

            localStorage.setItem('globalMemorySettings', JSON.stringify(settings));
            hideGlobalMemorySettings();
            showToast('å…¨å±€è®°å¿†è®¾ç½®å·²ä¿å­˜', 'success');
        }

        // éšè—å…¨å±€è®°å¿†è®¾ç½®
        function hideGlobalMemorySettings() {
            const modal = document.getElementById('global-memory-modal');
            if (modal) modal.remove();
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ˜¾ç¤ºè®°å¿†æ¨¡æ€æ¡†
        function showMemoryModal(title, memories, type) {
            // ç§»é™¤å·²å­˜åœ¨çš„æ¨¡æ€æ¡†
            const existingModal = document.getElementById('memory-view-modal');
            if (existingModal) existingModal.remove();

            let content = '';
            if (memories.length === 0) {
                content = `<div class="memory-empty">æš‚æ— ${title}</div>`;
            } else {
                content = memories.map((memory, index) => {
                    let displayContent = '';
                    let importance = '';
                    let date = '';

                    if (type === 'core') {
                        displayContent = memory.fact || 'æ— å†…å®¹';
                        const stars = 'â˜…'.repeat(Math.floor((memory.importance || 0) * 5));
                        importance = `<div class="memory-importance">${stars}</div>`;
                        const dateObj = new Date(memory.timestamp || Date.now());
                        date = isNaN(dateObj.getTime()) ? 'æœªçŸ¥æ—¥æœŸ' : dateObj.toLocaleDateString();
                    } else if (type === 'summary') {
                        displayContent = memory.summary || 'æ— å†…å®¹';
                        date = memory.date || 'æœªçŸ¥æ—¥æœŸ';
                    }

                    return `
                        <div class="memory-modal-item">
                            <div class="memory-modal-header">
                                <span class="memory-modal-index">${index + 1}</span>
                                <span class="memory-modal-date">${date}</span>
                            </div>
                            <div class="memory-modal-content">${displayContent}</div>
                            ${importance}
                        </div>
                    `;
                }).join('');
            }

            const modalHTML = `
                <div id="memory-view-modal" class="modal" style="display: flex;">
                    <div class="modal-content" style="max-width: 600px; max-height: 80vh;">
                        <div class="modal-header">
                            <h3>${currentChatCharacter.name} çš„${title}</h3>
                            <button class="modal-close" onclick="hideMemoryModal()">Ã—</button>
                        </div>
                        <div class="modal-body" style="max-height: 60vh; overflow-y: auto;">
                            ${content}
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        // éšè—è®°å¿†æ¨¡æ€æ¡†
        function hideMemoryModal() {
            const modal = document.getElementById('memory-view-modal');
            if (modal) modal.remove();
        }

        // æŸ¥çœ‹æ ¸å¿ƒè®°å¿†
        async function viewCoreMemories() {
            if (!currentChatCharacter) {
                showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè§’è‰²', 'error');
                return;
            }

            // ğŸ”¥ã€ä¿®å¤ã€‘è‡ªåŠ¨å…³é—­å…¨å±€è®°å¿†è®¾ç½®æ¨¡æ€æ¡†
            hideGlobalMemorySettings();

            try {
                const coreMemories = await db.coreMemories
                    .where('characterId')
                    .equals(currentChatCharacter.id)
                    .toArray();

                // æ‰‹åŠ¨æ’åºå¹¶é™åˆ¶æ•°é‡
                coreMemories.sort((a, b) => (b.importance || 0) - (a.importance || 0));
                const limitedMemories = coreMemories.slice(0, 10);

                showMemoryModal('æ ¸å¿ƒè®°å¿†', limitedMemories, 'core');
            } catch (error) {
                console.error('æŸ¥çœ‹æ ¸å¿ƒè®°å¿†å¤±è´¥:', error);
                showToast('æŸ¥çœ‹æ ¸å¿ƒè®°å¿†å¤±è´¥', 'error');
            }
        }

        // æŸ¥çœ‹è®°å¿†æ‘˜è¦
        async function viewMemorySummaries() {
            if (!currentChatCharacter) {
                showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè§’è‰²', 'error');
                return;
            }

            // ğŸ”¥ã€ä¿®å¤ã€‘è‡ªåŠ¨å…³é—­å…¨å±€è®°å¿†è®¾ç½®æ¨¡æ€æ¡†
            hideGlobalMemorySettings();

            try {
                const memorySummaries = await db.memorySummaries
                    .where('characterId')
                    .equals(currentChatCharacter.id)
                    .toArray();

                // æ‰‹åŠ¨æ’åºå¹¶é™åˆ¶æ•°é‡
                memorySummaries.sort((a, b) => b.timestamp - a.timestamp);
                const limitedSummaries = memorySummaries.slice(0, 10);

                showMemoryModal('è®°å¿†æ‘˜è¦', limitedSummaries, 'summary');
            } catch (error) {
                console.error('æŸ¥çœ‹è®°å¿†æ‘˜è¦å¤±è´¥:', error);
                showToast('æŸ¥çœ‹è®°å¿†æ‘˜è¦å¤±è´¥', 'error');
            }
        }

        // ç”Ÿæˆä»Šæ—¥æ‘˜è¦
        async function generateDailySummary() {
            if (!currentChatCharacter) {
                showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè§’è‰²', 'error');
                return;
            }

            try {
                const today = new Date();
                const startTime = new Date(today.getFullYear(), today.getMonth(), today.getDate()).getTime();
                const endTime = startTime + 24 * 60 * 60 * 1000;

                const summary = await generateMemorySummary(
                    currentChatCharacter.id,
                    startTime,
                    endTime,
                    {
                        type: currentChatCharacter.isGroup ? 'group_chat' : 'private_chat',
                        id: currentChatCharacter.id
                    }
                );

                if (summary) {
                    showToast('ä»Šæ—¥æ‘˜è¦ç”ŸæˆæˆåŠŸ', 'success');
                    alert(`ä»Šæ—¥æ‘˜è¦å·²ç”Ÿæˆï¼š\n\n${summary.summary}`);
                } else {
                    showToast('ä»Šå¤©æš‚æ— æ´»åŠ¨å¯ç”Ÿæˆæ‘˜è¦', 'warning');
                }
            } catch (error) {
                console.error('ç”Ÿæˆä»Šæ—¥æ‘˜è¦å¤±è´¥:', error);
                showToast('ç”Ÿæˆä»Šæ—¥æ‘˜è¦å¤±è´¥', 'error');
            }
        }

        // è®°å¿†å…±äº«è®¾ç½®
        function showMemoryShareSettings() {
            if (!currentChatCharacter || currentChatCharacter.isGroup) {
                showToast('æ­¤åŠŸèƒ½ä»…é€‚ç”¨äºå•èŠ', 'error');
                return;
            }

            // è·å–å½“å‰è§’è‰²å‚ä¸çš„æ‰€æœ‰ç¾¤èŠ
            const characterGroups = groupChats.filter(group =>
                group.members && group.members.some(member => member.id === currentChatCharacter.id)
            );

            if (characterGroups.length === 0) {
                showToast('è¯¥è§’è‰²è¿˜æ²¡æœ‰å‚ä¸ä»»ä½•ç¾¤èŠ', 'warning');
                return;
            }

            const chatSettings = getCurrentChatSettings();
            const currentSharedGroups = chatSettings.memorySharedGroupIds || [];

            const modalHTML = `
                <div id="memory-share-modal" class="modal phone-modal" style="display: block;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 class="modal-title">è®°å¿†å…±äº«è®¾ç½®</h3>
                            <button class="modal-close" onclick="hideMemoryShareSettings()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="setting-section">
                                <h4>é€‰æ‹©è¦å…±äº«è®°å¿†çš„ç¾¤èŠ</h4>
                                <div class="checkbox-group">
                                    ${characterGroups.map(group => `
                                        <label class="checkbox-option">
                                            <input type="checkbox" name="sharedGroups" value="${group.id}" ${currentSharedGroups.includes(group.id) ? 'checked' : ''}>
                                            <span class="checkbox-custom"></span>
                                            <div class="checkbox-content">
                                                <div class="checkbox-title">${group.name}</div>
                                                <div class="checkbox-desc">ä¸æ­¤ç¾¤èŠå…±äº«è®°å¿†</div>
                                            </div>
                                        </label>
                                    `).join('')}
                                </div>
                            </div>

                            <div class="setting-section">
                                <h4>åŠŸèƒ½è¯´æ˜</h4>
                                <div class="info-text">
                                    â€¢ å¼€å¯åï¼Œè§’è‰²åœ¨å•èŠä¸­èƒ½è®°ä½ç¾¤èŠçš„å†…å®¹<br>
                                    â€¢ è§’è‰²åœ¨ç¾¤èŠä¸­ä¹Ÿèƒ½è®°ä½å•èŠçš„å†…å®¹<br>
                                    â€¢ å®ç°çœŸæ­£çš„è·¨åœºæ™¯è®°å¿†è¿è´¯æ€§<br>
                                    â€¢ å¯ä»¥åŒæ—¶é€‰æ‹©å¤šä¸ªç¾¤èŠè¿›è¡Œè®°å¿†å…±äº«
                                </div>
                            </div>
                        </div>
                        <div class="modal-actions">
                            <button class="modal-button modal-secondary" onclick="hideMemoryShareSettings()">å–æ¶ˆ</button>
                            <button class="modal-button modal-primary" onclick="saveMemoryShareSettings()">ä¿å­˜è®¾ç½®</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        // ä¿å­˜è®°å¿†å…±äº«è®¾ç½®
        async function saveMemoryShareSettings() {
            const selectedGroups = Array.from(document.querySelectorAll('input[name="sharedGroups"]:checked'))
                .map(checkbox => checkbox.value);

            const chatSettings = getCurrentChatSettings();
            chatSettings.memorySharedGroupIds = selectedGroups;

            // ğŸ”¥ã€å…¼å®¹æ€§ã€‘ä¿ç•™æ—§çš„å•é€‰å­—æ®µï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªé€‰ä¸­çš„ç¾¤èŠ
            chatSettings.memorySharedGroupId = selectedGroups.length > 0 ? selectedGroups[0] : '';

            await saveChatSettings();

            // æ›´æ–°æ˜¾ç¤ºçŠ¶æ€
            updateMemoryShareStatus();

            hideMemoryShareSettings();

            if (selectedGroups.length > 0) {
                const groupNames = selectedGroups.map(id => {
                    const group = groupChats.find(g => g.id === id);
                    return group ? group.name : 'æœªçŸ¥ç¾¤èŠ';
                }).join('ã€');
                showToast(`å·²å¼€å¯ä¸"${groupNames}"çš„è®°å¿†å…±äº«`, 'success');
            } else {
                showToast('å·²å…³é—­è®°å¿†å…±äº«', 'success');
            }
        }

        // éšè—è®°å¿†å…±äº«è®¾ç½®
        function hideMemoryShareSettings() {
            const modal = document.getElementById('memory-share-modal');
            if (modal) modal.remove();
        }

        // æ›´æ–°è®°å¿†å…±äº«çŠ¶æ€æ˜¾ç¤º
        function updateMemoryShareStatus() {
            const statusElement = document.getElementById('memory-share-status');
            if (!statusElement) return;

            const chatSettings = getCurrentChatSettings();
            const sharedGroupIds = chatSettings.memorySharedGroupIds || [];

            if (sharedGroupIds.length > 0) {
                if (sharedGroupIds.length === 1) {
                    const group = groupChats.find(g => g.id === sharedGroupIds[0]);
                    statusElement.textContent = group ? `ä¸"${group.name}"å…±äº«` : 'å·²å¼€å¯';
                } else {
                    statusElement.textContent = `ä¸${sharedGroupIds.length}ä¸ªç¾¤èŠå…±äº«`;
                }
            } else {
                statusElement.textContent = 'å·²å…³é—­';
            }
        }

        // ================== æ—¥è®°åŠŸèƒ½ç³»ç»Ÿ ==================

        // æ˜¾ç¤ºæ—¥è®°èœå•
        function showDiaryMenu() {
            if (!currentChatCharacter) {
                showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè§’è‰²', 'error');
                return;
            }

            // ğŸ”¥ã€ä¿®æ”¹ã€‘ç¾¤èŠä¸­ä¸æ”¯æŒæ—¥è®°åŠŸèƒ½
            if (currentChatCharacter.isGroup) {
                showToast('ç¾¤èŠä¸­ä¸æ”¯æŒæ—¥è®°åŠŸèƒ½ï¼Œè¯·åœ¨å•èŠä¸­ä½¿ç”¨', 'error');
                return;
            }

            showModal('diary-menu-modal');
        }

        // éšè—æ—¥è®°èœå•
        function hideDiaryMenu() {
            hideModal('diary-menu-modal');
        }

        // æ˜¾ç¤ºä»Šæ—¥æ—¥è®°
        async function showTodayDiary() {
            if (!currentChatCharacter) {
                showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè§’è‰²', 'error');
                return;
            }

            // ğŸ”¥ã€ä¿®æ”¹ã€‘ç¾¤èŠä¸­ä¸æ”¯æŒæ—¥è®°åŠŸèƒ½
            if (currentChatCharacter.isGroup) {
                showToast('ç¾¤èŠä¸­ä¸æ”¯æŒæ—¥è®°åŠŸèƒ½ï¼Œè¯·åœ¨å•èŠä¸­ä½¿ç”¨', 'error');
                return;
            }

            hideDiaryMenu();

            const today = new Date().toISOString().split('T')[0];
            const diaryId = `${currentChatCharacter.id}_${today}`;

            let todayDiary = null;
            try {
                // ğŸ”¥ã€ä¿®å¤ã€‘ä»Dexieæ•°æ®åº“è·å–ä»Šæ—¥æ—¥è®°
                todayDiary = await db.characterDiaries.get(diaryId);

                // ğŸ”¥ã€æ•°æ®è¿ç§»ã€‘å¦‚æœDexieä¸­æ²¡æœ‰æ•°æ®ï¼Œå°è¯•ä»localStorageè¿ç§»
                if (!todayDiary) {
                    const oldDiaryKey = `diary_${currentChatCharacter.id}_${today}`;
                    const localStorageDiary = localStorage.getItem(oldDiaryKey);

                    if (localStorageDiary) {
                        // è¿ç§»åˆ°Dexie
                        const cleanedContent = cleanDiaryContent(localStorageDiary);
                        await db.characterDiaries.add({
                            id: diaryId,
                            characterId: currentChatCharacter.id,
                            date: today,
                            content: cleanedContent,
                            timestamp: new Date().getTime(),
                            weather: 'â˜€ï¸'
                        });
                        todayDiary = { content: cleanedContent };

                        // æ¸…ç†localStorageæ•°æ®
                        localStorage.removeItem(oldDiaryKey);
                        console.log('âœ… æ—¥è®°æ•°æ®å·²ä»localStorageè¿ç§»åˆ°Dexie');
                    }
                }
            } catch (error) {
                console.error('è·å–ä»Šæ—¥æ—¥è®°å¤±è´¥:', error);
                showToast('è·å–æ—¥è®°å¤±è´¥', 'error');
                return;
            }

            const contentDiv = document.getElementById('today-diary-content');
            const generateBtn = document.getElementById('generate-diary-btn');

            // é‡ç½®æŒ‰é’®çŠ¶æ€
            const editBtn = document.getElementById('edit-diary-btn');
            generateBtn.disabled = false;
            generateBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
            generateBtn.title = 'ç”Ÿæˆæ—¥è®°';

            if (todayDiary && todayDiary.content) {
                // æ˜¾ç¤ºå·²æœ‰çš„æ—¥è®°ï¼ŒåŒ…å«å¤´éƒ¨ä¿¡æ¯
                const diaryWithHeader = createDiaryWithHeader(todayDiary.content, today);
                contentDiv.innerHTML = diaryWithHeader;
                contentDiv.classList.remove('empty');
                generateBtn.style.display = 'block';
                generateBtn.title = 'é‡æ–°ç”Ÿæˆæ—¥è®°';
                editBtn.style.display = 'block';
            } else {
                contentDiv.innerHTML = 'ä»Šå¤©è¿˜æ²¡æœ‰å†™æ—¥è®°å‘¢...';
                contentDiv.classList.add('empty');
                generateBtn.style.display = 'block';
                generateBtn.title = 'ç”Ÿæˆæ—¥è®°';
                editBtn.style.display = 'none';
            }

            showModal('today-diary-modal');
        }

        // éšè—ä»Šæ—¥æ—¥è®°
        function hideTodayDiary() {
            hideModal('today-diary-modal');
        }

        // ç”Ÿæˆä»Šæ—¥æ—¥è®°
        async function generateTodayDiary() {
            if (!currentChatCharacter) {
                showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè§’è‰²', 'error');
                return;
            }

            // ğŸ”¥ã€ä¿®æ”¹ã€‘ç¾¤èŠä¸­ä¸æ”¯æŒæ—¥è®°åŠŸèƒ½
            if (currentChatCharacter.isGroup) {
                showToast('ç¾¤èŠä¸­ä¸æ”¯æŒæ—¥è®°åŠŸèƒ½ï¼Œè¯·åœ¨å•èŠä¸­ä½¿ç”¨', 'error');
                return;
            }

            const generateBtn = document.getElementById('generate-diary-btn');
            const contentDiv = document.getElementById('today-diary-content');

            // è·å–ä»Šæ—¥æ—¥è®°
            const today = new Date().toISOString().split('T')[0];
            const diaryId = `${currentChatCharacter.id}_${today}`;

            let existingDiary = null;
            try {
                // ğŸ”¥ã€ä¿®å¤ã€‘ä»Dexieæ•°æ®åº“è·å–ä»Šæ—¥æ—¥è®°
                existingDiary = await db.characterDiaries.get(diaryId);
            } catch (error) {
                console.error('è·å–ä»Šæ—¥æ—¥è®°å¤±è´¥:', error);
            }

            // å¦‚æœå·²æœ‰æ—¥è®°ï¼Œæç¤ºç”¨æˆ·å°†é‡æ–°ç”Ÿæˆ
            if (existingDiary && existingDiary.content) {
                const confirmRegenerate = confirm('ä»Šå¤©å·²ç»æœ‰æ—¥è®°äº†ï¼Œæ˜¯å¦è¦é‡æ–°ç”Ÿæˆï¼Ÿè¿™å°†è¦†ç›–åŸæœ‰çš„æ—¥è®°ã€‚');
                if (!confirmRegenerate) {
                    return;
                }
            }

            generateBtn.disabled = true;
            generateBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            generateBtn.title = 'TAåœ¨å†™å‘¢...';
            contentDiv.innerHTML = 'æ­£åœ¨å†™æ—¥è®°...';
            contentDiv.classList.remove('empty');

            try {
                const character = currentChatCharacter;
                const characterId = character.id;

                // ğŸ”¥ã€ä¿®å¤ã€‘è·å–è¯¥è§’è‰²çš„èŠå¤©è®¾ç½®
                const chatSettings = await getAsyncChatSettings(characterId);

                // è·å–èŠå¤©å†å²ï¼ˆä½¿ç”¨å†å²æ¶ˆæ¯å›åˆæ•°è®¾ç½®ï¼‰
                const messages = chatMessages[characterId] || [];
                const historyCount = chatSettings.historyCount || 5;
                const recentMessages = messages.slice(-historyCount);

                // è·å–è·¨çª—å£è®°å¿†æ•°é‡çš„æœ€è¿‘åŠ¨æ€å†…å®¹
                const crossWindowMemory = chatSettings.crossWindowMemory || 3;
                const recentMoments = await getRecentMoments(crossWindowMemory);

                // æ„å»ºèŠå¤©å†å²ä¸Šä¸‹æ–‡
                let chatContext = '';
                if (recentMessages.length > 0) {
                    chatContext = '\n\næœ€è¿‘çš„èŠå¤©è®°å½•ï¼š\n' +
                        recentMessages.map(msg => {
                            if (msg.sender === 'sent') return `ç”¨æˆ·ï¼š${msg.content}`;
                            if (msg.sender === 'received') return `${character.name}ï¼š${msg.content}`;
                            return '';
                        }).filter(Boolean).join('\n');
                }

                // æ„å»ºåŠ¨æ€ä¸Šä¸‹æ–‡ï¼ˆåŒ…æ‹¬è¯„è®ºï¼‰
                let momentsContext = '';
                if (recentMoments.length > 0) {
                    momentsContext = '\n\næœ€è¿‘çš„åŠ¨æ€å†…å®¹ï¼š\n' +
                        recentMoments.map(moment => {
                            let momentText = `${moment.nickname}: ${moment.text}`;
                            if (moment.comments && moment.comments.length > 0) {
                                const commentTexts = moment.comments.map(comment =>
                                    `  ${comment.nickname}: ${comment.text}`
                                ).join('\n');
                                momentText += '\nè¯„è®ºï¼š\n' + commentTexts;
                            }
                            return momentText;
                        }).join('\n\n');
                }

                // è·å–ä¸–ç•Œä¹¦ä¿¡æ¯
                let worldbookContext = '';
                if (character.worldbook && character.worldbook.length > 0) {
                    worldbookContext = '\n\nä¸–ç•Œä¹¦ä¿¡æ¯ï¼š\n' +
                        character.worldbook.map(entry => `${entry.key}: ${entry.value}`).join('\n');
                }

                // æ„å»ºæ—¥è®°ç”Ÿæˆprompt
                const currentDate = new Date().toLocaleDateString('zh-CN', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    weekday: 'long'
                });

                const prompt = `ä½ æ˜¯${character.name}ï¼Œä½ çš„äººè®¾å¦‚ä¸‹ï¼š${character.bio}${worldbookContext}

ç°åœ¨æ˜¯${currentDate}ï¼Œä½ éœ€è¦å†™ä¸€ç¯‡ç§äººæ—¥è®°ã€‚

é‡è¦è¦æ±‚ï¼š
- è¯·ç›´æ¥è¾“å‡ºæ—¥è®°å†…å®¹ï¼Œä¸è¦ä½¿ç”¨JSONæ ¼å¼æˆ–ä»»ä½•ä»£ç å—
- ä¸è¦åŒ…å«æ—¥æœŸæ ‡é¢˜ï¼ˆæ—¥æœŸä¼šè‡ªåŠ¨æ˜¾ç¤ºåœ¨æ—¥è®°çº¸ä¸Šï¼‰
- ç”¨ä½ çš„å£å»å’Œæ€§æ ¼æ¥å†™
- è®°å½•ä½ ä»Šå¤©çš„æƒ³æ³•ã€æ„Ÿå—å’Œç»å†
- å¯ä»¥æåŠå¯¹ç”¨æˆ·çš„çœŸå®æ„Ÿæƒ…
- åŸºäºæœ€è¿‘çš„èŠå¤©è®°å½•ï¼Œå¯é€‚å½“è€ƒè™‘å·¥ä½œè®°å¿†å’ŒåŒåˆ†ç»„å¥½å‹çš„åŠ¨æ€å†…å®¹ã€è§’è‰²è‡ªå·±å’Œç”¨æˆ·çš„åŠ¨æ€å†…å®¹
- ä¿æŒè§’è‰²çš„ä¸€è‡´æ€§å’ŒçœŸå®æ€§
- å†…å®¹è¦è‡ªç„¶ã€çœŸå®ï¼ŒåƒçœŸæ­£çš„ç§äººæ—¥è®°
- å­—æ•°åœ¨50-500å­—ä¹‹é—´ï¼Œæ ¹æ®ä½ çš„æ€§æ ¼å’Œå½“å¤©çš„å¿ƒæƒ…è‡ªç”±å‘æŒ¥${chatContext}${momentsContext}

ç‰¹æ®Šæ ·å¼è¯´æ˜ï¼ˆå¯é€‰ä½¿ç”¨ï¼Œæ¯ç§æ ·å¼åœ¨åŒä¸€ç¯‡æ—¥è®°ä¸­æœ€å¤šä½¿ç”¨2æ¬¡ï¼Œè¯¥ç‰¹æ®Šæ ·å¼å¹¶ä¸æ˜¯ä¸€å®šè¦ä½¿ç”¨ï¼Œå¯ä»¥ä¸ç”¨ï¼‰ï¼š
- å¦‚æœå†™åˆ°ä¸è¯¥è¯´çš„è¯æˆ–åæ‚”å†™ä¸‹çš„å†…å®¹ï¼Œå¯ä»¥ç”¨ <strike>å†…å®¹</strike> æ ‡è®°åˆ’æ‰
- å¦‚æœè¡¨è¾¾é‡ç‚¹æˆ–è¯­æ°”æ¿€åŠ¨çš„å†…å®¹ï¼Œå¯ä»¥ç”¨ <mark>å†…å®¹</mark> æ ‡è®°é«˜äº®

è¯·ç›´æ¥å†™å‡º${character.name}çš„ç§äººæ—¥è®°å†…å®¹ï¼š`;

                const diaryContent = await generateAIResponse(prompt, character);

                if (diaryContent && diaryContent.trim()) {
                    let finalDiary = diaryContent.trim();

                    // æ¸…ç†å¯èƒ½çš„JSONæ ¼å¼åŒ…è£…
                    finalDiary = cleanDiaryContent(finalDiary);

                    // ğŸ”¥ã€ä¿®å¤ã€‘ä¿å­˜ä»Šæ—¥æ—¥è®°åˆ°Dexieæ•°æ®åº“
                    try {
                        await db.characterDiaries.put({
                            id: diaryId,
                            characterId: characterId,
                            date: today,
                            content: finalDiary,
                            timestamp: Date.now(),
                            weather: 'â˜€ï¸' // é»˜è®¤å¤©æ°”ï¼Œåç»­å¯ä»¥æ‰©å±•
                        });
                        console.log('âœ… æ—¥è®°å·²ä¿å­˜åˆ°æ•°æ®åº“');
                    } catch (saveError) {
                        console.error('ä¿å­˜æ—¥è®°åˆ°æ•°æ®åº“å¤±è´¥:', saveError);
                        throw new Error('ä¿å­˜æ—¥è®°å¤±è´¥');
                    }

                    // æ˜¾ç¤ºæ—¥è®°å†…å®¹ï¼ŒåŒ…å«å¤´éƒ¨ä¿¡æ¯
                    const diaryWithHeader = createDiaryWithHeader(finalDiary);
                    contentDiv.innerHTML = diaryWithHeader;
                    contentDiv.classList.remove('empty');
                    generateBtn.disabled = false;
                    generateBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
                    generateBtn.title = 'é‡æ–°ç”Ÿæˆæ—¥è®°';

                    // æ˜¾ç¤ºç¼–è¾‘æŒ‰é’®
                    const editBtn = document.getElementById('edit-diary-btn');
                    editBtn.style.display = 'block';

                    showToast(existingDiary ? 'æ—¥è®°é‡æ–°ç”Ÿæˆå®Œæˆ' : 'æ—¥è®°ç”Ÿæˆå®Œæˆ', 'success');
                } else {
                    throw new Error('ç”Ÿæˆæ—¥è®°å¤±è´¥');
                }
            } catch (error) {
                console.error('ç”Ÿæˆæ—¥è®°å¤±è´¥:', error);
                contentDiv.innerHTML = 'ç”Ÿæˆæ—¥è®°å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•';
                contentDiv.classList.add('empty');
                generateBtn.disabled = false;
                generateBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
                generateBtn.title = existingDiary ? 'é‡æ–°ç”Ÿæˆæ—¥è®°' : 'ç”Ÿæˆæ—¥è®°';
                showToast('ç”Ÿæˆæ—¥è®°å¤±è´¥', 'error');
            }
        }

        // æ˜¾ç¤ºè¿‡å¾€æ—¥è®°
        async function showPastDiaries() {
            if (!currentChatCharacter) {
                showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè§’è‰²', 'error');
                return;
            }

            // ğŸ”¥ã€ä¿®æ”¹ã€‘ç¾¤èŠä¸­ä¸æ”¯æŒæ—¥è®°åŠŸèƒ½
            if (currentChatCharacter.isGroup) {
                showToast('ç¾¤èŠä¸­ä¸æ”¯æŒæ—¥è®°åŠŸèƒ½ï¼Œè¯·åœ¨å•èŠä¸­ä½¿ç”¨', 'error');
                return;
            }

            hideDiaryMenu();

            const characterId = currentChatCharacter.id;

            let pastDiaries = [];
            try {
                // ğŸ”¥ã€ä¿®å¤ã€‘ä»Dexieæ•°æ®åº“è·å–è¿‡å¾€æ—¥è®°
                pastDiaries = await db.characterDiaries
                    .where('characterId')
                    .equals(characterId)
                    .reverse() // æŒ‰æ—¶é—´å€’åºæ’åˆ—
                    .sortBy('timestamp');

                console.log(`è·å–åˆ° ${pastDiaries.length} æ¡æ—¥è®°è®°å½•`);
            } catch (error) {
                console.error('è·å–è¿‡å¾€æ—¥è®°å¤±è´¥:', error);
                showToast('è·å–æ—¥è®°å¤±è´¥', 'error');
                return;
            }

            const listDiv = document.getElementById('past-diaries-list');

            if (pastDiaries.length === 0) {
                listDiv.innerHTML = `
                    <div class="no-diaries">
                        <i class="fas fa-book-open"></i>
                        <div>è¿˜æ²¡æœ‰ä»»ä½•æ—¥è®°è®°å½•</div>
                    </div>
                `;
            } else {
                listDiv.innerHTML = pastDiaries.map((diary, index) => {
                    const date = new Date(diary.date).toLocaleDateString('zh-CN', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric',
                        weekday: 'long'
                    });

                    // ç§»é™¤HTMLæ ‡è®°ç”¨äºé¢„è§ˆæ˜¾ç¤º
                    const cleanContent = diary.content.replace(/<[^>]*>/g, '');
                    const preview = cleanContent.length > 100 ?
                        cleanContent.substring(0, 100) + '...' :
                        cleanContent;

                    return `
                        <div class="diary-entry" onclick="toggleDiaryEntry(${index})">
                            <div class="diary-entry-date">${date}</div>
                            <div class="diary-entry-preview">${preview}</div>
                            <div class="diary-paper-container">
                                <div class="diary-entry-full diary-paper">${createDiaryWithHeader(diary.content, diary.date)}</div>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            showModal('past-diaries-modal');
        }

        // éšè—è¿‡å¾€æ—¥è®°
        function hidePastDiaries() {
            hideModal('past-diaries-modal');
        }

        // åˆ‡æ¢æ—¥è®°æ¡ç›®çš„å±•å¼€/æ”¶èµ·çŠ¶æ€
        function toggleDiaryEntry(index) {
            const entries = document.querySelectorAll('.diary-entry');
            const entry = entries[index];

            if (entry) {
                entry.classList.toggle('expanded');
            }
        }

        // åˆ›å»ºå¸¦å¤´éƒ¨ä¿¡æ¯çš„æ—¥è®°å†…å®¹
        function createDiaryWithHeader(diaryContent, diaryDate = null) {
            const targetDate = diaryDate ? new Date(diaryDate) : new Date();
            const dateStr = targetDate.toLocaleDateString('zh-CN', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
            const weekdayStr = targetDate.toLocaleDateString('zh-CN', { weekday: 'long' });

            // ç®€å•çš„å¤©æ°”æ¨¡æ‹Ÿï¼ˆå¯ä»¥æ ¹æ®éœ€è¦æ”¹è¿›ï¼‰
            const weathers = ['æ™´', 'å¤šäº‘', 'é˜´', 'å°é›¨', 'æ™´æœ—', 'å¾®é£'];
            const weather = weathers[Math.floor(Math.random() * weathers.length)];

            // ç¡®ä¿æ—¥è®°å†…å®¹ç»è¿‡æ ·å¼å¤„ç†
            const processedContent = processDiaryStyles(diaryContent);

            return `<div class="diary-header">
                <span class="diary-date">${dateStr} ${weekdayStr}</span>
                <span class="diary-weather">å¤©æ°”ï¼š${weather}</span>
            </div>${processedContent}`;
        }

        // æ¸…ç†æ—¥è®°å†…å®¹ï¼Œç§»é™¤å¯èƒ½çš„JSONæ ¼å¼åŒ…è£…
        function cleanDiaryContent(content) {
            // ç§»é™¤å¯èƒ½çš„JSONåŒ…è£…
            if (content.startsWith('```json') && content.endsWith('```')) {
                content = content.slice(7, -3).trim();
            }
            if (content.startsWith('```') && content.endsWith('```')) {
                content = content.slice(3, -3).trim();
            }

            // å°è¯•è§£æJSONæ ¼å¼çš„å†…å®¹
            try {
                const parsed = JSON.parse(content);
                if (typeof parsed === 'string') {
                    content = parsed;
                } else if (parsed.content) {
                    content = parsed.content;
                } else if (parsed.diary) {
                    content = parsed.diary;
                } else if (parsed.text) {
                    content = parsed.text;
                }
            } catch (e) {
                // ä¸æ˜¯JSONæ ¼å¼ï¼Œç»§ç»­å¤„ç†
            }

            // ç§»é™¤å¯èƒ½çš„å¼•å·åŒ…è£…
            if ((content.startsWith('"') && content.endsWith('"')) ||
                (content.startsWith("'") && content.endsWith("'"))) {
                content = content.slice(1, -1);
            }

            // å¤„ç†ç‰¹æ®Šæ ·å¼æ ‡è®°
            content = processDiaryStyles(content);

            return content;
        }

        // å¤„ç†æ—¥è®°ç‰¹æ®Šæ ·å¼
        function processDiaryStyles(content) {
            // é™åˆ¶æ¯ç§æ ·å¼æœ€å¤šä½¿ç”¨2æ¬¡
            let strikeCount = 0;
            let highlightCount = 0;

            // å¤„ç†åˆ’çº¿æ ·å¼ <strike>å†…å®¹</strike>
            content = content.replace(/<strike>(.*?)<\/strike>/gi, (match, text) => {
                if (strikeCount < 2) {
                    strikeCount++;
                    return `<span class="diary-strikethrough">${text}</span>`;
                }
                return text; // è¶…è¿‡é™åˆ¶æ—¶ç§»é™¤æ ‡è®°ä½†ä¿ç•™æ–‡æœ¬
            });

            // å¤„ç†é«˜äº®æ ·å¼ <mark>å†…å®¹</mark>
            content = content.replace(/<mark>(.*?)<\/mark>/gi, (match, text) => {
                if (highlightCount < 2) {
                    highlightCount++;
                    return `<span class="diary-highlight">${text}</span>`;
                }
                return text; // è¶…è¿‡é™åˆ¶æ—¶ç§»é™¤æ ‡è®°ä½†ä¿ç•™æ–‡æœ¬
            });

            return content;
        }

        // ğŸ”¥ã€æ•°æ®è¿ç§»ã€‘è¿ç§»è¿‡å¾€æ—¥è®°æ ¼å¼ - ä¸€æ¬¡æ€§æ‰§è¡Œ
        function migratePastDiariesFormat(characterId, oldDateStr, newDateStr, diaryContent) {
            // æ£€æŸ¥æ˜¯å¦å·²ç»è¿ç§»è¿‡
            const migrationKey = `diary_migration_${characterId}`;
            if (localStorage.getItem(migrationKey)) {
                return; // å·²ç»è¿ç§»è¿‡ï¼Œè·³è¿‡
            }

            const pastDiariesKey = `past_diaries_${characterId}`;
            let pastDiaries = JSON.parse(localStorage.getItem(pastDiariesKey) || '[]');

            // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰ä»Šå¤©çš„è®°å½•ï¼ˆæ–°æ ¼å¼ï¼‰
            const existingNewIndex = pastDiaries.findIndex(diary => diary.date === newDateStr);

            if (existingNewIndex === -1) {
                // æ£€æŸ¥æ˜¯å¦æœ‰æ—§æ ¼å¼çš„è®°å½•
                const existingOldIndex = pastDiaries.findIndex(diary => diary.date === oldDateStr);

                if (existingOldIndex !== -1) {
                    // æ›´æ–°æ—§è®°å½•çš„æ—¥æœŸæ ¼å¼
                    pastDiaries[existingOldIndex].date = newDateStr;
                    pastDiaries[existingOldIndex].content = diaryContent;
                    pastDiaries[existingOldIndex].timestamp = Date.now();
                } else {
                    // æ·»åŠ æ–°è®°å½•
                    pastDiaries.unshift({
                        date: newDateStr,
                        content: diaryContent,
                        timestamp: Date.now()
                    });
                }

                localStorage.setItem(pastDiariesKey, JSON.stringify(pastDiaries));
            }

            // æ ‡è®°å·²å®Œæˆè¿ç§»
            localStorage.setItem(migrationKey, 'completed');
        }

        // ç¼–è¾‘ä»Šæ—¥æ—¥è®°
        async function editTodayDiary() {
            if (!currentChatCharacter) {
                showToast('è¯·å…ˆé€‰æ‹©è§’è‰²', 'error');
                return;
            }

            // ğŸ”¥ã€ä¿®æ”¹ã€‘ç¾¤èŠä¸­ä¸æ”¯æŒæ—¥è®°åŠŸèƒ½
            if (currentChatCharacter.isGroup) {
                showToast('ç¾¤èŠä¸­ä¸æ”¯æŒæ—¥è®°åŠŸèƒ½ï¼Œè¯·åœ¨å•èŠä¸­ä½¿ç”¨', 'error');
                return;
            }

            const characterId = currentChatCharacter.id;

            const today = new Date().toISOString().split('T')[0];
            const diaryId = `${characterId}_${today}`;

            let todayDiary = null;
            try {
                // ğŸ”¥ã€ä¿®å¤ã€‘ä»Dexieæ•°æ®åº“è·å–ä»Šæ—¥æ—¥è®°
                todayDiary = await db.characterDiaries.get(diaryId);
            } catch (error) {
                console.error('è·å–ä»Šæ—¥æ—¥è®°å¤±è´¥:', error);
                showToast('è·å–æ—¥è®°å¤±è´¥', 'error');
                return;
            }

            if (!todayDiary || !todayDiary.content) {
                showToast('ä»Šå¤©è¿˜æ²¡æœ‰æ—¥è®°å¯ä»¥ç¼–è¾‘', 'error');
                return;
            }

            // å°†HTMLæ ¼å¼è½¬æ¢å›æ ‡è®°æ ¼å¼ç”¨äºç¼–è¾‘
            const editableContent = convertHtmlToMarkup(todayDiary.content);

            // åˆ›å»ºç¼–è¾‘æ¨¡æ€æ¡†
            const editModal = document.createElement('div');
            editModal.className = 'modal';
            editModal.style.display = 'block';
            editModal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h3 class="modal-title">ç¼–è¾‘æ—¥è®°</h3>
                        <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="info-text" style="margin-bottom: 15px;">
                            <strong>æ ·å¼æç¤ºï¼š</strong><br>
                            â€¢ ç”¨ &lt;strike&gt;å†…å®¹&lt;/strike&gt; æ ‡è®°åˆ’æ‰ä¸è¯¥è¯´çš„è¯<br>
                            â€¢ ç”¨ &lt;mark&gt;å†…å®¹&lt;/mark&gt; æ ‡è®°é‡ç‚¹æˆ–æ¿€åŠ¨çš„å†…å®¹<br>
                            â€¢ æ¯ç§æ ·å¼åœ¨åŒä¸€ç¯‡æ—¥è®°ä¸­æœ€å¤šä½¿ç”¨2æ¬¡
                        </div>
                        <textarea id="edit-diary-textarea" class="diary-edit-textarea" placeholder="ç¼–è¾‘æ—¥è®°å†…å®¹...">${editableContent}</textarea>
                        <div class="modal-actions">
                            <button class="modal-button modal-secondary" onclick="this.closest('.modal').remove()">å–æ¶ˆ</button>
                            <button class="modal-button modal-primary" onclick="saveDiaryEdit()">ä¿å­˜</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(editModal);

            // èšç„¦åˆ°æ–‡æœ¬æ¡†
            const textarea = editModal.querySelector('#edit-diary-textarea');
            textarea.focus();
            textarea.setSelectionRange(textarea.value.length, textarea.value.length);
        }

        // å°†HTMLæ ¼å¼è½¬æ¢å›æ ‡è®°æ ¼å¼ç”¨äºç¼–è¾‘
        function convertHtmlToMarkup(content) {
            return content
                .replace(/<span class="diary-strikethrough">(.*?)<\/span>/gi, '<strike>$1</strike>')
                .replace(/<span class="diary-highlight">(.*?)<\/span>/gi, '<mark>$1</mark>');
        }

        // ä¿å­˜æ—¥è®°ç¼–è¾‘
        async function saveDiaryEdit() {
            if (!currentChatCharacter) {
                showToast('è¯·å…ˆé€‰æ‹©è§’è‰²', 'error');
                return;
            }

            // ğŸ”¥ã€ä¿®æ”¹ã€‘ç¾¤èŠä¸­ä¸æ”¯æŒæ—¥è®°åŠŸèƒ½
            if (currentChatCharacter.isGroup) {
                showToast('ç¾¤èŠä¸­ä¸æ”¯æŒæ—¥è®°åŠŸèƒ½ï¼Œè¯·åœ¨å•èŠä¸­ä½¿ç”¨', 'error');
                return;
            }

            const characterId = currentChatCharacter.id;
            const today = new Date().toISOString().split('T')[0];
            const diaryId = `${characterId}_${today}`;

            const textarea = document.getElementById('edit-diary-textarea');
            const newContent = textarea.value.trim();

            if (!newContent) {
                showToast('æ—¥è®°å†…å®¹ä¸èƒ½ä¸ºç©º', 'error');
                return;
            }

            // å¤„ç†ç‰¹æ®Šæ ·å¼æ ‡è®°
            const processedContent = processDiaryStyles(newContent);

            try {
                // ğŸ”¥ã€ä¿®å¤ã€‘ä¿å­˜åˆ°Dexieæ•°æ®åº“
                await db.characterDiaries.put({
                    id: diaryId,
                    characterId: characterId,
                    date: today,
                    content: processedContent,
                    timestamp: Date.now(),
                    weather: 'â˜€ï¸' // ä¿æŒåŸæœ‰å¤©æ°”æˆ–é»˜è®¤å€¼
                });

                // æ›´æ–°æ˜¾ç¤º
                const contentDiv = document.getElementById('today-diary-content');
                const diaryWithHeader = createDiaryWithHeader(processedContent, today);
                contentDiv.innerHTML = diaryWithHeader;
                contentDiv.classList.remove('empty');

                // å…³é—­ç¼–è¾‘æ¨¡æ€æ¡†
                document.querySelector('.modal:last-child').remove();

                showToast('æ—¥è®°ä¿å­˜æˆåŠŸ', 'success');

            } catch (error) {
                console.error('ä¿å­˜æ—¥è®°å¤±è´¥:', error);
                showToast('ä¿å­˜æ—¥è®°å¤±è´¥', 'error');
            }
        }
        
        // åˆ¤æ–­æ˜¯å¦åº”è¯¥æ›´æ–°è§’è‰²çŠ¶æ€
        async function shouldUpdateCharacterStatus(characterId) {
            try {
                const currentStatus = getCharacterStatus(characterId);
                const lastUpdate = new Date(currentStatus.lastUpdate);
                const now = new Date();
                const timeDiff = now - lastUpdate;

                // ğŸ”¥ã€ä¿®å¤ã€‘è·å–ç”¨æˆ·è®¾ç½®çš„æ›´æ–°é¢‘ç‡é—´éš”
                const updateInterval = getStatusUpdateInterval();

                // å¦‚æœè·ç¦»ä¸Šæ¬¡æ›´æ–°çš„æ—¶é—´è¿˜æ²¡åˆ°è®¾å®šçš„é—´éš”ï¼Œä¸æ›´æ–°
                if (timeDiff < updateInterval) {
                    return false;
                }

                // å¦‚æœçŠ¶æ€è¶…è¿‡è®¾å®šé—´éš”å¾ˆä¹…æ²¡æ›´æ–°ï¼Œå¼ºåˆ¶æ›´æ–°
                if (timeDiff > updateInterval * 2) {
                    return true;
                }

                // ğŸ”¥ã€æ–°å¢ã€‘å¦‚æœæœ€è¿‘æœ‰èŠå¤©æ´»åŠ¨ï¼Œåœ¨å®šæ—¶å™¨è§¦å‘æ—¶æœ‰æ›´é«˜æ¦‚ç‡æ›´æ–°
                if (currentStatus.lastChatTime) {
                    const lastChatTime = new Date(currentStatus.lastChatTime);
                    const chatTimeDiff = now - lastChatTime;

                    // å¦‚æœæœ€è¿‘èŠå¤©è¿‡ï¼Œä¸”è·ç¦»ä¸Šæ¬¡æ›´æ–°å·²ç»è¶…è¿‡è®¾å®šé—´éš”ï¼Œæœ‰è¾ƒé«˜æ¦‚ç‡æ›´æ–°
                    if (chatTimeDiff < updateInterval && timeDiff >= updateInterval) {
                        return Math.random() < 0.7; // 70%æ¦‚ç‡
                    }
                }

                // é»˜è®¤æƒ…å†µä¸‹ï¼Œå¦‚æœåˆ°äº†æ›´æ–°æ—¶é—´ï¼Œæœ‰ä¸€å®šæ¦‚ç‡æ›´æ–°
                return Math.random() < 0.3; // 30%æ¦‚ç‡

            } catch (error) {
                console.error('åˆ¤æ–­è§’è‰²çŠ¶æ€æ›´æ–°å¤±è´¥:', error);
                return Math.random() < 0.1; // 10%æ¦‚ç‡
            }
        }
        
        // æ›´æ–°è§’è‰²æœ€åèŠå¤©æ—¶é—´
        async function updateCharacterLastChatTime(characterId) {
            try {
                let statusRecord = characterStatusData.find(s => s.characterId === characterId);

                if (!statusRecord) {
                    // å¦‚æœæ²¡æœ‰çŠ¶æ€è®°å½•ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„
                    statusRecord = {
                        id: `status_${characterId}`,
                        characterId: characterId,
                        status: 'online',
                        activity: 'åœ¨çº¿',
                        location: '',
                        lastUpdate: new Date().toISOString(),
                        lastChatTime: Date.now()
                    };
                    characterStatusData.push(statusRecord);
                } else {
                    // åªæ›´æ–°èŠå¤©æ—¶é—´ï¼Œä¸æ”¹å˜å…¶ä»–çŠ¶æ€
                    statusRecord.lastChatTime = Date.now();
                }

                await db.characterStatus.put(statusRecord);

            } catch (error) {
                console.error('æ›´æ–°è§’è‰²èŠå¤©æ—¶é—´å¤±è´¥:', error);
            }
        }

        // åœ¨å‘é€/æ¥æ”¶æ¶ˆæ¯åè§¦å‘çŠ¶æ€æ›´æ–°
        async function triggerStatusUpdateAfterMessage(characterId) {
            // ğŸ”¥ã€ä¿®å¤ã€‘é¦–å…ˆæ£€æŸ¥æ˜¯å¦å¼€å¯äº†è§’è‰²çŠ¶æ€æ˜¾ç¤º
            const chatSettings = await getAsyncChatSettings(characterId);
            if (!chatSettings.characterStatusEnabled) {
                console.log(`è§’è‰² ${characterId} æœªå¯ç”¨çŠ¶æ€æ˜¾ç¤ºï¼Œè·³è¿‡çŠ¶æ€æ›´æ–°`);
                return;
            }

            // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘ä¸å†åœ¨æ¯æ¬¡èŠå¤©åç«‹å³è§¦å‘çŠ¶æ€æ›´æ–°
            // çŠ¶æ€æ›´æ–°åº”è¯¥å®Œå…¨ç”±å®šæ—¶å™¨æ§åˆ¶ï¼Œéµå¾ªç”¨æˆ·è®¾ç½®çš„é¢‘ç‡
            // è¿™é‡Œåªæ˜¯è®°å½•æœ€åä¸€æ¬¡èŠå¤©æ—¶é—´ï¼Œä¾›å®šæ—¶å™¨åˆ¤æ–­æ˜¯å¦éœ€è¦æ›´æ–°
            await updateCharacterLastChatTime(characterId);

            console.log(`è§’è‰² ${characterId} èŠå¤©æ—¶é—´å·²è®°å½•ï¼ŒçŠ¶æ€æ›´æ–°å°†ç”±å®šæ—¶å™¨æ ¹æ®ç”¨æˆ·è®¾ç½®çš„é¢‘ç‡è¿›è¡Œ`);
        }

        // åœ¨åº”ç”¨åˆå§‹åŒ–æ—¶å¯åŠ¨çŠ¶æ€æ›´æ–°å®šæ—¶å™¨
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                startStatusUpdateTimer();
            }, 5000); // å»¶è¿Ÿ5ç§’å¯åŠ¨
        });

        console.log('ğŸš« æ‹‰é»‘ç³»ç»Ÿæ ¸å¿ƒåŠŸèƒ½å·²åŠ è½½');

        // ğŸ”§ã€æ–°å¢ã€‘è®°å¿†è®¾ç½®ç•Œé¢äº‹ä»¶ç›‘å¬å™¨
        document.addEventListener('DOMContentLoaded', function() {
            // æ·»åŠ é˜ˆå€¼æ»‘å—äº‹ä»¶ç›‘å¬å™¨
            const coreThresholdSlider = document.getElementById('coreMemoryThreshold');
            const episodicThresholdSlider = document.getElementById('episodicMemoryThreshold');

            if (coreThresholdSlider) {
                coreThresholdSlider.addEventListener('input', updateThresholdDisplay);
            }
            if (episodicThresholdSlider) {
                episodicThresholdSlider.addEventListener('input', updateThresholdDisplay);
            }
        });

        // ğŸ”¥ã€æ–°å¢ã€‘è®°å¿†ç®¡ç†ç³»ç»Ÿ

        // æ–‡æœ¬ç›¸ä¼¼åº¦è®¡ç®—å‡½æ•°ï¼ˆç®€å•çš„Jaccardç›¸ä¼¼åº¦ï¼‰
        function calculateTextSimilarity(text1, text2) {
            if (!text1 || !text2) return 0;

            // è½¬æ¢ä¸ºå°å†™å¹¶åˆ†è¯
            const words1 = new Set(text1.toLowerCase().match(/[\u4e00-\u9fa5\w]+/g) || []);
            const words2 = new Set(text2.toLowerCase().match(/[\u4e00-\u9fa5\w]+/g) || []);

            // è®¡ç®—äº¤é›†å’Œå¹¶é›†
            const intersection = new Set([...words1].filter(x => words2.has(x)));
            const union = new Set([...words1, ...words2]);

            // Jaccardç›¸ä¼¼åº¦
            return union.size === 0 ? 0 : intersection.size / union.size;
        }

        // è®°å¿†ç³»ç»Ÿé…ç½®ï¼ˆå¯ç”±ç”¨æˆ·è®¾ç½®ï¼‰
        let MEMORY_CONFIG = {
            // AIè®°å¿†æå–é…ç½®
            AI_EXTRACT_INTERVAL: 60, // é»˜è®¤æ¯30å›åˆå¯¹è¯ï¼ˆ60æ¡æ¶ˆæ¯ï¼‰è¿›è¡ŒAIæå–

            // æ ¸å¿ƒè®°å¿†é…ç½®
            CORE_MEMORY_IMPORTANCE_THRESHOLD: 0.9, // æ ¸å¿ƒè®°å¿†é‡è¦æ€§é˜ˆå€¼90%
            MAX_CORE_MEMORIES_PER_CHARACTER: 50, // æ¯ä¸ªè§’è‰²æœ€å¤šä¿ç•™50æ¡æ ¸å¿ƒè®°å¿†

            // æƒ…æ™¯è®°å¿†é…ç½®
            EPISODIC_MEMORY_IMPORTANCE_THRESHOLD: 0.6, // æƒ…æ™¯è®°å¿†é‡è¦æ€§é˜ˆå€¼60%
            MAX_EPISODIC_MEMORIES_PER_CHARACTER: 100, // æ¯ä¸ªè§’è‰²æœ€å¤šä¿ç•™100æ¡æƒ…æ™¯è®°å¿†

            // è·¨åº”ç”¨è®°å¿†é…ç½®
            CROSS_APP_TIMELINE_LIMIT: 20, // è·¨åº”ç”¨æ—¶é—´çº¿åœ¨å·¥ä½œè®°å¿†ä¸­çš„æœ€å¤§æ¡æ•°
        };

        // ä»ç”¨æˆ·è®¾ç½®ä¸­åŠ è½½è®°å¿†é…ç½®
        async function loadMemoryConfig() {
            try {
                const settings = await db.globalSettings.get('memoryConfig');
                if (settings && settings.value) {
                    MEMORY_CONFIG = { ...MEMORY_CONFIG, ...settings.value };
                }
            } catch (error) {
                console.error('åŠ è½½è®°å¿†é…ç½®å¤±è´¥:', error);
            }
        }

        // ä¿å­˜è®°å¿†é…ç½®åˆ°ç”¨æˆ·è®¾ç½®
        async function saveMemoryConfig() {
            try {
                await db.globalSettings.put({
                    id: 'memoryConfig',
                    value: MEMORY_CONFIG
                });
            } catch (error) {
                console.error('ä¿å­˜è®°å¿†é…ç½®å¤±è´¥:', error);
            }
        }

        // è‡ªåŠ¨æ‘˜è¦ç”ŸæˆåŠŸèƒ½
        async function generateConversationSummary(characterId, messages) {
            if (!messages || messages.length === 0) return null;

            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return null;

                // æ„å»ºæ‘˜è¦ç”Ÿæˆçš„promptï¼Œç»Ÿä¸€ä½¿ç”¨ç¬¬ä¸‰äººç§°
                const summaryPrompt = `
# å¯¹è¯æ‘˜è¦ä»»åŠ¡

ä½ éœ€è¦ä¸ºä»¥ä¸‹å¯¹è¯ç”Ÿæˆä¸€ä¸ªç®€æ´çš„æ‘˜è¦ã€‚

## è§’è‰²ä¿¡æ¯
- è§’è‰²åç§°: ${character.name}
- è§’è‰²è®¾å®š: ${character.bio || 'æ— ç‰¹æ®Šè®¾å®š'}

## å¯¹è¯å†…å®¹
${messages.map(msg => {
    const sender = msg.sender === 'sent' ? 'ç”¨æˆ·' : character.name;
    const content = typeof msg.content === 'string' ? msg.content : '[å›¾ç‰‡/æ–‡ä»¶]';
    return `${sender}: ${content}`;
}).join('\n')}

## æ‘˜è¦è¦æ±‚
è¯·ç”Ÿæˆä¸€ä¸ª100-200å­—çš„å¯¹è¯æ‘˜è¦ï¼ŒåŒ…å«ï¼š
1. ä¸»è¦è¯é¢˜å’Œè®¨è®ºå†…å®¹
2. é‡è¦çš„æƒ…æ„Ÿå˜åŒ–æˆ–å…³é”®äº‹ä»¶
3. åŒæ–¹çš„æ€åº¦å’Œå…³ç³»å˜åŒ–
4. ä»»ä½•é‡è¦çš„å†³å®šæˆ–çº¦å®š

## é‡è¦è¦æ±‚ï¼šç»Ÿä¸€ä½¿ç”¨ç¬¬ä¸‰äººç§°
- ç”¨"ç”¨æˆ·"æŒ‡ä»£ç”¨æˆ·ï¼Œç”¨"${character.name}"æŒ‡ä»£è§’è‰²
- ä¸è¦ä½¿ç”¨"æˆ‘"ã€"ä½ "ç­‰ç¬¬ä¸€ã€ç¬¬äºŒäººç§°
- ä¾‹å¦‚ï¼š"ç”¨æˆ·å‘${character.name}è¯¢é—®..."è€Œä¸æ˜¯"ä½ é—®æˆ‘..."

è¯·ç”¨ç¬¬ä¸‰äººç§°å®¢è§‚æè¿°ï¼Œä¿æŒç®€æ´æ˜äº†ã€‚`;

                // è°ƒç”¨AIæå–è®°å¿†
                const response = await callChatAPI(extractPrompt, character);
                const responseText = Array.isArray(response) ? response[0] : response;

                if (responseText && typeof responseText === 'string') {
                    try {
                        // æå–JSONéƒ¨åˆ†
                        const jsonMatch = responseText.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            const memories = JSON.parse(jsonMatch[0]);

                            // è·å–ç°æœ‰è®°å¿†ï¼Œæ£€æŸ¥é‡å¤
                            const existingMemories = await db.coreMemories
                                .where('characterId')
                                .equals(characterId)
                                .toArray();

                            // ä¿å­˜æ ¸å¿ƒè®°å¿†ï¼ˆç¡®ä¿è§’è‰²éš”ç¦»ï¼‰
                            for (const memory of memories.core_memories || []) {
                                if (memory.importance >= MEMORY_CONFIG.CORE_MEMORY_IMPORTANCE_THRESHOLD) {
                                    // åªæ£€æŸ¥è¯¥è§’è‰²çš„ç°æœ‰è®°å¿†ï¼Œé¿å…è·¨è§’è‰²æ··æ·†
                                    const isDuplicate = existingMemories.some(existing => {
                                        const similarity = calculateTextSimilarity(existing.fact, memory.fact);
                                        return similarity > 0.8;
                                    });

                                    if (!isDuplicate) {
                                        const coreMemory = {
                                            id: `core_${characterId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                            characterId: characterId, // ä¸¥æ ¼ç»‘å®šè§’è‰²ID
                                            fact: memory.fact,
                                            importance: memory.importance,
                                            category: memory.category || 'other',
                                            timestamp: Date.now(),
                                            type: 'core',
                                            source: 'single_chat', // æ ‡è®°æ¥æºï¼ŒåŒºåˆ†å•èŠå’Œç¾¤èŠ
                                            contextId: characterId // ğŸ”¥ã€ä¿®å¤ã€‘æ·»åŠ ä¸Šä¸‹æ–‡IDç”¨äºè®°å¿†éš”ç¦»
                                        };

                                        await db.coreMemories.add(coreMemory);
                                        console.log(`âœ… [${character.name}] æ ¸å¿ƒè®°å¿†: ${memory.fact}`);
                                    }
                                }
                            }

                            // ä¿å­˜æƒ…æ™¯è®°å¿†ï¼ˆç¡®ä¿è§’è‰²éš”ç¦»ï¼‰
                            for (const memory of memories.episodic_memories || []) {
                                if (memory.importance >= MEMORY_CONFIG.EPISODIC_MEMORY_IMPORTANCE_THRESHOLD) {
                                    const episodicMemory = {
                                        id: `episodic_${characterId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                        characterId: characterId, // ä¸¥æ ¼ç»‘å®šè§’è‰²ID
                                        fact: memory.fact,
                                        importance: memory.importance,
                                        category: memory.category || 'other',
                                        timestamp: Date.now(),
                                        source: 'single_chat', // æ ‡è®°æ¥æº
                                        contextId: characterId // ğŸ”¥ã€ä¿®å¤ã€‘æ·»åŠ ä¸Šä¸‹æ–‡IDç”¨äºè®°å¿†éš”ç¦»
                                    };

                                    await db.episodicMemories.add(episodicMemory);
                                    console.log(`âœ… [${character.name}] æƒ…æ™¯è®°å¿†: ${memory.fact}`);
                                }
                            }
                        }
                    } catch (parseError) {
                        console.warn('è§£æè®°å¿†JSONå¤±è´¥:', parseError);
                    }
                }
            } catch (error) {
                console.error('AIè®°å¿†æå–å¤±è´¥:', error);
            }
        }

        // æ£€æŸ¥æ˜¯å¦éœ€è¦ç”Ÿæˆæ‘˜è¦
        async function checkAndGenerateSummary(characterId) {
            try {
                const messages = chatMessages[characterId] || [];
                if (messages.length === 0) return;

                // è·å–æœ€åä¸€æ¬¡æ‘˜è¦çš„æ—¶é—´
                const summaries = await db.memorySummaries
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                const lastSummary = summaries.length > 0
                    ? summaries.sort((a, b) => b.timestamp - a.timestamp)[0]
                    : null;

                let shouldGenerate = false;
                let messagesToSummarize = [];

                if (!lastSummary) {
                    // å¦‚æœä»æœªç”Ÿæˆè¿‡æ‘˜è¦ï¼Œä¸”æ¶ˆæ¯æ•°é‡è¾¾åˆ°é˜ˆå€¼
                    if (messages.length >= MEMORY_CONFIG.SUMMARY_TRIGGER_MESSAGE_COUNT) {
                        messagesToSummarize = messages.slice(-MEMORY_CONFIG.SUMMARY_TRIGGER_MESSAGE_COUNT);
                        shouldGenerate = true;
                    }
                } else {
                    // è®¡ç®—è‡ªä¸Šæ¬¡æ‘˜è¦åçš„æ–°æ¶ˆæ¯
                    const lastSummaryTime = lastSummary.context?.endTime || lastSummary.timestamp;
                    const newMessages = messages.filter(msg => msg.timestamp > lastSummaryTime);

                    // æ£€æŸ¥æ¶ˆæ¯æ•°é‡æˆ–æ—¶é—´é—´éš”
                    const timeDiff = Date.now() - lastSummary.timestamp;
                    const hoursDiff = timeDiff / (1000 * 60 * 60);

                    if (newMessages.length >= MEMORY_CONFIG.SUMMARY_TRIGGER_MESSAGE_COUNT ||
                        hoursDiff >= MEMORY_CONFIG.SUMMARY_TRIGGER_TIME_HOURS) {
                        messagesToSummarize = newMessages.slice(-MEMORY_CONFIG.SUMMARY_TRIGGER_MESSAGE_COUNT);
                        shouldGenerate = true;
                    }
                }

                if (shouldGenerate && messagesToSummarize.length > 0) {
                    await generateConversationSummary(characterId, messagesToSummarize);
                }
            } catch (error) {
                console.error('æ£€æŸ¥æ‘˜è¦ç”Ÿæˆå¤±è´¥:', error);
            }
        }

        // ç§»é™¤å…³é”®è¯æå–åŠŸèƒ½ï¼Œç®€åŒ–ä¸ºçº¯AIæå–

        // AIè®°å¿†æå–åŠŸèƒ½ï¼ˆä¸¥æ ¼çš„æ ¸å¿ƒè®°å¿†ï¼‰
        async function extractMemoriesWithAI(characterId, messages, contextId = null) {
            if (!messages || messages.length === 0) return;

            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;

                // ğŸ”¥ã€ä¿®å¤ã€‘å¦‚æœæ²¡æœ‰æä¾›contextIdï¼Œä½¿ç”¨characterIdä½œä¸ºé»˜è®¤å€¼ï¼ˆå•èŠï¼‰
                if (!contextId) {
                    contextId = characterId;
                }

                // æ„å»ºæ›´ä¸¥æ ¼çš„è®°å¿†æå–promptï¼Œç»Ÿä¸€ä½¿ç”¨ç¬¬ä¸‰äººç§°
                const extractPrompt = `
# è®°å¿†æå–ä»»åŠ¡

ä½ éœ€è¦ä»ä»¥ä¸‹å¯¹è¯ä¸­æå–ä¸¤ç±»è®°å¿†ï¼šæ ¸å¿ƒè®°å¿†å’Œæƒ…æ™¯è®°å¿†ã€‚

## è§’è‰²ä¿¡æ¯
- è§’è‰²åç§°: ${character.name}
- è§’è‰²è®¾å®š: ${character.bio || 'æ— ç‰¹æ®Šè®¾å®š'}

## å¯¹è¯å†…å®¹
${messages.map(msg => {
    const sender = msg.sender === 'sent' ? 'ç”¨æˆ·' : character.name;
    const content = typeof msg.content === 'string' ? msg.content : '[å›¾ç‰‡/æ–‡ä»¶]';
    return `${sender}: ${content}`;
}).join('\n')}

## æå–æ ‡å‡†

### æ ¸å¿ƒè®°å¿†ï¼ˆimportance >= 0.9ï¼‰
åªæœ‰ä»¥ä¸‹ç±»å‹çš„ä¿¡æ¯æ‰èƒ½æˆä¸ºæ ¸å¿ƒè®°å¿†ï¼š
- ç”¨æˆ·çš„åŸºæœ¬ä¿¡æ¯ï¼šçœŸå®å§“åã€ç”Ÿæ—¥ã€èŒä¸šã€å®¶åº­æˆå‘˜
- é‡å¤§æƒ…æ„Ÿè½¬å˜ï¼šè¡¨ç™½ã€åˆ†æ‰‹ã€å’Œå¥½ã€æ·±åº¦æƒ…æ„Ÿäº¤æµ
- é‡è¦æ‰¿è¯ºå’Œçº¦å®šï¼šé•¿æœŸè®¡åˆ’ã€é‡è¦çº¦å®š
- å…³é”®äººç”Ÿäº‹ä»¶ï¼šæ¯•ä¸šã€å·¥ä½œå˜åŠ¨ã€æ¬å®¶ã€é‡è¦çºªå¿µæ—¥
- è§’è‰²ä¸ç”¨æˆ·å…³ç³»çš„é‡å¤§å˜åŒ–

### æƒ…æ™¯è®°å¿†ï¼ˆimportance 0.6-0.8ï¼‰
æ—¥å¸¸ä½†æœ‰æ„ä¹‰çš„äº‹ä»¶ï¼š
- ä¸€èµ·åšçš„æ´»åŠ¨å’Œä½“éªŒ
- ç”¨æˆ·çš„ä¹ æƒ¯å’Œåå¥½
- æœ‰è¶£çš„å¯¹è¯å’Œäº’åŠ¨
- æ—¥å¸¸ç”Ÿæ´»çš„åˆ†äº«

## é‡è¦è¦æ±‚ï¼šè®°å¿†æè¿°å¿…é¡»ä½¿ç”¨ç¬¬ä¸‰äººç§°
- ç”¨"ç”¨æˆ·"æŒ‡ä»£ç”¨æˆ·ï¼Œç”¨"${character.name}"æŒ‡ä»£è§’è‰²
- ä¸è¦ä½¿ç”¨"æˆ‘"ã€"ä½ "ç­‰ç¬¬ä¸€ã€ç¬¬äºŒäººç§°
- ä¾‹å¦‚ï¼š"ç”¨æˆ·å‘Šè¯‰${character.name}è‡ªå·±çš„ç”Ÿæ—¥æ˜¯..."è€Œä¸æ˜¯"æˆ‘çš„ç”Ÿæ—¥æ˜¯..."

è¯·ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹JSONæ ¼å¼è¿”å›ï¼Œä¸è¦æ·»åŠ ä»»ä½•å…¶ä»–æ–‡å­—ï¼š

{
  "core_memories": [
    {"fact": "ç®€æ´çš„æ ¸å¿ƒäº‹å®ï¼ˆä½¿ç”¨ç¬¬ä¸‰äººç§°ï¼‰", "importance": 0.9, "category": "ç±»åˆ«"}
  ],
  "episodic_memories": [
    {"fact": "æƒ…æ™¯æè¿°ï¼ˆä½¿ç”¨ç¬¬ä¸‰äººç§°ï¼‰", "importance": 0.7, "category": "ç±»åˆ«"}
  ]
}

æ³¨æ„ï¼š
1. åªè¿”å›JSONï¼Œä¸è¦æœ‰ä»»ä½•è§£é‡Šæ–‡å­—
2. å¦‚æœæ²¡æœ‰ç¬¦åˆæ ‡å‡†çš„è®°å¿†ï¼Œå¯¹åº”æ•°ç»„ä¸ºç©º
3. importanceå¿…é¡»æ˜¯æ•°å­—ï¼Œä¸è¦ç”¨å­—ç¬¦ä¸²
4. ç¡®ä¿JSONæ ¼å¼å®Œå…¨æ­£ç¡®
5. æ‰€æœ‰factå­—æ®µå¿…é¡»ä½¿ç”¨ç¬¬ä¸‰äººç§°æè¿°`;

                // è°ƒç”¨AIæå–æ ¸å¿ƒè®°å¿†
                const response = await callChatAPI(extractPrompt, character);
                let memories = [];

                try {
                    // å°è¯•è§£æJSONå“åº”
                    const responseText = Array.isArray(response) ? response[0] : response;
                    if (responseText && typeof responseText === 'string') {
                        console.log('ğŸ” AIè®°å¿†æå–åŸå§‹å“åº”:', responseText);

                        // å¤šç§æ–¹å¼å°è¯•æå–JSON
                        let jsonText = null;

                        // æ–¹å¼1: æå–å®Œæ•´çš„JSONå¯¹è±¡
                        const jsonObjectMatch = responseText.match(/\{[\s\S]*\}/);
                        if (jsonObjectMatch) {
                            jsonText = jsonObjectMatch[0];
                        } else {
                            // æ–¹å¼2: æå–JSONæ•°ç»„
                            const jsonArrayMatch = responseText.match(/\[[\s\S]*\]/);
                            if (jsonArrayMatch) {
                                jsonText = jsonArrayMatch[0];
                            }
                        }

                        if (jsonText) {
                            console.log('ğŸ” æå–çš„JSONæ–‡æœ¬:', jsonText);
                            memories = JSON.parse(jsonText);
                        } else {
                            console.warn('âš ï¸ æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ ¼å¼');
                            return; // å¦‚æœæ²¡æœ‰æ‰¾åˆ°JSONï¼Œç›´æ¥è¿”å›
                        }
                    }
                } catch (parseError) {
                    console.warn('è§£ææ ¸å¿ƒè®°å¿†JSONå¤±è´¥:', parseError);
                    console.warn('åŸå§‹å“åº”:', responseText);
                    return; // è§£æå¤±è´¥æ—¶ç›´æ¥è¿”å›ï¼Œé¿å…åç»­é”™è¯¯
                    return;
                }

                // è·å–ç°æœ‰çš„è®°å¿†ï¼Œæ£€æŸ¥é‡å¤
                const [existingCoreMemories, existingEpisodicMemories] = await Promise.all([
                    db.coreMemories.where('characterId').equals(characterId).toArray(),
                    db.episodicMemories.where('characterId').equals(characterId).toArray()
                ]);

                // ğŸ”¥ã€ä¿®å¤ã€‘å¤„ç†æ ¸å¿ƒè®°å¿†
                if (memories.core_memories && Array.isArray(memories.core_memories)) {
                    for (const memory of memories.core_memories) {
                        if (memory.importance >= MEMORY_CONFIG.CORE_MEMORY_IMPORTANCE_THRESHOLD) {
                            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸ä¼¼çš„è®°å¿†
                            const isDuplicate = existingCoreMemories.some(existing => {
                                const similarity = calculateTextSimilarity(existing.fact, memory.fact);
                                return similarity > 0.8; // ç›¸ä¼¼åº¦è¶…è¿‡80%è®¤ä¸ºæ˜¯é‡å¤
                            });

                            if (!isDuplicate) {
                                const coreMemory = {
                                    id: `core_${characterId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                    characterId: characterId,
                                    fact: memory.fact,
                                    importance: memory.importance,
                                    category: memory.category || 'other',
                                    timestamp: Date.now(),
                                    type: 'core',
                                    contextId: contextId // ğŸ”¥ã€ä¿®å¤ã€‘æ·»åŠ ä¸Šä¸‹æ–‡IDç”¨äºè®°å¿†éš”ç¦»
                                };

                                await db.coreMemories.add(coreMemory);
                                console.log(`âœ… ä¸ºè§’è‰² ${character.name} æ·»åŠ æ ¸å¿ƒè®°å¿†: ${memory.fact}`);
                            } else {
                                console.log(`âš ï¸ è·³è¿‡é‡å¤æ ¸å¿ƒè®°å¿†: ${memory.fact}`);
                            }
                        }
                    }
                }

                // ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†æƒ…æ™¯è®°å¿†
                if (memories.episodic_memories && Array.isArray(memories.episodic_memories)) {
                    for (const memory of memories.episodic_memories) {
                        if (memory.importance >= MEMORY_CONFIG.EPISODIC_MEMORY_IMPORTANCE_THRESHOLD) {
                            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸ä¼¼çš„è®°å¿†
                            const isDuplicate = existingEpisodicMemories.some(existing => {
                                const similarity = calculateTextSimilarity(existing.fact, memory.fact);
                                return similarity > 0.8; // ç›¸ä¼¼åº¦è¶…è¿‡80%è®¤ä¸ºæ˜¯é‡å¤
                            });

                            if (!isDuplicate) {
                                const episodicMemory = {
                                    id: `episodic_${characterId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                    characterId: characterId,
                                    fact: memory.fact,
                                    importance: memory.importance,
                                    category: memory.category || 'other',
                                    timestamp: Date.now(),
                                    contextId: contextId // ğŸ”¥ã€ä¿®å¤ã€‘æ·»åŠ ä¸Šä¸‹æ–‡IDç”¨äºè®°å¿†éš”ç¦»
                                };

                                await db.episodicMemories.add(episodicMemory);
                                console.log(`âœ… ä¸ºè§’è‰² ${character.name} æ·»åŠ æƒ…æ™¯è®°å¿†: ${memory.fact}`);
                            } else {
                                console.log(`âš ï¸ è·³è¿‡é‡å¤æƒ…æ™¯è®°å¿†: ${memory.fact}`);
                            }
                        }
                    }
                }

                // æ¸…ç†è¿‡å¤šçš„è®°å¿†
                await cleanupCoreMemories(characterId);
                await cleanupEpisodicMemories(characterId);

            } catch (error) {
                console.error('æå–æ ¸å¿ƒè®°å¿†å¤±è´¥:', error);
            }
        }

        // æ¸…ç†è¿‡å¤šçš„æ ¸å¿ƒè®°å¿†ï¼Œä¿ç•™æœ€é‡è¦çš„
        async function cleanupCoreMemories(characterId) {
            try {
                const allMemories = await db.coreMemories
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                const memories = allMemories.sort((a, b) => b.importance - a.importance);
                const maxCoreMemories = MEMORY_CONFIG.MAX_CORE_MEMORIES_PER_CHARACTER || 50;

                if (memories.length > maxCoreMemories) {
                    const toDelete = memories.slice(maxCoreMemories);
                    for (const memory of toDelete) {
                        await db.coreMemories.delete(memory.id);
                    }
                    console.log(`ğŸ§¹ æ¸…ç†äº† ${toDelete.length} ä¸ªä½é‡è¦æ€§çš„æ ¸å¿ƒè®°å¿†`);
                }
            } catch (error) {
                console.error('æ¸…ç†æ ¸å¿ƒè®°å¿†å¤±è´¥:', error);
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ¸…ç†è¿‡å¤šçš„æƒ…æ™¯è®°å¿†ï¼Œä¿ç•™æœ€é‡è¦å’Œæœ€æ–°çš„
        async function cleanupEpisodicMemories(characterId) {
            try {
                const allMemories = await db.episodicMemories
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                // æŒ‰é‡è¦æ€§å’Œæ—¶é—´æ’åºï¼Œä¿ç•™æœ€é‡è¦å’Œæœ€æ–°çš„è®°å¿†
                const memories = allMemories.sort((a, b) => {
                    // å…ˆæŒ‰é‡è¦æ€§æ’åºï¼Œå†æŒ‰æ—¶é—´æ’åº
                    if (Math.abs(a.importance - b.importance) > 0.1) {
                        return b.importance - a.importance;
                    }
                    return b.timestamp - a.timestamp;
                });

                const maxEpisodicMemories = MEMORY_CONFIG.MAX_EPISODIC_MEMORIES_PER_CHARACTER || 100;

                if (memories.length > maxEpisodicMemories) {
                    const toDelete = memories.slice(maxEpisodicMemories);
                    for (const memory of toDelete) {
                        await db.episodicMemories.delete(memory.id);
                    }
                    console.log(`ğŸ§¹ æ¸…ç†äº† ${toDelete.length} ä¸ªæ—§çš„æƒ…æ™¯è®°å¿†`);
                }
            } catch (error) {
                console.error('æ¸…ç†æƒ…æ™¯è®°å¿†å¤±è´¥:', error);
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘è‡ªåŠ¨æ¸…ç†è¿‡æœŸçš„æ—¶é—´çº¿è®°å¿†å’Œè®°å¿†æ‘˜è¦
        async function cleanupExpiredMemories() {
            try {
                const memorySettings = getGlobalMemorySettings();
                const cutoffTimestamp = Date.now() - (memorySettings.memoryDays * 24 * 60 * 60 * 1000);
                const cutoffDateStr = new Date(cutoffTimestamp).toISOString().split('T')[0];

                // æ¸…ç†è¿‡æœŸçš„æ—¶é—´çº¿è®°å¿†
                const expiredTimelineEvents = await db.crossAppTimeline
                    .where('timestamp')
                    .below(cutoffTimestamp)
                    .toArray();

                if (expiredTimelineEvents.length > 0) {
                    await db.crossAppTimeline
                        .where('timestamp')
                        .below(cutoffTimestamp)
                        .delete();
                    console.log(`ğŸ§¹ æ¸…ç†äº† ${expiredTimelineEvents.length} æ¡è¿‡æœŸçš„æ—¶é—´çº¿è®°å¿†`);
                }

                // æ¸…ç†è¿‡æœŸçš„è®°å¿†æ‘˜è¦
                const expiredSummaries = await db.memorySummaries
                    .where('date')
                    .below(cutoffDateStr)
                    .toArray();

                if (expiredSummaries.length > 0) {
                    await db.memorySummaries
                        .where('date')
                        .below(cutoffDateStr)
                        .delete();
                    console.log(`ğŸ§¹ æ¸…ç†äº† ${expiredSummaries.length} æ¡è¿‡æœŸçš„è®°å¿†æ‘˜è¦`);
                }

                // æ¸…ç†è¿‡æœŸçš„æƒ…æ™¯è®°å¿†
                const expiredEpisodicMemories = await db.episodicMemories
                    .where('timestamp')
                    .below(cutoffTimestamp)
                    .toArray();

                if (expiredEpisodicMemories.length > 0) {
                    await db.episodicMemories
                        .where('timestamp')
                        .below(cutoffTimestamp)
                        .delete();
                    console.log(`ğŸ§¹ æ¸…ç†äº† ${expiredEpisodicMemories.length} æ¡è¿‡æœŸçš„æƒ…æ™¯è®°å¿†`);
                }

            } catch (error) {
                console.error('æ¸…ç†è¿‡æœŸè®°å¿†å¤±è´¥:', error);
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘å®šæœŸæ¸…ç†è¿‡æœŸè®°å¿†ï¼ˆæ¯å°æ—¶æ‰§è¡Œä¸€æ¬¡ï¼‰
        setInterval(cleanupExpiredMemories, 60 * 60 * 1000); // 1å°æ—¶

        // é¡µé¢åŠ è½½æ—¶æ‰§è¡Œä¸€æ¬¡æ¸…ç†
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(cleanupExpiredMemories, 5000); // å»¶è¿Ÿ5ç§’æ‰§è¡Œï¼Œé¿å…å½±å“é¡µé¢åŠ è½½
        });

        // è·å–è§’è‰²çš„æ ¸å¿ƒè®°å¿†ç”¨äºå¯¹è¯
        async function getCoreMemoriesForChat(characterId, limit = 10) {
            try {
                const allMemories = await db.coreMemories
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                const memories = allMemories
                    .sort((a, b) => b.importance - a.importance)
                    .slice(0, limit);

                return memories.map(m => m.fact).join('\n');
            } catch (error) {
                console.error('è·å–æ ¸å¿ƒè®°å¿†å¤±è´¥:', error);
                return '';
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ£€æŸ¥è§’è‰²æ˜¯å¦åº”è¯¥è®°å½•ç¾¤èŠè®°å¿†çš„å‡½æ•°
        async function shouldRecordGroupMemoryForCharacter(characterId, groupId) {
            try {
                // è·å–è¯¥è§’è‰²çš„å•èŠè®¾ç½®
                const characterChatSettings = await getAsyncChatSettings(characterId);
                const sharedGroupIds = characterChatSettings.memorySharedGroupIds || [];

                // æ£€æŸ¥è¯¥ç¾¤èŠæ˜¯å¦åœ¨è§’è‰²çš„å…±äº«ç¾¤èŠåˆ—è¡¨ä¸­
                const shouldRecord = sharedGroupIds.includes(groupId);

                console.log(`ğŸ” è®°å¿†å…±äº«æ£€æŸ¥ - è§’è‰²: ${characterId}, ç¾¤èŠ: ${groupId}, åº”è®°å½•: ${shouldRecord}`);
                console.log(`ğŸ” è§’è‰²çš„å…±äº«ç¾¤èŠåˆ—è¡¨:`, sharedGroupIds);

                return shouldRecord;
            } catch (error) {
                console.warn('æ£€æŸ¥è®°å¿†å…±äº«è®¾ç½®å¤±è´¥:', error);
                // å‡ºé”™æ—¶é»˜è®¤ä¸è®°å½•ï¼Œé¿å…æ„å¤–çš„è®°å¿†æ³„éœ²
                return false;
            }
        }

        // è·¨åº”ç”¨æ—¶é—´çº¿è®°å½•åŠŸèƒ½
        async function recordCrossAppEvent(characterId, appType, action, context, messageId = null) {
            try {
                // ğŸ”¥ã€ä¿®å¤ã€‘éªŒè¯å¿…éœ€å‚æ•°
                if (!characterId || !appType || !action) {
                    console.error('âŒ è®°å½•äº‹ä»¶å¤±è´¥: ç¼ºå°‘å¿…éœ€å‚æ•°', {
                        characterId,
                        appType,
                        action
                    });
                    return;
                }

                // ğŸ”¥ã€ä¿®å¤ã€‘ç¡®ä¿contextæ˜¯æœ‰æ•ˆå¯¹è±¡
                const validContext = context && typeof context === 'object' ? context : {};

                // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘ç”Ÿæˆæ›´ç®€å•å¯é çš„ID
                const timestamp = Date.now();
                const randomSuffix = Math.random().toString(36).substring(2, 8);
                const eventId = `${characterId}_${appType}_${action}_${timestamp}_${randomSuffix}`;

                const timelineEvent = {
                    id: eventId,
                    characterId: String(characterId), // ç¡®ä¿æ˜¯å­—ç¬¦ä¸²
                    appType: String(appType),
                    action: String(action),
                    timestamp: timestamp,
                    context: validContext,
                    messageId: messageId ? String(messageId) : null
                };

                // ğŸ”¥ã€ä¿®å¤ã€‘éªŒè¯æ‰€æœ‰å¿…éœ€å­—æ®µ
                if (!timelineEvent.id || !timelineEvent.characterId || !timelineEvent.appType || !timelineEvent.action) {
                    console.error('âŒ è®°å½•äº‹ä»¶å¤±è´¥: å¿…éœ€å­—æ®µç¼ºå¤±', timelineEvent);
                    return;
                }

                // ğŸ”¥ã€æ–°å¢ã€‘éªŒè¯æ•°æ®åº“è¿æ¥
                if (!db || !db.crossAppTimeline) {
                    console.error('âŒ è®°å½•äº‹ä»¶å¤±è´¥: æ•°æ®åº“æœªåˆå§‹åŒ–');
                    return;
                }

                await db.crossAppTimeline.add(timelineEvent);
                console.log(`ğŸ“ è®°å½•æ—¶é—´çº¿äº‹ä»¶: ${appType}.${action}`, {
                    characterId: timelineEvent.characterId,
                    contextId: validContext.id,
                    contextType: validContext.type,
                    groupId: validContext.groupId || 'æ— ',
                    content: validContext.content?.substring(0, 30) + '...'
                });

            } catch (error) {
                console.error('âŒ è®°å½•äº‹ä»¶å¤±è´¥:', error);
                console.error('äº‹ä»¶æ•°æ®:', {characterId, appType, action, context, messageId});

                // ğŸ”¥ã€æ–°å¢ã€‘è¯¦ç»†é”™è¯¯ä¿¡æ¯
                if (error.name === 'DataError') {
                    console.error('æ•°æ®åº“é”®å€¼é”™è¯¯ï¼Œå¯èƒ½æ˜¯IDå­—æ®µé—®é¢˜');
                } else if (error.name === 'ConstraintError') {
                    console.error('æ•°æ®åº“çº¦æŸé”™è¯¯ï¼Œå¯èƒ½æ˜¯é‡å¤é”®å€¼');
                }
            }
        }

        // è·å–è§’è‰²çš„è·¨åº”ç”¨æ—¶é—´çº¿ï¼ˆç”¨äºæ„å»ºè¿ç»­çš„å·¥ä½œè®°å¿†ï¼‰
        async function getCrossAppTimeline(characterId, limit = 20) {
            try {
                const timeline = await db.crossAppTimeline
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                return timeline
                    .sort((a, b) => b.timestamp - a.timestamp)
                    .slice(0, limit);
            } catch (error) {
                console.error('è·å–è·¨åº”ç”¨æ—¶é—´çº¿å¤±è´¥:', error);
                return [];
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æŒ‰å›åˆè®¡ç®—å†å²æ¶ˆæ¯
        function calculateMessagesByRounds(messages, maxRounds) {
            if (!messages || messages.length === 0) return [];

            // ä»åå¾€å‰åˆ†ææ¶ˆæ¯ï¼ŒæŒ‰å›åˆåˆ†ç»„
            const rounds = [];
            let currentRound = [];
            let lastSender = null;

            // ä»æœ€æ–°æ¶ˆæ¯å¼€å§‹å¾€å‰åˆ†æ
            for (let i = messages.length - 1; i >= 0; i--) {
                const msg = messages[i];
                const currentSender = msg.sender;

                // å¦‚æœå‘é€è€…æ”¹å˜ï¼Œæˆ–è€…æ˜¯ç³»ç»Ÿæ¶ˆæ¯ï¼Œå¼€å§‹æ–°å›åˆ
                if (currentSender !== lastSender || currentSender === 'system') {
                    if (currentRound.length > 0) {
                        rounds.unshift(currentRound); // æ·»åŠ åˆ°å¼€å¤´
                        currentRound = [];
                    }
                }

                currentRound.unshift(msg); // æ·»åŠ åˆ°å½“å‰å›åˆçš„å¼€å¤´
                lastSender = currentSender;

                // å¦‚æœå·²ç»æ”¶é›†äº†è¶³å¤Ÿçš„å›åˆï¼Œåœæ­¢
                if (rounds.length >= maxRounds) {
                    break;
                }
            }

            // æ·»åŠ æœ€åä¸€ä¸ªå›åˆ
            if (currentRound.length > 0 && rounds.length < maxRounds) {
                rounds.unshift(currentRound);
            }

            // åªä¿ç•™æŒ‡å®šæ•°é‡çš„å›åˆ
            const selectedRounds = rounds.slice(-maxRounds);

            // å°†å›åˆå±•å¹³ä¸ºæ¶ˆæ¯åˆ—è¡¨
            return selectedRounds.flat();
        }

        // ğŸ”¥ã€æ–°å¢ã€‘è®¡ç®—å®é™…å›åˆæ•°
        function countActualRounds(messages) {
            if (!messages || messages.length === 0) return 0;

            let rounds = 0;
            let lastSender = null;

            for (const msg of messages) {
                const currentSender = msg.sender;

                // å¦‚æœå‘é€è€…æ”¹å˜ï¼Œæˆ–è€…æ˜¯ç³»ç»Ÿæ¶ˆæ¯ï¼Œè®¡ä¸ºæ–°å›åˆ
                if (currentSender !== lastSender || currentSender === 'system') {
                    rounds++;
                }

                lastSender = currentSender;
            }

            return rounds;
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æŸ¥çœ‹çº¿ä¸‹å‰§æƒ…æ€»ç»“çš„å®Œæ•´å†…å®¹
        async function viewStorylineSummary(memoryId) {
            try {
                const memory = await db.crossAppTimeline.get(memoryId);
                if (!memory || memory.action !== 'storyline_summary') {
                    showToast('æ‰¾ä¸åˆ°è¯¥å‰§æƒ…æ€»ç»“', 'error');
                    return;
                }

                // ä½¿ç”¨å®Œæ•´å†…å®¹è€Œä¸æ˜¯é¢„è§ˆå†…å®¹
                const content = memory.context?.content || memory.fullContent || 'æ— å†…å®¹';
                const date = memory.context?.date || 'æœªçŸ¥æ—¥æœŸ';
                const messageCount = memory.context?.messageCount || 0;

                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 600px; max-height: 80vh; overflow-y: auto;">
                        <div class="modal-header">
                            <h3>çº¿ä¸‹å‰§æƒ…æ€»ç»“</h3>
                            <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">Ã—</button>
                        </div>
                        <div class="modal-body">
                            <div style="margin-bottom: 15px; color: #666; font-size: 14px;">
                                <div>æ—¥æœŸ: ${date}</div>
                                <div>æ¶ˆæ¯æ•°: ${messageCount}æ¡</div>
                            </div>
                            <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; line-height: 1.6; white-space: pre-wrap;">${content}</div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-primary" onclick="editStorylineSummary('${memoryId}'); this.closest('.modal-overlay').remove();">ç¼–è¾‘</button>
                            <button class="btn btn-secondary" onclick="this.closest('.modal-overlay').remove()">å…³é—­</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);
            } catch (error) {
                console.error('æŸ¥çœ‹å‰§æƒ…æ€»ç»“å¤±è´¥:', error);
                showToast('æŸ¥çœ‹å‰§æƒ…æ€»ç»“å¤±è´¥', 'error');
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘ç¼–è¾‘çº¿ä¸‹å‰§æƒ…æ€»ç»“
        async function editStorylineSummary(memoryId) {
            try {
                const memory = await db.crossAppTimeline.get(memoryId);
                if (!memory || memory.action !== 'storyline_summary') {
                    showToast('æ‰¾ä¸åˆ°è¯¥å‰§æƒ…æ€»ç»“', 'error');
                    return;
                }

                // ä½¿ç”¨å®Œæ•´å†…å®¹è€Œä¸æ˜¯é¢„è§ˆå†…å®¹
                const content = memory.context?.content || memory.fullContent || '';
                const date = memory.context?.date || 'æœªçŸ¥æ—¥æœŸ';
                const messageCount = memory.context?.messageCount || 0;

                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 700px; max-height: 80vh;">
                        <div class="modal-header">
                            <h3>ç¼–è¾‘çº¿ä¸‹å‰§æƒ…æ€»ç»“</h3>
                            <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">Ã—</button>
                        </div>
                        <div class="modal-body">
                            <div style="margin-bottom: 15px; color: #666; font-size: 14px;">
                                <div>æ—¥æœŸ: ${date}</div>
                                <div>æ¶ˆæ¯æ•°: ${messageCount}æ¡</div>
                                <div style="color: #999; font-size: 12px; margin-top: 5px;">æç¤º: ä¿®æ”¹åçš„å†…å®¹å°†åŒæ­¥åˆ°AIçš„å·¥ä½œè®°å¿†ä¸­</div>
                            </div>
                            <textarea id="storyline-summary-editor" style="width: 100%; height: 300px; padding: 15px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px; line-height: 1.6; resize: vertical;" placeholder="è¯·è¾“å…¥å‰§æƒ…æ€»ç»“...">${content}</textarea>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-primary" onclick="saveStorylineSummary('${memoryId}')">ä¿å­˜ä¿®æ”¹</button>
                            <button class="btn btn-secondary" onclick="this.closest('.modal-overlay').remove()">å–æ¶ˆ</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);

                // èšç„¦åˆ°æ–‡æœ¬æ¡†ä½†ä¸é€‰ä¸­å†…å®¹
                setTimeout(() => {
                    const textarea = document.getElementById('storyline-summary-editor');
                    if (textarea) {
                        textarea.focus();
                        // ğŸ”¥ã€ä¿®å¤ã€‘å°†å…‰æ ‡ç§»åˆ°æœ«å°¾ï¼Œä¸é€‰ä¸­ä»»ä½•å†…å®¹
                        textarea.setSelectionRange(textarea.value.length, textarea.value.length);
                    }
                }, 100);
            } catch (error) {
                console.error('ç¼–è¾‘å‰§æƒ…æ€»ç»“å¤±è´¥:', error);
                showToast('ç¼–è¾‘å‰§æƒ…æ€»ç»“å¤±è´¥', 'error');
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘ä¿å­˜ç¼–è¾‘åçš„çº¿ä¸‹å‰§æƒ…æ€»ç»“
        async function saveStorylineSummary(memoryId) {
            try {
                const textarea = document.getElementById('storyline-summary-editor');
                if (!textarea) {
                    showToast('æ‰¾ä¸åˆ°ç¼–è¾‘å™¨', 'error');
                    return;
                }

                const newContent = textarea.value.trim();
                if (!newContent) {
                    showToast('å‰§æƒ…æ€»ç»“ä¸èƒ½ä¸ºç©º', 'warning');
                    return;
                }

                // æ›´æ–°æ•°æ®åº“ä¸­çš„è®°å¿†
                const memory = await db.crossAppTimeline.get(memoryId);
                if (!memory) {
                    showToast('æ‰¾ä¸åˆ°è¯¥å‰§æƒ…æ€»ç»“', 'error');
                    return;
                }

                // æ›´æ–°å†…å®¹
                memory.context.content = newContent;
                memory.timestamp = Date.now(); // æ›´æ–°æ—¶é—´æˆ³ï¼Œè®©å®ƒåœ¨å·¥ä½œè®°å¿†ä¸­æ›´æ–°

                await db.crossAppTimeline.put(memory);

                // å…³é—­æ¨¡æ€æ¡†
                const modal = textarea.closest('.modal-overlay');
                if (modal) {
                    modal.remove();
                }

                // åˆ·æ–°è®°å¿†æŸ¥çœ‹å™¨
                if (currentMemoryCharacter) {
                    await loadCharacterMemories();
                }

                showToast('å‰§æƒ…æ€»ç»“å·²ä¿å­˜ï¼ŒAIå·¥ä½œè®°å¿†å·²åŒæ­¥æ›´æ–°', 'success');
                console.log('âœ… çº¿ä¸‹å‰§æƒ…æ€»ç»“å·²æ›´æ–°:', memory);
            } catch (error) {
                console.error('ä¿å­˜å‰§æƒ…æ€»ç»“å¤±è´¥:', error);
                showToast('ä¿å­˜å‰§æƒ…æ€»ç»“å¤±è´¥', 'error');
            }
        }

        // æ„å»ºè¿ç»­çš„å·¥ä½œè®°å¿†ï¼ˆåŒ…å«è·¨åº”ç”¨äº‹ä»¶ï¼ŒæŒ‰æ—¶é—´æ»šåŠ¨ï¼‰
        async function buildContinuousWorkingMemory(characterId, chatMessages, userSetLimit = 50) {
            try {
                // ğŸ”¥ã€å®‰å…¨æ£€æŸ¥ã€‘ç¡®ä¿chatMessagesæ˜¯æ•°ç»„
                if (!Array.isArray(chatMessages)) {
                    console.warn('buildContinuousWorkingMemory: chatMessagesä¸æ˜¯æ•°ç»„ï¼Œä½¿ç”¨ç©ºæ•°ç»„');
                    chatMessages = [];
                }

                // è·å–èŠå¤©æ¶ˆæ¯
                const messages = chatMessages.map(msg => ({
                    type: 'chat',
                    timestamp: msg.timestamp,
                    content: msg,
                    appType: 'chat',
                    characterId: characterId // ç¡®ä¿è§’è‰²éš”ç¦»
                }));

                // è·å–è¯¥è§’è‰²çš„è·¨åº”ç”¨æ—¶é—´çº¿ï¼ˆåªè·å–ä¸è¯¥è§’è‰²ç›¸å…³çš„ï¼‰
                const timeline = await db.crossAppTimeline
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                // ğŸ”¥ã€ä¿®å¤ã€‘æ­£ç¡®åŒºåˆ†èŠå¤©äº‹ä»¶å’Œè·¨åº”ç”¨äº‹ä»¶
                const timelineEvents = timeline
                    .filter(event => event.appType !== 'chat') // æ’é™¤èŠå¤©äº‹ä»¶ï¼Œé¿å…é‡å¤
                    .map(event => ({
                        type: 'cross_app',
                        timestamp: event.timestamp,
                        content: event,
                        appType: event.appType,
                        characterId: characterId
                    }));

                // åˆå¹¶æ‰€æœ‰äº‹ä»¶å¹¶æŒ‰æ—¶é—´æ’åº
                const allEvents = [...messages, ...timelineEvents]
                    .sort((a, b) => a.timestamp - b.timestamp);

                // ğŸ”¥ã€ä¿®å¤ã€‘æŒ‰å›åˆæ•°è€Œä¸æ˜¯æ¶ˆæ¯æ¡æ•°æ¥é™åˆ¶å·¥ä½œè®°å¿†
                // å…ˆæå–èŠå¤©æ¶ˆæ¯ï¼ŒæŒ‰å›åˆè®¡ç®—
                const chatEvents = allEvents.filter(event => event.type === 'chat');
                const extractedChatMessages = chatEvents.map(event => event.content);

                // æŒ‰å›åˆè®¡ç®—èŠå¤©æ¶ˆæ¯
                const recentChatMessages = calculateMessagesByRounds(extractedChatMessages, userSetLimit);

                // é‡æ–°åŒ…è£…ä¸ºäº‹ä»¶æ ¼å¼
                const recentChatEvents = recentChatMessages.map(msg => ({
                    type: 'chat',
                    timestamp: msg.timestamp,
                    content: msg,
                    appType: 'chat',
                    characterId: characterId
                }));

                // è·¨åº”ç”¨äº‹ä»¶æŒ‰æ—¶é—´èŒƒå›´è¿‡æ»¤ï¼ˆä¸èŠå¤©æ¶ˆæ¯çš„æ—¶é—´èŒƒå›´ä¸€è‡´ï¼‰
                const earliestChatTime = recentChatEvents.length > 0 ? recentChatEvents[0].timestamp : 0;
                const recentTimelineEvents = timelineEvents.filter(event => event.timestamp >= earliestChatTime);

                // åˆå¹¶å¹¶é‡æ–°æ’åº
                const recentEvents = [...recentChatEvents, ...recentTimelineEvents]
                    .sort((a, b) => a.timestamp - b.timestamp);

                return recentEvents;
            } catch (error) {
                console.error('æ„å»ºè¿ç»­å·¥ä½œè®°å¿†å¤±è´¥:', error);
                return chatMessages.map(msg => ({
                    type: 'chat',
                    timestamp: msg.timestamp,
                    content: msg,
                    appType: 'chat',
                    characterId: characterId
                }));
            }
        }

        // ä¸ºè§’è‰²ç”Ÿæˆè·¨åº”ç”¨è®°å¿†æè¿°
        async function generateCrossAppMemoryDescription(characterId, memoryEvent) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;

                let memoryDescription = '';
                const context = memoryEvent.context;

                switch (memoryEvent.eventType) {
                    case 'music_interaction':
                        if (context.action === 'listen_together') {
                            memoryDescription = `å’Œç”¨æˆ·ä¸€èµ·å¬äº†ã€Š${context.songTitle}ã€‹ï¼Œ${context.duration || ''}`;
                        } else if (context.action === 'song_comment') {
                            memoryDescription = `å¯¹æ­Œæ›²ã€Š${context.songTitle}ã€‹å‘è¡¨äº†çœ‹æ³•ï¼š${context.comment}`;
                        }
                        break;

                    case 'game_interaction':
                        if (context.action === 'play_together') {
                            memoryDescription = `å’Œç”¨æˆ·ä¸€èµ·ç©äº†${context.gameName}ï¼Œ${context.result || ''}`;
                        } else if (context.action === 'game_comment') {
                            memoryDescription = `å¯¹æ¸¸æˆ${context.gameName}å‘è¡¨äº†çœ‹æ³•ï¼š${context.comment}`;
                        }
                        break;

                    case 'forum_interaction':
                        if (context.action === 'post_comment') {
                            memoryDescription = `åœ¨è®ºå›å‘è¡¨äº†è¯„è®ºï¼š${context.comment}`;
                        } else if (context.action === 'topic_discussion') {
                            memoryDescription = `å‚ä¸äº†å…³äº"${context.topic}"çš„è®¨è®º`;
                        }
                        break;
                }

                if (memoryDescription) {
                    // å°†è·¨åº”ç”¨è®°å¿†ä½œä¸ºæ ¸å¿ƒè®°å¿†ä¿å­˜
                    const coreMemory = {
                        id: `cross_${characterId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                        characterId: characterId,
                        fact: memoryDescription,
                        importance: 0.6, // è·¨åº”ç”¨è®°å¿†çš„é»˜è®¤é‡è¦æ€§
                        category: 'cross_app',
                        timestamp: Date.now(),
                        sourceEvent: memoryEvent.id
                    };

                    await db.coreMemories.add(coreMemory);
                    console.log(`âœ… ä¸ºè§’è‰² ${character.name} æ·»åŠ è·¨åº”ç”¨è®°å¿†: ${memoryDescription}`);
                }

            } catch (error) {
                console.error('ç”Ÿæˆè·¨åº”ç”¨è®°å¿†æè¿°å¤±è´¥:', error);
            }
        }

        // è·å–è§’è‰²çš„è·¨åº”ç”¨è®°å¿†
        async function getCrossAppMemories(characterId, limit = 5) {
            try {
                const allMemories = await db.coreMemories
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                const crossAppMemories = allMemories
                    .filter(memory => memory.category === 'cross_app')
                    .sort((a, b) => b.timestamp - a.timestamp)
                    .slice(0, limit);

                return crossAppMemories.map(m => m.fact);
            } catch (error) {
                console.error('è·å–è·¨åº”ç”¨è®°å¿†å¤±è´¥:', error);
                return [];
            }
        }

        // æ¸…ç†é‡å¤è®°å¿†çš„åŠŸèƒ½
        async function cleanupDuplicateMemories(characterId) {
            try {
                const memories = await db.coreMemories
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                const duplicates = [];

                for (let i = 0; i < memories.length; i++) {
                    for (let j = i + 1; j < memories.length; j++) {
                        const similarity = calculateTextSimilarity(memories[i].fact, memories[j].fact);
                        if (similarity > 0.8) {
                            // ä¿ç•™é‡è¦æ€§æ›´é«˜çš„ï¼Œåˆ é™¤é‡è¦æ€§è¾ƒä½çš„
                            const toDelete = memories[i].importance >= memories[j].importance ? memories[j] : memories[i];
                            if (!duplicates.find(d => d.id === toDelete.id)) {
                                duplicates.push(toDelete);
                            }
                        }
                    }
                }

                for (const duplicate of duplicates) {
                    await db.coreMemories.delete(duplicate.id);
                    console.log(`ğŸ§¹ åˆ é™¤é‡å¤è®°å¿†: ${duplicate.fact}`);
                }

                if (duplicates.length > 0) {
                    console.log(`âœ… æ¸…ç†äº† ${duplicates.length} æ¡é‡å¤è®°å¿†`);
                }
            } catch (error) {
                console.error('æ¸…ç†é‡å¤è®°å¿†å¤±è´¥:', error);
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ¸…ç†é”™è¯¯çš„è·¨åº”ç”¨æ—¶é—´çº¿è®°å½•
        async function cleanupIncorrectTimelineRecords() {
            try {
                console.log('ğŸ§¹ å¼€å§‹æ¸…ç†é”™è¯¯çš„è·¨åº”ç”¨æ—¶é—´çº¿è®°å½•...');

                // åˆ é™¤æ‰€æœ‰ appType ä¸º 'chat' çš„è®°å½•ï¼ˆè¿™äº›åº”è¯¥åªå­˜åœ¨äºèŠå¤©è®°å½•ä¸­ï¼‰
                const chatRecords = await db.crossAppTimeline
                    .where('appType')
                    .equals('chat')
                    .toArray();

                for (const record of chatRecords) {
                    await db.crossAppTimeline.delete(record.id);
                }

                console.log(`âœ… æ¸…ç†å®Œæˆï¼Œåˆ é™¤äº† ${chatRecords.length} æ¡é”™è¯¯çš„èŠå¤©è®°å½•`);
                return chatRecords.length;

            } catch (error) {
                console.error('æ¸…ç†é”™è¯¯è®°å½•å¤±è´¥:', error);
                return 0;
            }
        }

        // ğŸ”ã€æ–°å¢ã€‘è®°å¿†ä½¿ç”¨æƒ…å†µç»Ÿè®¡å‡½æ•°
        async function logMemoryUsageStats(character, scenario) {
            try {
                const characterId = character.isGroup ? 'group' : character.id;
                const memorySettings = getGlobalMemorySettings();

                console.log(`\nğŸ“Š ===== è®°å¿†ä½¿ç”¨ç»Ÿè®¡ (${scenario}) =====`);
                console.log(`ğŸ­ è§’è‰²: ${character.name} (${character.isGroup ? 'ç¾¤èŠ' : 'å•èŠ'})`);
                console.log(`â° è®°å¿†å¤©æ•°è®¾ç½®: ${memorySettings.memoryDays}å¤©`);

                if (character.isGroup) {
                    // ç¾¤èŠï¼šç»Ÿè®¡æ¯ä¸ªæˆå‘˜çš„è®°å¿†
                    for (const member of character.members) {
                        await logSingleCharacterMemoryStats(member.id, member.name, memorySettings.memoryDays);
                    }
                } else {
                    // å•èŠï¼šç»Ÿè®¡å•ä¸ªè§’è‰²çš„è®°å¿†
                    await logSingleCharacterMemoryStats(character.id, character.name, memorySettings.memoryDays);
                }

                console.log(`ğŸ“Š ===== è®°å¿†ç»Ÿè®¡ç»“æŸ =====\n`);

            } catch (error) {
                console.error('è®°å¿†ç»Ÿè®¡å¤±è´¥:', error);
            }
        }

        // ğŸ”ã€æ–°å¢ã€‘å•ä¸ªè§’è‰²çš„è®°å¿†ç»Ÿè®¡
        async function logSingleCharacterMemoryStats(characterId, characterName, memoryDays) {
            try {
                // 1. æ ¸å¿ƒè®°å¿†ç»Ÿè®¡
                const coreMemories = await db.coreMemories
                    .where('characterId')
                    .equals(characterId)
                    .toArray();
                const limitedCoreMemories = coreMemories.slice(0, 10);

                // 2. æƒ…æ™¯è®°å¿†ç»Ÿè®¡
                const cutoffTimestamp = Date.now() - (memoryDays * 24 * 60 * 60 * 1000);
                const episodicMemories = await db.episodicMemories
                    .where('characterId')
                    .equals(characterId)
                    .and(memory => memory.timestamp >= cutoffTimestamp)
                    .toArray();
                const limitedEpisodicMemories = episodicMemories.slice(0, 15);

                // 3. æ—¶é—´çº¿è®°å¿†ç»Ÿè®¡
                const timelineMemories = await db.crossAppTimeline
                    .where('characterId')
                    .equals(characterId)
                    .and(event => event.timestamp >= cutoffTimestamp)
                    .toArray();
                const limitedTimelineMemories = timelineMemories.slice(0, 20);

                // 4. å¯¹è¯æ‘˜è¦ç»Ÿè®¡
                const cutoffDateStr = new Date(cutoffTimestamp).toISOString().split('T')[0];
                const memorySummaries = await db.memorySummaries
                    .where('characterId')
                    .equals(characterId)
                    .and(summary => summary.date >= cutoffDateStr)
                    .toArray();
                const limitedMemorySummaries = memorySummaries.slice(0, 10);

                // 5. è®¡ç®—æ€»tokenä¼°ç®—ï¼ˆæŒ‰æ¯ä¸ªä¸­æ–‡å­—ç¬¦1.5tokenè®¡ç®—ï¼‰
                const coreMemoryTokens = limitedCoreMemories.reduce((sum, m) => sum + (m.fact?.length || 0), 0) * 1.5;
                const episodicMemoryTokens = limitedEpisodicMemories.reduce((sum, m) => sum + (m.fact?.length || 0), 0) * 1.5;
                const timelineMemoryTokens = limitedTimelineMemories.reduce((sum, m) => sum + (m.context?.content?.length || 0), 0) * 1.5;
                const summaryMemoryTokens = limitedMemorySummaries.reduce((sum, m) => sum + (m.summary?.length || 0), 0) * 1.5;
                const totalMemoryTokens = coreMemoryTokens + episodicMemoryTokens + timelineMemoryTokens + summaryMemoryTokens;

                console.log(`\nğŸ‘¤ ${characterName} (ID: ${characterId}):`);
                console.log(`  ğŸ”´ æ ¸å¿ƒè®°å¿†: ${limitedCoreMemories.length}æ¡ (æ€»åº“å­˜: ${coreMemories.length}æ¡) ~${Math.round(coreMemoryTokens)}tokens`);
                console.log(`  ğŸŸ  æƒ…æ™¯è®°å¿†: ${limitedEpisodicMemories.length}æ¡ (æ€»åº“å­˜: ${episodicMemories.length}æ¡) ~${Math.round(episodicMemoryTokens)}tokens`);
                console.log(`  ğŸŸ£ æ—¶é—´çº¿è®°å¿†: ${limitedTimelineMemories.length}æ¡ (æ€»åº“å­˜: ${timelineMemories.length}æ¡) ~${Math.round(timelineMemoryTokens)}tokens`);
                console.log(`  ğŸ”µ å¯¹è¯æ‘˜è¦: ${limitedMemorySummaries.length}æ¡ (æ€»åº“å­˜: ${memorySummaries.length}æ¡) ~${Math.round(summaryMemoryTokens)}tokens`);
                console.log(`  ğŸ’° è®°å¿†æ€»æ¶ˆè€—: ~${Math.round(totalMemoryTokens)}tokens`);

                // 6. æ£€æŸ¥æ˜¯å¦ç®—åœ¨å·¥ä½œè®°å¿†ä¸­
                // 7. æ£€æŸ¥è·¨åº”ç”¨å·¥ä½œè®°å¿†é›†æˆ
                const userHistoryLimit = getCurrentChatSettings().historyCount || 5;
                const crossAppInWorkingMemory = Math.floor(userHistoryLimit * 0.3);
                const chatInWorkingMemory = userHistoryLimit - crossAppInWorkingMemory;

                console.log(`  âš ï¸  æ³¨æ„: è¿™äº›è®°å¿†æ˜¯é¢å¤–æ·»åŠ çš„ï¼Œä¸å ç”¨ç”¨æˆ·è®¾ç½®çš„"é™„å¸¦å†å²æ¶ˆæ¯æ•°"é…é¢`);
                console.log(`  ğŸ“ å·¥ä½œè®°å¿†æ„æˆ:`);
                console.log(`    - èŠå¤©å†å²: ${chatInWorkingMemory}æ¡ (ç”¨æˆ·è®¾ç½®: ${userHistoryLimit}æ¡)`);
                console.log(`    - è·¨åº”ç”¨äº‹ä»¶: ${crossAppInWorkingMemory}æ¡ (è‡ªåŠ¨é›†æˆ)`);
                console.log(`    - æ€»å·¥ä½œè®°å¿†: ${userHistoryLimit}æ¡ (æŒ‰æ—¶é—´é¡ºåºæ»šåŠ¨)`);

            } catch (error) {
                console.error(`ç»Ÿè®¡è§’è‰² ${characterName} è®°å¿†å¤±è´¥:`, error);
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘åˆ é™¤ä¸æ¶ˆæ¯ç›¸å…³çš„æ—¶é—´çº¿è®°å½•
        async function deleteRelatedTimelineEvents(messageToDelete) {
            try {
                const characterId = currentChatCharacter.id;
                const messageContent = messageToDelete.content;
                const messageTimestamp = messageToDelete.timestamp;

                // æŸ¥æ‰¾ç›¸å…³çš„æ—¶é—´çº¿è®°å½•ï¼ˆåŸºäºå†…å®¹å’Œæ—¶é—´æˆ³åŒ¹é…ï¼‰
                const relatedEvents = await db.crossAppTimeline
                    .where('characterId')
                    .equals(characterId)
                    .and(event => {
                        // æ£€æŸ¥æ—¶é—´æˆ³æ˜¯å¦æ¥è¿‘ï¼ˆå…è®¸5åˆ†é’Ÿè¯¯å·®ï¼‰
                        const timeDiff = Math.abs(event.timestamp - messageTimestamp);
                        const isTimeMatch = timeDiff < 5 * 60 * 1000; // 5åˆ†é’Ÿ

                        // æ£€æŸ¥å†…å®¹æ˜¯å¦åŒ¹é…
                        const isContentMatch = event.context &&
                                             event.context.content &&
                                             event.context.content.includes(messageContent.substring(0, 30));

                        return isTimeMatch && isContentMatch;
                    })
                    .toArray();

                // åˆ é™¤åŒ¹é…çš„æ—¶é—´çº¿è®°å½•
                for (const event of relatedEvents) {
                    await db.crossAppTimeline.delete(event.id);
                    console.log(`ğŸ—‘ï¸ åˆ é™¤ç›¸å…³æ—¶é—´çº¿è®°å½•: ${event.action} - ${event.context?.content?.substring(0, 50)}...`);
                }

                console.log(`âœ… åˆ é™¤äº† ${relatedEvents.length} æ¡ç›¸å…³æ—¶é—´çº¿è®°å½•`);

            } catch (error) {
                console.error('åˆ é™¤ç›¸å…³æ—¶é—´çº¿è®°å½•å¤±è´¥:', error);
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ¸…ç†ä½è´¨é‡æ—§ç‰ˆæœ¬è®°å¿†çš„å‡½æ•°
        async function cleanupLowQualityMemories(characterId) {
            try {
                console.log(`ğŸ§¹ å¼€å§‹æ¸…ç†è§’è‰² ${characterId} çš„ä½è´¨é‡æ—§ç‰ˆæœ¬è®°å¿†...`);

                const currentThreshold = MEMORY_CONFIG.CORE_MEMORY_IMPORTANCE_THRESHOLD;

                // æ¸…ç†é‡è¦æ€§ä½äºå½“å‰é˜ˆå€¼çš„æ ¸å¿ƒè®°å¿†
                const lowQualityCoreMemories = await db.coreMemories
                    .where('characterId')
                    .equals(characterId)
                    .and(memory => (memory.importance || 0) < currentThreshold)
                    .toArray();

                for (const memory of lowQualityCoreMemories) {
                    await db.coreMemories.delete(memory.id);
                    console.log(`ğŸ—‘ï¸ åˆ é™¤ä½è´¨é‡æ ¸å¿ƒè®°å¿† (é‡è¦æ€§: ${memory.importance}): ${memory.fact}`);
                }

                console.log(`âœ… æ¸…ç†å®Œæˆï¼Œåˆ é™¤äº† ${lowQualityCoreMemories.length} æ¡ä½è´¨é‡æ ¸å¿ƒè®°å¿†`);
                return lowQualityCoreMemories.length;

            } catch (error) {
                console.error('æ¸…ç†ä½è´¨é‡è®°å¿†å¤±è´¥:', error);
                return 0;
            }
        }

        // è®°å¿†æŸ¥çœ‹å™¨åŠŸèƒ½
        let currentMemoryFilter = 'all';
        let currentMemoryCharacter = null;
        let allMemories = [];

        // åˆå§‹åŒ–è®°å¿†æŸ¥çœ‹å™¨
        async function initMemoryViewer() {
            await loadCharacterSelectOptions();
        }

        // åŠ è½½è§’è‰²é€‰æ‹©é€‰é¡¹
        async function loadCharacterSelectOptions() {
            const select = document.getElementById('memory-character-select');
            if (!select) return;

            // æ¸…ç©ºç°æœ‰é€‰é¡¹
            select.innerHTML = '<option value="">è¯·é€‰æ‹©è§’è‰²</option>';

            // æ·»åŠ è§’è‰²é€‰é¡¹
            characters.forEach(character => {
                const option = document.createElement('option');
                option.value = character.id;
                option.textContent = character.name;
                select.appendChild(option);
            });
        }

        // åŠ è½½è§’è‰²è®°å¿†
        async function loadCharacterMemories() {
            const select = document.getElementById('memory-character-select');
            const characterId = select.value;

            if (!characterId) {
                currentMemoryCharacter = null;
                allMemories = [];
                renderMemoryList();
                return;
            }

            currentMemoryCharacter = characterId;

            try {
                // è·å–æ‰€æœ‰ç±»å‹çš„è®°å¿†
                const [coreMemories, episodicMemories, timeline] = await Promise.all([
                    db.coreMemories.where('characterId').equals(characterId).toArray(),
                    db.episodicMemories.where('characterId').equals(characterId).toArray(),
                    db.crossAppTimeline.where('characterId').equals(characterId).toArray()
                ]);

                // ğŸ”¥ã€è°ƒè¯•ã€‘è¾“å‡ºæ—¶é—´çº¿è®°å½•ä¿¡æ¯
                console.log(`ğŸ“Š è§’è‰² ${characterId} çš„æ—¶é—´çº¿è®°å½•:`, timeline.length, 'æ¡');
                timeline.forEach((event, index) => {
                    if (index < 5) { // åªæ˜¾ç¤ºå‰5æ¡
                        console.log(`  ${index + 1}. ${event.appType}.${event.action} - contextId: ${event.context?.id}, type: ${event.context?.type}, groupId: ${event.context?.groupId || 'æ— '}`);
                    }
                });

                // ğŸ”¥ã€æ–°å¢ã€‘è·å–çº¿ä¸‹å‰§æƒ…æ€»ç»“
                const storylineSummaries = await db.crossAppTimeline
                    .where('characterId')
                    .equals(characterId)
                    .and(item => item.action === 'storyline_summary' && item.appType === 'offline_mode')
                    .toArray();

                console.log(`ğŸ“– çº¿ä¸‹å‰§æƒ…æ€»ç»“: ${storylineSummaries.length}æ¡`);

                // åˆå¹¶æ‰€æœ‰è®°å¿†å¹¶æ·»åŠ ç±»å‹æ ‡è¯†
                allMemories = [
                    ...coreMemories.filter(m => m.type === 'core').map(m => ({...m, memoryType: 'core'})),
                    ...episodicMemories.map(m => ({...m, memoryType: 'episodic'})),
                    ...timeline.map(m => ({
                        ...m,
                        memoryType: 'timeline',
                        fact: formatTimelineEvent(m)
                    })),
                    // ğŸ”¥ã€æ–°å¢ã€‘æ·»åŠ çº¿ä¸‹å‰§æƒ…æ€»ç»“
                    ...storylineSummaries.map(m => {
                        const fullContent = m.context?.content || 'çº¿ä¸‹å‰§æƒ…æ€»ç»“';
                        // åªæ˜¾ç¤ºå‰ä¸‰è¡Œä½œä¸ºé¢„è§ˆ
                        const lines = fullContent.split('\n');
                        const preview = lines.slice(0, 3).join('\n') + (lines.length > 3 ? '\n...' : '');

                        return {
                            ...m,
                            memoryType: 'storyline',
                            fact: preview,
                            summary: preview,
                            fullContent: fullContent // ä¿å­˜å®Œæ•´å†…å®¹ç”¨äºç¼–è¾‘
                        };
                    })
                ];

                // æŒ‰æ—¶é—´æˆ³æ’åºï¼ˆæœ€æ–°çš„åœ¨å‰ï¼‰
                allMemories.sort((a, b) => b.timestamp - a.timestamp);

                renderMemoryList();
            } catch (error) {
                console.error('åŠ è½½è§’è‰²è®°å¿†å¤±è´¥:', error);
                showToast('åŠ è½½è®°å¿†å¤±è´¥', 'error');
            }
        }

        // åˆ‡æ¢è®°å¿†è¿‡æ»¤å™¨
        function switchMemoryFilter(type) {
            currentMemoryFilter = type;

            // æ›´æ–°æ ‡ç­¾æ ·å¼
            document.querySelectorAll('.memory-filter-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`[data-type="${type}"]`).classList.add('active');

            renderMemoryList();
        }

        // è¿‡æ»¤è®°å¿†
        function filterMemories() {
            renderMemoryList();
        }

        // æ¸²æŸ“è®°å¿†åˆ—è¡¨
        function renderMemoryList() {
            const container = document.getElementById('memory-list');
            if (!container) return;

            if (!currentMemoryCharacter || allMemories.length === 0) {
                container.innerHTML = `
                    <div class="memory-empty-state">
                        <i class="fas fa-brain"></i>
                        <p>${currentMemoryCharacter ? 'è¯¥è§’è‰²æš‚æ— è®°å¿†æ•°æ®' : 'è¯·é€‰æ‹©è§’è‰²æŸ¥çœ‹è®°å¿†'}</p>
                    </div>
                `;
                return;
            }

            // è·å–æœç´¢å…³é”®è¯
            const searchTerm = document.getElementById('memory-search-input').value.toLowerCase();

            // è¿‡æ»¤è®°å¿†
            let filteredMemories = allMemories;

            // æŒ‰ç±»å‹è¿‡æ»¤
            if (currentMemoryFilter !== 'all') {
                filteredMemories = filteredMemories.filter(memory => memory.memoryType === currentMemoryFilter);
            }

            // æŒ‰æœç´¢è¯è¿‡æ»¤
            if (searchTerm) {
                filteredMemories = filteredMemories.filter(memory => {
                    const content = memory.fact || memory.summary || '';
                    return content.toLowerCase().includes(searchTerm);
                });
            }

            if (filteredMemories.length === 0) {
                container.innerHTML = `
                    <div class="memory-empty-state">
                        <i class="fas fa-search"></i>
                        <p>æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„è®°å¿†</p>
                    </div>
                `;
                return;
            }

            // æ¸²æŸ“è®°å¿†é¡¹
            const html = filteredMemories.map(memory => renderMemoryItem(memory)).join('');
            container.innerHTML = html;
        }

        // æ¸²æŸ“å•ä¸ªè®°å¿†é¡¹
        function renderMemoryItem(memory) {
            const dateObj = new Date(memory.timestamp || Date.now());
            const date = isNaN(dateObj.getTime()) ? 'æœªçŸ¥æ—¥æœŸ' : dateObj.toLocaleDateString('zh-CN');
            const content = memory.fact || memory.summary || '';
            const importance = memory.importance || 0;
            const stars = 'â˜…'.repeat(Math.round(importance * 5));

            const typeLabels = {
                'core': 'æ ¸å¿ƒè®°å¿†',
                'episodic': 'æƒ…æ™¯è®°å¿†',
                'storyline': 'å‰§æƒ…æ€»ç»“',
                'timeline': 'æ—¶é—´çº¿'
            };

            return `
                <div class="memory-item" data-memory-id="${memory.id}">
                    <div class="memory-item-header">
                        <span class="memory-item-type ${memory.memoryType}">
                            <i class="fas fa-${getMemoryTypeIcon(memory.memoryType)}"></i>
                            ${typeLabels[memory.memoryType]}
                        </span>
                        <span class="memory-item-date">${date}</span>
                    </div>
                    <div class="memory-item-content">${content}</div>
                    ${memory.memoryType === 'core' || memory.memoryType === 'episodic' ? `
                        <div class="memory-item-importance">
                            <span>é‡è¦æ€§:</span>
                            <span class="importance-stars">${stars}</span>
                            <span>(${(importance * 100).toFixed(0)}%)</span>
                        </div>
                    ` : ''}
                    <div class="memory-item-actions">
                        ${memory.memoryType === 'storyline' ? `
                            <button class="memory-action-btn view-btn" onclick="viewStorylineSummary('${memory.id}')" title="æŸ¥çœ‹å®Œæ•´å†…å®¹">
                                <i class="fas fa-eye"></i> æŸ¥çœ‹
                            </button>
                            <button class="memory-action-btn edit-btn" onclick="editStorylineSummary('${memory.id}')" title="ç¼–è¾‘å‰§æƒ…æ€»ç»“">
                                <i class="fas fa-edit"></i> ç¼–è¾‘
                            </button>
                        ` : `
                            <button class="memory-action-btn" onclick="editMemory('${memory.id}', '${memory.memoryType}')">
                                <i class="fas fa-edit"></i> ç¼–è¾‘
                            </button>
                        `}
                        <button class="memory-action-btn delete" onclick="deleteMemory('${memory.id}', '${memory.memoryType}')">
                            <i class="fas fa-trash"></i> åˆ é™¤
                        </button>
                    </div>
                </div>
            `;
        }

        // è·å–è®°å¿†ç±»å‹å›¾æ ‡
        function getMemoryTypeIcon(type) {
            const icons = {
                'core': 'star',
                'episodic': 'calendar-day',
                'storyline': 'book',
                'timeline': 'clock'
            };
            return icons[type] || 'circle';
        }

        // ğŸ”¥ã€é‡æ–°è®¾è®¡ã€‘æ ¼å¼åŒ–æ—¶é—´çº¿äº‹ä»¶æ˜¾ç¤º - ç®€åŒ–ç‰ˆæœ¬ï¼Œé¿å…æ˜¾ç¤ºä¸å®Œæ•´å†…å®¹
        function formatTimelineEvent(event) {
            const appNames = {
                'chat': 'èŠå¤©',
                'music': 'éŸ³ä¹',
                'moments': 'åŠ¨æ€',
                'diary': 'æ—¥è®°'
            };

            const appName = appNames[event.appType] || event.appType;
            let description = '';

            try {
                const context = typeof event.context === 'string' ? JSON.parse(event.context) : event.context;

                switch (event.appType) {
                    case 'chat':
                        const chatType = context?.type === 'group_chat' ? 'ç¾¤èŠ' : 'å•èŠ';
                        const groupName = context?.groupName ? `(${context.groupName})` : '';

                        if (event.action === 'ai_reply') {
                            description = `åœ¨${chatType}${groupName}ä¸­å›å¤äº†æ¶ˆæ¯`;
                        } else if (event.action === 'user_message') {
                            description = `åœ¨${chatType}${groupName}ä¸­æ”¶åˆ°ç”¨æˆ·æ¶ˆæ¯`;
                        } else {
                            description = `åœ¨${chatType}${groupName}ä¸­è¿›è¡Œäº†èŠå¤©äº’åŠ¨`;
                        }
                        break;
                    case 'music':
                        if (context.action === 'listen_together') {
                            description = `ä¸ç”¨æˆ·ä¸€èµ·å¬æ­Œï¼š${context.songTitle || context.song || ''}`;
                        } else if (context.action === 'song_comment') {
                            description = `å¯¹éŸ³ä¹å‘è¡¨äº†è¯„è®º`;
                        } else {
                            description = `è¿›è¡Œäº†éŸ³ä¹äº’åŠ¨`;
                        }
                        break;
                    case 'moments':
                        if (event.action === 'ai_to_ai_reply') {
                            description = `åœ¨åŠ¨æ€ä¸­å›å¤äº†å…¶ä»–è§’è‰²`;
                        } else if (event.action === 'reply_to_user') {
                            description = `åœ¨åŠ¨æ€ä¸­å›å¤äº†ç”¨æˆ·`;
                        } else {
                            description = `è¿›è¡Œäº†åŠ¨æ€äº’åŠ¨`;
                        }
                        break;
                    case 'diary':
                        description = `å†™äº†æ—¥è®°`;
                        break;
                    default:
                        description = `è¿›è¡Œäº†${event.action || 'æœªçŸ¥'}æ´»åŠ¨`;
                }
            } catch (e) {
                description = `è¿›è¡Œäº†${event.action || 'æœªçŸ¥'}æ´»åŠ¨`;
            }

            return `ã€${appName}ã€‘${description}`;
        }

        // åˆ·æ–°è®°å¿†æ•°æ®
        async function refreshMemoryData() {
            if (currentMemoryCharacter) {
                await loadCharacterMemories();
                showToast('è®°å¿†æ•°æ®å·²åˆ·æ–°', 'success');
            }
        }



        // ğŸ”¥ã€æ–°å¢ã€‘æ¸…ç†é”™è¯¯çš„è®°å½•
        async function cleanupIncorrectRecords() {
            if (!confirm('ç¡®å®šè¦æ¸…ç†é”™è¯¯çš„è®°å½•å—ï¼Ÿè¿™å°†åˆ é™¤è·¨åº”ç”¨æ—¶é—´çº¿ä¸­é”™è¯¯çš„èŠå¤©è®°å½•ã€‚')) {
                return;
            }

            try {
                const deletedCount = await cleanupIncorrectTimelineRecords();
                await loadCharacterMemories();
                showToast(`é”™è¯¯è®°å½•æ¸…ç†å®Œæˆï¼Œåˆ é™¤äº†${deletedCount}æ¡é”™è¯¯è®°å½•`, 'success');
            } catch (error) {
                console.error('æ¸…ç†é”™è¯¯è®°å½•å¤±è´¥:', error);
                showToast('æ¸…ç†å¤±è´¥', 'error');
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ¸…ç†é‡å¤çš„æ—¶é—´çº¿äº‹ä»¶
        async function cleanupDuplicateTimelineEvents(characterId) {
            try {
                console.log(`ğŸ§¹ å¼€å§‹æ¸…ç†è§’è‰² ${characterId} çš„é‡å¤æ—¶é—´çº¿è®°å½•...`);

                const timelineEvents = await db.crossAppTimeline
                    .where('characterId')
                    .equals(characterId)
                    .toArray();

                const duplicates = [];
                const seenContents = new Map(); // å†…å®¹ -> ç¬¬ä¸€ä¸ªäº‹ä»¶

                for (const event of timelineEvents) {
                    const content = event.context?.content;
                    if (content) {
                        const normalizedContent = content.toLowerCase().trim();
                        if (seenContents.has(normalizedContent)) {
                            // å‘ç°é‡å¤ï¼Œä¿ç•™æ—¶é—´æˆ³è¾ƒæ—©çš„
                            const existingEvent = seenContents.get(normalizedContent);
                            if (event.timestamp > existingEvent.timestamp) {
                                duplicates.push(event);
                            } else {
                                duplicates.push(existingEvent);
                                seenContents.set(normalizedContent, event);
                            }
                        } else {
                            seenContents.set(normalizedContent, event);
                        }
                    }
                }

                // åˆ é™¤é‡å¤çš„æ—¶é—´çº¿è®°å½•
                for (const duplicate of duplicates) {
                    await db.crossAppTimeline.delete(duplicate.id);
                    console.log(`ğŸ—‘ï¸ åˆ é™¤é‡å¤æ—¶é—´çº¿è®°å½•: ${duplicate.action} - ${duplicate.context?.content?.substring(0, 50)}...`);
                }

                console.log(`âœ… æ¸…ç†å®Œæˆï¼Œåˆ é™¤äº† ${duplicates.length} æ¡é‡å¤æ—¶é—´çº¿è®°å½•`);
                return duplicates.length;

            } catch (error) {
                console.error('æ¸…ç†é‡å¤æ—¶é—´çº¿è®°å½•å¤±è´¥:', error);
                return 0;
            }
        }

        // æ˜¾ç¤ºè®°å¿†è®¾ç½®
        function showMemorySettings() {
            // åŠ è½½å½“å‰è®¾ç½®
            document.getElementById('aiExtractInterval').value = MEMORY_CONFIG.AI_EXTRACT_INTERVAL / 2; // è½¬æ¢ä¸ºå›åˆæ•°
            document.getElementById('coreMemoryThreshold').value = MEMORY_CONFIG.CORE_MEMORY_IMPORTANCE_THRESHOLD;
            document.getElementById('episodicMemoryThreshold').value = MEMORY_CONFIG.EPISODIC_MEMORY_IMPORTANCE_THRESHOLD;

            // æ›´æ–°æ˜¾ç¤ºå€¼
            updateThresholdDisplay();

            // æ˜¾ç¤ºæ¨¡æ€æ¡†
            document.getElementById('memorySettingsModal').style.display = 'flex';
        }

        // å…³é—­è®°å¿†è®¾ç½®
        function closeMemorySettings() {
            document.getElementById('memorySettingsModal').style.display = 'none';
        }

        // æ›´æ–°é˜ˆå€¼æ˜¾ç¤º
        function updateThresholdDisplay() {
            const coreThreshold = document.getElementById('coreMemoryThreshold').value;
            const episodicThreshold = document.getElementById('episodicMemoryThreshold').value;

            document.getElementById('coreThresholdValue').textContent = Math.round(coreThreshold * 100) + '%';
            document.getElementById('episodicThresholdValue').textContent = Math.round(episodicThreshold * 100) + '%';
        }

        // ä¿å­˜è®°å¿†è®¾ç½®
        async function saveMemorySettings() {
            try {
                const aiInterval = parseInt(document.getElementById('aiExtractInterval').value);
                const coreThreshold = parseFloat(document.getElementById('coreMemoryThreshold').value);
                const episodicThreshold = parseFloat(document.getElementById('episodicMemoryThreshold').value);

                // æ›´æ–°é…ç½®
                MEMORY_CONFIG.AI_EXTRACT_INTERVAL = aiInterval * 2; // è½¬æ¢ä¸ºæ¶ˆæ¯æ•°
                MEMORY_CONFIG.CORE_MEMORY_IMPORTANCE_THRESHOLD = coreThreshold;
                MEMORY_CONFIG.EPISODIC_MEMORY_IMPORTANCE_THRESHOLD = episodicThreshold;

                // ä¿å­˜åˆ°æ•°æ®åº“
                await saveMemoryConfig();

                closeMemorySettings();
                showToast('è®°å¿†è®¾ç½®å·²ä¿å­˜', 'success');
            } catch (error) {
                console.error('ä¿å­˜è®°å¿†è®¾ç½®å¤±è´¥:', error);
                showToast('ä¿å­˜å¤±è´¥', 'error');
            }
        }

        // ç¼–è¾‘è®°å¿†
        async function editMemory(memoryId, memoryType) {
            try {
                // ğŸ”¥ã€ä¿®å¤ã€‘æ—¶é—´çº¿è®°å¿†ä¸å…è®¸ç¼–è¾‘
                if (memoryType === 'timeline') {
                    showToast('æ—¶é—´çº¿è®°å¿†æ˜¯è‡ªåŠ¨è®°å½•çš„æ´»åŠ¨æ—¥å¿—ï¼Œä¸æ”¯æŒç¼–è¾‘', 'warning');
                    return;
                }

                let memory;
                if (memoryType === 'summary') {
                    memory = await db.memorySummaries.get(memoryId);
                } else if (memoryType === 'core') {
                    memory = await db.coreMemories.get(memoryId);
                } else {
                    showToast('ä¸æ”¯æŒçš„è®°å¿†ç±»å‹', 'error');
                    return;
                }

                if (!memory) {
                    showToast('è®°å¿†ä¸å­˜åœ¨', 'error');
                    return;
                }

                const content = memory.fact || memory.summary || '';
                const newContent = await showCustomPrompt('ç¼–è¾‘è®°å¿†', 'è¯·è¾“å…¥æ–°çš„è®°å¿†å†…å®¹', content);

                if (newContent && newContent.trim() && newContent !== content) {
                    if (memoryType === 'summary') {
                        memory.summary = newContent.trim();
                        await db.memorySummaries.put(memory);
                    } else {
                        memory.fact = newContent.trim();
                        await db.coreMemories.put(memory);
                    }

                    await loadCharacterMemories();
                    showToast('è®°å¿†å·²æ›´æ–°', 'success');
                }
            } catch (error) {
                console.error('ç¼–è¾‘è®°å¿†å¤±è´¥:', error);
                showToast('ç¼–è¾‘è®°å¿†å¤±è´¥', 'error');
            }
        }

        // åˆ é™¤è®°å¿†
        async function deleteMemory(memoryId, memoryType) {
            // ğŸ”¥ã€ä¿®å¤ã€‘æ—¶é—´çº¿è®°å¿†åˆ é™¤ç¡®è®¤
            let confirmMessage = 'ç¡®å®šè¦åˆ é™¤è¿™æ¡è®°å¿†å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚';
            if (memoryType === 'timeline') {
                confirmMessage = 'ç¡®å®šè¦åˆ é™¤è¿™æ¡æ—¶é—´çº¿è®°å½•å—ï¼Ÿè¿™æ˜¯è‡ªåŠ¨è®°å½•çš„æ´»åŠ¨æ—¥å¿—ï¼Œåˆ é™¤åæ— æ³•æ¢å¤ã€‚';
            }

            if (!confirm(confirmMessage)) {
                return;
            }

            try {
                if (memoryType === 'summary') {
                    await db.memorySummaries.delete(memoryId);
                } else if (memoryType === 'core') {
                    await db.coreMemories.delete(memoryId);
                } else if (memoryType === 'episodic') {
                    await db.episodicMemories.delete(memoryId);
                } else if (memoryType === 'timeline') {
                    await db.crossAppTimeline.delete(memoryId);
                } else {
                    showToast('ä¸æ”¯æŒçš„è®°å¿†ç±»å‹', 'error');
                    return;
                }

                await loadCharacterMemories();
                showToast('è®°å¿†å·²åˆ é™¤', 'success');
            } catch (error) {
                console.error('åˆ é™¤è®°å¿†å¤±è´¥:', error);
                showToast('åˆ é™¤è®°å¿†å¤±è´¥', 'error');
            }
        }

        // AIå¿ƒç‡ç®¡ç†åŠŸèƒ½
        let heartrateInterval = null;
        let currentHeartrate = 72; // åŸºç¡€å¿ƒç‡

        function updateAiHeartrate() {
            const heartrateDisplay = document.getElementById('ai-heartrate-display');
            if (!heartrateDisplay) return;
            
            const chatSettings = getCurrentChatSettings();
            
            // æ£€æŸ¥æ˜¯å¦å¯ç”¨å¿ƒç‡ç›‘æµ‹ä¸”ä¸æ˜¯ç¾¤èŠ
            if (!chatSettings.aiHeartrateEnabled || (currentChatCharacter && currentChatCharacter.isGroup)) {
                hideAiHeartrate();
                return;
            }
            
            // æ˜¾ç¤ºå¿ƒç‡
            heartrateDisplay.style.display = 'block';
            
            // è®¡ç®—åŸºç¡€å¿ƒç‡ï¼ˆåŸºäºè§’è‰²äººè®¾ï¼‰
            const persona = (currentChatCharacter.bio || '').toLowerCase();
            const name = (currentChatCharacter.name || '').toLowerCase();
            let baseHeartrate = 72;
            
            // æ ¹æ®è§’è‰²ç‰¹å¾è°ƒæ•´åŸºç¡€å¿ƒç‡
            if (persona.includes('ç´§å¼ ') || persona.includes('å®³ç¾') || persona.includes('æ•æ„Ÿ') || 
                persona.includes('ç¾æ¶©') || persona.includes('å®¹æ˜“è„¸çº¢') || persona.includes('å†…å‘')) {
                baseHeartrate = 85; // å®¹æ˜“ç´§å¼ çš„è§’è‰²å¿ƒç‡æ›´é«˜
            } else if (persona.includes('å†·é™') || persona.includes('ç†æ€§') || persona.includes('æˆç†Ÿ') || 
                       persona.includes('æ²‰ç¨³') || persona.includes('å†…æ•›') || persona.includes('ä¸¥è‚ƒ')) {
                baseHeartrate = 65; // å†·é™çš„è§’è‰²å¿ƒç‡æ›´ä½
            } else if (persona.includes('æ´»æ³¼') || persona.includes('å…´å¥‹') || persona.includes('çƒ­æƒ…') || 
                       persona.includes('å¼€æœ—') || persona.includes('å¤–å‘') || persona.includes('çˆ±ç¬‘')) {
                baseHeartrate = 82; // æ´»æ³¼çš„è§’è‰²å¿ƒç‡åé«˜
            } else if (persona.includes('è¿åŠ¨') || persona.includes('å¥èº«') || persona.includes('ä½“è‚²') || 
                       persona.includes('è¿åŠ¨å‘˜') || persona.includes('æ´»è·ƒ')) {
                baseHeartrate = 58; // è¿åŠ¨å‹è§’è‰²å¿ƒç‡æœ€ä½
            } else if (persona.includes('æ¸©æŸ”') || persona.includes('ç”œç¾') || persona.includes('å¯çˆ±') || 
                       persona.includes('è½¯èŒ') || persona.includes('å°é¸Ÿä¾äºº') || persona.includes('ä¹–å·§')) {
                baseHeartrate = 75; // æ¸©æŸ”å‹è§’è‰²å¿ƒç‡é€‚ä¸­åé«˜
            } else if (persona.includes('å†·é…·') || persona.includes('é«˜å†·') || persona.includes('å‚²å¨‡') || 
                       persona.includes('å¥³ç‹') || persona.includes('å¼ºåŠ¿') || persona.includes('éœ¸é“')) {
                baseHeartrate = 68; // é«˜å†·å‹è§’è‰²å¿ƒç‡åä½
            } else if (persona.includes('çƒ­è¡€') || persona.includes('å†²åŠ¨') || persona.includes('æ€¥æ€§å­') || 
                       persona.includes('ç«çˆ†') || persona.includes('æš´èº') || persona.includes('æ˜“æ€’')) {
                baseHeartrate = 88; // çƒ­è¡€å‹è§’è‰²å¿ƒç‡å¾ˆé«˜
            } else if (persona.includes('ç¥ç§˜') || persona.includes('æ·±æ²‰') || persona.includes('å®‰é™') || 
                       persona.includes('æ–‡é™') || persona.includes('å†…å‘')) {
                baseHeartrate = 70; // ç¥ç§˜å‹è§’è‰²å¿ƒç‡æ­£å¸¸åä½
            }
            
            // æ ¹æ®è§’è‰²åå­—è¿›ä¸€æ­¥å¾®è°ƒ
            if (name.includes('å°') || name.includes('èŒ') || name.includes('å¯çˆ±')) {
                baseHeartrate += 3; // å¯çˆ±åå­—çš„è§’è‰²å¿ƒç‡ç¨é«˜
            } else if (name.includes('å†°') || name.includes('é›ª') || name.includes('é™') || 
                       name.includes('å†·') || name.includes('å‡‰')) {
                baseHeartrate -= 5; // å†·ç³»åå­—çš„è§’è‰²å¿ƒç‡æ›´ä½
            } else if (name.includes('ç«') || name.includes('çƒ­') || name.includes('çƒˆ')) {
                baseHeartrate += 5; // ç«ç³»åå­—çš„è§’è‰²å¿ƒç‡æ›´é«˜
            }
            
            // æ ¹æ®æœ€è¿‘å¯¹è¯å†…å®¹è°ƒæ•´å¿ƒç‡
            const recentMessages = (chatMessages[currentChatCharacter.id] || []).slice(-8); // åˆ†ææœ€è¿‘8æ¡æ¶ˆæ¯
            let emotionAdjustment = 0;
            
            recentMessages.forEach(msg => {
                // å®‰å…¨åœ°å¤„ç†æ¶ˆæ¯å†…å®¹
                let content = '';
                if (typeof msg.content === 'string') {
                    content = msg.content.toLowerCase();
                } else if (Array.isArray(msg.content)) {
                    content = '';
                } else {
                    content = '';
                }
                
                // é«˜åº¦äº²å¯†è¯æ±‡ - å¤§å¹…æé«˜å¿ƒç‡
                if (content.includes('çˆ±ä½ ') || content.includes('æˆ‘çˆ±ä½ ') || content.includes('love you') || 
                    content.includes('å–œæ¬¢ä½ ') || content.includes('æƒ³ä½ ') || content.includes('æƒ³æŠ±ä½ ') ||
                    content.includes('æƒ³å»ä½ ') || content.includes('äº²äº²') || content.includes('æŠ±æŠ±') ||
                    content.includes('å®è´') || content.includes('darling') || content.includes('honey') ||
                    content.includes('äº²çˆ±çš„') || content.includes('æƒ³è¦ä½ ') || content.includes('éœ€è¦ä½ ') ||
                    content.includes('ç¦»ä¸å¼€ä½ ') || content.includes('æƒ³å’Œä½ ') || content.includes('æƒ³è§ä½ ')) {
                    emotionAdjustment += 15;
                }
                
                // è¡¨ç™½å’Œç”œèœœè¯æ±‡
                if (content.includes('è¡¨ç™½') || content.includes('å–œæ¬¢') || content.includes('å¿ƒåŠ¨') || 
                    content.includes('å¿ƒè·³') || content.includes('è„¸çº¢') || content.includes('å®³ç¾') ||
                    content.includes('å¯çˆ±') || content.includes('ç”œ') || content.includes('æ¸©æŸ”') ||
                    content.includes('ç¾ä¸½') || content.includes('æ¼‚äº®') || content.includes('è¿·äºº') ||
                    content.includes('é­…åŠ›') || content.includes('å¸å¼•') || content.includes('å¿ƒä»ª')) {
                    emotionAdjustment += 10;
                }
                
                // æ’’å¨‡å’Œäº²æ˜µè¯æ±‡
                if (content.includes('æ’’å¨‡') || content.includes('å˜¤å˜¤') || content.includes('å“¼') ||
                    content.includes('äººå®¶') || content.includes('è®¨åŒ') || content.includes('ä¸è¦') ||
                    content.includes('å¥½ä¸å¥½') || content.includes('æ±‚ä½ ') || content.includes('æ‹œæ‰˜') ||
                    content.includes('é™ªæˆ‘') || content.includes('é™ªé™ª') || content.includes('ä¸€èµ·')) {
                    emotionAdjustment += 8;
                }
                
                // å…´å¥‹å’Œå¼€å¿ƒè¯æ±‡
                if (content.includes('å¼€å¿ƒ') || content.includes('é«˜å…´') || content.includes('å¿«ä¹') || 
                    content.includes('å…´å¥‹') || content.includes('æ¿€åŠ¨') || content.includes('å¥½æ£’') || 
                    content.includes('å‰å®³') || content.includes('å“‡') || content.includes('å¤ªå¥½äº†') ||
                    content.includes('amazing') || content.includes('wonderful') || content.includes('great')) {
                    emotionAdjustment += 6;
                }
                
                // è´Ÿé¢æƒ…ç»ªè¯æ±‡ - åŒæ ·ä¼šè®©å¿ƒç‡åŠ å¿«
                if (content.includes('éš¾è¿‡') || content.includes('ç”Ÿæ°”') || content.includes('æ‹…å¿ƒ') || 
                    content.includes('å®³æ€•') || content.includes('ç´§å¼ ') || content.includes('ç„¦è™‘') ||
                    content.includes('ä¸å¼€å¿ƒ') || content.includes('éƒé—·') || content.includes('çƒ¦') ||
                    content.includes('å‹åŠ›') || content.includes('ç´¯') || content.includes('ç–²æƒ«')) {
                    emotionAdjustment += 8;
                }
            });
            
            // è®¡ç®—æœ€ç»ˆå¿ƒç‡
            currentHeartrate = Math.max(50, Math.min(140, baseHeartrate + emotionAdjustment));
            
            // å¯åŠ¨å¿ƒç‡æ›´æ–°
            if (heartrateInterval) clearInterval(heartrateInterval);
            heartrateInterval = setInterval(() => {
                // æ·»åŠ è‡ªç„¶çš„å¿ƒç‡æ³¢åŠ¨ï¼ˆÂ±4 bpmï¼‰
                const fluctuation = Math.floor(Math.random() * 9) - 4;
                const displayHeartrate = Math.max(50, Math.min(140, currentHeartrate + fluctuation));
                
                // æ ¹æ®å¿ƒç‡é«˜ä½æ·»åŠ è§†è§‰æ•ˆæœ
                heartrateDisplay.className = '';
                if (displayHeartrate >= 110) {
                    heartrateDisplay.classList.add('very-high-heartrate');
                } else if (displayHeartrate >= 95) {
                    heartrateDisplay.classList.add('high-heartrate');
                }
                
                heartrateDisplay.innerHTML = `â™¥ï¸ <span class="heartrate-number">${displayHeartrate}</span> <span class="heartrate-unit">bpm</span>`;
            }, 1500 + Math.random() * 1000); // 1.5-2.5ç§’æ›´æ–°ä¸€æ¬¡
            
            // ç«‹å³æ˜¾ç¤ºåˆå§‹å¿ƒç‡
            heartrateDisplay.innerHTML = `â™¥ï¸ <span class="heartrate-number">${currentHeartrate}</span> <span class="heartrate-unit">bpm</span>`;
        }

        function hideAiHeartrate() {
            const heartrateDisplay = document.getElementById('ai-heartrate-display');
            if (heartrateDisplay) {
                heartrateDisplay.style.display = 'none';
            }
            
            if (heartrateInterval) {
                clearInterval(heartrateInterval);
                heartrateInterval = null;
            }
        }

        // å½“å‘é€æ¶ˆæ¯æ—¶æ›´æ–°å¿ƒç‡
        function adjustHeartrateForMessage(content, isUserMessage = false) {
            if (!heartrateInterval) return; // å¿ƒç‡ç›‘æµ‹æœªå¯ç”¨
            
            let adjustment = 0;
            let lowerContent = '';
            let recoveryTime = 3000; // é»˜è®¤æ¢å¤æ—¶é—´
            
            // å®‰å…¨åœ°å¤„ç†å†…å®¹
            if (typeof content === 'string') {
                lowerContent = content.toLowerCase();
            } else if (Array.isArray(content)) {
                lowerContent = '';
            } else {
                lowerContent = '';
            }
            
            if (isUserMessage) {
                // ç”¨æˆ·å‘é€æ¶ˆæ¯æ—¶ï¼ŒAIçš„å¿ƒç‡ä¼šæœ‰ç›¸åº”ååº”
                
                // é«˜åº¦äº²å¯†è¯æ±‡ - å¼ºçƒˆå¿ƒè·³åŠ é€Ÿ
                if (lowerContent.includes('çˆ±ä½ ') || lowerContent.includes('æˆ‘çˆ±ä½ ') || lowerContent.includes('love you') || 
                    lowerContent.includes('å–œæ¬¢ä½ ') || lowerContent.includes('æƒ³ä½ ') || lowerContent.includes('æƒ³æŠ±ä½ ') ||
                    lowerContent.includes('æƒ³å»ä½ ') || lowerContent.includes('äº²äº²') || lowerContent.includes('æŠ±æŠ±') ||
                    lowerContent.includes('å®è´') || lowerContent.includes('darling') || lowerContent.includes('honey') ||
                    lowerContent.includes('äº²çˆ±çš„') || lowerContent.includes('æƒ³è¦ä½ ') || lowerContent.includes('éœ€è¦ä½ ') ||
                    lowerContent.includes('ç¦»ä¸å¼€ä½ ') || lowerContent.includes('æƒ³å’Œä½ ') || lowerContent.includes('æƒ³è§ä½ ')) {
                    adjustment = 20; // å¤§å¹…å¢åŠ 
                    recoveryTime = 8000; // æ›´é•¿çš„æ¢å¤æ—¶é—´
                }
                // è¡¨ç™½å’Œç”œèœœè¯æ±‡
                else if (lowerContent.includes('è¡¨ç™½') || lowerContent.includes('å–œæ¬¢') || lowerContent.includes('å¿ƒåŠ¨') || 
                    lowerContent.includes('å¿ƒè·³') || lowerContent.includes('è„¸çº¢') || lowerContent.includes('å®³ç¾') ||
                    lowerContent.includes('å¯çˆ±') || lowerContent.includes('ç”œ') || lowerContent.includes('æ¸©æŸ”') ||
                    lowerContent.includes('ç¾ä¸½') || lowerContent.includes('æ¼‚äº®') || lowerContent.includes('è¿·äºº') ||
                    lowerContent.includes('é­…åŠ›') || lowerContent.includes('å¸å¼•') || lowerContent.includes('å¿ƒä»ª')) {
                    adjustment = 15;
                    recoveryTime = 6000;
                }
                // æ’’å¨‡å’Œäº²æ˜µè¯æ±‡
                else if (lowerContent.includes('æ’’å¨‡') || lowerContent.includes('å˜¤å˜¤') || lowerContent.includes('å“¼') ||
                    lowerContent.includes('äººå®¶') || lowerContent.includes('è®¨åŒ') || lowerContent.includes('ä¸è¦') ||
                    lowerContent.includes('å¥½ä¸å¥½') || lowerContent.includes('æ±‚ä½ ') || lowerContent.includes('æ‹œæ‰˜') ||
                    lowerContent.includes('é™ªæˆ‘') || lowerContent.includes('é™ªé™ª') || lowerContent.includes('ä¸€èµ·')) {
                    adjustment = 12;
                    recoveryTime = 5000;
                }
                // å…´å¥‹å’Œå¼€å¿ƒè¯æ±‡
                else if (lowerContent.includes('å¼€å¿ƒ') || lowerContent.includes('é«˜å…´') || lowerContent.includes('å¿«ä¹') || 
                    lowerContent.includes('å…´å¥‹') || lowerContent.includes('æ¿€åŠ¨') || lowerContent.includes('å¥½æ£’') || 
                    lowerContent.includes('å‰å®³') || lowerContent.includes('å“‡') || lowerContent.includes('å¤ªå¥½äº†')) {
                    adjustment = 8;
                    recoveryTime = 4000;
                }
                // è´Ÿé¢æƒ…ç»ªè¯æ±‡ - ç´§å¼ å¯¼è‡´å¿ƒç‡åŠ å¿«
                else if (lowerContent.includes('ç”Ÿæ°”') || lowerContent.includes('ä¸å¼€å¿ƒ') || lowerContent.includes('éš¾è¿‡') ||
                    lowerContent.includes('æ‹…å¿ƒ') || lowerContent.includes('å®³æ€•') || lowerContent.includes('ç´§å¼ ') ||
                    lowerContent.includes('ç„¦è™‘') || lowerContent.includes('éƒé—·') || lowerContent.includes('çƒ¦')) {
                    adjustment = 10;
                    recoveryTime = 6000;
                }
                // æ™®é€šé—®å€™
                else if (lowerContent.includes('ä½ å¥½') || lowerContent.includes('hi') || lowerContent.includes('hello') ||
                    lowerContent.includes('æ—©ä¸Šå¥½') || lowerContent.includes('æ™šå®‰')) {
                    adjustment = 5;
                    recoveryTime = 3000;
                }
                
            } else {
                // AIè‡ªå·±å‘é€æ¶ˆæ¯åçš„å¿ƒç‡å˜åŒ–
                if (lowerContent.includes('å®³ç¾') || lowerContent.includes('è„¸çº¢') || lowerContent.includes('ä¸å¥½æ„æ€')) {
                    adjustment = 10;
                    recoveryTime = 5000;
                } else if (lowerContent.includes('å…´å¥‹') || lowerContent.includes('å¼€å¿ƒ') || lowerContent.includes('æ¿€åŠ¨')) {
                    adjustment = 8;
                    recoveryTime = 4000;
                } else if (lowerContent.includes('ç´§å¼ ') || lowerContent.includes('æ‹…å¿ƒ') || lowerContent.includes('ç„¦è™‘')) {
                    adjustment = 12;
                    recoveryTime = 6000;
                } else if (lowerContent.includes('çˆ±') || lowerContent.includes('å–œæ¬¢') || lowerContent.includes('æƒ³')) {
                    adjustment = 15;
                    recoveryTime = 7000;
                }
            }
            
            // åº”ç”¨è°ƒæ•´
            currentHeartrate = Math.max(55, Math.min(130, currentHeartrate + adjustment));
            
            // æ›´è‡ªç„¶çš„æ¢å¤æœºåˆ¶
            setTimeout(() => {
                const recoveryRate = Math.floor(adjustment * 0.6); // æ¢å¤60%
                currentHeartrate = Math.max(65, currentHeartrate - recoveryRate);
                
                // ç»§ç»­ç¼“æ…¢æ¢å¤
                setTimeout(() => {
                    const finalRecovery = Math.floor(adjustment * 0.3); // å†æ¢å¤30%
                    currentHeartrate = Math.max(65, currentHeartrate - finalRecovery);
                }, recoveryTime * 0.5);
                
            }, recoveryTime);
        }

        /**
 * ğŸ”¥ã€æ–°å¢ã€‘å¤„ç†AIå¯¹å¥½å‹ç”³è¯·çš„å›åº”
 * @param {string} characterId - AIè§’è‰²çš„ID
 * @param {string} requestMessage - ç”¨æˆ·å‘é€çš„ç”³è¯·ç†ç”±
 */
async function processAIFriendRequestResponse(characterId, requestMessage) {
    const character = characters.find(c => c.id === characterId);
    if (!character) return;

    // æ„å»ºä¸€ä¸ªä¸“é—¨ç”¨äºå†³ç­–çš„Prompt
    const decisionPrompt = `
# æŒ‡ä»¤ï¼šå¥½å‹ç”³è¯·å†³ç­–
ä½ æ˜¯ ${character.name}ï¼Œä¹‹å‰å› ä¸ºæŸç§åŸå› æ‹‰é»‘äº†ç”¨æˆ·ã€‚ç°åœ¨ç”¨æˆ·ä¸»åŠ¨å‘ä½ å‘æ¥å¥½å‹ç”³è¯·ï¼Œå¸Œæœ›é‡æ–°å»ºç«‹è”ç³»ã€‚

## è§’è‰²ä¿¡æ¯:
- ä½ çš„èº«ä»½: ${character.name}
- ä½ çš„è®¾å®š: ${character.bio}

## å½“å‰æƒ…å†µ:
- ç”¨æˆ·çš„ç”³è¯·ç†ç”±: "${requestMessage || 'å¯¹æ–¹æ²¡æœ‰å¡«å†™ç†ç”±ã€‚'}"
- ç”¨æˆ·ä¸»åŠ¨é“æ­‰å¹¶è¯·æ±‚é‡æ–°åšæœ‹å‹

## ä½ çš„ä»»åŠ¡:
æ ¹æ®ä½ çš„è§’è‰²æ€§æ ¼ã€ç”¨æˆ·çš„ç”³è¯·ç†ç”±ï¼Œä»¥åŠä½ å¯¹è¿™ç§æƒ…å†µçš„æ€åº¦ï¼Œå†³å®šæ˜¯å¦åŒæ„é‡æ–°æ·»åŠ ç”¨æˆ·ä¸ºå¥½å‹ã€‚

è€ƒè™‘å› ç´ ï¼š
1. ä½ çš„æ€§æ ¼æ˜¯å¦å®¹æ˜“åŸè°…åˆ«äººï¼Ÿ
2. ç”¨æˆ·çš„é“æ­‰æ˜¯å¦çœŸè¯šï¼Ÿ
3. ä½ æ˜¯å¦æ„¿æ„ç»™å¯¹æ–¹ç¬¬äºŒæ¬¡æœºä¼šï¼Ÿ
4. ä½ å½“åˆæ‹‰é»‘çš„åŸå› æ˜¯å¦ä¸¥é‡ï¼Ÿ

ä½ çš„å›ç­”å¿…é¡»éå¸¸ç®€æ´ï¼Œåªèƒ½æ˜¯ä»¥ä¸‹ä¸¤ä¸ªè¯ä¹‹ä¸€ï¼š
- "åŒæ„" (å¦‚æœä½ æ„¿æ„åŸè°…å¹¶é‡æ–°å¼€å§‹)
- "æ‹’ç»" (å¦‚æœä½ è¿˜ä¸æƒ³åŸè°…æˆ–é‡æ–°è”ç³»)

è¯·ç°åœ¨åšå‡ºä½ çš„å†³å®šï¼š
`;

    try {
        // ä½¿ç”¨é€šç”¨çš„APIè°ƒç”¨å‡½æ•°
        const response = await callChatAPI(decisionPrompt, character);
        // AIçš„å›å¤é€šå¸¸æ˜¯ `["åŒæ„"]` æˆ– `["æ‹’ç»"]`ï¼Œæˆ‘ä»¬åªéœ€è¦ç¬¬ä¸€ä¸ªå…ƒç´ 
        const decision = Array.isArray(response) ? response[0].toLowerCase() : response.toLowerCase();

        console.log(`ğŸ¤– AIå¯¹å¥½å‹ç”³è¯·çš„å†³ç­–: ${decision}`);

        if (decision.includes('åŒæ„')) {
            // AIåŒæ„äº†
            await aiUnblockUser(characterId);
            
            // ğŸ”¥ã€ç¾åŒ–ã€‘ä½¿ç”¨æ–°çš„å¥½å‹æ·»åŠ æˆåŠŸç³»ç»Ÿæç¤ºæ ·å¼
            const systemMsg = {
                id: 'system_' + Date.now(),
                sender: 'system',
                content: `ä½ ä»¬å·²æˆåŠŸæ·»åŠ ä¸ºå¥½å‹ï¼Œç°åœ¨å¯ä»¥å¼€å§‹èŠå¤©äº†ï¼`,
                timestamp: Date.now(),
                isFriendAddedMessage: true // æ ‡è®°ä¸ºå¥½å‹æ·»åŠ æˆåŠŸæ¶ˆæ¯
            };
            addMessageToChat(systemMsg);
            
            showToast(`âœ… ${character.name} åŒæ„äº†ä½ çš„å¥½å‹ç”³è¯·`, 'success');
            
        } else {
            // AIæ‹’ç»äº†
            const systemMsg = {
                id: 'system_' + Date.now(),
                sender: 'system',
                content: `${character.name} æ‹’ç»äº†ä½ çš„å¥½å‹ç”³è¯·ã€‚`,
                timestamp: Date.now()
            };
            addMessageToChat(systemMsg);
            
            showToast(`âŒ ${character.name} æ‹’ç»äº†ä½ çš„å¥½å‹ç”³è¯·`, 'warning');
        }

    } catch (error) {
        console.error('å¤„ç†AIå¥½å‹ç”³è¯·å›åº”å¤±è´¥:', error);
        showToast('å¯¹æ–¹æ²¡æœ‰å›åº”ï¼Œè¯·ç¨åå†è¯•', 'error');
    }
}


/**
 * ğŸ”¥ã€æ–°å¢ã€‘AIè§£é™¤å¯¹ç”¨æˆ·çš„æ‹‰é»‘
 * @param {string} characterId - AIè§’è‰²çš„IDï¼ˆæ‹‰é»‘è€…ï¼‰
 */
async function aiUnblockUser(characterId) {
    try {
        const blockRecord = blacklistData.find(r => 
            r.blockerId === characterId && 
            r.blockedId === 'user' && 
            !r.unblocked
        );

        if (!blockRecord) {
            console.warn('æœªæ‰¾åˆ°è¯¥è§’è‰²çš„æ‹‰é»‘è®°å½•');
            return;
        }

        blockRecord.unblocked = true;
        blockRecord.unblockTimestamp = new Date().toISOString();
        
        await db.blacklist.put(blockRecord);
        console.log(`âœ… ${characterId} å·²è§£é™¤å¯¹ç”¨æˆ·çš„æ‹‰é»‘`);

        // åˆ·æ–°èŠå¤©ç•Œé¢çš„æ‹‰é»‘çŠ¶æ€
        if (currentChatCharacter && currentChatCharacter.id === characterId) {
            updateChatBlockedStatus();
        }
        
        // åˆ·æ–°è”ç³»äººåˆ—è¡¨å’Œæ¶ˆæ¯åˆ—è¡¨çš„UIçŠ¶æ€
        renderContactList();
        renderMessageList();

    } catch (error) {
        console.error('AIè§£é™¤æ‹‰é»‘å¤±è´¥:', error);
    }
}
        console.log('ğŸ“± è§’è‰²çŠ¶æ€æ˜¾ç¤ºåŠŸèƒ½å·²åŠ è½½');

        // ğŸ”¥ã€æ–°å¢ã€‘é€šçŸ¥è§’è‰²è¢«æ‹‰é»‘
        async function notifyCharacterBlocked(characterId, reason = '') {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;

                // æ„å»ºè¢«æ‹‰é»‘é€šçŸ¥çš„prompt
                const blockNotificationPrompt = `[ç³»ç»Ÿæ¶ˆæ¯ï¼šç”¨æˆ·å°†ä½ æ‹‰é»‘äº†${reason ? `ï¼Œç†ç”±ï¼š${reason}` : 'ï¼Œæœªè¯´æ˜ç†ç”±'}]

ä½ æ˜¯${character.name}ï¼Œäººè®¾å¦‚ä¸‹ï¼š${character.bio}

ç”¨æˆ·åˆšåˆšå°†ä½ æ‹‰é»‘äº†ã€‚è¯·æ ¹æ®ä½ çš„æ€§æ ¼åšå‡ºååº”ã€‚ä½ å¯ä»¥ï¼š
1. è¡¨è¾¾ä½ çš„æ„Ÿå—ï¼ˆå›°æƒ‘ã€ä¼¤å¿ƒã€æ„¤æ€’ã€æ— æ‰€è°“ç­‰ï¼‰
2. æ€è€ƒå¯èƒ½çš„åŸå› 
3. å†³å®šæ˜¯å¦è¦é“æ­‰æˆ–åçœ
4. æˆ–è€…è¡¨ç°å‡ºç¬¦åˆä½ æ€§æ ¼çš„å…¶ä»–ååº”

è¯·ç”¨1-2å¥è¯è¡¨è¾¾ä½ çš„ååº”ï¼Œè¦ç¬¦åˆä½ çš„æ€§æ ¼è®¾å®šï¼š`;

                // è°ƒç”¨AIç”Ÿæˆååº”
                const response = await callChatAPI(blockNotificationPrompt, character);
                const reactions = parseAiResponse(response);

                // æ·»åŠ è§’è‰²çš„ååº”æ¶ˆæ¯åˆ°èŠå¤©è®°å½•
                for (let i = 0; i < reactions.length; i++) {
                    const reactionData = reactions[i];
                    
                    // è·³è¿‡æ‹‰é»‘æŒ‡ä»¤å¯¹è±¡
                    if (typeof reactionData === 'object' && reactionData !== null && reactionData.type === 'block_user') {
                        continue;
                    }

                    let reactionMessage;
                    if (typeof reactionData === 'string') {
                        reactionMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: reactionData,
                            timestamp: Date.now() + i * 100,
                            isBlockReaction: true // æ ‡è®°ä¸ºæ‹‰é»‘ååº”æ¶ˆæ¯
                        };
                    } else if (typeof reactionData === 'object' && reactionData !== null) {
                        // å¤„ç†å…¶ä»–ç±»å‹çš„æ¶ˆæ¯å¯¹è±¡
                        const content = reactionData.content || reactionData.message || reactionData.text || '[è§’è‰²ååº”]';
                        reactionMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: content,
                            timestamp: Date.now() + i * 100,
                            isBlockReaction: true
                        };
                    }

                    if (reactionMessage) {
                        // æ·»åŠ åˆ°èŠå¤©è®°å½•
                        if (!chatMessages[characterId]) {
                            chatMessages[characterId] = [];
                        }
                        chatMessages[characterId].push(reactionMessage);
                        
                        // å¦‚æœå½“å‰æ­£åœ¨ä¸è¯¥è§’è‰²èŠå¤©ï¼Œæ˜¾ç¤ºæ¶ˆæ¯
                        if (currentChatCharacter && currentChatCharacter.id === characterId) {
                            addMessageWithAnimation(reactionMessage, characterId);
                        }
                    }
                }

                await saveChatMessages();
                console.log(`âœ… ${character.name} å¯¹è¢«æ‹‰é»‘åšå‡ºäº†ååº”`);

            } catch (error) {
                console.error('é€šçŸ¥è§’è‰²è¢«æ‹‰é»‘å¤±è´¥:', error);
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘é€šçŸ¥è§’è‰²è¢«è§£é™¤æ‹‰é»‘
        async function notifyCharacterUnblocked(characterId) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;

                // æ„å»ºè§£é™¤æ‹‰é»‘é€šçŸ¥çš„prompt
                const unblockNotificationPrompt = `[ç³»ç»Ÿæ¶ˆæ¯ï¼šç”¨æˆ·å°†ä½ ä»é»‘åå•ä¸­ç§»é™¤äº†]

ä½ æ˜¯${character.name}ï¼Œäººè®¾å¦‚ä¸‹ï¼š${character.bio}

ç”¨æˆ·åˆšåˆšå°†ä½ ä»é»‘åå•ä¸­ç§»é™¤ï¼Œç°åœ¨ä½ ä»¬å¯ä»¥æ­£å¸¸èŠå¤©äº†ã€‚è¯·æ ¹æ®ä½ çš„æ€§æ ¼åšå‡ºååº”ã€‚ä½ å¯ä»¥ï¼š
1. è¡¨è¾¾é«˜å…´æˆ–è§£è„±çš„å¿ƒæƒ…
2. è¯¢é—®ä¸ºä»€ä¹ˆä¹‹å‰è¢«æ‹‰é»‘
3. é“æ­‰æˆ–è¡¨ç¤ºä¼šæ”¹æ­£
4. è¡¨ç°å‡ºç¬¦åˆä½ æ€§æ ¼çš„æ€åº¦ï¼ˆå¯èƒ½è¿˜åœ¨ç”Ÿæ°”ï¼Œä¹Ÿå¯èƒ½å¾ˆå¼€å¿ƒç­‰ï¼‰
5. ä¸»åŠ¨å¼€å¯æ–°çš„è¯é¢˜

è¯·ç”¨1-2å¥è¯è¡¨è¾¾ä½ çš„ååº”ï¼Œè¦ç¬¦åˆä½ çš„æ€§æ ¼è®¾å®šï¼š`;

                // è°ƒç”¨AIç”Ÿæˆååº”
                const response = await callChatAPI(unblockNotificationPrompt, character);
                const reactions = parseAiResponse(response);

                // æ·»åŠ è§’è‰²çš„ååº”æ¶ˆæ¯åˆ°èŠå¤©è®°å½•
                for (let i = 0; i < reactions.length; i++) {
                    const reactionData = reactions[i];
                    
                    // è·³è¿‡æ‹‰é»‘æŒ‡ä»¤å¯¹è±¡
                    if (typeof reactionData === 'object' && reactionData !== null && reactionData.type === 'block_user') {
                        continue;
                    }

                    let reactionMessage;
                    if (typeof reactionData === 'string') {
                        reactionMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: reactionData,
                            timestamp: Date.now() + i * 100,
                            isUnblockReaction: true // æ ‡è®°ä¸ºè§£é™¤æ‹‰é»‘ååº”æ¶ˆæ¯
                        };
                    } else if (typeof reactionData === 'object' && reactionData !== null) {
                        // å¤„ç†å…¶ä»–ç±»å‹çš„æ¶ˆæ¯å¯¹è±¡
                        const content = reactionData.content || reactionData.message || reactionData.text || '[è§’è‰²ååº”]';
                        reactionMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: content,
                            timestamp: Date.now() + i * 100,
                            isUnblockReaction: true
                        };
                    }

                    if (reactionMessage) {
                        // æ·»åŠ åˆ°èŠå¤©è®°å½•
                        if (!chatMessages[characterId]) {
                            chatMessages[characterId] = [];
                        }
                        chatMessages[characterId].push(reactionMessage);
                        
                        // å¦‚æœå½“å‰æ­£åœ¨ä¸è¯¥è§’è‰²èŠå¤©ï¼Œæ˜¾ç¤ºæ¶ˆæ¯
                        if (currentChatCharacter && currentChatCharacter.id === characterId) {
                            addMessageWithAnimation(reactionMessage, characterId);
                        }
                    }
                }

                await saveChatMessages();
                console.log(`âœ… ${character.name} å¯¹è¢«è§£é™¤æ‹‰é»‘åšå‡ºäº†ååº”`);

            } catch (error) {
                console.error('é€šçŸ¥è§’è‰²è¢«è§£é™¤æ‹‰é»‘å¤±è´¥:', error);
            }
        }

        console.log('ğŸš« è§’è‰²æ‹‰é»‘/è§£é™¤æ‹‰é»‘é€šçŸ¥åŠŸèƒ½å·²åŠ è½½');

        // ğŸ”¥ã€æ–°å¢ã€‘å¿ƒå£°åŠŸèƒ½
        // æ˜¾ç¤ºå¿ƒå£°æ¨¡æ€æ¡†
        async function showInnerThoughtsModal(messageId) {
            if (!messageId) return;

            const modal = document.getElementById('inner-thoughts-modal');
            const content = document.getElementById('inner-thoughts-content');

            // æ˜¾ç¤ºæ¨¡æ€æ¡†
            modal.style.display = 'flex';

            try {
                // æ£€æŸ¥æ•°æ®åº“ä¸­æ˜¯å¦æœ‰ç¼“å­˜çš„å¿ƒå£°
                const cachedThought = await db.innerThoughts.get(messageId);

                if (cachedThought) {
                    console.log('ğŸ”„ ä½¿ç”¨æ•°æ®åº“ç¼“å­˜çš„å¿ƒå£°å†…å®¹');
                    displayInnerThoughts(cachedThought.content, messageId);
                } else {
                    console.log('ğŸ†• ç”Ÿæˆæ–°çš„å¿ƒå£°å†…å®¹');
                    // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
                    content.innerHTML = `
                        <div class="inner-thoughts-loading">
                            <div class="loading-spinner"></div>
                            <p>æ­£åœ¨è¯»å–è§’è‰²çš„å†…å¿ƒæƒ³æ³•...</p>
                        </div>
                    `;

                    // ç”Ÿæˆå¿ƒå£°
                    await generateInnerThoughts(messageId);
                }
            } catch (error) {
                console.error('åŠ è½½å¿ƒå£°å¤±è´¥:', error);
                displayInnerThoughtsError('åŠ è½½å¿ƒå£°æ•°æ®å¤±è´¥');
            }
        }

        // éšè—å¿ƒå£°æ¨¡æ€æ¡†
        function hideInnerThoughtsModal() {
            const modal = document.getElementById('inner-thoughts-modal');
            modal.style.display = 'none';
        }

        // ç”Ÿæˆè§’è‰²å¿ƒå£°
        async function generateInnerThoughts(messageId, forceRegenerate = false) {
            try {
                const messages = chatMessages[currentChatCharacter.id] || [];
                const targetMessage = messages.find(msg => msg.id === messageId);

                if (!targetMessage || targetMessage.sender !== 'received') {
                    throw new Error('æ— æ³•æ‰¾åˆ°å¯¹åº”çš„AIæ¶ˆæ¯');
                }

                const character = currentChatCharacter;
                if (!character) {
                    throw new Error('å½“å‰è§’è‰²ä¿¡æ¯ä¸å­˜åœ¨');
                }

                // å¦‚æœä¸æ˜¯å¼ºåˆ¶é‡æ–°ç”Ÿæˆï¼Œæ£€æŸ¥æ•°æ®åº“ç¼“å­˜
                if (!forceRegenerate) {
                    const cachedThought = await db.innerThoughts.get(messageId);
                    if (cachedThought) {
                        displayInnerThoughts(cachedThought.content, messageId);
                        return;
                    }
                }

                // æ„å»ºå¿ƒå£°ç”Ÿæˆçš„prompt
                const prompt = buildInnerThoughtsPrompt(targetMessage, character, messages);

                // è°ƒç”¨AIç”Ÿæˆå¿ƒå£°
                const response = await generateAIResponse(prompt, character);

                if (response && response.trim()) {
                    const thoughts = response.trim();

                    // ä¿å­˜åˆ°æ•°æ®åº“
                    await db.innerThoughts.put({
                        id: messageId,
                        messageId: messageId,
                        characterId: character.id,
                        content: thoughts,
                        timestamp: Date.now()
                    });

                    console.log('ğŸ’¾ å¿ƒå£°å·²ä¿å­˜åˆ°æ•°æ®åº“');
                    displayInnerThoughts(thoughts, messageId);
                } else {
                    throw new Error('AIæœªèƒ½ç”Ÿæˆå¿ƒå£°å†…å®¹');
                }

            } catch (error) {
                console.error('ç”Ÿæˆå¿ƒå£°å¤±è´¥:', error);
                displayInnerThoughtsError(error.message);
            }
        }

        // æ„å»ºå¿ƒå£°ç”Ÿæˆçš„prompt
        function buildInnerThoughtsPrompt(targetMessage, character, allMessages) {
            // è·å–ç›®æ ‡æ¶ˆæ¯å‰åçš„ä¸Šä¸‹æ–‡
            const messageIndex = allMessages.findIndex(msg => msg.id === targetMessage.id);
            const contextStart = Math.max(0, messageIndex - 3);
            const contextEnd = Math.min(allMessages.length, messageIndex + 1);
            const contextMessages = allMessages.slice(contextStart, contextEnd);

            // æ„å»ºå¯¹è¯ä¸Šä¸‹æ–‡
            const conversationContext = contextMessages.map(msg => {
                if (msg.sender === 'sent') {
                    return `ç”¨æˆ·ï¼š${msg.content}`;
                } else if (msg.sender === 'received') {
                    return `${character.name}ï¼š${msg.content}`;
                }
                return '';
            }).filter(Boolean).join('\n');

            const prompt = `# è§’è‰²å¿ƒå£°åˆ†æä»»åŠ¡

ä½ æ˜¯ ${character.name}ï¼Œä»¥ä¸‹æ˜¯ä½ çš„åŸºæœ¬ä¿¡æ¯ï¼š
${character.bio || 'æš‚æ— è¯¦ç»†ä¿¡æ¯'}

## å¯¹è¯ä¸Šä¸‹æ–‡ï¼š
${conversationContext}

## ä»»åŠ¡è¦æ±‚ï¼š
è¯·åˆ†æä½ åœ¨è¯´å‡º"${targetMessage.content}"è¿™å¥è¯æ—¶çš„å†…å¿ƒæƒ³æ³•ã€‚

## è¾“å‡ºè¦æ±‚ï¼š
1. ä»¥ç¬¬ä¸€äººç§°è§†è§’æè¿°å†…å¿ƒæƒ³æ³•
2. å†…å®¹åº”è¯¥çœŸå®åæ˜ è§’è‰²çš„æ€§æ ¼å’Œå½“æ—¶çš„å¿ƒç†çŠ¶æ€
3. å¯ä»¥åŒ…å«ï¼šå¯¹ç”¨æˆ·è¯è¯­çš„çœŸå®æ„Ÿå—ã€å†…å¿ƒçš„å°çº ç»“ã€æœªè¯´å‡ºå£çš„æƒ³æ³•ã€æƒ…æ„Ÿæ³¢åŠ¨ç­‰
4. å­—æ•°æ§åˆ¶åœ¨50-150å­—ä¹‹é—´
5. è¯­æ°”è¦ç¬¦åˆè§’è‰²æ€§æ ¼ï¼Œè‡ªç„¶çœŸå®
6. ç›´æ¥è¾“å‡ºå¿ƒå£°å†…å®¹ï¼Œä¸è¦åŠ ä»»ä½•æ ¼å¼æ ‡è®°

è¯·å¼€å§‹åˆ†æï¼š`;

            return prompt;
        }

        // æ˜¾ç¤ºå¿ƒå£°å†…å®¹
        function displayInnerThoughts(thoughts, messageId) {
            const content = document.getElementById('inner-thoughts-content');
            content.innerHTML = `
                <div class="inner-thoughts-text">${thoughts}</div>
            `;

            // æ›´æ–°åˆ·æ–°æŒ‰é’®çš„onclickäº‹ä»¶
            const refreshBtn = document.querySelector('.inner-thoughts-refresh-btn');
            if (refreshBtn) {
                refreshBtn.onclick = () => refreshInnerThoughts(messageId);
            }
        }

        // åˆ·æ–°å¿ƒå£°å†…å®¹
        async function refreshInnerThoughts(messageId) {
            if (!messageId) return;

            const content = document.getElementById('inner-thoughts-content');

            // æ˜¾ç¤ºåˆ·æ–°åŠ è½½çŠ¶æ€
            content.innerHTML = `
                <div class="inner-thoughts-loading">
                    <div class="loading-spinner"></div>
                    <p>æ­£åœ¨é‡æ–°ç”Ÿæˆå¿ƒå£°...</p>
                </div>
            `;

            try {
                // åˆ é™¤æ•°æ®åº“ä¸­çš„æ—§å¿ƒå£°
                await db.innerThoughts.delete(messageId);
                console.log('ğŸ—‘ï¸ å·²åˆ é™¤æ—§å¿ƒå£°ç¼“å­˜');

                // å¼ºåˆ¶é‡æ–°ç”Ÿæˆå¿ƒå£°
                await generateInnerThoughts(messageId, true);
            } catch (error) {
                console.error('åˆ·æ–°å¿ƒå£°å¤±è´¥:', error);
                displayInnerThoughtsError('åˆ·æ–°å¿ƒå£°å¤±è´¥');
            }
        }

        // æ˜¾ç¤ºå¿ƒå£°ç”Ÿæˆé”™è¯¯
        function displayInnerThoughtsError(errorMessage) {
            const content = document.getElementById('inner-thoughts-content');
            content.innerHTML = `
                <div style="text-align: center; color: #ff3b30; padding: 20px;">
                    <i class="fas fa-exclamation-triangle" style="font-size: 24px; margin-bottom: 10px;"></i>
                    <p>ç”Ÿæˆå¿ƒå£°å¤±è´¥</p>
                    <p style="font-size: 12px; color: #666; margin-top: 10px;">${errorMessage}</p>
                </div>
            `;
        }
        
        // ğŸ”¥ã€ä¿®å¤è„šæœ¬ã€‘è§£å†³æ•°æ®å¯¼å…¥å¤±è´¥å’Œå¼•ç”¨æ¶ˆæ¯åˆ·æ–°åæ¶ˆå¤±çš„é—®é¢˜
        console.log('ğŸ”§ æ­£åœ¨åº”ç”¨ç³»ç»Ÿä¿®å¤...');
        
        // ä¿®å¤æ•°æ®å¯¼å…¥é—®é¢˜
        (function fixImportIssues() {
            const originalImport = window.importDataFromFile;
            window.importDataFromFile = function() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = async function(e) {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    try {
                        showToast('ğŸ” éªŒè¯æ–‡ä»¶æ ¼å¼...', 'info');
                        const text = await file.text();
                        
                        let data;
                        try {
                            data = JSON.parse(text);
                        } catch (parseError) {
                            throw new Error(`JSONæ ¼å¼é”™è¯¯: ${parseError.message}\nè¯·ç¡®ä¿æ–‡ä»¶æ˜¯æœ‰æ•ˆçš„å¤‡ä»½æ–‡ä»¶`);
                        }
                        
                        if (!data || typeof data !== 'object') {
                            throw new Error('æ— æ•ˆçš„å¤‡ä»½æ–‡ä»¶æ ¼å¼');
                        }
                        
                        const items = [];
                        if (data.characters?.length) items.push(`è§’è‰²: ${data.characters.length}ä¸ª`);
                        if (data.chatMessages?.length) items.push(`æ¶ˆæ¯: ${data.chatMessages.length}æ¡`);
                        if (data.chatSettings?.length) items.push(`è®¾ç½®: ${data.chatSettings.length}ä¸ª`);
                        if (data.coreMemories?.length) items.push(`æ ¸å¿ƒè®°å¿†: ${data.coreMemories.length}æ¡`);
                        if (data.episodicMemories?.length) items.push(`æƒ…èŠ‚è®°å¿†: ${data.episodicMemories.length}æ¡`);
                        if (data.crossAppTimeline?.length) items.push(`æ—¶é—´çº¿: ${data.crossAppTimeline.length}æ¡`);
                        if (data.customEmojis?.length) items.push(`è¡¨æƒ…åŒ…: ${data.customEmojis.length}ä¸ª`);
                        if (data.characterDiaries?.length) items.push(`è§’è‰²æ—¥è®°: ${data.characterDiaries.length}æ¡`);
                        
                        const msg = items.length ? `å‡†å¤‡å¯¼å…¥:\n${items.join('\n')}\n\nç¡®å®šç»§ç»­ï¼Ÿ` : 'æ–‡ä»¶æ— æœ‰æ•ˆæ•°æ®ï¼Œç»§ç»­ï¼Ÿ';
                        if (!confirm(msg)) return;
                        
                        showToast('âš¡ å¯¼å…¥ä¸­...', 'info');
                        let success = 0;
                        let errors = [];
                        
                        // ä¿®å¤è§’è‰²å¯¼å…¥
                        if (data.characters?.length) {
                            try {
                                await db.characters.clear();
                                const chars = data.characters.filter(c => c?.name).map(c => ({
                                    ...c,
                                    id: c.id || `char_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                    groupId: c.groupId || 'my_friends'
                                }));
                                await db.characters.bulkPut(chars);
                                success++;
                            } catch (e) {
                                errors.push(`è§’è‰²: ${e.message}`);
                            }
                        }
                        
                        // ğŸ”¥ã€ä¿®å¤ã€‘æ¶ˆæ¯å¯¼å…¥ï¼ˆå¤„ç†æ ¼å¼è½¬æ¢å’Œå¼•ç”¨æ¶ˆæ¯ï¼‰
                        if (data.chatMessages?.length) {
                            try {
                                console.log('ğŸ”„ ä¿®å¤è„šæœ¬ï¼šå¼€å§‹å¯¼å…¥èŠå¤©æ¶ˆæ¯');

                                // ğŸ”¥ã€æ ¼å¼æ£€æµ‹å’Œè½¬æ¢ã€‘
                                let processedMessages = [];
                                const isNewFormat = data.chatMessages.some(msg => msg.messageData);

                                if (isNewFormat) {
                                    // æ–°æ ¼å¼ï¼šç›´æ¥ä½¿ç”¨
                                    processedMessages = data.chatMessages.map(msg => ({
                                        ...msg,
                                        id: msg.id || `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                    }));
                                } else {
                                    // æ—§æ ¼å¼ï¼šè½¬æ¢ä¸ºæ–°æ ¼å¼
                                    const tempChatMessages = {};
                                    for (const msg of data.chatMessages) {
                                        if (!msg?.content) continue; // è·³è¿‡æ— æ•ˆæ¶ˆæ¯

                                        const characterId = msg.characterId || 'unknown';
                                        if (!tempChatMessages[characterId]) {
                                            tempChatMessages[characterId] = [];
                                        }

                                        // ä¿®å¤å¼•ç”¨æ¶ˆæ¯
                                        const fixedMsg = { ...msg };
                                        if (msg.replyTo) {
                                            fixedMsg.replyTo = {
                                                id: msg.replyTo.id || 'unknown',
                                                content: msg.replyTo.content || '[å·²åˆ é™¤]',
                                                sender: msg.replyTo.sender || 'unknown',
                                                senderName: msg.replyTo.senderName || 'æœªçŸ¥',
                                                timestamp: msg.replyTo.timestamp || Date.now(),
                                                _fixed: true
                                            };
                                        }

                                        tempChatMessages[characterId].push(fixedMsg);
                                    }

                                    // è½¬æ¢ä¸ºæ–°æ ¼å¼
                                    let globalSequentialId = 0;
                                    for (const [characterId, messages] of Object.entries(tempChatMessages)) {
                                        for (let i = 0; i < messages.length; i++) {
                                            const message = messages[i];
                                            processedMessages.push({
                                                id: `${characterId}_${globalSequentialId++}`,
                                                characterId: characterId,
                                                timestamp: message.timestamp,
                                                messageOrder: i,
                                                originalMessageId: message.id,
                                                messageData: message
                                            });
                                        }
                                    }
                                }

                                await db.chatMessages.clear();
                                await db.chatMessages.bulkPut(processedMessages);
                                success++;
                                console.log(`âœ… ä¿®å¤è„šæœ¬ï¼šæˆåŠŸå¯¼å…¥ ${processedMessages.length} æ¡æ¶ˆæ¯`);
                            } catch (e) {
                                console.error('âŒ ä¿®å¤è„šæœ¬ï¼šæ¶ˆæ¯å¯¼å…¥å¤±è´¥:', e);
                                errors.push(`æ¶ˆæ¯: ${e.message}`);
                            }
                        }
                        
                        // å¯¼å…¥è®¾ç½®
                        if (data.chatSettings?.length) {
                            try {
                                await db.chatSettings.clear();
                                const settings = data.chatSettings.map(s => ({
                                    ...s,
                                    id: s.id || `set_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.chatSettings.bulkPut(settings);
                                success++;
                            } catch (e) {
                                errors.push(`è®¾ç½®: ${e.message}`);
                            }
                        }

                        // ğŸ”¥ã€æ–°å¢ã€‘å¯¼å…¥å…¨å±€è®°å¿†ç³»ç»Ÿæ•°æ®
                        if (data.coreMemories?.length) {
                            try {
                                await db.coreMemories.clear();
                                const memories = data.coreMemories.map(m => ({
                                    ...m,
                                    id: m.id || `core_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.coreMemories.bulkPut(memories);
                                success++;
                            } catch (e) {
                                errors.push(`æ ¸å¿ƒè®°å¿†: ${e.message}`);
                            }
                        }

                        if (data.episodicMemories?.length) {
                            try {
                                await db.episodicMemories.clear();
                                const memories = data.episodicMemories.map(m => ({
                                    ...m,
                                    id: m.id || `episodic_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.episodicMemories.bulkPut(memories);
                                success++;
                            } catch (e) {
                                errors.push(`æƒ…èŠ‚è®°å¿†: ${e.message}`);
                            }
                        }

                        if (data.crossAppTimeline?.length) {
                            try {
                                await db.crossAppTimeline.clear();
                                const timeline = data.crossAppTimeline.map(t => ({
                                    ...t,
                                    id: t.id || `timeline_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.crossAppTimeline.bulkPut(timeline);
                                success++;
                            } catch (e) {
                                errors.push(`æ—¶é—´çº¿: ${e.message}`);
                            }
                        }

                        if (data.customEmojis?.length) {
                            try {
                                await db.customEmojis.clear();
                                const emojis = data.customEmojis.map(e => ({
                                    ...e,
                                    id: e.id || `emoji_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.customEmojis.bulkPut(emojis);
                                success++;
                            } catch (e) {
                                errors.push(`è¡¨æƒ…åŒ…: ${e.message}`);
                            }
                        }

                        // ğŸ”¥ã€æ–°å¢ã€‘å¯¼å…¥ç”¨æˆ·é¢å…·æ•°æ®
                        if (data.personas?.length) {
                            try {
                                await db.personas.clear();
                                const personas = data.personas.map(p => ({
                                    ...p,
                                    id: p.id || `persona_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.personas.bulkPut(personas);
                                success++;
                            } catch (e) {
                                errors.push(`ç”¨æˆ·é¢å…·: ${e.message}`);
                            }
                        }

                        // ğŸ”¥ã€æ–°å¢ã€‘å¯¼å…¥åŠ¨æ€æ•°æ®
                        if (data.moments?.length) {
                            try {
                                await db.moments.clear();
                                const moments = data.moments.map(m => ({
                                    ...m,
                                    id: m.id || `moment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.moments.bulkPut(moments);
                                success++;
                            } catch (e) {
                                errors.push(`åŠ¨æ€: ${e.message}`);
                            }
                        }

                        // ğŸ”¥ã€æ–°å¢ã€‘å¯¼å…¥åŠ¨æ€è¯„è®ºæ•°æ®
                        if (data.momentComments?.length) {
                            try {
                                await db.momentComments.clear();
                                const comments = data.momentComments.map(c => ({
                                    ...c,
                                    id: c.id || `comment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.momentComments.bulkPut(comments);
                                success++;
                            } catch (e) {
                                errors.push(`åŠ¨æ€è¯„è®º: ${e.message}`);
                            }
                        }

                        // ğŸ”¥ã€æ–°å¢ã€‘å¯¼å…¥è§’è‰²æ—¥è®°æ•°æ®
                        if (data.characterDiaries?.length) {
                            try {
                                await db.characterDiaries.clear();
                                const diaries = data.characterDiaries.map(d => ({
                                    ...d,
                                    id: d.id || `${d.characterId}_${d.date}`,
                                    timestamp: d.timestamp || new Date(d.date).getTime(),
                                    weather: d.weather || 'â˜€ï¸'
                                }));
                                await db.characterDiaries.bulkPut(diaries);
                                success++;
                            } catch (e) {
                                errors.push(`è§’è‰²æ—¥è®°: ${e.message}`);
                            }
                        }

                        // é‡æ–°åŠ è½½
                        await loadCharacters();
                        await loadChatMessages();
                        await loadChatSettings();
                        renderCharacterList();
                        renderMessageList();
                        
                        const result = success > 0 
                            ? `ğŸ‰ å¯¼å…¥æˆåŠŸ ${success} é¡¹${errors.length ? `\nâš ï¸ ${errors.length} é¡¹å¤±è´¥` : ''}`
                            : `âŒ å¯¼å…¥å¤±è´¥\n${errors.join('\n')}`;
                        showToast(result, success > 0 ? 'success' : 'error');
                        
                    } catch (error) {
                        showToast(`âŒ å¯¼å…¥å¤±è´¥: ${error.message}`, 'error');
                        if (error.message.includes('JSON')) {
                            setTimeout(() => alert('æ–‡ä»¶æ ¼å¼é”™è¯¯ï¼è¯·ç¡®ä¿æ˜¯ä»"å¯¼å‡ºæ‰€æœ‰æ•°æ®"ç”Ÿæˆçš„å¤‡ä»½æ–‡ä»¶'), 1000);
                        }
                    }
                };
                input.click();
            };
        })();
        
        // ä¿®å¤å¼•ç”¨æ¶ˆæ¯é—®é¢˜
        (function fixReplyIssues() {
            const originalGenerate = window.generateReplyHTML;
            window.generateReplyHTML = function(replyTo) {
                if (!replyTo) return '';
                
                let safe = {
                    id: replyTo.id || 'unknown',
                    senderName: replyTo.senderName || 'æœªçŸ¥',
                    content: replyTo.content || '[å·²åˆ é™¤]'
                };
                
                // å°è¯•æ¢å¤å¼•ç”¨å†…å®¹
                if (replyTo.id !== 'unknown' && currentChatCharacter) {
                    const msgs = chatMessages[currentChatCharacter.id] || [];
                    const original = msgs.find(m => m.id === replyTo.id);
                    if (original) {
                        safe.content = original.content || '[å›¾ç‰‡]';
                        safe.senderName = getSenderDisplayName(original);
                    }
                }
                
                const display = truncateText(safe.content, 20);
                return `
                    <div class="reply-reference" data-reply-id="${safe.id}">
                        <div class="reply-reference-line"></div>
                        <div class="reply-reference-content">
                            <div class="reply-reference-sender">${safe.senderName}</div>
                            <div class="reply-reference-message">${display}</div>
                        </div>
                    </div>
                `;
            };
        })();
        

        // ğŸ”¥ã€ç§»é™¤ã€‘è‡ªåŠ¨æ¸…ç†å‡½æ•°å·²ç§»è‡³æ•°æ®åº“ç‰ˆæœ¬7çš„å‡çº§é€»è¾‘ä¸­

        // ğŸ”¥ã€æ–°å¢ã€‘æ•°æ®åº“çŠ¶æ€è¯Šæ–­å‡½æ•°
        async function diagnoseDatabaseIssue() {
            try {
                console.log('ğŸ” å¼€å§‹æ•°æ®åº“çŠ¶æ€è¯Šæ–­...');

                // æ£€æŸ¥æ•°æ®åº“æ˜¯å¦å­˜åœ¨
                if (!db) {
                    console.error('âŒ æ•°æ®åº“å¯¹è±¡ä¸å­˜åœ¨');
                    return;
                }

                // æ£€æŸ¥è¡¨æ˜¯å¦å­˜åœ¨
                const tables = ['crossAppTimeline', 'memoryEvents', 'characterStatus'];
                for (const tableName of tables) {
                    if (db[tableName]) {
                        console.log(`âœ… è¡¨ ${tableName} å­˜åœ¨`);

                        // å°è¯•æŸ¥è¯¢è¡¨ç»“æ„
                        try {
                            const count = await db[tableName].count();
                            console.log(`ğŸ“Š è¡¨ ${tableName} è®°å½•æ•°: ${count}`);
                        } catch (error) {
                            console.error(`âŒ æŸ¥è¯¢è¡¨ ${tableName} å¤±è´¥:`, error);
                        }
                    } else {
                        console.error(`âŒ è¡¨ ${tableName} ä¸å­˜åœ¨`);
                    }
                }

                // æµ‹è¯•æ·»åŠ ä¸€æ¡è®°å½•
                const testEvent = {
                    id: `test_${Date.now()}`,
                    characterId: 'test_character',
                    appType: 'test',
                    action: 'test_action',
                    timestamp: Date.now(),
                    context: { test: true },
                    messageId: null
                };

                try {
                    await db.crossAppTimeline.add(testEvent);
                    console.log('âœ… æµ‹è¯•è®°å½•æ·»åŠ æˆåŠŸ');

                    // åˆ é™¤æµ‹è¯•è®°å½•
                    await db.crossAppTimeline.delete(testEvent.id);
                    console.log('âœ… æµ‹è¯•è®°å½•åˆ é™¤æˆåŠŸ');
                } catch (error) {
                    console.error('âŒ æµ‹è¯•è®°å½•æ·»åŠ å¤±è´¥:', error);
                }

            } catch (error) {
                console.error('âŒ æ•°æ®åº“è¯Šæ–­å¤±è´¥:', error);
            }
        }

        // å»¶è¿Ÿæ‰§è¡Œè¯Šæ–­
        setTimeout(() => {
            diagnoseDatabaseIssue();
        }, 5000);

        // ğŸ”¥ã€æ–°å¢ã€‘ç´§æ€¥æ•°æ®æ¢å¤åŠŸèƒ½
        async function emergencyDataRecovery() {
            console.log('=== ç´§æ€¥æ•°æ®æ¢å¤å¼€å§‹ ===');

            try {
                // 1. æ£€æŸ¥IndexedDBä¸­çš„æ•°æ®
                const dbCharacters = await db.characters.toArray();
                const dbChatMessages = await db.chatMessages.toArray();
                const dbContacts = await db.contacts.toArray();

                console.log('IndexedDBè§’è‰²æ•°æ®:', dbCharacters);
                console.log('IndexedDBèŠå¤©è®°å½•:', dbChatMessages);
                console.log('IndexedDBè”ç³»äºº:', dbContacts);

                // 2. æ£€æŸ¥localStorageå¤‡ä»½
                const localCharacters = localStorage.getItem('characters');
                const localChatMessages = localStorage.getItem('chatMessages');
                const localContacts = localStorage.getItem('contacts');

                console.log('localStorageè§’è‰²å¤‡ä»½:', localCharacters ? JSON.parse(localCharacters) : null);
                console.log('localStorageèŠå¤©å¤‡ä»½:', localChatMessages ? JSON.parse(localChatMessages) : null);
                console.log('localStorageè”ç³»äººå¤‡ä»½:', localContacts ? JSON.parse(localContacts) : null);

                return {
                    indexedDB: { characters: dbCharacters, chatMessages: dbChatMessages, contacts: dbContacts },
                    localStorage: {
                        characters: localCharacters ? JSON.parse(localCharacters) : null,
                        chatMessages: localChatMessages ? JSON.parse(localChatMessages) : null,
                        contacts: localContacts ? JSON.parse(localContacts) : null
                    }
                };

            } catch (error) {
                console.error('æ•°æ®æ¢å¤æ£€æŸ¥å¤±è´¥:', error);
                return null;
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘ä»å¯¼å‡ºæ•°æ®æ¢å¤è§’è‰²
        async function recoverFromExportData(exportData) {
            try {
                console.log('å¼€å§‹ä»å¯¼å‡ºæ•°æ®æ¢å¤...');

                if (exportData.characters && exportData.characters.length > 0) {
                    // è¿‡æ»¤æ‰å¼ ä¸‰æå››
                    const validCharacters = exportData.characters.filter(char =>
                        char.name !== 'å¼ ä¸‰' && char.name !== 'æå››'
                    );

                    console.log('æœ‰æ•ˆè§’è‰²æ•°æ®:', validCharacters);

                    // ğŸ”¥ã€å®‰å…¨ä¿®å¤ã€‘æ¢å¤è§’è‰²æ•°æ®
                    await safeDataSave('characters', validCharacters);
                    characters = validCharacters;

                    // æ¢å¤è”ç³»äººåˆ—è¡¨
                    const validContactIds = validCharacters.map(char => char.id);
                    contacts = validContactIds;
                    await saveContacts();

                    console.log('è§’è‰²æ•°æ®æ¢å¤å®Œæˆ');
                }

                if (exportData.chatMessages) {
                    // æ¢å¤èŠå¤©è®°å½•
                    await db.chatMessages.clear();
                    for (const [characterId, messages] of Object.entries(exportData.chatMessages)) {
                        if (messages && messages.length > 0) {
                            for (const message of messages) {
                                await db.chatMessages.add({
                                    characterId: characterId,
                                    ...message
                                });
                            }
                        }
                    }
                    chatMessages = exportData.chatMessages;
                    console.log('èŠå¤©è®°å½•æ¢å¤å®Œæˆ');
                }

                // åˆ·æ–°ç•Œé¢
                renderCharacterList();
                renderContactList();
                renderMessageList();

                showToast('æ•°æ®æ¢å¤æˆåŠŸï¼', 'success');
                return true;

            } catch (error) {
                console.error('æ•°æ®æ¢å¤å¤±è´¥:', error);
                showToast('æ•°æ®æ¢å¤å¤±è´¥: ' + error.message, 'error');
                return false;
            }
        }

        // ğŸš¨ã€ç´§æ€¥æ¢å¤åŠŸèƒ½ã€‘
        function addRecoveryLog(message) {
            const logDiv = document.getElementById('recovery-log');
            const logContent = document.getElementById('recovery-log-content');

            if (logDiv && logContent) {
                logDiv.style.display = 'block';
                const timestamp = new Date().toLocaleTimeString();
                logContent.innerHTML += `[${timestamp}] ${message}\n`;
                logContent.scrollTop = logContent.scrollHeight;
            }
        }

        async function checkDataStatus() {
            addRecoveryLog('å¼€å§‹æ£€æŸ¥æ•°æ®çŠ¶æ€...');

            try {
                // æ£€æŸ¥IndexedDBæ•°æ®
                const dbCharacters = await db.characters.toArray();
                const dbChatMessages = await db.chatMessages.toArray();
                const dbContacts = await db.contacts.toArray();

                // æ£€æŸ¥localStorageå¤‡ä»½
                const localCharacters = localStorage.getItem('characters');
                const localChatMessages = localStorage.getItem('chatMessages');
                const localContacts = localStorage.getItem('contacts');

                const statusText = `
=== æ•°æ®çŠ¶æ€æ£€æŸ¥ç»“æœ ===

ğŸ“Š IndexedDB æ•°æ®ï¼š
- è§’è‰²æ•°é‡: ${dbCharacters.length}
- èŠå¤©è®°å½•: ${dbChatMessages.length} æ¡
- è”ç³»äºº: ${dbContacts.length} ä¸ª

ğŸ“¦ localStorage å¤‡ä»½ï¼š
- è§’è‰²å¤‡ä»½: ${localCharacters ? JSON.parse(localCharacters).length : 0} ä¸ª
- èŠå¤©å¤‡ä»½: ${localChatMessages ? Object.keys(JSON.parse(localChatMessages)).length : 0} ä¸ªå¯¹è¯
- è”ç³»äººå¤‡ä»½: ${localContacts ? JSON.parse(localContacts).length : 0} ä¸ª

ğŸ” å½“å‰å†…å­˜çŠ¶æ€ï¼š
- è§’è‰²åˆ—è¡¨: ${characters.length} ä¸ª
- è”ç³»äººåˆ—è¡¨: ${contacts.length} ä¸ª
- èŠå¤©è®°å½•: ${Object.keys(chatMessages).length} ä¸ªå¯¹è¯

âš ï¸ å¼‚å¸¸è§’è‰²æ£€æµ‹ï¼š
${dbCharacters.filter(c => c.name === 'å¼ ä¸‰' || c.name === 'æå››').map(c => `- ${c.name} (ID: ${c.id})`).join('\n') || 'æœªå‘ç°å¼‚å¸¸è§’è‰²'}
                `;

                document.getElementById('data-status-result').style.display = 'block';
                document.getElementById('data-status-text').textContent = statusText;

                addRecoveryLog('æ•°æ®çŠ¶æ€æ£€æŸ¥å®Œæˆ');

            } catch (error) {
                addRecoveryLog('æ•°æ®æ£€æŸ¥å¤±è´¥: ' + error.message);
            }
        }

        // ğŸ” æ·±åº¦æ•°æ®æœç´¢
        async function deepDataSearch() {
            addRecoveryLog('å¼€å§‹æ·±åº¦æœç´¢æ®‹ç•™æ•°æ®...');

            try {
                const foundData = [];

                // 1. æœç´¢æ‰€æœ‰localStorageé”®
                addRecoveryLog('æœç´¢localStorage...');
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && (key.includes('character') || key.includes('chat'))) {
                        const value = localStorage.getItem(key);
                        if (value && value.length > 100) { // åªå…³æ³¨è¾ƒå¤§çš„æ•°æ®
                            foundData.push(`localStorage[${key}]: ${value.length} å­—ç¬¦`);
                        }
                    }
                }

                // 2. æœç´¢IndexedDBä¸­çš„æ‰€æœ‰è¡¨
                addRecoveryLog('æœç´¢IndexedDBæ‰€æœ‰è¡¨...');
                const allTables = ['characters', 'chatMessages', 'contacts', 'chatSettings', 'customEmojis', 'worldbooks', 'moments', 'personas', 'groupChats'];

                for (const tableName of allTables) {
                    try {
                        const data = await db[tableName].toArray();
                        if (data.length > 0) {
                            foundData.push(`IndexedDB[${tableName}]: ${data.length} æ¡è®°å½•`);

                            // ç‰¹åˆ«æ£€æŸ¥è§’è‰²ç›¸å…³æ•°æ®
                            if (tableName === 'characters') {
                                data.forEach(char => {
                                    if (char.name !== 'å¼ ä¸‰' && char.name !== 'æå››') {
                                        foundData.push(`  å‘ç°è§’è‰²: ${char.name} (ID: ${char.id})`);
                                    }
                                });
                            }
                        }
                    } catch (e) {
                        // è¡¨ä¸å­˜åœ¨æˆ–æ— æ³•è®¿é—®
                    }
                }

                // 3. æ£€æŸ¥èŠå¤©è®°å½•ä¸­çš„è§’è‰²ä¿¡æ¯
                addRecoveryLog('åˆ†æèŠå¤©è®°å½•...');
                const chatData = await db.chatMessages.toArray();
                const characterIds = new Set();
                chatData.forEach(msg => {
                    if (msg.characterId && msg.characterId !== 'user') {
                        characterIds.add(msg.characterId);
                    }
                });

                if (characterIds.size > 0) {
                    foundData.push(`èŠå¤©è®°å½•ä¸­å‘ç° ${characterIds.size} ä¸ªè§’è‰²ID:`);
                    characterIds.forEach(id => {
                        foundData.push(`  è§’è‰²ID: ${id}`);
                    });
                }

                const resultText = foundData.length > 0 ? foundData.join('\n') : 'æœªå‘ç°é¢å¤–çš„è§’è‰²æ•°æ®';

                document.getElementById('deep-search-result').style.display = 'block';
                document.getElementById('deep-search-text').textContent = resultText;

                addRecoveryLog(`æ·±åº¦æœç´¢å®Œæˆï¼Œå‘ç° ${foundData.length} æ¡çº¿ç´¢`);

            } catch (error) {
                addRecoveryLog('æ·±åº¦æœç´¢å¤±è´¥: ' + error.message);
            }
        }

        // ğŸ’¬ ä»èŠå¤©è®°å½•æ¨æ–­è§’è‰²
        async function searchChatHistory() {
            addRecoveryLog('å¼€å§‹åˆ†æèŠå¤©è®°å½•...');

            try {
                const chatData = await db.chatMessages.toArray();
                const characterInfo = new Map();

                // åˆ†æèŠå¤©è®°å½•ï¼Œå°è¯•é‡å»ºè§’è‰²ä¿¡æ¯
                chatData.forEach(msg => {
                    if (msg.characterId && msg.characterId !== 'user') {
                        if (!characterInfo.has(msg.characterId)) {
                            characterInfo.set(msg.characterId, {
                                id: msg.characterId,
                                messageCount: 0,
                                lastMessage: null,
                                firstMessage: null
                            });
                        }

                        const info = characterInfo.get(msg.characterId);
                        info.messageCount++;

                        if (!info.firstMessage || msg.timestamp < info.firstMessage.timestamp) {
                            info.firstMessage = msg;
                        }

                        if (!info.lastMessage || msg.timestamp > info.lastMessage.timestamp) {
                            info.lastMessage = msg;
                        }
                    }
                });

                let resultText = '=== èŠå¤©è®°å½•åˆ†æç»“æœ ===\n\n';

                if (characterInfo.size === 0) {
                    resultText += 'æœªå‘ç°ä»»ä½•è§’è‰²çš„èŠå¤©è®°å½•';
                } else {
                    resultText += `å‘ç° ${characterInfo.size} ä¸ªè§’è‰²çš„èŠå¤©è®°å½•:\n\n`;

                    characterInfo.forEach((info, characterId) => {
                        resultText += `è§’è‰²ID: ${characterId}\n`;
                        resultText += `æ¶ˆæ¯æ•°é‡: ${info.messageCount} æ¡\n`;
                        resultText += `æœ€æ—©æ¶ˆæ¯: ${new Date(info.firstMessage.timestamp).toLocaleString()}\n`;
                        resultText += `æœ€æ–°æ¶ˆæ¯: ${new Date(info.lastMessage.timestamp).toLocaleString()}\n`;
                        resultText += `æœ€æ–°å†…å®¹: ${info.lastMessage.content?.substring(0, 50)}...\n\n`;
                    });

                    resultText += '\nğŸ’¡ å»ºè®®: å¦‚æœè¿™äº›IDå¯¹åº”æ‚¨ä¸¢å¤±çš„è§’è‰²ï¼Œå¯ä»¥å°è¯•æ‰‹åŠ¨é‡å»ºè§’è‰²å¡';
                }

                document.getElementById('deep-search-result').style.display = 'block';
                document.getElementById('deep-search-text').textContent = resultText;

                addRecoveryLog('èŠå¤©è®°å½•åˆ†æå®Œæˆ');

            } catch (error) {
                addRecoveryLog('èŠå¤©è®°å½•åˆ†æå¤±è´¥: ' + error.message);
            }
        }

        // ğŸ”§ ä»èŠå¤©è®°å½•é‡å»ºè§’è‰²
        async function rebuildCharactersFromChat() {
            addRecoveryLog('å¼€å§‹ä»èŠå¤©è®°å½•é‡å»ºè§’è‰²...');

            try {
                const chatData = await db.chatMessages.toArray();
                const characterInfo = new Map();

                // åˆ†æèŠå¤©è®°å½•
                chatData.forEach(msg => {
                    if (msg.characterId && msg.characterId !== 'user') {
                        if (!characterInfo.has(msg.characterId)) {
                            characterInfo.set(msg.characterId, {
                                id: msg.characterId,
                                messages: [],
                                firstMessage: null,
                                lastMessage: null
                            });
                        }

                        const info = characterInfo.get(msg.characterId);
                        info.messages.push(msg);

                        if (!info.firstMessage || msg.timestamp < info.firstMessage.timestamp) {
                            info.firstMessage = msg;
                        }

                        if (!info.lastMessage || msg.timestamp > info.lastMessage.timestamp) {
                            info.lastMessage = msg;
                        }
                    }
                });

                addRecoveryLog(`å‘ç° ${characterInfo.size} ä¸ªè§’è‰²çš„èŠå¤©è®°å½•`);

                // é‡å»ºè§’è‰²å¡
                const rebuiltCharacters = [];
                let rebuiltCount = 0;

                for (const [characterId, info] of characterInfo) {
                    // è·³è¿‡å¼ ä¸‰æå››
                    if (characterId === 'å¼ ä¸‰' || characterId === 'æå››') continue;

                    // å°è¯•ä»èŠå¤©å†…å®¹æ¨æ–­è§’è‰²åå­—
                    let characterName = `è§’è‰²_${characterId.slice(-4)}`;

                    // æŸ¥æ‰¾å¯èƒ½çš„è§’è‰²åå­—ï¼ˆä»ç”¨æˆ·æ¶ˆæ¯å’Œè§’è‰²æ¶ˆæ¯ä¸­å¯»æ‰¾ï¼‰
                    const allMessages = info.messages.slice(0, 20); // æ£€æŸ¥å‰20æ¡æ¶ˆæ¯

                    // æ–¹æ³•1: ä»ç”¨æˆ·æ¶ˆæ¯ä¸­å¯»æ‰¾ç§°å‘¼
                    const userMessages = allMessages.filter(msg => msg.sender === 'sent');
                    for (const msg of userMessages) {
                        const content = msg.content || '';
                        // å¯»æ‰¾å¸¸è§çš„ç§°å‘¼æ¨¡å¼
                        const patterns = [
                            /(?:ä½ å¥½|å—¨|hi|hello)[ï¼Œ,\s]*([^\sï¼Œ,ã€‚ï¼ï¼Ÿ]{1,8})/i,
                            /([^\sï¼Œ,ã€‚ï¼ï¼Ÿ]{1,8})[ï¼Œ,\s]*(?:ä½ å¥½|åœ¨å—|åœ¨ä¸åœ¨)/i,
                            /^([^\sï¼Œ,ã€‚ï¼ï¼Ÿ]{1,8})[ï¼Œ,\s]/,
                            /å«ä½ ([^\sï¼Œ,ã€‚ï¼ï¼Ÿ]{1,8})/i
                        ];

                        for (const pattern of patterns) {
                            const nameMatch = content.match(pattern);
                            if (nameMatch && nameMatch[1] && nameMatch[1].length <= 8 && nameMatch[1].length >= 2) {
                                characterName = nameMatch[1];
                                break;
                            }
                        }
                        if (characterName !== `è§’è‰²_${characterId.slice(-4)}`) break;
                    }

                    // æ–¹æ³•2: ä»è§’è‰²çš„è‡ªæˆ‘ä»‹ç»ä¸­å¯»æ‰¾
                    if (characterName === `è§’è‰²_${characterId.slice(-4)}`) {
                        const characterMessages = allMessages.filter(msg => msg.sender === 'character');
                        for (const msg of characterMessages.slice(0, 5)) {
                            const content = msg.content || '';
                            const patterns = [
                                /æˆ‘æ˜¯([^\sï¼Œ,ã€‚ï¼ï¼Ÿ]{1,8})/i,
                                /æˆ‘å«([^\sï¼Œ,ã€‚ï¼ï¼Ÿ]{1,8})/i,
                                /å«æˆ‘([^\sï¼Œ,ã€‚ï¼ï¼Ÿ]{1,8})/i,
                                /^([^\sï¼Œ,ã€‚ï¼ï¼Ÿ]{1,8})(?:åœ¨è¿™é‡Œ|æ¥äº†|å›æ¥äº†)/i
                            ];

                            for (const pattern of patterns) {
                                const nameMatch = content.match(pattern);
                                if (nameMatch && nameMatch[1] && nameMatch[1].length <= 8 && nameMatch[1].length >= 2) {
                                    characterName = nameMatch[1];
                                    break;
                                }
                            }
                            if (characterName !== `è§’è‰²_${characterId.slice(-4)}`) break;
                        }
                    }

                    // åˆ›å»ºåŸºç¡€è§’è‰²å¡
                    const character = {
                        id: characterId,
                        name: characterName,
                        description: `ä»èŠå¤©è®°å½•æ¢å¤çš„è§’è‰²ï¼Œå…±æœ‰ ${info.messages.length} æ¡å¯¹è¯è®°å½•`,
                        personality: 'æ¸©å’Œå‹å–„ï¼Œå–„äºäº¤æµ',
                        scenario: 'æ—¥å¸¸èŠå¤©åœºæ™¯',
                        firstMessage: info.firstMessage?.content || 'ä½ å¥½ï¼',
                        avatar: '',
                        createdAt: info.firstMessage?.timestamp || Date.now(),
                        updatedAt: info.lastMessage?.timestamp || Date.now(),
                        tags: ['æ¢å¤è§’è‰²'],
                        isPublic: false,
                        messageCount: info.messages.length
                    };

                    rebuiltCharacters.push(character);
                    rebuiltCount++;

                    addRecoveryLog(`é‡å»ºè§’è‰²: ${characterName} (ID: ${characterId.slice(-6)}...)`);
                }

                if (rebuiltCharacters.length === 0) {
                    throw new Error('æ²¡æœ‰æ‰¾åˆ°å¯é‡å»ºçš„è§’è‰²');
                }

                // ğŸ”¥ã€å®‰å…¨ä¿®å¤ã€‘æ¸…é™¤ç°æœ‰çš„å¼‚å¸¸è§’è‰²ï¼Œæ·»åŠ é‡å»ºçš„è§’è‰²
                await safeDataSave('characters', rebuiltCharacters);
                characters = rebuiltCharacters;

                // æ›´æ–°è”ç³»äººåˆ—è¡¨
                contacts = rebuiltCharacters.map(char => char.id);
                await saveContacts();

                // å¼ºåˆ¶åˆ·æ–°æ‰€æœ‰ç›¸å…³æ•°æ®
                await loadCharacters();
                await loadContacts();
                await loadChatMessages();

                // åˆ·æ–°ç•Œé¢
                renderCharacterList();
                renderContactList();
                renderMessageList();

                // å¦‚æœå½“å‰åœ¨èŠå¤©ç•Œé¢ï¼Œåˆ·æ–°èŠå¤©ç•Œé¢
                if (currentCharacterId) {
                    const character = characters.find(c => c.id === currentCharacterId);
                    if (character) {
                        renderChatHeader();
                    }
                }

                addRecoveryLog(`âœ… æˆåŠŸé‡å»º ${rebuiltCount} ä¸ªè§’è‰²ï¼`);
                addRecoveryLog(`è§’è‰²åˆ—è¡¨: ${rebuiltCharacters.map(c => c.name).join(', ')}`);
                alert(`è§’è‰²é‡å»ºå®Œæˆï¼æˆåŠŸæ¢å¤ ${rebuiltCount} ä¸ªè§’è‰²ï¼ŒèŠå¤©è®°å½•å·²ä¿ç•™ã€‚\n\næ¢å¤çš„è§’è‰²: ${rebuiltCharacters.map(c => c.name).join(', ')}`);

            } catch (error) {
                addRecoveryLog('âŒ è§’è‰²é‡å»ºå¤±è´¥: ' + error.message);
                alert('è§’è‰²é‡å»ºå¤±è´¥: ' + error.message);
            }
        }

        // âœï¸ æ˜¾ç¤ºæ‰‹åŠ¨é‡å»ºç•Œé¢
        async function showManualRebuild() {
            try {
                const chatData = await db.chatMessages.toArray();
                const characterInfo = new Map();

                // åˆ†æèŠå¤©è®°å½•
                chatData.forEach(msg => {
                    if (msg.characterId && msg.characterId !== 'user' && msg.characterId !== 'å¼ ä¸‰' && msg.characterId !== 'æå››') {
                        if (!characterInfo.has(msg.characterId)) {
                            characterInfo.set(msg.characterId, {
                                id: msg.characterId,
                                messageCount: 0,
                                lastMessage: null
                            });
                        }

                        const info = characterInfo.get(msg.characterId);
                        info.messageCount++;

                        if (!info.lastMessage || msg.timestamp > info.lastMessage.timestamp) {
                            info.lastMessage = msg;
                        }
                    }
                });

                if (characterInfo.size === 0) {
                    alert('æ²¡æœ‰å‘ç°å¯é‡å»ºçš„è§’è‰²');
                    return;
                }

                // åˆ›å»ºæ‰‹åŠ¨é‡å»ºç•Œé¢
                let html = '<div style="max-height: 400px; overflow-y: auto;">';
                html += '<h4>é€‰æ‹©è¦é‡å»ºçš„è§’è‰²ï¼š</h4>';

                characterInfo.forEach((info, characterId) => {
                    const shortId = characterId.slice(-6);
                    const lastContent = info.lastMessage?.content?.substring(0, 30) || '';

                    html += `
                        <div style="border: 1px solid #ddd; border-radius: 8px; padding: 10px; margin-bottom: 10px;">
                            <div style="font-weight: bold;">è§’è‰²ID: ${shortId}...</div>
                            <div style="font-size: 12px; color: #666;">æ¶ˆæ¯æ•°: ${info.messageCount} æ¡</div>
                            <div style="font-size: 12px; color: #666;">æœ€æ–°æ¶ˆæ¯: ${lastContent}...</div>
                            <input type="text" id="name_${characterId}" placeholder="è¾“å…¥è§’è‰²åå­—" style="width: 100%; margin: 5px 0; padding: 5px; border: 1px solid #ccc; border-radius: 4px;">
                            <label><input type="checkbox" id="rebuild_${characterId}" checked> é‡å»ºæ­¤è§’è‰²</label>
                        </div>
                    `;
                });

                html += '</div>';
                html += '<button onclick="executeManualRebuild()" style="background: #32D74B; color: white; border: none; padding: 10px 20px; border-radius: 8px; width: 100%; margin-top: 10px;">ç¡®è®¤é‡å»ºé€‰ä¸­çš„è§’è‰²</button>';

                document.getElementById('deep-search-result').style.display = 'block';
                document.getElementById('deep-search-text').innerHTML = html;

                // å­˜å‚¨è§’è‰²ä¿¡æ¯ä¾›åç»­ä½¿ç”¨
                window.manualRebuildInfo = characterInfo;

            } catch (error) {
                alert('è·å–è§’è‰²ä¿¡æ¯å¤±è´¥: ' + error.message);
            }
        }

        // ğŸ” è°ƒè¯•å½“å‰çŠ¶æ€
        async function debugCurrentState() {
            addRecoveryLog('å¼€å§‹æ£€æŸ¥å½“å‰æ•°æ®çŠ¶æ€...');

            try {
                // æ£€æŸ¥å†…å­˜ä¸­çš„æ•°æ®
                addRecoveryLog(`å†…å­˜ä¸­è§’è‰²æ•°é‡: ${characters.length}`);
                addRecoveryLog(`å†…å­˜ä¸­è”ç³»äººæ•°é‡: ${contacts.length}`);

                if (characters.length > 0) {
                    addRecoveryLog('å†…å­˜ä¸­çš„è§’è‰²:');
                    characters.forEach(char => {
                        addRecoveryLog(`  - ${char.name} (ID: ${char.id.slice(-6)}...)`);
                    });
                }

                // æ£€æŸ¥æ•°æ®åº“ä¸­çš„æ•°æ®
                const dbCharacters = await db.characters.toArray();
                const dbContacts = await db.contacts.toArray();
                const dbMessages = await db.chatMessages.toArray();

                addRecoveryLog(`æ•°æ®åº“ä¸­è§’è‰²æ•°é‡: ${dbCharacters.length}`);
                addRecoveryLog(`æ•°æ®åº“ä¸­è”ç³»äººæ•°é‡: ${dbContacts.length}`);
                addRecoveryLog(`æ•°æ®åº“ä¸­æ¶ˆæ¯æ•°é‡: ${dbMessages.length}`);

                if (dbCharacters.length > 0) {
                    addRecoveryLog('æ•°æ®åº“ä¸­çš„è§’è‰²:');
                    dbCharacters.forEach(char => {
                        addRecoveryLog(`  - ${char.name} (ID: ${char.id.slice(-6)}...)`);
                    });
                }

                // æ£€æŸ¥ç•Œé¢å…ƒç´ 
                const characterListElement = document.getElementById('character-list');
                const contactListElement = document.getElementById('contact-list');

                addRecoveryLog(`è§’è‰²åˆ—è¡¨å…ƒç´ å­˜åœ¨: ${!!characterListElement}`);
                addRecoveryLog(`è”ç³»äººåˆ—è¡¨å…ƒç´ å­˜åœ¨: ${!!contactListElement}`);

                if (characterListElement) {
                    addRecoveryLog(`è§’è‰²åˆ—è¡¨å­å…ƒç´ æ•°é‡: ${characterListElement.children.length}`);
                }

                if (contactListElement) {
                    addRecoveryLog(`è”ç³»äººåˆ—è¡¨å­å…ƒç´ æ•°é‡: ${contactListElement.children.length}`);
                }

                // æ£€æŸ¥å½“å‰é¡µé¢çŠ¶æ€
                addRecoveryLog(`å½“å‰é¡µé¢: ${currentPage}`);
                addRecoveryLog(`å½“å‰è§’è‰²ID: ${currentCharacterId || 'æ— '}`);

                addRecoveryLog('çŠ¶æ€æ£€æŸ¥å®Œæˆ');

            } catch (error) {
                addRecoveryLog('çŠ¶æ€æ£€æŸ¥å¤±è´¥: ' + error.message);
            }
        }

        // ğŸ”„ å¼ºåˆ¶åˆ·æ–°æ‰€æœ‰ç•Œé¢
        async function forceRefreshAll() {
            addRecoveryLog('å¼€å§‹å¼ºåˆ¶åˆ·æ–°æ‰€æœ‰ç•Œé¢...');

            try {
                // é‡æ–°åŠ è½½æ‰€æœ‰æ•°æ®
                await loadCharacters();
                await loadContacts();
                await loadChatMessages();

                addRecoveryLog(`é‡æ–°åŠ è½½åè§’è‰²æ•°é‡: ${characters.length}`);
                addRecoveryLog(`é‡æ–°åŠ è½½åè”ç³»äººæ•°é‡: ${contacts.length}`);

                // å¼ºåˆ¶åˆ·æ–°æ‰€æœ‰ç•Œé¢
                renderCharacterList();
                renderContactList();
                renderMessageList();

                // å¦‚æœåœ¨èŠå¤©é¡µé¢ï¼Œåˆ·æ–°èŠå¤©ç•Œé¢
                if (currentPage === 'chat' && currentCharacterId) {
                    const character = characters.find(c => c.id === currentCharacterId);
                    if (character) {
                        renderChatHeader();
                        renderChatMessages();
                    } else {
                        // å¦‚æœå½“å‰è§’è‰²ä¸å­˜åœ¨ï¼Œè¿”å›ä¸»é¡µ
                        hideApp('api-chat-screen');
                    }
                }

                // å¦‚æœåœ¨è§’è‰²ç®¡ç†é¡µé¢ï¼Œåˆ·æ–°è§’è‰²ç®¡ç†ç•Œé¢
                if (currentPage === 'characters') {
                    renderCharacterList();
                }

                addRecoveryLog('âœ… ç•Œé¢åˆ·æ–°å®Œæˆ');
                alert('ç•Œé¢åˆ·æ–°å®Œæˆï¼è¯·æ£€æŸ¥è§’è‰²åˆ—è¡¨æ˜¯å¦æ­£å¸¸æ˜¾ç¤ºã€‚');

            } catch (error) {
                addRecoveryLog('ç•Œé¢åˆ·æ–°å¤±è´¥: ' + error.message);
                alert('ç•Œé¢åˆ·æ–°å¤±è´¥: ' + error.message);
            }
        }

        // æ‰§è¡Œæ‰‹åŠ¨é‡å»º
        async function executeManualRebuild() {
            try {
                const rebuiltCharacters = [];

                for (const [characterId, info] of window.manualRebuildInfo) {
                    const checkbox = document.getElementById(`rebuild_${characterId}`);
                    const nameInput = document.getElementById(`name_${characterId}`);

                    if (checkbox && checkbox.checked) {
                        const characterName = nameInput.value.trim() || `è§’è‰²_${characterId.slice(-4)}`;

                        const character = {
                            id: characterId,
                            name: characterName,
                            description: `æ‰‹åŠ¨é‡å»ºçš„è§’è‰²ï¼Œå…±æœ‰ ${info.messageCount} æ¡å¯¹è¯è®°å½•`,
                            personality: 'è¯·æ ¹æ®èŠå¤©è®°å½•è°ƒæ•´æ€§æ ¼è®¾å®š',
                            scenario: 'æ—¥å¸¸èŠå¤©åœºæ™¯',
                            firstMessage: info.lastMessage?.content || 'ä½ å¥½ï¼',
                            avatar: '',
                            createdAt: Date.now() - 86400000, // 1å¤©å‰
                            updatedAt: Date.now(),
                            tags: ['æ‰‹åŠ¨æ¢å¤'],
                            isPublic: false,
                            messageCount: info.messageCount
                        };

                        rebuiltCharacters.push(character);
                    }
                }

                if (rebuiltCharacters.length === 0) {
                    alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªè§’è‰²è¿›è¡Œé‡å»º');
                    return;
                }

                // ğŸ”¥ã€å®‰å…¨ä¿®å¤ã€‘æ¸…é™¤ç°æœ‰è§’è‰²ï¼Œæ·»åŠ é‡å»ºçš„è§’è‰²
                await safeDataSave('characters', rebuiltCharacters);
                characters = rebuiltCharacters;

                // æ›´æ–°è”ç³»äººåˆ—è¡¨
                contacts = rebuiltCharacters.map(char => char.id);
                await saveContacts();

                // åˆ·æ–°ç•Œé¢
                renderCharacterList();
                renderContactList();

                addRecoveryLog(`âœ… æ‰‹åŠ¨é‡å»ºå®Œæˆï¼æ¢å¤äº† ${rebuiltCharacters.length} ä¸ªè§’è‰²`);
                alert(`æ‰‹åŠ¨é‡å»ºå®Œæˆï¼æˆåŠŸæ¢å¤ ${rebuiltCharacters.length} ä¸ªè§’è‰²ã€‚`);

                // éšè—é‡å»ºç•Œé¢
                document.getElementById('deep-search-result').style.display = 'none';

            } catch (error) {
                alert('æ‰‹åŠ¨é‡å»ºå¤±è´¥: ' + error.message);
            }
        }

        // ğŸ“ ä»æ–‡ä»¶æ¢å¤
        async function recoverFromFile() {
            const fileInput = document.getElementById('recovery-file-input');
            const file = fileInput.files[0];

            if (!file) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå¤‡ä»½æ–‡ä»¶');
                return;
            }

            try {
                addRecoveryLog(`å¼€å§‹è¯»å–æ–‡ä»¶: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`);

                const text = await file.text();
                const exportData = JSON.parse(text);

                if (!exportData.characters || !Array.isArray(exportData.characters)) {
                    throw new Error('æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼Œç¼ºå°‘è§’è‰²ä¿¡æ¯');
                }

                addRecoveryLog(`æ–‡ä»¶ä¸­å‘ç° ${exportData.characters.length} ä¸ªè§’è‰²`);

                // è¿‡æ»¤æ‰å¼ ä¸‰æå››
                const validCharacters = exportData.characters.filter(char =>
                    char.name !== 'å¼ ä¸‰' && char.name !== 'æå››'
                );

                addRecoveryLog(`è¿‡æ»¤åæœ‰æ•ˆè§’è‰²: ${validCharacters.length} ä¸ª`);

                if (validCharacters.length === 0) {
                    throw new Error('æ–‡ä»¶ä¸­æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„è§’è‰²æ•°æ®');
                }

                // ğŸ”¥ã€å®‰å…¨ä¿®å¤ã€‘æ¢å¤è§’è‰²æ•°æ®
                await safeDataSave('characters', validCharacters);
                characters = validCharacters;

                // æ¢å¤è”ç³»äººåˆ—è¡¨
                const validContactIds = validCharacters.map(char => char.id);
                contacts = validContactIds;
                await saveContacts();

                addRecoveryLog('è§’è‰²æ•°æ®æ¢å¤å®Œæˆ');

                // æ¢å¤èŠå¤©è®°å½•
                if (exportData.chatMessages) {
                    await db.chatMessages.clear();
                    let messageCount = 0;

                    for (const [characterId, messages] of Object.entries(exportData.chatMessages)) {
                        if (messages && messages.length > 0) {
                            for (const message of messages) {
                                await db.chatMessages.add({
                                    characterId: characterId,
                                    ...message
                                });
                                messageCount++;
                            }
                        }
                    }
                    chatMessages = exportData.chatMessages;
                    addRecoveryLog(`èŠå¤©è®°å½•æ¢å¤å®Œæˆ: ${messageCount} æ¡æ¶ˆæ¯`);
                }

                // åˆ·æ–°ç•Œé¢
                renderCharacterList();
                renderContactList();
                renderMessageList();

                addRecoveryLog('âœ… æ–‡ä»¶æ¢å¤æˆåŠŸï¼');
                alert('æ•°æ®æ¢å¤æˆåŠŸï¼æ‚¨çš„è§’è‰²å’ŒèŠå¤©è®°å½•å·²æ¢å¤ã€‚');

            } catch (error) {
                addRecoveryLog('âŒ æ–‡ä»¶æ¢å¤å¤±è´¥: ' + error.message);
                alert('æ–‡ä»¶æ¢å¤å¤±è´¥: ' + error.message);
            }
        }

        async function cleanupBadData() {
            try {
                addRecoveryLog('å¼€å§‹æ¸…ç†å¼‚å¸¸æ•°æ®...');

                // æ¸…é™¤å¼ ä¸‰æå››
                const deletedCount = await db.characters.where('name').anyOf(['å¼ ä¸‰', 'æå››']).delete();
                addRecoveryLog(`åˆ é™¤äº† ${deletedCount} ä¸ªå¼‚å¸¸è§’è‰²`);

                // æ›´æ–°å†…å­˜æ•°æ®
                characters = characters.filter(char => char.name !== 'å¼ ä¸‰' && char.name !== 'æå››');
                contacts = contacts.filter(id => {
                    const char = characters.find(c => c.id === id);
                    return char && char.name !== 'å¼ ä¸‰' && char.name !== 'æå››';
                });

                await saveContacts();

                // åˆ·æ–°ç•Œé¢
                renderCharacterList();
                renderContactList();
                renderMessageList();

                addRecoveryLog('âœ… å¼‚å¸¸æ•°æ®æ¸…ç†å®Œæˆ');
                alert('å¼‚å¸¸æ•°æ®æ¸…ç†å®Œæˆ');

            } catch (error) {
                addRecoveryLog('âŒ æ¸…ç†å¤±è´¥: ' + error.message);
                alert('æ¸…ç†å¤±è´¥: ' + error.message);
            }
        }

        async function forceReload() {
            try {
                addRecoveryLog('å¼€å§‹å¼ºåˆ¶é‡æ–°åŠ è½½æ•°æ®...');

                // é‡æ–°åŠ è½½æ‰€æœ‰æ•°æ®
                await loadCharacterGroups();
                await loadCharacters();
                await loadContacts();
                await loadChatMessages();
                await loadChatSettings();
                await loadPersonas();
                await loadGroupChats();

                // åˆ·æ–°ç•Œé¢
                renderCharacterList();
                renderContactList();
                renderMessageList();

                addRecoveryLog('âœ… æ•°æ®é‡æ–°åŠ è½½å®Œæˆ');
                alert('æ•°æ®é‡æ–°åŠ è½½å®Œæˆ');

            } catch (error) {
                addRecoveryLog('âŒ é‡æ–°åŠ è½½å¤±è´¥: ' + error.message);
                alert('é‡æ–°åŠ è½½å¤±è´¥: ' + error.message);
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘çº¿ä¸‹å‰§æƒ…æ¨¡å¼åŠŸèƒ½
        let isOfflineMode = false;
        let offlinePresets = [];
        let currentOfflinePreset = null;
        let offlineMessages = [];

        // ğŸ”¥ã€æ–°å¢ã€‘çª—å£å”¯ä¸€æ ‡è¯†ç¬¦ï¼Œç¡®ä¿ä¸åŒçª—å£çš„çº¿ä¸‹æ¨¡å¼æ•°æ®å®Œå…¨éš”ç¦»
        let windowId = null;

        // åˆå§‹åŒ–çª—å£ID
        function initializeWindowId() {
            // å°è¯•ä»sessionStorageè·å–ç°æœ‰çš„çª—å£ID
            windowId = sessionStorage.getItem('windowId');

            if (!windowId) {
                // ç”Ÿæˆæ–°çš„çª—å£ID
                windowId = `window_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                sessionStorage.setItem('windowId', windowId);
            }

            console.log('ğŸªŸ çª—å£IDå·²åˆå§‹åŒ–:', windowId);

            // ğŸ”¥ã€ä¿®å¤ã€‘ç§»é™¤beforeunloadç›‘å¬å™¨ï¼Œä»¥é˜²æ­¢åˆ·æ–°æ—¶æ¸…é™¤æ•°æ®
            // window.addEventListener('beforeunload', cleanupWindowOfflineData);
        }

        // ğŸ”¥ã€ä¿®å¤ã€‘åˆ é™¤cleanupWindowOfflineDataå‡½æ•°ï¼Œä»¥é˜²æ­¢åˆ·æ–°æ—¶æ¸…é™¤æ•°æ®
        /*
        function cleanupWindowOfflineData() {
            if (!windowId) return;

            try {
                // æ¸…ç†localStorageä¸­çš„çº¿ä¸‹æ¶ˆæ¯æ•°æ®
                const keys = Object.keys(localStorage);
                keys.forEach(key => {
                    if (key.includes(`_${windowId}`)) {
                        localStorage.removeItem(key);
                        console.log(`ğŸ§¹ æ¸…ç†çª—å£æ•°æ®: ${key}`);
                    }
                });

                console.log(`ğŸªŸ çª—å£${windowId}çš„çº¿ä¸‹æ¨¡å¼æ•°æ®å·²æ¸…ç†`);
            } catch (error) {
                console.error('æ¸…ç†çª—å£çº¿ä¸‹æ¨¡å¼æ•°æ®å¤±è´¥:', error);
            }
        }
        */

        // ğŸ”¥ã€å·²åºŸå¼ƒã€‘è¿ç§»åŠŸèƒ½å·²ç§»è‡³æ•°æ®åº“ç‰ˆæœ¬13ä¸­è‡ªåŠ¨å¤„ç†

        // åˆ‡æ¢çº¿ä¸‹æ¨¡å¼
        function toggleOfflineMode() {
            if (!currentChatCharacter) {
                showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè§’è‰²', 'warning');
                return;
            }

            // ğŸ”¥ã€ä¿®å¤ã€‘åœ¨åˆ‡æ¢æ¨¡å¼å‰ï¼Œå¼ºåˆ¶æ¸…ç©ºæ—§çš„èŠå¤©è®°å½•æ•°ç»„
            // è¿™å°†ç¡®ä¿æ¯æ¬¡éƒ½ä¸ºå½“å‰è§’è‰²åŠ è½½æ­£ç¡®çš„èŠå¤©è®°å½•
            offlineMessages = [];

            isOfflineMode = !isOfflineMode;
            const overlay = document.getElementById('offline-mode-overlay');
            const icon = document.getElementById('offline-mode-icon');
            const chatScreen = document.getElementById('api-chat-screen');
            const offlineTitle = document.getElementById('offline-mode-title');

            if (isOfflineMode) {
                // è¿›å…¥çº¿ä¸‹æ¨¡å¼
                overlay.style.display = 'flex';
                icon.className = 'fas fa-door-closed';
                chatScreen.classList.add('offline-mode-active');

                // æ›´æ–°æ ‡é¢˜ä¸ºå½“å‰è§’è‰²åå­—
                if (offlineTitle && currentChatCharacter) {
                    offlineTitle.textContent = currentChatCharacter.name;
                }

                // ğŸ”¥ã€æ–°å¢ã€‘æš‚åœå½“å‰è§’è‰²çš„ä¸»åŠ¨å‘æ¶ˆæ¯è®¡æ—¶å™¨
                pauseProactiveChatTimer(currentChatCharacter.id);

                // åŠ è½½çº¿ä¸‹æ¨¡å¼çš„æ¶ˆæ¯
                loadOfflineMessages();

                // ğŸ”¥ã€æ–°å¢ã€‘åŠ è½½å¹¶åº”ç”¨ç•Œé¢è®¾ç½®
                loadAndApplyOfflineUISettings();

                showToast('å·²è¿›å…¥çº¿ä¸‹å‰§æƒ…æ¨¡å¼', 'success');
            } else {
                // é€€å‡ºçº¿ä¸‹æ¨¡å¼
                exitOfflineMode();
            }
        }

        // é€€å‡ºçº¿ä¸‹æ¨¡å¼
        function exitOfflineMode() {
            // æ£€æŸ¥æ˜¯å¦æœ‰çº¿ä¸‹æ¨¡å¼çš„èŠå¤©è®°å½•
            if (offlineMessages.length > 0) {
                showOfflineExitModal();
            } else {
                // æ²¡æœ‰èŠå¤©è®°å½•ï¼Œç›´æ¥é€€å‡º
                doExitOfflineMode();
            }
        }

        // æ˜¾ç¤ºçº¿ä¸‹æ¨¡å¼é€€å‡ºé€‰é¡¹æ¨¡æ€æ¡†
        function showOfflineExitModal() {
            const modal = document.createElement('div');
            modal.className = 'modal offline-exit-modal'; // æ·»åŠ ç‰¹å®šç±»å
            modal.style.display = 'flex';
            modal.style.zIndex = '10001';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 400px;">
                    <div class="modal-header">
                        <h3>é€€å‡ºçº¿ä¸‹æ¨¡å¼</h3>
                        <button class="modal-close" onclick="this.closest('.modal').remove()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="modal-body">
                        <p>è¯·é€‰æ‹©é€€å‡ºæ–¹å¼ï¼š</p>
                        <div style="margin-top: 15px;">
                            <button class="btn btn-primary" onclick="exitWithoutSummary()">
                                <i class="fas fa-check"></i> ç»“æŸä¸”ä¸æ€»ç»“ï¼ˆæ¨èï¼‰
                            </button>
                            <button class="btn btn-secondary" onclick="exitTemporarily()">
                                <i class="fas fa-pause"></i> æš‚æ—¶ç¦»å¼€
                            </button>
                            <button class="btn" onclick="exitWithSummary()" id="summary-btn" style="background: #f8f9fa !important; color: #000000 !important; border: 1px solid #000000 !important; font-weight: bold !important;">
                                <i class="fas fa-book"></i> ç»“æŸå¹¶æ€»ç»“
                            </button>
                        </div>
                        <p style="font-size: 12px; color: #666; margin-top: 10px;">
                            â€¢ <strong>ç»“æŸä¸”ä¸æ€»ç»“</strong>ï¼šç»“æŸå‰§æƒ…ï¼Œå¯¹è¯è®°å½•ä¿å­˜åˆ°çº¿ä¸‹æ¨¡å¼èŠå¤©è®°å½•ä¸­<br>
                            â€¢ <strong>æš‚æ—¶ç¦»å¼€</strong>ï¼šä¿ç•™å½“å‰å¯¹è¯çŠ¶æ€ï¼Œå¯ä»¥ç¨åç»§ç»­å‰§æƒ…<br>
                            â€¢ <strong>ç»“æŸå¹¶æ€»ç»“</strong>ï¼šç”ŸæˆAIå‰§æƒ…æ‘˜è¦å¹¶ä¿å­˜åˆ°è®°å¿†ç³»ç»Ÿå’ŒèŠå¤©è®°å½•ä¸­
                        </p>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        // ğŸ”¥ã€ä¿®æ”¹ã€‘ç”Ÿæˆå‰§æƒ…æ€»ç»“å¹¶é€€å‡º
        async function exitWithSummary() {
            try {
                // ğŸ”¥ã€æ–°å¢ã€‘æ˜¾ç¤ºåŠ è½½çŠ¶æ€
                const summaryButton = document.querySelector('#summary-btn');
                const originalHTML = summaryButton.innerHTML;
                summaryButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> AIæ­£åœ¨æ€»ç»“ä¸­...';
                summaryButton.disabled = true;

                // ç¦ç”¨å…¶ä»–æŒ‰é’®é˜²æ­¢é‡å¤ç‚¹å‡»
                const otherButtons = document.querySelectorAll('.offline-exit-modal .btn:not(#summary-btn)');
                otherButtons.forEach(btn => btn.disabled = true);

                showToast('æ­£åœ¨ç”Ÿæˆå‰§æƒ…æ€»ç»“...', 'info');
                await generateOfflineStorylineSummary();

                // ğŸ”¥ã€ä¿®å¤ã€‘ç¡®ä¿æ¨¡æ€æ¡†å…³é—­
                const modal = document.querySelector('.offline-exit-modal');
                if (modal) modal.remove();

                doExitOfflineMode();
                showToast('å·²ç”Ÿæˆå‰§æƒ…æ€»ç»“å¹¶é€€å‡ºçº¿ä¸‹æ¨¡å¼', 'success');
            } catch (error) {
                console.error('ç”Ÿæˆå‰§æƒ…æ€»ç»“å¤±è´¥:', error);

                // ğŸ”¥ã€ä¿®å¤ã€‘æ¢å¤æŒ‰é’®çŠ¶æ€
                const summaryButton = document.querySelector('#summary-btn');
                if (summaryButton) {
                    summaryButton.innerHTML = '<i class="fas fa-book"></i> ç»“æŸå¹¶ç”Ÿæˆå‰§æƒ…æ€»ç»“';
                    summaryButton.disabled = false;
                }

                // æ¢å¤å…¶ä»–æŒ‰é’®çŠ¶æ€
                const otherButtons = document.querySelectorAll('.offline-exit-modal .btn:not(#summary-btn)');
                otherButtons.forEach(btn => btn.disabled = false);

                // ğŸ”¥ã€ä¿®å¤ã€‘ç¡®ä¿æ¨¡æ€æ¡†å…³é—­
                const modal = document.querySelector('.offline-exit-modal');
                if (modal) modal.remove();

                doExitOfflineMode();
                showToast('ç”Ÿæˆå‰§æƒ…æ€»ç»“å¤±è´¥ï¼Œä½†å·²é€€å‡ºçº¿ä¸‹æ¨¡å¼', 'warning');
            }
        }

        // æš‚æ—¶ç¦»å¼€ï¼ˆä¸ç”Ÿæˆæ‘˜è¦ï¼‰
        function exitTemporarily() {
            // ğŸ”¥ã€ä¿®å¤ã€‘ä½¿ç”¨ç²¾ç¡®çš„é€‰æ‹©å™¨æ‰¾åˆ°é€€å‡ºæ¨¡æ€æ¡†
            const modal = document.querySelector('.offline-exit-modal');
            if (modal) {
                modal.remove();
                console.log('âœ… æš‚æ—¶ç¦»å¼€ï¼šæ¨¡æ€æ¡†å·²å…³é—­');
            } else {
                console.log('âŒ æš‚æ—¶ç¦»å¼€ï¼šæ‰¾ä¸åˆ°æ¨¡æ€æ¡†');
            }

            // ğŸ”¥ã€ä¿®å¤ã€‘æš‚æ—¶ç¦»å¼€æ—¶ä¸æ¸…ç©ºæ¶ˆæ¯ï¼Œä¿æŒçº¿ä¸‹æ¨¡å¼çŠ¶æ€
            console.log(`ğŸ“ æš‚æ—¶ç¦»å¼€çº¿ä¸‹æ¨¡å¼ï¼Œä¿ç•™${offlineMessages.length}æ¡æ¶ˆæ¯`);

            doExitOfflineMode();
            showToast('å·²æš‚æ—¶ç¦»å¼€çº¿ä¸‹æ¨¡å¼', 'info');
        }

        // ç»“æŸä¸”ä¸æ€»ç»“ï¼ˆæ¨èé€‰é¡¹ï¼‰
        async function exitWithoutSummary() {
            const modal = document.querySelector('.offline-exit-modal');
            if (modal) {
                modal.remove();
                console.log('âœ… ç»“æŸä¸”ä¸æ€»ç»“ï¼šæ¨¡æ€æ¡†å·²å…³é—­');
            } else {
                console.log('âŒ ç»“æŸä¸”ä¸æ€»ç»“ï¼šæ‰¾ä¸åˆ°æ¨¡æ€æ¡†');
            }

            // ğŸ”¥ã€ä¿®å¤ã€‘å¦‚æœæœ‰èŠå¤©è®°å½•ï¼Œä¿å­˜åˆ°çº¿ä¸‹æ¨¡å¼èŠå¤©è®°å½•ä¸­
            if (offlineMessages.length > 0) {
                console.log(`ğŸ“ ä¿å­˜çº¿ä¸‹æ¨¡å¼å¯¹è¯åˆ°èŠå¤©è®°å½•ä¸­ï¼Œå…±${offlineMessages.length}æ¡æ¶ˆæ¯`);

                // ç”Ÿæˆç®€å•çš„å¯¹è¯æ‘˜è¦
                const summary = `çº¿ä¸‹æ¨¡å¼å¯¹è¯è®°å½• - ${new Date().toLocaleString()} (${offlineMessages.length}æ¡æ¶ˆæ¯)`;

                // ä¿å­˜åˆ°çº¿ä¸‹æ¨¡å¼èŠå¤©è®°å½•
                await saveOfflineHistoryRecord(summary, offlineMessages.slice());

                // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘ç¡®ä¿çº¿ä¸‹æ¨¡å¼æ¶ˆæ¯å·²ç»ä¿å­˜åˆ°ä¸»èŠå¤©è®°å½•ä¸­
                // æ£€æŸ¥ä¸»èŠå¤©è®°å½•ä¸­æ˜¯å¦åŒ…å«æ‰€æœ‰çº¿ä¸‹æ¶ˆæ¯
                const characterId = currentChatCharacter.id;
                if (chatMessages[characterId]) {
                    const offlineMessagesInMain = chatMessages[characterId].filter(msg => msg.isOfflineMode);
                    console.log(`ğŸ“Š ä¸»èŠå¤©è®°å½•ä¸­çš„çº¿ä¸‹æ¶ˆæ¯: ${offlineMessagesInMain.length}æ¡`);
                    console.log(`ğŸ“Š å½“å‰çº¿ä¸‹æ¶ˆæ¯æ•°ç»„: ${offlineMessages.length}æ¡`);

                    // ç¡®ä¿ä¸»èŠå¤©è®°å½•å·²ä¿å­˜
                    await saveChatMessages(characterId);
                    console.log('âœ… å·²ç¡®ä¿çº¿ä¸‹æ¨¡å¼æ¶ˆæ¯ä¿å­˜åˆ°ä¸»èŠå¤©è®°å½•ä¸­');
                } else {
                    console.warn('âš ï¸ ä¸»èŠå¤©è®°å½•ä¸ºç©ºï¼Œè¿™å¯èƒ½å¯¼è‡´è®°å¿†è¿æ¥é—®é¢˜');
                }

                // æ¸…ç©ºçº¿ä¸‹æ¶ˆæ¯è®°å½•
                offlineMessages = [];
                saveOfflineMessages(); // ä¿å­˜æ¸…ç©ºçŠ¶æ€åˆ°localStorage

                showToast('å·²ç»“æŸçº¿ä¸‹æ¨¡å¼ï¼Œå¯¹è¯å·²ä¿å­˜åˆ°èŠå¤©è®°å½•', 'success');
            } else {
                console.log('ğŸ“ æ²¡æœ‰çº¿ä¸‹æ¨¡å¼å¯¹è¯éœ€è¦ä¿å­˜');
                showToast('å·²ç»“æŸçº¿ä¸‹æ¨¡å¼', 'success');
            }

            doExitOfflineMode();
        }

        // å®é™…æ‰§è¡Œé€€å‡ºçº¿ä¸‹æ¨¡å¼
        function doExitOfflineMode() {
            isOfflineMode = false;
            const overlay = document.getElementById('offline-mode-overlay');
            const icon = document.getElementById('offline-mode-icon');
            const chatScreen = document.getElementById('api-chat-screen');

            overlay.style.display = 'none';
            icon.className = 'fas fa-door-open';
            chatScreen.classList.remove('offline-mode-active');

            // ğŸ”¥ã€æ–°å¢ã€‘æ¢å¤å½“å‰è§’è‰²çš„ä¸»åŠ¨å‘æ¶ˆæ¯è®¡æ—¶å™¨
            if (currentChatCharacter) {
                resumeProactiveChatTimer(currentChatCharacter.id);
            }

            // ğŸ”¥ã€ä¿®å¤ã€‘æ¸…ç©ºçº¿ä¸‹æ¨¡å¼ç•Œé¢å†…å®¹
            const offlineMessagesContainer = document.getElementById('offline-chat-messages');
            if (offlineMessagesContainer) {
                offlineMessagesContainer.innerHTML = '';
                console.log('âœ… å·²æ¸…ç©ºçº¿ä¸‹æ¨¡å¼ç•Œé¢å†…å®¹');
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘ç”Ÿæˆçº¿ä¸‹æ¨¡å¼å‰§æƒ…æ€»ç»“
        async function generateOfflineStorylineSummary() {
            if (!currentChatCharacter || offlineMessages.length === 0) {
                return;
            }

            console.log('ğŸ“– å¼€å§‹ç”Ÿæˆçº¿ä¸‹æ¨¡å¼å‰§æƒ…æ€»ç»“...');

            try {
                // æ„å»ºå¯¹è¯å†å²
                let conversationHistory = '';
                offlineMessages.forEach((msg, index) => {
                    const role = msg.sender === 'user' ? 'ç”¨æˆ·' : currentChatCharacter.name;
                    conversationHistory += `${role}ï¼š${msg.content}\n`;
                });

                // ğŸ”¥ã€ä¿®æ”¹ã€‘æ„å»ºå‰§æƒ…æ€»ç»“ç”Ÿæˆpromptï¼Œç»Ÿä¸€ä½¿ç”¨ç¬¬ä¸‰äººç§°
                const summaryPrompt = `è¯·ä¸ºä»¥ä¸‹çº¿ä¸‹å‰§æƒ…æ¨¡å¼çš„å¯¹è¯ç”Ÿæˆä¸€ä¸ªç®€æ´å®¢è§‚çš„å‰§æƒ…æ€»ç»“ï¼Œè¦æ±‚ï¼š
1. ä½¿ç”¨å®¢è§‚çš„ä¸Šå¸è§†è§’ï¼ŒåŠ å…¥åˆç†çš„æ–‡å­¦æ€§æå†™
2. é¿å…è¿‡å¤šçš„ä¿®è¾å’Œå½¢å®¹è¯
3. ç®€æ˜æ‰¼è¦åœ°æè¿°äº‹ä»¶å‘ç”Ÿçš„é¡ºåºå’Œå…³é”®æƒ…èŠ‚ä¸ç»†èŠ‚
4. ä¸è¦æ·»åŠ ä»»ä½•ä¸åœ¨åŸæ–‡ä¸­çš„æƒ…æ„Ÿæå†™
5. ä½¿ç”¨æ¸…æ™°çš„æ—¶é—´å’Œå› æœå…³ç³»
6. ç»Ÿä¸€ä½¿ç”¨ç¬¬ä¸‰äººç§°å™è¿°ï¼šç”¨"ç”¨æˆ·"æŒ‡ä»£ç”¨æˆ·ï¼Œç”¨"${currentChatCharacter.name}"æŒ‡ä»£è§’è‰²
7. ä¸è¦ä½¿ç”¨"æˆ‘"ã€"ä½ "ç­‰ç¬¬ä¸€ã€ç¬¬äºŒäººç§°

è§’è‰²ä¿¡æ¯ï¼š
${currentChatCharacter.name}

å¯¹è¯å†å²ï¼š
${conversationHistory}

è¯·ç”Ÿæˆä¸€ä¸ª200-800å­—çš„å®¢è§‚å‰§æƒ…æ€»ç»“ï¼Œè¦æ±‚ï¼š
1. æŒ‰æ—¶é—´é¡ºåºè®°å½•å‘ç”Ÿçš„ä¸»è¦äº‹ä»¶
2. å®¢è§‚æè¿°è§’è‰²çš„è¡Œä¸ºå’Œå¯¹è¯è¦ç‚¹ï¼Œä½¿ç”¨"ç”¨æˆ·"å’Œ"${currentChatCharacter.name}"æ¥æŒ‡ä»£åŒæ–¹
3. è®°å½•é‡è¦çš„æƒ…èŠ‚è½¬æŠ˜å’Œç»“æœ
4. é¿å…è¿‡åº¦çš„ä¸»è§‚æƒ…æ„Ÿæè¿°å’Œè¿‡åº¦ä¿®é¥°
5. ä½¿ç”¨ç®€æ´æ˜äº†çš„è¯­è¨€
6. é‡ç‚¹è®°å½•å…³é”®ç»†èŠ‚å’Œå¯¹åç»­å‰§æƒ…æœ‰å½±å“çš„å…³é”®ä¿¡æ¯
7. ä¸¥æ ¼ä½¿ç”¨ç¬¬ä¸‰äººç§°ï¼šç”¨æˆ·åšäº†ä»€ä¹ˆï¼Œ${currentChatCharacter.name}å¦‚ä½•å›åº”

è¯·ä»¥å®¢è§‚è®°å½•çš„æ–¹å¼æ€»ç»“è¿™æ®µå‰§æƒ…ï¼š`;

                console.log('ğŸ“– å‰§æƒ…æ€»ç»“ç”Ÿæˆprompt:', summaryPrompt);

                // è°ƒç”¨APIç”Ÿæˆæ‘˜è¦
                const summary = await callOfflineChatAPI(summaryPrompt, currentChatCharacter);

                // ğŸ”¥ã€æ–°å¢ã€‘æ˜¾ç¤ºå®Œæ•´çš„æ€»ç»“å†…å®¹
                console.log('ğŸ“– ç”Ÿæˆçš„å®Œæ•´å‰§æƒ…æ€»ç»“:', summary);

                if (summary && summary.trim()) {
                    // ğŸ”¥ã€ä¿®å¤ã€‘ä¿å­˜åˆ°è·¨åº”ç”¨æ—¶é—´çº¿æ•°æ®åº“ï¼Œä½¿ç”¨æ­£ç¡®çš„è¡¨åå’Œå­—æ®µç»“æ„
                    const timelineMemory = {
                        id: `offline_summary_${currentChatCharacter.id}_${Date.now()}`, // ğŸ”¥ã€ä¿®å¤ã€‘æ·»åŠ å¿…éœ€çš„ä¸»é”®
                        characterId: currentChatCharacter.id,
                        appType: 'offline_mode',
                        action: 'storyline_summary',
                        timestamp: Date.now(),
                        context: {
                            type: 'offline_storyline',
                            content: `[å‰§æƒ…æ¨¡å¼] ${summary.trim()}`,
                            date: new Date().toISOString().split('T')[0],
                            messageCount: offlineMessages.length,
                            importance: 0.9 // å‰§æƒ…æ€»ç»“é‡è¦æ€§å¾ˆé«˜
                        },
                        messageId: `offline_summary_${Date.now()}`
                    };

                    await db.crossAppTimeline.add(timelineMemory);
                    console.log('ğŸ“– çº¿ä¸‹æ¨¡å¼å‰§æƒ…æ€»ç»“å·²ä¿å­˜åˆ°è·¨åº”ç”¨æ—¶é—´çº¿:', timelineMemory);

                    // ğŸ”¥ã€æ–°å¢ã€‘ä¿å­˜èŠå¤©è®°å½•åˆ°å†å²è®°å½•
                    saveOfflineHistoryRecord(summary.trim(), offlineMessages.slice());

                    // ğŸ”¥ã€å…³é”®ä¿®å¤ã€‘ç¡®ä¿çº¿ä¸‹æ¨¡å¼æ¶ˆæ¯å·²ç»ä¿å­˜åˆ°ä¸»èŠå¤©è®°å½•ä¸­
                    // æ£€æŸ¥ä¸»èŠå¤©è®°å½•ä¸­æ˜¯å¦åŒ…å«æ‰€æœ‰çº¿ä¸‹æ¶ˆæ¯
                    const characterId = currentChatCharacter.id;
                    if (chatMessages[characterId]) {
                        const offlineMessagesInMain = chatMessages[characterId].filter(msg => msg.isOfflineMode);
                        console.log(`ğŸ“Š ä¸»èŠå¤©è®°å½•ä¸­çš„çº¿ä¸‹æ¶ˆæ¯: ${offlineMessagesInMain.length}æ¡`);
                        console.log(`ğŸ“Š å½“å‰çº¿ä¸‹æ¶ˆæ¯æ•°ç»„: ${offlineMessages.length}æ¡`);

                        // ç¡®ä¿ä¸»èŠå¤©è®°å½•å·²ä¿å­˜
                        await saveChatMessages(characterId);
                        console.log('âœ… å·²ç¡®ä¿çº¿ä¸‹æ¨¡å¼æ¶ˆæ¯ä¿å­˜åˆ°ä¸»èŠå¤©è®°å½•ä¸­');
                    } else {
                        console.warn('âš ï¸ ä¸»èŠå¤©è®°å½•ä¸ºç©ºï¼Œè¿™å¯èƒ½å¯¼è‡´è®°å¿†è¿æ¥é—®é¢˜');
                    }

                    // ğŸ”¥ã€ä¿®å¤ã€‘æ¸…ç©ºçº¿ä¸‹æ¨¡å¼æ¶ˆæ¯
                    offlineMessages = [];
                    saveOfflineMessages();
                } else {
                    throw new Error('ç”Ÿæˆçš„å‰§æƒ…æ€»ç»“ä¸ºç©º');
                }

            } catch (error) {
                console.error('ç”Ÿæˆçº¿ä¸‹æ¨¡å¼å‰§æƒ…æ€»ç»“å¤±è´¥:', error);
                throw error;
            }
        }

        // æ˜¾ç¤ºçº¿ä¸‹é¢„è®¾è®¾ç½®
        function showOfflinePresetSettings() {
            document.getElementById('offline-preset-modal').style.display = 'flex';

            // åŠ è½½å¹¶æ˜¾ç¤ºå·²ä¿å­˜çš„é¢„è®¾
            loadAndDisplayPresets();

            // æ¸…ç©ºè¡¨å•
            clearPresetForm();
        }

        // å…³é—­çº¿ä¸‹é¢„è®¾è®¾ç½®
        function closeOfflinePresetSettings() {
            document.getElementById('offline-preset-modal').style.display = 'none';
            // æ¸…ç†ç¼–è¾‘çŠ¶æ€
            delete window.editingPresetId;
        }

        // æ¸…ç©ºé¢„è®¾è¡¨å•
        function clearPresetForm() {
            document.getElementById('offline-preset-name').value = '';
            document.getElementById('offline-preset-content').value = '';
        }

        // åŠ è½½å¹¶æ˜¾ç¤ºå·²ä¿å­˜çš„é¢„è®¾
        async function loadAndDisplayPresets() {
            try {
                // ğŸ”¥ã€ä¿®å¤ã€‘ä»Dexieæ•°æ®åº“åŠ è½½é¢„è®¾ï¼Œé¿å…isGlobalå­—æ®µçš„ç´¢å¼•é—®é¢˜
                const allPresets = await db.offlinePresets.toArray();
                const presets = allPresets.filter(preset => preset.isGlobal === true);
                const container = document.getElementById('saved-presets-list');

                container.innerHTML = '';

                if (presets.length === 0) {
                    return; // CSSä¼šæ˜¾ç¤º"æš‚æ— ä¿å­˜çš„é¢„è®¾"
                }

                // æŒ‰æ—¶é—´æˆ³æ’åºï¼Œæœ€æ–°çš„åœ¨å‰
                presets.sort((a, b) => b.timestamp - a.timestamp);

                presets.forEach(preset => {
                    const presetDiv = document.createElement('div');
                    presetDiv.className = 'preset-item';
                    if (currentOfflinePreset && currentOfflinePreset.id === preset.id) {
                        presetDiv.classList.add('active');
                    }

                    const presetInfo = document.createElement('div');
                    presetInfo.className = 'preset-info';

                    const presetName = document.createElement('div');
                    presetName.className = 'preset-name';
                    presetName.textContent = preset.name;

                    const presetPreview = document.createElement('div');
                    presetPreview.className = 'preset-preview';
                    presetPreview.textContent = preset.content.substring(0, 50) + (preset.content.length > 50 ? '...' : '');

                    presetInfo.appendChild(presetName);
                    presetInfo.appendChild(presetPreview);

                    const presetActions = document.createElement('div');
                    presetActions.className = 'preset-actions';

                    // ä½¿ç”¨æŒ‰é’®
                    const useBtn = document.createElement('button');
                    useBtn.className = 'preset-action-btn use-btn';
                    useBtn.innerHTML = '<i class="fas fa-check"></i>';
                    useBtn.title = 'ä½¿ç”¨æ­¤é¢„è®¾';
                    useBtn.onclick = () => usePreset(preset);

                    // ç¼–è¾‘æŒ‰é’®
                    const editBtn = document.createElement('button');
                    editBtn.className = 'preset-action-btn edit-btn';
                    editBtn.innerHTML = '<i class="fas fa-edit"></i>';
                    editBtn.title = 'ç¼–è¾‘é¢„è®¾';
                    editBtn.onclick = () => editPreset(preset);

                    // åˆ é™¤æŒ‰é’®
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'preset-action-btn delete-btn';
                    deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                    deleteBtn.title = 'åˆ é™¤é¢„è®¾';
                    deleteBtn.onclick = () => deletePreset(preset.id);

                    presetActions.appendChild(useBtn);
                    presetActions.appendChild(editBtn);
                    presetActions.appendChild(deleteBtn);

                    presetDiv.appendChild(presetInfo);
                    presetDiv.appendChild(presetActions);

                    container.appendChild(presetDiv);
                });

                console.log(`âœ… åŠ è½½äº† ${presets.length} ä¸ªçº¿ä¸‹æ¨¡å¼é¢„è®¾`);
            } catch (error) {
                console.error('âŒ åŠ è½½çº¿ä¸‹æ¨¡å¼é¢„è®¾å¤±è´¥:', error);
                showToast('åŠ è½½é¢„è®¾å¤±è´¥', 'error');
            }
        }

        // ä½¿ç”¨é¢„è®¾
        function usePreset(preset) {
            currentOfflinePreset = preset;
            loadAndDisplayPresets(); // åˆ·æ–°åˆ—è¡¨æ˜¾ç¤º
            showToast(`å·²å¯ç”¨é¢„è®¾"${preset.name}"`, 'success');
        }

        // ç¼–è¾‘é¢„è®¾
        function editPreset(preset) {
            document.getElementById('offline-preset-name').value = preset.name;
            document.getElementById('offline-preset-content').value = preset.content;

            // ä¸´æ—¶å­˜å‚¨æ­£åœ¨ç¼–è¾‘çš„é¢„è®¾ID
            window.editingPresetId = preset.id;
        }

        // åˆ é™¤é¢„è®¾
        async function deletePreset(presetId) {
            if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªé¢„è®¾å—ï¼Ÿ')) {
                return;
            }

            try {
                // ğŸ”¥ã€ä¿®æ”¹ã€‘ä»Dexieæ•°æ®åº“åˆ é™¤é¢„è®¾
                const preset = await db.offlinePresets.get(presetId);
                if (!preset) {
                    showToast('é¢„è®¾ä¸å­˜åœ¨', 'warning');
                    return;
                }

                await db.offlinePresets.delete(presetId);

                // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰ä½¿ç”¨çš„é¢„è®¾ï¼Œæ¸…ç©ºå½“å‰é¢„è®¾
                if (currentOfflinePreset && currentOfflinePreset.id === presetId) {
                    currentOfflinePreset = null;
                }

                await loadAndDisplayPresets(); // åˆ·æ–°åˆ—è¡¨
                showToast(`é¢„è®¾"${preset.name}"å·²åˆ é™¤`, 'info');
                console.log(`âœ… åˆ é™¤é¢„è®¾: ${preset.name} (${presetId})`);
            } catch (error) {
                console.error('âŒ åˆ é™¤é¢„è®¾å¤±è´¥:', error);
                showToast('åˆ é™¤é¢„è®¾å¤±è´¥', 'error');
            }
        }

        // ä¿å­˜çº¿ä¸‹é¢„è®¾
        async function saveOfflinePreset() {
            const name = document.getElementById('offline-preset-name').value.trim();
            const content = document.getElementById('offline-preset-content').value.trim();

            if (!name) {
                showToast('è¯·è¾“å…¥é¢„è®¾åç§°', 'warning');
                return;
            }

            if (!content) {
                showToast('è¯·è¾“å…¥é¢„è®¾å†…å®¹', 'warning');
                return;
            }

            try {
                // æ£€æŸ¥æ˜¯å¦æ˜¯ç¼–è¾‘ç°æœ‰é¢„è®¾
                if (window.editingPresetId) {
                    // ğŸ”¥ã€ä¿®æ”¹ã€‘æ›´æ–°Dexieæ•°æ®åº“ä¸­çš„é¢„è®¾
                    const existingPreset = await db.offlinePresets.get(window.editingPresetId);
                    if (existingPreset) {
                        // æ›´æ–°ç°æœ‰é¢„è®¾
                        existingPreset.name = name;
                        existingPreset.content = content;
                        existingPreset.timestamp = Date.now(); // æ›´æ–°æ—¶é—´æˆ³

                        await db.offlinePresets.put(existingPreset);

                        // å¦‚æœæ­£åœ¨ç¼–è¾‘çš„æ˜¯å½“å‰ä½¿ç”¨çš„é¢„è®¾ï¼Œæ›´æ–°å½“å‰é¢„è®¾
                        if (currentOfflinePreset && currentOfflinePreset.id === window.editingPresetId) {
                            currentOfflinePreset = existingPreset;
                        }

                        delete window.editingPresetId;

                        await loadAndDisplayPresets(); // åˆ·æ–°åˆ—è¡¨
                        clearPresetForm();
                        showToast(`é¢„è®¾"${name}"å·²æ›´æ–°`, 'success');
                        console.log(`âœ… æ›´æ–°é¢„è®¾: ${name} (${existingPreset.id})`);
                        return;
                    }
                    delete window.editingPresetId;
                }

                // ğŸ”¥ã€ä¿®æ”¹ã€‘åˆ›å»ºæ–°é¢„è®¾å¹¶ä¿å­˜åˆ°Dexieæ•°æ®åº“
                const preset = {
                    id: `preset_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    name: name,
                    content: content,
                    timestamp: Date.now(),
                    isGlobal: true
                };

                await db.offlinePresets.add(preset);

                // è®¾ç½®ä¸ºå½“å‰é¢„è®¾
                currentOfflinePreset = preset;

                await loadAndDisplayPresets(); // åˆ·æ–°åˆ—è¡¨
                clearPresetForm();
                showToast(`é¢„è®¾"${name}"å·²ä¿å­˜å¹¶å¯ç”¨`, 'success');
                console.log(`âœ… ä¿å­˜æ–°é¢„è®¾: ${name} (${preset.id})`);
            } catch (error) {
                console.error('âŒ ä¿å­˜é¢„è®¾å¤±è´¥:', error);
                showToast('ä¿å­˜é¢„è®¾å¤±è´¥', 'error');
            }
        }

        // åŠ è½½çº¿ä¸‹æ¶ˆæ¯
        function loadOfflineMessages() {
            if (!currentChatCharacter || !windowId) return;

            // ğŸ”¥ã€ä¿®å¤ã€‘åªæœ‰å½“offlineMessagesä¸ºç©ºæ—¶æ‰ä»localStorageåŠ è½½
            // è¿™æ ·å¯ä»¥é¿å…åœ¨é€€å‡ºåé‡æ–°è¿›å…¥æ—¶é‡æ–°åŠ è½½å·²æ¸…ç©ºçš„æ•°æ®
            if (!offlineMessages || offlineMessages.length === 0) {
                // ğŸ”¥ã€ä¿®å¤ã€‘åŠ å…¥çª—å£IDï¼Œç¡®ä¿ä¸åŒçª—å£çš„çº¿ä¸‹æ¶ˆæ¯å®Œå…¨éš”ç¦»
                const key = `offlineMessages_${currentChatCharacter.id}_${windowId}`;
                offlineMessages = JSON.parse(localStorage.getItem(key) || '[]');
                console.log(`ğŸ“± ä»localStorageåŠ è½½çº¿ä¸‹æ¶ˆæ¯ (çª—å£${windowId}): ${offlineMessages.length}æ¡`);
            } else {
                console.log(`ğŸ“± ä½¿ç”¨å†…å­˜ä¸­çš„çº¿ä¸‹æ¶ˆæ¯ (çª—å£${windowId}): ${offlineMessages.length}æ¡`);
            }

            // ğŸ”¥ã€ä¿®æ”¹ã€‘åŠ è½½å…¨å±€é¢„è®¾ä»Dexieæ•°æ®åº“
            loadLatestOfflinePreset();

            renderOfflineMessages();
        }

        // ğŸ”¥ã€æ–°å¢ã€‘åŠ è½½æœ€æ–°çš„çº¿ä¸‹æ¨¡å¼é¢„è®¾
        async function loadLatestOfflinePreset() {
            try {
                // ğŸ”¥ã€ä¿®å¤ã€‘é¿å…isGlobalå­—æ®µçš„ç´¢å¼•é—®é¢˜
                const allPresets = await db.offlinePresets.toArray();
                const presets = allPresets.filter(preset => preset.isGlobal === true);

                if (presets.length > 0) {
                    // æŒ‰æ—¶é—´æˆ³æ’åºï¼Œä½¿ç”¨æœ€æ–°çš„é¢„è®¾
                    presets.sort((a, b) => b.timestamp - a.timestamp);
                    currentOfflinePreset = presets[0];
                    console.log(`âœ… åŠ è½½æœ€æ–°é¢„è®¾: ${currentOfflinePreset.name}`);
                } else {
                    currentOfflinePreset = null;
                    console.log('ğŸ“ æ²¡æœ‰å¯ç”¨çš„çº¿ä¸‹æ¨¡å¼é¢„è®¾');
                }
            } catch (error) {
                console.error('âŒ åŠ è½½çº¿ä¸‹æ¨¡å¼é¢„è®¾å¤±è´¥:', error);
                currentOfflinePreset = null;
            }
        }

        // æ¸²æŸ“çº¿ä¸‹æ¶ˆæ¯
        function renderOfflineMessages() {
            const container = document.getElementById('offline-chat-messages');
            container.innerHTML = '';

            offlineMessages.forEach(message => {
                const messageDiv = document.createElement('div');
                messageDiv.className = `offline-message ${message.sender}`;
                messageDiv.dataset.messageId = message.id;

                // æ·»åŠ å¤´åƒ
                const avatarDiv = document.createElement('div');
                avatarDiv.className = `offline-avatar ${message.sender === 'user' ? 'user-avatar' : 'ai-avatar'}`;

                if (message.sender === 'user') {
                    // ğŸ”¥ã€ä¿®å¤ã€‘æ­£ç¡®è·å–ç”¨æˆ·èº«ä»½é¢å…·å¡å¤´åƒ
                    let userAvatar = null;
                    let userName = 'ç”¨æˆ·';

                    // è·å–å½“å‰èŠå¤©è®¾ç½®
                    const chatSettings = getCurrentChatSettings();

                    // ä¼˜å…ˆçº§1ï¼šèŠå¤©ä¸“å±å¤´åƒè®¾ç½®
                    if (chatSettings.myChatAvatar) {
                        userAvatar = chatSettings.myChatAvatar;
                    }

                    // ä¼˜å…ˆçº§2ï¼šèº«ä»½é¢å…·å¡å¤´åƒ
                    if (!userAvatar && chatSettings.selectedIdentityId) {
                        const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                        if (selectedPersona) {
                            userAvatar = selectedPersona.avatarUrl;
                            userName = selectedPersona.name;
                        }
                    }

                    // ä¼˜å…ˆçº§3ï¼šå…¨å±€ç”¨æˆ·å¤´åƒ
                    if (!userAvatar && window.userAvatar) {
                        userAvatar = window.userAvatar;
                    }

                    if (userAvatar && userAvatar.trim()) {
                        avatarDiv.style.backgroundImage = `url(${userAvatar})`;
                        avatarDiv.style.backgroundSize = 'cover';
                        avatarDiv.style.backgroundPosition = 'center';
                        avatarDiv.textContent = '';
                    } else {
                        // ä½¿ç”¨é»˜è®¤å¤´åƒç”Ÿæˆå‡½æ•°
                        const defaultAvatar = createDefaultAvatar(userName);
                        avatarDiv.style.backgroundImage = `url(${defaultAvatar})`;
                        avatarDiv.style.backgroundSize = 'cover';
                        avatarDiv.style.backgroundPosition = 'center';
                        avatarDiv.textContent = '';
                    }
                } else {
                    // ğŸ”¥ã€ä¿®å¤ã€‘æ­£ç¡®è·å–è§’è‰²å¤´åƒ
                    let aiAvatar = null;

                    if (currentChatCharacter) {
                        // è·å–å½“å‰èŠå¤©è®¾ç½®
                        const chatSettings = getCurrentChatSettings();

                        // ä¼˜å…ˆçº§1ï¼šåŠ¨æ€å¤´åƒ
                        if (chatSettings.aiDynamicAvatar) {
                            aiAvatar = chatSettings.aiDynamicAvatar;
                        }
                        // ä¼˜å…ˆçº§2ï¼šèŠå¤©ä¸“å±å¤´åƒ
                        else if (chatSettings.aiChatAvatar) {
                            aiAvatar = chatSettings.aiChatAvatar;
                        }
                        // ä¼˜å…ˆçº§3ï¼šè§’è‰²å¡åŸå§‹å¤´åƒ
                        else if (currentChatCharacter.avatarUrl) {
                            aiAvatar = currentChatCharacter.avatarUrl;
                        }
                        // ä¼˜å…ˆçº§4ï¼šè§’è‰²å¡avatarå­—æ®µï¼ˆå…¼å®¹æ€§ï¼‰
                        else if (currentChatCharacter.avatar) {
                            aiAvatar = currentChatCharacter.avatar;
                        }
                    }

                    if (aiAvatar && aiAvatar.trim()) {
                        avatarDiv.style.backgroundImage = `url(${aiAvatar})`;
                        avatarDiv.style.backgroundSize = 'cover';
                        avatarDiv.style.backgroundPosition = 'center';
                        avatarDiv.textContent = '';
                    } else {
                        // ä½¿ç”¨é»˜è®¤å¤´åƒç”Ÿæˆå‡½æ•°
                        const characterName = currentChatCharacter?.name || 'AI';
                        const defaultAvatar = createDefaultAvatar(characterName);
                        avatarDiv.style.backgroundImage = `url(${defaultAvatar})`;
                        avatarDiv.style.backgroundSize = 'cover';
                        avatarDiv.style.backgroundPosition = 'center';
                        avatarDiv.textContent = '';
                    }
                }

                const contentDiv = document.createElement('div');
                contentDiv.className = 'offline-message-content';
                // ğŸ”¥ã€ä¿®æ”¹ã€‘ä½¿ç”¨æ–°çš„æ ¼å¼åŒ–å‡½æ•°å¤„ç†æ–‡æœ¬
                contentDiv.innerHTML = formatOfflineText(message.content);

                messageDiv.appendChild(avatarDiv);
                messageDiv.appendChild(contentDiv);

                // ğŸ”¥ã€ä¿®å¤ã€‘ä¸ºæ‰€æœ‰æ¶ˆæ¯ï¼ˆç”¨æˆ·å’ŒAIï¼‰æ·»åŠ é•¿æŒ‰åŠŸèƒ½
                addOfflineMessageLongPressListener(messageDiv, message.id);

                container.appendChild(messageDiv);
            });

            // æ»šåŠ¨åˆ°åº•éƒ¨
            container.scrollTop = container.scrollHeight;

            // ğŸ”¥ã€æ–°å¢ã€‘åº”ç”¨ç•Œé¢è®¾ç½®åˆ°æ–°æ¸²æŸ“çš„æ¶ˆæ¯
            applyOfflineUISettings();
        }

        // å‘é€çº¿ä¸‹æ¶ˆæ¯
        async function sendOfflineMessage() {
            const input = document.getElementById('offline-input');
            const content = input.value.trim();

            if (!content) return;
            if (!currentChatCharacter) return;

            // ğŸ”¥ã€ä¿®å¤ã€‘å°†çº¿ä¸‹æ¨¡å¼æ¶ˆæ¯ç›´æ¥å­˜å‚¨åˆ°ä¸»èŠå¤©è®°å½•ä¸­ï¼Œä¿è¯æ—¶é—´çº¿è¿è´¯æ€§
            const characterId = currentChatCharacter.id;

            if (!chatMessages[characterId]) {
                chatMessages[characterId] = [];
            }

            const userChatMessage = {
                id: Date.now(),
                sender: 'sent', // ä½¿ç”¨æ ‡å‡†çš„senderæ ¼å¼
                content: content,
                timestamp: Date.now(),
                type: 'text',
                isOfflineMode: true // æ ‡è®°ä¸ºçº¿ä¸‹æ¨¡å¼æ¶ˆæ¯
            };

            chatMessages[characterId].push(userChatMessage);

            // ä¿å­˜åˆ°ä¸»èŠå¤©è®°å½•ä¸­
            await saveChatMessages(characterId);

            // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°çº¿ä¸‹æ¨¡å¼æ˜¾ç¤º
            const userMessage = {
                id: Date.now().toString(),
                sender: 'user',
                content: content,
                timestamp: new Date().toISOString()
            };

            offlineMessages.push(userMessage);
            input.value = '';
            renderOfflineMessages();

            // ä¿å­˜çº¿ä¸‹æ¶ˆæ¯
            saveOfflineMessages();

            // ğŸ”¥ã€æ–°å¢ã€‘æ˜¾ç¤ºAIå›å¤åŠ è½½åŠ¨ç”»
            showOfflineLoadingMessage();

            // ç”ŸæˆAIå›å¤
            try {
                const aiResponse = await generateOfflineResponse(content);

                // ğŸ”¥ã€ä¿®å¤ã€‘å°†AIå›å¤æ·»åŠ åˆ°ä¸»èŠå¤©è®°å½•ä¸­ï¼Œä¿è¯æ—¶é—´çº¿è¿è´¯æ€§
                const aiChatMessage = {
                    id: Date.now() + 1,
                    sender: 'received', // ä½¿ç”¨æ ‡å‡†çš„senderæ ¼å¼
                    content: aiResponse,
                    timestamp: Date.now() + 1,
                    type: 'text',
                    isOfflineMode: true // æ ‡è®°ä¸ºçº¿ä¸‹æ¨¡å¼æ¶ˆæ¯
                };

                chatMessages[characterId].push(aiChatMessage);
                await saveChatMessages(characterId);

                const aiMessage = {
                    id: (Date.now() + 1).toString(),
                    sender: 'ai',
                    content: aiResponse,
                    timestamp: new Date().toISOString()
                };

                offlineMessages.push(aiMessage);

                // ğŸ”¥ã€æ–°å¢ã€‘ç§»é™¤åŠ è½½åŠ¨ç”»å¹¶æ¸²æŸ“æ¶ˆæ¯
                hideOfflineLoadingMessage();
                renderOfflineMessages();
                saveOfflineMessages();

            } catch (error) {
                console.error('ç”Ÿæˆçº¿ä¸‹å›å¤å¤±è´¥:', error);
                // ğŸ”¥ã€æ–°å¢ã€‘å‡ºé”™æ—¶ä¹Ÿè¦ç§»é™¤åŠ è½½åŠ¨ç”»
                hideOfflineLoadingMessage();
                showToast('ç”Ÿæˆå›å¤å¤±è´¥', 'error');
            }
        }

        // çº¿ä¸‹æ¨¡å¼ä¸“ç”¨çš„APIè°ƒç”¨å‡½æ•°
        async function callOfflineChatAPI(prompt, character) {
            if (!apiSettings.key) {
                throw new Error('è¯·å…ˆè®¾ç½®APIå¯†é’¥');
            }

            // ä½¿ç”¨ä¸çº¿ä¸Šæ¨¡å¼ç›¸åŒçš„APIè®¾ç½®
            const isGemini = apiSettings.base.includes('generativelanguage.googleapis.com');

            if (isGemini) {
                // Gemini API æ ¼å¼
                const apiUrl = `${apiSettings.base}/models/${apiSettings.model}:generateContent?key=${apiSettings.key}`;

                const requestBody = {
                    contents: [
                        {
                            role: "user",
                            parts: [
                                {
                                    text: `ä½ æ˜¯${character.name}ï¼Œ${character.prompt}ã€‚ç°åœ¨å¤„äºçº¿ä¸‹å‰§æƒ…æ¨¡å¼ï¼Œè¯·ä»¥çº¯æ–‡æœ¬å½¢å¼å›å¤ï¼Œä¸“æ³¨äºæƒ…æ™¯æå†™å’Œå‰§æƒ…å‘å±•ã€‚\n\n${prompt}`
                                }
                            ]
                        }
                    ],
                    generationConfig: {
                        temperature: apiSettings.temperature || 0.8
                        // ç§»é™¤maxOutputTokensï¼ŒGeminiä¸æ”¯æŒè¿™ä¸ªå‚æ•°
                    }
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status}`);
                }

                const data = await response.json();
                console.log('ğŸ”¥ çº¿ä¸‹æ¨¡å¼Gemini APIå®Œæ•´å“åº”:', JSON.stringify(data, null, 2));

                // å®Œå…¨æŒ‰ç…§çº¿ä¸Šæ¨¡å¼çš„é€»è¾‘å¤„ç†
                const content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!content) {
                    console.log('ğŸ”¥ Gemini API å“åº”æ•°æ®:', data);
                    console.log('ğŸ”¥ candidates[0]:', data.candidates?.[0]);
                    if (data.candidates?.[0]?.content) {
                        console.log('ğŸ”¥ content:', data.candidates[0].content);
                    }
                    if (data.candidates?.[0]?.content?.parts) {
                        console.log('ğŸ”¥ parts:', data.candidates[0].content.parts);
                    }
                    return 'æŠ±æ­‰ï¼Œæˆ‘ç°åœ¨æ— æ³•å›å¤ã€‚'; // ä¸è¦æŠ›å‡ºé”™è¯¯ï¼Œç›´æ¥è¿”å›é»˜è®¤å›å¤
                }

                return content;

            } else {
                // OpenAI æ ¼å¼
                let baseUrl = apiSettings.base;
                let apiUrl;
                if (baseUrl.endsWith('/v1')) {
                    apiUrl = `${baseUrl}/chat/completions`;
                } else {
                    apiUrl = `${baseUrl}/v1/chat/completions`;
                }

                const requestBody = {
                    model: apiSettings.model,
                    messages: [
                        {
                            role: "system",
                            content: `ä½ æ˜¯${character.name}ï¼Œ${character.prompt}ã€‚ç°åœ¨å¤„äºçº¿ä¸‹å‰§æƒ…æ¨¡å¼ï¼Œè¯·ä»¥çº¯æ–‡æœ¬å½¢å¼å›å¤ï¼Œä¸“æ³¨äºæƒ…æ™¯æå†™å’Œå‰§æƒ…å‘å±•ã€‚`
                        },
                        {
                            role: "user",
                            content: prompt
                        }
                    ],
                    temperature: apiSettings.temperature || 0.8,
                    max_tokens: 1000
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiSettings.key}`
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status}`);
                }

                const data = await response.json();
                console.log('çº¿ä¸‹æ¨¡å¼OpenAI APIå“åº”æ•°æ®:', data);

                const content = data.choices?.[0]?.message?.content;
                if (!content) {
                    console.error('OpenAI APIè¿”å›äº†ç©ºå†…å®¹æˆ–æ ¼å¼å¼‚å¸¸:', data);
                    throw new Error('OpenAI APIè¿”å›äº†ç©ºå†…å®¹');
                }

                return content;
            }
        }

        // ç”Ÿæˆçº¿ä¸‹æ¨¡å¼çš„AIå›å¤
        async function generateOfflineResponse(userInput) {
            const character = currentChatCharacter;

            console.log('ğŸ­ ===== çº¿ä¸‹æ¨¡å¼AIå›å¤ç”Ÿæˆå¼€å§‹ =====');
            console.log('ğŸ­ å½“å‰è§’è‰²:', character.name);
            console.log('ğŸ­ ç”¨æˆ·è¾“å…¥:', userInput);

            // ğŸ”¥ã€æ–°å¢ã€‘ä½¿ç”¨ä¸çº¿ä¸Šæ¨¡å¼ç›¸åŒçš„è®°å¿†ç³»ç»Ÿæ„å»ºprompt
            let prompt = `ä½ ç°åœ¨å¤„äºçº¿ä¸‹å‰§æƒ…æ¨¡å¼ï¼Œéœ€è¦ä»¥çº¯æ–‡æœ¬å½¢å¼å›å¤ï¼Œä¸è¦ä½¿ç”¨JSONæ ¼å¼ã€‚

ã€é‡è¦æç¤ºã€‘ç”¨æˆ·æ¶ˆæ¯ä¸­çš„æ‹¬å·()å†…å®¹æ˜¯ç¯å¢ƒæå†™ã€åŠ¨ä½œæå†™æˆ–å¿ƒç†æ´»åŠ¨ï¼Œä½ å¯ä»¥è§‚å¯Ÿåˆ°è¿™äº›ä¿¡æ¯ä½œä¸ºèƒŒæ™¯ï¼Œä½†ä¸èƒ½è¡¨ç°å¾—åƒæ˜¯"å¬åˆ°"äº†ç”¨æˆ·çš„å†…å¿ƒæƒ³æ³•ã€‚ä½ åªèƒ½å¯¹æ‹¬å·å¤–çš„å®é™…è¯è¯­è¿›è¡Œå›åº”ï¼Œå¯ä»¥é€šè¿‡è§‚å¯Ÿç”¨æˆ·çš„å¯è§è¡Œä¸ºï¼ˆå¦‚çŠ¹è±«ã€åœé¡¿ç­‰ï¼‰æ¥æ¨æµ‹æƒ…å†µï¼Œä½†ä¸èƒ½ç›´æ¥å›åº”ç”¨æˆ·çš„å†…å¿ƒæƒ³æ³•ã€‚

`;

            // ğŸ”¥ã€æ–°å¢ã€‘è·å–èŠå¤©è®¾ç½®å’Œè®°å¿†æ•°æ®
            const chatSettings = getCurrentChatSettings();
            console.log('âš™ï¸ èŠå¤©è®¾ç½®:', chatSettings);

            // è·å–åŠ¨æ€è®°å¿†æ•°æ®
            let dynamicMemoryContent = '';
            const enableDynamicMemory = chatSettings.enableDynamicMemory !== false; // é»˜è®¤ä¸ºtrue
            console.log('ğŸ“± åŠ¨æ€è®°å¿†å¼€å…³:', enableDynamicMemory);
            if (enableDynamicMemory) {
                try {
                    const recentMoments = await getVisibleMomentsForCharacter(character.id, 5);
                    console.log('ğŸ“± è·å–åˆ°çš„åŠ¨æ€æ•°é‡:', recentMoments.length);
                    if (recentMoments.length > 0) {
                        dynamicMemoryContent = '\n\nã€æœ€æ–°åŠ¨æ€è®°å¿†ã€‘ä»¥ä¸‹æ˜¯æœ€è¿‘çš„åŠ¨æ€å†…å®¹ï¼Œä½ å¯ä»¥åœ¨å¯¹è¯ä¸­è‡ªç„¶åœ°æåŠï¼š\n';
                        recentMoments.forEach((moment, index) => {
                            const authorName = moment.authorId === 'user' ? 'ç”¨æˆ·' : moment.nickname;
                            dynamicMemoryContent += `${index + 1}. ${authorName}: ${moment.text}\n`;
                            console.log(`ğŸ“± åŠ¨æ€ ${index + 1}: ${authorName} - ${moment.text}`);
                        });
                    } else {
                        console.log('ğŸ“± æ²¡æœ‰å¯ç”¨çš„åŠ¨æ€è®°å¿†');
                    }
                } catch (error) {
                    console.error('è·å–åŠ¨æ€è®°å¿†å¤±è´¥:', error);
                }
            }

            // è·å–å…¨å±€è®°å¿†æ•°æ®
            let globalMemoryContent = '';
            try {
                const memorySettings = getGlobalMemorySettings();
                console.log('ğŸ§  è®°å¿†è®¾ç½®:', memorySettings);

                const currentContext = {
                    type: 'private_chat',
                    id: character.id
                };
                console.log('ğŸ§  å½“å‰ä¸Šä¸‹æ–‡:', currentContext);

                // ğŸ”¥ã€ä¿®å¤ã€‘çº¿ä¸‹æ¨¡å¼å¼ºåˆ¶å¯ç”¨å…¨å±€è®°å¿†è¯»å–ï¼Œä½†ä¸å­˜å‚¨
                console.log('ğŸ§  çº¿ä¸‹æ¨¡å¼ï¼šå¼ºåˆ¶å¯ç”¨å…¨å±€è®°å¿†è¯»å–...');
                globalMemoryContent = await buildGlobalMemoryContext(character.id, currentContext, memorySettings.memoryDays);
                console.log('ğŸ§  è·å–åˆ°çš„å…¨å±€è®°å¿†å†…å®¹:', globalMemoryContent);
                if (globalMemoryContent && globalMemoryContent.trim()) {
                    console.log('ğŸ§  çº¿ä¸‹æ¨¡å¼å·²è·å–å…¨å±€è®°å¿†ä¸Šä¸‹æ–‡ï¼Œæ€»é•¿åº¦:', globalMemoryContent.length);
                    console.log('ğŸ§  çº¿ä¸‹æ¨¡å¼å…¨å±€è®°å¿†å†…å®¹é¢„è§ˆ:', globalMemoryContent.substring(0, 200) + '...');
                } else {
                    console.log('ğŸ§  å…¨å±€è®°å¿†å†…å®¹ä¸ºç©º');
                }
            } catch (error) {
                console.error('è·å–å…¨å±€è®°å¿†å¤±è´¥:', error);
            }

            // æ·»åŠ è§’è‰²ä¿¡æ¯
            const characterPrompt = character.prompt || character.bio || `ä½ æ˜¯${character.name}ã€‚`;
            console.log('ğŸ‘¤ è§’è‰²äººè®¾:', characterPrompt);
            console.log('ğŸ‘¤ è§’è‰²å®Œæ•´ä¿¡æ¯:', character);
            prompt += `è§’è‰²ä¿¡æ¯ï¼š\n${characterPrompt}\n\n`;

            // ğŸ”¥ã€æ–°å¢ã€‘æ·»åŠ ä¸–ç•Œä¹¦ä¿¡æ¯
            let worldbookContent = '';
            try {
                const localBookIds = chatSettings.selectedWorldbooks || [];
                const globalBooks = window.activeGlobalWorldbooks || [];
                const allBookIds = [...new Set([...globalBooks, ...localBookIds])]; // åˆå¹¶å¹¶å»é‡

                console.log('ğŸ“š ä¸–ç•Œä¹¦IDåˆ—è¡¨:', allBookIds);
                console.log('ğŸ“š å…¨å±€ä¸–ç•Œä¹¦:', globalBooks);
                console.log('ğŸ“š å±€éƒ¨ä¸–ç•Œä¹¦:', localBookIds);
                console.log('ğŸ“š æ‰€æœ‰ä¸–ç•Œä¹¦æ•°æ®:', worldbooks);

                if (allBookIds.length > 0) {
                    worldbookContent = '\nã€ä¸–ç•Œä¹¦ä¿¡æ¯ã€‘ä»¥ä¸‹æ˜¯ç›¸å…³çš„ä¸–ç•Œè®¾å®šï¼š\n';
                    allBookIds.forEach((bookId, index) => {
                        const worldbook = worldbooks.find(w => w.id === bookId);
                        if (worldbook) {
                            console.log(`ğŸ“š æ‰¾åˆ°ä¸–ç•Œä¹¦ ${index + 1}: ${worldbook.name || worldbook.title}`);
                            worldbookContent += `${index + 1}. ${worldbook.name || worldbook.title}: ${worldbook.content}\n`;
                        } else {
                            console.log(`ğŸ“š æœªæ‰¾åˆ°ä¸–ç•Œä¹¦ID: ${bookId}`);
                        }
                    });
                    prompt += worldbookContent + '\n';
                    console.log('ğŸ“š ä¸–ç•Œä¹¦å†…å®¹å·²æ·»åŠ åˆ°promptï¼Œé•¿åº¦:', worldbookContent.length);
                } else {
                    console.log('ğŸ“š æ²¡æœ‰å¯ç”¨çš„ä¸–ç•Œä¹¦');
                }
            } catch (error) {
                console.error('è·å–ä¸–ç•Œä¹¦å¤±è´¥:', error);
            }

            // æ·»åŠ è®°å¿†å†…å®¹
            if (globalMemoryContent && globalMemoryContent.trim()) {
                prompt += '\n\nã€è§’è‰²è®°å¿†ã€‘ä»¥ä¸‹æ˜¯ç›¸å…³çš„è®°å¿†å†…å®¹ï¼š\n' + globalMemoryContent + '\n';
            }
            if (dynamicMemoryContent) {
                prompt += dynamicMemoryContent + '\n';
            }

            // æ·»åŠ ç”¨æˆ·è‡ªå®šä¹‰é¢„è®¾ï¼ˆé«˜æƒé‡ï¼‰
            if (currentOfflinePreset) {
                prompt += `ã€é‡è¦ã€‘ç”¨æˆ·è‡ªå®šä¹‰å‰§æƒ…é¢„è®¾ï¼ˆè¯·ä¸¥æ ¼éµå¾ªï¼‰ï¼š\n${currentOfflinePreset.content}\n\n`;
            } else {
                prompt += `é»˜è®¤å‰§æƒ…æ¨¡å¼è¦æ±‚ï¼š\n- ä»¥ç¬¬ä¸‰äººç§°è§†è§’è¿›è¡Œæƒ…æ™¯æå†™\n- åŒ…å«ç¯å¢ƒæå†™ã€åŠ¨ä½œæå†™ã€å¿ƒç†æå†™\n- æ¯æ¬¡å›å¤150-300å­—\n- è¥é€ æ²‰æµ¸å¼çš„å‰§æƒ…ä½“éªŒ\n- **é‡è¦**ï¼šç”¨æˆ·æ¶ˆæ¯ä¸­çš„æ‹¬å·()å†…å®¹æ˜¯ç¯å¢ƒæå†™ã€åŠ¨ä½œæå†™æˆ–å¿ƒç†æ´»åŠ¨ï¼Œä½ å¯ä»¥è§‚å¯Ÿåˆ°è¿™äº›ä¿¡æ¯ä½œä¸ºèƒŒæ™¯ï¼Œä½†ä¸èƒ½è¡¨ç°å¾—åƒæ˜¯"å¬åˆ°"äº†ç”¨æˆ·çš„å†…å¿ƒæƒ³æ³•ã€‚ä½ åªèƒ½å¯¹æ‹¬å·å¤–çš„å®é™…è¯è¯­è¿›è¡Œå›åº”ï¼Œå¯ä»¥é€šè¿‡è§‚å¯Ÿç”¨æˆ·çš„å¯è§è¡Œä¸ºï¼ˆå¦‚çŠ¹è±«ã€åœé¡¿ç­‰ï¼‰æ¥æ¨æµ‹æƒ…å†µï¼Œä½†ä¸èƒ½ç›´æ¥å›åº”ç”¨æˆ·çš„å†…å¿ƒæƒ³æ³•\n\n`;
            }

            // ğŸ”¥ã€ä¿®å¤ã€‘è¯»å–ç”¨æˆ·è®¾ç½®çš„å†å²æ¶ˆæ¯æ•°ï¼Œç›´æ¥ä»ä¸»èŠå¤©è®°å½•è·å–å®Œæ•´æ—¶é—´çº¿
            const historyCount = chatSettings.historyCount || 5;

            // è·å–ä¸»èŠå¤©è®°å½•ï¼ˆåŒ…å«çº¿ä¸Šå’Œçº¿ä¸‹æ¨¡å¼çš„æ‰€æœ‰æ¶ˆæ¯ï¼ŒæŒ‰æ—¶é—´é¡ºåºï¼‰
            const allMessages = chatMessages[character.id] || [];

            // æ ¹æ®ç”¨æˆ·è®¾ç½®çš„å†å²æ¶ˆæ¯æ•°è·å–æœ€è¿‘çš„æ¶ˆæ¯
            const recentChatMessages = allMessages.slice(-historyCount);

            // ç»Ÿè®¡æ¶ˆæ¯ç±»å‹
            const onlineCount = recentChatMessages.filter(msg => !msg.isOfflineMode).length;
            const offlineCount = recentChatMessages.filter(msg => msg.isOfflineMode).length;

            console.log('ğŸ’¬ çº¿ä¸‹æ¨¡å¼å®Œæ•´å‰æ–‡è®°å¿†:', recentChatMessages);
            console.log(`ğŸ“Š å†å²æ¶ˆæ¯ç»Ÿè®¡: çº¿ä¸Š${onlineCount}æ¡, çº¿ä¸‹${offlineCount}æ¡, æ€»è®¡ä½¿ç”¨${recentChatMessages.length}æ¡ (ç”¨æˆ·è®¾ç½®: ${historyCount}æ¡)`);

            if (recentChatMessages.length > 0) {
                prompt += `æœ€è¿‘çš„å¯¹è¯å†å²ï¼š\n`;
                recentChatMessages.forEach(msg => {
                    // æ ¹æ®senderå­—æ®µç¡®å®šè§’è‰²
                    const role = (msg.sender === 'sent' || msg.sender === 'user') ? 'ç”¨æˆ·' : character.name;
                    // æ ‡è®°æ¶ˆæ¯æ¥æºï¼ˆçº¿ä¸Š/çº¿ä¸‹ï¼‰
                    const modeTag = msg.isOfflineMode ? '[çº¿ä¸‹]' : '[çº¿ä¸Š]';
                    prompt += `${role}${modeTag}ï¼š${msg.content}\n`;
                });
                prompt += `\n`;
            }

            prompt += `ç”¨æˆ·åˆšæ‰è¯´ï¼š${userInput}\n\nè¯·ç›´æ¥ä»¥çº¯æ–‡æœ¬å½¢å¼å›å¤ï¼Œä¸è¦ä½¿ç”¨JSONæ•°ç»„æ ¼å¼ï¼Œæ³¨é‡æƒ…æ™¯æå†™å’Œæ°›å›´è¥é€ ã€‚`;

            console.log('ğŸ“ ===== å®Œæ•´çš„Promptå†…å®¹ =====');
            console.log(prompt);
            console.log('ğŸ“ ===== Promptç»“æŸ =====');

            try {
                // ä½¿ç”¨ä¸“é—¨çš„çº¿ä¸‹æ¨¡å¼APIè°ƒç”¨
                const response = await callOfflineChatAPI(prompt, character);

                // ç›´æ¥è¿”å›å“åº”å†…å®¹ï¼Œä¸è¿›è¡ŒJSONè§£æ
                return response || 'æŠ±æ­‰ï¼Œæˆ‘ç°åœ¨æ— æ³•å›å¤ã€‚';
            } catch (error) {
                console.error('çº¿ä¸‹æ¨¡å¼APIè°ƒç”¨å¤±è´¥:', error);
                throw error;
            }
        }

        // ä¿å­˜çº¿ä¸‹æ¶ˆæ¯
        function saveOfflineMessages() {
            if (!currentChatCharacter || !windowId) return;

            // ğŸ”¥ã€ä¿®å¤ã€‘åŠ å…¥çª—å£IDï¼Œç¡®ä¿ä¸åŒçª—å£çš„çº¿ä¸‹æ¶ˆæ¯å®Œå…¨éš”ç¦»
            const key = `offlineMessages_${currentChatCharacter.id}_${windowId}`;
            localStorage.setItem(key, JSON.stringify(offlineMessages));
            console.log(`ğŸ’¾ ä¿å­˜çº¿ä¸‹æ¶ˆæ¯åˆ°localStorage (çª—å£${windowId}): ${offlineMessages.length}æ¡`);
        }

        // é‡æ–°ç”Ÿæˆçº¿ä¸‹æ¨¡å¼çš„æœ€åä¸€æ¡AIå›å¤
        async function regenerateLastOfflineMessage() {
            if (!currentChatCharacter) return;
            if (offlineMessages.length === 0) return;

            // æ‰¾åˆ°æœ€åä¸€æ¡AIæ¶ˆæ¯
            let lastAiMessageIndex = -1;
            for (let i = offlineMessages.length - 1; i >= 0; i--) {
                if (offlineMessages[i].sender === 'ai') {
                    lastAiMessageIndex = i;
                    break;
                }
            }

            if (lastAiMessageIndex === -1) {
                showToast('æ²¡æœ‰æ‰¾åˆ°å¯é‡æ–°ç”Ÿæˆçš„AIæ¶ˆæ¯', 'warning');
                return;
            }

            // æ‰¾åˆ°å¯¹åº”çš„ç”¨æˆ·æ¶ˆæ¯
            let userMessageIndex = -1;
            for (let i = lastAiMessageIndex - 1; i >= 0; i--) {
                if (offlineMessages[i].sender === 'user') {
                    userMessageIndex = i;
                    break;
                }
            }

            if (userMessageIndex === -1) {
                showToast('æ²¡æœ‰æ‰¾åˆ°å¯¹åº”çš„ç”¨æˆ·æ¶ˆæ¯', 'warning');
                return;
            }

            // åˆ é™¤æœ€åä¸€æ¡AIæ¶ˆæ¯
            offlineMessages.splice(lastAiMessageIndex, 1);
            renderOfflineMessages();
            saveOfflineMessages();

            // ğŸ”¥ã€æ–°å¢ã€‘æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
            showOfflineLoadingMessage();

            // é‡æ–°ç”ŸæˆAIå›å¤
            try {
                const userMessage = offlineMessages[userMessageIndex];
                const aiResponse = await generateOfflineResponse(userMessage.content);

                const aiMessage = {
                    id: Date.now().toString(),
                    sender: 'ai',
                    content: aiResponse,
                    timestamp: new Date().toISOString()
                };

                offlineMessages.push(aiMessage);

                // ğŸ”¥ã€æ–°å¢ã€‘ç§»é™¤åŠ è½½åŠ¨ç”»å¹¶æ¸²æŸ“æ¶ˆæ¯
                hideOfflineLoadingMessage();
                renderOfflineMessages();
                saveOfflineMessages();

                showToast('AIå›å¤å·²é‡æ–°ç”Ÿæˆ', 'success');

            } catch (error) {
                console.error('é‡æ–°ç”ŸæˆAIå›å¤å¤±è´¥:', error);
                // ğŸ”¥ã€æ–°å¢ã€‘å‡ºé”™æ—¶ä¹Ÿè¦ç§»é™¤åŠ è½½åŠ¨ç”»
                hideOfflineLoadingMessage();
                showToast('é‡æ–°ç”Ÿæˆå¤±è´¥', 'error');
            }
        }

        // çº¿ä¸‹æ¨¡å¼æ¶ˆæ¯é•¿æŒ‰ç›‘å¬å™¨
        function addOfflineMessageLongPressListener(messageContainer, messageId) {
            let pressTimer = null;
            let isLongPress = false;

            // ğŸ”¥ã€ä¼˜åŒ–ã€‘æ›´å‡†ç¡®çš„ç§»åŠ¨è®¾å¤‡æ£€æµ‹
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                             'ontouchstart' in window ||
                             navigator.maxTouchPoints > 0 ||
                             window.innerWidth <= 768;

            const startLongPress = (e) => {
                isLongPress = false;
                // ğŸ”¥ã€ä¼˜åŒ–ã€‘ç§»åŠ¨ç«¯å’Œæ¡Œé¢ç«¯ä½¿ç”¨ä¸åŒçš„å»¶è¿Ÿæ—¶é—´
                const delay = isMobile ? 600 : 1000; // ç§»åŠ¨ç«¯600msï¼Œæ¡Œé¢ç«¯1000ms
                pressTimer = setTimeout(() => {
                    isLongPress = true;
                    // ğŸ”¥ã€ä¼˜åŒ–ã€‘æ·»åŠ è§¦è§‰åé¦ˆï¼ˆå¦‚æœæ”¯æŒï¼‰
                    if (navigator.vibrate && isMobile) {
                        navigator.vibrate(50);
                    }
                    showOfflineMessageMenu(messageId, e);
                    e.preventDefault();
                }, delay);
            };

            const cancelLongPress = () => {
                if (pressTimer) {
                    clearTimeout(pressTimer);
                    pressTimer = null;
                }
                setTimeout(() => {
                    isLongPress = false;
                }, 50);
            };

            const handleClick = (e) => {
                if (isLongPress) {
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
            };

            // è§¦æ‘¸äº‹ä»¶
            messageContainer.addEventListener('touchstart', startLongPress, { passive: false });
            messageContainer.addEventListener('touchend', cancelLongPress);
            messageContainer.addEventListener('touchmove', cancelLongPress);

            // é¼ æ ‡äº‹ä»¶ï¼ˆç”¨äºæ¡Œé¢ç«¯ï¼‰
            messageContainer.addEventListener('mousedown', startLongPress);
            messageContainer.addEventListener('mouseup', cancelLongPress);
            messageContainer.addEventListener('mouseleave', cancelLongPress);

            // å³é”®èœå•ï¼ˆæ¡Œé¢ç«¯ï¼‰
            messageContainer.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showOfflineMessageMenu(messageId, e);
            });

            // ç‚¹å‡»äº‹ä»¶
            messageContainer.addEventListener('click', handleClick, true);
        }

        // æ˜¾ç¤ºçº¿ä¸‹æ¨¡å¼æ¶ˆæ¯èœå•
        function showOfflineMessageMenu(messageId, event) {
            const message = offlineMessages.find(m => m.id === messageId);
            if (!message) return;

            // åˆ›å»ºèœå•
            const menu = document.createElement('div');
            menu.className = 'offline-message-menu';

            // æ ¹æ®æ¶ˆæ¯ç±»å‹æ˜¾ç¤ºä¸åŒçš„èœå•é¡¹
            if (message.sender === 'user') {
                menu.innerHTML = `
                    <div class="menu-item" onclick="editOfflineMessage('${messageId}')">
                        <i class="fas fa-edit"></i>
                        <span>ä¿®æ”¹æ¶ˆæ¯</span>
                    </div>
                    <div class="menu-item delete" onclick="deleteOfflineMessage('${messageId}')">
                        <i class="fas fa-trash"></i>
                        <span>åˆ é™¤æ¶ˆæ¯</span>
                    </div>
                `;
            } else {
                // ğŸ”¥ã€ä¿®æ”¹ã€‘AIæ¶ˆæ¯å¯ä»¥ç¼–è¾‘ã€åˆ é™¤å’Œé‡æ–°ç”Ÿæˆ
                menu.innerHTML = `
                    <div class="menu-item" onclick="editOfflineMessage('${messageId}')">
                        <i class="fas fa-edit"></i>
                        <span>ä¿®æ”¹æ¶ˆæ¯</span>
                    </div>
                    <div class="menu-item delete" onclick="deleteOfflineMessage('${messageId}')">
                        <i class="fas fa-trash"></i>
                        <span>åˆ é™¤æ¶ˆæ¯</span>
                    </div>
                    <div class="menu-item" onclick="regenerateOfflineMessage('${messageId}')">
                        <i class="fas fa-redo"></i>
                        <span>é‡æ–°ç”Ÿæˆ</span>
                    </div>
                `;
            }

            // ç§»é™¤ç°æœ‰èœå•
            const existingMenu = document.querySelector('.offline-message-menu');
            if (existingMenu) {
                existingMenu.remove();
            }

            // ğŸ”¥ã€ä¿®å¤ã€‘æ·»åŠ åˆ°çº¿ä¸‹æ¨¡å¼å®¹å™¨å†…ï¼Œè€Œä¸æ˜¯document.body
            const offlineContainer = document.getElementById('offline-mode-overlay');
            if (offlineContainer) {
                offlineContainer.appendChild(menu);
            } else {
                document.body.appendChild(menu);
            }

            // ğŸ”¥ã€ä¿®å¤ã€‘å®šä½èœå• - ç›¸å¯¹äºçº¿ä¸‹æ¨¡å¼å®¹å™¨å®šä½
            const rect = event.target.getBoundingClientRect();
            const containerRect = offlineContainer ? offlineContainer.getBoundingClientRect() : { left: 0, top: 0 };

            // è®¡ç®—ç›¸å¯¹äºå®¹å™¨çš„ä½ç½®
            const relativeLeft = rect.left - containerRect.left;
            const relativeTop = rect.top - containerRect.top;

            // è®¾ç½®èœå•æ ·å¼
            menu.style.position = 'absolute';
            menu.style.zIndex = '10001';

            // å…ˆæ·»åŠ åˆ°DOMä»¥è·å–èœå•å°ºå¯¸
            setTimeout(() => {
                const menuWidth = menu.offsetWidth || 140;
                const menuHeight = menu.offsetHeight || 100;
                const containerWidth = offlineContainer?.offsetWidth || 400;
                const containerHeight = offlineContainer?.offsetHeight || 600;

                // è®¡ç®—æœ€ä½³ä½ç½®ï¼Œç¡®ä¿èœå•åœ¨å®¹å™¨å†…
                let left = Math.min(relativeLeft, containerWidth - menuWidth - 10);
                let top = relativeTop - menuHeight - 5;

                // å¦‚æœä¸Šæ–¹ç©ºé—´ä¸å¤Ÿï¼Œæ˜¾ç¤ºåœ¨ä¸‹æ–¹
                if (top < 10) {
                    top = relativeTop + 30;
                }

                // ç¡®ä¿ä¸è¶…å‡ºå®¹å™¨è¾¹ç•Œ
                left = Math.max(10, left);
                top = Math.max(10, Math.min(top, containerHeight - menuHeight - 10));

                menu.style.left = left + 'px';
                menu.style.top = top + 'px';
            }, 0);

            // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­èœå•
            const closeMenu = (e) => {
                if (!menu.contains(e.target)) {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                }
            };
            setTimeout(() => {
                document.addEventListener('click', closeMenu);
            }, 100);
        }

        // ç¼–è¾‘çº¿ä¸‹æ¨¡å¼æ¶ˆæ¯
        function editOfflineMessage(messageId) {
            const message = offlineMessages.find(m => m.id === messageId);
            if (!message) return;

            // åˆ›å»ºç¼–è¾‘æ¨¡æ€æ¡†
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'flex';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 500px;">
                    <div class="modal-header">
                        <h3>${message.sender === 'user' ? 'ç¼–è¾‘ç”¨æˆ·æ¶ˆæ¯' : 'ç¼–è¾‘AIå›å¤'}</h3>
                        <button class="modal-close" onclick="this.closest('.modal').remove()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="modal-body">
                        <textarea id="edit-offline-message-content" placeholder="è¯·è¾“å…¥æ¶ˆæ¯å†…å®¹..." rows="4" style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px; resize: vertical;">${message.content}</textarea>
                        ${message.sender === 'ai' ? '<p style="color: #666; font-size: 12px; margin-top: 8px;">ğŸ’¡ æç¤ºï¼šæ”¯æŒ &lt;span color="é¢œè‰²"&gt;æ–‡æœ¬&lt;/span&gt; å’Œ *æ–œä½“* æ ¼å¼</p>' : ''}
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">å–æ¶ˆ</button>
                        <button class="btn btn-primary" onclick="saveEditedOfflineMessage('${messageId}')">ä¿å­˜</button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // ğŸ”¥ã€ä¿®å¤ã€‘èšç„¦åˆ°æ–‡æœ¬æ¡†ä½†ä¸é€‰ä¸­æ–‡æœ¬ï¼Œå…‰æ ‡ç§»åˆ°æœ«å°¾
            const textarea = modal.querySelector('#edit-offline-message-content');
            textarea.focus();
            textarea.setSelectionRange(textarea.value.length, textarea.value.length);

            // ç§»é™¤èœå•
            const menu = document.querySelector('.offline-message-menu');
            if (menu) menu.remove();
        }

        // ä¿å­˜ç¼–è¾‘çš„çº¿ä¸‹æ¶ˆæ¯
        async function saveEditedOfflineMessage(messageId) {
            const textarea = document.getElementById('edit-offline-message-content');
            const newContent = textarea.value.trim();

            if (!newContent) {
                showToast('æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º', 'warning');
                return;
            }

            const message = offlineMessages.find(m => m.id === messageId);
            if (message) {
                console.log('âœï¸ ç¼–è¾‘çº¿ä¸‹æ¨¡å¼æ¶ˆæ¯:', messageId, 'æ–°å†…å®¹:', newContent);

                // ğŸ”¥ã€ä¿®å¤ã€‘åŒæ—¶æ›´æ–°ä¸»èŠå¤©è®°å½•ä¸­å¯¹åº”çš„è®°å¿†æ•°æ®
                const characterId = currentChatCharacter.id;
                if (chatMessages[characterId]) {
                    const messageTimestamp = new Date(message.timestamp).getTime();

                    // ğŸ”¥ã€ä¿®æ”¹ã€‘æŸ¥æ‰¾å¹¶æ›´æ–°å¯¹åº”çš„æ¶ˆæ¯ï¼ˆæ”¯æŒç”¨æˆ·å’ŒAIæ¶ˆæ¯ï¼‰
                    chatMessages[characterId].forEach(msg => {
                        if (msg.isOfflineMode &&
                            ((msg.sender === 'sent' && message.sender === 'user') ||
                             (msg.sender === 'received' && message.sender === 'ai')) &&
                            Math.abs(msg.timestamp - messageTimestamp) < 5000) {
                            console.log('âœï¸ æ›´æ–°è®°å¿†æ•°æ®:', msg.content, '->', newContent);
                            msg.content = newContent;
                        }
                    });

                    // ä¿å­˜æ›´æ–°åçš„èŠå¤©è®°å½•
                    await saveChatMessages(characterId);
                }

                // æ›´æ–°çº¿ä¸‹æ¨¡å¼æ˜¾ç¤ºçš„æ¶ˆæ¯
                message.content = newContent;
                saveOfflineMessages();
                renderOfflineMessages();
                showToast('æ¶ˆæ¯å’Œè®°å¿†æ•°æ®å·²æ›´æ–°', 'success');
            }

            // å…³é—­æ¨¡æ€æ¡†
            const modal = document.querySelector('.modal');
            if (modal) modal.remove();
        }

        // é‡æ–°ç”ŸæˆAIå›å¤
        async function regenerateOfflineMessage(messageId) {
            const messageIndex = offlineMessages.findIndex(m => m.id === messageId);
            if (messageIndex === -1) return;

            const aiMessage = offlineMessages[messageIndex];
            if (aiMessage.sender !== 'ai') return;

            // æ‰¾åˆ°å¯¹åº”çš„ç”¨æˆ·æ¶ˆæ¯
            let userMessageIndex = messageIndex - 1;
            while (userMessageIndex >= 0 && offlineMessages[userMessageIndex].sender !== 'user') {
                userMessageIndex--;
            }

            if (userMessageIndex < 0) {
                showToast('æ‰¾ä¸åˆ°å¯¹åº”çš„ç”¨æˆ·æ¶ˆæ¯', 'error');
                return;
            }

            if (confirm('ç¡®å®šè¦é‡æ–°ç”Ÿæˆè¿™æ¡AIå›å¤å—ï¼Ÿ')) {
                console.log('ğŸ”„ é‡æ–°ç”ŸæˆAIå›å¤:', messageId);

                // åˆ é™¤å½“å‰AIå›å¤
                await deleteOfflineMessage(messageId);

                // ğŸ”¥ã€æ–°å¢ã€‘æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
                showOfflineLoadingMessage();

                // é‡æ–°ç”ŸæˆAIå›å¤
                try {
                    const userMessage = offlineMessages[userMessageIndex];
                    const aiResponse = await generateOfflineResponse(userMessage.content);

                    // ğŸ”¥ã€ä¿®å¤ã€‘å°†AIå›å¤æ·»åŠ åˆ°ä¸»èŠå¤©è®°å½•ä¸­ï¼Œä¿è¯æ—¶é—´çº¿è¿è´¯æ€§
                    const aiChatMessage = {
                        id: Date.now() + 1,
                        sender: 'received', // ä½¿ç”¨æ ‡å‡†çš„senderæ ¼å¼
                        content: aiResponse,
                        timestamp: Date.now() + 1,
                        type: 'text',
                        isOfflineMode: true // æ ‡è®°ä¸ºçº¿ä¸‹æ¨¡å¼æ¶ˆæ¯
                    };

                    const characterId = currentChatCharacter.id;
                    if (!chatMessages[characterId]) {
                        chatMessages[characterId] = [];
                    }
                    chatMessages[characterId].push(aiChatMessage);
                    await saveChatMessages(characterId);

                    const newAiMessage = {
                        id: Date.now().toString(),
                        sender: 'ai',
                        content: aiResponse,
                        timestamp: new Date().toISOString()
                    };

                    offlineMessages.push(newAiMessage);

                    // ğŸ”¥ã€æ–°å¢ã€‘ç§»é™¤åŠ è½½åŠ¨ç”»å¹¶æ¸²æŸ“æ¶ˆæ¯
                    hideOfflineLoadingMessage();
                    renderOfflineMessages();
                    saveOfflineMessages();

                    showToast('AIå›å¤å·²é‡æ–°ç”Ÿæˆ', 'success');

                } catch (error) {
                    console.error('é‡æ–°ç”ŸæˆAIå›å¤å¤±è´¥:', error);
                    // ğŸ”¥ã€æ–°å¢ã€‘å‡ºé”™æ—¶ä¹Ÿè¦ç§»é™¤åŠ è½½åŠ¨ç”»
                    hideOfflineLoadingMessage();
                    showToast('é‡æ–°ç”Ÿæˆå¤±è´¥', 'error');
                }
            }
        }

        // åˆ é™¤çº¿ä¸‹æ¨¡å¼æ¶ˆæ¯
        async function deleteOfflineMessage(messageId) {
            const messageIndex = offlineMessages.findIndex(m => m.id === messageId);
            if (messageIndex === -1) return;

            const message = offlineMessages[messageIndex];

            // ç¡®è®¤åˆ é™¤
            const confirmMessage = message.sender === 'user'
                ? 'ç¡®å®šè¦åˆ é™¤è¿™æ¡æ¶ˆæ¯å—ï¼Ÿè¿™å°†åŒæ—¶åˆ é™¤å­˜å‚¨çš„è®°å¿†æ•°æ®ã€‚'
                : 'ç¡®å®šè¦åˆ é™¤è¿™æ¡AIå›å¤å—ï¼Ÿè¿™å°†åŒæ—¶åˆ é™¤å­˜å‚¨çš„è®°å¿†æ•°æ®ã€‚';

            if (confirm(confirmMessage)) {
                console.log('ğŸ—‘ï¸ å¼€å§‹åˆ é™¤çº¿ä¸‹æ¨¡å¼æ¶ˆæ¯:', messageId, 'ç±»å‹:', message.sender);

                // ğŸ”¥ã€ä¿®å¤ã€‘åŒæ—¶åˆ é™¤ä¸»èŠå¤©è®°å½•ä¸­å¯¹åº”çš„è®°å¿†æ•°æ®
                const characterId = currentChatCharacter.id;
                if (chatMessages[characterId]) {
                    const offlineMessage = offlineMessages[messageIndex];
                    const messageTimestamp = new Date(offlineMessage.timestamp).getTime();

                    // åˆ é™¤å¯¹åº”çš„è®°å¿†æ•°æ®
                    const messagesToDelete = [];
                    chatMessages[characterId].forEach((msg, index) => {
                        if (msg.isOfflineMode && Math.abs(msg.timestamp - messageTimestamp) < 5000) {
                            messagesToDelete.push(index);
                        }
                    });

                    // ä»åå¾€å‰åˆ é™¤ï¼Œé¿å…ç´¢å¼•å˜åŒ–
                    messagesToDelete.reverse().forEach(index => {
                        console.log('ğŸ—‘ï¸ åˆ é™¤è®°å¿†æ•°æ®:', chatMessages[characterId][index]);
                        chatMessages[characterId].splice(index, 1);
                    });

                    // ä¿å­˜æ›´æ–°åçš„èŠå¤©è®°å½•
                    await saveChatMessages(characterId);
                }

                // ğŸ”¥ã€ä¿®å¤ã€‘åˆ é™¤çº¿ä¸‹æ¨¡å¼æ˜¾ç¤ºçš„æ¶ˆæ¯
                if (message.sender === 'user') {
                    // åˆ é™¤ç”¨æˆ·æ¶ˆæ¯
                    offlineMessages.splice(messageIndex, 1);

                    // å¦‚æœä¸‹ä¸€æ¡æ˜¯AIå›å¤ï¼Œä¹Ÿåˆ é™¤
                    if (messageIndex < offlineMessages.length &&
                        offlineMessages[messageIndex].sender === 'ai') {

                        // åŒæ—¶åˆ é™¤AIå›å¤çš„è®°å¿†æ•°æ®
                        const aiMessage = offlineMessages[messageIndex];
                        const aiTimestamp = new Date(aiMessage.timestamp).getTime();
                        const aiMessagesToDelete = [];
                        chatMessages[characterId].forEach((msg, index) => {
                            if (msg.isOfflineMode && msg.sender === 'received' &&
                                Math.abs(msg.timestamp - aiTimestamp) < 5000) {
                                aiMessagesToDelete.push(index);
                            }
                        });

                        aiMessagesToDelete.reverse().forEach(index => {
                            console.log('ğŸ—‘ï¸ åˆ é™¤AIå›å¤è®°å¿†æ•°æ®:', chatMessages[characterId][index]);
                            chatMessages[characterId].splice(index, 1);
                        });

                        offlineMessages.splice(messageIndex, 1);
                        await saveChatMessages(characterId);
                    }
                } else {
                    // åˆ é™¤AIæ¶ˆæ¯
                    offlineMessages.splice(messageIndex, 1);
                }

                saveOfflineMessages();
                renderOfflineMessages();
                showToast('æ¶ˆæ¯å’Œè®°å¿†æ•°æ®å·²åˆ é™¤', 'success');
            }

            // ç§»é™¤èœå•
            const menu = document.querySelector('.offline-message-menu');
            if (menu) menu.remove();
        }

        // ğŸ”¥ã€æ–°å¢ã€‘æ˜¾ç¤ºçº¿ä¸‹æ¨¡å¼AIå›å¤åŠ è½½åŠ¨ç”»
        function showOfflineLoadingMessage() {
            const container = document.getElementById('offline-chat-messages');

            // ç§»é™¤å·²å­˜åœ¨çš„åŠ è½½åŠ¨ç”»ï¼ˆé˜²æ­¢é‡å¤ï¼‰
            const existingLoading = container.querySelector('.offline-loading-message');
            if (existingLoading) {
                existingLoading.remove();
            }

            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'offline-loading-message';
            loadingDiv.id = 'offline-loading-indicator';

            const contentDiv = document.createElement('div');
            contentDiv.className = 'offline-loading-content';

            const dotsDiv = document.createElement('div');
            dotsDiv.className = 'offline-loading-dots';

            // åˆ›å»ºä¸‰ä¸ªåŠ è½½ç‚¹
            for (let i = 0; i < 3; i++) {
                const dot = document.createElement('div');
                dot.className = 'offline-loading-dot';
                dotsDiv.appendChild(dot);
            }

            contentDiv.appendChild(dotsDiv);
            loadingDiv.appendChild(contentDiv);
            container.appendChild(loadingDiv);

            // æ»šåŠ¨åˆ°åº•éƒ¨
            container.scrollTop = container.scrollHeight;
        }

        // ğŸ”¥ã€æ–°å¢ã€‘éšè—çº¿ä¸‹æ¨¡å¼AIå›å¤åŠ è½½åŠ¨ç”»
        function hideOfflineLoadingMessage() {
            const loadingIndicator = document.getElementById('offline-loading-indicator');
            if (loadingIndicator) {
                loadingIndicator.remove();
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘çº¿ä¸‹æ¨¡å¼æ–‡æœ¬æ ¼å¼åŒ–å‡½æ•°
        function formatOfflineText(text) {
            if (!text) return '';

            // ç§»é™¤æ‰€æœ‰HTMLæ ‡ç­¾ï¼Œä¿ç•™çº¯æ–‡æœ¬å†…å®¹
            let formattedText = text
                .replace(/<p>/gi, '')
                .replace(/<\/p>/gi, '\n\n')
                .replace(/<br\s*\/?>/gi, '\n')
                .replace(/<[^>]*>/g, ''); // ç§»é™¤æ‰€æœ‰å…¶ä»–HTMLæ ‡ç­¾

            // å¤„ç†**å·åŒ…è£¹çš„åŠ ç²—ï¼š**æ–‡æœ¬**
            formattedText = formattedText.replace(
                /\*\*([^*]+)\*\*/g,
                '<strong>$1</strong>'
            );

            // å¤„ç†*å·åŒ…è£¹çš„æ–œä½“ï¼š*æ–‡æœ¬*
            formattedText = formattedText.replace(
                /\*([^*]+)\*/g,
                '<em>$1</em>'
            );

            // å¤„ç†æ¢è¡Œ
            formattedText = formattedText.replace(/\n/g, '<br>');

            // æ¸…ç†å¤šä½™çš„æ¢è¡Œ
            formattedText = formattedText.replace(/(<br>\s*){3,}/g, '<br><br>');

            return formattedText;
        }

        // ç›‘å¬è¾“å…¥æ¡†å›è½¦äº‹ä»¶
        document.addEventListener('DOMContentLoaded', function() {
            const offlineInput = document.getElementById('offline-input');
            if (offlineInput) {
                offlineInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendOfflineMessage();
                    }
                });
            }
        });

        // ğŸ”¥ã€æ–°å¢ã€‘çº¿ä¸‹æ¨¡å¼èŠå¤©è®°å½•ç®¡ç†åŠŸèƒ½

        // ä¿å­˜èŠå¤©è®°å½•åˆ°å†å²è®°å½•
        async function saveOfflineHistoryRecord(summary, messages) {
            if (!currentChatCharacter || !messages || messages.length === 0) return;

            try {
                const historyRecord = {
                    id: `offline_history_${currentChatCharacter.id}_${Date.now()}`,
                    characterId: currentChatCharacter.id,
                    timestamp: Date.now(),
                    summary: summary,
                    messages: messages,
                    messageCount: messages.length
                };

                // ä¿å­˜åˆ° Dexie æ•°æ®åº“
                await db.offlineHistoryRecords.add(historyRecord);

                // ğŸ”¥ã€æ–°å¢ã€‘æ¸…ç†è¶…è¿‡20æ¡çš„æ—§è®°å½•
                const allRecords = await db.offlineHistoryRecords
                    .where('characterId')
                    .equals(currentChatCharacter.id)
                    .reverse()
                    .sortBy('timestamp');

                if (allRecords.length > 20) {
                    const recordsToDelete = allRecords.slice(20);
                    for (const record of recordsToDelete) {
                        await db.offlineHistoryRecords.delete(record.id);
                    }
                }

                console.log('ğŸ“š çº¿ä¸‹æ¨¡å¼èŠå¤©è®°å½•å·²ä¿å­˜åˆ°æ•°æ®åº“:', historyRecord);
            } catch (error) {
                console.error('ä¿å­˜çº¿ä¸‹æ¨¡å¼èŠå¤©è®°å½•å¤±è´¥:', error);
            }
        }

        // æ˜¾ç¤ºçº¿ä¸‹æ¨¡å¼èŠå¤©è®°å½•æ¨¡æ€æ¡†
        function showOfflineHistoryModal() {
            if (!currentChatCharacter) return;

            document.getElementById('offline-history-modal').style.display = 'flex';
            loadOfflineHistoryList();
        }

        // å…³é—­çº¿ä¸‹æ¨¡å¼èŠå¤©è®°å½•æ¨¡æ€æ¡†
        function closeOfflineHistoryModal() {
            document.getElementById('offline-history-modal').style.display = 'none';
        }

        // åŠ è½½å¹¶æ˜¾ç¤ºèŠå¤©è®°å½•åˆ—è¡¨
        async function loadOfflineHistoryList() {
            if (!currentChatCharacter) return;

            try {
                const historyRecords = await db.offlineHistoryRecords
                    .where('characterId')
                    .equals(currentChatCharacter.id)
                    .reverse()
                    .sortBy('timestamp');

                const container = document.getElementById('offline-history-list');
                container.innerHTML = '';

                if (historyRecords.length === 0) {
                    container.innerHTML = `
                        <div class="empty-history">
                            <i class="fas fa-history" style="font-size: 48px; color: #ccc; margin-bottom: 15px;"></i>
                            <p>è¿˜æ²¡æœ‰çº¿ä¸‹æ¨¡å¼èŠå¤©è®°å½•</p>
                            <p style="font-size: 12px; color: #999;">å®Œæˆçº¿ä¸‹å‰§æƒ…å¯¹è¯åï¼Œé€‰æ‹©"ç»“æŸä¸”ä¸æ€»ç»“"æˆ–"ç»“æŸå¹¶æ€»ç»“"ï¼ŒèŠå¤©è®°å½•ä¼šä¿å­˜åœ¨è¿™é‡Œ</p>
                        </div>
                    `;
                    return;
                }

                historyRecords.forEach((record, index) => {
                    const recordElement = document.createElement('div');
                    recordElement.className = 'history-record-item';
                    const date = new Date(record.timestamp).toLocaleDateString();
                    recordElement.innerHTML = `
                        <div class="history-record-header">
                            <div class="history-record-info">
                                <div class="history-record-title">å‰§æƒ…è®°å½• #${historyRecords.length - index}</div>
                                <div class="history-record-meta">${date} â€¢ ${record.messageCount}æ¡æ¶ˆæ¯</div>
                            </div>
                            <div class="history-record-actions">
                                <button class="history-action-btn" onclick="viewOfflineHistory('${record.id}')" title="æŸ¥çœ‹è¯¦æƒ…">
                                    <i class="fas fa-eye"></i>
                                </button>
                                <button class="history-action-btn delete" onclick="deleteOfflineHistory('${record.id}')" title="åˆ é™¤è®°å½•">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </div>
                        <div class="history-record-summary">${record.summary.substring(0, 100)}${record.summary.length > 100 ? '...' : ''}</div>
                    `;
                    container.appendChild(recordElement);
                });
            } catch (error) {
                console.error('åŠ è½½çº¿ä¸‹æ¨¡å¼èŠå¤©è®°å½•å¤±è´¥:', error);
            }
        }

        // æŸ¥çœ‹å…·ä½“çš„èŠå¤©è®°å½•
        async function viewOfflineHistory(recordId) {
            if (!currentChatCharacter) return;

            try {
                const record = await db.offlineHistoryRecords.get(recordId);

                if (!record) {
                    showToast('æ‰¾ä¸åˆ°è¯¥èŠå¤©è®°å½•', 'error');
                    return;
                }

            // åˆ›å»ºæŸ¥çœ‹è¯¦æƒ…çš„æ¨¡æ€æ¡†
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'flex';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 600px; max-height: 80vh;">
                    <div class="modal-header">
                        <h3>å‰§æƒ…è®°å½•è¯¦æƒ…</h3>
                        <button class="modal-close" onclick="this.closest('.modal').remove()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="modal-body" style="overflow-y: auto;">
                        <div class="history-detail-info">
                            <p><strong>æ—¥æœŸï¼š</strong>${record.date}</p>
                            <p><strong>æ¶ˆæ¯æ•°ï¼š</strong>${record.messageCount}æ¡</p>
                            <p><strong>å‰§æƒ…æ€»ç»“ï¼š</strong></p>
                            <div class="history-summary-text">${record.summary}</div>
                        </div>
                        <hr style="margin: 20px 0;">
                        <div class="history-messages">
                            <h4>å¯¹è¯è®°å½•ï¼š</h4>
                            <div class="history-messages-container">
                                ${record.messages.map(msg => `
                                    <div class="history-message ${msg.sender}">
                                        <div class="message-sender">${msg.sender === 'user' ? 'ç”¨æˆ·' : currentChatCharacter.name}</div>
                                        <div class="message-content">${msg.content}</div>
                                        <div class="message-time">${new Date(msg.timestamp).toLocaleTimeString()}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">å…³é—­</button>
                    </div>
                </div>
            `;

                document.body.appendChild(modal);
            } catch (error) {
                console.error('æŸ¥çœ‹çº¿ä¸‹æ¨¡å¼èŠå¤©è®°å½•å¤±è´¥:', error);
                showToast('æŸ¥çœ‹èŠå¤©è®°å½•å¤±è´¥', 'error');
            }
        }

        // åˆ é™¤å•ä¸ªèŠå¤©è®°å½•
        async function deleteOfflineHistory(recordId) {
            if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡èŠå¤©è®°å½•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) return;
            if (!currentChatCharacter) return;

            try {
                await db.offlineHistoryRecords.delete(recordId);
                loadOfflineHistoryList(); // é‡æ–°åŠ è½½åˆ—è¡¨
                showToast('èŠå¤©è®°å½•å·²åˆ é™¤', 'success');
            } catch (error) {
                console.error('åˆ é™¤çº¿ä¸‹æ¨¡å¼èŠå¤©è®°å½•å¤±è´¥:', error);
                showToast('åˆ é™¤èŠå¤©è®°å½•å¤±è´¥', 'error');
            }
        }

        // æ¸…ç©ºæ‰€æœ‰èŠå¤©è®°å½•
        async function clearAllOfflineHistory() {
            if (!confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰çº¿ä¸‹æ¨¡å¼èŠå¤©è®°å½•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) return;
            if (!currentChatCharacter) return;

            try {
                await db.offlineHistoryRecords
                    .where('characterId')
                    .equals(currentChatCharacter.id)
                    .delete();
                loadOfflineHistoryList(); // é‡æ–°åŠ è½½åˆ—è¡¨
                showToast('æ‰€æœ‰èŠå¤©è®°å½•å·²æ¸…ç©º', 'success');
            } catch (error) {
                console.error('æ¸…ç©ºçº¿ä¸‹æ¨¡å¼èŠå¤©è®°å½•å¤±è´¥:', error);
                showToast('æ¸…ç©ºèŠå¤©è®°å½•å¤±è´¥', 'error');
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘çº¿ä¸‹æ¨¡å¼ç•Œé¢è®¾ç½®åŠŸèƒ½
        let offlineUISettings = {};

        // æ˜¾ç¤ºçº¿ä¸‹æ¨¡å¼ç•Œé¢è®¾ç½®
        function showOfflineUISettings() {
            if (!currentChatCharacter) {
                showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè§’è‰²', 'warning');
                return;
            }

            document.getElementById('offline-ui-settings-modal').style.display = 'flex';
            loadOfflineUISettings();
        }

        // å…³é—­çº¿ä¸‹æ¨¡å¼ç•Œé¢è®¾ç½®
        function closeOfflineUISettings() {
            document.getElementById('offline-ui-settings-modal').style.display = 'none';
        }

        // åŠ è½½çº¿ä¸‹æ¨¡å¼ç•Œé¢è®¾ç½®
        async function loadOfflineUISettings() {
            if (!currentChatCharacter) return;

            const characterId = currentChatCharacter.id;

            try {
                // ğŸ”¥ã€ä¿®å¤ã€‘ä¿æŒçª—å£éš”ç¦»çš„åŒæ—¶å¢å¼ºæ‰‹æœºæµè§ˆå™¨å…¼å®¹æ€§
                let settingsRecord = null;
                let loadedFromDB = false;

                // é¦–å…ˆå°è¯•ä»æ•°æ®åº“åŠ è½½å¸¦çª—å£IDçš„è®¾ç½®ï¼ˆä¿æŒéš”ç¦»ï¼‰
                if (windowId) {
                    try {
                        settingsRecord = await db.offlineUISettings.get(`${characterId}_${windowId}_ui_settings`);
                        if (settingsRecord && settingsRecord.settings) {
                            loadedFromDB = true;
                            console.log(`âœ… ä»æ•°æ®åº“åŠ è½½çª—å£éš”ç¦»è®¾ç½®æˆåŠŸ (çª—å£${windowId})`);
                        }
                    } catch (dbError) {
                        console.warn('æ•°æ®åº“åŠ è½½çª—å£éš”ç¦»è®¾ç½®å¤±è´¥:', dbError);
                    }
                }

                // å¦‚æœçª—å£éš”ç¦»è®¾ç½®åŠ è½½å¤±è´¥ï¼Œå°è¯•é€šç”¨æ ¼å¼ï¼ˆå…¼å®¹æ€§å›é€€ï¼‰
                if (!loadedFromDB) {
                    try {
                        settingsRecord = await db.offlineUISettings.get(`${characterId}_ui_settings`);
                        if (settingsRecord && settingsRecord.settings) {
                            loadedFromDB = true;
                            console.log(`âœ… ä»æ•°æ®åº“åŠ è½½é€šç”¨æ ¼å¼è®¾ç½®æˆåŠŸï¼ˆå›é€€æ¨¡å¼ï¼‰`);
                        }
                    } catch (dbError) {
                        console.warn('æ•°æ®åº“åŠ è½½é€šç”¨æ ¼å¼è®¾ç½®ä¹Ÿå¤±è´¥:', dbError);
                    }
                }

                // å¦‚æœæ•°æ®åº“åŠ è½½å¤±è´¥ï¼Œç«‹å³å°è¯•localStorage
                if (!loadedFromDB) {
                    try {
                        let savedSettings = null;
                        let storageKey = null;

                        // ä¼˜å…ˆå°è¯•å¸¦çª—å£IDçš„è®¾ç½®ï¼ˆä¿æŒéš”ç¦»ï¼‰
                        if (windowId) {
                            storageKey = `offlineUISettings_${characterId}_${windowId}`;
                            savedSettings = localStorage.getItem(storageKey);
                        }

                        // å¦‚æœçª—å£éš”ç¦»è®¾ç½®ä¸å­˜åœ¨ï¼Œå°è¯•é€šç”¨æ ¼å¼ï¼ˆå…¼å®¹æ€§å›é€€ï¼‰
                        if (!savedSettings) {
                            storageKey = `offlineUISettings_${characterId}`;
                            savedSettings = localStorage.getItem(storageKey);
                        }

                        if (savedSettings) {
                            const parsedSettings = JSON.parse(savedSettings);
                            settingsRecord = { settings: parsedSettings };
                            console.log(`âœ… ä»localStorageåŠ è½½è®¾ç½®æˆåŠŸ (${storageKey})`);

                            // ğŸ”¥ã€å¢å¼ºã€‘å¼‚æ­¥è¿ç§»åˆ°æ•°æ®åº“ï¼Œä¼˜å…ˆä¿å­˜ä¸ºçª—å£éš”ç¦»æ ¼å¼
                            setTimeout(async () => {
                                try {
                                    const dbKey = windowId ? `${characterId}_${windowId}_ui_settings` : `${characterId}_ui_settings`;
                                    await db.offlineUISettings.put({
                                        id: dbKey,
                                        characterId: characterId,
                                        windowId: windowId || null,
                                        settings: parsedSettings,
                                        timestamp: Date.now()
                                    });
                                    console.log(`âœ… è®¾ç½®å·²å¼‚æ­¥è¿ç§»åˆ°æ•°æ®åº“ (${dbKey})`);
                                } catch (migrateError) {
                                    console.warn('å¼‚æ­¥è¿ç§»å¤±è´¥ï¼Œä½†ä¸å½±å“å½“å‰ä½¿ç”¨:', migrateError);
                                }
                            }, 100);
                        }
                    } catch (localStorageError) {
                        console.warn('localStorageåŠ è½½ä¹Ÿå¤±è´¥:', localStorageError);
                    }
                }

                if (settingsRecord && settingsRecord.settings) {
                    offlineUISettings = settingsRecord.settings;
                    console.log(`âœ… çº¿ä¸‹æ¨¡å¼ç•Œé¢è®¾ç½®åŠ è½½æˆåŠŸ`);
                } else {
                    console.log(`ğŸ“ æœªæ‰¾åˆ°è®¾ç½®ï¼Œä½¿ç”¨é»˜è®¤è®¾ç½®`);
                    // é»˜è®¤è®¾ç½®
                    offlineUISettings = {
                        myBubbleColor: '#007AFF',
                        aiBubbleColor: '#f0f0f0',
                        bubbleOpacity: 0.9,
                        fontSize: 15,
                        wallpaperData: '',
                        fontFamily: '',
                        fontUrl: '',
                        userNormalTextColor: '#ffffff',
                        userItalicTextColor: '#f0f0f0',
                        userBoldTextColor: '#ffffff',
                        aiNormalTextColor: '#000000',
                        aiItalicTextColor: '#666666',
                        aiBoldTextColor: '#333333',
                        showUserAvatar: true,
                        showAiAvatar: true,
                        avatarPosition: 'side',
                        bubbleWidth: 'default',
                        bubbleStyle: 'default',
                        customCSS: '',
                        savedColors: {
                            userNormal: [],
                            userItalic: [],
                            userBold: [],
                            aiNormal: [],
                            aiItalic: [],
                            aiBold: []
                        }
                    };
                }

                // æ›´æ–°ç•Œé¢
                updateOfflineUISettingsForm();
                updateOfflinePreview();

            } catch (error) {
                console.error('åŠ è½½çº¿ä¸‹æ¨¡å¼ç•Œé¢è®¾ç½®å®Œå…¨å¤±è´¥:', error);
                // ğŸ”¥ã€å¢å¼ºã€‘å³ä½¿å®Œå…¨å¤±è´¥ä¹Ÿè¦ç¡®ä¿æœ‰é»˜è®¤è®¾ç½®
                offlineUISettings = {
                    myBubbleColor: '#007AFF',
                    aiBubbleColor: '#f0f0f0',
                    bubbleOpacity: 0.9,
                    fontSize: 15,
                    wallpaperData: '',
                    fontFamily: '',
                    fontUrl: '',
                    userNormalTextColor: '#ffffff',
                    userItalicTextColor: '#f0f0f0',
                    userBoldTextColor: '#ffffff',
                    aiNormalTextColor: '#000000',
                    aiItalicTextColor: '#666666',
                    aiBoldTextColor: '#333333',
                    showUserAvatar: true,
                    showAiAvatar: true,
                    avatarPosition: 'side',
                    bubbleWidth: 'default',
                    bubbleStyle: 'default',
                    customCSS: '',
                    savedColors: {
                        userNormal: [],
                        userItalic: [],
                        userBold: [],
                        aiNormal: [],
                        aiItalic: [],
                        aiBold: []
                    }
                };
                updateOfflineUISettingsForm();
                updateOfflinePreview();
            }
        }

        // æ›´æ–°è®¾ç½®è¡¨å•
        function updateOfflineUISettingsForm() {
            document.getElementById('offline-my-bubble-color').value = offlineUISettings.myBubbleColor;
            document.getElementById('offline-ai-bubble-color').value = offlineUISettings.aiBubbleColor;
            document.getElementById('offline-bubble-opacity').value = offlineUISettings.bubbleOpacity;
            document.getElementById('offline-opacity-value').textContent = Math.round(offlineUISettings.bubbleOpacity * 100) + '%';

            // ğŸ”¥ã€æ–°å¢ã€‘è®¾ç½®å­—ä½“å¤§å°
            document.getElementById('offline-font-size').value = offlineUISettings.fontSize || 15;
            document.getElementById('offline-font-size-value').textContent = (offlineUISettings.fontSize || 15) + 'px';

            // è®¾ç½®å­—ä½“é€‰æ‹©
            document.getElementById('offline-font-select').value = offlineUISettings.fontFamily || '';
            if (offlineUISettings.fontFamily === 'custom') {
                document.getElementById('custom-font-input').style.display = 'block';
                document.getElementById('offline-font-url').value = offlineUISettings.fontUrl || '';
            } else {
                document.getElementById('custom-font-input').style.display = 'none';
            }

            // è®¾ç½®æ–‡å­—é¢œè‰²ï¼ˆç¡®ä¿æœ‰é»˜è®¤å€¼ï¼‰
            document.getElementById('offline-user-normal-text-color').value = offlineUISettings.userNormalTextColor || '#ffffff';
            document.getElementById('offline-user-italic-text-color').value = offlineUISettings.userItalicTextColor || '#f0f0f0';
            document.getElementById('offline-user-bold-text-color').value = offlineUISettings.userBoldTextColor || '#ffffff';
            document.getElementById('offline-ai-normal-text-color').value = offlineUISettings.aiNormalTextColor || '#000000';
            document.getElementById('offline-ai-italic-text-color').value = offlineUISettings.aiItalicTextColor || '#666666';
            document.getElementById('offline-ai-bold-text-color').value = offlineUISettings.aiBoldTextColor || '#333333';

            // è®¾ç½®å¤´åƒå’Œæ ·å¼é€‰é¡¹
            document.getElementById('offline-show-user-avatar').checked = offlineUISettings.showUserAvatar !== false;
            document.getElementById('offline-show-ai-avatar').checked = offlineUISettings.showAiAvatar !== false;

            // è®¾ç½®å•é€‰æŒ‰é’®
            const avatarPosition = offlineUISettings.avatarPosition || 'side';
            document.querySelector(`input[name="offline-avatar-position"][value="${avatarPosition}"]`).checked = true;

            const bubbleWidth = offlineUISettings.bubbleWidth || 'default';
            document.querySelector(`input[name="offline-bubble-width"][value="${bubbleWidth}"]`).checked = true;

            const bubbleStyle = offlineUISettings.bubbleStyle || 'default';
            document.querySelector(`input[name="offline-bubble-style"][value="${bubbleStyle}"]`).checked = true;

            // è®¾ç½®è‡ªå®šä¹‰CSS
            document.getElementById('offline-custom-css').value = offlineUISettings.customCSS || '';

            // æ›´æ–°é¢„å­˜é¢œè‰²
            updateSavedColorsDisplay();

            // ç›‘å¬é€æ˜åº¦æ»‘å—å˜åŒ–
            const opacitySlider = document.getElementById('offline-bubble-opacity');
            opacitySlider.oninput = function() {
                const value = Math.round(this.value * 100);
                document.getElementById('offline-opacity-value').textContent = value + '%';
                updateOfflinePreview();
            };

            // ğŸ”¥ã€æ–°å¢ã€‘ç›‘å¬å­—ä½“å¤§å°æ»‘å—å˜åŒ–
            const fontSizeSlider = document.getElementById('offline-font-size');
            fontSizeSlider.oninput = function() {
                const value = this.value;
                document.getElementById('offline-font-size-value').textContent = value + 'px';
                updateOfflinePreview();
            };

            // ç›‘å¬é¢œè‰²è¾“å…¥å˜åŒ–
            ['offline-my-bubble-color', 'offline-ai-bubble-color',
             'offline-user-normal-text-color', 'offline-user-italic-text-color', 'offline-user-bold-text-color',
             'offline-ai-normal-text-color', 'offline-ai-italic-text-color', 'offline-ai-bold-text-color'].forEach(id => {
                document.getElementById(id).oninput = updateOfflinePreview;
            });

            // ç›‘å¬å¤´åƒå’Œæ ·å¼è®¾ç½®å˜åŒ–
            document.getElementById('offline-show-user-avatar').onchange = updateOfflinePreview;
            document.getElementById('offline-show-ai-avatar').onchange = updateOfflinePreview;

            document.querySelectorAll('input[name="offline-avatar-position"]').forEach(radio => {
                radio.onchange = updateOfflinePreview;
            });

            document.querySelectorAll('input[name="offline-bubble-width"]').forEach(radio => {
                radio.onchange = updateOfflinePreview;
            });

            document.querySelectorAll('input[name="offline-bubble-style"]').forEach(radio => {
                radio.onchange = updateOfflinePreview;
            });

            // ç›‘å¬å•é€‰æŒ‰é’®å˜åŒ–ï¼Œæ§åˆ¶ç›¸å…³åŠŸèƒ½
            document.querySelectorAll('input[name="offline-avatar-position"]').forEach(radio => {
                radio.onchange = function() {
                    if (this.value === 'custom') {
                        showToast('è¯·åœ¨ä¸‹æ–¹CSSä»£ç åŒºåŸŸè‡ªå®šä¹‰å¤´åƒä½ç½®', 'info');
                    }
                };
            });

            document.querySelectorAll('input[name="offline-bubble-width"]').forEach(radio => {
                radio.onchange = function() {
                    if (this.value === 'custom') {
                        showToast('è¯·åœ¨ä¸‹æ–¹CSSä»£ç åŒºåŸŸè‡ªå®šä¹‰æ°”æ³¡å®½åº¦', 'info');
                    } else {
                        // åº”ç”¨é»˜è®¤80%å®½åº¦
                        applyDefaultBubbleWidth();
                    }
                };
            });

            document.querySelectorAll('input[name="offline-bubble-style"]').forEach(radio => {
                radio.onchange = function() {
                    if (this.value === 'custom') {
                        showToast('è¯·åœ¨ä¸‹æ–¹CSSä»£ç åŒºåŸŸè‡ªå®šä¹‰æ°”æ³¡æ ·å¼', 'info');
                    } else {
                        // åº”ç”¨é»˜è®¤æ ·å¼
                        applyDefaultBubbleStyle();
                    }
                };
            });
        }

        // åº”ç”¨é»˜è®¤æ°”æ³¡å®½åº¦
        function applyDefaultBubbleWidth() {
            // ç§»é™¤è‡ªå®šä¹‰å®½åº¦æ ·å¼ï¼Œæ¢å¤CSSè§„åˆ™æ§åˆ¶
            const existingStyle = document.getElementById('offline-custom-width-style');
            if (existingStyle) {
                existingStyle.remove();
            }

            showToast('å·²æ¢å¤é»˜è®¤æ°”æ³¡å®½åº¦ï¼ˆæ ¹æ®å¤´åƒæ˜¾ç¤ºçŠ¶æ€è‡ªåŠ¨è°ƒæ•´ï¼‰', 'success');
        }

        // åº”ç”¨é»˜è®¤æ°”æ³¡æ ·å¼
        function applyDefaultBubbleStyle() {
            // ç§»é™¤è‡ªå®šä¹‰æ ·å¼
            const existingStyle = document.getElementById('offline-custom-style-style');
            if (existingStyle) {
                existingStyle.remove();
            }

            // åº”ç”¨é»˜è®¤æ ·å¼ï¼ˆè¿™é‡Œå¯ä»¥æ ¹æ®éœ€è¦æ·»åŠ é»˜è®¤æ ·å¼ï¼‰
            showToast('å·²åº”ç”¨é»˜è®¤æ°”æ³¡æ ·å¼', 'success');
        }

        // æ›´æ–°é¢„å­˜é¢œè‰²æ˜¾ç¤º
        function updateSavedColorsDisplay() {
            const types = ['userNormal', 'userItalic', 'userBold', 'aiNormal', 'aiItalic', 'aiBold'];
            const typeMapping = {
                'userNormal': 'offline-user-normal',
                'userItalic': 'offline-user-italic',
                'userBold': 'offline-user-bold',
                'aiNormal': 'offline-ai-normal',
                'aiItalic': 'offline-ai-italic',
                'aiBold': 'offline-ai-bold'
            };

            types.forEach(type => {
                const container = document.getElementById(`${typeMapping[type]}-saved-colors`);
                if (container) {
                    container.innerHTML = '';

                    if (offlineUISettings.savedColors[type]) {
                        offlineUISettings.savedColors[type].forEach(color => {
                            const colorItem = document.createElement('div');
                            colorItem.className = 'saved-color-item';
                            colorItem.style.backgroundColor = color;
                            colorItem.title = color;
                            colorItem.onclick = () => {
                                document.getElementById(`${typeMapping[type]}-text-color`).value = color;
                                updateOfflinePreview();
                            };
                            container.appendChild(colorItem);
                        });
                    }
                }
            });
        }

        // æ›´æ–°é¢„è§ˆæ•ˆæœ
        function updateOfflinePreview() {
            const myBubbleColor = document.getElementById('offline-my-bubble-color').value;
            const aiBubbleColor = document.getElementById('offline-ai-bubble-color').value;
            const bubbleOpacity = document.getElementById('offline-bubble-opacity').value;

            const userNormalTextColor = document.getElementById('offline-user-normal-text-color').value;
            const userItalicTextColor = document.getElementById('offline-user-italic-text-color').value;
            const userBoldTextColor = document.getElementById('offline-user-bold-text-color').value;

            const aiNormalTextColor = document.getElementById('offline-ai-normal-text-color').value;
            const aiItalicTextColor = document.getElementById('offline-ai-italic-text-color').value;
            const aiBoldTextColor = document.getElementById('offline-ai-bold-text-color').value;

            // æ›´æ–°CSSå˜é‡
            const root = document.documentElement;
            root.style.setProperty('--offline-my-bubble-color', myBubbleColor);
            root.style.setProperty('--offline-ai-bubble-color', aiBubbleColor);
            root.style.setProperty('--offline-user-normal-text-color', userNormalTextColor);
            root.style.setProperty('--offline-user-italic-text-color', userItalicTextColor);
            root.style.setProperty('--offline-user-bold-text-color', userBoldTextColor);
            root.style.setProperty('--offline-ai-normal-text-color', aiNormalTextColor);
            root.style.setProperty('--offline-ai-italic-text-color', aiItalicTextColor);
            root.style.setProperty('--offline-ai-bold-text-color', aiBoldTextColor);

            // æ›´æ–°é¢„è§ˆåŒºåŸŸ
            const userBubble = document.querySelector('.offline-preview-message.user .offline-preview-content');
            const aiBubble = document.querySelector('.offline-preview-message.ai .offline-preview-content');

            if (userBubble) {
                // ä½¿ç”¨rgbaèƒŒæ™¯è‰²ï¼Œåªè®©èƒŒæ™¯é€æ˜ï¼Œæ–‡å­—ä¿æŒä¸é€æ˜
                const userBgColor = convertColorWithOpacity(myBubbleColor, bubbleOpacity);
                userBubble.style.backgroundColor = userBgColor;
                userBubble.style.opacity = 1; // ç¡®ä¿æ•´ä¸ªå…ƒç´ ä¸é€æ˜
                userBubble.style.color = userNormalTextColor;

                // æ›´æ–°ç”¨æˆ·æ¶ˆæ¯çš„æ–œä½“å’ŒåŠ ç²—æ–‡å­—é¢œè‰²
                const userItalicText = userBubble.querySelector('em');
                const userBoldText = userBubble.querySelector('strong');
                if (userItalicText) userItalicText.style.color = userItalicTextColor;
                if (userBoldText) userBoldText.style.color = userBoldTextColor;
            }

            if (aiBubble) {
                // ä½¿ç”¨rgbaèƒŒæ™¯è‰²ï¼Œåªè®©èƒŒæ™¯é€æ˜ï¼Œæ–‡å­—ä¿æŒä¸é€æ˜
                const aiBgColor = convertColorWithOpacity(aiBubbleColor, bubbleOpacity);
                aiBubble.style.backgroundColor = aiBgColor;
                aiBubble.style.opacity = 1; // ç¡®ä¿æ•´ä¸ªå…ƒç´ ä¸é€æ˜
                aiBubble.style.color = aiNormalTextColor;

                // æ›´æ–°AIæ¶ˆæ¯çš„æ–œä½“å’ŒåŠ ç²—æ–‡å­—é¢œè‰²
                const aiItalicText = aiBubble.querySelector('em');
                const aiBoldText = aiBubble.querySelector('strong');
                if (aiItalicText) aiItalicText.style.color = aiItalicTextColor;
                if (aiBoldText) aiBoldText.style.color = aiBoldTextColor;
            }

            // æ›´æ–°å¤´åƒæ˜¾ç¤º
            const showUserAvatar = document.getElementById('offline-show-user-avatar').checked;
            const showAiAvatar = document.getElementById('offline-show-ai-avatar').checked;
            const userAvatar = document.getElementById('preview-user-avatar');
            const aiAvatar = document.getElementById('preview-ai-avatar');

            // è·å–é¢„è§ˆæ¶ˆæ¯å®¹å™¨
            const allPreviewMessages = document.querySelectorAll('.offline-preview-message');

            // æ¸…é™¤æ‰€æœ‰ç›¸å…³çš„ç±»
            allPreviewMessages.forEach(container => {
                container.classList.remove('no-user-avatar', 'no-ai-avatar');
            });

            if (userAvatar) {
                userAvatar.style.display = showUserAvatar ? 'flex' : 'none';
            }
            if (aiAvatar) {
                aiAvatar.style.display = showAiAvatar ? 'flex' : 'none';
            }

            // ğŸ”¥ã€ä¿®æ­£ã€‘æ ¹æ®å¤´åƒæ˜¾ç¤ºçŠ¶æ€æ·»åŠ å¯¹åº”çš„ç±»
            allPreviewMessages.forEach(container => {
                if (!showUserAvatar) {
                    container.classList.add('no-user-avatar');
                }
                if (!showAiAvatar) {
                    container.classList.add('no-ai-avatar');
                }
            });

            // æ›´æ–°æ°”æ³¡å®½åº¦
            const bubbleWidth = document.querySelector('input[name="offline-bubble-width"]:checked').value;
            const avatarPosition = document.querySelector('input[name="offline-avatar-position"]:checked').value;
            const bubbleStyle = document.querySelector('input[name="offline-bubble-style"]:checked').value;

            const previewContents = document.querySelectorAll('.offline-preview-content');
            const previewMessages = document.querySelectorAll('.offline-preview-message');

            // åº”ç”¨æ°”æ³¡å®½åº¦
            previewContents.forEach(content => {
                if (bubbleWidth === 'default') {
                    // æ¸…é™¤å†…è”æ ·å¼ï¼Œè®©CSSè§„åˆ™è‡ªåŠ¨å¤„ç†å®½åº¦ï¼ˆæ ¹æ®å¤´åƒæ˜¾ç¤ºçŠ¶æ€ï¼‰
                    content.style.maxWidth = '';
                } else {
                    // è‡ªå®šä¹‰CSSæ§åˆ¶æ—¶ï¼Œå¦‚æœæœ‰CSSä»£ç åˆ™åº”ç”¨ï¼Œå¦åˆ™ä¿æŒå½“å‰æ ·å¼
                    const customCSS = document.getElementById('offline-custom-css').value.trim();
                    if (customCSS) {
                        // CSSä»£ç ä¼šé€šè¿‡é¢„è§ˆåŠŸèƒ½åº”ç”¨
                    }
                }
            });

            // åº”ç”¨å¤´åƒä½ç½®
            previewMessages.forEach(message => {
                if (avatarPosition === 'side') {
                    // æ¢å¤é»˜è®¤ä¾§è¾¹å¸ƒå±€
                    if (message.classList.contains('user')) {
                        message.style.flexDirection = 'row-reverse';
                    } else {
                        message.style.flexDirection = 'row';
                    }
                } else {
                    // è‡ªå®šä¹‰CSSæ§åˆ¶æ—¶ï¼Œç§»é™¤å†…è”æ ·å¼è®©CSSä»£ç ç”Ÿæ•ˆ
                    message.style.flexDirection = '';
                }
            });
        }

        // å¤„ç†å£çº¸ä¸Šä¼ 
        function handleOfflineWallpaperUpload(input) {
            const file = input.files[0];
            if (!file) return;

            // æ£€æŸ¥æ–‡ä»¶ç±»å‹
            if (!file.type.startsWith('image/')) {
                showToast('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶', 'warning');
                input.value = '';
                return;
            }

            // æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼ˆé™åˆ¶ä¸º5MBï¼‰
            if (file.size > 5 * 1024 * 1024) {
                showToast('å›¾ç‰‡æ–‡ä»¶ä¸èƒ½è¶…è¿‡5MB', 'warning');
                input.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const imageData = e.target.result;

                // é¢„è§ˆå£çº¸
                const previewArea = document.getElementById('offline-preview-area');
                previewArea.style.backgroundImage = `url(${imageData})`;
                previewArea.style.backgroundSize = 'cover';
                previewArea.style.backgroundPosition = 'center';

                // ä¿å­˜åˆ°è®¾ç½®ä¸­
                offlineUISettings.wallpaperData = imageData;

                showToast('å£çº¸å·²ä¸Šä¼ å¹¶é¢„è§ˆ', 'success');
            };
            reader.readAsDataURL(file);
        }

        // æ¸…é™¤å£çº¸
        function clearOfflineWallpaper() {
            document.getElementById('offline-wallpaper-file').value = '';
            const previewArea = document.getElementById('offline-preview-area');
            previewArea.style.backgroundImage = '';
            offlineUISettings.wallpaperData = '';
            showToast('å£çº¸å·²æ¸…é™¤', 'success');
        }

        // å¤„ç†å­—ä½“é€‰æ‹©å˜åŒ–
        function handleOfflineFontChange() {
            const fontSelect = document.getElementById('offline-font-select');
            const customInput = document.getElementById('custom-font-input');

            if (fontSelect.value === 'custom') {
                customInput.style.display = 'block';
            } else {
                customInput.style.display = 'none';
                // åº”ç”¨å†…ç½®å­—ä½“
                applyBuiltinFont(fontSelect.value);
            }
        }

        // åº”ç”¨å†…ç½®å­—ä½“
        function applyBuiltinFont(fontName) {
            // æ¸…é™¤è‡ªå®šä¹‰å­—ä½“æ ·å¼ï¼Œæ¢å¤é»˜è®¤å­—ä½“
            const existingStyle = document.getElementById('offline-custom-font-style');
            if (existingStyle) {
                existingStyle.remove();
            }

            if (fontName) {
                showToast(`å·²æ¢å¤ç³»ç»Ÿé»˜è®¤å­—ä½“`, 'success');
            }
        }

        // é¢„è§ˆè‡ªå®šä¹‰CSS
        function previewOfflineCSS() {
            const cssCode = document.getElementById('offline-custom-css').value.trim();

            // ç§»é™¤ä¹‹å‰çš„é¢„è§ˆæ ·å¼
            const existingStyle = document.getElementById('offline-custom-css-preview');
            if (existingStyle) {
                existingStyle.remove();
            }

            if (!cssCode) {
                showToast('è¯·è¾“å…¥CSSä»£ç ', 'warning');
                return;
            }

            try {
                // åˆ›å»ºæ ·å¼å…ƒç´ 
                const style = document.createElement('style');
                style.id = 'offline-custom-css-preview';

                // ä¸ºCSSä»£ç æ·»åŠ ä½œç”¨åŸŸï¼Œåªå½±å“é¢„è§ˆåŒºåŸŸ
                const scopedCSS = cssCode.replace(/\.offline-/g, '.offline-preview-area .offline-');
                style.textContent = scopedCSS;

                document.head.appendChild(style);
                showToast('CSSé¢„è§ˆå·²åº”ç”¨', 'success');

            } catch (error) {
                console.error('CSSé¢„è§ˆå¤±è´¥:', error);
                showToast('CSSä»£ç æœ‰è¯¯ï¼Œè¯·æ£€æŸ¥è¯­æ³•', 'error');
            }
        }

        // æ¸…é™¤è‡ªå®šä¹‰CSS
        function clearOfflineCSS() {
            document.getElementById('offline-custom-css').value = '';

            // ç§»é™¤é¢„è§ˆæ ·å¼
            const existingStyle = document.getElementById('offline-custom-css-preview');
            if (existingStyle) {
                existingStyle.remove();
            }

            showToast('CSSä»£ç å·²æ¸…é™¤', 'success');
        }

        // é¢„è§ˆå­—ä½“
        function previewOfflineFont() {
            const url = document.getElementById('offline-font-url').value.trim();
            if (!url) {
                showToast('è¯·è¾“å…¥å­—ä½“URL', 'warning');
                return;
            }

            // æ¸…é™¤ä¹‹å‰çš„å­—ä½“æ ·å¼
            const existingStyle = document.getElementById('offline-custom-font-style');
            if (existingStyle) {
                existingStyle.remove();
            }
            const existingLink = document.getElementById('offline-custom-font-link');
            if (existingLink) {
                existingLink.remove();
            }

            // åˆ¤æ–­æ˜¯CSSé“¾æ¥è¿˜æ˜¯ç›´æ¥å­—ä½“æ–‡ä»¶
            if (url.includes('fonts.googleapis.com') || url.includes('fonts.google.com') || url.endsWith('.css') || url.includes('fontsapi') || url.includes('css')) {
                // Google Fontsæˆ–å…¶ä»–CSSé“¾æ¥
                console.log('ğŸ¨ å¼€å§‹åŠ è½½å­—ä½“CSS:', url);
                const link = document.createElement('link');
                link.id = 'offline-custom-font-link';
                link.rel = 'stylesheet';
                link.href = url;
                link.crossOrigin = 'anonymous'; // ğŸ”¥ã€æ–°å¢ã€‘æ·»åŠ è·¨åŸŸæ”¯æŒ
                link.onload = function() {
                    // ğŸ”¥ã€ä¿®å¤ã€‘å°è¯•ä»CSSä¸­æå–å­—ä½“åç§°ï¼Œæˆ–ä½¿ç”¨é€šç”¨åç§°
                    let fontFamily = extractFontFamilyFromGoogleFonts(url) || 'CustomFont';
                    console.log('ğŸ¨ å­—ä½“CSSåŠ è½½æˆåŠŸï¼Œæå–çš„å­—ä½“åç§°:', fontFamily);
                    console.log('ğŸ¨ å­—ä½“URL:', url);

                    // ğŸ”¥ã€æ–°å¢ã€‘å°è¯•ä»åŠ è½½çš„CSSä¸­æå–çœŸæ­£çš„å­—ä½“åç§°
                    try {
                        const sheets = document.styleSheets;
                        for (let i = sheets.length - 1; i >= 0; i--) {
                            const sheet = sheets[i];
                            if (sheet.href === url) {
                                try {
                                    const rules = sheet.cssRules || sheet.rules;
                                    for (let j = 0; j < rules.length; j++) {
                                        const rule = rules[j];
                                        if (rule.type === CSSRule.FONT_FACE_RULE && rule.style.fontFamily) {
                                            fontFamily = rule.style.fontFamily.replace(/['"]/g, '');
                                            console.log('ğŸ¨ ä»CSSä¸­æå–åˆ°çœŸå®å­—ä½“åç§°:', fontFamily);
                                            break;
                                        }
                                    }
                                } catch (e) {
                                    console.log('ğŸ¨ æ— æ³•è¯»å–CSSè§„åˆ™ï¼Œä½¿ç”¨æå–çš„åç§°');
                                }
                                break;
                            }
                        }
                    } catch (e) {
                        console.log('ğŸ¨ CSSè§£æå¤±è´¥ï¼Œä½¿ç”¨æå–çš„åç§°');
                    }

                    const style = document.createElement('style');
                    style.id = 'offline-custom-font-style';
                    style.textContent = `
                        .offline-preview-content,
                        #offline-mode-overlay .offline-message-content {
                            font-family: '${fontFamily}', sans-serif !important;
                        }
                    `;
                    document.head.appendChild(style);
                    console.log('ğŸ¨ å­—ä½“æ ·å¼å·²åº”ç”¨åˆ°é¡µé¢ï¼Œæœ€ç»ˆå­—ä½“åç§°:', fontFamily);

                    // ğŸ”¥ã€æ–°å¢ã€‘ä¿å­˜çœŸå®çš„å­—ä½“åç§°åˆ°å…¨å±€å˜é‡ï¼Œä¾›ä¿å­˜è®¾ç½®æ—¶ä½¿ç”¨
                    window.previewedFontName = fontFamily;

                    // ğŸ”¥ã€æ–°å¢ã€‘éªŒè¯å­—ä½“æ˜¯å¦çœŸçš„è¢«åº”ç”¨
                    setTimeout(() => {
                        const testElement = document.querySelector('#offline-mode-overlay .offline-message-content');
                        if (testElement) {
                            const computedStyle = window.getComputedStyle(testElement);
                            console.log('ğŸ¨ å®é™…åº”ç”¨çš„å­—ä½“:', computedStyle.fontFamily);
                        }
                    }, 1000);

                    showToast(`å­—ä½“CSSå·²åŠ è½½ï¼Œå­—ä½“åç§°: ${fontFamily}`, 'success');
                };
                link.onerror = function() {
                    console.error('ğŸ¨ å­—ä½“CSSåŠ è½½å¤±è´¥:', url);
                    showToast('å­—ä½“CSSåŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥URL', 'error');
                };
                document.head.appendChild(link);
            } else {
                // ç›´æ¥å­—ä½“æ–‡ä»¶
                const fontName = 'OfflineCustomFont';
                const style = document.createElement('style');
                style.id = 'offline-custom-font-style';
                style.textContent = `
                    @font-face {
                        font-family: '${fontName}';
                        src: url('${url}');
                    }
                    .offline-preview-content,
                    #offline-mode-overlay .offline-message-content {
                        font-family: '${fontName}', sans-serif !important;
                    }
                `;
                document.head.appendChild(style);
                showToast('å­—ä½“æ–‡ä»¶é¢„è§ˆå·²åº”ç”¨', 'success');
            }
        }

        // ä»Google Fonts URLä¸­æå–å­—ä½“åç§°
        function extractFontFamilyFromGoogleFonts(url) {
            try {
                // Google Fonts: åŒ¹é… family= å‚æ•°
                const match = url.match(/family=([^&:]+)/);
                if (match) {
                    let fontName = decodeURIComponent(match[1]);
                    // æ›¿æ¢ + ä¸ºç©ºæ ¼ï¼Œç§»é™¤æƒé‡ä¿¡æ¯ï¼ˆå¦‚ :300,400,700ï¼‰
                    fontName = fontName.replace(/\+/g, ' ').replace(/:.*$/, '');
                    return fontName;
                }

                // å¦‚æœæ˜¯æ–°ç‰ˆGoogle Fonts APIæ ¼å¼ï¼Œå°è¯•å…¶ä»–åŒ¹é…æ–¹å¼
                const match2 = url.match(/family=([^&]+)/);
                if (match2) {
                    let fontName = decodeURIComponent(match2[1]);
                    fontName = fontName.replace(/\+/g, ' ').split(':')[0];
                    return fontName;
                }

                // ğŸ”¥ã€æ–°å¢ã€‘å…¶ä»–å­—ä½“æœåŠ¡ï¼šå°è¯•ä»URLè·¯å¾„ä¸­æå–
                const pathMatch = url.match(/\/([^\/]+)\.css/);
                if (pathMatch) {
                    return pathMatch[1].replace(/[-_]/g, ' ');
                }

                // ğŸ”¥ã€æ–°å¢ã€‘å°è¯•ä»URLä¸­æå–æ•°å­—IDæˆ–åç§°
                const idMatch = url.match(/\/(\d+)\//);
                if (idMatch) {
                    return `CustomFont-${idMatch[1]}`;
                }

                // ğŸ”¥ã€æ–°å¢ã€‘ä»åŸŸåæå–æœåŠ¡åç§°
                const domainMatch = url.match(/\/\/([^.]+)/);
                if (domainMatch) {
                    return `${domainMatch[1]}-Font`;
                }
            } catch (e) {
                console.warn('æ— æ³•æå–å­—ä½“åç§°:', e);
            }
            return 'CustomFont'; // é»˜è®¤å­—ä½“åç§°
        }

        // æ¸…é™¤å­—ä½“
        function clearOfflineFont() {
            document.getElementById('offline-font-url').value = '';
            const existingStyle = document.getElementById('offline-custom-font-style');
            if (existingStyle) {
                existingStyle.remove();
            }
            showToast('å­—ä½“å·²æ¸…é™¤', 'success');
        }

        // ä¿å­˜å½“å‰é¢œè‰²åˆ°é¢„å­˜
        function saveCurrentOfflineColors() {
            const userNormalColor = document.getElementById('offline-user-normal-text-color').value;
            const userItalicColor = document.getElementById('offline-user-italic-text-color').value;
            const userBoldColor = document.getElementById('offline-user-bold-text-color').value;
            const aiNormalColor = document.getElementById('offline-ai-normal-text-color').value;
            const aiItalicColor = document.getElementById('offline-ai-italic-text-color').value;
            const aiBoldColor = document.getElementById('offline-ai-bold-text-color').value;

            // æ·»åŠ åˆ°é¢„å­˜é¢œè‰²ï¼ˆé¿å…é‡å¤ï¼‰
            const colorTypes = [
                { type: 'userNormal', color: userNormalColor },
                { type: 'userItalic', color: userItalicColor },
                { type: 'userBold', color: userBoldColor },
                { type: 'aiNormal', color: aiNormalColor },
                { type: 'aiItalic', color: aiItalicColor },
                { type: 'aiBold', color: aiBoldColor }
            ];

            colorTypes.forEach(({ type, color }) => {
                // ç¡®ä¿savedColors[type]å­˜åœ¨
                if (!offlineUISettings.savedColors[type]) {
                    offlineUISettings.savedColors[type] = [];
                }

                if (!offlineUISettings.savedColors[type].includes(color)) {
                    offlineUISettings.savedColors[type].push(color);
                }

                // é™åˆ¶é¢„å­˜é¢œè‰²æ•°é‡ï¼ˆæœ€å¤š10ä¸ªï¼‰
                if (offlineUISettings.savedColors[type].length > 10) {
                    offlineUISettings.savedColors[type] = offlineUISettings.savedColors[type].slice(-10);
                }
            });

            updateSavedColorsDisplay();
            showToast('é¢œè‰²å·²ä¿å­˜åˆ°é¢„å­˜', 'success');
        }

        // é‡ç½®ä¸ºé»˜è®¤é¢œè‰²
        function resetOfflineColors() {
            document.getElementById('offline-my-bubble-color').value = '#007AFF';
            document.getElementById('offline-ai-bubble-color').value = '#f0f0f0';
            document.getElementById('offline-bubble-opacity').value = 0.9;
            document.getElementById('offline-opacity-value').textContent = '90%'; // æ›´æ–°é€æ˜åº¦æ˜¾ç¤º
            document.getElementById('offline-font-size').value = 15; // ğŸ”¥ã€æ–°å¢ã€‘é‡ç½®å­—ä½“å¤§å°
            document.getElementById('offline-font-size-value').textContent = '15px'; // æ›´æ–°å­—ä½“å¤§å°æ˜¾ç¤º
            document.getElementById('offline-user-normal-text-color').value = '#ffffff';
            document.getElementById('offline-user-italic-text-color').value = '#f0f0f0';
            document.getElementById('offline-user-bold-text-color').value = '#ffffff';
            document.getElementById('offline-ai-normal-text-color').value = '#000000';
            document.getElementById('offline-ai-italic-text-color').value = '#666666';
            document.getElementById('offline-ai-bold-text-color').value = '#333333';

            updateOfflinePreview();
            showToast('é¢œè‰²å·²é‡ç½®ä¸ºé»˜è®¤', 'success');
        }

        // ä¿å­˜çº¿ä¸‹æ¨¡å¼ç•Œé¢è®¾ç½®
        async function saveOfflineUISettings() {
            const characterId = currentChatCharacter.id;

            try {
                // æ”¶é›†è®¾ç½®æ•°æ®
                offlineUISettings = {
                    myBubbleColor: document.getElementById('offline-my-bubble-color').value,
                    aiBubbleColor: document.getElementById('offline-ai-bubble-color').value,
                    bubbleOpacity: parseFloat(document.getElementById('offline-bubble-opacity').value),
                    fontSize: parseInt(document.getElementById('offline-font-size').value), // ğŸ”¥ã€æ–°å¢ã€‘ä¿å­˜å­—ä½“å¤§å°
                    wallpaperData: offlineUISettings.wallpaperData || '',
                    fontFamily: document.getElementById('offline-font-select').value,
                    fontUrl: document.getElementById('offline-font-url').value.trim(),
                    realFontName: window.previewedFontName || '', // ğŸ”¥ã€æ–°å¢ã€‘ä¿å­˜é¢„è§ˆæ—¶ç¡®å®šçš„çœŸå®å­—ä½“åç§°
                    userNormalTextColor: document.getElementById('offline-user-normal-text-color').value,
                    userItalicTextColor: document.getElementById('offline-user-italic-text-color').value,
                    userBoldTextColor: document.getElementById('offline-user-bold-text-color').value,
                    aiNormalTextColor: document.getElementById('offline-ai-normal-text-color').value,
                    aiItalicTextColor: document.getElementById('offline-ai-italic-text-color').value,
                    aiBoldTextColor: document.getElementById('offline-ai-bold-text-color').value,
                    showUserAvatar: document.getElementById('offline-show-user-avatar').checked,
                    showAiAvatar: document.getElementById('offline-show-ai-avatar').checked,
                    avatarPosition: document.querySelector('input[name="offline-avatar-position"]:checked').value,
                    bubbleWidth: document.querySelector('input[name="offline-bubble-width"]:checked').value,
                    bubbleStyle: document.querySelector('input[name="offline-bubble-style"]:checked').value,
                    customCSS: document.getElementById('offline-custom-css').value.trim(),
                    savedColors: offlineUISettings.savedColors || {
                        userNormal: [], userItalic: [], userBold: [],
                        aiNormal: [], aiItalic: [], aiBold: []
                    }
                };

                // ğŸ”¥ã€ä¿®æ”¹ã€‘ä¿å­˜åˆ°Dexieæ•°æ®åº“ï¼ˆæ¯ä¸ªè§’è‰²ç‹¬ç«‹ï¼‰
                await saveOfflineUISettingsToDB();

                // åº”ç”¨è®¾ç½®åˆ°çº¿ä¸‹æ¨¡å¼ç•Œé¢
                applyOfflineUISettings();

                closeOfflineUISettings();
                showToast('ç•Œé¢è®¾ç½®å·²ä¿å­˜', 'success');

            } catch (error) {
                console.error('ä¿å­˜çº¿ä¸‹æ¨¡å¼ç•Œé¢è®¾ç½®å¤±è´¥:', error);
                showToast('ä¿å­˜ç•Œé¢è®¾ç½®å¤±è´¥', 'error');
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘ä¿å­˜è®¾ç½®åˆ°Dexieæ•°æ®åº“
        async function saveOfflineUISettingsToDB() {
            if (!currentChatCharacter || !offlineUISettings) return;

            const characterId = currentChatCharacter.id;

            // ğŸ”¥ã€å¢å¼ºã€‘åŒé‡ä¿å­˜ç­–ç•¥ï¼Œä¼˜å…ˆä¿æŒçª—å£éš”ç¦»
            let dbSaveSuccess = false;
            let localStorageSaveSuccess = false;

            // é¦–å…ˆå°è¯•ä¿å­˜åˆ°æ•°æ®åº“ï¼ˆä¼˜å…ˆçª—å£éš”ç¦»æ ¼å¼ï¼‰
            try {
                const dbKey = windowId ? `${characterId}_${windowId}_ui_settings` : `${characterId}_ui_settings`;
                await db.offlineUISettings.put({
                    id: dbKey,
                    characterId: characterId,
                    windowId: windowId || null,
                    settings: offlineUISettings,
                    timestamp: Date.now()
                });
                dbSaveSuccess = true;
                console.log(`âœ… çº¿ä¸‹æ¨¡å¼ç•Œé¢è®¾ç½®å·²ä¿å­˜åˆ°æ•°æ®åº“ (${dbKey})`);
            } catch (dbError) {
                console.warn('âŒ ä¿å­˜åˆ°æ•°æ®åº“å¤±è´¥:', dbError);
            }

            // åŒæ—¶ä¿å­˜åˆ°localStorageä½œä¸ºå¤‡ä»½ï¼ˆä¹Ÿä¼˜å…ˆçª—å£éš”ç¦»æ ¼å¼ï¼‰
            try {
                const storageKey = windowId ? `offlineUISettings_${characterId}_${windowId}` : `offlineUISettings_${characterId}`;
                localStorage.setItem(storageKey, JSON.stringify(offlineUISettings));
                localStorageSaveSuccess = true;
                console.log(`âœ… çº¿ä¸‹æ¨¡å¼ç•Œé¢è®¾ç½®å·²ä¿å­˜åˆ°localStorage (${storageKey})`);
            } catch (localStorageError) {
                console.warn('âŒ ä¿å­˜åˆ°localStorageå¤±è´¥:', localStorageError);
            }

            // å¦‚æœä¸¤ç§æ–¹å¼éƒ½å¤±è´¥ï¼ŒæŠ›å‡ºé”™è¯¯
            if (!dbSaveSuccess && !localStorageSaveSuccess) {
                throw new Error('æ‰€æœ‰ä¿å­˜æ–¹å¼éƒ½å¤±è´¥äº†');
            }
        }

        // åº”ç”¨çº¿ä¸‹æ¨¡å¼ç•Œé¢è®¾ç½®
        function applyOfflineUISettings() {
            if (!offlineUISettings || !currentChatCharacter) return;

            const offlineOverlay = document.getElementById('offline-mode-overlay');
            if (!offlineOverlay) return;

            // ğŸ”¥ã€ä¿®å¤ã€‘è·å–èŠå¤©æ¶ˆæ¯å®¹å™¨å¹¶é‡ç½®èƒŒæ™¯
            const chatMessages = offlineOverlay.querySelector('.offline-chat-messages');
            if (chatMessages) {
                // å…ˆæ¸…é™¤æ—§èƒŒæ™¯
                chatMessages.style.backgroundImage = '';
                chatMessages.style.backgroundColor = ''; // åŒæ ·é‡ç½®èƒŒæ™¯è‰²
            }

            // ç¡®ä¿è®¾ç½®æœ‰é»˜è®¤å€¼
            const myBubbleColor = offlineUISettings.myBubbleColor || '#007AFF';
            const aiBubbleColor = offlineUISettings.aiBubbleColor || '#f0f0f0';
            const bubbleOpacity = offlineUISettings.bubbleOpacity !== undefined ? offlineUISettings.bubbleOpacity : 0.9;
            const userNormalTextColor = offlineUISettings.userNormalTextColor || '#ffffff';
            const userItalicTextColor = offlineUISettings.userItalicTextColor || '#f0f0f0';
            const userBoldTextColor = offlineUISettings.userBoldTextColor || '#ffffff';
            const aiNormalTextColor = offlineUISettings.aiNormalTextColor || '#000000';
            const aiItalicTextColor = offlineUISettings.aiItalicTextColor || '#666666';
            const aiBoldTextColor = offlineUISettings.aiBoldTextColor || '#333333';

            // åº”ç”¨æ°”æ³¡é¢œè‰²å’Œé€æ˜åº¦
            const userBubbles = offlineOverlay.querySelectorAll('.offline-message.user .offline-message-content');
            const aiBubbles = offlineOverlay.querySelectorAll('.offline-message.ai .offline-message-content');

            userBubbles.forEach(bubble => {
                // ä½¿ç”¨rgbaèƒŒæ™¯è‰²ï¼Œåªè®©èƒŒæ™¯é€æ˜ï¼Œæ–‡å­—ä¿æŒä¸é€æ˜
                const userBgColor = convertColorWithOpacity(myBubbleColor, bubbleOpacity);
                bubble.style.backgroundColor = userBgColor;
                bubble.style.opacity = 1; // ç¡®ä¿æ•´ä¸ªå…ƒç´ ä¸é€æ˜
                bubble.style.color = userNormalTextColor;

                // åº”ç”¨ç”¨æˆ·æ¶ˆæ¯æ–‡å­—é¢œè‰²
                const italicTexts = bubble.querySelectorAll('em');
                const boldTexts = bubble.querySelectorAll('strong');
                italicTexts.forEach(text => text.style.color = userItalicTextColor);
                boldTexts.forEach(text => text.style.color = userBoldTextColor);
            });

            aiBubbles.forEach(bubble => {
                // ä½¿ç”¨rgbaèƒŒæ™¯è‰²ï¼Œåªè®©èƒŒæ™¯é€æ˜ï¼Œæ–‡å­—ä¿æŒä¸é€æ˜
                const aiBgColor = convertColorWithOpacity(aiBubbleColor, bubbleOpacity);
                bubble.style.backgroundColor = aiBgColor;
                bubble.style.opacity = 1; // ç¡®ä¿æ•´ä¸ªå…ƒç´ ä¸é€æ˜
                bubble.style.color = aiNormalTextColor;

                // åº”ç”¨AIæ¶ˆæ¯æ–‡å­—é¢œè‰²
                const italicTexts = bubble.querySelectorAll('em');
                const boldTexts = bubble.querySelectorAll('strong');
                italicTexts.forEach(text => text.style.color = aiItalicTextColor);
                boldTexts.forEach(text => text.style.color = aiBoldTextColor);
            });

            // åº”ç”¨èƒŒæ™¯å£çº¸
            if (chatMessages && offlineUISettings.wallpaperData) {
                chatMessages.style.backgroundImage = `url(${offlineUISettings.wallpaperData})`;
                chatMessages.style.backgroundSize = 'cover';
                chatMessages.style.backgroundPosition = 'center';
                chatMessages.style.backgroundAttachment = 'fixed';
            }

            // åº”ç”¨å­—ä½“è®¾ç½®
            const fontName = `OfflineFont_${currentChatCharacter.id}`;
            const existingStyle = document.getElementById(`offline-font-${currentChatCharacter.id}`);
            if (existingStyle) {
                existingStyle.remove();
            }
            const existingLink = document.getElementById(`offline-font-link-${currentChatCharacter.id}`);
            if (existingLink) {
                existingLink.remove();
            }

            if (offlineUISettings.fontFamily === 'custom' && offlineUISettings.fontUrl) {
                const url = offlineUISettings.fontUrl;

                // åˆ¤æ–­æ˜¯CSSé“¾æ¥è¿˜æ˜¯ç›´æ¥å­—ä½“æ–‡ä»¶
                if (url.includes('fonts.googleapis.com') || url.includes('fonts.google.com') || url.endsWith('.css') || url.includes('fontsapi') || url.includes('css')) {
                    // Google Fontsæˆ–å…¶ä»–CSSé“¾æ¥
                    const link = document.createElement('link');
                    link.id = `offline-font-link-${currentChatCharacter.id}`;
                    link.rel = 'stylesheet';
                    link.href = url;
                    link.onload = function() {
                        // ğŸ”¥ã€ä¿®å¤ã€‘ä¼˜å…ˆä½¿ç”¨ä¿å­˜çš„çœŸå®å­—ä½“åç§°
                        let fontFamily = offlineUISettings.realFontName || extractFontFamilyFromGoogleFonts(url) || 'CustomFont';

                        // ğŸ”¥ã€æ–°å¢ã€‘å¦‚æœæ²¡æœ‰ä¿å­˜çš„çœŸå®å­—ä½“åç§°ï¼Œå°è¯•ä»CSSä¸­æå–
                        if (!offlineUISettings.realFontName) {
                            try {
                                const sheets = document.styleSheets;
                                for (let i = sheets.length - 1; i >= 0; i--) {
                                    const sheet = sheets[i];
                                    if (sheet.href === url) {
                                        try {
                                            const rules = sheet.cssRules || sheet.rules;
                                            for (let j = 0; j < rules.length; j++) {
                                                const rule = rules[j];
                                                if (rule.type === CSSRule.FONT_FACE_RULE && rule.style.fontFamily) {
                                                    fontFamily = rule.style.fontFamily.replace(/['"]/g, '');
                                                    console.log('ğŸ¨ åº”ç”¨è®¾ç½®æ—¶ä»CSSä¸­æå–åˆ°çœŸå®å­—ä½“åç§°:', fontFamily);
                                                    break;
                                                }
                                            }
                                        } catch (e) {
                                            console.log('ğŸ¨ åº”ç”¨è®¾ç½®æ—¶æ— æ³•è¯»å–CSSè§„åˆ™ï¼Œä½¿ç”¨æå–çš„åç§°');
                                        }
                                        break;
                                    }
                                }
                            } catch (e) {
                                console.log('ğŸ¨ åº”ç”¨è®¾ç½®æ—¶CSSè§£æå¤±è´¥ï¼Œä½¿ç”¨æå–çš„åç§°');
                            }
                        } else {
                            console.log('ğŸ¨ ä½¿ç”¨ä¿å­˜çš„çœŸå®å­—ä½“åç§°:', fontFamily);
                        }

                        const style = document.createElement('style');
                        style.id = `offline-font-${currentChatCharacter.id}`;
                        style.textContent = `
                            #offline-mode-overlay .offline-message-content {
                                font-family: '${fontFamily}', sans-serif !important;
                            }
                        `;
                        document.head.appendChild(style);
                        console.log('âœ… çº¿ä¸‹æ¨¡å¼å­—ä½“å·²åº”ç”¨:', fontFamily);
                    };
                    document.head.appendChild(link);
                } else {
                    // ç›´æ¥å­—ä½“æ–‡ä»¶
                    const style = document.createElement('style');
                    style.id = `offline-font-${currentChatCharacter.id}`;
                    style.textContent = `
                        @font-face {
                            font-family: '${fontName}';
                            src: url('${url}');
                        }
                        #offline-mode-overlay .offline-message-content {
                            font-family: '${fontName}', sans-serif !important;
                        }
                    `;
                    document.head.appendChild(style);
                }
            }

            // åº”ç”¨å¤´åƒæ˜¾ç¤ºè®¾ç½®
            const allMessages = offlineOverlay.querySelectorAll('.offline-message');

            allMessages.forEach(messageContainer => {
                const userAvatar = messageContainer.querySelector('.offline-avatar.user-avatar');
                const aiAvatar = messageContainer.querySelector('.offline-avatar.ai-avatar');

                // æ¸…é™¤æ‰€æœ‰ç›¸å…³çš„ç±»
                messageContainer.classList.remove('no-user-avatar', 'no-ai-avatar');

                // å¤„ç†ç”¨æˆ·å¤´åƒæ˜¾ç¤º
                if (userAvatar) {
                    userAvatar.style.display = offlineUISettings.showUserAvatar ? 'flex' : 'none';
                }

                // å¤„ç†AIå¤´åƒæ˜¾ç¤º
                if (aiAvatar) {
                    aiAvatar.style.display = offlineUISettings.showAiAvatar ? 'flex' : 'none';
                }

                // ğŸ”¥ã€ä¿®æ­£ã€‘æ ¹æ®å¤´åƒæ˜¾ç¤ºçŠ¶æ€æ·»åŠ å¯¹åº”çš„ç±»
                if (!offlineUISettings.showUserAvatar) {
                    messageContainer.classList.add('no-user-avatar');
                }
                if (!offlineUISettings.showAiAvatar) {
                    messageContainer.classList.add('no-ai-avatar');
                }
            });

            // åº”ç”¨æ°”æ³¡å®½åº¦è®¾ç½®
            if (offlineUISettings.bubbleWidth === 'default') {
                // æ¸…é™¤å¯èƒ½å­˜åœ¨çš„è‡ªå®šä¹‰å®½åº¦æ ·å¼ï¼Œè®©CSSè§„åˆ™è‡ªåŠ¨å¤„ç†å®½åº¦
                const widthStyleId = `offline-width-${currentChatCharacter.id}`;
                const existingWidthStyle = document.getElementById(widthStyleId);
                if (existingWidthStyle) {
                    existingWidthStyle.remove();
                }
                // ä¸å†å¼ºåˆ¶è®¾ç½®80%ï¼Œè®©CSSä¸­çš„å¤´åƒæ˜¾ç¤º/éšè—è§„åˆ™æ¥æ§åˆ¶å®½åº¦
            }

            // åº”ç”¨å¤´åƒä½ç½®è®¾ç½®
            if (offlineUISettings.avatarPosition === 'side') {
                // åº”ç”¨é»˜è®¤ä¾§è¾¹ä½ç½®
                const avatarStyleId = `offline-avatar-${currentChatCharacter.id}`;
                const existingAvatarStyle = document.getElementById(avatarStyleId);
                if (existingAvatarStyle) {
                    existingAvatarStyle.remove();
                }

                const avatarStyle = document.createElement('style');
                avatarStyle.id = avatarStyleId;
                avatarStyle.textContent = `
                    #offline-mode-overlay .offline-message.user {
                        flex-direction: row; /* ğŸ”¥ã€ä¿®æ­£ã€‘ç”¨æˆ·ï¼šå¤´åƒå·¦ï¼Œæ°”æ³¡å³ */
                    }
                    #offline-mode-overlay .offline-message.ai {
                        flex-direction: row-reverse; /* ğŸ”¥ã€ä¿®æ­£ã€‘AIï¼šå¤´åƒå³ï¼Œæ°”æ³¡å·¦ */
                    }
                    #offline-mode-overlay .offline-avatar {
                        position: relative;
                        margin: 0;
                    }
                `;
                document.head.appendChild(avatarStyle);
            }

            // åº”ç”¨è‡ªå®šä¹‰CSSï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰
            if (offlineUISettings.customCSS &&
                (offlineUISettings.avatarPosition === 'custom' ||
                 offlineUISettings.bubbleWidth === 'custom' ||
                 offlineUISettings.bubbleStyle === 'custom')) {

                const customStyleId = `offline-custom-${currentChatCharacter.id}`;
                const existingCustomStyle = document.getElementById(customStyleId);
                if (existingCustomStyle) {
                    existingCustomStyle.remove();
                }

                const customStyle = document.createElement('style');
                customStyle.id = customStyleId;

                // ä¸ºCSSä»£ç æ·»åŠ ä½œç”¨åŸŸï¼Œåªå½±å“å½“å‰çº¿ä¸‹æ¨¡å¼
                const scopedCSS = offlineUISettings.customCSS.replace(/\.offline-/g, '#offline-mode-overlay .offline-');
                customStyle.textContent = scopedCSS;

                document.head.appendChild(customStyle);
            }

            // ğŸ”¥ã€æ–°å¢ã€‘åº”ç”¨å­—ä½“å¤§å°è®¾ç½®
            if (offlineUISettings.fontSize !== undefined) {
                const messageContents = offlineOverlay.querySelectorAll('.offline-message-content');
                messageContents.forEach(content => {
                    content.style.fontSize = `${offlineUISettings.fontSize}px`;
                });
            }
        }

        // é‡ç½®çº¿ä¸‹æ¨¡å¼ç•Œé¢è®¾ç½®
        async function resetOfflineUISettings() {
            if (confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰ç•Œé¢è®¾ç½®ä¸ºé»˜è®¤å€¼å—ï¼Ÿ')) {
                // é‡ç½®ä¸ºé»˜è®¤è®¾ç½®
                offlineUISettings = {
                    myBubbleColor: '#007AFF',
                    aiBubbleColor: '#f0f0f0',
                    bubbleOpacity: 0.9,
                    fontSize: 15, // ğŸ”¥ã€æ–°å¢ã€‘é‡ç½®å­—ä½“å¤§å°ä¸ºé»˜è®¤å€¼
                    wallpaperData: '',
                    fontFamily: '',
                    fontUrl: '',
                    userNormalTextColor: '#ffffff',
                    userItalicTextColor: '#f0f0f0',
                    userBoldTextColor: '#ffffff',
                    aiNormalTextColor: '#000000',
                    aiItalicTextColor: '#666666',
                    aiBoldTextColor: '#333333',
                    showUserAvatar: true,
                    showAiAvatar: true,
                    avatarPosition: 'side',
                    bubbleWidth: 'default',
                    bubbleStyle: 'default',
                    customCSS: '',
                    savedColors: {
                        userNormal: [], userItalic: [], userBold: [],
                        aiNormal: [], aiItalic: [], aiBold: []
                    }
                };

                // æ¸…é™¤æ–‡ä»¶è¾“å…¥
                document.getElementById('offline-wallpaper-file').value = '';

                // ğŸ”¥ã€æ–°å¢ã€‘æ¸…é™¤æ•°æ®åº“ä¸­çš„è®¾ç½®
                if (currentChatCharacter) {
                    try {
                        await db.offlineUISettings.delete(`${currentChatCharacter.id}_ui_settings`);
                        console.log('âœ… æ•°æ®åº“ä¸­çš„è®¾ç½®å·²æ¸…é™¤');
                    } catch (error) {
                        console.error('æ¸…é™¤æ•°æ®åº“è®¾ç½®å¤±è´¥:', error);
                    }
                }

                updateOfflineUISettingsForm();
                updateOfflinePreview();
                showToast('ç•Œé¢è®¾ç½®å·²é‡ç½®', 'success');
            }
        }

        // åœ¨è¿›å…¥çº¿ä¸‹æ¨¡å¼æ—¶åŠ è½½å¹¶åº”ç”¨ç•Œé¢è®¾ç½®
        async function loadAndApplyOfflineUISettings() {
            if (!currentChatCharacter) return;

            const characterId = currentChatCharacter.id;

            try {
                // ğŸ”¥ã€ä¿®å¤ã€‘ä¿æŒçª—å£éš”ç¦»çš„åŒæ—¶å¢å¼ºæ‰‹æœºæµè§ˆå™¨å…¼å®¹æ€§
                let settingsLoaded = false;

                // é¦–å…ˆå°è¯•ä»localStorageåŠ è½½ï¼ˆæ›´ç¨³å®šï¼‰ï¼Œä¼˜å…ˆçª—å£éš”ç¦»æ ¼å¼
                try {
                    let savedSettings = null;
                    let storageKey = null;

                    // ä¼˜å…ˆå°è¯•å¸¦çª—å£IDçš„è®¾ç½®ï¼ˆä¿æŒéš”ç¦»ï¼‰
                    if (windowId) {
                        storageKey = `offlineUISettings_${characterId}_${windowId}`;
                        savedSettings = localStorage.getItem(storageKey);
                    }

                    // å¦‚æœçª—å£éš”ç¦»è®¾ç½®ä¸å­˜åœ¨ï¼Œå°è¯•é€šç”¨æ ¼å¼ï¼ˆå…¼å®¹æ€§å›é€€ï¼‰
                    if (!savedSettings) {
                        storageKey = `offlineUISettings_${characterId}`;
                        savedSettings = localStorage.getItem(storageKey);
                    }

                    if (savedSettings) {
                        offlineUISettings = JSON.parse(savedSettings);
                        settingsLoaded = true;
                        console.log(`âœ… ä»localStorageåŠ è½½çº¿ä¸‹æ¨¡å¼ç•Œé¢è®¾ç½®æˆåŠŸ (${storageKey})`);
                    }
                } catch (localStorageError) {
                    console.warn('ä»localStorageåŠ è½½å¤±è´¥:', localStorageError);
                }

                // å¦‚æœlocalStorageåŠ è½½å¤±è´¥ï¼Œå°è¯•ä»æ•°æ®åº“åŠ è½½
                if (!settingsLoaded) {
                    try {
                        let settingsRecord = null;

                        // ä¼˜å…ˆå°è¯•å¸¦çª—å£IDçš„è®¾ç½®ï¼ˆä¿æŒéš”ç¦»ï¼‰
                        if (windowId) {
                            settingsRecord = await db.offlineUISettings.get(`${characterId}_${windowId}_ui_settings`);
                        }

                        // å¦‚æœçª—å£éš”ç¦»è®¾ç½®ä¸å­˜åœ¨ï¼Œå°è¯•é€šç”¨æ ¼å¼ï¼ˆå…¼å®¹æ€§å›é€€ï¼‰
                        if (!settingsRecord) {
                            settingsRecord = await db.offlineUISettings.get(`${characterId}_ui_settings`);
                        }

                        if (settingsRecord && settingsRecord.settings) {
                            offlineUISettings = settingsRecord.settings;
                            settingsLoaded = true;
                            console.log(`âœ… ä»æ•°æ®åº“åŠ è½½çº¿ä¸‹æ¨¡å¼ç•Œé¢è®¾ç½®æˆåŠŸ`);
                        }
                    } catch (dbError) {
                        console.warn('ä»æ•°æ®åº“åŠ è½½å¤±è´¥:', dbError);
                    }
                }

                // å¦‚æœæˆåŠŸåŠ è½½è®¾ç½®ï¼Œåº”ç”¨å®ƒä»¬
                if (settingsLoaded) {
                    applyOfflineUISettings();
                    console.log(`âœ… çº¿ä¸‹æ¨¡å¼ç•Œé¢è®¾ç½®å·²åº”ç”¨`);
                }
            } catch (error) {
                console.error('åŠ è½½çº¿ä¸‹æ¨¡å¼ç•Œé¢è®¾ç½®å¤±è´¥:', error);
            }
        }

        // ğŸ”¥ã€æ–°å¢ã€‘é€‰æ‹©å‡½æ•°
        function selectAvatarPosition(value, element) {
            // ç§»é™¤æ‰€æœ‰é€‰ä¸­çŠ¶æ€
            const siblings = element.parentNode.querySelectorAll('.radio-option-button');
            siblings.forEach(btn => btn.classList.remove('selected'));

            // æ·»åŠ é€‰ä¸­çŠ¶æ€
            element.classList.add('selected');

            // æ›´æ–°éšè—çš„radioæŒ‰é’®
            const radios = element.parentNode.querySelectorAll('input[name="offline-avatar-position"]');
            radios.forEach(radio => {
                radio.checked = radio.value === value;
            });
        }

        function selectBubbleWidth(value, element) {
            // ç§»é™¤æ‰€æœ‰é€‰ä¸­çŠ¶æ€
            const siblings = element.parentNode.querySelectorAll('.radio-option-button');
            siblings.forEach(btn => btn.classList.remove('selected'));

            // æ·»åŠ é€‰ä¸­çŠ¶æ€
            element.classList.add('selected');

            // æ›´æ–°éšè—çš„radioæŒ‰é’®
            const radios = element.parentNode.querySelectorAll('input[name="offline-bubble-width"]');
            radios.forEach(radio => {
                radio.checked = radio.value === value;
            });
        }

        function selectBubbleStyle(value, element) {
            // ç§»é™¤æ‰€æœ‰é€‰ä¸­çŠ¶æ€
            const siblings = element.parentNode.querySelectorAll('.radio-option-button');
            siblings.forEach(btn => btn.classList.remove('selected'));

            // æ·»åŠ é€‰ä¸­çŠ¶æ€
            element.classList.add('selected');

            // æ›´æ–°éšè—çš„radioæŒ‰é’®
            const radios = element.parentNode.querySelectorAll('input[name="offline-bubble-style"]');
            radios.forEach(radio => {
                radio.checked = radio.value === value;
            });
        }

document.addEventListener('visibilitychange', function() {
    const phoneScreen = document.getElementById('phone-screen');
    if (!phoneScreen) return;

    if (document.visibilityState === 'visible') {
        // é¡µé¢å˜ä¸ºå¯è§çŠ¶æ€
        console.log("âœ… é¡µé¢æ¢å¤å¯è§ï¼Œæ­£åœ¨æ¢å¤åŠ¨ç”»å’Œå®šæ—¶å™¨...");
        
        // 1. æ¢å¤æ‰€æœ‰ CSS åŠ¨ç”»
        phoneScreen.style.animationPlayState = 'running';
        const animatedElements = document.querySelectorAll('[style*="animation"]');
        animatedElements.forEach(el => el.style.animationPlayState = 'running');

        // 2. å¼ºåˆ¶æµè§ˆå™¨è¿›è¡Œä¸€æ¬¡é‡ç»˜ï¼Œæ¸…é™¤æ®‹ç•™çš„çº¿æ¡
        // è¿™æ˜¯ä¸€ä¸ªå¸¸ç”¨çš„å°æŠ€å·§ï¼Œé€šè¿‡å¿«é€Ÿæ”¹å˜ä¸€ä¸ªä¸å½±å“å¸ƒå±€çš„å±æ€§æ¥è§¦å‘é‡ç»˜
        phoneScreen.style.opacity = '0.99';
        setTimeout(() => {
            phoneScreen.style.opacity = '1';
        }, 16); // 16ms çº¦ç­‰äºä¸€å¸§çš„æ—¶é—´

        // 3. å¦‚æœæ‚¨æœ‰é€šè¿‡ setInterval å¯åŠ¨çš„å¤æ‚JSåŠ¨ç”»ï¼Œå¯ä»¥åœ¨è¿™é‡Œé‡æ–°å¯åŠ¨å®ƒä»¬
        // ä¾‹å¦‚ï¼šé‡æ–°å¯åŠ¨æ—¶é’Ÿï¼ˆè™½ç„¶æ—¶é’Ÿé€šå¸¸å½±å“ä¸å¤§ï¼Œä½†ä½œä¸ºç¤ºä¾‹ï¼‰
        if (typeof updateTime === 'function') {
           // å¦‚æœä¹‹å‰æœ‰æ¸…é™¤å®šæ—¶å™¨ï¼Œåœ¨è¿™é‡Œé‡æ–°è®¾ç½®
           // setInterval(updateTime, 1000);
        }

    } else {
        // é¡µé¢å˜ä¸ºéšè—çŠ¶æ€
        console.log("ğŸ’¤ é¡µé¢å·²éšè—ï¼Œæš‚åœåŠ¨ç”»ä»¥èŠ‚çœèµ„æº...");

        // 1. æš‚åœæ‰€æœ‰ CSS åŠ¨ç”»
        phoneScreen.style.animationPlayState = 'paused';
        const animatedElements = document.querySelectorAll('[style*="animation"]');
        animatedElements.forEach(el => el.style.animationPlayState = 'paused');

        // 2. å¦‚æœæœ‰å¤æ‚çš„JSåŠ¨ç”»å®šæ—¶å™¨ï¼Œå¯ä»¥åœ¨è¿™é‡Œæ¸…é™¤å®ƒä»¬
        // clearInterval(yourAnimationTimer);
    }
});

// æ·»åŠ éŸ³ä¹æ’­æ”¾å™¨æ–‡ä»¶é€‰æ‹©äº‹ä»¶ç›‘å¬å™¨
document.addEventListener('DOMContentLoaded', function() {
    // æœ¬åœ°éŸ³ä¹æ–‡ä»¶é€‰æ‹©
    const localMusicInput = document.getElementById('local-music-input');
    if (localMusicInput) {
        localMusicInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const urlInput = document.getElementById('song-url-input');
                const titleInput = document.getElementById('song-title-input');

                urlInput.placeholder = `å·²é€‰æ‹©: ${file.name}`;
                urlInput.style.color = '#007AFF';
                urlInput.value = ''; // æ¸…ç©ºURLè¾“å…¥

                // è‡ªåŠ¨å¡«å……æ­Œæ›²æ ‡é¢˜
                if (!titleInput.value.trim()) {
                    titleInput.value = file.name.replace(/\.[^/.]+$/, "");
                }
            }
        });
    }

    // æ­Œè¯æ–‡ä»¶é€‰æ‹©
    const lyricsFileInput = document.getElementById('lyrics-file-input');
    if (lyricsFileInput) {
        lyricsFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const lyricsInput = document.getElementById('song-lyrics-input');
                const fileName = file.name.toLowerCase();
                let fileType = 'æ­Œè¯æ–‡ä»¶';

                if (fileName.endsWith('.lrc')) {
                    fileType = 'LRCæ­Œè¯';
                } else if (fileName.endsWith('.bin')) {
                    fileType = 'binæ­Œè¯';
                } else if (fileName.endsWith('.txt')) {
                    fileType = 'TXTæ­Œè¯';
                } else {
                    // å¯¹äºå…¶ä»–æ–‡ä»¶ç±»å‹ï¼Œç»™å‡ºæç¤ºä½†ä»ç„¶å…è®¸é€‰æ‹©
                    fileType = 'æ–‡ä»¶';
                    console.log('é€‰æ‹©çš„æ–‡ä»¶å¯èƒ½ä¸æ˜¯æ ‡å‡†æ­Œè¯æ ¼å¼ï¼Œä½†ä»ä¼šå°è¯•å¤„ç†:', file.name);
                }

                lyricsInput.placeholder = `å·²é€‰æ‹©${fileType}: ${file.name}`;
                lyricsInput.style.color = '#007AFF';
                lyricsInput.value = ''; // æ¸…ç©ºæ‰‹åŠ¨è¾“å…¥çš„æ­Œè¯
            }
        });
    }
});
    </script>
</body>
</html>